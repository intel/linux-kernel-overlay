From 749d43047fcec4edeff7ac888e732305dab791a3 Mon Sep 17 00:00:00 2001
From: zouxiaoh <xiaohong.zou@intel.com>
Date: Wed, 9 Nov 2022 17:43:00 +0800
Subject: [PATCH 20/21] media: i2c: fix allyes build issue

Change Description:
fix build issue.

Signed-off-by: Chen Meng J <meng.j.chen@intel.com>
Signed-off-by: zouxiaoh <xiaohong.zou@intel.com>
---
 drivers/media/i2c/ar0234.c                    |  21 +--
 drivers/media/i2c/d4xx.c                      | 148 ++++++------------
 .../media/platform/intel/ipu6-acpi-common.c   |   1 +
 .../media/platform/intel/ipu6-acpi-pdata.c    |  11 +-
 drivers/media/platform/intel/ipu6-acpi.c      |   4 +-
 include/media/ipu-acpi.h                      |   7 +-
 include/media/ipu-isys.h                      |   4 +
 7 files changed, 73 insertions(+), 123 deletions(-)

diff --git a/drivers/media/i2c/ar0234.c b/drivers/media/i2c/ar0234.c
index 611451bcb87c..c95f05936cb4 100644
--- a/drivers/media/i2c/ar0234.c
+++ b/drivers/media/i2c/ar0234.c
@@ -1371,6 +1371,8 @@ struct ar0234 {
 	bool streaming;
 
 	struct ar0234_platform_data *platform_data;
+
+	s64 sub_stream;
 };
 
 static int ar0234_read_reg(struct ar0234 *ar0234, u16 reg, u16 len, u32 *val)
@@ -1782,7 +1784,6 @@ static int ar0234_init_controls(struct ar0234 *ar0234)
 	struct v4l2_ctrl_handler *ctrl_hdlr;
 	s64 exposure_max;
 	s64 hblank;
-	struct v4l2_ctrl_config cfg = { 0 };
 	int ret;
 
 	ctrl_hdlr = &ar0234->ctrl_handler;
@@ -1858,11 +1859,7 @@ static int ar0234_init_controls(struct ar0234 *ar0234)
 	ar0234->hflip = v4l2_ctrl_new_std(ctrl_hdlr, &ar0234_ctrl_ops,
 					  V4L2_CID_HFLIP, 0, 1, 1, 0);
 
-	ar0234_q_sub_stream.qmenu_int = devm_kzalloc(&client->dev, sizeof(s64), GFP_KERNEL);
-	if (!ar0234_q_sub_stream.qmenu_int) {
-		dev_dbg(&client->dev, "failed alloc mem for query sub stream.\n");
-		return -ENOMEM;
-	}
+	ar0234_q_sub_stream.qmenu_int = &ar0234->sub_stream;
 	ar0234->query_sub_stream = v4l2_ctrl_new_custom(ctrl_hdlr, &ar0234_q_sub_stream, NULL);
 	if (ctrl_hdlr->error) {
 		dev_dbg(&client->dev, "new query sub stream ctrl, error = %d.\n",
@@ -2041,7 +2038,6 @@ static int ar0234_set_format(struct v4l2_subdev *sd,
 	s32 vblank_def;
 	s64 hblank;
 	int i;
-	s64 *sub_stream;
 
 	for (i = 0; i < ARRAY_SIZE(supported_modes); i++) {
 		if (supported_modes[i].width != fmt->format.width
@@ -2092,12 +2088,11 @@ static int ar0234_set_format(struct v4l2_subdev *sd,
 
 		__v4l2_ctrl_s_ctrl(ar0234->frame_interval, 1000 / mode->fps);
 
-		sub_stream = ar0234->query_sub_stream->qmenu_int;
-		set_sub_stream_fmt(sub_stream, mode->code);
-		set_sub_stream_h(sub_stream, mode->height);
-		set_sub_stream_w(sub_stream, mode->width);
-		set_sub_stream_dt(sub_stream, mbus_code_to_mipi(mode->code));
-		set_sub_stream_vc_id(sub_stream, 0);
+		set_sub_stream_fmt(&ar0234->sub_stream, mode->code);
+		set_sub_stream_h(&ar0234->sub_stream, mode->height);
+		set_sub_stream_w(&ar0234->sub_stream, mode->width);
+		set_sub_stream_dt(&ar0234->sub_stream, mbus_code_to_mipi(mode->code));
+		set_sub_stream_vc_id(&ar0234->sub_stream, 0);
 	}
 
 	mutex_unlock(&ar0234->mutex);
diff --git a/drivers/media/i2c/d4xx.c b/drivers/media/i2c/d4xx.c
index c423c5342878..2d6c18e768ea 100644
--- a/drivers/media/i2c/d4xx.c
+++ b/drivers/media/i2c/d4xx.c
@@ -1230,6 +1230,7 @@ static int ds5_sensor_set_fmt(struct v4l2_subdev *sd,
 	return __ds5_sensor_set_fmt(state, sensor, v4l2_state, fmt);
 }
 
+#if 0
 static int ds5_configure(struct ds5 *state)
 {
 	struct ds5_sensor *sensor;
@@ -1415,6 +1416,7 @@ static int ds5_configure(struct ds5 *state)
 
 	return 0;
 }
+#endif
 
 static int ds5_configure_depth(struct ds5 *state)
 {
@@ -2443,7 +2445,6 @@ static int ds5_ctrl_init(struct ds5 *state)
 	struct v4l2_subdev *sd = &state->mux.sd.subdev;
 	int ret;
 
-	dev_info(NULL, "%s(), line %d\n", __func__, __LINE__);
 	ret = v4l2_ctrl_handler_init(hdl, DS5_N_CONTROLS);
 	if (ret < 0) {
 		v4l2_err(sd, "cannot init ctrl handler (%d)\n", ret);
@@ -2494,7 +2495,6 @@ static int ds5_ctrl_init(struct ds5 *state)
 
 	ctrls->query_sub_stream = v4l2_ctrl_new_custom(hdl, &d4xx_controls_q_sub_stream, NULL);
 	ctrls->set_sub_stream = v4l2_ctrl_new_custom(hdl, &d4xx_controls_s_sub_stream, NULL);
-	dev_info(NULL, "%s(), line %d\n", __func__, __LINE__);
 	if (hdl->error) {
 		v4l2_err(sd, "error creating controls (%d)\n", hdl->error);
 		ret = hdl->error;
@@ -2506,7 +2506,6 @@ static int ds5_ctrl_init(struct ds5 *state)
 
 	state->mux.sd.subdev.ctrl_handler = hdl;
 
-	dev_info(NULL, "%s(), line %d\n", __func__, __LINE__);
 	return 0;
 }
 
@@ -2518,10 +2517,8 @@ static int ds5_sensor_init(struct i2c_client *c, struct ds5 *state,
 	struct media_entity *entity = &sensor->sd.entity;
 	struct media_pad *pad = &sensor->pad;
 	dev_t *dev_num = &state->client->dev.devt;
-
-	dev_info(sd->dev, "%s(): %p %s %p %p", __func__, c, c->name, state, state->client);
-
 	struct d4xx_pdata *dpdata = c->dev.platform_data;
+
 	v4l2_i2c_subdev_init(sd, c, ops);
 	sd->owner = THIS_MODULE;
 	sd->internal_ops = &ds5_sensor_internal_ops;
@@ -2546,14 +2543,12 @@ static int ds5_sensor_register(struct ds5 *state, struct ds5_sensor *sensor)
 	// FIXME: is async needed?
 	ret = v4l2_device_register_subdev(state->mux.sd.subdev.v4l2_dev, sd);
 	if (ret < 0) {
-		dev_err(sd->dev, "%s(): %d: %d\n", __func__, __LINE__, ret);
 		return ret;
 	}
 
 	ret = media_create_pad_link(entity, 0, &state->mux.sd.subdev.entity, sensor->mux_pad,
 				       MEDIA_LNK_FL_IMMUTABLE | MEDIA_LNK_FL_ENABLED);
 	if (ret < 0) {
-		dev_err(sd->dev, "%s(): %d: %d\n", __func__, __LINE__, ret);
 		goto e_sd;
 	}
 
@@ -2803,7 +2798,6 @@ static int ds5_mux_set_fmt(struct v4l2_subdev *sd,
 		struct v4l2_subdev_state *v4l2_state,
 		struct v4l2_subdev_format *fmt)
 {
-	struct ds5 *state = container_of(sd, struct ds5, mux.sd.subdev);
 	struct v4l2_mbus_framefmt *ffmt;
 	u32 pad = fmt->pad;
 	int ret = 0;
@@ -2932,19 +2926,18 @@ static int ds5_mux_s_frame_interval(struct v4l2_subdev *sd,
 static int ds5_mux_s_stream(struct v4l2_subdev *sd, int on)
 {
 	struct ds5 *state = container_of(sd, struct ds5, mux.sd.subdev);
-	u16 streaming_depth, streaming_rgb, streaming_y8, rate, depth_status, rgb_status, y8_status, s_stream;
+	u16 streaming_depth, streaming_rgb, streaming_y8, rate, depth_status, rgb_status, y8_status;
 	int ret = 0;
 	u16 streaming, status;
 	u16 config_status_base, stream_status_base, stream_id;
 	unsigned int i = 0;
+	u16 err_status;
+	u16 tmp;
 
 	dev_info(&state->client->dev, "%s(): %s on = %d\n", __func__, state->mux.last_set->sd.name, on);
 
 	state->mux.last_set->streaming = on;
 
-	//if (on)
-	//	ret = ds5_configure(state);
-
 	// TODO: remove, workaround for FW crash in start
 	msleep_range(100);
 
@@ -2968,7 +2961,7 @@ static int ds5_mux_s_stream(struct v4l2_subdev *sd, int on)
 
 		return 0;
 	}
-#if 1 /* depth */
+
 	msleep_range(100);
 	if (on)
 		ret = ds5_configure_depth(state);
@@ -2992,9 +2985,7 @@ static int ds5_mux_s_stream(struct v4l2_subdev *sd, int on)
 			dev_err(&state->client->dev,
 				"start depth streaming failed, exit on timeout\n");
 		}
-#endif
 
-#if 1 /* RGB */
 	msleep_range(100);
 	if (on)
 		ret = ds5_configure_rgb(state);
@@ -3019,8 +3010,6 @@ static int ds5_mux_s_stream(struct v4l2_subdev *sd, int on)
 			dev_err(&state->client->dev,
 				"start RGB streaming failed, exit on timeout\n");
 		}
-#endif
-	//ds5_write(state, 0x1000,  on ? 0x201 : 0x102);
 
 	/* IR */
 	msleep_range(100);
@@ -3049,11 +3038,9 @@ static int ds5_mux_s_stream(struct v4l2_subdev *sd, int on)
 				"start imu streaming failed, exit on timeout\n");
 		}
 
-	u16 err_status;
 	// TODO: this read seems to cause FW crash, need to debug
 	//ds5_read(state, 0x402, &rate);
 	rate = 0;
-	u16 tmp;
 
 	ds5_read(state, 0x401a, &err_status);
 	ds5_read(state, 0x1004, &streaming_depth);
@@ -3080,19 +3067,18 @@ static int ds5_mux_s_stream(struct v4l2_subdev *sd, int on)
 
 static int ds5_mux_s_stream_vc(struct ds5 *state, u16 vc_id, u16 on)
 {
-	u16 streaming_depth, streaming_rgb, streaming_y8, rate, depth_status, rgb_status, y8_status, s_stream;
+	u16 streaming_depth, streaming_rgb, streaming_y8, rate, depth_status, rgb_status, y8_status;
 	int ret = 0;
 	u16 streaming, status;
 	u16 config_status_base, stream_status_base, stream_id;
 	unsigned int i = 0;
+	u16 err_status;
+	u16 tmp;
 
 	dev_info(&state->client->dev, "%s(): %s on = %d\n", __func__, state->mux.last_set->sd.name, on);
 
 	state->mux.last_set->streaming = on;
 
-	//if (on)
-	//	ret = ds5_configure(state);
-
 	// TODO: remove, workaround for FW crash in start
 	msleep_range(100);
 
@@ -3102,28 +3088,23 @@ static int ds5_mux_s_stream_vc(struct ds5 *state, u16 vc_id, u16 on)
 		ds5_read(state, 0x4802, &rgb_status);
 
 		if ((vc_id == DS5_MUX_PAD_DEPTH_A - 1) || (vc_id == DS5_MUX_PAD_DEPTH_B - 1)) {
-		msleep_range(100);
-		ret = ds5_write(state, DS5_START_STOP_STREAM,
-				DS5_STREAM_STOP | DS5_STREAM_DEPTH);
-}
+			msleep_range(100);
+			ret = ds5_write(state, DS5_START_STOP_STREAM,
+					DS5_STREAM_STOP | DS5_STREAM_DEPTH);
+		}
 		if ((vc_id == DS5_MUX_PAD_RGB_A - 1) || (vc_id == DS5_MUX_PAD_RGB_B - 1)) {
-		msleep_range(100);
-		ret = ds5_write(state, DS5_START_STOP_STREAM,
-				DS5_STREAM_STOP | DS5_STREAM_RGB);
-}
-/*
-		msleep_range(100);
-		ret = ds5_write(state, DS5_START_STOP_STREAM,
-				DS5_STREAM_STOP | DS5_STREAM_IMU);
-*/
+			msleep_range(100);
+			ret = ds5_write(state, DS5_START_STOP_STREAM,
+					DS5_STREAM_STOP | DS5_STREAM_RGB);
+		}
 		if ((vc_id == DS5_MUX_PAD_MOTION_T_A - 1) || (vc_id == DS5_MUX_PAD_MOTION_T_B - 1)) {
-		msleep_range(100);
-		ret = ds5_write(state, DS5_START_STOP_STREAM,
-				DS5_STREAM_STOP | DS5_STREAM_IR);
-}
+			msleep_range(100);
+			ret = ds5_write(state, DS5_START_STOP_STREAM,
+					DS5_STREAM_STOP | DS5_STREAM_IR);
+		}
 		return 0;
 	}
-#if 1 /* depth */
+
 	msleep_range(100);
 	if ((on) && ((vc_id == DS5_MUX_PAD_DEPTH_A - 1) || (vc_id == DS5_MUX_PAD_DEPTH_B - 1))) {
 		ret = ds5_configure_depth(state);
@@ -3148,9 +3129,7 @@ static int ds5_mux_s_stream_vc(struct ds5 *state, u16 vc_id, u16 on)
 				"start depth streaming failed, exit on timeout\n");
 		}
 	}
-#endif
 
-#if 1 /* RGB */
 	if ((on) && ((vc_id == DS5_MUX_PAD_RGB_A - 1) || (vc_id == DS5_MUX_PAD_RGB_B - 1))) {
 	msleep_range(100);
 	if (on)
@@ -3174,11 +3153,9 @@ static int ds5_mux_s_stream_vc(struct ds5 *state, u16 vc_id, u16 on)
 
 		if (DS5_START_MAX_COUNT == i) {
 			dev_err(&state->client->dev,
-				"start RGB streaming failed, exit on timeout\n");
+					"start RGB streaming failed, exit on timeout\n");
 		}
-}
-#endif
-	//ds5_write(state, 0x1000,  on ? 0x201 : 0x102);
+	}
 
 	if ((on) && ((vc_id == DS5_MUX_PAD_MOTION_T_A - 1) || (vc_id == DS5_MUX_PAD_MOTION_T_B - 1))) {
 	msleep_range(100);
@@ -3206,14 +3183,12 @@ static int ds5_mux_s_stream_vc(struct ds5 *state, u16 vc_id, u16 on)
 			dev_err(&state->client->dev,
 				"start imu streaming failed, exit on timeout\n");
 		}
-}
+	}
 
-	    u16 err_status;
 	// TODO: this read seems to cause FW crash, need to debug
 	//ds5_read(state, 0x402, &rate);
 	rate = 0;
-    u16 tmp;
-    ds5_read(state, 0x401a, &err_status);
+	ds5_read(state, 0x401a, &err_status);
 
 	ds5_read(state, 0x1004, &streaming_depth);
 	ds5_read(state, 0x1008, &streaming_rgb);
@@ -3221,14 +3196,14 @@ static int ds5_mux_s_stream_vc(struct ds5 *state, u16 vc_id, u16 on)
 	ds5_read(state, 0x4800, &depth_status);
 	ds5_read(state, 0x4802, &rgb_status);
 	ds5_read(state, 0x4808, &y8_status);
-    ds5_read(state, 0x4002, &tmp);
-    ds5_read(state, 0x4022, &tmp);
-    ds5_read(state, 0x4082, &tmp);
-
-    //ds5_write(state, 0x4002,  0x100 );
-   //ds5_write(state, 0x4022,  0x0 );
-    //ds5_read(state, 0x4002, &tmp);
-    //ds5_read(state, 0x4022, &tmp);
+	ds5_read(state, 0x4002, &tmp);
+	ds5_read(state, 0x4022, &tmp);
+	ds5_read(state, 0x4082, &tmp);
+
+	//ds5_write(state, 0x4002,  0x100 );
+	//ds5_write(state, 0x4022,  0x0 );
+	//ds5_read(state, 0x4002, &tmp);
+	//ds5_read(state, 0x4022, &tmp);
 	msleep_range(DS5_START_POLL_TIME*50);
 
 	dev_info(&state->client->dev, "%s(): streaming %x-%x-%x depth status 0x%04x, rgb status 0x%04x, rate %u\n", __func__,
@@ -3326,23 +3301,21 @@ static const struct v4l2_subdev_ops ds5_mux_subdev_ops = {
 	.video = &ds5_mux_video_ops,
 };
 
+#if 0 /* function not used */
 static int ds5_des_register(struct ds5 *state, struct ds5_des *des)
 {
 	struct v4l2_subdev *sd = &des->sd;
-	struct media_entity *entity = &des->sd.entity;
 	int ret;
 
 	// FIXME: is async needed?
 	ret = v4l2_device_register_subdev(state->mux.sd.subdev.v4l2_dev, sd);
 	if (ret < 0) {
-		dev_err(sd->dev, "%s(): %d: %d\n", __func__, __LINE__, ret);
 		return ret;
 	}
 
 	//ret = media_create_pad_link(entity, 1, &state->mux.sd.subdev.entity, des->mux_pad,
 	//			       MEDIA_LNK_FL_IMMUTABLE | MEDIA_LNK_FL_ENABLED);
 	//if (ret < 0) {
-	//	dev_err(sd->dev, "%s(): %d: %d\n", __func__, __LINE__, ret);
 	//	goto e_sd;
        // }
 
@@ -3355,6 +3328,7 @@ static int ds5_des_register(struct ds5 *state, struct ds5_des *des)
 
 	return ret;
 }
+#endif
 
 static int ds5_mux_registered(struct v4l2_subdev *sd)
 {
@@ -3415,12 +3389,9 @@ static int ds5_mux_register(struct i2c_client *c, struct ds5 *state)
 
 static int ds5_hw_init(struct i2c_client *c, struct ds5 *state)
 {
-	struct v4l2_subdev *sd = &state->mux.sd.subdev;
 	u16 mipi_status, n_lanes, phy, drate_min, drate_max;
 	int ret;
 
-	dev_info(NULL, "%s(), line %d\n", __func__, __LINE__);
-
 	ret = ds5_read(state, DS5_MIPI_SUPPORT_LINES, &n_lanes);
 	if (!ret)
 		ret = ds5_read(state, DS5_MIPI_SUPPORT_PHY, &phy);
@@ -3431,12 +3402,6 @@ static int ds5_hw_init(struct i2c_client *c, struct ds5 *state)
 	if (!ret)
 		ret = ds5_read(state, DS5_MIPI_DATARATE_MAX, &drate_max);
 
-	if (!ret)
-		dev_info(sd->dev, "%s(): %d: %u lanes, phy %x, data rate %u-%u\n",
-			 __func__, __LINE__, n_lanes, phy, drate_min, drate_max);
-
-	dev_info(NULL, "%s(), line %d, set 2 lanes\n", __func__, __LINE__);
-	// mjchen: 4 or 2 ?
 	n_lanes = 2;
 
 	ret = ds5_write(state, DS5_MIPI_LANE_NUMS, n_lanes - 1);
@@ -3445,13 +3410,10 @@ static int ds5_hw_init(struct i2c_client *c, struct ds5 *state)
 
 	ret = ds5_read(state, DS5_MIPI_CONF_STATUS, &mipi_status);
 
-	dev_info(sd->dev, "%s(): %d status %x\n", __func__, __LINE__,
-		 mipi_status);
-//	dev_info(sd->dev, "%s(): %d phandle %x node %s status %x\n", __func__, __LINE__,
-//		 c->dev.of_node->phandle, c->dev.of_node->full_name, mipi_status);
-
 	return ret;
 }
+
+#if 0 /* not used function */
 static int ds5_des_init(struct i2c_client *c, struct ds5 *state)
 {
 	struct v4l2_subdev *sd = &state->max9296.des.sd;
@@ -3479,6 +3441,7 @@ static int ds5_des_init(struct i2c_client *c, struct ds5 *state)
 	entity->function = MEDIA_ENT_F_CAM_SENSOR;
 	return media_entity_pads_init(entity, 2, pads);
 }
+#endif
 static int ds5_mux_init(struct i2c_client *c, struct ds5 *state)
 {
 	struct v4l2_subdev *sd = &state->mux.sd.subdev;
@@ -3528,7 +3491,6 @@ static int ds5_mux_init(struct i2c_client *c, struct ds5 *state)
 e_ctrl:
 	v4l2_ctrl_handler_free(sd->ctrl_handler);
 #endif
-e_entity:
 	media_entity_cleanup(entity);
 
 	return ret;
@@ -3611,7 +3573,6 @@ static int ds5_fixed_configuration(struct i2c_client *client, struct ds5 *state)
 	}
 	}
 
-	dev_info(NULL, "%s(), line %d\n", __func__, __LINE__);
 	sensor = &state->rgb.sensor;
 	switch (dev_type) {
 	case DS5_DEVICE_TYPE_D43X:
@@ -3639,7 +3600,6 @@ static int ds5_fixed_configuration(struct i2c_client *client, struct ds5 *state)
 	sensor->n_formats = 1;
 	sensor->mux_pad = DS5_MUX_PAD_IMU;
 
-	dev_info(NULL, "%s(), line %d\n", __func__, __LINE__);
 	/* Development: set a configuration during probing */
 	if ((cfg0 & 0xff00) == 0x1800) {
 		/* MIPI CSI-2 YUV420 isn't supported by V4L, reconfigure to Y8 */
@@ -3664,28 +3624,21 @@ static int ds5_fixed_configuration(struct i2c_client *client, struct ds5 *state)
 			return ret;
 	}
 
-	dev_info(NULL, "%s(), line %d\n", __func__, __LINE__);
 	return 0;
 }
 
 static int ds5_parse_cam(struct i2c_client *client, struct ds5 *state)
 {
-	dev_info(NULL, "%s(), line %d\n", __func__, __LINE__);
 	int ret;
 
 	ret = ds5_fixed_configuration(client, state);
 	if (ret < 0)
 		return ret;
 
-	dev_info(NULL, "%s(), line %d\n", __func__, __LINE__);
 	ds5_sensor_format_init(&state->depth.sensor);
-	dev_info(NULL, "%s(), line %d\n", __func__, __LINE__);
 	ds5_sensor_format_init(&state->motion_t.sensor);
-	dev_info(NULL, "%s(), line %d\n", __func__, __LINE__);
 	ds5_sensor_format_init(&state->rgb.sensor);
-	dev_info(NULL, "%s(), line %d\n", __func__, __LINE__);
 	ds5_sensor_format_init(&state->imu.sensor);
-	dev_info(NULL, "%s(), line %d\n", __func__, __LINE__);
 
 	return 0;
 }
@@ -3858,16 +3811,17 @@ static ssize_t device_write(struct file *flip, const char __user *buffer, size_t
 
 	if (mutex_lock_interruptible(&state->lock))
 		return -ERESTARTSYS;
-	switch (state->dfu_dev.dfu_state_flag) {
 
-	case DS5_DFU_OPEN:
+	if (state->dfu_dev.dfu_state_flag == DS5_DFU_OPEN) {
 		ret = ds5_dfu_switch_to_dfu(state);
 		if (ret < 0) {
 			dev_err(&state->client->dev, "%s(): Switch to dfu failed (%d)\n", __func__, ret);
 			goto dfu_write_error;
 		}
-		/*no break - proceed to recovery*/
-	case DS5_DFU_RECOVERY:
+		state->dfu_dev.dfu_state_flag = DS5_DFU_RECOVERY;
+	}
+
+	if (state->dfu_dev.dfu_state_flag == DS5_DFU_RECOVERY) {
 		ret = ds5_dfu_detach(state);
 		if (ret < 0) {
 			dev_err(&state->client->dev, "%s(): Detach failed (%d)\n", __func__, ret);
@@ -3875,9 +3829,9 @@ static ssize_t device_write(struct file *flip, const char __user *buffer, size_t
 		}
 		state->dfu_dev.dfu_state_flag = DS5_DFU_IN_PROGRESS;
 		state->dfu_dev.init_v4l_f = 1;
+	}
 
-		/*no break - proceed to download*/
-	case DS5_DFU_IN_PROGRESS: {
+	if (state->dfu_dev.dfu_state_flag == DS5_DFU_IN_PROGRESS) {
 		unsigned int dfu_full_blocks = len / DFU_BLOCK_SIZE;
 		unsigned int dfu_part_blocks = len % DFU_BLOCK_SIZE;
 
@@ -3911,14 +3865,11 @@ static ssize_t device_write(struct file *flip, const char __user *buffer, size_t
 			state->dfu_dev.dfu_state_flag = DS5_DFU_DONE;
 		}
 		dev_notice(&state->client->dev, "%s(): DFU block (%d) bytes written\n", __func__, (int)len);
-		break;
-	}
-	default:
+	} else {
 		dev_err(&state->client->dev, "%s(): Wrong state (%d)\n", __func__, state->dfu_dev.dfu_state_flag);
 		ret =  -EINVAL;
 		goto dfu_write_error;
-
-	};
+	}
 	mutex_unlock(&state->lock);
 	return len;
 
@@ -4233,7 +4184,6 @@ static int ds5_probe(struct i2c_client *c, const struct i2c_device_id *id)
 		state->is_rgb = 1;
 
 	ret = ds5_v4l_init(c, state);
-	dev_info(NULL, "%s(), line %d\n", __func__, __LINE__);
 	if (ret < 0)
 		goto e_chardev;
 	/* Override I2C drvdata */
diff --git a/drivers/media/platform/intel/ipu6-acpi-common.c b/drivers/media/platform/intel/ipu6-acpi-common.c
index 05e61f9b3cfa..d07dc97fadcf 100644
--- a/drivers/media/platform/intel/ipu6-acpi-common.c
+++ b/drivers/media/platform/intel/ipu6-acpi-common.c
@@ -13,6 +13,7 @@
  *
  */
 #include <linux/platform_device.h>
+#include <linux/version.h>
 #include <media/ipu-acpi-pdata.h>
 #include <media/ipu-acpi.h>
 
diff --git a/drivers/media/platform/intel/ipu6-acpi-pdata.c b/drivers/media/platform/intel/ipu6-acpi-pdata.c
index 744a12ea0299..c68834e4e35e 100644
--- a/drivers/media/platform/intel/ipu6-acpi-pdata.c
+++ b/drivers/media/platform/intel/ipu6-acpi-pdata.c
@@ -21,6 +21,14 @@
 #define SUFFIX_BASE 96
 #define MSG_LEN 128
 
+static struct ipu_isys_subdev_pdata *ptr_built_in_pdata;
+
+void set_built_in_pdata(struct ipu_isys_subdev_pdata *pdata)
+{
+	ptr_built_in_pdata = pdata;
+};
+EXPORT_SYMBOL(set_built_in_pdata);
+
 static struct ipu_isys_clk_mapping clk_mapping[] = {
 	{ CLKDEV_INIT(NULL, NULL, NULL), NULL }
 };
@@ -371,7 +379,6 @@ void update_pdata(struct device *dev,
 			enum connection_type connect)
 {
 	struct ipu_isys_subdev_info *acpi_subdev;
-	struct ipu_isys_subdev_pdata *ptr_built_in_pdata;
 	bool found = false;
 
 	acpi_subdev = new_subdev;
@@ -379,8 +386,6 @@ void update_pdata(struct device *dev,
 	/* update local ipu_isys_subdev_pdata */
 	add_local_subdevs(acpi_subdev);
 
-	ptr_built_in_pdata = get_built_in_pdata();
-
 	/* if there is existing pdata, update the existing one */
 	if (ptr_built_in_pdata) {
 		struct ipu_isys_subdev_info **subdevs, *sd_info;
diff --git a/drivers/media/platform/intel/ipu6-acpi.c b/drivers/media/platform/intel/ipu6-acpi.c
index f334faf868cb..1e18ac2a3a21 100644
--- a/drivers/media/platform/intel/ipu6-acpi.c
+++ b/drivers/media/platform/intel/ipu6-acpi.c
@@ -190,7 +190,7 @@ int ipu_get_acpi_devices(void *driver_data,
 		dev_dbg(dev, "Built-in pdata not found");
 	else {
 		dev_dbg(dev, "Built-in pdata found");
-		ptr_built_in_pdata = *built_in_pdata;
+		set_built_in_pdata(*built_in_pdata);
 	}
 
 	if ((!fn) || (!driver_data))
@@ -212,7 +212,7 @@ EXPORT_SYMBOL(ipu_get_acpi_devices);
 
 static int __init ipu_acpi_init(void)
 {
-	ptr_built_in_pdata = NULL;
+	set_built_in_pdata(NULL);
 	return 0;
 }
 
diff --git a/include/media/ipu-acpi.h b/include/media/ipu-acpi.h
index 9fb172bef03c..67953db42715 100644
--- a/include/media/ipu-acpi.h
+++ b/include/media/ipu-acpi.h
@@ -28,12 +28,7 @@
 #define GPIO_READY_STAT		0x13
 #define GPIO_HDMI_DETECT	0x14
 
-struct ipu_isys_subdev_pdata *ptr_built_in_pdata;
-
-struct ipu_isys_subdev_pdata *get_built_in_pdata(void)
-{
-	return ptr_built_in_pdata;
-};
+void set_built_in_pdata(struct ipu_isys_subdev_pdata *pdata);
 
 enum connection_type {
 	TYPE_DIRECT,
diff --git a/include/media/ipu-isys.h b/include/media/ipu-isys.h
index 5fe4a872737d..c1b014892e59 100644
--- a/include/media/ipu-isys.h
+++ b/include/media/ipu-isys.h
@@ -20,6 +20,10 @@ struct ipu_isys_subdev_i2c_info {
 	int i2c_adapter_id;
 	char i2c_adapter_bdf[32];
 };
+#define IPU_SPDATA_NAME_LEN	20
+#define IPU_SPDATA_BDF_LEN	32
+#define IPU_SPLATA_GPIO_NUM 4
+#define IPU_SPLATA_IRQ_PIN_NAME_LEN 16
 
 #if (IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA) \
 	&& IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_PDATA_DYNAMIC_LOADING)) \
-- 
2.25.1

