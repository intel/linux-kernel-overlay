From 591d5bd24af4098ec1790a6b9ef1478514a31ca4 Mon Sep 17 00:00:00 2001
From: Jani Nikula <jani.nikula@intel.com>
Date: Thu, 16 Feb 2023 22:45:00 +0200
Subject: [PATCH 0636/2351] drm/displayid: provide access to DisplayID version
 and primary use case

The DisplayID structure version and primary use case are stored in the
DisplayID Base Section. We should be checking them in a number of places
when parsing the DisplayID blocks. Currently, we completely ignore the
primary use case, and just look at the block tags without cross-checking
against structure version.

Store the version and primary use case in the DisplayID iterator, and
provide accessors to them. In general, the information is needed when
iterating the blocks, and this is a convenient place to both store and
retrieve the information during parsing.

Promote using accessors rather than users poking at the iterator
directly.

Cc: Iaroslav Boliukin <iam@lach.pw>
Cc: Dmitry Osipenko <dmitry.osipenko@collabora.com>
Signed-off-by: Jani Nikula <jani.nikula@intel.com>
Tested-by: Dmitry Osipenko <dmitry.osipenko@collabora.com>
Reviewed-by: Dmitry Osipenko <dmitry.osipenko@collabora.com>
Signed-off-by: Dmitry Osipenko <dmitry.osipenko@collabora.com>
Link: https://patchwork.freedesktop.org/patch/msgid/ad8a35c109f97ffe115e6b18e4a132b592f11089.1676580180.git.jani.nikula@intel.com
---
 drivers/gpu/drm/drm_displayid.c | 30 ++++++++++++++++++++++++++++++
 include/drm/drm_displayid.h     | 12 +++++++++++-
 2 files changed, 41 insertions(+), 1 deletion(-)

diff --git a/drivers/gpu/drm/drm_displayid.c b/drivers/gpu/drm/drm_displayid.c
index 0de9b5530393a..9edc111be7eeb 100644
--- a/drivers/gpu/drm/drm_displayid.c
+++ b/drivers/gpu/drm/drm_displayid.c
@@ -123,6 +123,9 @@ __displayid_iter_next(struct displayid_iter *iter)
 	}
 
 	for (;;) {
+		/* The first section we encounter is the base section */
+		bool base_section = !iter->section;
+
 		iter->section = drm_find_displayid_extension(iter->drm_edid,
 							     &iter->length,
 							     &iter->idx,
@@ -132,6 +135,18 @@ __displayid_iter_next(struct displayid_iter *iter)
 			return NULL;
 		}
 
+		/* Save the structure version and primary use case. */
+		if (base_section) {
+			const struct displayid_header *base;
+
+			base = displayid_get_header(iter->section, iter->length,
+						    iter->idx);
+			if (!IS_ERR(base)) {
+				iter->version = base->rev;
+				iter->primary_use = base->prod_id;
+			}
+		}
+
 		iter->idx += sizeof(struct displayid_header);
 
 		block = displayid_iter_block(iter);
@@ -144,3 +159,18 @@ void displayid_iter_end(struct displayid_iter *iter)
 {
 	memset(iter, 0, sizeof(*iter));
 }
+
+/* DisplayID Structure Version/Revision from the Base Section. */
+u8 displayid_version(const struct displayid_iter *iter)
+{
+	return iter->version;
+}
+
+/*
+ * DisplayID Primary Use Case (2.0+) or Product Type Identifier (1.0-1.3) from
+ * the Base Section.
+ */
+u8 displayid_primary_use(const struct displayid_iter *iter)
+{
+	return iter->primary_use;
+}
diff --git a/include/drm/drm_displayid.h b/include/drm/drm_displayid.h
index 49649eb8447e0..566497eeb3b81 100644
--- a/include/drm/drm_displayid.h
+++ b/include/drm/drm_displayid.h
@@ -139,7 +139,11 @@ struct displayid_vesa_vendor_specific_block {
 	u8 mso;
 } __packed;
 
-/* DisplayID iteration */
+/*
+ * DisplayID iteration.
+ *
+ * Do not access directly, this is private.
+ */
 struct displayid_iter {
 	const struct drm_edid *drm_edid;
 
@@ -147,6 +151,9 @@ struct displayid_iter {
 	int length;
 	int idx;
 	int ext_index;
+
+	u8 version;
+	u8 primary_use;
 };
 
 void displayid_iter_edid_begin(const struct drm_edid *drm_edid,
@@ -157,4 +164,7 @@ __displayid_iter_next(struct displayid_iter *iter);
 	while (((__block) = __displayid_iter_next(__iter)))
 void displayid_iter_end(struct displayid_iter *iter);
 
+u8 displayid_version(const struct displayid_iter *iter);
+u8 displayid_primary_use(const struct displayid_iter *iter);
+
 #endif
-- 
2.25.1

