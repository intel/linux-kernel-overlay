From 86e78553dc2608bea6b88681fc0e160f0bf84559 Mon Sep 17 00:00:00 2001
From: zouxiaoh <xiaohong.zou@intel.com>
Date: Tue, 26 Oct 2021 09:38:07 +0800
Subject: [PATCH 5/8] Update LT driver.

Change Description:
Update LT driver.

Test Platform:
TGL-U

Signed-off-by: mengyaog <mengyao.guo@intel.com>
Signed-off-by: zouxiaoh <xiaohong.zou@intel.com>
---
 drivers/media/i2c/lt6911uxc.c | 215 ++++++++++------------------------
 1 file changed, 65 insertions(+), 150 deletions(-)

diff --git a/drivers/media/i2c/lt6911uxc.c b/drivers/media/i2c/lt6911uxc.c
index 6660b527ab86..377c8c7275d0 100644
--- a/drivers/media/i2c/lt6911uxc.c
+++ b/drivers/media/i2c/lt6911uxc.c
@@ -113,6 +113,7 @@ MODULE_PARM_DESC(debug, "debug level (0-3)");
 #define REG_FRAME_STATUS	0xD414
 
 #define LT69111UXC_IRQ_MODE
+#define MAX_MIPI_PORT_USE 3
 
 /* v4l2 dv timings */
 static struct v4l2_dv_timings default_timing = V4L2_DV_BT_CEA_3840X2160P30;
@@ -221,52 +222,6 @@ struct lt6911uxc_state {
 	bool auxiliary_port;
 };
 
-struct lt6911uxc_mode supported_modes[3] = {
-	{
-		//LT6911UXC-a
-		.width = 3840,
-		.height = 2160,
-		.hts = 0,
-		.vts_def = 0,
-		.vts_min = 0,
-		.code = MEDIA_BUS_FMT_UYVY8_1X16,
-		.lanes = 4,
-		.fps = 60,
-		.bpp = 8,
-		.pixel_clk = 297000000,
-		.byte_clk = 168000000,
-		.audio_sample_rate = 48000,
-	},
-	{	//LT6911UXC-c for the right side image of 4K60fps
-		.width = 1920,
-		.height = 2160,
-		.hts = 0,
-		.vts_def = 0,
-		.vts_min = 0,
-		.code = MEDIA_BUS_FMT_UYVY8_1X16,
-		.lanes = 4,
-		.fps = 60,
-		.bpp = 8,
-		.pixel_clk = 297000000,
-		.byte_clk = 168000000,
-		.audio_sample_rate = 48000,
-	},
-	{	//LT6911UXC-b
-		.width = 3840,
-		.height = 2160,
-		.hts = 0,
-		.vts_def = 0,
-		.vts_min = 0,
-		.code = MEDIA_BUS_FMT_UYVY8_1X16,
-		.lanes = 4,
-		.fps = 60,
-		.bpp = 8,
-		.pixel_clk = 297000000,
-		.byte_clk = 168000000,
-		.audio_sample_rate = 48000,
-	},
-};
-
 static const struct v4l2_event lt6911uxc_ev_source_change = {
 	.type = V4L2_EVENT_SOURCE_CHANGE,
 	.u.src_change.changes = V4L2_EVENT_SRC_CH_RESOLUTION,
@@ -972,17 +927,18 @@ static int lt6911uxc_set_stream(struct v4l2_subdev *sd, int enable)
 		if (ret < 0) {
 			pm_runtime_put_noidle(&client->dev);
 			mutex_unlock(&lt6911uxc->mutex);
-			dev_dbg(&client->dev, "pm runtime get sync error.\n");
+			dev_info(&client->dev, "pm runtime get sync error.\n");
 			return ret;
 		}
-
 		ret = lt6911uxc_start_streaming(lt6911uxc);
+		dev_dbg(sd->dev, "[%s()], start streaming.\n", __func__);
 		if (ret) {
 			lt6911uxc_stop_streaming(lt6911uxc);
 			pm_runtime_put(&client->dev);
 		}
 	} else {
 		lt6911uxc_stop_streaming(lt6911uxc);
+		dev_dbg(sd->dev, "[%s()], stop streaming.\n", __func__);
 		pm_runtime_put(&client->dev);
 	}
 
@@ -1018,43 +974,16 @@ static int lt6911uxc_set_format(struct v4l2_subdev *sd,
 {
 	struct lt6911uxc_state *lt6911uxc = to_state(sd);
 	struct i2c_client *client = v4l2_get_subdevdata(&lt6911uxc->sd);
-	struct lt6911uxc_mode *mode;
 	s32 vblank_def;
 	s64 hblank;
-	int i;
-	s32 mipi_lanes;
-
-	mipi_lanes = lt6911uxc->mipi_lanes->val;
-	for (i = 0; i < ARRAY_SIZE(supported_modes); i++) {
-		if (supported_modes[i].width != fmt->format.width
-			|| supported_modes[i].height != fmt->format.height) {
-			dev_dbg(&client->dev, "resolution doesn't match\n");
-			continue;
-		}
-		if (supported_modes[i].code != fmt->format.code) {
-			dev_dbg(&client->dev, "pixel format doesn't match\n");
-			continue;
-		}
-		if (supported_modes[i].lanes != mipi_lanes) {
-			dev_dbg(&client->dev, "mipi lanes doesn't match\n");
-			continue;
-		}
-
-		mode = &supported_modes[i];
-		break;
-	}
-
-	if (i >= ARRAY_SIZE(supported_modes))
-		mode = &supported_modes[0];
 
 	mutex_lock(&lt6911uxc->mutex);
-	lt6911uxc_update_pad_format(mode, &fmt->format);
+	lt6911uxc_update_pad_format(lt6911uxc->cur_mode, &fmt->format);
 	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {
 		*v4l2_subdev_get_try_format(sd, cfg, fmt->pad) = fmt->format;
 	} else {
-		lt6911uxc->cur_mode = mode;
 		__v4l2_ctrl_s_ctrl(lt6911uxc->link_freq,
-			mode->link_freq_index);
+			lt6911uxc->cur_mode->link_freq_index);
 		__v4l2_ctrl_modify_range(lt6911uxc->pixel_rate,
 			25000000, 297000000, 1,
 			get_pixel_rate(lt6911uxc));
@@ -1067,16 +996,16 @@ static int lt6911uxc_set_format(struct v4l2_subdev *sd,
 					hblank);
 
 		/* Update limits and set FPS to default */
-		vblank_def = mode->vts_def - mode->height;
+		vblank_def = lt6911uxc->cur_mode->vts_def - lt6911uxc->cur_mode->height;
 		__v4l2_ctrl_modify_range(lt6911uxc->vblank,
 					 0,
-					 0xffff - mode->height, 1,
+					 0xffff - lt6911uxc->cur_mode->height, 1,
 					 vblank_def);
 		__v4l2_ctrl_s_ctrl(lt6911uxc->vblank, vblank_def);
 
-		__v4l2_ctrl_s_ctrl(lt6911uxc->fps, mode->fps);
+		__v4l2_ctrl_s_ctrl(lt6911uxc->fps, lt6911uxc->cur_mode->fps);
 
-		__v4l2_ctrl_s_ctrl(lt6911uxc->frame_interval, 1000 / mode->fps);
+		__v4l2_ctrl_s_ctrl(lt6911uxc->frame_interval, 1000 / lt6911uxc->cur_mode->fps);
 	}
 	mutex_unlock(&lt6911uxc->mutex);
 
@@ -1105,11 +1034,9 @@ static int lt6911uxc_enum_mbus_code(struct v4l2_subdev *sd,
 				 struct v4l2_subdev_pad_config *cfg,
 				 struct v4l2_subdev_mbus_code_enum *code)
 {
-	if (code->index >= ARRAY_SIZE(supported_modes))
-		return -EINVAL;
-
-	code->code = supported_modes[code->index].code;
+	struct lt6911uxc_state *lt6911uxc = to_state(sd);
 
+	code->code = lt6911uxc->cur_mode->code;
 	return 0;
 }
 
@@ -1117,40 +1044,24 @@ static int lt6911uxc_enum_frame_size(struct v4l2_subdev *sd,
 				  struct v4l2_subdev_pad_config *cfg,
 				  struct v4l2_subdev_frame_size_enum *fse)
 {
-	if (fse->index >= ARRAY_SIZE(supported_modes))
-		return -EINVAL;
+	struct lt6911uxc_state *lt6911uxc = to_state(sd);
 
-	fse->min_width = supported_modes[fse->index].width;
+	fse->min_width = lt6911uxc->cur_mode->width;
 	fse->max_width = fse->min_width;
-	fse->min_height = supported_modes[fse->index].height;
+	fse->min_height = lt6911uxc->cur_mode->height;
 	fse->max_height = fse->min_height;
 
 	return 0;
 }
 
-static int lt6911uxc_frame_rate[] = { 30, 60 };
-
-static int lt6911uxc_enum_frame_interval(struct v4l2_subdev *subdev,
+static int lt6911uxc_enum_frame_interval(struct v4l2_subdev *sd,
 		struct v4l2_subdev_pad_config *cfg,
 		struct v4l2_subdev_frame_interval_enum *fie)
 {
-	int mode_size = ARRAY_SIZE(supported_modes);
-	int i;
-
-	if (fie->index >= ARRAY_SIZE(lt6911uxc_frame_rate))
-		return -EINVAL;
-
-	for (i = 0; i < mode_size; i++)
-		if (fie->code == supported_modes[i].code
-			&& fie->width == supported_modes[i].width
-			&& fie->height == supported_modes[i].height)
-			break;
-
-	if (i == mode_size)
-		return -EINVAL;
+	struct lt6911uxc_state *lt6911uxc = to_state(sd);
 
 	fie->interval.numerator = 1;
-	fie->interval.denominator = lt6911uxc_frame_rate[fie->index];
+	fie->interval.denominator = lt6911uxc->cur_mode->fps;
 
 	return 0;
 }
@@ -1159,20 +1070,27 @@ static int lt6911uxc_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
 {
 	struct lt6911uxc_state *lt6911uxc = to_state(sd);
 
-	mutex_lock(&lt6911uxc->mutex);
+	lt6911uxc_set_stream(sd, true);
 	lt6911uxc_update_pad_format(lt6911uxc->cur_mode,
-				 v4l2_subdev_get_try_format(sd, fh->pad, 0));
-	mutex_unlock(&lt6911uxc->mutex);
-	dev_dbg(sd->dev, "[%s()]width:%u, height:%u, fps:%u",
-			 __func__,
-			 lt6911uxc->cur_mode->width,
-			 lt6911uxc->cur_mode->height,
-			 lt6911uxc->cur_mode->fps);
+								v4l2_subdev_get_try_format(sd, fh->pad, 0));
+	dev_info(sd->dev, "[%s()]width:%u, height:%u, fps:%u.\n",
+			__func__,
+			lt6911uxc->cur_mode->width,
+			lt6911uxc->cur_mode->height,
+			lt6911uxc->cur_mode->fps);
+	return 0;
+}
+
+static int lt6911uxc_close(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	lt6911uxc_set_stream(sd, false);
+	dev_info(sd->dev, "[%s()], stop stream.\n", __func__);
 	return 0;
 }
 
 static const struct v4l2_subdev_internal_ops lt6911uxc_subdev_internal_ops = {
 	.open = lt6911uxc_open,
+	.close = lt6911uxc_close,
 };
 
 static const struct v4l2_subdev_video_ops lt6911uxc_video_ops = {
@@ -1235,7 +1153,7 @@ static int lt6911uxc_remove(struct i2c_client *client)
 	return 0;
 }
 
-static int lt6911uxc_HDMI_status_update(struct lt6911uxc_state *lt6911uxc)
+static int lt6911uxc_video_status_update(struct lt6911uxc_state *lt6911uxc)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(&lt6911uxc->sd);
 	u16 val = 0;
@@ -1253,7 +1171,7 @@ static int lt6911uxc_HDMI_status_update(struct lt6911uxc_state *lt6911uxc)
 			REG_INT_HDMI);
 	switch (int_event) {
 	case INT_HDMI_STABLE:
-		dev_dbg(&client->dev, "HDMI signal stable\n");
+		dev_dbg(&client->dev, "Video signal stable\n");
 		lt6911uxc->streaming = true;
 
 		/* byte clock / MIPI clock */
@@ -1298,11 +1216,6 @@ static int lt6911uxc_HDMI_status_update(struct lt6911uxc_state *lt6911uxc)
 			fps = pixel_clk / (htotal * vtotal);
 		lanes = lt6911uxc_i2c_rd8(&lt6911uxc->sd,
 			 REG_MIPI_LANES);
-		if ((width != lt6911uxc->cur_mode->width)
-			||  (height != lt6911uxc->cur_mode->height)
-			|| (fps != lt6911uxc->cur_mode->fps)
-			|| (lanes != lt6911uxc->cur_mode->lanes)) {
-
 			lt6911uxc->cur_mode->height = height;
 			lt6911uxc->cur_mode->fps = fps;
 			lt6911uxc->cur_mode->code = MEDIA_BUS_FMT_UYVY8_1X16;
@@ -1320,19 +1233,14 @@ static int lt6911uxc_HDMI_status_update(struct lt6911uxc_state *lt6911uxc)
 				lt6911uxc->cur_mode->byte_clk = byte_clock;
 			}
 			dev_info(&client->dev,
-			"width:%u, height:%u, fps:%u",
+			"width:%u, height:%u, fps:%u, lanes: %d\n",
 			lt6911uxc->cur_mode->width,
 			lt6911uxc->cur_mode->height,
-			lt6911uxc->cur_mode->fps);
-			dev_info(&client->dev,
-			"pixel_clk:%u, byte_clock:%u, lanes: %d\n",
-			lt6911uxc->cur_mode->pixel_clk,
-			lt6911uxc->cur_mode->byte_clk,
+			lt6911uxc->cur_mode->fps,
 			lt6911uxc->cur_mode->lanes);
-		}
 	break;
 	case INT_HDMI_DISCONNECT:
-		dev_dbg(&client->dev, "HDMI signal disconnected\n");
+		dev_dbg(&client->dev, "Video signal disconnected\n");
 		if (true == lt6911uxc->streaming) {
 			lt6911uxc->cur_mode->width = 0;
 			lt6911uxc->cur_mode->height = 0;
@@ -1346,7 +1254,7 @@ static int lt6911uxc_HDMI_status_update(struct lt6911uxc_state *lt6911uxc)
 	break;
 	default:
 		lt6911uxc->streaming = false;
-		dev_dbg(&client->dev, "unhandled  = 0x%02X\n", int_event);
+		dev_dbg(&client->dev, "Unhandled video= 0x%02X\n", int_event);
 	return  -ENOLINK;
 	}
 	return 0;
@@ -1385,7 +1293,7 @@ static void lt6911uxc_audio_status_update(struct lt6911uxc_state *lt6911uxc)
 			}
 		break;
 	default:
-		dev_err(&client->dev, "unhandled = 0x%02X\n", int_event);
+		dev_err(&client->dev, "Unhandled audio= 0x%02X\n", int_event);
 		lt6911uxc->cur_mode->audio_sample_rate = 0;
 		return;
 	}
@@ -1403,7 +1311,7 @@ static void lt6911uxc_audio_status_update(struct lt6911uxc_state *lt6911uxc)
 static void  lt6911uxc_check_status(struct lt6911uxc_state *lt6911uxc)
 {
 	lt6911uxc_ext_control(lt6911uxc, true);
-	lt6911uxc_HDMI_status_update(lt6911uxc);
+	lt6911uxc_video_status_update(lt6911uxc);
 	lt6911uxc_audio_status_update(lt6911uxc);
 	lt6911uxc_i2c_wr8(&lt6911uxc->sd, REG_INT_RESPOND, 1);
 	lt6911uxc_ext_control(lt6911uxc, false);
@@ -1443,6 +1351,22 @@ static int lt6911uxc_probe(struct i2c_client *client)
 	if (!lt6911uxc)
 		return -ENOMEM;
 
+	lt6911uxc->cur_mode = devm_kzalloc(&client->dev, sizeof(struct lt6911uxc_mode),
+	     GFP_KERNEL);
+	if (!lt6911uxc->cur_mode)
+		return -ENOMEM;
+
+	memset(lt6911uxc->cur_mode, 0, sizeof(struct lt6911uxc_mode));
+	lt6911uxc->cur_mode->width = 3840,
+	lt6911uxc->cur_mode->height = 2160,
+	lt6911uxc->cur_mode->code = MEDIA_BUS_FMT_UYVY8_1X16,
+	lt6911uxc->cur_mode->lanes = 4,
+	lt6911uxc->cur_mode->fps = 30,
+	lt6911uxc->cur_mode->bpp = 8,
+	lt6911uxc->cur_mode->pixel_clk = 297000000,
+	lt6911uxc->cur_mode->byte_clk = 168000000,
+	lt6911uxc->cur_mode->audio_sample_rate = 48000,
+
 	lt6911uxc->platform_data = client->dev.platform_data;
 	if (lt6911uxc->platform_data == NULL) {
 		dev_err(&client->dev, "no platform data provided\n");
@@ -1472,20 +1396,6 @@ static int lt6911uxc_probe(struct i2c_client *client)
 		}
 		lt6911uxc_ext_control(lt6911uxc, false);
 
-		switch (lt6911uxc->platform_data->port) {
-		case 1:
-			lt6911uxc->cur_mode = &supported_modes[0];
-			break;
-		case 2:
-			lt6911uxc->cur_mode = &supported_modes[2];
-			break;
-		default:
-			lt6911uxc->cur_mode = &supported_modes[0];
-			dev_err(&client->dev,
-				"Undefined lt6911uxc suffix, use mode (0).\n");
-			break;
-		}
-
 		ret = lt6911uxc_init_controls(lt6911uxc);
 		if (ret) {
 			dev_info(&client->dev,  "Could not init control %d!\n", ret);
@@ -1535,10 +1445,15 @@ static int lt6911uxc_probe(struct i2c_client *client)
 		mutex_lock(&lt6911uxc->mutex);
 		lt6911uxc_check_status(lt6911uxc);
 		mutex_unlock(&lt6911uxc->mutex);
+
+		/* Stop to transmit MIPI data firstly waiting for IPU ready */
+		lt6911uxc_stop_streaming(lt6911uxc);
 	} else {
-		/* 4K60fps mode, the setting needs to be fixed on 1920x2160@60fps */
+		/* 4K60fps mode, the setting needs to be fixed on 1920x2160@60fps*/
 		lt6911uxc->auxiliary_port = true;
-		lt6911uxc->cur_mode = &supported_modes[1];
+		lt6911uxc->cur_mode->width = 1920,
+		lt6911uxc->cur_mode->height = 2160,
+		lt6911uxc->cur_mode->fps = 60,
 
 		ret = lt6911uxc_init_controls(lt6911uxc);
 		if (ret) {
@@ -1571,7 +1486,7 @@ static int lt6911uxc_probe(struct i2c_client *client)
 	lt6911uxc->sd.dev = &client->dev;
 	lt6911uxc->sd.internal_ops = &lt6911uxc_subdev_internal_ops;
 	lt6911uxc->sd.flags |=
-		V4L2_SUBDEV_FL_HAS_DEVNODE | V4L2_SUBDEV_FL_HAS_EVENTS;
+			V4L2_SUBDEV_FL_HAS_DEVNODE | V4L2_SUBDEV_FL_HAS_EVENTS;
 
 	ret = v4l2_async_register_subdev_sensor_common(&lt6911uxc->sd);
 	if (ret < 0) {
-- 
2.25.1

