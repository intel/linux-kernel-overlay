From a1c7382f2f0255951c28a9b35530ab8ed64a7863 Mon Sep 17 00:00:00 2001
From: Muhammad Husaini Zulkifli <muhammad.husaini.zulkifli@intel.com>
Date: Fri, 28 Oct 2022 12:45:16 +0800
Subject: [PATCH 68/78] taprio: Add bitmask checking based on the traffic class

Random bitmask value of preempt may be entered by the user.
Current code does not check whether the bitmask value is support
or not based on the traffic class.

This patch add the check to see if bitmask value enter by user is
greater than traffic class or vice versa before final conversion of
preempt bitmask from traffic class to queues.

Signed-off-by: Muhammad Husaini Zulkifli <muhammad.husaini.zulkifli@intel.com>
---
 net/sched/sch_taprio.c | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/net/sched/sch_taprio.c b/net/sched/sch_taprio.c
index 83427c76fa0d..8425ddc95814 100644
--- a/net/sched/sch_taprio.c
+++ b/net/sched/sch_taprio.c
@@ -1618,6 +1618,7 @@ static int taprio_change(struct Qdisc *sch, struct nlattr *opt,
 		u32 preempt = nla_get_u32(tb[TCA_TAPRIO_ATTR_PREEMPT_TCS]);
 		struct tc_preempt_qopt_offload qopt = { };
 		u32 all_tcs_mask = GENMASK(dev->num_tc, 0);
+		int bitmask = (int)__ilog2_u32(preempt);
 
 		if ((preempt & all_tcs_mask) == all_tcs_mask) {
 			NL_SET_ERR_MSG(extack, "At least one queue must be not be preemptible");
@@ -1625,6 +1626,12 @@ static int taprio_change(struct Qdisc *sch, struct nlattr *opt,
 			goto free_sched;
 		}
 
+		if (bitmask > dev->num_tc) {
+			NL_SET_ERR_MSG(extack, "Bitmask set must not greater than traffic class");
+			err = -EOPNOTSUPP;
+			goto free_sched;
+		}
+
 		qopt.preemptible_queues = netdev_tc_map_to_queue_mask(dev, preempt);
 
 		err = dev->netdev_ops->ndo_setup_tc(dev, TC_SETUP_PREEMPT,
-- 
2.17.1

