From ba97c9e7dd41f99c74b51eb364e5a6c150aa6947 Mon Sep 17 00:00:00 2001
From: "Garg, Nemesa" <nemesa.garg@intel.com>
Date: Tue, 24 Jan 2023 20:03:59 +0530
Subject: [PATCH 1083/1096] drm/i915/hdmi/mtl: Compute VRR config for HDMI

This patch adds helper functions to compute the VRR parameters, that
are required to be sent to the HDMI2.1 sink as HDMI VTEM packets.
The parameters to be filled in EMP Header and Data registers and stored
in a new member vtem_config in crtc_state.

Signed-off-by: Garg, Nemesa <nemesa.garg@intel.com>
Signed-off-by: Ankit Nautiyal <ankit.k.nautiyal@intel.com>
Reviewed-by: Bhanuprakash Modem <bhanuprakash.modem@intel.com>
---
 .../drm/i915/display/intel_display_types.h    |  1 +
 drivers/gpu/drm/i915/display/intel_hdmi.c     | 50 +++++++++++++++++++
 2 files changed, 51 insertions(+)

diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index f4b0ec71a20a..7662f09626f6 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -1348,6 +1348,7 @@ struct intel_crtc_state {
 		u8 pipeline_full;
 		u16 flipline, vmin, vmax, guardband;
 		u16 vsync_start, vsync_end;
+		struct hdmi_video_timing_emp_config vtem_config;
 	} vrr;
 
 	struct {
diff --git a/drivers/gpu/drm/i915/display/intel_hdmi.c b/drivers/gpu/drm/i915/display/intel_hdmi.c
index d1be4d47aee4..0eda27ecf199 100644
--- a/drivers/gpu/drm/i915/display/intel_hdmi.c
+++ b/drivers/gpu/drm/i915/display/intel_hdmi.c
@@ -2974,6 +2974,51 @@ static void intel_hdmi_compute_cvtemp_header(struct intel_crtc_state *pipe_confi
 	cvt_emp->enabled = true;
 }
 
+void intel_hdmi_compute_vtemp_payload(struct intel_crtc_state *crtc_state)
+{
+	struct drm_display_mode *mode = &crtc_state->hw.adjusted_mode;
+	struct hdmi_vtem_payload *vtem_payload = &crtc_state->vrr.vtem_config.payload;
+
+	int base_rr = drm_mode_vrefresh(mode);
+	int vic = crtc_state->infoframes.avi.avi.video_code;
+
+	vtem_payload->vrr_en = crtc_state->vrr.enable;
+	vtem_payload->qms_en = false;
+	vtem_payload->fva_factor = 0;
+
+	if (vic != 0) {
+		vtem_payload->base_vfront = 0;
+		vtem_payload->base_refresh_rate = 0;
+	} else {
+		vtem_payload->base_vfront = mode->vsync_start - mode->vdisplay;
+		vtem_payload->base_refresh_rate = base_rr;
+	}
+
+	vtem_payload->m_const = false;
+}
+
+static void intel_hdmi_compute_vtemp_header(struct intel_crtc_state *pipe_config)
+{
+	struct hdmi_extended_metadata_packet *vtem_emp = &pipe_config->vrr.vtem_config.vtemp;
+
+	vtem_emp->type = HDMI_EMP_TYPE_VTEM;
+	vtem_emp->header.hb0 = TRANS_HDMI_EMP_HB0;
+	vtem_emp->first_data_set.pb0_new = true;
+	vtem_emp->first_data_set.pb0_end = false;
+	vtem_emp->first_data_set.pb0_afr = false;
+	vtem_emp->first_data_set.pb0_vfr = true;
+
+	if (pipe_config->vrr.vtem_config.payload.qms_en)
+		vtem_emp->first_data_set.pb0_sync = true;
+	else
+		vtem_emp->first_data_set.pb0_sync = false;
+	vtem_emp->first_data_set.ds_type = HDMI_EMP_DS_TYPE_PSTATIC;
+	vtem_emp->first_data_set.org_id = 1;
+	vtem_emp->first_data_set.data_set_tag = 1;
+	vtem_emp->first_data_set.data_set_length = 4;
+	vtem_emp->enabled = true;
+}
+
 int intel_hdmi_compute_config(struct intel_encoder *encoder,
 			      struct intel_crtc_state *pipe_config,
 			      struct drm_connector_state *conn_state)
@@ -3096,6 +3141,11 @@ int intel_hdmi_compute_config(struct intel_encoder *encoder,
 	if (pipe_config->dsc.compression_enable)
 		intel_hdmi_compute_cvtemp_header(pipe_config);
 
+	if (pipe_config->vrr.enable) {
+		intel_hdmi_compute_vtemp_payload(pipe_config);
+		intel_hdmi_compute_vtemp_header(pipe_config);
+	}
+
 	return 0;
 }
 
-- 
2.25.1

