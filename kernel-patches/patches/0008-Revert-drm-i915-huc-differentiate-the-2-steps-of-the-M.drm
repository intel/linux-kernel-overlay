From 275866fb6320dfd822765d1fd0597b1712ff9a1b Mon Sep 17 00:00:00 2001
From: Junxiao Chang <junxiao.chang@intel.com>
Date: Thu, 6 Jul 2023 15:01:14 +0800
Subject: [PATCH 0008/2351] Revert "drm/i915/huc: differentiate the 2 steps of
 the MTL HuC auth flow"

This reverts commit e8c2e30a15ae6c633849e73ad954b2fdd1df4c04.
---
 drivers/gpu/drm/i915/gt/uc/intel_huc.c    | 94 ++++++-----------------
 drivers/gpu/drm/i915/gt/uc/intel_huc.h    | 16 +---
 drivers/gpu/drm/i915/gt/uc/intel_huc_fw.c |  4 +-
 drivers/gpu/drm/i915/i915_reg.h           |  3 -
 drivers/gpu/drm/i915/pxp/intel_pxp.c      |  4 +-
 include/uapi/drm/i915_drm.h               |  3 +-
 6 files changed, 30 insertions(+), 94 deletions(-)

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_huc.c b/drivers/gpu/drm/i915/gt/uc/intel_huc.c
index fdbf55336acbb..e2422abdd2669 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_huc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_huc.c
@@ -10,7 +10,6 @@
 #include "intel_huc.h"
 #include "intel_huc_print.h"
 #include "i915_drv.h"
-#include "i915_reg.h"
 
 #include <linux/device/bus.h>
 #include <linux/mei_aux.h>
@@ -107,7 +106,7 @@ static enum hrtimer_restart huc_delayed_load_timer_callback(struct hrtimer *hrti
 {
 	struct intel_huc *huc = container_of(hrtimer, struct intel_huc, delayed_load.timer);
 
-	if (!intel_huc_is_authenticated(huc, INTEL_HUC_AUTH_BY_GSC)) {
+	if (!intel_huc_is_authenticated(huc)) {
 		if (huc->delayed_load.status == INTEL_HUC_WAITING_ON_GSC)
 			huc_notice(huc, "timed out waiting for MEI GSC\n");
 		else if (huc->delayed_load.status == INTEL_HUC_WAITING_ON_PXP)
@@ -125,7 +124,7 @@ static void huc_delayed_load_start(struct intel_huc *huc)
 {
 	ktime_t delay;
 
-	GEM_BUG_ON(intel_huc_is_authenticated(huc, INTEL_HUC_AUTH_BY_GSC));
+	GEM_BUG_ON(intel_huc_is_authenticated(huc));
 
 	/*
 	 * On resume we don't have to wait for MEI-GSC to be re-probed, but we
@@ -278,23 +277,13 @@ void intel_huc_init_early(struct intel_huc *huc)
 	}
 
 	if (GRAPHICS_VER(i915) >= 11) {
-		huc->status[INTEL_HUC_AUTH_BY_GUC].reg = GEN11_HUC_KERNEL_LOAD_INFO;
-		huc->status[INTEL_HUC_AUTH_BY_GUC].mask = HUC_LOAD_SUCCESSFUL;
-		huc->status[INTEL_HUC_AUTH_BY_GUC].value = HUC_LOAD_SUCCESSFUL;
+		huc->status.reg = GEN11_HUC_KERNEL_LOAD_INFO;
+		huc->status.mask = HUC_LOAD_SUCCESSFUL;
+		huc->status.value = HUC_LOAD_SUCCESSFUL;
 	} else {
-		huc->status[INTEL_HUC_AUTH_BY_GUC].reg = HUC_STATUS2;
-		huc->status[INTEL_HUC_AUTH_BY_GUC].mask = HUC_FW_VERIFIED;
-		huc->status[INTEL_HUC_AUTH_BY_GUC].value = HUC_FW_VERIFIED;
-	}
-
-	if (IS_DG2(i915)) {
-		huc->status[INTEL_HUC_AUTH_BY_GSC].reg = GEN11_HUC_KERNEL_LOAD_INFO;
-		huc->status[INTEL_HUC_AUTH_BY_GSC].mask = HUC_LOAD_SUCCESSFUL;
-		huc->status[INTEL_HUC_AUTH_BY_GSC].value = HUC_LOAD_SUCCESSFUL;
-	} else {
-		huc->status[INTEL_HUC_AUTH_BY_GSC].reg = HECI_FWSTS5(MTL_GSC_HECI1_BASE);
-		huc->status[INTEL_HUC_AUTH_BY_GSC].mask = HECI_FWSTS5_HUC_AUTH_DONE;
-		huc->status[INTEL_HUC_AUTH_BY_GSC].value = HECI_FWSTS5_HUC_AUTH_DONE;
+		huc->status.reg = HUC_STATUS2;
+		huc->status.mask = HUC_FW_VERIFIED;
+		huc->status.value = HUC_FW_VERIFIED;
 	}
 }
 
@@ -385,41 +374,28 @@ void intel_huc_suspend(struct intel_huc *huc)
 	delayed_huc_load_complete(huc);
 }
 
-static const char *auth_mode_string(struct intel_huc *huc,
-				    enum intel_huc_authentication_type type)
-{
-	bool partial = !huc->loaded_via_gsc && huc->fw.is_meu_binary &&
-		       type == INTEL_HUC_AUTH_BY_GUC;
-
-	return partial ? "clear media" : "all workloads";
-}
-
-int intel_huc_wait_for_auth_complete(struct intel_huc *huc,
-				     enum intel_huc_authentication_type type)
+int intel_huc_wait_for_auth_complete(struct intel_huc *huc)
 {
 	struct intel_gt *gt = huc_to_gt(huc);
 	int ret;
 
-
-
 	ret = __intel_wait_for_register(gt->uncore,
-					huc->status[type].reg,
-					huc->status[type].mask,
-					huc->status[type].value,
+					huc->status.reg,
+					huc->status.mask,
+					huc->status.value,
 					2, 50, NULL);
 
 	/* mark the load process as complete even if the wait failed */
 	delayed_huc_load_complete(huc);
 
 	if (ret) {
-		huc_err(huc, "firmware not verified for %s: %pe\n",
-			auth_mode_string(huc, type), ERR_PTR(ret));
+		huc_err(huc, "firmware not verified %pe\n", ERR_PTR(ret));
 		intel_uc_fw_change_status(&huc->fw, INTEL_UC_FIRMWARE_LOAD_FAIL);
 		return ret;
 	}
 
 	intel_uc_fw_change_status(&huc->fw, INTEL_UC_FIRMWARE_RUNNING);
-	huc_info(huc, "authenticated for %s!\n", auth_mode_string(huc, type));
+	huc_info(huc, "authenticated!\n");
 	return 0;
 }
 
@@ -459,7 +435,7 @@ int intel_huc_auth(struct intel_huc *huc)
 	}
 
 	/* Check authentication status, it should be done by now */
-	ret = intel_huc_wait_for_auth_complete(huc, INTEL_HUC_AUTH_BY_GUC);
+	ret = intel_huc_wait_for_auth_complete(huc);
 	if (ret)
 		goto fail;
 
@@ -470,27 +446,16 @@ int intel_huc_auth(struct intel_huc *huc)
 	return ret;
 }
 
-bool intel_huc_is_authenticated(struct intel_huc *huc,
-				enum intel_huc_authentication_type type)
+bool intel_huc_is_authenticated(struct intel_huc *huc)
 {
 	struct intel_gt *gt = huc_to_gt(huc);
 	intel_wakeref_t wakeref;
 	u32 status = 0;
 
 	with_intel_runtime_pm(gt->uncore->rpm, wakeref)
-		status = intel_uncore_read(gt->uncore, huc->status[type].reg);
+		status = intel_uncore_read(gt->uncore, huc->status.reg);
 
-	return (status & huc->status[type].mask) == huc->status[type].value;
-}
-
-static bool huc_is_fully_authenticated(struct intel_huc *huc)
-{
-	struct intel_uc_fw *huc_fw = &huc->fw;
-
-	if (!huc_fw->is_meu_binary)
-		return intel_huc_is_authenticated(huc, INTEL_HUC_AUTH_BY_GUC);
-	else
-		return intel_huc_is_authenticated(huc, INTEL_HUC_AUTH_BY_GSC);
+	return (status & huc->status.mask) == huc->status.value;
 }
 
 /**
@@ -505,9 +470,7 @@ static bool huc_is_fully_authenticated(struct intel_huc *huc)
  */
 int intel_huc_check_status(struct intel_huc *huc)
 {
-	struct intel_uc_fw *huc_fw = &huc->fw;
-
-	switch (__intel_uc_fw_status(huc_fw)) {
+	switch (__intel_uc_fw_status(&huc->fw)) {
 	case INTEL_UC_FIRMWARE_NOT_SUPPORTED:
 		return -ENODEV;
 	case INTEL_UC_FIRMWARE_DISABLED:
@@ -524,17 +487,7 @@ int intel_huc_check_status(struct intel_huc *huc)
 		break;
 	}
 
-	/*
-	 * meu binaries loaded by GuC are first partially authenticated by GuC
-	 * and then fully authenticated by GSC
-	 */
-	if (huc_is_fully_authenticated(huc))
-		return 1; /* full auth */
-	else if (huc_fw->is_meu_binary && !huc->loaded_via_gsc &&
-		 intel_huc_is_authenticated(huc, INTEL_HUC_AUTH_BY_GUC))
-		return 2; /* clear media only */
-	else
-		return 0;
+	return intel_huc_is_authenticated(huc);
 }
 
 static bool huc_has_delayed_load(struct intel_huc *huc)
@@ -548,10 +501,7 @@ void intel_huc_update_auth_status(struct intel_huc *huc)
 	if (!intel_uc_fw_is_loadable(&huc->fw))
 		return;
 
-	if (!huc->fw.is_meu_binary)
-		return;
-
-	if (huc_is_fully_authenticated(huc))
+	if (intel_huc_is_authenticated(huc))
 		intel_uc_fw_change_status(&huc->fw,
 					  INTEL_UC_FIRMWARE_RUNNING);
 	else if (huc_has_delayed_load(huc))
@@ -584,5 +534,5 @@ void intel_huc_load_status(struct intel_huc *huc, struct drm_printer *p)
 
 	with_intel_runtime_pm(gt->uncore->rpm, wakeref)
 		drm_printf(p, "HuC status: 0x%08x\n",
-			   intel_uncore_read(gt->uncore, huc->status[INTEL_HUC_AUTH_BY_GUC].reg));
+			   intel_uncore_read(gt->uncore, huc->status.reg));
 }
diff --git a/drivers/gpu/drm/i915/gt/uc/intel_huc.h b/drivers/gpu/drm/i915/gt/uc/intel_huc.h
index 2961bf0155286..678bc1e384c8d 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_huc.h
+++ b/drivers/gpu/drm/i915/gt/uc/intel_huc.h
@@ -22,12 +22,6 @@ enum intel_huc_delayed_load_status {
 	INTEL_HUC_DELAYED_LOAD_ERROR,
 };
 
-enum intel_huc_authentication_type {
-	INTEL_HUC_AUTH_BY_GUC = 0,
-	INTEL_HUC_AUTH_BY_GSC,
-	INTEL_HUC_AUTH_MAX_MODES
-};
-
 struct intel_huc {
 	/* Generic uC firmware management */
 	struct intel_uc_fw fw;
@@ -37,7 +31,7 @@ struct intel_huc {
 		i915_reg_t reg;
 		u32 mask;
 		u32 value;
-	} status[INTEL_HUC_AUTH_MAX_MODES];
+	} status;
 
 	struct {
 		struct i915_sw_fence fence;
@@ -54,12 +48,10 @@ int intel_huc_init(struct intel_huc *huc);
 void intel_huc_fini(struct intel_huc *huc);
 void intel_huc_suspend(struct intel_huc *huc);
 int intel_huc_auth(struct intel_huc *huc);
-int intel_huc_wait_for_auth_complete(struct intel_huc *huc,
-				     enum intel_huc_authentication_type type);
-bool intel_huc_is_authenticated(struct intel_huc *huc,
-				enum intel_huc_authentication_type type);
+int intel_huc_wait_for_auth_complete(struct intel_huc *huc);
 int intel_huc_check_status(struct intel_huc *huc);
 void intel_huc_update_auth_status(struct intel_huc *huc);
+bool intel_huc_is_authenticated(struct intel_huc *huc);
 
 void intel_huc_register_gsc_notifier(struct intel_huc *huc, struct bus_type *bus);
 void intel_huc_unregister_gsc_notifier(struct intel_huc *huc, struct bus_type *bus);
@@ -95,7 +87,7 @@ static inline bool intel_huc_is_loaded_by_gsc(const struct intel_huc *huc)
 static inline bool intel_huc_wait_required(struct intel_huc *huc)
 {
 	return intel_huc_is_used(huc) && intel_huc_is_loaded_by_gsc(huc) &&
-	       !intel_huc_is_authenticated(huc, INTEL_HUC_AUTH_BY_GSC);
+	       !intel_huc_is_authenticated(huc);
 }
 
 void intel_huc_load_status(struct intel_huc *huc, struct drm_printer *p);
diff --git a/drivers/gpu/drm/i915/gt/uc/intel_huc_fw.c b/drivers/gpu/drm/i915/gt/uc/intel_huc_fw.c
index ed05dbec4da26..3f4cd2b085da9 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_huc_fw.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_huc_fw.c
@@ -129,7 +129,7 @@ int intel_huc_fw_load_and_auth_via_gsc(struct intel_huc *huc)
 	 * component gets re-bound and this function called again. If so, just
 	 * mark the HuC as loaded.
 	 */
-	if (intel_huc_is_authenticated(huc, INTEL_HUC_AUTH_BY_GSC)) {
+	if (intel_huc_is_authenticated(huc)) {
 		intel_uc_fw_change_status(&huc->fw, INTEL_UC_FIRMWARE_RUNNING);
 		return 0;
 	}
@@ -142,7 +142,7 @@ int intel_huc_fw_load_and_auth_via_gsc(struct intel_huc *huc)
 
 	intel_uc_fw_change_status(&huc->fw, INTEL_UC_FIRMWARE_TRANSFERRED);
 
-	return intel_huc_wait_for_auth_complete(huc, INTEL_HUC_AUTH_BY_GSC);
+	return intel_huc_wait_for_auth_complete(huc);
 }
 
 /**
diff --git a/drivers/gpu/drm/i915/i915_reg.h b/drivers/gpu/drm/i915/i915_reg.h
index b964292fa2ccc..5267d17908003 100644
--- a/drivers/gpu/drm/i915/i915_reg.h
+++ b/drivers/gpu/drm/i915/i915_reg.h
@@ -931,9 +931,6 @@
 #define HECI_CONTROL_AND_STATUS(base)	_MMIO(base + 0x4)
 #define HECI_GENERAL_STATUS(base)	_MMIO(base + 0xc4c)
 
-#define HECI_FWSTS5(base)		_MMIO(base + 0xc68)
-#define   HECI_FWSTS5_HUC_AUTH_DONE	(1 << 19)
-
 #define HSW_GTT_CACHE_EN	_MMIO(0x4024)
 #define   GTT_CACHE_EN_ALL	0xF0007FFF
 #define GEN7_WR_WATERMARK	_MMIO(0x4028)
diff --git a/drivers/gpu/drm/i915/pxp/intel_pxp.c b/drivers/gpu/drm/i915/pxp/intel_pxp.c
index cf72fc55782d4..6052756352e60 100644
--- a/drivers/gpu/drm/i915/pxp/intel_pxp.c
+++ b/drivers/gpu/drm/i915/pxp/intel_pxp.c
@@ -363,9 +363,7 @@ int intel_pxp_start(struct intel_pxp *pxp)
 		return -ENODEV;
 
 	if (HAS_ENGINE(pxp->ctrl_gt, GSC0)) {
-		if (wait_for(intel_huc_is_authenticated(&pxp->ctrl_gt->uc.huc,
-							INTEL_HUC_AUTH_BY_GSC),
-				 8000))
+		if (wait_for(intel_uc_fw_is_running(&pxp->ctrl_gt->uc.gsc.fw), 250))
 			return -ENXIO;
 	} else {
 		if (wait_for(pxp_component_bound(pxp), 250))
diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 5a2bea8ce32e0..5f175f519bb85 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -659,8 +659,7 @@ typedef struct drm_i915_irq_wait {
  * If the IOCTL is successful, the returned parameter will be set to one of the
  * following values:
  *  * 0 if HuC firmware load is not complete,
- *  * 1 if HuC firmware is loaded and fully authenticated,
- *  * 2 if HuC firmware is loaded and authenticated for clear media only
+ *  * 1 if HuC firmware is authenticated and running.
  */
 #define I915_PARAM_HUC_STATUS		 42
 
-- 
2.25.1

