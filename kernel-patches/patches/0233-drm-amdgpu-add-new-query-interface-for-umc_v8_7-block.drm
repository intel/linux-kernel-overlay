From bdf41772effcb62ec369cd9046b4b7dc23875cca Mon Sep 17 00:00:00 2001
From: mziya <Mohammadzafar.ziya@amd.com>
Date: Sat, 15 Jan 2022 15:21:54 +0800
Subject: [PATCH 0233/2251] drm/amdgpu: add new query interface for umc_v8_7
 block

add smu message query error information interface,

function name align with IP version number

V2:
	Removed unused err cnt entry

Signed-off-by: mziya <Mohammadzafar.ziya@amd.com>
Acked-by: Evan Quan <evan.quan@amd.com>
Reviewed-by: Stanley.Yang <Stanley.Yang@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
---
 drivers/gpu/drm/amd/amdgpu/umc_v8_7.c | 160 +++++++++++++++++++++++++-
 1 file changed, 155 insertions(+), 5 deletions(-)

diff --git a/drivers/gpu/drm/amd/amdgpu/umc_v8_7.c b/drivers/gpu/drm/amd/amdgpu/umc_v8_7.c
index ff9e1fac616d..291b37f6db4e 100644
--- a/drivers/gpu/drm/amd/amdgpu/umc_v8_7.c
+++ b/drivers/gpu/drm/amd/amdgpu/umc_v8_7.c
@@ -40,13 +40,161 @@ const uint32_t
 		{9, 0},   {15, 6}
 };
 
-static inline uint32_t get_umc_8_reg_offset(struct amdgpu_device *adev,
+static inline uint32_t get_umc_v8_7_reg_offset(struct amdgpu_device *adev,
 					    uint32_t umc_inst,
 					    uint32_t ch_inst)
 {
 	return adev->umc.channel_offs*ch_inst + UMC_8_INST_DIST*umc_inst;
 }
 
+static inline uint32_t get_umc_v8_7_channel_index(struct amdgpu_device *adev,
+						uint32_t umc_inst,
+						uint32_t ch_inst)
+{
+	return adev->umc.channel_idx_tbl[umc_inst * adev->umc.channel_inst_num + ch_inst];
+}
+
+static void umc_v8_7_ecc_info_query_correctable_error_count(struct amdgpu_device *adev,
+						uint32_t channel_index,
+						unsigned long *error_count)
+{
+	uint64_t mc_umc_status;
+	struct amdgpu_ras *ras = amdgpu_ras_get_context(adev);
+	/* check for SRAM correctable error
+	 * MCUMC_STATUS is a 64 bit register
+	 */
+	mc_umc_status = ras->umc_ecc.ecc[channel_index].mca_umc_status;
+	if (REG_GET_FIELD(mc_umc_status, MCA_UMC_UMC0_MCUMC_STATUST0, Val) == 1 &&
+	    REG_GET_FIELD(mc_umc_status, MCA_UMC_UMC0_MCUMC_STATUST0, CECC) == 1)
+		*error_count += 1;
+}
+
+static void umc_v8_7_ecc_info_querry_uncorrectable_error_count(struct amdgpu_device *adev,
+							uint32_t channel_index,
+							unsigned long *error_count)
+{
+	uint64_t mc_umc_status;
+	struct amdgpu_ras *ras = amdgpu_ras_get_context(adev);
+
+	/* check the MCUMC_STATUS */
+	mc_umc_status = ras->umc_ecc.ecc[channel_index].mca_umc_status;
+	if ((REG_GET_FIELD(mc_umc_status, MCA_UMC_UMC0_MCUMC_STATUST0, Val) == 1) &&
+	    (REG_GET_FIELD(mc_umc_status, MCA_UMC_UMC0_MCUMC_STATUST0, Deferred) == 1 ||
+	    REG_GET_FIELD(mc_umc_status, MCA_UMC_UMC0_MCUMC_STATUST0, UECC) == 1 ||
+	    REG_GET_FIELD(mc_umc_status, MCA_UMC_UMC0_MCUMC_STATUST0, PCC) == 1 ||
+	    REG_GET_FIELD(mc_umc_status, MCA_UMC_UMC0_MCUMC_STATUST0, UC) == 1 ||
+	    REG_GET_FIELD(mc_umc_status, MCA_UMC_UMC0_MCUMC_STATUST0, TCC) == 1))
+		*error_count += 1;
+}
+
+static void umc_v8_7_ecc_info_query_ras_error_count(struct amdgpu_device *adev,
+					void *ras_error_status)
+{
+	struct ras_err_data *err_data = (struct ras_err_data *)ras_error_status;
+
+	uint32_t umc_inst        = 0;
+	uint32_t ch_inst         = 0;
+	uint32_t umc_reg_offset  = 0;
+	uint32_t channel_index   = 0;
+
+	/* TODO: driver needs to toggle DF Cstate to ensure
+	 * safe access of UMC registers. Will add the protection
+	 */
+	LOOP_UMC_INST_AND_CH(umc_inst, ch_inst) {
+		umc_reg_offset = get_umc_v8_7_reg_offset(adev,
+							umc_inst,
+							ch_inst);
+		channel_index = get_umc_v8_7_channel_index(adev,
+							umc_inst,
+							ch_inst);
+		umc_v8_7_ecc_info_query_correctable_error_count(adev,
+							channel_index,
+							&(err_data->ce_count));
+		umc_v8_7_ecc_info_querry_uncorrectable_error_count(adev,
+							channel_index,
+							&(err_data->ue_count));
+	}
+}
+
+static void umc_v8_7_ecc_info_query_error_address(struct amdgpu_device *adev,
+					struct ras_err_data *err_data,
+					uint32_t umc_reg_offset,
+					uint32_t ch_inst,
+					uint32_t umc_inst)
+{
+	uint64_t mc_umc_status, err_addr, retired_page;
+	struct eeprom_table_record *err_rec;
+	uint32_t channel_index;
+	struct amdgpu_ras *ras = amdgpu_ras_get_context(adev);
+
+	channel_index =
+		adev->umc.channel_idx_tbl[umc_inst * adev->umc.channel_inst_num + ch_inst];
+
+	mc_umc_status = ras->umc_ecc.ecc[channel_index].mca_umc_status;
+
+	if (mc_umc_status == 0)
+		return;
+
+	if (!err_data->err_addr)
+		return;
+
+	err_rec = &err_data->err_addr[err_data->err_addr_cnt];
+
+	/* calculate error address if ue/ce error is detected */
+	if (REG_GET_FIELD(mc_umc_status, MCA_UMC_UMC0_MCUMC_STATUST0, Val) == 1 &&
+	    (REG_GET_FIELD(mc_umc_status, MCA_UMC_UMC0_MCUMC_STATUST0, UECC) == 1 ||
+	    REG_GET_FIELD(mc_umc_status, MCA_UMC_UMC0_MCUMC_STATUST0, CECC) == 1)) {
+
+		err_addr = ras->umc_ecc.ecc[channel_index].mca_umc_addr;
+		err_addr = REG_GET_FIELD(err_addr, MCA_UMC_UMC0_MCUMC_ADDRT0, ErrorAddr);
+
+		/* translate umc channel address to soc pa, 3 parts are included */
+		retired_page = ADDR_OF_4KB_BLOCK(err_addr) |
+				ADDR_OF_256B_BLOCK(channel_index) |
+				OFFSET_IN_256B_BLOCK(err_addr);
+
+		/* we only save ue error information currently, ce is skipped */
+		if (REG_GET_FIELD(mc_umc_status, MCA_UMC_UMC0_MCUMC_STATUST0, UECC)
+				== 1) {
+			err_rec->address = err_addr;
+			/* page frame address is saved */
+			err_rec->retired_page = retired_page >> AMDGPU_GPU_PAGE_SHIFT;
+			err_rec->ts = (uint64_t)ktime_get_real_seconds();
+			err_rec->err_type = AMDGPU_RAS_EEPROM_ERR_NON_RECOVERABLE;
+			err_rec->cu = 0;
+			err_rec->mem_channel = channel_index;
+			err_rec->mcumc_id = umc_inst;
+
+			err_data->err_addr_cnt++;
+		}
+	}
+}
+
+static void umc_v8_7_ecc_info_query_ras_error_address(struct amdgpu_device *adev,
+					void *ras_error_status)
+{
+	struct ras_err_data *err_data = (struct ras_err_data *)ras_error_status;
+
+	uint32_t umc_inst        = 0;
+	uint32_t ch_inst         = 0;
+	uint32_t umc_reg_offset  = 0;
+
+	/* TODO: driver needs to toggle DF Cstate to ensure
+	 * safe access of UMC resgisters. Will add the protection
+	 * when firmware interface is ready
+	 */
+	LOOP_UMC_INST_AND_CH(umc_inst, ch_inst) {
+		umc_reg_offset = get_umc_v8_7_reg_offset(adev,
+							umc_inst,
+							ch_inst);
+		umc_v8_7_ecc_info_query_error_address(adev,
+						err_data,
+						umc_reg_offset,
+						ch_inst,
+						umc_inst);
+	}
+}
+
 static void umc_v8_7_clear_error_count_per_channel(struct amdgpu_device *adev,
 					uint32_t umc_reg_offset)
 {
@@ -92,7 +240,7 @@ static void umc_v8_7_clear_error_count(struct amdgpu_device *adev)
 	uint32_t umc_reg_offset  = 0;
 
 	LOOP_UMC_INST_AND_CH(umc_inst, ch_inst) {
-		umc_reg_offset = get_umc_8_reg_offset(adev,
+		umc_reg_offset = get_umc_v8_7_reg_offset(adev,
 						umc_inst,
 						ch_inst);
 
@@ -178,7 +326,7 @@ static void umc_v8_7_query_ras_error_count(struct amdgpu_device *adev,
 	uint32_t umc_reg_offset  = 0;
 
 	LOOP_UMC_INST_AND_CH(umc_inst, ch_inst) {
-		umc_reg_offset = get_umc_8_reg_offset(adev,
+		umc_reg_offset = get_umc_v8_7_reg_offset(adev,
 						      umc_inst,
 						      ch_inst);
 
@@ -268,7 +416,7 @@ static void umc_v8_7_query_ras_error_address(struct amdgpu_device *adev,
 	uint32_t umc_reg_offset  = 0;
 
 	LOOP_UMC_INST_AND_CH(umc_inst, ch_inst) {
-		umc_reg_offset = get_umc_8_reg_offset(adev,
+		umc_reg_offset = get_umc_v8_7_reg_offset(adev,
 						      umc_inst,
 						      ch_inst);
 
@@ -316,7 +464,7 @@ static void umc_v8_7_err_cnt_init(struct amdgpu_device *adev)
 	uint32_t umc_reg_offset  = 0;
 
 	LOOP_UMC_INST_AND_CH(umc_inst, ch_inst) {
-		umc_reg_offset = get_umc_8_reg_offset(adev,
+		umc_reg_offset = get_umc_v8_7_reg_offset(adev,
 						      umc_inst,
 						      ch_inst);
 
@@ -334,4 +482,6 @@ struct amdgpu_umc_ras umc_v8_7_ras = {
 		.hw_ops = &umc_v8_7_ras_hw_ops,
 	},
 	.err_cnt_init = umc_v8_7_err_cnt_init,
+	.ecc_info_query_ras_error_count = umc_v8_7_ecc_info_query_ras_error_count,
+	.ecc_info_query_ras_error_address = umc_v8_7_ecc_info_query_ras_error_address,
 };
-- 
2.25.1

