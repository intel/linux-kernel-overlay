From 45dec08bc49f19eb5de753c383e3a2c48126371f Mon Sep 17 00:00:00 2001
From: Peter Ujfalusi <peter.ujfalusi@linux.intel.com>
Date: Tue, 4 Apr 2023 12:21:07 +0300
Subject: [PATCH 10/38] ASoC: SOF: Intel: hda: Skip interfaces not supported on
 a platform

Not all interfaces (SSP/DMIC/HDA/SDW) are available on all platforms.
If the interface is not even supported then there is no point in executing
a probe or query for that interface.

Introduce a simple function (hda_get_interface_mask) to query the
interfaces supported on the platform.

Signed-off-by: Peter Ujfalusi <peter.ujfalusi@linux.intel.com>
Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
Reviewed-by: Rander Wang <rander.wang@intel.com>
Link: https://lore.kernel.org/r/20230404092115.27949-5-peter.ujfalusi@linux.intel.com
Signed-off-by: Mark Brown <broonie@kernel.org>
---
 sound/soc/sof/intel/hda.c | 50 ++++++++++++++++++++++++++++++++++-----
 1 file changed, 44 insertions(+), 6 deletions(-)

diff --git a/sound/soc/sof/intel/hda.c b/sound/soc/sof/intel/hda.c
index e4dd795bfe8d..251b3b1d8020 100644
--- a/sound/soc/sof/intel/hda.c
+++ b/sound/soc/sof/intel/hda.c
@@ -45,6 +45,37 @@
 #define EXCEPT_MAX_HDR_SIZE	0x400
 #define HDA_EXT_ROM_STATUS_SIZE 8
 
+static u32 hda_get_interface_mask(struct snd_sof_dev *sdev)
+{
+	const struct sof_intel_dsp_desc *chip;
+	u32 interface_mask = 0;
+
+	chip = get_chip_info(sdev->pdata);
+	switch (chip->hw_ip_version) {
+	case SOF_INTEL_TANGIER:
+	case SOF_INTEL_BAYTRAIL:
+	case SOF_INTEL_BROADWELL:
+		interface_mask = BIT(SOF_DAI_INTEL_SSP);
+		break;
+	case SOF_INTEL_CAVS_1_5:
+	case SOF_INTEL_CAVS_1_5_PLUS:
+		interface_mask = BIT(SOF_DAI_INTEL_SSP) | BIT(SOF_DAI_INTEL_DMIC) |
+				 BIT(SOF_DAI_INTEL_HDA);
+		break;
+	case SOF_INTEL_CAVS_1_8:
+	case SOF_INTEL_CAVS_2_0:
+	case SOF_INTEL_CAVS_2_5:
+	case SOF_INTEL_ACE_1_0:
+		interface_mask = BIT(SOF_DAI_INTEL_SSP) | BIT(SOF_DAI_INTEL_DMIC) |
+				 BIT(SOF_DAI_INTEL_HDA) | BIT(SOF_DAI_INTEL_ALH);
+		break;
+	default:
+		break;
+	}
+
+	return interface_mask;
+}
+
 #if IS_ENABLED(CONFIG_SND_SOC_SOF_INTEL_SOUNDWIRE)
 
 /*
@@ -860,6 +891,7 @@ static int dmic_detect_topology_fixup(struct snd_sof_dev *sdev,
 
 static int hda_init_caps(struct snd_sof_dev *sdev)
 {
+	u32 interface_mask = hda_get_interface_mask(sdev);
 	struct hdac_bus *bus = sof_to_bus(sdev);
 	struct snd_sof_pdata *pdata = sdev->pdata;
 	struct sof_intel_hda_dev *hdev = pdata->hw_pdata;
@@ -880,6 +912,10 @@ static int hda_init_caps(struct snd_sof_dev *sdev)
 
 	hda_bus_ml_init(bus);
 
+	/* Skip SoundWire if it is not supported */
+	if (!(interface_mask & BIT(SOF_DAI_INTEL_ALH)))
+		goto skip_soundwire;
+
 	/* scan SoundWire capabilities exposed by DSDT */
 	ret = hda_sdw_acpi_scan(sdev);
 	if (ret < 0) {
@@ -1501,12 +1537,16 @@ void hda_set_mach_params(struct snd_soc_acpi_mach *mach,
 
 struct snd_soc_acpi_mach *hda_machine_select(struct snd_sof_dev *sdev)
 {
+	u32 interface_mask = hda_get_interface_mask(sdev);
 	struct snd_sof_pdata *sof_pdata = sdev->pdata;
 	const struct sof_dev_desc *desc = sof_pdata->desc;
-	struct snd_soc_acpi_mach *mach;
+	struct snd_soc_acpi_mach *mach = NULL;
 	const char *tplg_filename;
 
-	mach = snd_soc_acpi_find_machine(desc->machines);
+	/* Try I2S or DMIC if it is supported */
+	if (interface_mask & (BIT(SOF_DAI_INTEL_SSP) | BIT(SOF_DAI_INTEL_DMIC)))
+		mach = snd_soc_acpi_find_machine(desc->machines);
+
 	if (mach) {
 		bool add_extension = false;
 		bool tplg_fixup = false;
@@ -1613,10 +1653,8 @@ struct snd_soc_acpi_mach *hda_machine_select(struct snd_sof_dev *sdev)
 		}
 	}
 
-	/*
-	 * If I2S fails, try SoundWire
-	 */
-	if (!mach)
+	/* If I2S fails, try SoundWire if it is supported */
+	if (!mach && (interface_mask & BIT(SOF_DAI_INTEL_ALH)))
 		mach = hda_sdw_machine_select(sdev);
 
 	/*
-- 
2.25.1

