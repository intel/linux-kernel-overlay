From a28867696061a1be54960089016434aee399da9d Mon Sep 17 00:00:00 2001
From: zouxiaoh <xiaohong.zou@intel.com>
Date: Mon, 16 Jan 2023 17:34:08 +0800
Subject: [PATCH 3/3] media: i2c: lt6911uxc: Support s3

support s3

Signed-off-by: cjiang3x <chaox.jiang@intel.com>
Signed-off-by: Chen Meng J <meng.j.chen@intel.com>
Signed-off-by: zouxiaoh <xiaohong.zou@intel.com>
---
 drivers/media/i2c/lt6911uxc.c | 70 ++++++++++++++++++++++++++++-------
 1 file changed, 56 insertions(+), 14 deletions(-)

diff --git a/drivers/media/i2c/lt6911uxc.c b/drivers/media/i2c/lt6911uxc.c
index 138e899e5ab2..c6bdb1912bec 100644
--- a/drivers/media/i2c/lt6911uxc.c
+++ b/drivers/media/i2c/lt6911uxc.c
@@ -912,7 +912,6 @@ static int lt6911uxc_start_streaming(struct lt6911uxc_state *lt6911uxc)
 	lt6911uxc_ext_control(lt6911uxc, true);
 	lt6911uxc_csi_enable(&lt6911uxc->sd, true);
 	lt6911uxc_ext_control(lt6911uxc, false);
-	lt6911uxc->streaming = true;
 
 	ret = __v4l2_ctrl_handler_setup(lt6911uxc->sd.ctrl_handler);
 	if (ret)
@@ -930,8 +929,6 @@ static void lt6911uxc_stop_streaming(struct lt6911uxc_state *lt6911uxc)
 	lt6911uxc_ext_control(lt6911uxc, true);
 	lt6911uxc_csi_enable(&lt6911uxc->sd, false);
 	lt6911uxc_ext_control(lt6911uxc, false);
-
-	lt6911uxc->streaming = false;
 }
 
 static int lt6911uxc_set_stream(struct v4l2_subdev *sd, int enable)
@@ -945,15 +942,21 @@ static int lt6911uxc_set_stream(struct v4l2_subdev *sd, int enable)
 	if (lt6911uxc->auxiliary_port == true)
 		return 0;
 
+	mutex_lock(&lt6911uxc->mutex);
 	if (enable) {
 		dev_dbg(sd->dev, "[%s()], start streaming.\n", __func__);
 		ret = lt6911uxc_start_streaming(lt6911uxc);
-		if (ret)
+		if (ret) {
+			enable = 0;
 			lt6911uxc_stop_streaming(lt6911uxc);
+		}
 	} else {
 		dev_dbg(sd->dev, "[%s()], stop streaming.\n", __func__);
 		lt6911uxc_stop_streaming(lt6911uxc);
 	}
+	mutex_unlock(&lt6911uxc->mutex);
+
+	lt6911uxc->streaming = enable;
 
 	return ret;
 }
@@ -970,16 +973,6 @@ static int lt6911uxc_g_frame_interval(struct v4l2_subdev *sd,
 	return 0;
 }
 
-static int __maybe_unused lt6911uxc_suspend(struct device *dev)
-{
-	return 0;
-}
-
-static int __maybe_unused lt6911uxc_resume(struct device *dev)
-{
-	return 0;
-}
-
 static int lt6911uxc_set_format(struct v4l2_subdev *sd,
 			     struct v4l2_subdev_pad_config *cfg,
 			     struct v4l2_subdev_format *fmt)
@@ -1516,6 +1509,55 @@ static int lt6911uxc_probe(struct i2c_client *client)
 	return ret;
 }
 
+static int lt6911uxc_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct lt6911uxc_state *lt6911uxc = to_state(sd);
+
+	if (-1 != lt6911uxc->platform_data->reset_pin)
+		if (gpio_get_value(lt6911uxc->platform_data->reset_pin))
+			gpio_set_value(lt6911uxc->platform_data->reset_pin, 0);
+
+	mutex_lock(&lt6911uxc->mutex);
+	if (lt6911uxc->streaming)
+		lt6911uxc_stop_streaming(lt6911uxc);
+
+	mutex_unlock(&lt6911uxc->mutex);
+	dev_dbg(sd->dev, "suspend streaming...\n");
+	return 0;
+}
+
+static int lt6911uxc_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct lt6911uxc_state *lt6911uxc = to_state(sd);
+	int ret;
+
+	if (-1 != lt6911uxc->platform_data->reset_pin)
+		if (!gpio_get_value(lt6911uxc->platform_data->reset_pin))
+			gpio_set_value(lt6911uxc->platform_data->reset_pin, 1);
+
+	usleep_range(200000, 205000);
+	//recheck the current HDMI status in case changed
+	lt6911uxc_check_status(lt6911uxc);
+
+	mutex_lock(&lt6911uxc->mutex);
+	if (lt6911uxc->streaming) {
+		ret = lt6911uxc_start_streaming(lt6911uxc);
+		if (ret) {
+			lt6911uxc->streaming = false;
+			lt6911uxc_stop_streaming(lt6911uxc);
+			mutex_unlock(&lt6911uxc->mutex);
+			return ret;
+		}
+	}
+	mutex_unlock(&lt6911uxc->mutex);
+	dev_dbg(sd->dev, "resume streaming...\n");
+	return 0;
+}
+
 static const struct dev_pm_ops lt6911uxc_pm_ops = {
 	SET_SYSTEM_SLEEP_PM_OPS(lt6911uxc_suspend, lt6911uxc_resume)
 };
-- 
2.25.1

