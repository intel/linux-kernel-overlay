From 60695d2bc3979334a8208b3399eaa117edbdd0b7 Mon Sep 17 00:00:00 2001
From: Chen Lei A <lei.a.chen@intel.com>
Date: Thu, 31 Aug 2023 10:34:22 +0800
Subject: [PATCH] kselftests: Bind performance test with a master CPU core

Description:
    Due to special reasons, some physical CPU cores are designed
    for ultra low power usage, if to run a high performance test
    on these cores to verfiy system performance, it will fail, this
    change will bind the performance test with a performance core to
    void the failure.

Signed-off-by: Chen Lei A <lei.a.chen@intel.com>
---
 .../testing/selftests/mqueue/mq_perf_tests.c  | 37 ++++++++++++++++++-
 1 file changed, 36 insertions(+), 1 deletion(-)

diff --git a/tools/testing/selftests/mqueue/mq_perf_tests.c b/tools/testing/selftests/mqueue/mq_perf_tests.c
index 5c16159d0bcd..36f1c8903d84 100644
--- a/tools/testing/selftests/mqueue/mq_perf_tests.c
+++ b/tools/testing/selftests/mqueue/mq_perf_tests.c
@@ -538,6 +538,39 @@ void increase_limits(void)
 	cur_nice = -20;
 }
 
+int find_cpuid_to_pin(void)
+{
+	FILE *fp;
+	char str[81];
+	int id = 0, num = 0;
+	double tmp, max_x = 0.;
+
+	//fp = popen("cat /proc/cpuinfo|grep cpu\\ MHz|sed -e 's/.*:[^0-9]//'", "r");
+	fp = popen("cat /proc/cpuinfo|grep cache\\ size|sed -e 's/.*:[^0-9]//'", "r");
+	if (fp < 0) {
+		printf("Cannot read CPU information\n");
+		return 0;
+	}
+
+	memset(str, 0, 81);
+	while (NULL != fgets(str, 80, fp)) {
+		tmp = atof(str);
+		if (abs(tmp - max_x) < 0.1 || max_x < tmp) {
+			max_x = tmp;
+			id = num;
+		}
+		memset(str, 0, 81);
+		num++;
+	}
+
+	pclose(fp);
+	if (num > cpus_online) {
+		printf("Warning: read CPU information error\n");
+		id = 0;
+	}
+	return id;
+}
+
 int main(int argc, char *argv[])
 {
 	struct mq_attr attr;
@@ -634,7 +667,9 @@ int main(int argc, char *argv[])
 		goto err_code;
 	} else if (!continuous_mode) {
 		num_cpus_to_pin = 1;
-		cpus_to_pin[0] = cpus_online - 1;
+		/* To avoid a high queue depth performanc test is binded with a physical */
+		/* CPU core which is designed with small cache for ultra low power usages. */
+		cpus_to_pin[0] = find_cpuid_to_pin();
 	}
 
 	max_msgs = fopen(MAX_MSGS, "r+");
-- 
2.25.1

