From b51e479d50ed60bae9bf43a32d613c422381bfe4 Mon Sep 17 00:00:00 2001
From: Tomas Winkler <tomas.winkler@intel.com>
Date: Thu, 10 Oct 2019 20:13:49 +0300
Subject: [PATCH 16/24] mei: dal: move read wait queue to the dal client struct

Move read wait queue to each client so only the active
reader is woken up.

Change-Id: I064a3e71b83bdf4f05f45f990105705a15cbf4ba
Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
---
 drivers/misc/mei/dal/dal_class.c | 30 ++++++++++++++++++++++--------
 drivers/misc/mei/dal/dal_dev.h   |  2 ++
 2 files changed, 24 insertions(+), 8 deletions(-)

diff --git a/drivers/misc/mei/dal/dal_class.c b/drivers/misc/mei/dal/dal_class.c
index e128bf47f978..28a676e7b62f 100644
--- a/drivers/misc/mei/dal/dal_class.c
+++ b/drivers/misc/mei/dal/dal_class.c
@@ -189,11 +189,11 @@ static void dal_recv_cb(struct mei_cl_device *cldev)
 		dev_dbg(&ddev->dev, "recv_cb(): setting CURRENT_READER to NULL\n");
 		ddev->current_read_client = NULL;
 	}
-out:
-	/* wake up all clients waiting for read or write */
-	if (wq_has_sleeper(&ddev->wq))
-		wake_up_interruptible(&ddev->wq);
 
+	/* wake up reader */
+	if (wq_has_sleeper(&dc->read_wq))
+		wake_up_interruptible(&dc->read_wq);
+out:
 	mutex_unlock(&ddev->context_lock);
 }
 
@@ -297,8 +297,11 @@ static int dal_send_error_access_denied(struct dal_client *dc, const void *cmd)
 		ret = -ENOMEM;
 		goto out;
 	}
-	ret = 0;
 
+	if (wq_has_sleeper(&dc->read_wq))
+		wake_up_interruptible(&dc->read_wq);
+
+	ret = 0;
 out:
 	mutex_unlock(&ddev->context_lock);
 	return ret;
@@ -524,7 +527,7 @@ int dal_wait_for_read(struct dal_client *dc)
 		dc->intf, kfifo_is_empty(&dc->read_queue));
 
 	/* wait until there is data in the read_queue */
-	ret = wait_event_interruptible(ddev->wq,
+	ret = wait_event_interruptible(dc->read_wq,
 				       !kfifo_is_empty(&dc->read_queue) ||
 					ddev->is_device_removed);
 
@@ -598,7 +601,9 @@ int dal_dc_setup(struct dal_device *ddev, enum dal_intf intf)
 	dc->intf = intf;
 	dc->ddev = ddev;
 	INIT_LIST_HEAD(&dc->wrlink);
+	init_waitqueue_head(&dc->read_wq);
 	ddev->clients[intf] = dc;
+
 	return 0;
 }
 
@@ -647,6 +652,9 @@ struct device *dal_find_dev(enum dal_dev_type device_id)
 static int dal_remove(struct mei_cl_device *cldev)
 {
 	struct dal_device *ddev = mei_cldev_get_drvdata(cldev);
+	struct dal_client *dc;
+
+	unsigned int i;
 
 	if (!ddev)
 		return 0;
@@ -655,11 +663,17 @@ static int dal_remove(struct mei_cl_device *cldev)
 
 	ddev->is_device_removed = 1;
 	/* make sure the above is set */
-	smp_mb();
+
 	/* wakeup write waiters so we can unload */
-	if (waitqueue_active(&ddev->wq))
+	if (wq_has_sleeper(&ddev->wq))
 		wake_up_interruptible(&ddev->wq);
 
+	for (i = 0; i < ARRAY_SIZE(ddev->clients); i++) {
+		dc = ddev->clients[i];
+		if (dc && wq_has_sleeper(&dc->read_wq))
+			wake_up_interruptible(&dc->read_wq);
+	}
+
 	mei_cldev_set_drvdata(cldev, NULL);
 
 	device_unregister(&ddev->dev);
diff --git a/drivers/misc/mei/dal/dal_dev.h b/drivers/misc/mei/dal/dal_dev.h
index e4feb245cc03..de6f04a224a3 100644
--- a/drivers/misc/mei/dal/dal_dev.h
+++ b/drivers/misc/mei/dal/dal_dev.h
@@ -55,6 +55,7 @@ enum dal_dev_type {
  * @wrlink: link in the writers list
  * @read_queue: queue of received messages from DAL FW
  * @intf: client interface - user space or kernel space
+ * @read_wq: reading wait queue.
  *
  * @seq: the sequence number of the last message sent (in kernel space API only)
  *       When a message is received from DAL FW, we use this sequence number
@@ -72,6 +73,7 @@ struct dal_client {
 	struct list_head wrlink;
 	struct kfifo read_queue;
 	enum dal_intf intf;
+	wait_queue_head_t read_wq;
 
 	u64 seq;
 	u32 expected_msg_size_from_fw;
-- 
2.25.1

