From ead4c19d1380d71fe6f837510d01859f844e6680 Mon Sep 17 00:00:00 2001
From: Ranjan Dutta <ranjan.dutta@intel.com>
Date: Tue, 19 Jul 2022 14:50:03 +0800
Subject: [PATCH 53/62] Revert "drm/ingenic: Reset pixclock rate when parent
 clock rate changes"

This reverts commit 032f8c67fe95608cf51cbf72163f7fa02f8913b3.
---
 drivers/gpu/drm/ingenic/ingenic-drm-drv.c | 61 +----------------------
 1 file changed, 1 insertion(+), 60 deletions(-)

diff --git a/drivers/gpu/drm/ingenic/ingenic-drm-drv.c b/drivers/gpu/drm/ingenic/ingenic-drm-drv.c
index e34718cf5c2e..b6bb5fc7d183 100644
--- a/drivers/gpu/drm/ingenic/ingenic-drm-drv.c
+++ b/drivers/gpu/drm/ingenic/ingenic-drm-drv.c
@@ -10,7 +10,6 @@
 #include <linux/clk.h>
 #include <linux/dma-mapping.h>
 #include <linux/module.h>
-#include <linux/mutex.h>
 #include <linux/of_device.h>
 #include <linux/platform_device.h>
 #include <linux/regmap.h>
@@ -69,21 +68,6 @@ struct ingenic_drm {
 
 	bool panel_is_sharp;
 	bool no_vblank;
-
-	/*
-	 * clk_mutex is used to synchronize the pixel clock rate update with
-	 * the VBLANK. When the pixel clock's parent clock needs to be updated,
-	 * clock_nb's notifier function will lock the mutex, then wait until the
-	 * next VBLANK. At that point, the parent clock's rate can be updated,
-	 * and the mutex is then unlocked. If an atomic commit happens in the
-	 * meantime, it will lock on the mutex, effectively waiting until the
-	 * clock update process finishes. Finally, the pixel clock's rate will
-	 * be recomputed when the mutex has been released, in the pending atomic
-	 * commit, or a future one.
-	 */
-	struct mutex clk_mutex;
-	bool update_clk_rate;
-	struct notifier_block clock_nb;
 };
 
 static const u32 ingenic_drm_primary_formats[] = {
@@ -127,29 +111,6 @@ static inline struct ingenic_drm *drm_crtc_get_priv(struct drm_crtc *crtc)
 	return container_of(crtc, struct ingenic_drm, crtc);
 }
 
-static inline struct ingenic_drm *drm_nb_get_priv(struct notifier_block *nb)
-{
-	return container_of(nb, struct ingenic_drm, clock_nb);
-}
-
-static int ingenic_drm_update_pixclk(struct notifier_block *nb,
-				     unsigned long action,
-				     void *data)
-{
-	struct ingenic_drm *priv = drm_nb_get_priv(nb);
-
-	switch (action) {
-	case PRE_RATE_CHANGE:
-		mutex_lock(&priv->clk_mutex);
-		priv->update_clk_rate = true;
-		drm_crtc_wait_one_vblank(&priv->crtc);
-		return NOTIFY_OK;
-	default:
-		mutex_unlock(&priv->clk_mutex);
-		return NOTIFY_OK;
-	}
-}
-
 static void ingenic_drm_crtc_atomic_enable(struct drm_crtc *crtc,
 					   struct drm_crtc_state *state)
 {
@@ -315,14 +276,8 @@ static void ingenic_drm_crtc_atomic_flush(struct drm_crtc *crtc,
 
 	if (drm_atomic_crtc_needs_modeset(state)) {
 		ingenic_drm_crtc_update_timings(priv, &state->mode);
-		priv->update_clk_rate = true;
-	}
 
-	if (priv->update_clk_rate) {
-		mutex_lock(&priv->clk_mutex);
 		clk_set_rate(priv->pix_clk, state->adjusted_mode.clock * 1000);
-		priv->update_clk_rate = false;
-		mutex_unlock(&priv->clk_mutex);
 	}
 
 	if (event) {
@@ -981,28 +936,16 @@ static int ingenic_drm_bind(struct device *dev, bool has_components)
 	if (soc_info->has_osd)
 		regmap_write(priv->map, JZ_REG_LCD_OSDC, JZ_LCD_OSDC_OSDEN);
 
-	mutex_init(&priv->clk_mutex);
-	priv->clock_nb.notifier_call = ingenic_drm_update_pixclk;
-
-	parent_clk = clk_get_parent(priv->pix_clk);
-	ret = clk_notifier_register(parent_clk, &priv->clock_nb);
-	if (ret) {
-		dev_err(dev, "Unable to register clock notifier\n");
-		goto err_devclk_disable;
-	}
-
 	ret = drm_dev_register(drm, 0);
 	if (ret) {
 		dev_err(dev, "Failed to register DRM driver\n");
-		goto err_clk_notifier_unregister;
+		goto err_devclk_disable;
 	}
 
 	drm_fbdev_generic_setup(drm, 32);
 
 	return 0;
 
-err_clk_notifier_unregister:
-	clk_notifier_unregister(parent_clk, &priv->clock_nb);
 err_devclk_disable:
 	if (priv->lcd_clk)
 		clk_disable_unprepare(priv->lcd_clk);
@@ -1024,9 +967,7 @@ static int compare_of(struct device *dev, void *data)
 static void ingenic_drm_unbind(struct device *dev)
 {
 	struct ingenic_drm *priv = dev_get_drvdata(dev);
-	struct clk *parent_clk = clk_get_parent(priv->pix_clk);
 
-	clk_notifier_unregister(parent_clk, &priv->clock_nb);
 	if (priv->lcd_clk)
 		clk_disable_unprepare(priv->lcd_clk);
 	clk_disable_unprepare(priv->pix_clk);
-- 
2.27.0

