From 8a307f6032f42a748c95b80b0316cf1973811cf0 Mon Sep 17 00:00:00 2001
From: Muhammad Husaini Zulkifli <muhammad.husaini.zulkifli@intel.com>
Date: Fri, 28 Oct 2022 12:45:16 +0800
Subject: [PATCH 2/6] taprio: Add bitmask checking based on the traffic class

Random bitmask value of preempt may be entered by the user.
Current code does not check whether the bitmask value is support
or not based on the traffic class.

This patch add the check to see if bitmask value enter by user is
greater than traffic class or vice versa before final conversion of
preempt bitmask from traffic class to queues.

Signed-off-by: Muhammad Husaini Zulkifli <muhammad.husaini.zulkifli@intel.com>
---
 net/sched/sch_taprio.c | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/net/sched/sch_taprio.c b/net/sched/sch_taprio.c
index fd61ce106738..5d5aab8953c9 100644
--- a/net/sched/sch_taprio.c
+++ b/net/sched/sch_taprio.c
@@ -1537,6 +1537,7 @@ static int taprio_change(struct Qdisc *sch, struct nlattr *opt,
 		u32 preempt = nla_get_u32(tb[TCA_TAPRIO_ATTR_PREEMPT_TCS]);
 		struct tc_preempt_qopt_offload qopt = { };
 		u32 all_tcs_mask = GENMASK(dev->num_tc, 0);
+		int bitmask = (int)__ilog2_u32(preempt);
 
 		if ((preempt & all_tcs_mask) == all_tcs_mask) {
 			NL_SET_ERR_MSG(extack, "At least one queue must be not be preemptible");
@@ -1544,6 +1545,12 @@ static int taprio_change(struct Qdisc *sch, struct nlattr *opt,
 			goto free_sched;
 		}
 
+		if (bitmask > dev->num_tc) {
+			NL_SET_ERR_MSG(extack, "Bitmask set must not greater than traffic class");
+			err = -EOPNOTSUPP;
+			goto free_sched;
+		}
+
 		qopt.preemptible_queues = netdev_tc_map_to_queue_mask(dev, preempt);
 
 		err = dev->netdev_ops->ndo_setup_tc(dev, TC_SETUP_PREEMPT,
-- 
2.25.1

