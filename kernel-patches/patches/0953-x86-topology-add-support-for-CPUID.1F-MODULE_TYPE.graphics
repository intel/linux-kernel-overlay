From 6a077125dc7a7c57c01d26358ebf5ebf8d9740ba Mon Sep 17 00:00:00 2001
From: Zhang Rui <rui.zhang@intel.com>
Date: Thu, 5 May 2022 09:29:17 +0800
Subject: [PATCH 0953/1096] x86/topology: add support for CPUID.1F MODULE_TYPE

This is just a prototye patch, and it is not targeted for upstream.

How to fix the problem is still under discussion internally.

Teach the kernel about CPUID.1F MODULE_TYPE.

Before this update, the unrecognized MODULE_TYPE bits in the APIC-ID were
assumed to be package_id bits.  The result is that the kernel would
erroneously report a multi Ecore module system as a multi-package system.

With this update, the module_id bits are treated as an extension of the
core_id bits, so that we can get the correct package_id, as well as a
unique core_id within a package.

We don't currently see the need to complicate the topology namespace.
(eg. making core_id=7 into module_id=1 + core_id=3).

Note that with SCHED_CLUSTER, sysfs already identifies Ecore modules with
a unique cluster_id.

The patch has been tested on an 8 Atom core ADL-N platform.

Signed-off-by: Zhang Rui <rui.zhang@intel.com>
Reported-and-tested-by: Wang Wendy <wendy.wang@intel.com>
Reviewed-by: Len Brown <len.brown@intel.com>
---
 arch/x86/kernel/cpu/topology.c | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/arch/x86/kernel/cpu/topology.c b/arch/x86/kernel/cpu/topology.c
index 5e868b62a7c4..f67f99d76371 100644
--- a/arch/x86/kernel/cpu/topology.c
+++ b/arch/x86/kernel/cpu/topology.c
@@ -19,6 +19,7 @@
 #define INVALID_TYPE	0
 #define SMT_TYPE	1
 #define CORE_TYPE	2
+#define MODULE_TYPE	3
 #define DIE_TYPE	5
 
 #define LEAFB_SUBTYPE(ecx)		(((ecx) >> 8) & 0xff)
@@ -121,7 +122,8 @@ int detect_extended_topology(struct cpuinfo_x86 *c)
 		/*
 		 * Check for the Core type in the implemented sub leaves.
 		 */
-		if (LEAFB_SUBTYPE(ecx) == CORE_TYPE) {
+		if (LEAFB_SUBTYPE(ecx) == CORE_TYPE ||
+		    LEAFB_SUBTYPE(ecx) == MODULE_TYPE) {
 			core_level_siblings = LEVEL_MAX_SIBLINGS(ebx);
 			core_plus_mask_width = BITS_SHIFT_NEXT_LEVEL(eax);
 			die_level_siblings = core_level_siblings;
-- 
2.25.1

