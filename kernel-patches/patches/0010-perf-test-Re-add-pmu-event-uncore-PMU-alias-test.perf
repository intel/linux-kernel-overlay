From 29965d4de2e25dfdb22c1ef152ad4012d8fb6680 Mon Sep 17 00:00:00 2001
From: John Garry <john.garry@huawei.com>
Date: Thu, 29 Jul 2021 21:56:22 +0800
Subject: [PATCH 10/60] perf test: Re-add pmu-event uncore PMU alias test

Add support to match aliases for uncore PMUs.

Since we cannot rely on the PMUs being present on the host system, use
fake PMUs.

The following conditions in the test are ensures:

- Expected count of aliases created

- All aliases can be matched to an expected alias in
  perf_pmu_test_pmu.aliases

This will catch the condition fixed in commit c47a5599eda3 ("perf tools:
Fix pattern matching for same substring in different PMU type"), where
excess events were created for a PMU. It will also fix the scenario
inadvertently broken there, where no aliases were created for aliases
with multiple tokens.

Signed-off-by: John Garry <john.garry@huawei.com>
Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
Cc: Ian Rogers <irogers@google.com>
Cc: Ingo Molnar <mingo@redhat.com>
Cc: Jin Yao <yao.jin@linux.intel.com>
Cc: Jiri Olsa <jolsa@redhat.com>
Cc: Mark Rutland <mark.rutland@arm.com>
Cc: Namhyung Kim <namhyung@kernel.org>
Cc: Peter Zijlstra <peterz@infradead.org>
Cc: linuxarm@huawei.com
Link: https //lore.kernel.org/r/1627566986-30605-8-git-send-email-john.garry@huawei.com
Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
---
 tools/perf/tests/pmu-events.c | 110 ++++++++++++++++++++++++++++++++++
 1 file changed, 110 insertions(+)

diff --git a/tools/perf/tests/pmu-events.c b/tools/perf/tests/pmu-events.c
index b90d532f49ec..bd9f664f054a 100644
--- a/tools/perf/tests/pmu-events.c
+++ b/tools/perf/tests/pmu-events.c
@@ -28,6 +28,14 @@ struct perf_pmu_test_event {
 	 * be set in the alias.
 	 */
 	const char *alias_long_desc;
+
+	/* PMU which we should match against */
+	const char *matching_pmu;
+};
+
+struct perf_pmu_test_pmu {
+	struct perf_pmu pmu;
+	struct perf_pmu_test_event const *aliases[10];
 };
 
 static const struct perf_pmu_test_event bp_l1_btb_correct = {
@@ -118,6 +126,7 @@ static const struct perf_pmu_test_event uncore_hisi_ddrc_flux_wcmd = {
 	},
 	.alias_str = "event=0x2",
 	.alias_long_desc = "DDRC write commands",
+	.matching_pmu = "hisi_sccl1_ddrc2",
 };
 
 static const struct perf_pmu_test_event unc_cbo_xsnp_response_miss_eviction = {
@@ -131,6 +140,7 @@ static const struct perf_pmu_test_event unc_cbo_xsnp_response_miss_eviction = {
 	},
 	.alias_str = "umask=0x81,event=0x22",
 	.alias_long_desc = "A cross-core snoop resulted from L3 Eviction which misses in some processor core",
+	.matching_pmu = "uncore_cbox_0",
 };
 
 static const struct perf_pmu_test_event *uncore_events[] = {
@@ -404,10 +414,103 @@ static int __test_core_pmu_event_aliases(char *pmu_name, int *count)
 	return res;
 }
 
+static int __test_uncore_pmu_event_aliases(struct perf_pmu_test_pmu *test_pmu)
+{
+	int alias_count = 0, to_match_count = 0, matched_count = 0;
+	struct perf_pmu_test_event const **table;
+	struct perf_pmu *pmu = &test_pmu->pmu;
+	const char *pmu_name = pmu->name;
+	struct perf_pmu_alias *a, *tmp, *alias;
+	struct pmu_events_map *map;
+	LIST_HEAD(aliases);
+	int res = 0;
+
+	map = __test_pmu_get_events_map();
+	if (!map)
+		return -1;
+	pmu_add_cpu_aliases_map(&aliases, pmu, map);
+
+	/* Count how many aliases we generated */
+	list_for_each_entry(alias, &aliases, list)
+		alias_count++;
+
+	/* Count how many aliases we expect from the known table */
+	for (table = &test_pmu->aliases[0]; *table; table++)
+		to_match_count++;
+
+	if (alias_count != to_match_count) {
+		pr_debug("testing aliases uncore PMU %s: mismatch expected aliases (%d) vs found (%d)\n",
+			 pmu_name, to_match_count, alias_count);
+		res = -1;
+		goto out;
+	}
+
+	list_for_each_entry(alias, &aliases, list) {
+		bool matched = false;
+
+		for (table = &test_pmu->aliases[0]; *table; table++) {
+			struct perf_pmu_test_event const *test_event = *table;
+			struct pmu_event const *event = &test_event->event;
+
+			if (!strcmp(event->name, alias->name)) {
+				if (compare_alias_to_test_event(alias,
+							test_event,
+							pmu_name)) {
+					continue;
+				}
+				matched = true;
+				matched_count++;
+			}
+		}
+
+		if (matched == false) {
+			pr_debug("testing aliases uncore PMU %s: could not match alias %s\n",
+				 pmu_name, alias->name);
+			res = -1;
+			goto out;
+		}
+	}
+
+	if (alias_count != matched_count) {
+		pr_debug("testing aliases uncore PMU %s: mismatch found aliases (%d) vs matched (%d)\n",
+			 pmu_name, matched_count, alias_count);
+		res = -1;
+	}
+
+out:
+	list_for_each_entry_safe(a, tmp, &aliases, list) {
+		list_del(&a->list);
+		perf_pmu_free_alias(a);
+	}
+	return res;
+}
+
+static struct perf_pmu_test_pmu test_pmus[] = {
+	{
+		.pmu = {
+			.name = (char *)"hisi_sccl1_ddrc2",
+			.is_uncore = 1,
+		},
+		.aliases = {
+			&uncore_hisi_ddrc_flux_wcmd,
+		},
+	},
+	{
+		.pmu = {
+			.name = (char *)"uncore_cbox_0",
+			.is_uncore = 1,
+		},
+		.aliases = {
+			&unc_cbo_xsnp_response_miss_eviction,
+		},
+	},
+};
+
 /* Test that aliases generated are as expected */
 static int test_aliases(void)
 {
 	struct perf_pmu *pmu = NULL;
+	unsigned long i;
 
 	while ((pmu = perf_pmu__scan(pmu)) != NULL) {
 		int count = 0;
@@ -434,6 +537,13 @@ static int test_aliases(void)
 		pr_debug("testing core PMU %s aliases: pass\n", pmu->name);
 	}
 
+	for (i = 0; i < ARRAY_SIZE(test_pmus); i++) {
+		int res = __test_uncore_pmu_event_aliases(&test_pmus[i]);
+
+		if (res)
+			return res;
+	}
+
 	return 0;
 }
 
-- 
2.25.1

