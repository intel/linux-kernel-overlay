From 0eb4361a3aa82daf9f4f9501f4c0893b3829afbd Mon Sep 17 00:00:00 2001
From: Junxiao Chang <junxiao.chang@intel.com>
Date: Thu, 6 Jul 2023 15:01:15 +0800
Subject: [PATCH 0012/2351] Revert "drm/i915/gsc: Fix race between HW init and
 GSC FW load"

This reverts commit 207cb8155d6ada545437e8372ed40c2e787dcb5c.
---
 drivers/gpu/drm/i915/gt/uc/intel_gsc_uc.c | 19 -------------------
 drivers/gpu/drm/i915/gt/uc/intel_gsc_uc.h |  1 -
 drivers/gpu/drm/i915/gt/uc/intel_uc.c     |  5 ++---
 3 files changed, 2 insertions(+), 23 deletions(-)

diff --git a/drivers/gpu/drm/i915/gt/uc/intel_gsc_uc.c b/drivers/gpu/drm/i915/gt/uc/intel_gsc_uc.c
index 25248d9a6a663..8693c5ecc4e63 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_gsc_uc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_gsc_uc.c
@@ -185,25 +185,6 @@ void intel_gsc_uc_flush_work(struct intel_gsc_uc *gsc)
 	flush_work(&gsc->work);
 }
 
-void intel_gsc_uc_resume(struct intel_gsc_uc *gsc)
-{
-	if (!intel_uc_fw_is_loadable(&gsc->fw))
-		return;
-
-	/*
-	 * we only want to start the GSC worker from here in the actual resume
-	 * flow and not during driver load. This is because GSC load is slow and
-	 * therefore we want to make sure that the default state init completes
-	 * first to not slow down the init thread. A separate call to
-	 * intel_gsc_uc_load_start will ensure that the GSC is loaded during
-	 * driver load.
-	 */
-	if (!gsc_uc_to_gt(gsc)->engine[GSC0]->default_state)
-		return;
-
-	intel_gsc_uc_load_start(gsc);
-}
-
 void intel_gsc_uc_load_start(struct intel_gsc_uc *gsc)
 {
 	struct intel_gt *gt = gsc_uc_to_gt(gsc);
diff --git a/drivers/gpu/drm/i915/gt/uc/intel_gsc_uc.h b/drivers/gpu/drm/i915/gt/uc/intel_gsc_uc.h
index 647e6bd65ac69..877177ca8ed6b 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_gsc_uc.h
+++ b/drivers/gpu/drm/i915/gt/uc/intel_gsc_uc.h
@@ -41,7 +41,6 @@ void intel_gsc_uc_init_early(struct intel_gsc_uc *gsc);
 int intel_gsc_uc_init(struct intel_gsc_uc *gsc);
 void intel_gsc_uc_fini(struct intel_gsc_uc *gsc);
 void intel_gsc_uc_flush_work(struct intel_gsc_uc *gsc);
-void intel_gsc_uc_resume(struct intel_gsc_uc *gsc);
 void intel_gsc_uc_load_start(struct intel_gsc_uc *gsc);
 
 static inline bool intel_gsc_uc_is_supported(const struct intel_gsc_uc *gsc)
diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc.c b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
index 08b46e8fd76f4..96208eb190518 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc.c
@@ -144,7 +144,6 @@ void intel_uc_init_early(struct intel_uc *uc)
 void intel_uc_init_late(struct intel_uc *uc)
 {
 	intel_guc_init_late(&uc->guc);
-	intel_gsc_uc_load_start(&uc->gsc);
 }
 
 void intel_uc_driver_late_release(struct intel_uc *uc)
@@ -555,6 +554,8 @@ static int __uc_init_hw(struct intel_uc *uc)
 		intel_rps_lower_unslice(&uc_to_gt(uc)->rps);
 	}
 
+	intel_gsc_uc_load_start(&uc->gsc);
+
 	guc_info(guc, "submission %s\n", str_enabled_disabled(intel_uc_uses_guc_submission(uc)));
 	guc_info(guc, "SLPC %s\n", str_enabled_disabled(intel_uc_uses_guc_slpc(uc)));
 
@@ -834,8 +835,6 @@ static int __uc_resume(struct intel_uc *uc, bool enable_communication)
 		return err;
 	}
 
-	intel_gsc_uc_resume(&uc->gsc);
-
 	return 0;
 }
 
-- 
2.25.1

