From 1d86f0adb96f3292ce3ea49c7c173ad89e1fa24d Mon Sep 17 00:00:00 2001
From: Zhou Furong <furong.zhou@intel.com>
Date: Tue, 19 Apr 2022 18:50:25 +0800
Subject: [PATCH 1/6] net: wwan: t7xxx: sync latest change from upstream for
 v5.18

squash all of difference between changes in v5.15 kernel and
latest one for v5.18.

Signed-off-by: Zhou Furong <furong.zhou@intel.com>
---
 drivers/net/wwan/t7xx/t7xx_cldma.c         |  22 +-
 drivers/net/wwan/t7xx/t7xx_cldma.h         |  28 +-
 drivers/net/wwan/t7xx/t7xx_common.h        |  66 ----
 drivers/net/wwan/t7xx/t7xx_dpmaif.c        | 109 +++---
 drivers/net/wwan/t7xx/t7xx_dpmaif.h        |  20 +-
 drivers/net/wwan/t7xx/t7xx_hif_cldma.c     |  28 +-
 drivers/net/wwan/t7xx/t7xx_hif_cldma.h     |   5 +-
 drivers/net/wwan/t7xx/t7xx_hif_dpmaif.c    |   6 +-
 drivers/net/wwan/t7xx/t7xx_hif_dpmaif.h    |  43 ++-
 drivers/net/wwan/t7xx/t7xx_hif_dpmaif_rx.c |  88 +++--
 drivers/net/wwan/t7xx/t7xx_hif_dpmaif_rx.h |  56 +--
 drivers/net/wwan/t7xx/t7xx_hif_dpmaif_tx.c | 184 ++++------
 drivers/net/wwan/t7xx/t7xx_hif_dpmaif_tx.h |  45 ++-
 drivers/net/wwan/t7xx/t7xx_mhccif.c        |  12 +-
 drivers/net/wwan/t7xx/t7xx_mhccif.h        |   2 +-
 drivers/net/wwan/t7xx/t7xx_modem_ops.c     |  97 ++---
 drivers/net/wwan/t7xx/t7xx_modem_ops.h     |   3 +-
 drivers/net/wwan/t7xx/t7xx_netdev.c        |  13 +-
 drivers/net/wwan/t7xx/t7xx_netdev.h        |   3 +-
 drivers/net/wwan/t7xx/t7xx_pci.c           |  75 ++--
 drivers/net/wwan/t7xx/t7xx_pci.h           |  24 +-
 drivers/net/wwan/t7xx/t7xx_pcie_mac.c      |   5 +-
 drivers/net/wwan/t7xx/t7xx_pcie_mac.h      |   2 +-
 drivers/net/wwan/t7xx/t7xx_port.h          |  32 +-
 drivers/net/wwan/t7xx/t7xx_port_ctrl_msg.c | 132 +++++--
 drivers/net/wwan/t7xx/t7xx_port_proxy.c    | 399 ++++++++-------------
 drivers/net/wwan/t7xx/t7xx_port_proxy.h    |  40 +--
 drivers/net/wwan/t7xx/t7xx_port_wwan.c     |  74 ++--
 drivers/net/wwan/t7xx/t7xx_reg.h           |  14 +-
 drivers/net/wwan/t7xx/t7xx_state_monitor.c |   4 +-
 drivers/net/wwan/t7xx/t7xx_state_monitor.h |  14 +-
 31 files changed, 700 insertions(+), 945 deletions(-)
 delete mode 100644 drivers/net/wwan/t7xx/t7xx_common.h

diff --git a/drivers/net/wwan/t7xx/t7xx_cldma.c b/drivers/net/wwan/t7xx/t7xx_cldma.c
index 2713d9a6034b..02cac3ab492d 100644
--- a/drivers/net/wwan/t7xx/t7xx_cldma.c
+++ b/drivers/net/wwan/t7xx/t7xx_cldma.c
@@ -6,7 +6,7 @@
  * Authors:
  *  Haijun Liu <haijun.liu@mediatek.com>
  *  Moises Veleta <moises.veleta@intel.com>
- *  Ricardo Martinez<ricardo.martinez@linux.intel.com>
+ *  Ricardo Martinez <ricardo.martinez@linux.intel.com>
  *
  * Contributors:
  *  Amir Hanania <amir.hanania@intel.com>
@@ -21,7 +21,6 @@
 #include <linux/io-64-nonatomic-lo-hi.h>
 #include <linux/types.h>
 
-#include "t7xx_common.h"
 #include "t7xx_cldma.h"
 
 #define ADDR_SIZE	8
@@ -61,7 +60,8 @@ void t7xx_cldma_hw_restore(struct t7xx_cldma_hw *hw_info)
 	iowrite32(DL_MEM_CHECK_DIS, hw_info->ap_pdn_base + REG_CLDMA_DL_MEM);
 }
 
-void t7xx_cldma_hw_start_queue(struct t7xx_cldma_hw *hw_info, u8 qno, enum mtk_txrx tx_rx)
+void t7xx_cldma_hw_start_queue(struct t7xx_cldma_hw *hw_info, unsigned int qno,
+			       enum mtk_txrx tx_rx)
 {
 	void __iomem *reg;
 	u32 val;
@@ -102,14 +102,14 @@ void t7xx_cldma_hw_reset(void __iomem *ao_base)
 	iowrite32(val, ao_base + REG_INFRA_RST2_CLR);
 }
 
-bool t7xx_cldma_tx_addr_is_set(struct t7xx_cldma_hw *hw_info, unsigned char qno)
+bool t7xx_cldma_tx_addr_is_set(struct t7xx_cldma_hw *hw_info, unsigned int qno)
 {
 	u32 offset = REG_CLDMA_UL_START_ADDRL_0 + qno * ADDR_SIZE;
 
 	return !!ioread64(hw_info->ap_pdn_base + offset);
 }
 
-void t7xx_cldma_hw_set_start_addr(struct t7xx_cldma_hw *hw_info, unsigned char qno, u64 address,
+void t7xx_cldma_hw_set_start_addr(struct t7xx_cldma_hw *hw_info, unsigned int qno, u64 address,
 				  enum mtk_txrx tx_rx)
 {
 	u32 offset = qno * ADDR_SIZE;
@@ -120,7 +120,7 @@ void t7xx_cldma_hw_set_start_addr(struct t7xx_cldma_hw *hw_info, unsigned char q
 	iowrite64(address, reg + offset);
 }
 
-void t7xx_cldma_hw_resume_queue(struct t7xx_cldma_hw *hw_info, unsigned char qno,
+void t7xx_cldma_hw_resume_queue(struct t7xx_cldma_hw *hw_info, unsigned int qno,
 				enum mtk_txrx tx_rx)
 {
 	void __iomem *base = hw_info->ap_pdn_base;
@@ -131,7 +131,7 @@ void t7xx_cldma_hw_resume_queue(struct t7xx_cldma_hw *hw_info, unsigned char qno
 		iowrite32(BIT(qno), base + REG_CLDMA_UL_RESUME_CMD);
 }
 
-unsigned int t7xx_cldma_hw_queue_status(struct t7xx_cldma_hw *hw_info, unsigned char qno,
+unsigned int t7xx_cldma_hw_queue_status(struct t7xx_cldma_hw *hw_info, unsigned int qno,
 					enum mtk_txrx tx_rx)
 {
 	void __iomem *reg;
@@ -179,7 +179,7 @@ unsigned int t7xx_cldma_hw_int_status(struct t7xx_cldma_hw *hw_info, unsigned in
 	return val & bitmask;
 }
 
-void t7xx_cldma_hw_irq_dis_txrx(struct t7xx_cldma_hw *hw_info, unsigned char qno,
+void t7xx_cldma_hw_irq_dis_txrx(struct t7xx_cldma_hw *hw_info, unsigned int qno,
 				enum mtk_txrx tx_rx)
 {
 	void __iomem *reg;
@@ -191,7 +191,7 @@ void t7xx_cldma_hw_irq_dis_txrx(struct t7xx_cldma_hw *hw_info, unsigned char qno
 	iowrite32(val, reg);
 }
 
-void t7xx_cldma_hw_irq_dis_eq(struct t7xx_cldma_hw *hw_info, unsigned char qno, enum mtk_txrx tx_rx)
+void t7xx_cldma_hw_irq_dis_eq(struct t7xx_cldma_hw *hw_info, unsigned int qno, enum mtk_txrx tx_rx)
 {
 	void __iomem *reg;
 	u32 val;
@@ -202,7 +202,7 @@ void t7xx_cldma_hw_irq_dis_eq(struct t7xx_cldma_hw *hw_info, unsigned char qno,
 	iowrite32(val << EQ_STA_BIT_OFFSET, reg);
 }
 
-void t7xx_cldma_hw_irq_en_txrx(struct t7xx_cldma_hw *hw_info, unsigned char qno,
+void t7xx_cldma_hw_irq_en_txrx(struct t7xx_cldma_hw *hw_info, unsigned int qno,
 			       enum mtk_txrx tx_rx)
 {
 	void __iomem *reg;
@@ -214,7 +214,7 @@ void t7xx_cldma_hw_irq_en_txrx(struct t7xx_cldma_hw *hw_info, unsigned char qno,
 	iowrite32(val, reg);
 }
 
-void t7xx_cldma_hw_irq_en_eq(struct t7xx_cldma_hw *hw_info, unsigned char qno, enum mtk_txrx tx_rx)
+void t7xx_cldma_hw_irq_en_eq(struct t7xx_cldma_hw *hw_info, unsigned int qno, enum mtk_txrx tx_rx)
 {
 	void __iomem *reg;
 	u32 val;
diff --git a/drivers/net/wwan/t7xx/t7xx_cldma.h b/drivers/net/wwan/t7xx/t7xx_cldma.h
index 6df5c373b38a..8949e8377fb0 100644
--- a/drivers/net/wwan/t7xx/t7xx_cldma.h
+++ b/drivers/net/wwan/t7xx/t7xx_cldma.h
@@ -6,7 +6,7 @@
  * Authors:
  *  Haijun Liu <haijun.liu@mediatek.com>
  *  Moises Veleta <moises.veleta@intel.com>
- *  Ricardo Martinez<ricardo.martinez@linux.intel.com>
+ *  Ricardo Martinez <ricardo.martinez@linux.intel.com>
  *
  * Contributors:
  *  Amir Hanania <amir.hanania@intel.com>
@@ -20,8 +20,6 @@
 #include <linux/bits.h>
 #include <linux/types.h>
 
-#include "t7xx_common.h"
-
 #define CLDMA_TXQ_NUM			8
 #define CLDMA_RXQ_NUM			8
 #define CLDMA_ALL_Q			GENMASK(7, 0)
@@ -133,6 +131,11 @@
 #define REG_INFRA_RST2_CLR		0x0144
 #define RST2_PMIC_SW_RST_CLR		BIT(18)
 
+enum mtk_txrx {
+	MTK_TX,
+	MTK_RX,
+};
+
 enum t7xx_hw_mode {
 	MODE_BIT_32,
 	MODE_BIT_36,
@@ -147,30 +150,31 @@ struct t7xx_cldma_hw {
 	u32				phy_interrupt_id;
 };
 
-void t7xx_cldma_hw_irq_dis_txrx(struct t7xx_cldma_hw *hw_info, unsigned char qno,
+void t7xx_cldma_hw_irq_dis_txrx(struct t7xx_cldma_hw *hw_info, unsigned int qno,
 				enum mtk_txrx tx_rx);
-void t7xx_cldma_hw_irq_dis_eq(struct t7xx_cldma_hw *hw_info, unsigned char qno,
+void t7xx_cldma_hw_irq_dis_eq(struct t7xx_cldma_hw *hw_info, unsigned int qno,
 			      enum mtk_txrx tx_rx);
-void t7xx_cldma_hw_irq_en_txrx(struct t7xx_cldma_hw *hw_info, unsigned char qno,
+void t7xx_cldma_hw_irq_en_txrx(struct t7xx_cldma_hw *hw_info, unsigned int qno,
 			       enum mtk_txrx tx_rx);
-void t7xx_cldma_hw_irq_en_eq(struct t7xx_cldma_hw *hw_info, unsigned char qno, enum mtk_txrx tx_rx);
-unsigned int t7xx_cldma_hw_queue_status(struct t7xx_cldma_hw *hw_info, unsigned char qno,
+void t7xx_cldma_hw_irq_en_eq(struct t7xx_cldma_hw *hw_info, unsigned int qno, enum mtk_txrx tx_rx);
+unsigned int t7xx_cldma_hw_queue_status(struct t7xx_cldma_hw *hw_info, unsigned int qno,
 					enum mtk_txrx tx_rx);
 void t7xx_cldma_hw_init(struct t7xx_cldma_hw *hw_info);
-void t7xx_cldma_hw_resume_queue(struct t7xx_cldma_hw *hw_info, unsigned char qno,
+void t7xx_cldma_hw_resume_queue(struct t7xx_cldma_hw *hw_info, unsigned int qno,
 				enum mtk_txrx tx_rx);
 void t7xx_cldma_hw_start(struct t7xx_cldma_hw *hw_info);
-void t7xx_cldma_hw_start_queue(struct t7xx_cldma_hw *hw_info, u8 qno, enum mtk_txrx tx_rx);
+void t7xx_cldma_hw_start_queue(struct t7xx_cldma_hw *hw_info, unsigned int qno,
+			       enum mtk_txrx tx_rx);
 void t7xx_cldma_hw_tx_done(struct t7xx_cldma_hw *hw_info, unsigned int bitmask);
 void t7xx_cldma_hw_rx_done(struct t7xx_cldma_hw *hw_info, unsigned int bitmask);
 void t7xx_cldma_hw_stop_all_qs(struct t7xx_cldma_hw *hw_info, enum mtk_txrx tx_rx);
 void t7xx_cldma_hw_set_start_addr(struct t7xx_cldma_hw *hw_info,
-				  unsigned char qno, u64 address, enum mtk_txrx tx_rx);
+				  unsigned int qno, u64 address, enum mtk_txrx tx_rx);
 void t7xx_cldma_hw_reset(void __iomem *ao_base);
 void t7xx_cldma_hw_stop(struct t7xx_cldma_hw *hw_info, enum mtk_txrx tx_rx);
 unsigned int t7xx_cldma_hw_int_status(struct t7xx_cldma_hw *hw_info, unsigned int bitmask,
 				      enum mtk_txrx tx_rx);
 void t7xx_cldma_hw_restore(struct t7xx_cldma_hw *hw_info);
 void t7xx_cldma_clear_ip_busy(struct t7xx_cldma_hw *hw_info);
-bool t7xx_cldma_tx_addr_is_set(struct t7xx_cldma_hw *hw_info, unsigned char qno);
+bool t7xx_cldma_tx_addr_is_set(struct t7xx_cldma_hw *hw_info, unsigned int qno);
 #endif
diff --git a/drivers/net/wwan/t7xx/t7xx_common.h b/drivers/net/wwan/t7xx/t7xx_common.h
deleted file mode 100644
index 60d938754119..000000000000
--- a/drivers/net/wwan/t7xx/t7xx_common.h
+++ /dev/null
@@ -1,66 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0-only
- *
- * Copyright (c) 2021, MediaTek Inc.
- * Copyright (c) 2021-2022, Intel Corporation.
- *
- * Authors:
- *  Haijun Liu <haijun.liu@mediatek.com>
- *  Ricardo Martinez<ricardo.martinez@linux.intel.com>
- *
- * Contributors:
- *  Andy Shevchenko <andriy.shevchenko@linux.intel.com>
- *  Chiranjeevi Rapolu <chiranjeevi.rapolu@intel.com>
- *  Eliot Lee <eliot.lee@intel.com>
- *  Moises Veleta <moises.veleta@intel.com>
- *  Sreehari Kancharla <sreehari.kancharla@intel.com>
- */
-
-#ifndef __T7XX_COMMON_H__
-#define __T7XX_COMMON_H__
-
-#include <linux/bits.h>
-#include <linux/skbuff.h>
-#include <linux/types.h>
-
-struct ccci_header {
-	__le32 packet_header;
-	__le32 packet_len;
-	__le32 status;
-	__le32 ex_msg;
-};
-
-/* Coupled with HW - indicates if there is data following the CCCI header or not */
-#define CCCI_HEADER_NO_DATA	0xffffffff
-
-#define CCCI_H_AST_BIT		BIT(31)
-#define CCCI_H_SEQ_FLD		GENMASK(30, 16)
-#define CCCI_H_CHN_FLD		GENMASK(15, 0)
-
-enum md_state {
-	MD_STATE_INVALID,
-	MD_STATE_WAITING_FOR_HS1,
-	MD_STATE_WAITING_FOR_HS2,
-	MD_STATE_READY,
-	MD_STATE_EXCEPTION,
-	MD_STATE_WAITING_TO_STOP,
-	MD_STATE_STOPPED,
-};
-
-enum mtk_txrx {
-	MTK_TX,
-	MTK_RX,
-};
-
-#ifdef NET_SKBUFF_DATA_USES_OFFSET
-static inline unsigned int t7xx_skb_data_area_size(struct sk_buff *skb)
-{
-	return skb->head + skb->end - skb->data;
-}
-#else
-static inline unsigned int t7xx_skb_data_area_size(struct sk_buff *skb)
-{
-	return skb->end - skb->data;
-}
-#endif
-
-#endif
diff --git a/drivers/net/wwan/t7xx/t7xx_dpmaif.c b/drivers/net/wwan/t7xx/t7xx_dpmaif.c
index d27fff91c4f9..78a019e51f0a 100644
--- a/drivers/net/wwan/t7xx/t7xx_dpmaif.c
+++ b/drivers/net/wwan/t7xx/t7xx_dpmaif.c
@@ -7,7 +7,7 @@
  *  Amir Hanania <amir.hanania@intel.com>
  *  Haijun Liu <haijun.liu@mediatek.com>
  *  Moises Veleta <moises.veleta@intel.com>
- *  Ricardo Martinez<ricardo.martinez@linux.intel.com>
+ *  Ricardo Martinez <ricardo.martinez@linux.intel.com>
  *
  * Contributors:
  *  Andy Shevchenko <andriy.shevchenko@linux.intel.com>
@@ -140,7 +140,7 @@ static u32 t7xx_update_dlq_intr(struct dpmaif_hw_info *hw_info, u32 q_done)
 	return value;
 }
 
-static int t7xx_mask_dlq_intr(struct dpmaif_hw_info *hw_info, unsigned char qno)
+static int t7xx_mask_dlq_intr(struct dpmaif_hw_info *hw_info, unsigned int qno)
 {
 	u32 value, q_done;
 	int ret;
@@ -161,7 +161,7 @@ static int t7xx_mask_dlq_intr(struct dpmaif_hw_info *hw_info, unsigned char qno)
 	return 0;
 }
 
-void t7xx_dpmaif_dlq_unmask_rx_done(struct dpmaif_hw_info *hw_info, unsigned char qno)
+void t7xx_dpmaif_dlq_unmask_rx_done(struct dpmaif_hw_info *hw_info, unsigned int qno)
 {
 	u32 mask;
 
@@ -179,7 +179,7 @@ void t7xx_dpmaif_clr_ip_busy_sts(struct dpmaif_hw_info *hw_info)
 }
 
 static void t7xx_dpmaif_dlq_mask_rx_pitcnt_len_err_intr(struct dpmaif_hw_info *hw_info,
-							unsigned char qno)
+							unsigned int qno)
 {
 	if (qno == DPF_RX_QNO0)
 		iowrite32(DPMAIF_DL_INT_DLQ0_PITCNT_LEN,
@@ -190,7 +190,7 @@ static void t7xx_dpmaif_dlq_mask_rx_pitcnt_len_err_intr(struct dpmaif_hw_info *h
 }
 
 void t7xx_dpmaif_dlq_unmask_pitcnt_len_err_intr(struct dpmaif_hw_info *hw_info,
-						unsigned char qno)
+						unsigned int qno)
 {
 	if (qno == DPF_RX_QNO0)
 		iowrite32(DPMAIF_DL_INT_DLQ0_PITCNT_LEN,
@@ -512,8 +512,7 @@ static void t7xx_dpmaif_dl_dlq_hpc_hw_init(struct dpmaif_hw_info *hw_info)
 	t7xx_dpmaif_hw_dlq_start_prs_thres_set(hw_info);
 }
 
-static int t7xx_dpmaif_dl_bat_init_done(struct dpmaif_hw_info *hw_info,
-					unsigned char q_num, bool frg_en)
+static int t7xx_dpmaif_dl_bat_init_done(struct dpmaif_hw_info *hw_info, bool frg_en)
 {
 	u32 value, dl_bat_init = 0;
 	int ret;
@@ -544,14 +543,13 @@ static int t7xx_dpmaif_dl_bat_init_done(struct dpmaif_hw_info *hw_info,
 }
 
 static void t7xx_dpmaif_dl_set_bat_base_addr(struct dpmaif_hw_info *hw_info,
-					     unsigned char q_num, dma_addr_t addr)
+					     dma_addr_t addr)
 {
 	iowrite32(lower_32_bits(addr), hw_info->pcie_base + DPMAIF_DL_BAT_INIT_CON0);
 	iowrite32(upper_32_bits(addr), hw_info->pcie_base + DPMAIF_DL_BAT_INIT_CON3);
 }
 
-static void t7xx_dpmaif_dl_set_bat_size(struct dpmaif_hw_info *hw_info,
-					unsigned char q_num, unsigned int size)
+static void t7xx_dpmaif_dl_set_bat_size(struct dpmaif_hw_info *hw_info, unsigned int size)
 {
 	unsigned int value;
 
@@ -561,7 +559,7 @@ static void t7xx_dpmaif_dl_set_bat_size(struct dpmaif_hw_info *hw_info,
 	iowrite32(value, hw_info->pcie_base + DPMAIF_DL_BAT_INIT_CON1);
 }
 
-static void t7xx_dpmaif_dl_bat_en(struct dpmaif_hw_info *hw_info, unsigned char q_num, bool enable)
+static void t7xx_dpmaif_dl_bat_en(struct dpmaif_hw_info *hw_info, bool enable)
 {
 	unsigned int value;
 
@@ -628,7 +626,7 @@ static void t7xx_dpmaif_dl_set_ao_bat_rsv_length(struct dpmaif_hw_info *hw_info)
 
 	value = ioread32(hw_info->pcie_base + DPMAIF_AO_DL_PKTINFO_CON2);
 	value &= ~DPMAIF_BAT_RSV_LEN_MSK;
-	value |= DPMAIF_HW_BAT_RSVLEN & DPMAIF_BAT_RSV_LEN_MSK;
+	value |= DPMAIF_HW_BAT_RSVLEN;
 	iowrite32(value, hw_info->pcie_base + DPMAIF_AO_DL_PKTINFO_CON2);
 }
 
@@ -657,7 +655,7 @@ static void t7xx_dpmaif_dl_set_ao_frg_check_thres(struct dpmaif_hw_info *hw_info
 
 	value = ioread32(hw_info->pcie_base + DPMAIF_AO_DL_RDY_CHK_FRG_THRES);
 	value &= ~DPMAIF_FRG_CHECK_THRES_MSK;
-	value |= (DPMAIF_HW_CHK_FRG_NUM & DPMAIF_FRG_CHECK_THRES_MSK);
+	value |= DPMAIF_HW_CHK_FRG_NUM;
 	iowrite32(value, hw_info->pcie_base + DPMAIF_AO_DL_RDY_CHK_FRG_THRES);
 }
 
@@ -672,8 +670,7 @@ static void t7xx_dpmaif_dl_set_ao_frg_bufsz(struct dpmaif_hw_info *hw_info)
 	iowrite32(value, hw_info->pcie_base + DPMAIF_AO_DL_RDY_CHK_FRG_THRES);
 }
 
-static void t7xx_dpmaif_dl_frg_ao_en(struct dpmaif_hw_info *hw_info, unsigned char q_num,
-				     bool enable)
+static void t7xx_dpmaif_dl_frg_ao_en(struct dpmaif_hw_info *hw_info, bool enable)
 {
 	unsigned int value;
 
@@ -703,19 +700,18 @@ static void t7xx_dpmaif_dl_set_pit_seqnum(struct dpmaif_hw_info *hw_info)
 
 	value = ioread32(hw_info->pcie_base + DPMAIF_AO_DL_PIT_SEQ_END);
 	value &= ~DPMAIF_DL_PIT_SEQ_MSK;
-	value |= DPMAIF_DL_PIT_SEQ_VALUE & DPMAIF_DL_PIT_SEQ_MSK;
+	value |= DPMAIF_DL_PIT_SEQ_VALUE;
 	iowrite32(value, hw_info->pcie_base + DPMAIF_AO_DL_PIT_SEQ_END);
 }
 
 static void t7xx_dpmaif_dl_set_dlq_pit_base_addr(struct dpmaif_hw_info *hw_info,
-						 unsigned char q_num, dma_addr_t addr)
+						 dma_addr_t addr)
 {
 	iowrite32(lower_32_bits(addr), hw_info->pcie_base + DPMAIF_DL_DLQPIT_INIT_CON0);
 	iowrite32(upper_32_bits(addr), hw_info->pcie_base + DPMAIF_DL_DLQPIT_INIT_CON4);
 }
 
-static void t7xx_dpmaif_dl_set_dlq_pit_size(struct dpmaif_hw_info *hw_info,
-					    unsigned char q_num, unsigned int size)
+static void t7xx_dpmaif_dl_set_dlq_pit_size(struct dpmaif_hw_info *hw_info, unsigned int size)
 {
 	unsigned int value;
 
@@ -729,7 +725,7 @@ static void t7xx_dpmaif_dl_set_dlq_pit_size(struct dpmaif_hw_info *hw_info,
 	iowrite32(0, hw_info->pcie_base + DPMAIF_DL_DLQPIT_INIT_CON6);
 }
 
-static void t7xx_dpmaif_dl_dlq_pit_en(struct dpmaif_hw_info *hw_info, unsigned char q_num)
+static void t7xx_dpmaif_dl_dlq_pit_en(struct dpmaif_hw_info *hw_info)
 {
 	unsigned int value;
 
@@ -739,7 +735,7 @@ static void t7xx_dpmaif_dl_dlq_pit_en(struct dpmaif_hw_info *hw_info, unsigned c
 }
 
 static void t7xx_dpmaif_dl_dlq_pit_init_done(struct dpmaif_hw_info *hw_info,
-					     unsigned char q_num, unsigned int pit_idx)
+					     unsigned int pit_idx)
 {
 	unsigned int dl_pit_init;
 	int timeout;
@@ -767,15 +763,13 @@ static void t7xx_dpmaif_dl_dlq_pit_init_done(struct dpmaif_hw_info *hw_info,
 		dev_err(hw_info->dev, "Data plane modem DL PIT initialization failed\n");
 }
 
-static void t7xx_dpmaif_config_dlq_pit_hw(struct dpmaif_hw_info *hw_info, unsigned char q_num,
+static void t7xx_dpmaif_config_dlq_pit_hw(struct dpmaif_hw_info *hw_info, unsigned int q_num,
 					  struct dpmaif_dl *dl_que)
 {
-	unsigned int pit_idx = q_num;
-
-	t7xx_dpmaif_dl_set_dlq_pit_base_addr(hw_info, q_num, dl_que->pit_base);
-	t7xx_dpmaif_dl_set_dlq_pit_size(hw_info, q_num, dl_que->pit_size_cnt);
-	t7xx_dpmaif_dl_dlq_pit_en(hw_info, q_num);
-	t7xx_dpmaif_dl_dlq_pit_init_done(hw_info, q_num, pit_idx);
+	t7xx_dpmaif_dl_set_dlq_pit_base_addr(hw_info, dl_que->pit_base);
+	t7xx_dpmaif_dl_set_dlq_pit_size(hw_info, dl_que->pit_size_cnt);
+	t7xx_dpmaif_dl_dlq_pit_en(hw_info);
+	t7xx_dpmaif_dl_dlq_pit_init_done(hw_info, q_num);
 }
 
 static void t7xx_dpmaif_config_all_dlq_hw(struct dpmaif_hw_info *hw_info)
@@ -819,12 +813,11 @@ static void t7xx_dpmaif_dl_all_q_en(struct dpmaif_hw_info *hw_info, bool enable)
 static int t7xx_dpmaif_config_dlq_hw(struct dpmaif_hw_info *hw_info)
 {
 	struct dpmaif_dl *dl_que;
-	unsigned int queue = 0; /* All queues share one BAT/frag BAT table */
 	int ret;
 
 	t7xx_dpmaif_dl_dlq_hpc_hw_init(hw_info);
 
-	dl_que = &hw_info->dl_que[queue];
+	dl_que = &hw_info->dl_que[0]; /* All queues share one BAT/frag BAT table */
 	if (!dl_que->que_started)
 		return -EBUSY;
 
@@ -839,21 +832,21 @@ static int t7xx_dpmaif_config_dlq_hw(struct dpmaif_hw_info *hw_info)
 	t7xx_dpmaif_dl_set_ao_pit_chknum(hw_info);
 	t7xx_dpmaif_dl_set_ao_bat_check_thres(hw_info);
 	t7xx_dpmaif_dl_set_ao_frg_check_thres(hw_info);
-	t7xx_dpmaif_dl_frg_ao_en(hw_info, queue, true);
+	t7xx_dpmaif_dl_frg_ao_en(hw_info, true);
 
-	t7xx_dpmaif_dl_set_bat_base_addr(hw_info, queue, dl_que->frg_base);
-	t7xx_dpmaif_dl_set_bat_size(hw_info, queue, dl_que->frg_size_cnt);
-	t7xx_dpmaif_dl_bat_en(hw_info, queue, true);
+	t7xx_dpmaif_dl_set_bat_base_addr(hw_info, dl_que->frg_base);
+	t7xx_dpmaif_dl_set_bat_size(hw_info, dl_que->frg_size_cnt);
+	t7xx_dpmaif_dl_bat_en(hw_info, true);
 
-	ret = t7xx_dpmaif_dl_bat_init_done(hw_info, queue, true);
+	ret = t7xx_dpmaif_dl_bat_init_done(hw_info, true);
 	if (ret)
 		return ret;
 
-	t7xx_dpmaif_dl_set_bat_base_addr(hw_info, queue, dl_que->bat_base);
-	t7xx_dpmaif_dl_set_bat_size(hw_info, queue, dl_que->bat_size_cnt);
-	t7xx_dpmaif_dl_bat_en(hw_info, queue, false);
+	t7xx_dpmaif_dl_set_bat_base_addr(hw_info, dl_que->bat_base);
+	t7xx_dpmaif_dl_set_bat_size(hw_info, dl_que->bat_size_cnt);
+	t7xx_dpmaif_dl_bat_en(hw_info, false);
 
-	ret = t7xx_dpmaif_dl_bat_init_done(hw_info, queue, false);
+	ret = t7xx_dpmaif_dl_bat_init_done(hw_info, false);
 	if (ret)
 		return ret;
 
@@ -865,7 +858,7 @@ static int t7xx_dpmaif_config_dlq_hw(struct dpmaif_hw_info *hw_info)
 }
 
 static void t7xx_dpmaif_ul_update_drb_size(struct dpmaif_hw_info *hw_info,
-					   unsigned char q_num, unsigned int size)
+					   unsigned int q_num, unsigned int size)
 {
 	unsigned int value;
 
@@ -876,14 +869,14 @@ static void t7xx_dpmaif_ul_update_drb_size(struct dpmaif_hw_info *hw_info,
 }
 
 static void t7xx_dpmaif_ul_update_drb_base_addr(struct dpmaif_hw_info *hw_info,
-						unsigned char q_num, dma_addr_t addr)
+						unsigned int q_num, dma_addr_t addr)
 {
 	iowrite32(lower_32_bits(addr), hw_info->pcie_base + DPMAIF_ULQSAR_n(q_num));
 	iowrite32(upper_32_bits(addr), hw_info->pcie_base + DPMAIF_UL_DRB_ADDRH_n(q_num));
 }
 
 static void t7xx_dpmaif_ul_rdy_en(struct dpmaif_hw_info *hw_info,
-				  unsigned char q_num, bool ready)
+				  unsigned int q_num, bool ready)
 {
 	u32 value;
 
@@ -898,7 +891,7 @@ static void t7xx_dpmaif_ul_rdy_en(struct dpmaif_hw_info *hw_info,
 }
 
 static void t7xx_dpmaif_ul_arb_en(struct dpmaif_hw_info *hw_info,
-				  unsigned char q_num, bool enable)
+				  unsigned int q_num, bool enable)
 {
 	u32 value;
 
@@ -977,37 +970,33 @@ static bool t7xx_dpmaif_ul_idle_check(struct dpmaif_hw_info *hw_info)
 	return !(dpmaif_ul_is_busy & DPMAIF_UL_IDLE_STS);
 }
 
-int t7xx_dpmaif_ul_update_hw_drb_cnt(struct dpmaif_hw_info *hw_info, unsigned char q_num,
-				     unsigned int drb_entry_cnt)
+void t7xx_dpmaif_ul_update_hw_drb_cnt(struct dpmaif_hw_info *hw_info, unsigned int q_num,
+				      unsigned int drb_entry_cnt)
 {
 	u32 ul_update, value;
-	int ret;
+	int err;
 
 	ul_update = drb_entry_cnt & DPMAIF_UL_ADD_COUNT_MASK;
 	ul_update |= DPMAIF_UL_ADD_UPDATE;
 
-	ret = ioread32_poll_timeout_atomic(hw_info->pcie_base + DPMAIF_ULQ_ADD_DESC_CH_n(q_num),
+	err = ioread32_poll_timeout_atomic(hw_info->pcie_base + DPMAIF_ULQ_ADD_DESC_CH_n(q_num),
 					   value, !(value & DPMAIF_UL_ADD_NOT_READY), 0,
 					   DPMAIF_CHECK_TIMEOUT_US);
-	if (ret) {
+	if (err) {
 		dev_err(hw_info->dev, "UL add is not ready\n");
-		return ret;
+		return;
 	}
 
 	iowrite32(ul_update, hw_info->pcie_base + DPMAIF_ULQ_ADD_DESC_CH_n(q_num));
 
-	ret = ioread32_poll_timeout_atomic(hw_info->pcie_base + DPMAIF_ULQ_ADD_DESC_CH_n(q_num),
+	err = ioread32_poll_timeout_atomic(hw_info->pcie_base + DPMAIF_ULQ_ADD_DESC_CH_n(q_num),
 					   value, !(value & DPMAIF_UL_ADD_NOT_READY), 0,
 					   DPMAIF_CHECK_TIMEOUT_US);
-	if (ret) {
+	if (err)
 		dev_err(hw_info->dev, "Timeout updating UL add\n");
-		return ret;
-	}
-
-	return 0;
 }
 
-unsigned int t7xx_dpmaif_ul_get_rd_idx(struct dpmaif_hw_info *hw_info, unsigned char q_num)
+unsigned int t7xx_dpmaif_ul_get_rd_idx(struct dpmaif_hw_info *hw_info, unsigned int q_num)
 {
 	unsigned int value = ioread32(hw_info->pcie_base + DPMAIF_ULQ_STA0_n(q_num));
 
@@ -1086,7 +1075,7 @@ int t7xx_dpmaif_dl_snd_hw_bat_cnt(struct dpmaif_hw_info *hw_info, unsigned int b
 	return 0;
 }
 
-unsigned int t7xx_dpmaif_dl_get_bat_rd_idx(struct dpmaif_hw_info *hw_info, unsigned char q_num)
+unsigned int t7xx_dpmaif_dl_get_bat_rd_idx(struct dpmaif_hw_info *hw_info, unsigned int q_num)
 {
 	u32 value;
 
@@ -1094,7 +1083,7 @@ unsigned int t7xx_dpmaif_dl_get_bat_rd_idx(struct dpmaif_hw_info *hw_info, unsig
 	return value & DPMAIF_DL_RD_WR_IDX_MSK;
 }
 
-unsigned int t7xx_dpmaif_dl_get_bat_wr_idx(struct dpmaif_hw_info *hw_info, unsigned char q_num)
+unsigned int t7xx_dpmaif_dl_get_bat_wr_idx(struct dpmaif_hw_info *hw_info, unsigned int q_num)
 {
 	u32 value;
 
@@ -1123,7 +1112,7 @@ int t7xx_dpmaif_dl_snd_hw_frg_cnt(struct dpmaif_hw_info *hw_info, unsigned int f
 	return 0;
 }
 
-unsigned int t7xx_dpmaif_dl_get_frg_rd_idx(struct dpmaif_hw_info *hw_info, unsigned char q_num)
+unsigned int t7xx_dpmaif_dl_get_frg_rd_idx(struct dpmaif_hw_info *hw_info, unsigned int q_num)
 {
 	u32 value;
 
@@ -1279,7 +1268,7 @@ int t7xx_dpmaif_hw_init(struct dpmaif_hw_info *hw_info, struct dpmaif_hw_params
 	return ret;
 }
 
-bool t7xx_dpmaif_ul_clr_done(struct dpmaif_hw_info *hw_info, unsigned char qno)
+bool t7xx_dpmaif_ul_clr_done(struct dpmaif_hw_info *hw_info, unsigned int qno)
 {
 	u32 intr_status;
 
diff --git a/drivers/net/wwan/t7xx/t7xx_dpmaif.h b/drivers/net/wwan/t7xx/t7xx_dpmaif.h
index 613551aca40b..ae292355a33d 100644
--- a/drivers/net/wwan/t7xx/t7xx_dpmaif.h
+++ b/drivers/net/wwan/t7xx/t7xx_dpmaif.h
@@ -7,7 +7,7 @@
  *  Amir Hanania <amir.hanania@intel.com>
  *  Haijun Liu <haijun.liu@mediatek.com>
  *  Moises Veleta <moises.veleta@intel.com>
- *  Ricardo Martinez<ricardo.martinez@linux.intel.com>
+ *  Ricardo Martinez <ricardo.martinez@linux.intel.com>
  *
  * Contributors:
  *  Chiranjeevi Rapolu <chiranjeevi.rapolu@intel.com>
@@ -154,25 +154,25 @@ void t7xx_dpmaif_start_hw(struct dpmaif_hw_info *hw_info);
 int t7xx_dpmaif_hw_get_intr_cnt(struct dpmaif_hw_info *hw_info,
 				struct dpmaif_hw_intr_st_para *para, int qno);
 void t7xx_dpmaif_unmask_ulq_intr(struct dpmaif_hw_info *hw_info, unsigned int q_num);
-int t7xx_dpmaif_ul_update_hw_drb_cnt(struct dpmaif_hw_info *hw_info, unsigned char q_num,
-				     unsigned int drb_entry_cnt);
+void t7xx_dpmaif_ul_update_hw_drb_cnt(struct dpmaif_hw_info *hw_info, unsigned int q_num,
+				      unsigned int drb_entry_cnt);
 int t7xx_dpmaif_dl_snd_hw_bat_cnt(struct dpmaif_hw_info *hw_info, unsigned int bat_entry_cnt);
 int t7xx_dpmaif_dl_snd_hw_frg_cnt(struct dpmaif_hw_info *hw_info, unsigned int frg_entry_cnt);
 int t7xx_dpmaif_dlq_add_pit_remain_cnt(struct dpmaif_hw_info *hw_info, unsigned int dlq_pit_idx,
 				       unsigned int pit_remain_cnt);
 void t7xx_dpmaif_dlq_unmask_pitcnt_len_err_intr(struct dpmaif_hw_info *hw_info,
-						unsigned char qno);
-void t7xx_dpmaif_dlq_unmask_rx_done(struct dpmaif_hw_info *hw_info, unsigned char qno);
-bool t7xx_dpmaif_ul_clr_done(struct dpmaif_hw_info *hw_info, unsigned char qno);
+						unsigned int qno);
+void t7xx_dpmaif_dlq_unmask_rx_done(struct dpmaif_hw_info *hw_info, unsigned int qno);
+bool t7xx_dpmaif_ul_clr_done(struct dpmaif_hw_info *hw_info, unsigned int qno);
 void t7xx_dpmaif_ul_clr_all_intr(struct dpmaif_hw_info *hw_info);
 void t7xx_dpmaif_dl_clr_all_intr(struct dpmaif_hw_info *hw_info);
 void t7xx_dpmaif_clr_ip_busy_sts(struct dpmaif_hw_info *hw_info);
 void t7xx_dpmaif_dl_unmask_batcnt_len_err_intr(struct dpmaif_hw_info *hw_info);
 void t7xx_dpmaif_dl_unmask_pitcnt_len_err_intr(struct dpmaif_hw_info *hw_info);
-unsigned int t7xx_dpmaif_ul_get_rd_idx(struct dpmaif_hw_info *hw_info, unsigned char q_num);
-unsigned int t7xx_dpmaif_dl_get_bat_rd_idx(struct dpmaif_hw_info *hw_info, unsigned char q_num);
-unsigned int t7xx_dpmaif_dl_get_bat_wr_idx(struct dpmaif_hw_info *hw_info, unsigned char q_num);
-unsigned int t7xx_dpmaif_dl_get_frg_rd_idx(struct dpmaif_hw_info *hw_info, unsigned char q_num);
+unsigned int t7xx_dpmaif_ul_get_rd_idx(struct dpmaif_hw_info *hw_info, unsigned int q_num);
+unsigned int t7xx_dpmaif_dl_get_bat_rd_idx(struct dpmaif_hw_info *hw_info, unsigned int q_num);
+unsigned int t7xx_dpmaif_dl_get_bat_wr_idx(struct dpmaif_hw_info *hw_info, unsigned int q_num);
+unsigned int t7xx_dpmaif_dl_get_frg_rd_idx(struct dpmaif_hw_info *hw_info, unsigned int q_num);
 unsigned int t7xx_dpmaif_dl_dlq_pit_get_wr_idx(struct dpmaif_hw_info *hw_info,
 					       unsigned int dlq_pit_idx);
 
diff --git a/drivers/net/wwan/t7xx/t7xx_hif_cldma.c b/drivers/net/wwan/t7xx/t7xx_hif_cldma.c
index 5c55f3584e87..e78995ecb63e 100644
--- a/drivers/net/wwan/t7xx/t7xx_hif_cldma.c
+++ b/drivers/net/wwan/t7xx/t7xx_hif_cldma.c
@@ -7,7 +7,7 @@
  *  Amir Hanania <amir.hanania@intel.com>
  *  Haijun Liu <haijun.liu@mediatek.com>
  *  Moises Veleta <moises.veleta@intel.com>
- *  Ricardo Martinez<ricardo.martinez@linux.intel.com>
+ *  Ricardo Martinez <ricardo.martinez@linux.intel.com>
  *  Sreehari Kancharla <sreehari.kancharla@intel.com>
  *
  * Contributors:
@@ -43,7 +43,6 @@
 #include <linux/workqueue.h>
 
 #include "t7xx_cldma.h"
-#include "t7xx_common.h"
 #include "t7xx_hif_cldma.h"
 #include "t7xx_mhccif.h"
 #include "t7xx_pci.h"
@@ -57,10 +56,10 @@
 #define CHECK_Q_STOP_TIMEOUT_US		1000000
 #define CHECK_Q_STOP_STEP_US		10000
 
-#define CLDMA_JUMBO_BUFFER		64528	/* 63kB + CCCI header */
+#define CLDMA_JUMBO_BUFF_SZ		64528	/* 63kB + CCCI header */
 
 static void md_cd_queue_struct_reset(struct cldma_queue *queue, struct cldma_ctrl *md_ctrl,
-				     enum mtk_txrx tx_rx, unsigned char index)
+				     enum mtk_txrx tx_rx, unsigned int index)
 {
 	queue->dir = tx_rx;
 	queue->index = index;
@@ -71,7 +70,7 @@ static void md_cd_queue_struct_reset(struct cldma_queue *queue, struct cldma_ctr
 }
 
 static void md_cd_queue_struct_init(struct cldma_queue *queue, struct cldma_ctrl *md_ctrl,
-				    enum mtk_txrx tx_rx, unsigned char index)
+				    enum mtk_txrx tx_rx, unsigned int index)
 {
 	md_cd_queue_struct_reset(queue, md_ctrl, tx_rx, index);
 	init_waitqueue_head(&queue->req_wq);
@@ -102,6 +101,11 @@ static void t7xx_cldma_rgpd_set_next_ptr(struct cldma_rgpd *rgpd, dma_addr_t nex
 	rgpd->next_gpd_ptr_l = cpu_to_le32(lower_32_bits(next_ptr));
 }
 
+static unsigned int t7xx_skb_data_area_size(struct sk_buff *skb)
+{
+	return skb_end_pointer(skb) - skb->data;
+}
+
 static int t7xx_cldma_alloc_and_map_skb(struct cldma_ctrl *md_ctrl, struct cldma_request *req,
 					size_t size)
 {
@@ -125,7 +129,7 @@ static int t7xx_cldma_alloc_and_map_skb(struct cldma_ctrl *md_ctrl, struct cldma
 static int t7xx_cldma_gpd_rx_from_q(struct cldma_queue *queue, int budget, bool *over_budget)
 {
 	struct cldma_ctrl *md_ctrl = queue->md_ctrl;
-	unsigned char hwo_polling_count = 0;
+	unsigned int hwo_polling_count = 0;
 	struct t7xx_cldma_hw *hw_info;
 	bool rx_not_done = true;
 	unsigned long flags;
@@ -455,6 +459,7 @@ static int t7xx_cldma_rx_ring_init(struct cldma_ctrl *md_ctrl, struct cldma_ring
 		list_add_tail(&req->entry, &ring->gpd_ring);
 	}
 
+	/* Link previous GPD to next GPD, circular */
 	list_for_each_entry(req, &ring->gpd_ring, entry) {
 		t7xx_cldma_rgpd_set_next_ptr(gpd, req->gpd_addr);
 		gpd = req->gpd;
@@ -502,6 +507,7 @@ static int t7xx_cldma_tx_ring_init(struct cldma_ctrl *md_ctrl, struct cldma_ring
 		list_add_tail(&req->entry, &ring->gpd_ring);
 	}
 
+	/* Link previous GPD to next GPD, circular */
 	list_for_each_entry(req, &ring->gpd_ring, entry) {
 		t7xx_cldma_tgpd_set_next_ptr(gpd, req->gpd_addr);
 		gpd = req->gpd;
@@ -885,7 +891,7 @@ static int t7xx_cldma_gpd_handle_tx_request(struct cldma_queue *queue, struct cl
 }
 
 /* Called with cldma_lock */
-static void t7xx_cldma_hw_start_send(struct cldma_ctrl *md_ctrl, u8 qno,
+static void t7xx_cldma_hw_start_send(struct cldma_ctrl *md_ctrl, int qno,
 				     struct cldma_request *prev_req)
 {
 	struct t7xx_cldma_hw *hw_info = &md_ctrl->hw_info;
@@ -929,7 +935,7 @@ void t7xx_cldma_set_recv_skb(struct cldma_ctrl *md_ctrl,
  * * -ENOMEM	- Allocation failure.
  * * -EINVAL	- Invalid queue request.
  * * -EIO	- Queue is not active.
- * * -EBUSY	- Resource lock failure.
+ * * -ETIMEDOUT	- Timeout waiting for the device to wake up.
  */
 int t7xx_cldma_send_skb(struct cldma_ctrl *md_ctrl, int qno, struct sk_buff *skb)
 {
@@ -968,7 +974,7 @@ int t7xx_cldma_send_skb(struct cldma_ctrl *md_ctrl, int qno, struct sk_buff *skb
 			spin_unlock_irqrestore(&queue->ring_lock, flags);
 
 			if (!t7xx_pci_sleep_disable_complete(md_ctrl->t7xx_dev)) {
-				ret = -EBUSY;
+				ret = -ETIMEDOUT;
 				break;
 			}
 
@@ -985,7 +991,7 @@ int t7xx_cldma_send_skb(struct cldma_ctrl *md_ctrl, int qno, struct sk_buff *skb
 		spin_unlock_irqrestore(&queue->ring_lock, flags);
 
 		if (!t7xx_pci_sleep_disable_complete(md_ctrl->t7xx_dev)) {
-			ret = -EBUSY;
+			ret = -ETIMEDOUT;
 			break;
 		}
 
@@ -1036,7 +1042,7 @@ static int t7xx_cldma_late_init(struct cldma_ctrl *md_ctrl)
 		md_ctrl->rx_ring[j].pkt_size = CLDMA_MTU;
 
 		if (j == CLDMA_RXQ_NUM - 1)
-			md_ctrl->rx_ring[j].pkt_size = CLDMA_JUMBO_BUFFER;
+			md_ctrl->rx_ring[j].pkt_size = CLDMA_JUMBO_BUFF_SZ;
 
 		ret = t7xx_cldma_rx_ring_init(md_ctrl, &md_ctrl->rx_ring[j]);
 		if (ret) {
diff --git a/drivers/net/wwan/t7xx/t7xx_hif_cldma.h b/drivers/net/wwan/t7xx/t7xx_hif_cldma.h
index 38210fa9cc19..e286cbbef626 100644
--- a/drivers/net/wwan/t7xx/t7xx_hif_cldma.h
+++ b/drivers/net/wwan/t7xx/t7xx_hif_cldma.h
@@ -6,7 +6,7 @@
  * Authors:
  *  Haijun Liu <haijun.liu@mediatek.com>
  *  Moises Veleta <moises.veleta@intel.com>
- *  Ricardo Martinez<ricardo.martinez@linux.intel.com>
+ *  Ricardo Martinez <ricardo.martinez@linux.intel.com>
  *  Sreehari Kancharla <sreehari.kancharla@intel.com>
  *
  * Contributors:
@@ -29,7 +29,6 @@
 #include <linux/types.h>
 
 #include "t7xx_cldma.h"
-#include "t7xx_common.h"
 #include "t7xx_pci.h"
 
 /**
@@ -61,7 +60,7 @@ struct cldma_ring {
 struct cldma_queue {
 	struct cldma_ctrl *md_ctrl;
 	enum mtk_txrx dir;
-	unsigned char index;
+	unsigned int index;
 	struct cldma_ring *tr_ring;
 	struct cldma_request *tr_done;
 	struct cldma_request *rx_refill;
diff --git a/drivers/net/wwan/t7xx/t7xx_hif_dpmaif.c b/drivers/net/wwan/t7xx/t7xx_hif_dpmaif.c
index 76f5f802083a..7eff3531b9a5 100644
--- a/drivers/net/wwan/t7xx/t7xx_hif_dpmaif.c
+++ b/drivers/net/wwan/t7xx/t7xx_hif_dpmaif.c
@@ -7,7 +7,7 @@
  *  Amir Hanania <amir.hanania@intel.com>
  *  Haijun Liu <haijun.liu@mediatek.com>
  *  Moises Veleta <moises.veleta@intel.com>
- *  Ricardo Martinez<ricardo.martinez@linux.intel.com>
+ *  Ricardo Martinez <ricardo.martinez@linux.intel.com>
  *
  * Contributors:
  *  Chiranjeevi Rapolu <chiranjeevi.rapolu@intel.com>
@@ -24,13 +24,13 @@
 #include <linux/wait.h>
 #include <linux/workqueue.h>
 
-#include "t7xx_common.h"
 #include "t7xx_dpmaif.h"
 #include "t7xx_hif_dpmaif.h"
 #include "t7xx_hif_dpmaif_rx.h"
 #include "t7xx_hif_dpmaif_tx.h"
 #include "t7xx_pci.h"
 #include "t7xx_pcie_mac.h"
+#include "t7xx_state_monitor.h"
 
 unsigned int t7xx_ring_buf_get_next_wr_idx(unsigned int buf_len, unsigned int buf_idx)
 {
@@ -482,7 +482,7 @@ static int t7xx_dpmaif_pm_entity_release(struct dpmaif_ctrl *dpmaif_ctrl)
 	return ret;
 }
 
-int t7xx_dpmaif_md_state_callback(struct dpmaif_ctrl *dpmaif_ctrl, unsigned char state)
+int t7xx_dpmaif_md_state_callback(struct dpmaif_ctrl *dpmaif_ctrl, enum md_state state)
 {
 	int ret = 0;
 
diff --git a/drivers/net/wwan/t7xx/t7xx_hif_dpmaif.h b/drivers/net/wwan/t7xx/t7xx_hif_dpmaif.h
index f86785ae2481..e576f12fe2d6 100644
--- a/drivers/net/wwan/t7xx/t7xx_hif_dpmaif.h
+++ b/drivers/net/wwan/t7xx/t7xx_hif_dpmaif.h
@@ -7,7 +7,7 @@
  *  Amir Hanania <amir.hanania@intel.com>
  *  Haijun Liu <haijun.liu@mediatek.com>
  *  Moises Veleta <moises.veleta@intel.com>
- *  Ricardo Martinez<ricardo.martinez@linux.intel.com>
+ *  Ricardo Martinez <ricardo.martinez@linux.intel.com>
  *
  * Contributors:
  *  Chiranjeevi Rapolu <chiranjeevi.rapolu@intel.com>
@@ -15,21 +15,21 @@
  *  Sreehari Kancharla <sreehari.kancharla@intel.com>
  */
 
-#ifndef __T7XX_DPMA_TX_H__
-#define __T7XX_DPMA_TX_H__
+#ifndef __T7XX_HIF_DPMAIF_H__
+#define __T7XX_HIF_DPMAIF_H__
 
+#include <linux/bitmap.h>
 #include <linux/mm_types.h>
 #include <linux/sched.h>
 #include <linux/skbuff.h>
 #include <linux/spinlock.h>
 #include <linux/types.h>
-#include <linux/workqueue.h>
 #include <linux/wait.h>
-#include <linux/bitmap.h>
+#include <linux/workqueue.h>
 
-#include "t7xx_common.h"
-#include "t7xx_pci.h"
 #include "t7xx_dpmaif.h"
+#include "t7xx_pci.h"
+#include "t7xx_state_monitor.h"
 
 /* SKB control buffer */
 struct t7xx_skb_cb {
@@ -83,10 +83,9 @@ struct dpmaif_bat_request {
 	void			*bat_base;
 	dma_addr_t		bat_bus_addr;
 	unsigned int		bat_size_cnt;
-	unsigned short		bat_wr_idx;
-	unsigned short		bat_release_rd_idx;
+	unsigned int		bat_wr_idx;
+	unsigned int		bat_release_rd_idx;
 	void			*bat_skb;
-	unsigned int		skb_pkt_cnt;
 	unsigned int		pkt_buf_sz;
 	unsigned long		*bat_bitmap;
 	atomic_t		refcnt;
@@ -95,7 +94,7 @@ struct dpmaif_bat_request {
 };
 
 struct dpmaif_rx_queue {
-	unsigned char		index;
+	unsigned int		index;
 	bool			que_started;
 	unsigned int		budget;
 
@@ -103,9 +102,9 @@ struct dpmaif_rx_queue {
 	dma_addr_t		pit_bus_addr;
 	unsigned int		pit_size_cnt;
 
-	unsigned short		pit_rd_idx;
-	unsigned short		pit_wr_idx;
-	unsigned short		pit_release_rd_idx;
+	unsigned int		pit_rd_idx;
+	unsigned int		pit_wr_idx;
+	unsigned int		pit_release_rd_idx;
 
 	struct dpmaif_bat_request *bat_req;
 	struct dpmaif_bat_request *bat_frag;
@@ -127,15 +126,15 @@ struct dpmaif_rx_queue {
 };
 
 struct dpmaif_tx_queue {
-	unsigned char		index;
+	unsigned int		index;
 	bool			que_started;
 	atomic_t		tx_budget;
 	void			*drb_base;
 	dma_addr_t		drb_bus_addr;
 	unsigned int		drb_size_cnt;
-	unsigned short		drb_wr_idx;
-	unsigned short		drb_rd_idx;
-	unsigned short		drb_release_rd_idx;
+	unsigned int		drb_wr_idx;
+	unsigned int		drb_rd_idx;
+	unsigned int		drb_release_rd_idx;
 	void			*drb_skb_base;
 	wait_queue_head_t	req_wq;
 	struct workqueue_struct	*worker;
@@ -144,9 +143,7 @@ struct dpmaif_tx_queue {
 	atomic_t		tx_processing;
 
 	struct dpmaif_ctrl	*dpmaif_ctrl;
-	spinlock_t		tx_skb_lock; /* Protects TX thread skb list */
-	struct list_head	tx_skb_queue;
-	unsigned int		tx_submit_skb_cnt;
+	struct sk_buff_head	tx_skb_head;
 	unsigned int		tx_list_max_len;
 	unsigned int		tx_skb_stat;
 };
@@ -203,9 +200,9 @@ struct dpmaif_ctrl {
 struct dpmaif_ctrl *t7xx_dpmaif_hif_init(struct t7xx_pci_dev *t7xx_dev,
 					 struct dpmaif_callbacks *callbacks);
 void t7xx_dpmaif_hif_exit(struct dpmaif_ctrl *dpmaif_ctrl);
-int t7xx_dpmaif_md_state_callback(struct dpmaif_ctrl *dpmaif_ctrl, unsigned char state);
+int t7xx_dpmaif_md_state_callback(struct dpmaif_ctrl *dpmaif_ctrl, enum md_state state);
 unsigned int t7xx_ring_buf_get_next_wr_idx(unsigned int buf_len, unsigned int buf_idx);
 unsigned int t7xx_ring_buf_rd_wr_count(unsigned int total_cnt, unsigned int rd_idx,
 				       unsigned int wr_idx, enum dpmaif_rdwr);
 
-#endif /* __T7XX_DPMA_TX_H__ */
+#endif /* __T7XX_HIF_DPMAIF_H__ */
diff --git a/drivers/net/wwan/t7xx/t7xx_hif_dpmaif_rx.c b/drivers/net/wwan/t7xx/t7xx_hif_dpmaif_rx.c
index 89b4fb5188d3..57ec49f9fc11 100644
--- a/drivers/net/wwan/t7xx/t7xx_hif_dpmaif_rx.c
+++ b/drivers/net/wwan/t7xx/t7xx_hif_dpmaif_rx.c
@@ -8,7 +8,7 @@
  *  Haijun Liu <haijun.liu@mediatek.com>
  *  Eliot Lee <eliot.lee@intel.com>
  *  Moises Veleta <moises.veleta@intel.com>
- *  Ricardo Martinez<ricardo.martinez@linux.intel.com>
+ *  Ricardo Martinez <ricardo.martinez@linux.intel.com>
  *
  * Contributors:
  *  Andy Shevchenko <andriy.shevchenko@linux.intel.com>
@@ -66,13 +66,13 @@
 /* Buffer type */
 #define PKT_BUF_FRAG			1
 
-static unsigned int t7xx_normal_pit_bid(const struct dpmaif_normal_pit *pit_info)
+static unsigned int t7xx_normal_pit_bid(const struct dpmaif_pit *pit_info)
 {
 	u32 value;
 
-	value = FIELD_GET(NORMAL_PIT_H_BID, le32_to_cpu(pit_info->pit_footer));
+	value = FIELD_GET(PD_PIT_H_BID, le32_to_cpu(pit_info->pd.footer));
 	value <<= 13;
-	value += FIELD_GET(NORMAL_PIT_BUFFER_ID, le32_to_cpu(pit_info->pit_header));
+	value += FIELD_GET(PD_PIT_BUFFER_ID, le32_to_cpu(pit_info->header));
 	return value;
 }
 
@@ -114,11 +114,11 @@ static int t7xx_dpmaif_net_rx_push_thread(void *arg)
 }
 
 static int t7xx_dpmaif_update_bat_wr_idx(struct dpmaif_ctrl *dpmaif_ctrl,
-					 const unsigned char q_num, const unsigned int bat_cnt)
+					 const unsigned int q_num, const unsigned int bat_cnt)
 {
 	struct dpmaif_rx_queue *rxq = &dpmaif_ctrl->rxq[q_num];
-	unsigned short old_rl_idx, new_wr_idx, old_wr_idx;
 	struct dpmaif_bat_request *bat_req = rxq->bat_req;
+	unsigned int old_rl_idx, new_wr_idx, old_wr_idx;
 
 	if (!rxq->que_started) {
 		dev_err(dpmaif_ctrl->dev, "RX queue %d has not been started\n", rxq->index);
@@ -157,7 +157,7 @@ static bool t7xx_alloc_and_map_skb_info(const struct dpmaif_ctrl *dpmaif_ctrl,
 	if (!skb)
 		return false;
 
-	data_len = t7xx_skb_data_area_size(skb);
+	data_len = skb_end_pointer(skb) - skb->data;
 
 	data_bus_addr = dma_map_single(dpmaif_ctrl->dev, skb->data, data_len, DMA_FROM_DEVICE);
 	if (dma_mapping_error(dpmaif_ctrl->dev, data_bus_addr)) {
@@ -202,7 +202,7 @@ static void t7xx_unmap_bat_skb(struct device *dev, struct dpmaif_bat_skb *bat_sk
  */
 int t7xx_dpmaif_rx_buf_alloc(struct dpmaif_ctrl *dpmaif_ctrl,
 			     const struct dpmaif_bat_request *bat_req,
-			     const unsigned char q_num, const unsigned int buf_cnt,
+			     const unsigned int q_num, const unsigned int buf_cnt,
 			     const bool initial)
 {
 	unsigned int i, bat_cnt, bat_max_cnt, bat_start_idx;
@@ -275,7 +275,7 @@ static int t7xx_dpmaifq_release_pit_entry(struct dpmaif_rx_queue *rxq,
 					  const unsigned int rel_entry_num)
 {
 	struct dpmaif_hw_info *hw_info = &rxq->dpmaif_ctrl->hw_info;
-	unsigned short old_rel_idx, new_rel_idx, hw_wr_idx;
+	unsigned int old_rel_idx, new_rel_idx, hw_wr_idx;
 	int ret;
 
 	if (!rxq->que_started)
@@ -358,9 +358,8 @@ static void t7xx_unmap_bat_page(struct device *dev, struct dpmaif_bat_page *bat_
 int t7xx_dpmaif_rx_frag_alloc(struct dpmaif_ctrl *dpmaif_ctrl, struct dpmaif_bat_request *bat_req,
 			      const unsigned int buf_cnt, const bool initial)
 {
+	unsigned int buf_space, cur_bat_idx = bat_req->bat_wr_idx;
 	struct dpmaif_bat_page *bat_skb = bat_req->bat_skb;
-	unsigned short cur_bat_idx = bat_req->bat_wr_idx;
-	unsigned int buf_space;
 	int ret = 0, i;
 
 	if (!buf_cnt || buf_cnt > bat_req->bat_size_cnt)
@@ -430,7 +429,7 @@ int t7xx_dpmaif_rx_frag_alloc(struct dpmaif_ctrl *dpmaif_ctrl, struct dpmaif_bat
 }
 
 static int t7xx_dpmaif_set_frag_to_skb(const struct dpmaif_rx_queue *rxq,
-				       const struct dpmaif_normal_pit *pkt_info,
+				       const struct dpmaif_pit *pkt_info,
 				       struct sk_buff *skb)
 {
 	unsigned long long data_bus_addr, data_base_addr;
@@ -446,12 +445,12 @@ static int t7xx_dpmaif_set_frag_to_skb(const struct dpmaif_rx_queue *rxq,
 	if (!page_info->page)
 		return -EINVAL;
 
-	data_bus_addr = le32_to_cpu(pkt_info->data_addr_ext);
-	data_bus_addr = (data_bus_addr << 32) + le32_to_cpu(pkt_info->p_data_addr);
+	data_bus_addr = le32_to_cpu(pkt_info->pd.data_addr_h);
+	data_bus_addr = (data_bus_addr << 32) + le32_to_cpu(pkt_info->pd.data_addr_l);
 	data_base_addr = page_info->data_bus_addr;
 	data_offset = data_bus_addr - data_base_addr;
 	data_offset += page_info->offset;
-	data_len = FIELD_GET(NORMAL_PIT_DATA_LEN, le32_to_cpu(pkt_info->pit_header));
+	data_len = FIELD_GET(PD_PIT_DATA_LEN, le32_to_cpu(pkt_info->header));
 	skb_add_rx_frag(skb, skb_shinfo(skb)->nr_frags, page_info->page,
 			data_offset, data_len, page_info->data_len);
 
@@ -462,7 +461,7 @@ static int t7xx_dpmaif_set_frag_to_skb(const struct dpmaif_rx_queue *rxq,
 }
 
 static int t7xx_dpmaif_get_frag(struct dpmaif_rx_queue *rxq,
-				const struct dpmaif_normal_pit *pkt_info,
+				const struct dpmaif_pit *pkt_info,
 				const struct dpmaif_cur_rx_skb_info *skb_info)
 {
 	unsigned int cur_bid = t7xx_normal_pit_bid(pkt_info);
@@ -493,13 +492,13 @@ static int t7xx_bat_cur_bid_check(struct dpmaif_rx_queue *rxq, const unsigned in
 	return 0;
 }
 
-static int t7xx_dpmaif_read_pit_seq(const struct dpmaif_normal_pit *pit)
+static int t7xx_dpmaif_read_pit_seq(const struct dpmaif_pit *pit)
 {
-	return FIELD_GET(NORMAL_PIT_PIT_SEQ, le32_to_cpu(pit->pit_footer));
+	return FIELD_GET(PD_PIT_PIT_SEQ, le32_to_cpu(pit->pd.footer));
 }
 
 static int t7xx_dpmaif_check_pit_seq(struct dpmaif_rx_queue *rxq,
-				     const struct dpmaif_normal_pit *pit)
+				     const struct dpmaif_pit *pit)
 {
 	unsigned int cur_pit_seq, expect_pit_seq = rxq->expect_pit_seq;
 
@@ -541,10 +540,9 @@ static int t7xx_dpmaif_release_bat_entry(const struct dpmaif_rx_queue *rxq,
 					 const enum bat_type buf_type)
 {
 	struct dpmaif_hw_info *hw_info = &rxq->dpmaif_ctrl->hw_info;
-	unsigned short old_rel_idx, new_rel_idx, hw_rd_idx;
+	unsigned int old_rel_idx, new_rel_idx, hw_rd_idx, i;
 	struct dpmaif_bat_request *bat;
 	unsigned long flags;
-	unsigned int i;
 
 	if (!rxq->que_started || !rel_entry_num)
 		return -EINVAL;
@@ -649,17 +647,19 @@ static int t7xx_dpmaif_frag_bat_release_and_add(const struct dpmaif_rx_queue *rx
 }
 
 static void t7xx_dpmaif_parse_msg_pit(const struct dpmaif_rx_queue *rxq,
-				      const struct dpmaif_msg_pit *msg_pit,
+				      const struct dpmaif_pit *msg_pit,
 				      struct dpmaif_cur_rx_skb_info *skb_info)
 {
-	skb_info->cur_chn_idx = FIELD_GET(MSG_PIT_CHANNEL_ID, le32_to_cpu(msg_pit->dword1));
-	skb_info->check_sum = FIELD_GET(MSG_PIT_CHECKSUM, le32_to_cpu(msg_pit->dword1));
-	skb_info->pit_dp = FIELD_GET(MSG_PIT_DP, le32_to_cpu(msg_pit->dword1));
-	skb_info->pkt_type = FIELD_GET(MSG_PIT_IP, le32_to_cpu(msg_pit->dword4));
+	int header = le32_to_cpu(msg_pit->header);
+
+	skb_info->cur_chn_idx = FIELD_GET(MSG_PIT_CHANNEL_ID, header);
+	skb_info->check_sum = FIELD_GET(MSG_PIT_CHECKSUM, header);
+	skb_info->pit_dp = FIELD_GET(MSG_PIT_DP, header);
+	skb_info->pkt_type = FIELD_GET(MSG_PIT_IP, le32_to_cpu(msg_pit->msg.params_3));
 }
 
 static int t7xx_dpmaif_set_data_to_skb(const struct dpmaif_rx_queue *rxq,
-				       const struct dpmaif_normal_pit *pkt_info,
+				       const struct dpmaif_pit *pkt_info,
 				       struct dpmaif_cur_rx_skb_info *skb_info)
 {
 	unsigned long long data_bus_addr, data_base_addr;
@@ -673,11 +673,11 @@ static int t7xx_dpmaif_set_data_to_skb(const struct dpmaif_rx_queue *rxq,
 	bat_skb += t7xx_normal_pit_bid(pkt_info);
 	dma_unmap_single(dev, bat_skb->data_bus_addr, bat_skb->data_len, DMA_FROM_DEVICE);
 
-	data_bus_addr = le32_to_cpu(pkt_info->data_addr_ext);
-	data_bus_addr = (data_bus_addr << 32) + le32_to_cpu(pkt_info->p_data_addr);
+	data_bus_addr = le32_to_cpu(pkt_info->pd.data_addr_h);
+	data_bus_addr = (data_bus_addr << 32) + le32_to_cpu(pkt_info->pd.data_addr_l);
 	data_base_addr = bat_skb->data_bus_addr;
 	data_offset = data_bus_addr - data_base_addr;
-	data_len = FIELD_GET(NORMAL_PIT_DATA_LEN, le32_to_cpu(pkt_info->pit_header));
+	data_len = FIELD_GET(PD_PIT_DATA_LEN, le32_to_cpu(pkt_info->header));
 	skb = bat_skb->skb;
 	skb->len = 0;
 	skb_reset_tail_pointer(skb);
@@ -695,7 +695,7 @@ static int t7xx_dpmaif_set_data_to_skb(const struct dpmaif_rx_queue *rxq,
 }
 
 static int t7xx_dpmaif_get_rx_pkt(struct dpmaif_rx_queue *rxq,
-				  const struct dpmaif_normal_pit *pkt_info,
+				  const struct dpmaif_pit *pkt_info,
 				  struct dpmaif_cur_rx_skb_info *skb_info)
 {
 	unsigned int cur_bid = t7xx_normal_pit_bid(pkt_info);
@@ -777,28 +777,27 @@ static int t7xx_dpmaif_rx_start(struct dpmaif_rx_queue *rxq, const unsigned int
 	cur_pit = rxq->pit_rd_idx;
 
 	for (rx_cnt = 0; rx_cnt < pit_cnt; rx_cnt++) {
-		struct dpmaif_normal_pit *pkt_info;
+		struct dpmaif_pit *pkt_info;
 		u32 val;
 
 		if (!skb_info->msg_pit_received && time_after_eq(jiffies, timeout))
 			break;
 
-		pkt_info = (struct dpmaif_normal_pit *)rxq->pit_base + cur_pit;
+		pkt_info = (struct dpmaif_pit *)rxq->pit_base + cur_pit;
 		if (t7xx_dpmaif_check_pit_seq(rxq, pkt_info)) {
 			dev_err_ratelimited(dev, "RXQ%u checks PIT SEQ fail\n", rxq->index);
 			return -EAGAIN;
 		}
 
-		val = FIELD_GET(NORMAL_PIT_PACKET_TYPE, le32_to_cpu(pkt_info->pit_header));
+		val = FIELD_GET(PD_PIT_PACKET_TYPE, le32_to_cpu(pkt_info->header));
 		if (val == DES_PT_MSG) {
 			if (skb_info->msg_pit_received)
 				dev_err(dev, "RXQ%u received repeated PIT\n", rxq->index);
 
 			skb_info->msg_pit_received = true;
-			t7xx_dpmaif_parse_msg_pit(rxq, (struct dpmaif_msg_pit *)pkt_info,
-						  skb_info);
+			t7xx_dpmaif_parse_msg_pit(rxq, pkt_info, skb_info);
 		} else { /* DES_PT_PD */
-			val = FIELD_GET(NORMAL_PIT_BUFFER_TYPE, le32_to_cpu(pkt_info->pit_header));
+			val = FIELD_GET(PD_PIT_BUFFER_TYPE, le32_to_cpu(pkt_info->header));
 			if (val != PKT_BUF_FRAG)
 				ret = t7xx_dpmaif_get_rx_pkt(rxq, pkt_info, skb_info);
 			else if (!skb_info->cur_skb)
@@ -811,7 +810,7 @@ static int t7xx_dpmaif_rx_start(struct dpmaif_rx_queue *rxq, const unsigned int
 				dev_err_ratelimited(dev, "RXQ%u error payload\n", rxq->index);
 			}
 
-			val = FIELD_GET(NORMAL_PIT_CONT, le32_to_cpu(pkt_info->pit_header));
+			val = FIELD_GET(PD_PIT_CONT, le32_to_cpu(pkt_info->header));
 			if (!val) {
 				if (!skb_info->err_payload) {
 					t7xx_dpmaif_rx_skb(rxq, skb_info);
@@ -868,7 +867,7 @@ static unsigned int t7xx_dpmaifq_poll_pit(struct dpmaif_rx_queue *rxq)
 }
 
 static int t7xx_dpmaif_rx_data_collect(struct dpmaif_ctrl *dpmaif_ctrl,
-				       const unsigned char q_num, const unsigned int budget)
+				       const unsigned int q_num, const unsigned int budget)
 {
 	struct dpmaif_rx_queue *rxq = &dpmaif_ctrl->rxq[q_num];
 	unsigned long time_limit;
@@ -880,7 +879,7 @@ static int t7xx_dpmaif_rx_data_collect(struct dpmaif_ctrl *dpmaif_ctrl,
 		unsigned int rd_cnt;
 		int real_cnt;
 
-		rd_cnt = min_t(unsigned int, cnt, budget);
+		rd_cnt = min(cnt, budget);
 
 		real_cnt = t7xx_dpmaif_rx_start(rxq, rd_cnt, time_limit);
 		if (real_cnt < 0)
@@ -991,7 +990,6 @@ int t7xx_dpmaif_bat_alloc(const struct dpmaif_ctrl *dpmaif_ctrl, struct dpmaif_b
 		bat_req->pkt_buf_sz = DPMAIF_HW_BAT_PKTBUF;
 	}
 
-	bat_req->skb_pkt_cnt = bat_req->bat_size_cnt;
 	bat_req->type = buf_type;
 	bat_req->bat_wr_idx = 0;
 	bat_req->bat_release_rd_idx = 0;
@@ -1003,7 +1001,7 @@ int t7xx_dpmaif_bat_alloc(const struct dpmaif_ctrl *dpmaif_ctrl, struct dpmaif_b
 		return -ENOMEM;
 
 	/* For AP SW to record skb information */
-	bat_req->bat_skb = devm_kzalloc(dpmaif_ctrl->dev, bat_req->skb_pkt_cnt * sw_buf_size,
+	bat_req->bat_skb = devm_kzalloc(dpmaif_ctrl->dev, bat_req->bat_size_cnt * sw_buf_size,
 					GFP_KERNEL);
 	if (!bat_req->bat_skb)
 		goto err_free_dma_mem;
@@ -1055,7 +1053,7 @@ static int t7xx_dpmaif_rx_alloc(struct dpmaif_rx_queue *rxq)
 	memset(&rxq->rx_data_info, 0, sizeof(rxq->rx_data_info));
 
 	rxq->pit_base = dma_alloc_coherent(rxq->dpmaif_ctrl->dev,
-					   rxq->pit_size_cnt * sizeof(struct dpmaif_normal_pit),
+					   rxq->pit_size_cnt * sizeof(struct dpmaif_pit),
 					   &rxq->pit_bus_addr, GFP_KERNEL | __GFP_ZERO);
 	if (!rxq->pit_base)
 		return -ENOMEM;
@@ -1078,7 +1076,7 @@ static void t7xx_dpmaif_rx_buf_free(const struct dpmaif_rx_queue *rxq)
 
 	if (rxq->pit_base)
 		dma_free_coherent(rxq->dpmaif_ctrl->dev,
-				  rxq->pit_size_cnt * sizeof(struct dpmaif_normal_pit),
+				  rxq->pit_size_cnt * sizeof(struct dpmaif_pit),
 				  rxq->pit_base, rxq->pit_bus_addr);
 }
 
@@ -1223,7 +1221,7 @@ static void t7xx_dpmaif_stop_rxq(struct dpmaif_rx_queue *rxq)
 		}
 	} while (cnt);
 
-	memset(rxq->pit_base, 0, rxq->pit_size_cnt * sizeof(struct dpmaif_normal_pit));
+	memset(rxq->pit_base, 0, rxq->pit_size_cnt * sizeof(struct dpmaif_pit));
 	memset(rxq->bat_req->bat_base, 0, rxq->bat_req->bat_size_cnt * sizeof(struct dpmaif_bat));
 	bitmap_zero(rxq->bat_req->bat_bitmap, rxq->bat_req->bat_size_cnt);
 	memset(&rxq->rx_data_info, 0, sizeof(rxq->rx_data_info));
diff --git a/drivers/net/wwan/t7xx/t7xx_hif_dpmaif_rx.h b/drivers/net/wwan/t7xx/t7xx_hif_dpmaif_rx.h
index e53d64b134e0..182f62dfe398 100644
--- a/drivers/net/wwan/t7xx/t7xx_hif_dpmaif_rx.h
+++ b/drivers/net/wwan/t7xx/t7xx_hif_dpmaif_rx.h
@@ -6,7 +6,7 @@
  * Authors:
  *  Haijun Liu <haijun.liu@mediatek.com>
  *  Eliot Lee <eliot.lee@intel.com>
- *  Ricardo Martinez<ricardo.martinez@linux.intel.com>
+ *  Ricardo Martinez <ricardo.martinez@linux.intel.com>
  *
  * Contributors:
  *  Amir Hanania <amir.hanania@intel.com>
@@ -28,35 +28,37 @@
 #define PKT_TYPE_IP6		1
 
 /* Structure of DL PIT */
-struct dpmaif_normal_pit {
-	__le32			pit_header;
-	__le32			p_data_addr;
-	__le32			data_addr_ext;
-	__le32			pit_footer;
+struct dpmaif_pit {
+	__le32 header;
+	union {
+		struct {
+			__le32 data_addr_l;
+			__le32 data_addr_h;
+			__le32 footer;
+		} pd;
+		struct {
+			__le32 params_1;
+			__le32 params_2;
+			__le32 params_3;
+		} msg;
+	};
 };
 
 /* PIT header fields */
-#define NORMAL_PIT_DATA_LEN	GENMASK(31, 16)
-#define NORMAL_PIT_BUFFER_ID	GENMASK(15, 3)
-#define NORMAL_PIT_BUFFER_TYPE	BIT(2)
-#define NORMAL_PIT_CONT		BIT(1)
-#define NORMAL_PIT_PACKET_TYPE	BIT(0)
+#define PD_PIT_DATA_LEN		GENMASK(31, 16)
+#define PD_PIT_BUFFER_ID	GENMASK(15, 3)
+#define PD_PIT_BUFFER_TYPE	BIT(2)
+#define PD_PIT_CONT		BIT(1)
+#define PD_PIT_PACKET_TYPE	BIT(0)
 /* PIT footer fields */
-#define NORMAL_PIT_DLQ_DONE	GENMASK(31, 30)
-#define NORMAL_PIT_ULQ_DONE	GENMASK(29, 24)
-#define NORMAL_PIT_HEADER_OFFSET GENMASK(23, 19)
-#define NORMAL_PIT_BI_F		GENMASK(18, 17)
-#define NORMAL_PIT_IG		BIT(16)
-#define NORMAL_PIT_RES		GENMASK(15, 11)
-#define NORMAL_PIT_H_BID	GENMASK(10, 8)
-#define NORMAL_PIT_PIT_SEQ	GENMASK(7, 0)
-
-struct dpmaif_msg_pit {
-	__le32			dword1;
-	__le32			dword2;
-	__le32			dword3;
-	__le32			dword4;
-};
+#define PD_PIT_DLQ_DONE		GENMASK(31, 30)
+#define PD_PIT_ULQ_DONE		GENMASK(29, 24)
+#define PD_PIT_HEADER_OFFSET	GENMASK(23, 19)
+#define PD_PIT_BI_F		GENMASK(18, 17)
+#define PD_PIT_IG		BIT(16)
+#define PD_PIT_RES		GENMASK(15, 11)
+#define PD_PIT_H_BID		GENMASK(10, 8)
+#define PD_PIT_PIT_SEQ		GENMASK(7, 0)
 
 #define MSG_PIT_DP		BIT(31)
 #define MSG_PIT_RES		GENMASK(30, 27)
@@ -98,7 +100,7 @@ void t7xx_dpmaif_rx_clear(struct dpmaif_ctrl *dpmaif_ctrl);
 int t7xx_dpmaif_bat_rel_wq_alloc(struct dpmaif_ctrl *dpmaif_ctrl);
 int t7xx_dpmaif_rx_buf_alloc(struct dpmaif_ctrl *dpmaif_ctrl,
 			     const struct dpmaif_bat_request *bat_req,
-			     const unsigned char q_num, const unsigned int buf_cnt,
+			     const unsigned int q_num, const unsigned int buf_cnt,
 			     const bool initial);
 int t7xx_dpmaif_rx_frag_alloc(struct dpmaif_ctrl *dpmaif_ctrl, struct dpmaif_bat_request *bat_req,
 			      const unsigned int buf_cnt, const bool first_time);
diff --git a/drivers/net/wwan/t7xx/t7xx_hif_dpmaif_tx.c b/drivers/net/wwan/t7xx/t7xx_hif_dpmaif_tx.c
index fc4d3d59c6e0..e999d87e0483 100644
--- a/drivers/net/wwan/t7xx/t7xx_hif_dpmaif_tx.c
+++ b/drivers/net/wwan/t7xx/t7xx_hif_dpmaif_tx.c
@@ -8,7 +8,7 @@
  *  Haijun Liu <haijun.liu@mediatek.com>
  *  Eliot Lee <eliot.lee@intel.com>
  *  Moises Veleta <moises.veleta@intel.com>
- *  Ricardo Martinez<ricardo.martinez@linux.intel.com>
+ *  Ricardo Martinez <ricardo.martinez@linux.intel.com>
  *
  * Contributors:
  *  Chiranjeevi Rapolu <chiranjeevi.rapolu@intel.com>
@@ -36,7 +36,6 @@
 #include <linux/wait.h>
 #include <linux/workqueue.h>
 
-#include "t7xx_common.h"
 #include "t7xx_dpmaif.h"
 #include "t7xx_hif_dpmaif.h"
 #include "t7xx_hif_dpmaif_tx.h"
@@ -50,11 +49,10 @@
 #define DES_DTYP_MSG		1
 
 static unsigned int t7xx_dpmaif_update_drb_rd_idx(struct dpmaif_ctrl *dpmaif_ctrl,
-						  unsigned char q_num)
+						  unsigned int q_num)
 {
 	struct dpmaif_tx_queue *txq = &dpmaif_ctrl->txq[q_num];
-	unsigned short old_sw_rd_idx, new_hw_rd_idx;
-	unsigned int drb_cnt;
+	unsigned int old_sw_rd_idx, new_hw_rd_idx, drb_cnt;
 	unsigned long flags;
 
 	if (!txq->que_started)
@@ -79,15 +77,14 @@ static unsigned int t7xx_dpmaif_update_drb_rd_idx(struct dpmaif_ctrl *dpmaif_ctr
 	return drb_cnt;
 }
 
-static unsigned short t7xx_dpmaif_release_tx_buffer(struct dpmaif_ctrl *dpmaif_ctrl,
-						    unsigned char q_num, unsigned int release_cnt)
+static unsigned int t7xx_dpmaif_release_tx_buffer(struct dpmaif_ctrl *dpmaif_ctrl,
+						  unsigned int q_num, unsigned int release_cnt)
 {
 	struct dpmaif_tx_queue *txq = &dpmaif_ctrl->txq[q_num];
 	struct dpmaif_callbacks *cb = dpmaif_ctrl->callbacks;
 	struct dpmaif_drb_skb *cur_drb_skb, *drb_skb_base;
-	struct dpmaif_drb_pd *cur_drb, *drb_base;
-	unsigned int drb_cnt, i;
-	unsigned short cur_idx;
+	struct dpmaif_drb *cur_drb, *drb_base;
+	unsigned int drb_cnt, i, cur_idx;
 	unsigned long flags;
 
 	drb_skb_base = txq->drb_skb_base;
@@ -100,13 +97,13 @@ static unsigned short t7xx_dpmaif_release_tx_buffer(struct dpmaif_ctrl *dpmaif_c
 
 	for (i = 0; i < release_cnt; i++) {
 		cur_drb = drb_base + cur_idx;
-		if (FIELD_GET(DRB_PD_DTYP, le32_to_cpu(cur_drb->header)) == DES_DTYP_PD) {
+		if (FIELD_GET(DRB_HDR_DTYP, le32_to_cpu(cur_drb->header)) == DES_DTYP_PD) {
 			cur_drb_skb = drb_skb_base + cur_idx;
 			if (!cur_drb_skb->is_msg)
 				dma_unmap_single(dpmaif_ctrl->dev, cur_drb_skb->bus_addr,
 						 cur_drb_skb->data_len, DMA_TO_DEVICE);
 
-			if (!FIELD_GET(DRB_PD_CONT, le32_to_cpu(cur_drb->header))) {
+			if (!FIELD_GET(DRB_HDR_CONT, le32_to_cpu(cur_drb->header))) {
 				if (!cur_drb_skb->skb) {
 					dev_err(dpmaif_ctrl->dev,
 						"txq%u: DRB check fail, invalid skb\n", q_num);
@@ -128,14 +125,14 @@ static unsigned short t7xx_dpmaif_release_tx_buffer(struct dpmaif_ctrl *dpmaif_c
 			cb->state_notify(dpmaif_ctrl->t7xx_dev, DMPAIF_TXQ_STATE_IRQ, txq->index);
 	}
 
-	if (FIELD_GET(DRB_PD_CONT, le32_to_cpu(cur_drb->header)))
+	if (FIELD_GET(DRB_HDR_CONT, le32_to_cpu(cur_drb->header)))
 		dev_err(dpmaif_ctrl->dev, "txq%u: DRB not marked as the last one\n", q_num);
 
 	return i;
 }
 
 static int t7xx_dpmaif_tx_release(struct dpmaif_ctrl *dpmaif_ctrl,
-				  unsigned char q_num, unsigned int budget)
+				  unsigned int q_num, unsigned int budget)
 {
 	struct dpmaif_tx_queue *txq = &dpmaif_ctrl->txq[q_num];
 	unsigned int rel_cnt, real_rel_cnt;
@@ -192,44 +189,41 @@ static void t7xx_dpmaif_tx_done(struct work_struct *work)
 	pm_runtime_put_autosuspend(dpmaif_ctrl->dev);
 }
 
-static void t7xx_setup_msg_drb(struct dpmaif_ctrl *dpmaif_ctrl, unsigned char q_num,
-			       unsigned short cur_idx, unsigned int pkt_len, unsigned short count_l,
-			       unsigned char channel_id)
+static void t7xx_setup_msg_drb(struct dpmaif_ctrl *dpmaif_ctrl, unsigned int q_num,
+			       unsigned int cur_idx, unsigned int pkt_len, unsigned int count_l,
+			       unsigned int channel_id)
 {
-	struct dpmaif_drb_msg *drb_base = dpmaif_ctrl->txq[q_num].drb_base;
-	struct dpmaif_drb_msg *drb = drb_base + cur_idx;
+	struct dpmaif_drb *drb_base = dpmaif_ctrl->txq[q_num].drb_base;
+	struct dpmaif_drb *drb = drb_base + cur_idx;
 
-	drb->header_dw1 = cpu_to_le32(FIELD_PREP(DRB_MSG_DTYP, DES_DTYP_MSG) |
-				      FIELD_PREP(DRB_MSG_CONT, 1) |
-				      FIELD_PREP(DRB_MSG_PACKET_LEN, pkt_len));
+	drb->header = cpu_to_le32(FIELD_PREP(DRB_HDR_DTYP, DES_DTYP_MSG) |
+				  FIELD_PREP(DRB_HDR_CONT, 1) |
+				  FIELD_PREP(DRB_HDR_DATA_LEN, pkt_len));
 
-	drb->header_dw2 = cpu_to_le32(FIELD_PREP(DRB_MSG_COUNT_L, count_l) |
-				      FIELD_PREP(DRB_MSG_CHANNEL_ID, channel_id) |
-				      FIELD_PREP(DRB_MSG_L4_CHK, 1));
+	drb->msg.msg_hdr = cpu_to_le32(FIELD_PREP(DRB_MSG_COUNT_L, count_l) |
+				       FIELD_PREP(DRB_MSG_CHANNEL_ID, channel_id) |
+				       FIELD_PREP(DRB_MSG_L4_CHK, 1));
 }
 
-static void t7xx_setup_payload_drb(struct dpmaif_ctrl *dpmaif_ctrl, unsigned char q_num,
-				   unsigned short cur_idx, dma_addr_t data_addr,
+static void t7xx_setup_payload_drb(struct dpmaif_ctrl *dpmaif_ctrl, unsigned int q_num,
+				   unsigned int cur_idx, dma_addr_t data_addr,
 				   unsigned int pkt_size, bool last_one)
 {
-	struct dpmaif_drb_pd *drb_base = dpmaif_ctrl->txq[q_num].drb_base;
-	struct dpmaif_drb_pd *drb = drb_base + cur_idx;
-
-	drb->header &= cpu_to_le32(~DRB_PD_DTYP);
-	drb->header |= cpu_to_le32(FIELD_PREP(DRB_PD_DTYP, DES_DTYP_PD));
-	drb->header &= cpu_to_le32(~DRB_PD_CONT);
+	struct dpmaif_drb *drb_base = dpmaif_ctrl->txq[q_num].drb_base;
+	struct dpmaif_drb *drb = drb_base + cur_idx;
+	u32 header;
 
+	header = FIELD_PREP(DRB_HDR_DTYP, DES_DTYP_PD) | FIELD_PREP(DRB_HDR_DATA_LEN, pkt_size);
 	if (!last_one)
-		drb->header |= cpu_to_le32(FIELD_PREP(DRB_PD_CONT, 1));
+		header |= FIELD_PREP(DRB_HDR_CONT, 1);
 
-	drb->header &= cpu_to_le32(~(u32)DRB_PD_DATA_LEN);
-	drb->header |= cpu_to_le32(FIELD_PREP(DRB_PD_DATA_LEN, pkt_size));
-	drb->p_data_addr = cpu_to_le32(lower_32_bits(data_addr));
-	drb->data_addr_ext = cpu_to_le32(upper_32_bits(data_addr));
+	drb->header = cpu_to_le32(header);
+	drb->pd.data_addr_l = cpu_to_le32(lower_32_bits(data_addr));
+	drb->pd.data_addr_h = cpu_to_le32(upper_32_bits(data_addr));
 }
 
-static void t7xx_record_drb_skb(struct dpmaif_ctrl *dpmaif_ctrl, unsigned char q_num,
-				unsigned short cur_idx, struct sk_buff *skb, unsigned short is_msg,
+static void t7xx_record_drb_skb(struct dpmaif_ctrl *dpmaif_ctrl, unsigned int q_num,
+				unsigned int cur_idx, struct sk_buff *skb, bool is_msg,
 				bool is_frag, bool is_last_one, dma_addr_t bus_addr,
 				unsigned int data_len)
 {
@@ -248,15 +242,11 @@ static void t7xx_record_drb_skb(struct dpmaif_ctrl *dpmaif_ctrl, unsigned char q
 static int t7xx_dpmaif_add_skb_to_ring(struct dpmaif_ctrl *dpmaif_ctrl, struct sk_buff *skb)
 {
 	unsigned int wr_cnt, send_cnt, payload_cnt;
-	unsigned short cur_idx, drb_wr_idx_backup;
-	bool is_frag, is_last_one = false;
+	unsigned int cur_idx, drb_wr_idx_backup;
 	struct skb_shared_info *shinfo;
 	struct dpmaif_tx_queue *txq;
 	struct t7xx_skb_cb *skb_cb;
-	unsigned int data_len;
-	dma_addr_t bus_addr;
 	unsigned long flags;
-	void *data_addr;
 
 	skb_cb = T7XX_SKB_CB(skb);
 	txq = &dpmaif_ctrl->txq[skb_cb->txq_number];
@@ -282,12 +272,15 @@ static int t7xx_dpmaif_add_skb_to_ring(struct dpmaif_ctrl *dpmaif_ctrl, struct s
 	if (txq->drb_wr_idx >= txq->drb_size_cnt)
 		txq->drb_wr_idx -= txq->drb_size_cnt;
 	t7xx_setup_msg_drb(dpmaif_ctrl, txq->index, cur_idx, skb->len, 0, skb_cb->netif_idx);
-	t7xx_record_drb_skb(dpmaif_ctrl, txq->index, cur_idx, skb, 1, 0, 0, 0, 0);
+	t7xx_record_drb_skb(dpmaif_ctrl, txq->index, cur_idx, skb, true, 0, 0, 0, 0);
 	spin_unlock_irqrestore(&txq->tx_lock, flags);
 
-	cur_idx = t7xx_ring_buf_get_next_wr_idx(txq->drb_size_cnt, cur_idx);
-
 	for (wr_cnt = 0; wr_cnt < payload_cnt; wr_cnt++) {
+		bool is_frag, is_last_one = wr_cnt == payload_cnt - 1;
+		unsigned int data_len;
+		dma_addr_t bus_addr;
+		void *data_addr;
+
 		if (!wr_cnt) {
 			data_len = skb_headlen(skb);
 			data_addr = skb->data;
@@ -300,35 +293,39 @@ static int t7xx_dpmaif_add_skb_to_ring(struct dpmaif_ctrl *dpmaif_ctrl, struct s
 			is_frag = true;
 		}
 
-		if (wr_cnt == payload_cnt - 1)
-			is_last_one = true;
-
 		bus_addr = dma_map_single(dpmaif_ctrl->dev, data_addr, data_len, DMA_TO_DEVICE);
-		if (dma_mapping_error(dpmaif_ctrl->dev, bus_addr)) {
-			dev_err(dpmaif_ctrl->dev, "DMA mapping fail\n");
-			atomic_set(&txq->tx_processing, 0);
+		if (dma_mapping_error(dpmaif_ctrl->dev, bus_addr))
+			goto unmap_buffers;
 
-			spin_lock_irqsave(&txq->tx_lock, flags);
-			txq->drb_wr_idx = drb_wr_idx_backup;
-			spin_unlock_irqrestore(&txq->tx_lock, flags);
-
-			return -ENOMEM;
-		}
+		cur_idx = t7xx_ring_buf_get_next_wr_idx(txq->drb_size_cnt, cur_idx);
 
 		spin_lock_irqsave(&txq->tx_lock, flags);
 		t7xx_setup_payload_drb(dpmaif_ctrl, txq->index, cur_idx, bus_addr, data_len,
 				       is_last_one);
-		t7xx_record_drb_skb(dpmaif_ctrl, txq->index, cur_idx, skb, 0, is_frag,
+		t7xx_record_drb_skb(dpmaif_ctrl, txq->index, cur_idx, skb, false, is_frag,
 				    is_last_one, bus_addr, data_len);
 		spin_unlock_irqrestore(&txq->tx_lock, flags);
-
-		cur_idx = t7xx_ring_buf_get_next_wr_idx(txq->drb_size_cnt, cur_idx);
 	}
 
 	atomic_sub(send_cnt, &txq->tx_budget);
 	atomic_set(&txq->tx_processing, 0);
 
 	return 0;
+
+unmap_buffers:
+	while (wr_cnt--) {
+		struct dpmaif_drb_skb *drb_skb = txq->drb_skb_base;
+
+		cur_idx = cur_idx ? cur_idx - 1 : txq->drb_size_cnt - 1;
+		drb_skb += cur_idx;
+		dma_unmap_single(dpmaif_ctrl->dev, drb_skb->bus_addr,
+				 drb_skb->data_len, DMA_TO_DEVICE);
+	}
+
+	txq->drb_wr_idx = drb_wr_idx_backup;
+	atomic_set(&txq->tx_processing, 0);
+
+	return -ENOMEM;
 }
 
 static bool t7xx_tx_lists_are_all_empty(const struct dpmaif_ctrl *dpmaif_ctrl)
@@ -336,7 +333,7 @@ static bool t7xx_tx_lists_are_all_empty(const struct dpmaif_ctrl *dpmaif_ctrl)
 	int i;
 
 	for (i = 0; i < DPMAIF_TXQ_NUM; i++) {
-		if (!list_empty(&dpmaif_ctrl->txq[i].tx_skb_queue))
+		if (!skb_queue_empty(&dpmaif_ctrl->txq[i].tx_skb_head))
 			return false;
 	}
 
@@ -357,18 +354,11 @@ static struct dpmaif_tx_queue *t7xx_select_tx_queue(struct dpmaif_ctrl *dpmaif_c
 
 static unsigned int t7xx_txq_drb_wr_available(struct dpmaif_tx_queue *txq)
 {
-	unsigned int drb_remain_cnt;
-	unsigned long flags;
-
-	spin_lock_irqsave(&txq->tx_lock, flags);
-	drb_remain_cnt = t7xx_ring_buf_rd_wr_count(txq->drb_size_cnt, txq->drb_release_rd_idx,
-						   txq->drb_wr_idx, DPMAIF_WRITE);
-	spin_unlock_irqrestore(&txq->tx_lock, flags);
-
-	return drb_remain_cnt;
+	return t7xx_ring_buf_rd_wr_count(txq->drb_size_cnt, txq->drb_release_rd_idx,
+					 txq->drb_wr_idx, DPMAIF_WRITE);
 }
 
-static unsigned char t7xx_skb_drb_cnt(struct sk_buff *skb)
+static unsigned int t7xx_skb_drb_cnt(struct sk_buff *skb)
 {
 	/* Normal DRB (frags data + skb linear data) + msg DRB */
 	return skb_shinfo(skb)->nr_frags + 2;
@@ -378,7 +368,6 @@ static int t7xx_txq_burst_send_skb(struct dpmaif_tx_queue *txq)
 {
 	unsigned int drb_remain_cnt, i;
 	unsigned int send_drb_cnt;
-	unsigned long flags;
 	int drb_cnt = 0;
 	int ret = 0;
 
@@ -387,10 +376,7 @@ static int t7xx_txq_burst_send_skb(struct dpmaif_tx_queue *txq)
 	for (i = 0; i < DPMAIF_SKB_TX_BURST_CNT; i++) {
 		struct sk_buff *skb;
 
-		spin_lock_irqsave(&txq->tx_skb_lock, flags);
-		skb = list_first_entry_or_null(&txq->tx_skb_queue, struct sk_buff, list);
-		spin_unlock_irqrestore(&txq->tx_skb_lock, flags);
-
+		skb = skb_peek(&txq->tx_skb_head);
 		if (!skb)
 			break;
 
@@ -410,11 +396,7 @@ static int t7xx_txq_burst_send_skb(struct dpmaif_tx_queue *txq)
 		}
 
 		drb_cnt += send_drb_cnt;
-
-		spin_lock_irqsave(&txq->tx_skb_lock, flags);
-		list_del(&skb->list);
-		txq->tx_submit_skb_cnt--;
-		spin_unlock_irqrestore(&txq->tx_skb_lock, flags);
+		skb_unlink(skb, &txq->tx_skb_head);
 	}
 
 	if (drb_cnt > 0)
@@ -523,7 +505,6 @@ int t7xx_dpmaif_tx_send_skb(struct dpmaif_ctrl *dpmaif_ctrl, unsigned int txq_nu
 	struct dpmaif_tx_queue *txq = &dpmaif_ctrl->txq[txq_number];
 	struct dpmaif_callbacks *callbacks;
 	struct t7xx_skb_cb *skb_cb;
-	unsigned long flags;
 
 	if (!(txq->tx_skb_stat++ % DPMAIF_SKB_TX_BURST_CNT)) {
 		unsigned int send_drb_cnt, drb_available_cnt;
@@ -534,19 +515,12 @@ int t7xx_dpmaif_tx_send_skb(struct dpmaif_ctrl *dpmaif_ctrl, unsigned int txq_nu
 			goto report_full_state;
 	}
 
-	spin_lock_irqsave(&txq->tx_skb_lock, flags);
-	if (txq->tx_submit_skb_cnt >= txq->tx_list_max_len) {
-		spin_unlock_irqrestore(&txq->tx_skb_lock, flags);
+	if (txq->tx_skb_head.qlen >= txq->tx_list_max_len)
 		goto report_full_state;
-	}
 
 	skb_cb = T7XX_SKB_CB(skb);
 	skb_cb->txq_number = txq_number;
-
-	list_add_tail(&skb->list, &txq->tx_skb_queue);
-	txq->tx_submit_skb_cnt++;
-	spin_unlock_irqrestore(&txq->tx_skb_lock, flags);
-
+	skb_queue_tail(&txq->tx_skb_head, skb);
 	wake_up(&dpmaif_ctrl->tx_wq);
 	return 0;
 
@@ -570,7 +544,7 @@ static int t7xx_dpmaif_tx_drb_buf_init(struct dpmaif_tx_queue *txq)
 {
 	size_t brb_skb_size, brb_pd_size;
 
-	brb_pd_size = DPMAIF_DRB_LIST_LEN * sizeof(struct dpmaif_drb_pd);
+	brb_pd_size = DPMAIF_DRB_LIST_LEN * sizeof(struct dpmaif_drb);
 	brb_skb_size = DPMAIF_DRB_LIST_LEN * sizeof(struct dpmaif_drb_skb);
 
 	txq->drb_size_cnt = DPMAIF_DRB_LIST_LEN;
@@ -594,10 +568,9 @@ static int t7xx_dpmaif_tx_drb_buf_init(struct dpmaif_tx_queue *txq)
 
 static void t7xx_dpmaif_tx_free_drb_skb(struct dpmaif_tx_queue *txq)
 {
-	struct dpmaif_drb_skb *drb_skb, *drb_skb_base;
+	struct dpmaif_drb_skb *drb_skb, *drb_skb_base = txq->drb_skb_base;
 	unsigned int i;
 
-	drb_skb_base = txq->drb_skb_base;
 	if (!drb_skb_base)
 		return;
 
@@ -621,7 +594,7 @@ static void t7xx_dpmaif_tx_drb_buf_rel(struct dpmaif_tx_queue *txq)
 {
 	if (txq->drb_base)
 		dma_free_coherent(txq->dpmaif_ctrl->dev,
-				  txq->drb_size_cnt * sizeof(struct dpmaif_drb_pd),
+				  txq->drb_size_cnt * sizeof(struct dpmaif_drb),
 				  txq->drb_base, txq->drb_bus_addr);
 
 	t7xx_dpmaif_tx_free_drb_skb(txq);
@@ -641,9 +614,7 @@ int t7xx_dpmaif_txq_init(struct dpmaif_tx_queue *txq)
 {
 	int ret;
 
-	spin_lock_init(&txq->tx_skb_lock);
-	INIT_LIST_HEAD(&txq->tx_skb_queue);
-	txq->tx_submit_skb_cnt = 0;
+	skb_queue_head_init(&txq->tx_skb_head);
 	txq->tx_skb_stat = 0;
 	txq->tx_list_max_len = DPMAIF_DRB_LIST_LEN / 2;
 	init_waitqueue_head(&txq->req_wq);
@@ -668,19 +639,10 @@ int t7xx_dpmaif_txq_init(struct dpmaif_tx_queue *txq)
 
 void t7xx_dpmaif_txq_free(struct dpmaif_tx_queue *txq)
 {
-	struct sk_buff *skb, *skb_next;
-	unsigned long flags;
-
 	if (txq->worker)
 		destroy_workqueue(txq->worker);
 
-	spin_lock_irqsave(&txq->tx_skb_lock, flags);
-	list_for_each_entry_safe(skb, skb_next, &txq->tx_skb_queue, list) {
-		list_del(&skb->list);
-		dev_kfree_skb_any(skb);
-	}
-	spin_unlock_irqrestore(&txq->tx_skb_lock, flags);
-
+	skb_queue_purge(&txq->tx_skb_head);
 	t7xx_dpmaif_tx_drb_buf_rel(txq);
 }
 
diff --git a/drivers/net/wwan/t7xx/t7xx_hif_dpmaif_tx.h b/drivers/net/wwan/t7xx/t7xx_hif_dpmaif_tx.h
index a670e76fe943..dfb33b8f4224 100644
--- a/drivers/net/wwan/t7xx/t7xx_hif_dpmaif_tx.h
+++ b/drivers/net/wwan/t7xx/t7xx_hif_dpmaif_tx.h
@@ -6,7 +6,7 @@
  * Authors:
  *  Haijun Liu <haijun.liu@mediatek.com>
  *  Eliot Lee <eliot.lee@intel.com>
- *  Ricardo Martinez<ricardo.martinez@linux.intel.com>
+ *  Ricardo Martinez <ricardo.martinez@linux.intel.com>
  *
  * Contributors:
  *  Amir Hanania <amir.hanania@intel.com>
@@ -22,41 +22,36 @@
 #include <linux/skbuff.h>
 #include <linux/types.h>
 
-#include "t7xx_common.h"
 #include "t7xx_hif_dpmaif.h"
 
 #define DPMAIF_TX_DEFAULT_QUEUE	0
 
-/* UL DRB */
-struct dpmaif_drb_pd {
-	__le32	header;
-	__le32	p_data_addr;
-	__le32	data_addr_ext;
-	__le32	reserved2;
+struct dpmaif_drb {
+	__le32 header;
+	union {
+		struct {
+			__le32 data_addr_l;
+			__le32 data_addr_h;
+			__le32 reserved;
+		} pd;
+		struct {
+			__le32 msg_hdr;
+			__le32 reserved1;
+			__le32 reserved2;
+		} msg;
+	};
 };
 
 /* Header fields */
-#define DRB_PD_DATA_LEN		GENMASK(31, 16)
-#define DRB_PD_RES		GENMASK(15, 3)
-#define DRB_PD_CONT		BIT(2)
-#define DRB_PD_DTYP		GENMASK(1, 0)
-
-struct dpmaif_drb_msg {
-	__le32	header_dw1;
-	__le32	header_dw2;
-	__le32	reserved4;
-	__le32	reserved5;
-};
-
-#define DRB_MSG_PACKET_LEN	GENMASK(31, 16)
-#define DRB_MSG_DW1_RES		GENMASK(15, 3)
-#define DRB_MSG_CONT		BIT(2)
-#define DRB_MSG_DTYP		GENMASK(1, 0)
+#define DRB_HDR_DATA_LEN	GENMASK(31, 16)
+#define DRB_HDR_RESERVED	GENMASK(15, 3)
+#define DRB_HDR_CONT		BIT(2)
+#define DRB_HDR_DTYP		GENMASK(1, 0)
 
 #define DRB_MSG_DW2_RES		GENMASK(31, 30)
 #define DRB_MSG_L4_CHK		BIT(29)
 #define DRB_MSG_IP_CHK		BIT(28)
-#define DRB_MSG_RES2		BIT(27)
+#define DRB_MSG_RESERVED	BIT(27)
 #define DRB_MSG_NETWORK_TYPE	GENMASK(26, 24)
 #define DRB_MSG_CHANNEL_ID	GENMASK(23, 16)
 #define DRB_MSG_COUNT_L		GENMASK(15, 0)
diff --git a/drivers/net/wwan/t7xx/t7xx_mhccif.c b/drivers/net/wwan/t7xx/t7xx_mhccif.c
index 6f69e970728f..3ee18d46f8d2 100644
--- a/drivers/net/wwan/t7xx/t7xx_mhccif.c
+++ b/drivers/net/wwan/t7xx/t7xx_mhccif.c
@@ -9,7 +9,7 @@
  *
  * Contributors:
  *  Amir Hanania <amir.hanania@intel.com>
- *  Ricardo Martinez<ricardo.martinez@linux.intel.com>
+ *  Ricardo Martinez <ricardo.martinez@linux.intel.com>
  */
 
 #include <linux/bits.h>
@@ -46,8 +46,8 @@ static irqreturn_t t7xx_mhccif_isr_thread(int irq, void *data)
 	struct t7xx_pci_dev *t7xx_dev = data;
 	u32 int_status, val;
 
-	val = L1_1_DISABLE_BIT(1) | L1_2_DISABLE_BIT(1);
-	iowrite32(val, IREG_BASE(t7xx_dev) + DIS_ASPM_LOWPWR_SET_0);
+	val = T7XX_L1_1_BIT(1) | T7XX_L1_2_BIT(1);
+	iowrite32(val, IREG_BASE(t7xx_dev) + DISABLE_ASPM_LOWPWR);
 
 	int_status = t7xx_mhccif_read_sw_int_sts(t7xx_dev);
 	if (int_status & D2H_SW_INT_MASK) {
@@ -65,12 +65,12 @@ static irqreturn_t t7xx_mhccif_isr_thread(int irq, void *data)
 	if (int_status & D2H_INT_SR_ACK)
 		complete(&t7xx_dev->pm_sr_ack);
 
-	iowrite32(L1_DISABLE_BIT(1), IREG_BASE(t7xx_dev) + DIS_ASPM_LOWPWR_CLR_0);
+	iowrite32(T7XX_L1_BIT(1), IREG_BASE(t7xx_dev) + ENABLE_ASPM_LOWPWR);
 
 	int_status = t7xx_mhccif_read_sw_int_sts(t7xx_dev);
 	if (!int_status) {
-		val = L1_1_DISABLE_BIT(1) | L1_2_DISABLE_BIT(1);
-		iowrite32(val, IREG_BASE(t7xx_dev) + DIS_ASPM_LOWPWR_CLR_0);
+		val = T7XX_L1_1_BIT(1) | T7XX_L1_2_BIT(1);
+		iowrite32(val, IREG_BASE(t7xx_dev) + ENABLE_ASPM_LOWPWR);
 	}
 
 	t7xx_pcie_mac_set_int(t7xx_dev, MHCCIF_INT);
diff --git a/drivers/net/wwan/t7xx/t7xx_mhccif.h b/drivers/net/wwan/t7xx/t7xx_mhccif.h
index d574e18391f9..209b386bc088 100644
--- a/drivers/net/wwan/t7xx/t7xx_mhccif.h
+++ b/drivers/net/wwan/t7xx/t7xx_mhccif.h
@@ -9,7 +9,7 @@
  *
  * Contributors:
  *  Amir Hanania <amir.hanania@intel.com>
- *  Ricardo Martinez<ricardo.martinez@linux.intel.com>
+ *  Ricardo Martinez <ricardo.martinez@linux.intel.com>
  */
 
 #ifndef __T7XX_MHCCIF_H__
diff --git a/drivers/net/wwan/t7xx/t7xx_modem_ops.c b/drivers/net/wwan/t7xx/t7xx_modem_ops.c
index 412838525208..3d585e877267 100644
--- a/drivers/net/wwan/t7xx/t7xx_modem_ops.c
+++ b/drivers/net/wwan/t7xx/t7xx_modem_ops.c
@@ -7,7 +7,7 @@
  *  Haijun Liu <haijun.liu@mediatek.com>
  *  Eliot Lee <eliot.lee@intel.com>
  *  Moises Veleta <moises.veleta@intel.com>
- *  Ricardo Martinez<ricardo.martinez@linux.intel.com>
+ *  Ricardo Martinez <ricardo.martinez@linux.intel.com>
  *
  * Contributors:
  *  Amir Hanania <amir.hanania@intel.com>
@@ -339,48 +339,29 @@ struct feature_query {
 
 static void t7xx_prepare_host_rt_data_query(struct t7xx_sys_info *core)
 {
-	struct t7xx_port_static *port_static = core->ctl_port->port_static;
-	struct ctrl_msg_header *ctrl_msg_h;
 	struct feature_query *ft_query;
-	struct ccci_header *ccci_h;
 	struct sk_buff *skb;
-	size_t packet_size;
 
-	packet_size = sizeof(*ccci_h) + sizeof(*ctrl_msg_h) + sizeof(*ft_query);
-	skb = __dev_alloc_skb(packet_size, GFP_KERNEL);
+	skb = t7xx_ctrl_alloc_skb(sizeof(*ft_query));
 	if (!skb)
 		return;
 
-	skb_put(skb, packet_size);
-
-	ccci_h = (struct ccci_header *)skb->data;
-	t7xx_ccci_header_init(ccci_h, 0, packet_size, port_static->tx_ch, 0);
-	ccci_h->status &= cpu_to_le32(~CCCI_H_SEQ_FLD);
-
-	ctrl_msg_h = (struct ctrl_msg_header *)(skb->data + sizeof(*ccci_h));
-	t7xx_ctrl_msg_header_init(ctrl_msg_h, CTL_ID_HS1_MSG, 0, sizeof(*ft_query));
-
-	ft_query = (struct feature_query *)(skb->data + sizeof(*ccci_h) + sizeof(*ctrl_msg_h));
+	ft_query = skb_put(skb, sizeof(*ft_query));
 	ft_query->head_pattern = cpu_to_le32(MD_FEATURE_QUERY_ID);
 	memcpy(ft_query->feature_set, core->feature_set, FEATURE_COUNT);
 	ft_query->tail_pattern = cpu_to_le32(MD_FEATURE_QUERY_ID);
 
 	/* Send HS1 message to device */
-	t7xx_port_proxy_send_skb(core->ctl_port, skb);
+	t7xx_port_send_ctl_skb(core->ctl_port, skb, CTL_ID_HS1_MSG, 0);
 }
 
 static int t7xx_prepare_device_rt_data(struct t7xx_sys_info *core, struct device *dev,
-				       void *data, int data_length)
+				       void *data)
 {
-	struct t7xx_port_static *port_static = core->ctl_port->port_static;
 	struct feature_query *md_feature = data;
-	struct ctrl_msg_header *ctrl_msg_h;
-	unsigned int total_data_len;
-	struct ccci_header *ccci_h;
-	size_t packet_size = 0;
+	struct mtk_runtime_feature *rt_feature;
+	unsigned int i, rt_data_len = 0;
 	struct sk_buff *skb;
-	char *rt_data;
-	int i;
 
 	/* Parse MD runtime data query */
 	if (le32_to_cpu(md_feature->head_pattern) != MD_FEATURE_QUERY_ID ||
@@ -391,45 +372,35 @@ static int t7xx_prepare_device_rt_data(struct t7xx_sys_info *core, struct device
 		return -EINVAL;
 	}
 
-	skb = __dev_alloc_skb(CLDMA_MTU, GFP_KERNEL);
+	for (i = 0; i < FEATURE_COUNT; i++) {
+		if (FIELD_GET(FEATURE_MSK, md_feature->feature_set[i]) !=
+		    MTK_FEATURE_MUST_BE_SUPPORTED)
+			rt_data_len += sizeof(*rt_feature);
+	}
+
+	skb = t7xx_ctrl_alloc_skb(rt_data_len);
 	if (!skb)
-		return -EFAULT;
+		return -ENOMEM;
 
-	ccci_h = (struct ccci_header *)skb->data;
-	t7xx_ccci_header_init(ccci_h, 0, packet_size, port_static->tx_ch, 0);
-	ccci_h->status &= cpu_to_le32(~CCCI_H_SEQ_FLD);
-	ctrl_msg_h = (struct ctrl_msg_header *)(skb->data + sizeof(*ccci_h));
-	t7xx_ctrl_msg_header_init(ctrl_msg_h, CTL_ID_HS3_MSG, 0, 0);
-	rt_data = skb->data + sizeof(*ccci_h) + sizeof(*ctrl_msg_h);
+	rt_feature  = skb_put(skb, rt_data_len);
+	memset(rt_feature, 0, rt_data_len);
 
 	/* Fill runtime feature */
 	for (i = 0; i < FEATURE_COUNT; i++) {
-		struct mtk_runtime_feature rt_feature;
-		u8 md_feature_mask;
+		u8 md_feature_mask = FIELD_GET(FEATURE_MSK, md_feature->feature_set[i]);
 
-		if (FIELD_GET(FEATURE_MSK, md_feature->feature_set[i]) ==
-		    MTK_FEATURE_MUST_BE_SUPPORTED)
+		if (md_feature_mask == MTK_FEATURE_MUST_BE_SUPPORTED)
 			continue;
 
-		memset(&rt_feature, 0, sizeof(rt_feature));
-		rt_feature.feature_id = i;
-
-		md_feature_mask = FIELD_GET(FEATURE_MSK, md_feature->feature_set[i]);
+		rt_feature->feature_id = i;
 		if (md_feature_mask == MTK_FEATURE_DOES_NOT_EXIST)
-			rt_feature.support_info = md_feature->feature_set[i];
+			rt_feature->support_info = md_feature->feature_set[i];
 
-		memcpy(rt_data, &rt_feature, sizeof(rt_feature));
-		rt_data += sizeof(rt_feature);
-		packet_size += sizeof(rt_feature);
+		rt_feature++;
 	}
 
-	ctrl_msg_h->data_length = cpu_to_le32(packet_size);
-	total_data_len = packet_size + sizeof(*ctrl_msg_h) + sizeof(*ccci_h);
-	ccci_h->packet_len = cpu_to_le32(total_data_len);
-	skb_put(skb, total_data_len);
-
 	/* Send HS3 message to device */
-	t7xx_port_proxy_send_skb(core->ctl_port, skb);
+	t7xx_port_send_ctl_skb(core->ctl_port, skb, CTL_ID_HS3_MSG, 0);
 	return 0;
 }
 
@@ -443,21 +414,18 @@ static int t7xx_parse_host_rt_data(struct t7xx_fsm_ctl *ctl, struct t7xx_sys_inf
 	offset = sizeof(struct feature_query);
 	for (i = 0; i < FEATURE_COUNT && offset < data_length; i++) {
 		rt_feature = data + offset;
-		ft_spt_st = FIELD_GET(FEATURE_MSK, rt_feature->support_info);
 		offset += sizeof(*rt_feature) + le32_to_cpu(rt_feature->data_len);
 
 		ft_spt_cfg = FIELD_GET(FEATURE_MSK, core->feature_set[i]);
 		if (ft_spt_cfg != MTK_FEATURE_MUST_BE_SUPPORTED)
 			continue;
 
+		ft_spt_st = FIELD_GET(FEATURE_MSK, rt_feature->support_info);
 		if (ft_spt_st != MTK_FEATURE_MUST_BE_SUPPORTED)
 			return -EINVAL;
 
-		if (i == RT_ID_MD_PORT_ENUM) {
-			struct port_msg *p_msg = (void *)rt_feature + sizeof(*rt_feature);
-
-			t7xx_port_proxy_node_control(ctl->md, p_msg);
-		}
+		if (i == RT_ID_MD_PORT_ENUM)
+			t7xx_port_enum_msg_handler(ctl->md, rt_feature->data);
 	}
 
 	return 0;
@@ -494,7 +462,6 @@ static void t7xx_core_hk_handler(struct t7xx_modem *md, struct t7xx_fsm_ctl *ctl
 	struct device *dev = &md->t7xx_dev->pdev->dev;
 	struct t7xx_fsm_event *event, *event_next;
 	unsigned long flags;
-	void *event_data;
 	int ret;
 
 	t7xx_prepare_host_rt_data_query(core_info);
@@ -529,8 +496,7 @@ static void t7xx_core_hk_handler(struct t7xx_modem *md, struct t7xx_fsm_ctl *ctl
 	if (ctl->exp_flg)
 		goto err_free_event;
 
-	event_data = (void *)event + sizeof(*event);
-	ret = t7xx_parse_host_rt_data(ctl, core_info, dev, event_data, event->length);
+	ret = t7xx_parse_host_rt_data(ctl, core_info, dev, event->data, event->length);
 	if (ret) {
 		dev_err(dev, "Host failure parsing runtime data: %d\n", ret);
 		goto err_free_event;
@@ -539,7 +505,7 @@ static void t7xx_core_hk_handler(struct t7xx_modem *md, struct t7xx_fsm_ctl *ctl
 	if (ctl->exp_flg)
 		goto err_free_event;
 
-	ret = t7xx_prepare_device_rt_data(core_info, dev, event_data, event->length);
+	ret = t7xx_prepare_device_rt_data(core_info, dev, event->data);
 	if (ret) {
 		dev_err(dev, "Device failure parsing runtime data: %d", ret);
 		goto err_free_event;
@@ -651,8 +617,6 @@ static struct t7xx_modem *t7xx_md_alloc(struct t7xx_pci_dev *t7xx_dev)
 
 	md->t7xx_dev = t7xx_dev;
 	t7xx_dev->md = md;
-	md->core_md.ready = false;
-	md->core_md.handshake_ongoing = false;
 	spin_lock_init(&md->exp_lock);
 	md->handshake_wq = alloc_workqueue("%s", WQ_UNBOUND | WQ_MEM_RECLAIM | WQ_HIGHPRI,
 					   0, "md_hk_wq");
@@ -672,7 +636,6 @@ int t7xx_md_reset(struct t7xx_pci_dev *t7xx_dev)
 
 	md->md_init_finish = false;
 	md->exp_id = 0;
-	spin_lock_init(&md->exp_lock);
 	t7xx_fsm_reset(md);
 	t7xx_cldma_reset(md->md_ctrl[CLDMA_ID_MD]);
 	t7xx_port_proxy_reset(md->port_prox);
@@ -718,7 +681,7 @@ int t7xx_md_init(struct t7xx_pci_dev *t7xx_dev)
 
 	ret = t7xx_port_proxy_init(md);
 	if (ret)
-		goto err_uninit_cldma;
+		goto err_uninit_md_cldma;
 
 	ret = t7xx_fsm_append_cmd(md->fsm_ctl, FSM_CMD_START, 0);
 	if (ret) /* fsm_uninit flushes cmd queue */
@@ -731,7 +694,7 @@ int t7xx_md_init(struct t7xx_pci_dev *t7xx_dev)
 err_uninit_proxy:
 	t7xx_port_proxy_uninit(md->port_prox);
 
-err_uninit_cldma:
+err_uninit_md_cldma:
 	t7xx_cldma_exit(md->md_ctrl[CLDMA_ID_MD]);
 
 err_uninit_ccmni:
diff --git a/drivers/net/wwan/t7xx/t7xx_modem_ops.h b/drivers/net/wwan/t7xx/t7xx_modem_ops.h
index c0596d540ca5..7469ed636ae8 100644
--- a/drivers/net/wwan/t7xx/t7xx_modem_ops.h
+++ b/drivers/net/wwan/t7xx/t7xx_modem_ops.h
@@ -7,7 +7,7 @@
  *  Haijun Liu <haijun.liu@mediatek.com>
  *  Eliot Lee <eliot.lee@intel.com>
  *  Moises Veleta <moises.veleta@intel.com>
- *  Ricardo Martinez<ricardo.martinez@linux.intel.com>
+ *  Ricardo Martinez <ricardo.martinez@linux.intel.com>
  *
  * Contributors:
  *  Amir Hanania <amir.hanania@intel.com>
@@ -46,6 +46,7 @@ struct mtk_runtime_feature {
 	u8				support_info;
 	u8				reserved[2];
 	__le32				data_len;
+	__le32				data[];
 };
 
 enum md_event_id {
diff --git a/drivers/net/wwan/t7xx/t7xx_netdev.c b/drivers/net/wwan/t7xx/t7xx_netdev.c
index 3cd3cc3e5718..c6b6547f2c6f 100644
--- a/drivers/net/wwan/t7xx/t7xx_netdev.c
+++ b/drivers/net/wwan/t7xx/t7xx_netdev.c
@@ -6,7 +6,7 @@
  * Authors:
  *  Chandrashekar Devegowda <chandrashekar.devegowda@intel.com>
  *  Haijun Liu <haijun.liu@mediatek.com>
- *  Ricardo Martinez<ricardo.martinez@linux.intel.com>
+ *  Ricardo Martinez <ricardo.martinez@linux.intel.com>
  *
  * Contributors:
  *  Amir Hanania <amir.hanania@intel.com>
@@ -31,21 +31,15 @@
 #include <linux/wwan.h>
 #include <net/pkt_sched.h>
 
-#include "t7xx_common.h"
 #include "t7xx_hif_dpmaif_rx.h"
 #include "t7xx_hif_dpmaif_tx.h"
 #include "t7xx_netdev.h"
 #include "t7xx_pci.h"
+#include "t7xx_port_proxy.h"
 #include "t7xx_state_monitor.h"
 
 #define IP_MUX_SESSION_DEFAULT	0
 
-static u16 t7xx_ccmni_select_queue(struct net_device *dev, struct sk_buff *skb,
-				   struct net_device *sb_dev)
-{
-	return DPMAIF_TX_DEFAULT_QUEUE;
-}
-
 static int t7xx_ccmni_open(struct net_device *dev)
 {
 	struct t7xx_ccmni *ccmni = wwan_netdev_drvpriv(dev);
@@ -116,7 +110,6 @@ static const struct net_device_ops ccmni_netdev_ops = {
 	.ndo_stop	  = t7xx_ccmni_close,
 	.ndo_start_xmit   = t7xx_ccmni_start_xmit,
 	.ndo_tx_timeout   = t7xx_ccmni_tx_timeout,
-	.ndo_select_queue = t7xx_ccmni_select_queue,
 };
 
 static void t7xx_ccmni_start(struct t7xx_ccmni_ctrl *ctlb)
@@ -344,7 +337,7 @@ static void t7xx_ccmni_recv_skb(struct t7xx_pci_dev *t7xx_dev, struct sk_buff *s
 		skb->protocol = htons(ETH_P_IP);
 
 	skb_len = skb->len;
-	netif_rx_any_context(skb);
+	netif_rx(skb);
 	net_dev->stats.rx_packets++;
 	net_dev->stats.rx_bytes += skb_len;
 }
diff --git a/drivers/net/wwan/t7xx/t7xx_netdev.h b/drivers/net/wwan/t7xx/t7xx_netdev.h
index 279e15607ac7..f5ad49ca12a7 100644
--- a/drivers/net/wwan/t7xx/t7xx_netdev.h
+++ b/drivers/net/wwan/t7xx/t7xx_netdev.h
@@ -10,7 +10,7 @@
  * Contributors:
  *  Amir Hanania <amir.hanania@intel.com>
  *  Chiranjeevi Rapolu <chiranjeevi.rapolu@intel.com>
- *  Ricardo Martinez<ricardo.martinez@linux.intel.com>
+ *  Ricardo Martinez <ricardo.martinez@linux.intel.com>
  */
 
 #ifndef __T7XX_NETDEV_H__
@@ -20,7 +20,6 @@
 #include <linux/netdevice.h>
 #include <linux/types.h>
 
-#include "t7xx_common.h"
 #include "t7xx_hif_dpmaif.h"
 #include "t7xx_pci.h"
 #include "t7xx_state_monitor.h"
diff --git a/drivers/net/wwan/t7xx/t7xx_pci.c b/drivers/net/wwan/t7xx/t7xx_pci.c
index 92b85d4221c5..ce4b22b61f68 100644
--- a/drivers/net/wwan/t7xx/t7xx_pci.c
+++ b/drivers/net/wwan/t7xx/t7xx_pci.c
@@ -5,7 +5,7 @@
  *
  * Authors:
  *  Haijun Liu <haijun.liu@mediatek.com>
- *  Ricardo Martinez<ricardo.martinez@linux.intel.com>
+ *  Ricardo Martinez <ricardo.martinez@linux.intel.com>
  *  Sreehari Kancharla <sreehari.kancharla@intel.com>
  *
  * Contributors:
@@ -92,23 +92,17 @@ static int t7xx_pci_pm_init(struct t7xx_pci_dev *t7xx_dev)
 	struct pci_dev *pdev = t7xx_dev->pdev;
 
 	INIT_LIST_HEAD(&t7xx_dev->md_pm_entities);
-
-	spin_lock_init(&t7xx_dev->md_pm_lock);
-
 	mutex_init(&t7xx_dev->md_pm_entity_mtx);
-
+	spin_lock_init(&t7xx_dev->md_pm_lock);
 	init_completion(&t7xx_dev->sleep_lock_acquire);
 	init_completion(&t7xx_dev->pm_sr_ack);
+	atomic_set(&t7xx_dev->md_pm_state, MTK_PM_INIT);
 
-	atomic_set(&t7xx_dev->sleep_disable_count, 0);
 	device_init_wakeup(&pdev->dev, true);
-
 	dev_pm_set_driver_flags(&pdev->dev, pdev->dev.power.driver_flags |
 				DPM_FLAG_NO_DIRECT_COMPLETE);
 
-	atomic_set(&t7xx_dev->md_pm_state, MTK_PM_INIT);
-
-	iowrite32(L1_DISABLE_BIT(0), IREG_BASE(t7xx_dev) + DIS_ASPM_LOWPWR_SET_0);
+	iowrite32(T7XX_L1_BIT(0), IREG_BASE(t7xx_dev) + DISABLE_ASPM_LOWPWR);
 	pm_runtime_set_autosuspend_delay(&pdev->dev, PM_AUTOSUSPEND_MS);
 	pm_runtime_use_autosuspend(&pdev->dev);
 
@@ -124,7 +118,7 @@ void t7xx_pci_pm_init_late(struct t7xx_pci_dev *t7xx_dev)
 			     D2H_INT_RESUME_ACK |
 			     D2H_INT_SUSPEND_ACK_AP |
 			     D2H_INT_RESUME_ACK_AP);
-	iowrite32(L1_DISABLE_BIT(0), IREG_BASE(t7xx_dev) + DIS_ASPM_LOWPWR_CLR_0);
+	iowrite32(T7XX_L1_BIT(0), IREG_BASE(t7xx_dev) + ENABLE_ASPM_LOWPWR);
 	atomic_set(&t7xx_dev->md_pm_state, MTK_PM_RESUMED);
 
 	pm_runtime_put_noidle(&t7xx_dev->pdev->dev);
@@ -139,13 +133,13 @@ static int t7xx_pci_pm_reinit(struct t7xx_pci_dev *t7xx_dev)
 
 	pm_runtime_get_noresume(&t7xx_dev->pdev->dev);
 
-	iowrite32(L1_DISABLE_BIT(0), IREG_BASE(t7xx_dev) + DIS_ASPM_LOWPWR_SET_0);
+	iowrite32(T7XX_L1_BIT(0), IREG_BASE(t7xx_dev) + DISABLE_ASPM_LOWPWR);
 	return t7xx_wait_pm_config(t7xx_dev);
 }
 
 void t7xx_pci_pm_exp_detected(struct t7xx_pci_dev *t7xx_dev)
 {
-	iowrite32(L1_DISABLE_BIT(0), IREG_BASE(t7xx_dev) + DIS_ASPM_LOWPWR_SET_0);
+	iowrite32(T7XX_L1_BIT(0), IREG_BASE(t7xx_dev) + DISABLE_ASPM_LOWPWR);
 	t7xx_wait_pm_config(t7xx_dev);
 	atomic_set(&t7xx_dev->md_pm_state, MTK_PM_EXCEPTION);
 }
@@ -211,30 +205,29 @@ void t7xx_pci_disable_sleep(struct t7xx_pci_dev *t7xx_dev)
 {
 	unsigned long flags;
 
-	if (atomic_read(&t7xx_dev->md_pm_state) < MTK_PM_RESUMED) {
-		atomic_inc(&t7xx_dev->sleep_disable_count);
-		complete_all(&t7xx_dev->sleep_lock_acquire);
-		return;
-	}
-
 	spin_lock_irqsave(&t7xx_dev->md_pm_lock, flags);
-	if (atomic_inc_return(&t7xx_dev->sleep_disable_count) == 1) {
-		u32 deep_sleep_enabled;
+	t7xx_dev->sleep_disable_count++;
+	if (atomic_read(&t7xx_dev->md_pm_state) < MTK_PM_RESUMED)
+		goto unlock_and_complete;
+
+	if (t7xx_dev->sleep_disable_count == 1) {
+		u32 status;
 
 		reinit_completion(&t7xx_dev->sleep_lock_acquire);
 		t7xx_dev_set_sleep_capability(t7xx_dev, false);
 
-		deep_sleep_enabled = ioread32(IREG_BASE(t7xx_dev) + T7XX_PCIE_RESOURCE_STATUS);
-		deep_sleep_enabled &= T7XX_PCIE_RESOURCE_STS_MSK;
-		if (deep_sleep_enabled) {
-			spin_unlock_irqrestore(&t7xx_dev->md_pm_lock, flags);
-			complete_all(&t7xx_dev->sleep_lock_acquire);
-			return;
-		}
+		status = ioread32(IREG_BASE(t7xx_dev) + T7XX_PCIE_RESOURCE_STATUS);
+		if (status & T7XX_PCIE_RESOURCE_STS_MSK)
+			goto unlock_and_complete;
 
 		t7xx_mhccif_h2d_swint_trigger(t7xx_dev, H2D_CH_DS_LOCK);
 	}
 	spin_unlock_irqrestore(&t7xx_dev->md_pm_lock, flags);
+	return;
+
+unlock_and_complete:
+	spin_unlock_irqrestore(&t7xx_dev->md_pm_lock, flags);
+	complete_all(&t7xx_dev->sleep_lock_acquire);
 }
 
 /**
@@ -247,16 +240,16 @@ void t7xx_pci_enable_sleep(struct t7xx_pci_dev *t7xx_dev)
 {
 	unsigned long flags;
 
+	spin_lock_irqsave(&t7xx_dev->md_pm_lock, flags);
+	t7xx_dev->sleep_disable_count--;
 	if (atomic_read(&t7xx_dev->md_pm_state) < MTK_PM_RESUMED) {
-		atomic_dec(&t7xx_dev->sleep_disable_count);
+		spin_unlock_irqrestore(&t7xx_dev->md_pm_lock, flags);
 		return;
 	}
 
-	if (atomic_dec_and_test(&t7xx_dev->sleep_disable_count)) {
-		spin_lock_irqsave(&t7xx_dev->md_pm_lock, flags);
+	if (t7xx_dev->sleep_disable_count == 0)
 		t7xx_dev_set_sleep_capability(t7xx_dev, true);
-		spin_unlock_irqrestore(&t7xx_dev->md_pm_lock, flags);
-	}
+	spin_unlock_irqrestore(&t7xx_dev->md_pm_lock, flags);
 }
 
 static int t7xx_send_pm_request(struct t7xx_pci_dev *t7xx_dev, u32 request)
@@ -286,10 +279,10 @@ static int __t7xx_pci_pm_suspend(struct pci_dev *pdev)
 		return -EFAULT;
 	}
 
-	iowrite32(L1_DISABLE_BIT(0), IREG_BASE(t7xx_dev) + DIS_ASPM_LOWPWR_SET_0);
+	iowrite32(T7XX_L1_BIT(0), IREG_BASE(t7xx_dev) + DISABLE_ASPM_LOWPWR);
 	ret = t7xx_wait_pm_config(t7xx_dev);
 	if (ret) {
-		iowrite32(L1_DISABLE_BIT(0), IREG_BASE(t7xx_dev) + DIS_ASPM_LOWPWR_CLR_0);
+		iowrite32(T7XX_L1_BIT(0), IREG_BASE(t7xx_dev) + ENABLE_ASPM_LOWPWR);
 		return ret;
 	}
 
@@ -327,7 +320,7 @@ static int __t7xx_pci_pm_suspend(struct pci_dev *pdev)
 			entity->suspend_late(t7xx_dev, entity->entity_param);
 	}
 
-	iowrite32(L1_DISABLE_BIT(0), IREG_BASE(t7xx_dev) + DIS_ASPM_LOWPWR_CLR_0);
+	iowrite32(T7XX_L1_BIT(0), IREG_BASE(t7xx_dev) + ENABLE_ASPM_LOWPWR);
 	return 0;
 
 abort_suspend:
@@ -339,7 +332,7 @@ static int __t7xx_pci_pm_suspend(struct pci_dev *pdev)
 			entity->resume(t7xx_dev, entity->entity_param);
 	}
 
-	iowrite32(L1_DISABLE_BIT(0), IREG_BASE(t7xx_dev) + DIS_ASPM_LOWPWR_CLR_0);
+	iowrite32(T7XX_L1_BIT(0), IREG_BASE(t7xx_dev) + ENABLE_ASPM_LOWPWR);
 	atomic_set(&t7xx_dev->md_pm_state, MTK_PM_RESUMED);
 	t7xx_pcie_mac_set_int(t7xx_dev, SAP_RGU_INT);
 	return ret;
@@ -416,7 +409,7 @@ static int __t7xx_pci_pm_resume(struct pci_dev *pdev, bool state_check)
 
 	t7xx_dev = pci_get_drvdata(pdev);
 	if (atomic_read(&t7xx_dev->md_pm_state) <= MTK_PM_INIT) {
-		iowrite32(L1_DISABLE_BIT(0), IREG_BASE(t7xx_dev) + DIS_ASPM_LOWPWR_CLR_0);
+		iowrite32(T7XX_L1_BIT(0), IREG_BASE(t7xx_dev) + ENABLE_ASPM_LOWPWR);
 		return 0;
 	}
 
@@ -484,7 +477,7 @@ static int __t7xx_pci_pm_resume(struct pci_dev *pdev, bool state_check)
 		}
 	}
 
-	iowrite32(L1_DISABLE_BIT(0), IREG_BASE(t7xx_dev) + DIS_ASPM_LOWPWR_SET_0);
+	iowrite32(T7XX_L1_BIT(0), IREG_BASE(t7xx_dev) + DISABLE_ASPM_LOWPWR);
 	t7xx_wait_pm_config(t7xx_dev);
 
 	list_for_each_entry(entity, &t7xx_dev->md_pm_entities, entity) {
@@ -511,7 +504,7 @@ static int __t7xx_pci_pm_resume(struct pci_dev *pdev, bool state_check)
 
 	t7xx_dev->rgu_pci_irq_en = true;
 	t7xx_pcie_mac_set_int(t7xx_dev, SAP_RGU_INT);
-	iowrite32(L1_DISABLE_BIT(0), IREG_BASE(t7xx_dev) + DIS_ASPM_LOWPWR_CLR_0);
+	iowrite32(T7XX_L1_BIT(0), IREG_BASE(t7xx_dev) + ENABLE_ASPM_LOWPWR);
 	pm_runtime_mark_last_busy(&pdev->dev);
 	atomic_set(&t7xx_dev->md_pm_state, MTK_PM_RESUMED);
 
@@ -650,7 +643,7 @@ static int t7xx_interrupt_init(struct t7xx_pci_dev *t7xx_dev)
 
 	/* IPs enable interrupts when ready */
 	for (i = 0; i < EXT_INT_NUM; i++)
-		t7xx_pcie_mac_clear_int(t7xx_dev, i);
+		t7xx_pcie_mac_set_int(t7xx_dev, i);
 
 	return 0;
 }
diff --git a/drivers/net/wwan/t7xx/t7xx_pci.h b/drivers/net/wwan/t7xx/t7xx_pci.h
index 245d958bb4ca..50b37056ce5a 100644
--- a/drivers/net/wwan/t7xx/t7xx_pci.h
+++ b/drivers/net/wwan/t7xx/t7xx_pci.h
@@ -5,7 +5,7 @@
  *
  * Authors:
  *  Haijun Liu <haijun.liu@mediatek.com>
- *  Ricardo Martinez<ricardo.martinez@linux.intel.com>
+ *  Ricardo Martinez <ricardo.martinez@linux.intel.com>
  *  Sreehari Kancharla <sreehari.kancharla@intel.com>
  *
  * Contributors:
@@ -50,16 +50,15 @@ typedef irqreturn_t (*t7xx_intr_callback)(int irq, void *param);
  * @pdev: PCI device
  * @base_addr: memory base addresses of HW components
  * @md: modem interface
+ * @ccmni_ctlb: context structure used to control the network data path
+ * @rgu_pci_irq_en: RGU callback ISR registered and active
  * @md_pm_entities: list of pm entities
- * @md_pm_lock: protects PCIe sleep lock
  * @md_pm_entity_mtx: protects md_pm_entities list
- * @sleep_disable_count: PCIe L1.2 lock counter
- * @sleep_lock_acquire: indicates that sleep has been disabled
  * @pm_sr_ack: ack from the device when went to sleep or woke up
  * @md_pm_state: state for resume/suspend
- * @ccmni_ctlb: context structure used to control the network data path
- * @rgu_pci_irq_en: RGU callback isr registered and active
- * @pools: pre allocated skb pools
+ * @md_pm_lock: protects PCIe sleep lock
+ * @sleep_disable_count: PCIe L1.2 lock counter
+ * @sleep_lock_acquire: indicates that sleep has been disabled
  */
 struct t7xx_pci_dev {
 	t7xx_intr_callback	intr_handler[EXT_INT_NUM];
@@ -68,18 +67,17 @@ struct t7xx_pci_dev {
 	struct pci_dev		*pdev;
 	struct t7xx_addr_base	base_addr;
 	struct t7xx_modem	*md;
+	struct t7xx_ccmni_ctrl	*ccmni_ctlb;
+	bool			rgu_pci_irq_en;
 
 	/* Low Power Items */
 	struct list_head	md_pm_entities;
-	spinlock_t		md_pm_lock;		/* Protects PCI resource lock */
 	struct mutex		md_pm_entity_mtx;	/* Protects MD PM entities list */
-	atomic_t		sleep_disable_count;
-	struct completion	sleep_lock_acquire;
 	struct completion	pm_sr_ack;
 	atomic_t		md_pm_state;
-
-	struct t7xx_ccmni_ctrl	*ccmni_ctlb;
-	bool			rgu_pci_irq_en;
+	spinlock_t		md_pm_lock;		/* Protects PCI resource lock */
+	unsigned int		sleep_disable_count;
+	struct completion	sleep_lock_acquire;
 };
 
 enum t7xx_pm_id {
diff --git a/drivers/net/wwan/t7xx/t7xx_pcie_mac.c b/drivers/net/wwan/t7xx/t7xx_pcie_mac.c
index fd4b19274d9e..76da4c15e3de 100644
--- a/drivers/net/wwan/t7xx/t7xx_pcie_mac.c
+++ b/drivers/net/wwan/t7xx/t7xx_pcie_mac.c
@@ -11,7 +11,7 @@
  * Contributors:
  *  Amir Hanania <amir.hanania@intel.com>
  *  Chiranjeevi Rapolu <chiranjeevi.rapolu@intel.com>
- *  Ricardo Martinez<ricardo.martinez@linux.intel.com>
+ *  Ricardo Martinez <ricardo.martinez@linux.intel.com>
  */
 
 #include <linux/bits.h>
@@ -256,8 +256,7 @@ void t7xx_pcie_mac_clear_int_status(struct t7xx_pci_dev *t7xx_dev, enum t7xx_int
  */
 void t7xx_pcie_set_mac_msix_cfg(struct t7xx_pci_dev *t7xx_dev, unsigned int irq_count)
 {
-	u32 val;
+	u32 val = ffs(irq_count) * 2 - 1;
 
-	val = ffs(irq_count) * 2 - 1;
 	iowrite32(val, IREG_BASE(t7xx_dev) + T7XX_PCIE_CFG_MSIX);
 }
diff --git a/drivers/net/wwan/t7xx/t7xx_pcie_mac.h b/drivers/net/wwan/t7xx/t7xx_pcie_mac.h
index 92f1036532ae..50336fa7e8c2 100644
--- a/drivers/net/wwan/t7xx/t7xx_pcie_mac.h
+++ b/drivers/net/wwan/t7xx/t7xx_pcie_mac.h
@@ -9,7 +9,7 @@
  *
  * Contributors:
  *  Moises Veleta <moises.veleta@intel.com>
- *  Ricardo Martinez<ricardo.martinez@linux.intel.com>
+ *  Ricardo Martinez <ricardo.martinez@linux.intel.com>
  */
 
 #ifndef __T7XX_PCIE_MAC_H__
diff --git a/drivers/net/wwan/t7xx/t7xx_port.h b/drivers/net/wwan/t7xx/t7xx_port.h
index d65d8d79f976..f4edec38fd28 100644
--- a/drivers/net/wwan/t7xx/t7xx_port.h
+++ b/drivers/net/wwan/t7xx/t7xx_port.h
@@ -6,7 +6,7 @@
  * Authors:
  *  Haijun Liu <haijun.liu@mediatek.com>
  *  Moises Veleta <moises.veleta@intel.com>
- *  Ricardo Martinez<ricardo.martinez@linux.intel.com>
+ *  Ricardo Martinez <ricardo.martinez@linux.intel.com>
  *
  * Contributors:
  *  Amir Hanania <amir.hanania@intel.com>
@@ -31,21 +31,11 @@
 #include "t7xx_hif_cldma.h"
 #include "t7xx_pci.h"
 
-#define PORT_F_RX_ALLOW_DROP	BIT(0)	/* Packet will be dropped if port's RX buffer full */
-#define PORT_F_RX_FULLED	BIT(1)	/* RX buffer has been detected to be full */
-#define PORT_F_USER_HEADER	BIT(2)	/* CCCI header will be provided by user, but not by CCCI */
-#define PORT_F_RX_EXCLUSIVE	BIT(3)	/* RX queue only has this one port */
-#define PORT_F_RX_ADJUST_HEADER	BIT(4)	/* Check whether need remove CCCI header while recv skb */
-#define PORT_F_RX_CH_TRAFFIC	BIT(5)	/* Enable port channel traffic */
-#define PORT_F_RX_CHAR_NODE	BIT(7)	/* Requires exporting char dev node to userspace */
-#define PORT_F_CHAR_NODE_SHOW	BIT(10)	/* The char dev node is shown to userspace by default */
-
 /* Reused for net TX, Data queue, same bit as RX_FULLED */
 #define PORT_F_TX_DATA_FULLED	BIT(1)
 #define PORT_F_TX_ACK_FULLED	BIT(8)
 
 #define PORT_CH_ID_MASK		GENMASK(7, 0)
-#define	PORT_INVALID_CH_ID	GENMASK(15, 0)
 
 /* Channel ID and Message ID definitions.
  * The channel number consists of peer_id(15:12) , channel_id(11:0)
@@ -64,7 +54,7 @@ enum port_ch {
 	PORT_CH_MD_LOG_TX = 0x202b,
 	PORT_CH_LB_IT_RX = 0x203e,	/* Loop back test */
 	PORT_CH_LB_IT_TX = 0x203f,
-	PORT_CH_STATUS_RX = 0x2043,	/* Status polling */
+	PORT_CH_STATUS_RX = 0x2043,	/* Status events */
 	PORT_CH_MIPC_RX = 0x20ce,	/* MIPC */
 	PORT_CH_MIPC_TX = 0x20cf,
 	PORT_CH_MBIM_RX = 0x20d0,
@@ -97,9 +87,7 @@ struct port_ops {
 	int (*disable_chl)(struct t7xx_port *port);
 };
 
-typedef int (*port_skb_handler)(struct t7xx_port *port, struct sk_buff *skb);
-
-struct t7xx_port_static {
+struct t7xx_port_conf {
 	enum port_ch		tx_ch;
 	enum port_ch		rx_ch;
 	unsigned char		txq_index;
@@ -107,7 +95,6 @@ struct t7xx_port_static {
 	unsigned char		txq_exp_index;
 	unsigned char		rxq_exp_index;
 	enum cldma_id		path_id;
-	unsigned int		flags;
 	struct port_ops		*ops;
 	char			*name;
 	enum wwan_port_type	port_type;
@@ -115,7 +102,7 @@ struct t7xx_port_static {
 
 struct t7xx_port {
 	/* Members not initialized in definition */
-	struct t7xx_port_static *port_static;
+	struct t7xx_port_conf	*port_conf;
 	struct wwan_port	*wwan_port;
 	struct t7xx_pci_dev	*t7xx_dev;
 	struct device		*dev;
@@ -137,13 +124,16 @@ struct t7xx_port {
 	spinlock_t		port_update_lock; /* Protects port configuration */
 	wait_queue_head_t	rx_wq;
 	int			rx_length_th;
-	port_skb_handler	skb_handler;
 	bool			chan_enable;
 	struct task_struct	*thread;
-	unsigned int		flags;
 };
 
-int t7xx_port_recv_skb(struct t7xx_port *port, struct sk_buff *skb);
-int t7xx_port_send_skb_to_md(struct t7xx_port *port, struct sk_buff *skb);
+struct sk_buff *t7xx_port_alloc_skb(int payload);
+struct sk_buff *t7xx_ctrl_alloc_skb(int payload);
+int t7xx_port_enqueue_skb(struct t7xx_port *port, struct sk_buff *skb);
+int t7xx_port_send_skb(struct t7xx_port *port, struct sk_buff *skb, unsigned int pkt_header,
+		       unsigned int ex_msg);
+int t7xx_port_send_ctl_skb(struct t7xx_port *port, struct sk_buff *skb, unsigned int msg,
+			   unsigned int ex_msg);
 
 #endif /* __T7XX_PORT_H__ */
diff --git a/drivers/net/wwan/t7xx/t7xx_port_ctrl_msg.c b/drivers/net/wwan/t7xx/t7xx_port_ctrl_msg.c
index d7edde246cd7..01df69b25a5d 100644
--- a/drivers/net/wwan/t7xx/t7xx_port_ctrl_msg.c
+++ b/drivers/net/wwan/t7xx/t7xx_port_ctrl_msg.c
@@ -5,7 +5,7 @@
  *
  * Authors:
  *  Haijun Liu <haijun.liu@mediatek.com>
- *  Ricardo Martinez<ricardo.martinez@linux.intel.com>
+ *  Ricardo Martinez <ricardo.martinez@linux.intel.com>
  *  Moises Veleta <moises.veleta@intel.com>
  *
  * Contributors:
@@ -15,6 +15,7 @@
  *  Sreehari Kancharla <sreehari.kancharla@intel.com>
  */
 
+#include <linux/bitfield.h>
 #include <linux/device.h>
 #include <linux/err.h>
 #include <linux/kthread.h>
@@ -22,16 +23,41 @@
 #include <linux/skbuff.h>
 #include <linux/spinlock.h>
 
-#include "t7xx_common.h"
 #include "t7xx_port.h"
 #include "t7xx_port_proxy.h"
 #include "t7xx_state_monitor.h"
 
-static int fsm_ee_message_handler(struct t7xx_fsm_ctl *ctl, struct sk_buff *skb)
+#define PORT_MSG_VERSION	GENMASK(31, 16)
+#define PORT_MSG_PRT_CNT	GENMASK(15, 0)
+
+struct port_msg {
+	__le32	head_pattern;
+	__le32	info;
+	__le32	tail_pattern;
+	__le32	data[];
+};
+
+static int port_ctl_send_msg_to_md(struct t7xx_port *port, unsigned int msg, unsigned int ex_msg)
+{
+	struct sk_buff *skb;
+	int ret;
+
+	skb = t7xx_ctrl_alloc_skb(0);
+	if (!skb)
+		return -ENOMEM;
+
+	ret = t7xx_port_send_ctl_skb(port, skb, msg, ex_msg);
+	if (ret)
+		dev_kfree_skb_any(skb);
+
+	return ret;
+}
+
+static int fsm_ee_message_handler(struct t7xx_port *port, struct t7xx_fsm_ctl *ctl,
+				  struct sk_buff *skb)
 {
 	struct ctrl_msg_header *ctrl_msg_h = (struct ctrl_msg_header *)skb->data;
 	struct device *dev = &ctl->md->t7xx_dev->pdev->dev;
-	struct port_proxy *port_prox = ctl->md->port_prox;
 	enum md_state md_state;
 	int ret = -EINVAL;
 
@@ -46,25 +72,31 @@ static int fsm_ee_message_handler(struct t7xx_fsm_ctl *ctl, struct sk_buff *skb)
 	case CTL_ID_MD_EX:
 		if (le32_to_cpu(ctrl_msg_h->ex_msg) != MD_EX_CHK_ID) {
 			dev_err(dev, "Receive invalid MD_EX %x\n", ctrl_msg_h->ex_msg);
-		} else {
-			t7xx_port_proxy_send_msg_to_md(port_prox, PORT_CH_CONTROL_TX, CTL_ID_MD_EX,
-						       MD_EX_CHK_ID);
-			ret = t7xx_fsm_append_event(ctl, FSM_EVENT_MD_EX, NULL, 0);
-			if (ret)
-				dev_err(dev, "Failed to append Modem Exception event");
+			break;
 		}
 
+		ret = port_ctl_send_msg_to_md(port, CTL_ID_MD_EX, MD_EX_CHK_ID);
+		if (ret) {
+			dev_err(dev, "Failed to send exception message to modem\n");
+			break;
+		}
+
+		ret = t7xx_fsm_append_event(ctl, FSM_EVENT_MD_EX, NULL, 0);
+		if (ret)
+			dev_err(dev, "Failed to append Modem Exception event");
+
 		break;
 
 	case CTL_ID_MD_EX_ACK:
 		if (le32_to_cpu(ctrl_msg_h->ex_msg) != MD_EX_CHK_ACK_ID) {
 			dev_err(dev, "Receive invalid MD_EX_ACK %x\n", ctrl_msg_h->ex_msg);
-		} else {
-			ret = t7xx_fsm_append_event(ctl, FSM_EVENT_MD_EX_REC_OK, NULL, 0);
-			if (ret)
-				dev_err(dev, "Failed to append Modem Exception Received event");
+			break;
 		}
 
+		ret = t7xx_fsm_append_event(ctl, FSM_EVENT_MD_EX_REC_OK, NULL, 0);
+		if (ret)
+			dev_err(dev, "Failed to append Modem Exception Received event");
+
 		break;
 
 	case CTL_ID_MD_EX_PASS:
@@ -81,22 +113,61 @@ static int fsm_ee_message_handler(struct t7xx_fsm_ctl *ctl, struct sk_buff *skb)
 	return ret;
 }
 
+/**
+ * t7xx_port_enum_msg_handler() - Parse the port enumeration message to create/remove nodes.
+ * @md: Modem context.
+ * @msg: Message.
+ *
+ * Used to control create/remove device node.
+ *
+ * Return:
+ * * 0		- Success.
+ * * -EFAULT	- Message check failure.
+ */
+int t7xx_port_enum_msg_handler(struct t7xx_modem *md, void *msg)
+{
+	struct device *dev = &md->t7xx_dev->pdev->dev;
+	unsigned int version, port_count, i;
+	struct port_msg *port_msg = msg;
+
+	version = FIELD_GET(PORT_MSG_VERSION, le32_to_cpu(port_msg->info));
+	if (version != PORT_ENUM_VER ||
+	    le32_to_cpu(port_msg->head_pattern) != PORT_ENUM_HEAD_PATTERN ||
+	    le32_to_cpu(port_msg->tail_pattern) != PORT_ENUM_TAIL_PATTERN) {
+		dev_err(dev, "Invalid port control message %x:%x:%x\n",
+			version, le32_to_cpu(port_msg->head_pattern),
+			le32_to_cpu(port_msg->tail_pattern));
+		return -EFAULT;
+	}
+
+	port_count = FIELD_GET(PORT_MSG_PRT_CNT, le32_to_cpu(port_msg->info));
+	for (i = 0; i < port_count; i++) {
+		u32 port_info = le32_to_cpu(port_msg->data[i]);
+		unsigned int ch_id;
+		bool en_flag;
+
+		ch_id = FIELD_GET(PORT_INFO_CH_ID, port_info);
+		en_flag = !!(port_info & PORT_INFO_ENFLG);
+		if (t7xx_port_proxy_chl_enable_disable(md->port_prox, ch_id, en_flag))
+			dev_dbg(dev, "Port:%x not found\n", ch_id);
+	}
+
+	return 0;
+}
+
 static int control_msg_handler(struct t7xx_port *port, struct sk_buff *skb)
 {
-	struct t7xx_port_static *port_static = port->port_static;
 	struct t7xx_fsm_ctl *ctl = port->t7xx_dev->md->fsm_ctl;
-	struct port_proxy *port_prox = ctl->md->port_prox;
+	struct t7xx_port_conf *port_conf = port->port_conf;
 	struct ctrl_msg_header *ctrl_msg_h;
 	int ret = 0;
 
-	skb_pull(skb, sizeof(struct ccci_header));
-
 	ctrl_msg_h = (struct ctrl_msg_header *)skb->data;
 	switch (le32_to_cpu(ctrl_msg_h->ctrl_msg_id)) {
 	case CTL_ID_HS2_MSG:
 		skb_pull(skb, sizeof(*ctrl_msg_h));
 
-		if (port_static->rx_ch == PORT_CH_CONTROL_RX) {
+		if (port_conf->rx_ch == PORT_CH_CONTROL_RX) {
 			ret = t7xx_fsm_append_event(ctl, FSM_EVENT_MD_HS2, skb->data,
 						    le32_to_cpu(ctrl_msg_h->data_length));
 			if (ret)
@@ -110,19 +181,18 @@ static int control_msg_handler(struct t7xx_port *port, struct sk_buff *skb)
 	case CTL_ID_MD_EX_ACK:
 	case CTL_ID_MD_EX_PASS:
 	case CTL_ID_DRV_VER_ERROR:
-		ret = fsm_ee_message_handler(ctl, skb);
+		ret = fsm_ee_message_handler(port, ctl, skb);
 		dev_kfree_skb_any(skb);
 		break;
 
 	case CTL_ID_PORT_ENUM:
 		skb_pull(skb, sizeof(*ctrl_msg_h));
-		ret = t7xx_port_proxy_node_control(ctl->md, (struct port_msg *)skb->data);
+		ret = t7xx_port_enum_msg_handler(ctl->md, (struct port_msg *)skb->data);
 		if (!ret)
-			t7xx_port_proxy_send_msg_to_md(port_prox, PORT_CH_CONTROL_TX,
-						       CTL_ID_PORT_ENUM, 0);
+			ret = port_ctl_send_msg_to_md(port, CTL_ID_PORT_ENUM, 0);
 		else
-			t7xx_port_proxy_send_msg_to_md(port_prox, PORT_CH_CONTROL_TX,
-						       CTL_ID_PORT_ENUM, PORT_ENUM_VER_MISMATCH);
+			ret = port_ctl_send_msg_to_md(port, CTL_ID_PORT_ENUM,
+						      PORT_ENUM_VER_MISMATCH);
 
 		break;
 
@@ -134,8 +204,7 @@ static int control_msg_handler(struct t7xx_port *port, struct sk_buff *skb)
 	}
 
 	if (ret)
-		dev_err(port->dev, "%s control message handle error: %d\n", port_static->name,
-			ret);
+		dev_err(port->dev, "%s control message handle error: %d\n", port_conf->name, ret);
 
 	return ret;
 }
@@ -162,7 +231,7 @@ static int port_ctl_rx_thread(void *arg)
 		skb = __skb_dequeue(&port->rx_skb_list);
 		spin_unlock_irqrestore(&port->rx_wq.lock, flags);
 
-		port->skb_handler(port, skb);
+		control_msg_handler(port, skb);
 	}
 
 	return 0;
@@ -170,10 +239,9 @@ static int port_ctl_rx_thread(void *arg)
 
 static int port_ctl_init(struct t7xx_port *port)
 {
-	struct t7xx_port_static *port_static = port->port_static;
+	struct t7xx_port_conf *port_conf = port->port_conf;
 
-	port->skb_handler = &control_msg_handler;
-	port->thread = kthread_run(port_ctl_rx_thread, port, "%s", port_static->name);
+	port->thread = kthread_run(port_ctl_rx_thread, port, "%s", port_conf->name);
 	if (IS_ERR(port->thread)) {
 		dev_err(port->dev, "Failed to start port control thread\n");
 		return PTR_ERR(port->thread);
@@ -200,6 +268,6 @@ static void port_ctl_uninit(struct t7xx_port *port)
 
 struct port_ops ctl_port_ops = {
 	.init = port_ctl_init,
-	.recv_skb = t7xx_port_recv_skb,
+	.recv_skb = t7xx_port_enqueue_skb,
 	.uninit = port_ctl_uninit,
 };
diff --git a/drivers/net/wwan/t7xx/t7xx_port_proxy.c b/drivers/net/wwan/t7xx/t7xx_port_proxy.c
index 9a5cc64904d3..77484f30f860 100644
--- a/drivers/net/wwan/t7xx/t7xx_port_proxy.c
+++ b/drivers/net/wwan/t7xx/t7xx_port_proxy.c
@@ -7,7 +7,7 @@
  *  Amir Hanania <amir.hanania@intel.com>
  *  Haijun Liu <haijun.liu@mediatek.com>
  *  Moises Veleta <moises.veleta@intel.com>
- *  Ricardo Martinez<ricardo.martinez@linux.intel.com>
+ *  Ricardo Martinez <ricardo.martinez@linux.intel.com>
  *
  * Contributors:
  *  Andy Shevchenko <andriy.shevchenko@linux.intel.com>
@@ -31,7 +31,6 @@
 #include <linux/wait.h>
 #include <linux/wwan.h>
 
-#include "t7xx_common.h"
 #include "t7xx_hif_cldma.h"
 #include "t7xx_modem_ops.h"
 #include "t7xx_port.h"
@@ -45,11 +44,11 @@
 #define INVALID_SEQ_NUM			GENMASK(15, 0)
 
 #define for_each_proxy_port(i, p, proxy)	\
-	for (i = 0, (p) = &(proxy)->ports_private[i];	\
+	for (i = 0, (p) = &(proxy)->ports[i];	\
 	     i < (proxy)->port_number;		\
-	     i++, (p) = &(proxy)->ports_private[i])
+	     i++, (p) = &(proxy)->ports[i])
 
-static struct t7xx_port_static t7xx_md_ports[] = {
+static struct t7xx_port_conf t7xx_md_port_conf[] = {
 	{
 		.tx_ch = PORT_CH_UART2_TX,
 		.rx_ch = PORT_CH_UART2_RX,
@@ -58,7 +57,6 @@ static struct t7xx_port_static t7xx_md_ports[] = {
 		.txq_exp_index = 0xff,
 		.rxq_exp_index = 0xff,
 		.path_id = CLDMA_ID_MD,
-		.flags = 0,
 		.ops = &wwan_sub_port_ops,
 		.name = "AT",
 		.port_type = WWAN_PORT_AT,
@@ -67,10 +65,7 @@ static struct t7xx_port_static t7xx_md_ports[] = {
 		.rx_ch = PORT_CH_MBIM_RX,
 		.txq_index = Q_IDX_MBIM,
 		.rxq_index = Q_IDX_MBIM,
-		.txq_exp_index = 0,
-		.rxq_exp_index = 0,
 		.path_id = CLDMA_ID_MD,
-		.flags = 0,
 		.ops = &wwan_sub_port_ops,
 		.name = "MBIM",
 		.port_type = WWAN_PORT_MBIM,
@@ -79,10 +74,7 @@ static struct t7xx_port_static t7xx_md_ports[] = {
 		.rx_ch = PORT_CH_CONTROL_RX,
 		.txq_index = Q_IDX_CTRL,
 		.rxq_index = Q_IDX_CTRL,
-		.txq_exp_index = 0,
-		.rxq_exp_index = 0,
 		.path_id = CLDMA_ID_MD,
-		.flags = 0,
 		.ops = &ctl_port_ops,
 		.name = "t7xx_ctrl",
 	},
@@ -90,43 +82,36 @@ static struct t7xx_port_static t7xx_md_ports[] = {
 
 static struct t7xx_port *t7xx_proxy_get_port_by_ch(struct port_proxy *port_prox, enum port_ch ch)
 {
-	struct t7xx_port_static *port_static;
+	struct t7xx_port_conf *port_conf;
 	struct t7xx_port *port;
 	int i;
 
 	for_each_proxy_port(i, port, port_prox) {
-		port_static = port->port_static;
-		if (port_static->rx_ch == ch || port_static->tx_ch == ch)
+		port_conf = port->port_conf;
+		if (port_conf->rx_ch == ch || port_conf->tx_ch == ch)
 			return port;
 	}
 
 	return NULL;
 }
 
-void t7xx_port_proxy_set_tx_seq_num(struct t7xx_port *port, struct ccci_header *ccci_h)
-{
-	ccci_h->status &= cpu_to_le32(~CCCI_H_SEQ_FLD);
-	ccci_h->status |= cpu_to_le32(FIELD_PREP(CCCI_H_SEQ_FLD, port->seq_nums[MTK_TX]));
-	ccci_h->status |= cpu_to_le32(CCCI_H_AST_BIT);
-}
-
 static u16 t7xx_port_next_rx_seq_num(struct t7xx_port *port, struct ccci_header *ccci_h)
 {
-	u16 seq_num, next_seq_num, assert_bit;
+	u16 seq_num, next_seq_num;
+	bool assert_bit;
 
 	seq_num = FIELD_GET(CCCI_H_SEQ_FLD, le32_to_cpu(ccci_h->status));
 	next_seq_num = (seq_num + 1) & FIELD_MAX(CCCI_H_SEQ_FLD);
 	assert_bit = !!(le32_to_cpu(ccci_h->status) & CCCI_H_AST_BIT);
-	if (!assert_bit || port->seq_nums[MTK_RX] > FIELD_MAX(CCCI_H_SEQ_FLD))
+	if (!assert_bit || port->seq_nums[MTK_RX] == INVALID_SEQ_NUM)
 		return next_seq_num;
 
-	if (seq_num != port->seq_nums[MTK_RX]) {
+	if (seq_num != port->seq_nums[MTK_RX])
 		dev_warn_ratelimited(port->dev,
 				     "seq num out-of-order %u != %u (header %X, len %X)\n",
 				     seq_num, port->seq_nums[MTK_RX],
 				     le32_to_cpu(ccci_h->packet_header),
 				     le32_to_cpu(ccci_h->packet_len));
-	}
 
 	return next_seq_num;
 }
@@ -144,11 +129,11 @@ void t7xx_port_proxy_reset(struct port_proxy *port_prox)
 
 static int t7xx_port_get_queue_no(struct t7xx_port *port)
 {
-	struct t7xx_port_static *port_static = port->port_static;
+	struct t7xx_port_conf *port_conf = port->port_conf;
 	struct t7xx_fsm_ctl *ctl = port->t7xx_dev->md->fsm_ctl;
 
 	return t7xx_fsm_get_md_state(ctl) == MD_STATE_EXCEPTION ?
-		port_static->txq_exp_index : port_static->txq_index;
+		port_conf->txq_exp_index : port_conf->txq_index;
 }
 
 static void t7xx_port_struct_init(struct t7xx_port *port)
@@ -162,124 +147,139 @@ static void t7xx_port_struct_init(struct t7xx_port *port)
 	atomic_set(&port->usage_cnt, 0);
 }
 
-static void t7xx_port_adjust_skb(struct t7xx_port *port, struct sk_buff *skb)
+struct sk_buff *t7xx_port_alloc_skb(int payload)
 {
-	struct ccci_header *ccci_h = (struct ccci_header *)skb->data;
-	struct t7xx_port_static *port_static = port->port_static;
-
-	if (port->flags & PORT_F_USER_HEADER) {
-		if (le32_to_cpu(ccci_h->packet_header) == CCCI_HEADER_NO_DATA) {
-			if (skb->len > sizeof(*ccci_h)) {
-				dev_err_ratelimited(port->dev,
-						    "Recv unexpected data for %s, skb->len=%d\n",
-						    port_static->name, skb->len);
-				skb_trim(skb, sizeof(*ccci_h));
-			}
-		}
-	} else {
-		skb_pull(skb, sizeof(*ccci_h));
-	}
+	struct sk_buff *skb = __dev_alloc_skb(payload + sizeof(struct ccci_header), GFP_KERNEL);
+
+	if (skb)
+		skb_reserve(skb, sizeof(struct ccci_header));
+
+	return skb;
+}
+
+struct sk_buff *t7xx_ctrl_alloc_skb(int payload)
+{
+	struct sk_buff *skb = t7xx_port_alloc_skb(payload + sizeof(struct ctrl_msg_header));
+
+	if (skb)
+		skb_reserve(skb, sizeof(struct ctrl_msg_header));
+
+	return skb;
 }
 
 /**
- * t7xx_port_recv_skb() - receive skb from modem or HIF.
- * @port: port to use.
- * @skb: skb to use.
- *
- * Used to receive native HIF RX data, which has same the RX receive flow.
+ * t7xx_port_enqueue_skb() - Enqueue the received skb into the port's rx_skb_list.
+ * @port: port context.
+ * @skb: received skb.
  *
  * Return:
  * * 0		- Success.
- * * ERROR	- Error code.
+ * * -ENOBUFS	- Not enough buffer space.
  */
-int t7xx_port_recv_skb(struct t7xx_port *port, struct sk_buff *skb)
+int t7xx_port_enqueue_skb(struct t7xx_port *port, struct sk_buff *skb)
 {
-	struct ccci_header *ccci_h;
 	unsigned long flags;
-	u32 channel;
-	int ret = 0;
 
 	spin_lock_irqsave(&port->rx_wq.lock, flags);
 	if (port->rx_skb_list.qlen >= port->rx_length_th) {
-		port->flags |= PORT_F_RX_FULLED;
 		spin_unlock_irqrestore(&port->rx_wq.lock, flags);
 
 		return -ENOBUFS;
 	}
-	ccci_h = (struct ccci_header *)skb->data;
-	port->flags &= ~PORT_F_RX_FULLED;
-	if (port->flags & PORT_F_RX_ADJUST_HEADER)
-		t7xx_port_adjust_skb(port, skb);
-	channel = FIELD_GET(CCCI_H_CHN_FLD, le32_to_cpu(ccci_h->status));
-	if (channel == PORT_CH_STATUS_RX) {
-		ret = port->skb_handler(port, skb);
-	} else {
-		if (port->wwan_port)
-			wwan_port_rx(port->wwan_port, skb);
-		else
-			__skb_queue_tail(&port->rx_skb_list, skb);
-	}
+	__skb_queue_tail(&port->rx_skb_list, skb);
 	spin_unlock_irqrestore(&port->rx_wq.lock, flags);
 
 	wake_up_all(&port->rx_wq);
-	return ret;
+	return 0;
 }
 
-static struct cldma_ctrl *get_md_ctrl(struct t7xx_port *port)
+static int t7xx_port_send_raw_skb(struct t7xx_port *port, struct sk_buff *skb)
 {
-	enum cldma_id id = port->port_static->path_id;
+	enum cldma_id path_id = port->port_conf->path_id;
+	struct cldma_ctrl *md_ctrl;
+	int ret, tx_qno;
 
-	return port->t7xx_dev->md->md_ctrl[id];
+	md_ctrl = port->t7xx_dev->md->md_ctrl[path_id];
+	tx_qno = t7xx_port_get_queue_no(port);
+	ret = t7xx_cldma_send_skb(md_ctrl, tx_qno, skb);
+	if (ret)
+		dev_err(port->dev, "Failed to send skb: %d\n", ret);
+
+	return ret;
 }
 
-int t7xx_port_proxy_send_skb(struct t7xx_port *port, struct sk_buff *skb)
+static int t7xx_port_send_ccci_skb(struct t7xx_port *port, struct sk_buff *skb,
+				   unsigned int pkt_header, unsigned int ex_msg)
 {
-	struct ccci_header *ccci_h = (struct ccci_header *)(skb->data);
-	struct cldma_ctrl *md_ctrl;
-	unsigned char tx_qno;
+	struct t7xx_port_conf *port_conf = port->port_conf;
+	struct ccci_header *ccci_h;
+	u32 status;
 	int ret;
 
-	tx_qno = t7xx_port_get_queue_no(port);
-	t7xx_port_proxy_set_tx_seq_num(port, ccci_h);
+	ccci_h = skb_push(skb, sizeof(*ccci_h));
+	status = FIELD_PREP(CCCI_H_CHN_FLD, port_conf->tx_ch) |
+		 FIELD_PREP(CCCI_H_SEQ_FLD, port->seq_nums[MTK_TX]) | CCCI_H_AST_BIT;
+	ccci_h->status = cpu_to_le32(status);
+	ccci_h->packet_header = cpu_to_le32(pkt_header);
+	ccci_h->packet_len = cpu_to_le32(skb->len);
+	ccci_h->ex_msg = cpu_to_le32(ex_msg);
 
-	md_ctrl = get_md_ctrl(port);
-	ret = t7xx_cldma_send_skb(md_ctrl, tx_qno, skb);
-	if (ret) {
-		dev_err(port->dev, "Failed to send skb: %d\n", ret);
+	ret = t7xx_port_send_raw_skb(port, skb);
+	if (ret)
 		return ret;
-	}
 
 	port->seq_nums[MTK_TX]++;
-
 	return 0;
 }
 
-int t7xx_port_send_skb_to_md(struct t7xx_port *port, struct sk_buff *skb)
+int t7xx_port_send_ctl_skb(struct t7xx_port *port, struct sk_buff *skb, unsigned int msg,
+			   unsigned int ex_msg)
+{
+	struct ctrl_msg_header *ctrl_msg_h;
+	unsigned int msg_len = skb->len;
+	u32 pkt_header = 0;
+
+	ctrl_msg_h = skb_push(skb, sizeof(*ctrl_msg_h));
+	ctrl_msg_h->ctrl_msg_id = cpu_to_le32(msg);
+	ctrl_msg_h->ex_msg = cpu_to_le32(ex_msg);
+	ctrl_msg_h->data_length = cpu_to_le32(msg_len);
+
+	if (!msg_len)
+		pkt_header = CCCI_HEADER_NO_DATA;
+
+	return t7xx_port_send_ccci_skb(port, skb, pkt_header, ex_msg);
+}
+
+int t7xx_port_send_skb(struct t7xx_port *port, struct sk_buff *skb, unsigned int pkt_header,
+		       unsigned int ex_msg)
 {
-	struct t7xx_port_static *port_static = port->port_static;
 	struct t7xx_fsm_ctl *ctl = port->t7xx_dev->md->fsm_ctl;
-	struct cldma_ctrl *md_ctrl;
-	enum md_state md_state;
 	unsigned int fsm_state;
 
-	md_state = t7xx_fsm_get_md_state(ctl);
-
 	fsm_state = t7xx_fsm_get_ctl_state(ctl);
 	if (fsm_state != FSM_STATE_PRE_START) {
-		if (md_state == MD_STATE_WAITING_FOR_HS1 || md_state == MD_STATE_WAITING_FOR_HS2)
+		struct t7xx_port_conf *port_conf = port->port_conf;
+		enum md_state md_state = t7xx_fsm_get_md_state(ctl);
+
+		switch (md_state) {
+		case MD_STATE_EXCEPTION:
+			if (port_conf->tx_ch != PORT_CH_MD_LOG_TX)
+				return -EBUSY;
+			break;
+
+		case MD_STATE_WAITING_FOR_HS1:
+		case MD_STATE_WAITING_FOR_HS2:
+		case MD_STATE_STOPPED:
+		case MD_STATE_WAITING_TO_STOP:
+		case MD_STATE_INVALID:
 			return -ENODEV;
 
-		if (md_state == MD_STATE_EXCEPTION && port_static->tx_ch != PORT_CH_MD_LOG_TX &&
-		    port_static->tx_ch != PORT_CH_UART1_TX)
-			return -EBUSY;
-
-		if (md_state == MD_STATE_STOPPED || md_state == MD_STATE_WAITING_TO_STOP ||
-		    md_state == MD_STATE_INVALID)
-			return -ENODEV;
+		default:
+			break;
+		}
 	}
 
-	md_ctrl = get_md_ctrl(port);
-	return t7xx_cldma_send_skb(md_ctrl, t7xx_port_get_queue_no(port), skb);
+	return t7xx_port_send_ccci_skb(port, skb, pkt_header, ex_msg);
 }
 
 static void t7xx_proxy_setup_ch_mapping(struct port_proxy *port_prox)
@@ -297,70 +297,14 @@ static void t7xx_proxy_setup_ch_mapping(struct port_proxy *port_prox)
 	}
 
 	for_each_proxy_port(i, port, port_prox) {
-		struct t7xx_port_static *port_static = port->port_static;
-		enum cldma_id path_id = port_static->path_id;
+		struct t7xx_port_conf *port_conf = port->port_conf;
+		enum cldma_id path_id = port_conf->path_id;
 		u8 ch_id;
 
-		ch_id = FIELD_GET(PORT_CH_ID_MASK, port_static->rx_ch);
+		ch_id = FIELD_GET(PORT_CH_ID_MASK, port_conf->rx_ch);
 		list_add_tail(&port->entry, &port_prox->rx_ch_ports[ch_id]);
 		list_add_tail(&port->queue_entry,
-			      &port_prox->queue_ports[path_id][port_static->rxq_index]);
-	}
-}
-
-void t7xx_ccci_header_init(struct ccci_header *ccci_h, unsigned int pkt_header,
-			   size_t pkt_len, enum port_ch ch, unsigned int ex_msg)
-{
-	ccci_h->packet_header = cpu_to_le32(pkt_header);
-	ccci_h->packet_len = cpu_to_le32(pkt_len);
-	ccci_h->status &= cpu_to_le32(~CCCI_H_CHN_FLD);
-	ccci_h->status |= cpu_to_le32(FIELD_PREP(CCCI_H_CHN_FLD, ch));
-	ccci_h->ex_msg = cpu_to_le32(ex_msg);
-}
-
-void t7xx_ctrl_msg_header_init(struct ctrl_msg_header *ctrl_msg_h, unsigned int msg_id,
-			       unsigned int ex_msg, unsigned int len)
-{
-	ctrl_msg_h->ctrl_msg_id = cpu_to_le32(msg_id);
-	ctrl_msg_h->ex_msg = cpu_to_le32(ex_msg);
-	ctrl_msg_h->data_length = cpu_to_le32(len);
-}
-
-void t7xx_port_proxy_send_msg_to_md(struct port_proxy *port_prox, enum port_ch ch,
-				    unsigned int msg, unsigned int ex_msg)
-{
-	struct ctrl_msg_header *ctrl_msg_h;
-	struct ccci_header *ccci_h;
-	struct t7xx_port *port;
-	struct sk_buff *skb;
-	int ret;
-
-	port = t7xx_proxy_get_port_by_ch(port_prox, ch);
-	if (!port)
-		return;
-
-	skb = __dev_alloc_skb(sizeof(*ccci_h), GFP_KERNEL);
-	if (!skb)
-		return;
-
-	if (ch == PORT_CH_CONTROL_TX) {
-		ccci_h = (struct ccci_header *)(skb->data);
-		t7xx_ccci_header_init(ccci_h, CCCI_HEADER_NO_DATA,
-				      sizeof(*ctrl_msg_h) + sizeof(*ccci_h), ch, 0);
-		ctrl_msg_h = (struct ctrl_msg_header *)(skb->data + sizeof(*ccci_h));
-		t7xx_ctrl_msg_header_init(ctrl_msg_h, msg, ex_msg, 0);
-		skb_put(skb, sizeof(*ccci_h) + sizeof(*ctrl_msg_h));
-	} else {
-		ccci_h = skb_put(skb, sizeof(*ccci_h));
-		t7xx_ccci_header_init(ccci_h, CCCI_HEADER_NO_DATA, msg, ch, ex_msg);
-	}
-
-	ret = t7xx_port_proxy_send_skb(port, skb);
-	if (ret) {
-		struct t7xx_port_static *port_static = port->port_static;
-
-		dev_kfree_skb_any(skb);
-		dev_err(port->dev, "port%s send to MD fail\n", port_static->name);
+			      &port_prox->queue_ports[path_id][port_conf->rxq_index]);
 	}
 }
 
@@ -375,10 +319,10 @@ static struct t7xx_port *t7xx_port_proxy_find_port(struct t7xx_pci_dev *t7xx_dev
 	ch_id = FIELD_GET(PORT_CH_ID_MASK, channel);
 	port_list = &port_prox->rx_ch_ports[ch_id];
 	list_for_each_entry(port, port_list, entry) {
-		struct t7xx_port_static *port_static = port->port_static;
+		struct t7xx_port_conf *port_conf = port->port_conf;
 
-		if (queue->md_ctrl->hif_id == port_static->path_id &&
-		    channel == port_static->rx_ch)
+		if (queue->md_ctrl->hif_id == port_conf->path_id &&
+		    channel == port_conf->rx_ch)
 			return port;
 	}
 
@@ -400,7 +344,7 @@ static int t7xx_port_proxy_recv_skb(struct cldma_queue *queue, struct sk_buff *s
 	struct t7xx_pci_dev *t7xx_dev = queue->md_ctrl->t7xx_dev;
 	struct t7xx_fsm_ctl *ctl = t7xx_dev->md->fsm_ctl;
 	struct device *dev = queue->md_ctrl->dev;
-	struct t7xx_port_static *port_static;
+	struct t7xx_port_conf *port_conf;
 	struct t7xx_port *port;
 	u16 seq_num, channel;
 	int ret;
@@ -421,17 +365,14 @@ static int t7xx_port_proxy_recv_skb(struct cldma_queue *queue, struct sk_buff *s
 	}
 
 	seq_num = t7xx_port_next_rx_seq_num(port, ccci_h);
-	port_static = port->port_static;
-	ret = port_static->ops->recv_skb(port, skb);
-	if (ret && port->flags & PORT_F_RX_ALLOW_DROP) {
-		port->seq_nums[MTK_RX] = seq_num;
-		dev_err_ratelimited(dev, "Packed drop on port %s, error %d\n",
-				    port_static->name, ret);
-		goto drop_skb;
-	}
+	port_conf = port->port_conf;
+	skb_pull(skb, sizeof(*ccci_h));
 
-	if (ret)
+	ret = port_conf->ops->recv_skb(port, skb);
+	if (ret) {
+		skb_push(skb, sizeof(*ccci_h));
 		return ret;
+	}
 
 	port->seq_nums[MTK_RX] = seq_num;
 	return 0;
@@ -455,10 +396,10 @@ void t7xx_port_proxy_md_status_notify(struct port_proxy *port_prox, unsigned int
 	int i;
 
 	for_each_proxy_port(i, port, port_prox) {
-		struct t7xx_port_static *port_static = port->port_static;
+		struct t7xx_port_conf *port_conf = port->port_conf;
 
-		if (port_static->ops->md_state_notify)
-			port_static->ops->md_state_notify(port, state);
+		if (port_conf->ops->md_state_notify)
+			port_conf->ops->md_state_notify(port, state);
 	}
 }
 
@@ -469,24 +410,20 @@ static void t7xx_proxy_init_all_ports(struct t7xx_modem *md)
 	int i;
 
 	for_each_proxy_port(i, port, port_prox) {
-		struct t7xx_port_static *port_static = port->port_static;
+		struct t7xx_port_conf *port_conf = port->port_conf;
 
 		t7xx_port_struct_init(port);
 
-		if (port_static->tx_ch == PORT_CH_CONTROL_TX)
+		if (port_conf->tx_ch == PORT_CH_CONTROL_TX)
 			md->core_md.ctl_port = port;
 
 		port->t7xx_dev = md->t7xx_dev;
 		port->dev = &md->t7xx_dev->pdev->dev;
 		spin_lock_init(&port->port_update_lock);
+		port->chan_enable = false;
 
-		if (port->flags & PORT_F_CHAR_NODE_SHOW)
-			port->chan_enable = true;
-		else
-			port->chan_enable = false;
-
-		if (port_static->ops->init)
-			port_static->ops->init(port);
+		if (port_conf->ops->init)
+			port_conf->ops->init(port);
 	}
 
 	t7xx_proxy_setup_ch_mapping(port_prox);
@@ -494,34 +431,26 @@ static void t7xx_proxy_init_all_ports(struct t7xx_modem *md)
 
 static int t7xx_proxy_alloc(struct t7xx_modem *md)
 {
-	unsigned int port_number = ARRAY_SIZE(t7xx_md_ports);
+	unsigned int port_number = ARRAY_SIZE(t7xx_md_port_conf);
 	struct device *dev = &md->t7xx_dev->pdev->dev;
-	struct t7xx_port *ports_private;
 	struct port_proxy *port_prox;
 	int i;
 
-	port_prox = devm_kzalloc(dev, sizeof(*port_prox), GFP_KERNEL);
+	port_prox = devm_kzalloc(dev, sizeof(*port_prox) + sizeof(struct t7xx_port) * port_number,
+				 GFP_KERNEL);
 	if (!port_prox)
 		return -ENOMEM;
 
 	md->port_prox = port_prox;
 	port_prox->dev = dev;
-	port_prox->ports_shared = t7xx_md_ports;
 
-	ports_private = devm_kzalloc(dev, sizeof(*ports_private) * port_number, GFP_KERNEL);
-	if (!ports_private)
-		return -ENOMEM;
+	for (i = 0; i < port_number; i++)
+		port_prox->ports[i].port_conf = &t7xx_md_port_conf[i];
 
-	for (i = 0; i < port_number; i++) {
-		ports_private[i].port_static = &port_prox->ports_shared[i];
-		ports_private[i].flags = port_prox->ports_shared[i].flags;
-	}
-
-	port_prox->ports_private = ports_private;
 	port_prox->port_number = port_number;
 	t7xx_proxy_init_all_ports(md);
 	return 0;
-};
+}
 
 /**
  * t7xx_port_proxy_init() - Initialize ports.
@@ -551,70 +480,30 @@ void t7xx_port_proxy_uninit(struct port_proxy *port_prox)
 	int i;
 
 	for_each_proxy_port(i, port, port_prox) {
-		struct t7xx_port_static *port_static = port->port_static;
+		struct t7xx_port_conf *port_conf = port->port_conf;
 
-		if (port_static->ops->uninit)
-			port_static->ops->uninit(port);
+		if (port_conf->ops->uninit)
+			port_conf->ops->uninit(port);
 	}
 }
 
-/**
- * t7xx_port_proxy_node_control() - Create/remove node.
- * @md: Modem.
- * @port_msg: Message.
- *
- * Used to control create/remove device node.
- *
- * Return:
- * * 0		- Success.
- * * -EFAULT	- Message check failure.
- */
-int t7xx_port_proxy_node_control(struct t7xx_modem *md, struct port_msg *port_msg)
+int t7xx_port_proxy_chl_enable_disable(struct port_proxy *port_prox, unsigned int ch_id,
+				       bool en_flag)
 {
-	u32 *port_info_base = (void *)port_msg + sizeof(*port_msg);
-	struct device *dev = &md->t7xx_dev->pdev->dev;
-	unsigned int version, ports, i;
-
-	version = FIELD_GET(PORT_MSG_VERSION, le32_to_cpu(port_msg->info));
-	if (version != PORT_ENUM_VER ||
-	    le32_to_cpu(port_msg->head_pattern) != PORT_ENUM_HEAD_PATTERN ||
-	    le32_to_cpu(port_msg->tail_pattern) != PORT_ENUM_TAIL_PATTERN) {
-		dev_err(dev, "Invalid port control message %x:%x:%x\n",
-			version, le32_to_cpu(port_msg->head_pattern),
-			le32_to_cpu(port_msg->tail_pattern));
-		return -EFAULT;
-	}
+	struct t7xx_port *port = t7xx_proxy_get_port_by_ch(port_prox, ch_id);
+	struct t7xx_port_conf *port_conf;
 
-	ports = FIELD_GET(PORT_MSG_PRT_CNT, le32_to_cpu(port_msg->info));
-	for (i = 0; i < ports; i++) {
-		struct t7xx_port_static *port_static;
-		u32 *port_info = port_info_base + i;
-		struct t7xx_port *port;
-		unsigned int ch_id;
-		bool en_flag;
-
-		ch_id = FIELD_GET(PORT_INFO_CH_ID, *port_info);
-		port = t7xx_proxy_get_port_by_ch(md->port_prox, ch_id);
-		if (!port) {
-			dev_dbg(dev, "Port:%x not found\n", ch_id);
-			continue;
-		}
-
-		en_flag = !!(PORT_INFO_ENFLG & *port_info);
+	if (!port)
+		return -EINVAL;
 
-		if (t7xx_fsm_get_md_state(md->fsm_ctl) == MD_STATE_READY) {
-			port_static = port->port_static;
+	port_conf = port->port_conf;
 
-			if (en_flag) {
-				if (port_static->ops->enable_chl)
-					port_static->ops->enable_chl(port);
-			} else {
-				if (port_static->ops->disable_chl)
-					port_static->ops->disable_chl(port);
-			}
-		} else {
-			port->chan_enable = en_flag;
-		}
+	if (en_flag) {
+		if (port_conf->ops->enable_chl)
+			port_conf->ops->enable_chl(port);
+	} else {
+		if (port_conf->ops->disable_chl)
+			port_conf->ops->disable_chl(port);
 	}
 
 	return 0;
diff --git a/drivers/net/wwan/t7xx/t7xx_port_proxy.h b/drivers/net/wwan/t7xx/t7xx_port_proxy.h
index 1c9608987728..0390e41e2ef4 100644
--- a/drivers/net/wwan/t7xx/t7xx_port_proxy.h
+++ b/drivers/net/wwan/t7xx/t7xx_port_proxy.h
@@ -7,7 +7,7 @@
  *  Amir Hanania <amir.hanania@intel.com>
  *  Haijun Liu <haijun.liu@mediatek.com>
  *  Moises Veleta <moises.veleta@intel.com>
- *  Ricardo Martinez<ricardo.martinez@linux.intel.com>
+ *  Ricardo Martinez <ricardo.martinez@linux.intel.com>
  *
  * Contributors:
  *  Chiranjeevi Rapolu <chiranjeevi.rapolu@intel.com>
@@ -33,13 +33,26 @@
 
 struct port_proxy {
 	int				port_number;
-	struct t7xx_port_static		*ports_shared;
-	struct t7xx_port		*ports_private;
 	struct list_head		rx_ch_ports[PORT_CH_ID_MASK + 1];
 	struct list_head		queue_ports[CLDMA_NUM][MTK_QUEUES];
 	struct device			*dev;
+	struct t7xx_port		ports[];
 };
 
+struct ccci_header {
+	__le32 packet_header;
+	__le32 packet_len;
+	__le32 status;
+	__le32 ex_msg;
+};
+
+/* Coupled with HW - indicates if there is data following the CCCI header or not */
+#define CCCI_HEADER_NO_DATA	0xffffffff
+
+#define CCCI_H_AST_BIT		BIT(31)
+#define CCCI_H_SEQ_FLD		GENMASK(30, 16)
+#define CCCI_H_CHN_FLD		GENMASK(15, 0)
+
 struct ctrl_msg_header {
 	__le32	ctrl_msg_id;
 	__le32	ex_msg;
@@ -61,19 +74,10 @@ struct ctrl_msg_header {
 /* Modem exception check acknowledge identification code - "EREC" */
 #define MD_EX_CHK_ACK_ID	0x45524543
 
-struct port_msg {
-	__le32	head_pattern;
-	__le32	info;
-	__le32	tail_pattern;
-};
-
 #define PORT_INFO_RSRVD		GENMASK(31, 16)
 #define PORT_INFO_ENFLG		BIT(15)
 #define PORT_INFO_CH_ID		GENMASK(14, 0)
 
-#define PORT_MSG_VERSION	GENMASK(31, 16)
-#define PORT_MSG_PRT_CNT	GENMASK(15, 0)
-
 #define PORT_ENUM_VER		0
 #define PORT_ENUM_HEAD_PATTERN	0x5a5a5a5a
 #define PORT_ENUM_TAIL_PATTERN	0xa5a5a5a5
@@ -83,18 +87,12 @@ struct port_msg {
 extern struct port_ops wwan_sub_port_ops;
 extern struct port_ops ctl_port_ops;
 
-int t7xx_port_proxy_send_skb(struct t7xx_port *port, struct sk_buff *skb);
-void t7xx_port_proxy_set_tx_seq_num(struct t7xx_port *port, struct ccci_header *ccci_h);
-int t7xx_port_proxy_node_control(struct t7xx_modem *md, struct port_msg *port_msg);
 void t7xx_port_proxy_reset(struct port_proxy *port_prox);
-void t7xx_port_proxy_send_msg_to_md(struct port_proxy *port_prox, enum port_ch ch,
-				    unsigned int msg, unsigned int ex_msg);
 void t7xx_port_proxy_uninit(struct port_proxy *port_prox);
 int t7xx_port_proxy_init(struct t7xx_modem *md);
 void t7xx_port_proxy_md_status_notify(struct port_proxy *port_prox, unsigned int state);
-void t7xx_ccci_header_init(struct ccci_header *ccci_h, unsigned int pkt_header,
-			   size_t pkt_len, enum port_ch ch, unsigned int ex_msg);
-void t7xx_ctrl_msg_header_init(struct ctrl_msg_header *ctrl_msg_h, unsigned int msg_id,
-			       unsigned int ex_msg, unsigned int len);
+int t7xx_port_enum_msg_handler(struct t7xx_modem *md,  void *msg);
+int t7xx_port_proxy_chl_enable_disable(struct port_proxy *port_prox, unsigned int ch_id,
+				       bool en_flag);
 
 #endif /* __T7XX_PORT_PROXY_H__ */
diff --git a/drivers/net/wwan/t7xx/t7xx_port_wwan.c b/drivers/net/wwan/t7xx/t7xx_port_wwan.c
index ac9144021431..3919b9876263 100644
--- a/drivers/net/wwan/t7xx/t7xx_port_wwan.c
+++ b/drivers/net/wwan/t7xx/t7xx_port_wwan.c
@@ -8,7 +8,7 @@
  *  Chandrashekar Devegowda <chandrashekar.devegowda@intel.com>
  *  Haijun Liu <haijun.liu@mediatek.com>
  *  Moises Veleta <moises.veleta@intel.com>
- *  Ricardo Martinez<ricardo.martinez@linux.intel.com>
+ *  Ricardo Martinez <ricardo.martinez@linux.intel.com>
  *
  * Contributors:
  *  Andy Shevchenko <andriy.shevchenko@linux.intel.com>
@@ -29,13 +29,10 @@
 #include <linux/string.h>
 #include <linux/wwan.h>
 
-#include "t7xx_common.h"
 #include "t7xx_port.h"
 #include "t7xx_port_proxy.h"
 #include "t7xx_state_monitor.h"
 
-#define CCCI_HEADROOM		128
-
 static int t7xx_port_ctrl_start(struct wwan_port *port)
 {
 	struct t7xx_port *port_mtk = wwan_port_get_drvdata(port);
@@ -57,58 +54,41 @@ static void t7xx_port_ctrl_stop(struct wwan_port *port)
 static int t7xx_port_ctrl_tx(struct wwan_port *port, struct sk_buff *skb)
 {
 	struct t7xx_port *port_private = wwan_port_get_drvdata(port);
-	size_t actual_len, alloc_size, txq_mtu = CLDMA_MTU;
-	struct t7xx_port_static *port_static;
-	unsigned int len, i, packets;
+	size_t len, offset, chunk_len = 0, txq_mtu = CLDMA_MTU;
+	struct t7xx_port_conf *port_conf;
 	struct t7xx_fsm_ctl *ctl;
 	enum md_state md_state;
 
 	len = skb->len;
-	if (!len || !port_private->rx_length_th || !port_private->chan_enable)
+	if (!len || !port_private->chan_enable)
 		return -EINVAL;
 
-	port_static = port_private->port_static;
+	port_conf = port_private->port_conf;
 	ctl = port_private->t7xx_dev->md->fsm_ctl;
 	md_state = t7xx_fsm_get_md_state(ctl);
 	if (md_state == MD_STATE_WAITING_FOR_HS1 || md_state == MD_STATE_WAITING_FOR_HS2) {
 		dev_warn(port_private->dev, "Cannot write to %s port when md_state=%d\n",
-			 port_static->name, md_state);
+			 port_conf->name, md_state);
 		return -ENODEV;
 	}
 
-	alloc_size = min_t(size_t, txq_mtu, len + CCCI_HEADROOM);
-	actual_len = alloc_size - CCCI_HEADROOM;
-	packets = DIV_ROUND_UP(len, txq_mtu - CCCI_HEADROOM);
-
-	for (i = 0; i < packets; i++) {
-		struct ccci_header *ccci_h;
+	for (offset = 0; offset < len; offset += chunk_len) {
 		struct sk_buff *skb_ccci;
 		int ret;
 
-		if (packets > 1 && packets == i + 1) {
-			actual_len = len % (txq_mtu - CCCI_HEADROOM);
-			alloc_size = actual_len + CCCI_HEADROOM;
-		}
-
-		skb_ccci = __dev_alloc_skb(alloc_size, GFP_KERNEL);
+		chunk_len = min(len - offset, txq_mtu - sizeof(struct ccci_header));
+		skb_ccci = t7xx_port_alloc_skb(chunk_len);
 		if (!skb_ccci)
 			return -ENOMEM;
 
-		ccci_h = skb_put(skb_ccci, sizeof(*ccci_h));
-		t7xx_ccci_header_init(ccci_h, 0, actual_len + sizeof(*ccci_h),
-				      port_static->tx_ch, 0);
-		skb_put_data(skb_ccci, skb->data + i * (txq_mtu - CCCI_HEADROOM), actual_len);
-		t7xx_port_proxy_set_tx_seq_num(port_private, ccci_h);
-
-		ret = t7xx_port_send_skb_to_md(port_private, skb_ccci);
+		skb_put_data(skb_ccci, skb->data + offset, chunk_len);
+		ret = t7xx_port_send_skb(port_private, skb_ccci, 0, 0);
 		if (ret) {
 			dev_kfree_skb_any(skb_ccci);
 			dev_err(port_private->dev, "Write error on %s port, %d\n",
-				port_static->name, ret);
+				port_conf->name, ret);
 			return ret;
 		}
-
-		port_private->seq_nums[MTK_TX]++;
 	}
 
 	dev_kfree_skb(skb);
@@ -123,17 +103,7 @@ static const struct wwan_port_ops wwan_ops = {
 
 static int t7xx_port_wwan_init(struct t7xx_port *port)
 {
-	struct t7xx_port_static *port_static = port->port_static;
-
 	port->rx_length_th = RX_QUEUE_MAXLEN;
-	port->flags |= PORT_F_RX_ADJUST_HEADER;
-
-	if (port_static->rx_ch == PORT_CH_UART2_RX)
-		port->flags |= PORT_F_RX_CH_TRAFFIC;
-
-	if (!port->chan_enable)
-		port->flags |= PORT_F_RX_ALLOW_DROP;
-
 	return 0;
 }
 
@@ -146,30 +116,31 @@ static void t7xx_port_wwan_uninit(struct t7xx_port *port)
 
 	spin_lock_irqsave(&port->rx_wq.lock, flags);
 	port->rx_length_th = 0;
+	spin_unlock_irqrestore(&port->rx_wq.lock, flags);
+
 	wwan_remove_port(port->wwan_port);
 	port->wwan_port = NULL;
-	spin_unlock_irqrestore(&port->rx_wq.lock, flags);
 }
 
 static int t7xx_port_wwan_recv_skb(struct t7xx_port *port, struct sk_buff *skb)
 {
-	struct t7xx_port_static *port_static = port->port_static;
+	if (!atomic_read(&port->usage_cnt) || !port->chan_enable) {
+		struct t7xx_port_conf *port_conf = port->port_conf;
 
-	if (!atomic_read(&port->usage_cnt)) {
 		dev_kfree_skb_any(skb);
 		dev_err_ratelimited(port->dev, "Port %s is not opened, drop packets\n",
-				    port_static->name);
+				    port_conf->name);
 		return 0;
 	}
 
-	return t7xx_port_recv_skb(port, skb);
+	wwan_port_rx(port->wwan_port, skb);
+	return 0;
 }
 
 static int t7xx_port_wwan_enable_chl(struct t7xx_port *port)
 {
 	spin_lock(&port->port_update_lock);
 	port->chan_enable = true;
-	port->flags &= ~PORT_F_RX_ALLOW_DROP;
 	spin_unlock(&port->port_update_lock);
 
 	return 0;
@@ -179,7 +150,6 @@ static int t7xx_port_wwan_disable_chl(struct t7xx_port *port)
 {
 	spin_lock(&port->port_update_lock);
 	port->chan_enable = false;
-	port->flags |= PORT_F_RX_ALLOW_DROP;
 	spin_unlock(&port->port_update_lock);
 
 	return 0;
@@ -187,16 +157,16 @@ static int t7xx_port_wwan_disable_chl(struct t7xx_port *port)
 
 static void t7xx_port_wwan_md_state_notify(struct t7xx_port *port, unsigned int state)
 {
-	struct t7xx_port_static *port_static = port->port_static;
+	struct t7xx_port_conf *port_conf = port->port_conf;
 
 	if (state != MD_STATE_READY)
 		return;
 
 	if (!port->wwan_port) {
-		port->wwan_port = wwan_create_port(port->dev, port_static->port_type,
+		port->wwan_port = wwan_create_port(port->dev, port_conf->port_type,
 						   &wwan_ops, port);
 		if (IS_ERR(port->wwan_port))
-			dev_err(port->dev, "Unable to create WWWAN port %s", port_static->name);
+			dev_err(port->dev, "Unable to create WWWAN port %s", port_conf->name);
 	}
 }
 
diff --git a/drivers/net/wwan/t7xx/t7xx_reg.h b/drivers/net/wwan/t7xx/t7xx_reg.h
index c683c9c2f4de..7c1b81091a0f 100644
--- a/drivers/net/wwan/t7xx/t7xx_reg.h
+++ b/drivers/net/wwan/t7xx/t7xx_reg.h
@@ -12,7 +12,7 @@
  *  Andy Shevchenko <andriy.shevchenko@linux.intel.com>
  *  Eliot Lee <eliot.lee@intel.com>
  *  Moises Veleta <moises.veleta@intel.com>
- *  Ricardo Martinez<ricardo.martinez@linux.intel.com>
+ *  Ricardo Martinez <ricardo.martinez@linux.intel.com>
  *  Sreehari Kancharla <sreehari.kancharla@intel.com>
  */
 
@@ -110,13 +110,11 @@ enum t7xx_pm_resume_state {
 #define T7XX_PCIE_RESOURCE_STATUS		0x0d28
 #define T7XX_PCIE_RESOURCE_STS_MSK		GENMASK(4, 0)
 
-#define DIS_ASPM_LOWPWR_SET_0			0x0e50
-#define DIS_ASPM_LOWPWR_CLR_0			0x0e54
-#define DIS_ASPM_LOWPWR_SET_1			0x0e58
-#define DIS_ASPM_LOWPWR_CLR_1			0x0e5c
-#define L1_DISABLE_BIT(i)			BIT((i) * 4 + 1)
-#define L1_1_DISABLE_BIT(i)			BIT((i) * 4 + 2)
-#define L1_2_DISABLE_BIT(i)			BIT((i) * 4 + 3)
+#define DISABLE_ASPM_LOWPWR			0x0e50
+#define ENABLE_ASPM_LOWPWR			0x0e54
+#define T7XX_L1_BIT(i)				BIT((i) * 4 + 1)
+#define T7XX_L1_1_BIT(i)			BIT((i) * 4 + 2)
+#define T7XX_L1_2_BIT(i)			BIT((i) * 4 + 3)
 
 #define MSIX_ISTAT_HST_GRP0_0			0x0f00
 #define IMASK_HOST_MSIX_SET_GRP0_0		0x3000
diff --git a/drivers/net/wwan/t7xx/t7xx_state_monitor.c b/drivers/net/wwan/t7xx/t7xx_state_monitor.c
index e0024c3cbd3c..0bcca08ff2bd 100644
--- a/drivers/net/wwan/t7xx/t7xx_state_monitor.c
+++ b/drivers/net/wwan/t7xx/t7xx_state_monitor.c
@@ -7,7 +7,7 @@
  *  Haijun Liu <haijun.liu@mediatek.com>
  *  Eliot Lee <eliot.lee@intel.com>
  *  Moises Veleta <moises.veleta@intel.com>
- *  Ricardo Martinez<ricardo.martinez@linux.intel.com>
+ *  Ricardo Martinez <ricardo.martinez@linux.intel.com>
  *
  * Contributors:
  *  Amir Hanania <amir.hanania@intel.com>
@@ -445,7 +445,7 @@ int t7xx_fsm_append_event(struct t7xx_fsm_ctl *ctl, enum t7xx_fsm_event_state ev
 	event->length = length;
 
 	if (data && length)
-		memcpy((void *)event + sizeof(*event), data, length);
+		memcpy(event->data, data, length);
 
 	spin_lock_irqsave(&ctl->event_lock, flags);
 	list_add_tail(&event->entry, &ctl->event_queue);
diff --git a/drivers/net/wwan/t7xx/t7xx_state_monitor.h b/drivers/net/wwan/t7xx/t7xx_state_monitor.h
index 7c8d2d17cb50..b1af0259d4c5 100644
--- a/drivers/net/wwan/t7xx/t7xx_state_monitor.h
+++ b/drivers/net/wwan/t7xx/t7xx_state_monitor.h
@@ -10,7 +10,7 @@
  *
  * Contributors:
  *  Eliot Lee <eliot.lee@intel.com>
- *  Ricardo Martinez<ricardo.martinez@linux.intel.com>
+ *  Ricardo Martinez <ricardo.martinez@linux.intel.com>
  *  Sreehari Kancharla <sreehari.kancharla@intel.com>
  */
 
@@ -23,7 +23,6 @@
 #include <linux/types.h>
 #include <linux/wait.h>
 
-#include "t7xx_common.h"
 #include "t7xx_modem_ops.h"
 
 enum t7xx_fsm_state {
@@ -65,6 +64,16 @@ enum t7xx_md_irq_type {
 	MD_IRQ_PORT_ENUM,
 };
 
+enum md_state {
+	MD_STATE_INVALID,
+	MD_STATE_WAITING_FOR_HS1,
+	MD_STATE_WAITING_FOR_HS2,
+	MD_STATE_READY,
+	MD_STATE_EXCEPTION,
+	MD_STATE_WAITING_TO_STOP,
+	MD_STATE_STOPPED,
+};
+
 #define FSM_CMD_FLAG_WAIT_FOR_COMPLETION	BIT(0)
 #define FSM_CMD_FLAG_FLIGHT_MODE		BIT(1)
 #define FSM_CMD_FLAG_IN_INTERRUPT		BIT(2)
@@ -91,6 +100,7 @@ struct t7xx_fsm_event {
 	struct list_head	entry;
 	enum t7xx_fsm_event_state event_id;
 	unsigned int		length;
+	unsigned char		data[];
 };
 
 struct t7xx_fsm_command {
-- 
2.17.1

