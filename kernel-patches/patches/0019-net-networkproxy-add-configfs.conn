From 9cfbaadbfdc6df010810f378b5e1acf771eadb02 Mon Sep 17 00:00:00 2001
From: Lay Kuan Loon <kuan.loon.lay@intel.com>
Date: Wed, 20 Oct 2021 14:14:42 +0800
Subject: [PATCH 19/54] net: networkproxy: add configfs

Add configfs to read/write protocol handling decision and management
info database that used in Network Proxy Agent.

Signed-off-by: Lay Kuan Loon <kuan.loon.lay@intel.com>
Signed-off-by: Ong Boon Leong <boon.leong.ong@intel.com>
Signed-off-by: Song Yoong Siang <yoong.siang.song@intel.com>
Signed-off-by: Tan Tee Min <tee.min.tan@intel.com>
Signed-off-by: Noor Azura Ahmad Tarmizi <noor.azura.ahmad.tarmizi@intel.com>
---
 drivers/net/networkproxy/Makefile             |   2 +-
 drivers/net/networkproxy/network_proxy.c      | 305 ++++++++++++++++++
 .../net/networkproxy/network_proxy_configfs.c |  22 +-
 include/linux/network_proxy.h                 |  25 ++
 include/linux/network_proxy_common.h          |  70 ++++
 5 files changed, 412 insertions(+), 12 deletions(-)

diff --git a/drivers/net/networkproxy/Makefile b/drivers/net/networkproxy/Makefile
index 0073b7f8dae1..1ebe43df2c84 100644
--- a/drivers/net/networkproxy/Makefile
+++ b/drivers/net/networkproxy/Makefile
@@ -1,4 +1,4 @@
-obj-$(CONFIG_NETWORK_PROXY) = network_proxy.o
+obj-$(CONFIG_NETWORK_PROXY) = network_proxy.o network_proxy_configfs.o
 obj-$(CONFIG_NETWORK_PROXY_ISHTP) += np_ishtp_client.o
 
 CFLAGS_np_ishtp_client.o += -I$(srctree)/drivers/hid/intel-ish-hid
diff --git a/drivers/net/networkproxy/network_proxy.c b/drivers/net/networkproxy/network_proxy.c
index 4bdeaad1b559..60b1ac861ec6 100644
--- a/drivers/net/networkproxy/network_proxy.c
+++ b/drivers/net/networkproxy/network_proxy.c
@@ -1,11 +1,25 @@
 // SPDX-License-Identifier: GPL-2.0
 /* Copyright (c) 2022, Intel Corporation. */
 
+#include <linux/delay.h>
+#include <linux/inetdevice.h>
+#include <linux/ipv6.h>
+#include <linux/list.h>
 #include <linux/module.h>
+#include <linux/netdevice.h>
 #include <linux/network_proxy.h>
+#include <linux/sched.h>
 #include <linux/slab.h>
+#include <linux/wait.h>
+#include <net/addrconf.h>
+#include <net/if_inet6.h>
+
+/* timeout 1 second */
+#define NP_TIMEOUT_MS	1000
 
 static struct np_context *np_ctx;
+static struct task_struct *agent_access_task;
+static unsigned char *ipc_ptr;
 
 int netprox_send_ipc_msg(int cmd, const char *msg, int size)
 {
@@ -38,6 +52,270 @@ int netprox_send_ipc_msg(int cmd, const char *msg, int size)
 }
 EXPORT_SYMBOL(netprox_send_ipc_msg);
 
+static int netprox_read_from_agent(struct np_rules *rule, void *content,
+				   int *size)
+{
+	struct np_rules *ipc_resp;
+	void *ipc_res;
+	long time;
+
+	netprox_send_ipc_msg(NP_H2A_CMD_READ_CLS_RULE, (const char *)rule,
+			     sizeof(struct np_rules));
+
+	agent_access_task = current;
+	set_current_state(TASK_INTERRUPTIBLE);
+	time = schedule_timeout(msecs_to_jiffies(NP_TIMEOUT_MS));
+	if (time > 0) {
+		/* If time > 0 mean Agent response
+		 * NP_A2H_CMD_READ_CLS_RULE_RESULT, check the response
+		 * is same as query
+		 */
+		ipc_resp = (struct np_rules *)ipc_ptr;
+		if (rule->group == ipc_resp->group &&
+		    rule->type == ipc_resp->type &&
+		    rule->offset == ipc_resp->offset &&
+		    rule->size == ipc_resp->size) {
+			/* only copy the content without struct np_rules */
+			ipc_res = ipc_resp + 1;
+			memcpy(content, ipc_res, ipc_resp->size);
+		}
+	} else {
+		pr_err("netprox read rule timeout\n");
+		return -EPERM;
+	}
+
+	return 0;
+}
+
+static int netprox_process_classifier_rule_read(struct np_rules *rule,
+						void *content, int *size)
+{
+	int ret;
+
+	switch (rule->type) {
+	case NP_RL_T_IPV4:
+	case NP_RL_T_IPV6:
+	case NP_RL_T_SNMP:
+	case NP_RL_T_TCP_WAKE_PORT:
+	case NP_RL_T_MDNS:
+		ret = netprox_read_from_agent(rule, content, size);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static int netprox_process_mib_rule_read(struct np_rules *rule, void *content,
+					 int *size)
+{
+	int ret;
+
+	switch (rule->type) {
+	case NP_RL_T_MAC_ADDR:
+	case NP_RL_T_IPV4:
+	case NP_RL_T_IPV6:
+	case NP_RL_T_SNMP_COMMUNITY_STR:
+	case NP_RL_T_TCP_WAKE_PORT:
+	case NP_RL_T_IPV4_SUBNET:
+		ret = netprox_read_from_agent(rule, content, size);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+int netprox_read_rule(struct np_rules *rule, void *content, int *size)
+{
+	int ret;
+
+	switch (rule->group) {
+	case NP_RL_G_CLS:
+		ret = netprox_process_classifier_rule_read(rule, content, size);
+		break;
+	case NP_RL_G_MIB:
+		ret = netprox_process_mib_rule_read(rule, content, size);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL(netprox_read_rule);
+
+static int netprox_send_netdev_mib(int rule_type)
+{
+	struct inet6_ifaddr *ifp, *tmp;
+	struct in_device *indevice;
+	struct in_ifaddr *inifaddr;
+	struct net_device *ndev;
+	struct inet6_dev *idev;
+	struct np_rules *rule;
+	int size, i;
+	int ret = 0;
+	char *ptr;
+
+	if (np_ctx->np_netdev) {
+		ndev = np_ctx->np_netdev->netdev;
+	} else {
+		pr_err("netprox net device not register\n");
+		return -ENODEV;
+	}
+
+	size = 0;
+
+	switch (rule_type) {
+	case NP_RL_T_MAC_ADDR:
+		size = sizeof(struct np_rules) + NP_MAC_ADDR_BYTES;
+		break;
+	case NP_RL_T_IPV4_SUBNET:
+	case NP_RL_T_IPV4:
+		indevice = ndev->ip_ptr;
+		if (indevice) {
+			inifaddr = indevice->ifa_list;
+			if (inifaddr) {
+				/* only set size if ipv4 info is valid */
+				size = sizeof(struct np_rules)
+				       + NP_IPV4_ADDR_BYTES;
+			} else {
+				pr_err("IPV4 MIB ifa_list is null\n");
+			}
+		} else {
+			pr_err("IPV4 MIB ip_ptr is null\n");
+		}
+		break;
+	case NP_RL_T_IPV6:
+		idev = ndev->ip6_ptr;
+		if (idev) {
+			/* only set size if ipv6 info is valid */
+			size = sizeof(struct np_rules) +
+				(NP_IPV6_ADDR_ARRAY * NP_IPV6_ADDR_BYTES);
+		} else {
+			pr_err("IPV6 MIB ip6_ptr is null\n");
+		}
+		break;
+	default:
+		pr_err("unknown MIB type\n");
+		break;
+	}
+
+	if (size == 0)
+		return -EPERM;
+
+	rule = kzalloc(size, GFP_KERNEL);
+	if (!rule)
+		return -ENOMEM;
+
+	/* Set rule of MIB */
+	rule->group = NP_RL_G_MIB;
+	rule->type = rule_type;
+	rule->offset = 0;
+	ptr = (char *)rule->value;
+
+	switch (rule_type) {
+	case NP_RL_T_MAC_ADDR:
+		memcpy(ptr, ndev->dev_addr, NP_MAC_ADDR_BYTES);
+		break;
+	case NP_RL_T_IPV4:
+		indevice = ndev->ip_ptr;
+		inifaddr = indevice->ifa_list;
+		memcpy(ptr, (void *)&inifaddr->ifa_address, NP_IPV4_ADDR_BYTES);
+		break;
+	case NP_RL_T_IPV6:
+		i = 0;
+		idev = ndev->ip6_ptr;
+		size = sizeof(struct np_rules);
+		list_for_each_entry_safe(ifp, tmp, &idev->addr_list,
+					 if_list) {
+			if (i++ == NP_IPV6_ADDR_ARRAY) {
+				pr_err("more than %d IPV6 addr\n",
+				       NP_IPV6_ADDR_ARRAY);
+				break;
+			}
+			size += NP_IPV6_ADDR_BYTES;
+			memcpy(ptr, (void *)&ifp->addr, NP_IPV6_ADDR_BYTES);
+			ptr += NP_IPV6_ADDR_BYTES;
+		}
+		break;
+	case NP_RL_T_IPV4_SUBNET:
+		indevice = ndev->ip_ptr;
+		inifaddr = indevice->ifa_list;
+		memcpy(ptr, (void *)&inifaddr->ifa_mask, NP_IPV4_ADDR_BYTES);
+		break;
+	default:
+		ret = -EPERM;
+		pr_err("unknown MIB type\n");
+		break;
+	}
+
+	if (ret) {
+		kfree(rule);
+		return ret;
+	}
+
+	rule->size = size - sizeof(struct np_rules);
+	ret = netprox_send_ipc_msg(NP_H2A_CMD_WRITE_CLS_RULE,
+				   (const char *)rule,
+				   size);
+	kfree(rule);
+
+	return ret;
+}
+
+static int netprox_process_classifier_rule_write(struct np_rules *rule,
+						 int size)
+{
+	unsigned short *value;
+	int ret = 0;
+
+	switch (rule->type) {
+	case NP_RL_T_IPV4:
+	case NP_RL_T_IPV6:
+		/* Check if IPv4/IPv6 rule is enable then send IPv4/IPv6 info */
+		value = (unsigned short *)(rule->value);
+		if (*value & NP_RL_CLS_ENABLE) {
+			ret = netprox_send_netdev_mib(NP_RL_T_MAC_ADDR);
+			if (ret == 0)
+				ret = netprox_send_netdev_mib(rule->type);
+			if (ret == 0)
+				ret =
+				netprox_send_netdev_mib(NP_RL_T_IPV4_SUBNET);
+		}
+		break;
+	default:
+		break;
+	}
+
+	ret |= netprox_send_ipc_msg(NP_H2A_CMD_WRITE_CLS_RULE,
+				    (const char *)rule,
+				    size);
+	return ret;
+}
+
+int netprox_write_rule(struct np_rules *rule, int size)
+{
+	int ret;
+
+	switch (rule->group) {
+	case NP_RL_G_CLS:
+		ret = netprox_process_classifier_rule_write(rule, size);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL(netprox_write_rule);
+
 int netprox_agent_is_ready(void)
 {
 	if (!np_ctx->np_ipcdev || !np_ctx->np_netdev)
@@ -80,6 +358,10 @@ int netprox_ipc_recv(int cmd, unsigned char *payload, int size)
 
 	/* Process IPC message from Network Proxy Agent */
 	switch (cmd) {
+	case NP_A2H_CMD_AGENT_INFO:
+		if (size == sizeof(struct np_agent_info))
+			memcpy(&np_ctx->np_agent_info, payload, size);
+		break;
 	case NP_A2H_CMD_AGENT_READY:
 		np_ctx->agent_state = NP_AGENT_READY;
 		np_ctx->np_netdev->proxy_wakeup_enable(netdev, 1);
@@ -93,6 +375,13 @@ int netprox_ipc_recv(int cmd, unsigned char *payload, int size)
 	case NP_A2H_CMD_HOST_IS_EXITED:
 		np_ctx->host_state = NP_HOST_PROXY_EXIT;
 		break;
+	case NP_A2H_CMD_READ_CLS_RULE_RESULT:
+		ipc_ptr = payload;
+		if (agent_access_task)
+			wake_up_process(agent_access_task);
+		else
+			pr_err("Received cls_rule_result after timeout.\n");
+		break;
 	default:
 		pr_err("%s unknown command %d\n", __func__, cmd);
 		break;
@@ -134,6 +423,22 @@ int netprox_deregister_netdev(struct np_netdev *np_netdev)
 }
 EXPORT_SYMBOL(netprox_deregister_netdev);
 
+int netprox_register_configfs(struct np_configfs *np_configfs)
+{
+	np_ctx->np_configfs = np_configfs;
+
+	return np_cfs_agent_info(np_ctx, np_ctx->np_agent_info);
+}
+EXPORT_SYMBOL(netprox_register_configfs);
+
+int netprox_deregister_configfs(struct np_configfs *np_configfs)
+{
+	np_ctx->np_configfs = NULL;
+
+	return 0;
+}
+EXPORT_SYMBOL(netprox_deregister_configfs);
+
 static int __init network_proxy_init(void)
 {
 	np_ctx = kzalloc(sizeof(*np_ctx), GFP_KERNEL);
diff --git a/drivers/net/networkproxy/network_proxy_configfs.c b/drivers/net/networkproxy/network_proxy_configfs.c
index 9a8cca6c9aad..ded2fb3d9b87 100644
--- a/drivers/net/networkproxy/network_proxy_configfs.c
+++ b/drivers/net/networkproxy/network_proxy_configfs.c
@@ -20,29 +20,29 @@ struct np_cfs {
 static inline struct np_cfs *to_np_cfs(struct config_item *item)
 {
 	return item ? container_of(to_configfs_subsystem(to_config_group(item)),
-			struct np_cfs, subsys) : NULL;
+				   struct np_cfs, subsys) : NULL;
 }
 
 static ssize_t np_cfs_agent_version_show(struct config_item *item, char *page)
 {
-	return sprintf(page, "%d.%d.%d\n", cfs_agent(item).major,
-		       cfs_agent(item).minor,
-		       cfs_agent(item).revision);
+	return sysfs_emit(page, "%d.%d.%d\n", cfs_agent(item).major,
+			  cfs_agent(item).minor,
+			  cfs_agent(item).revision);
 }
 
 static ssize_t np_cfs_max_cls_rules_show(struct config_item *item, char *page)
 {
-	return sprintf(page, "%d\n", cfs_agent(item).max_cls_rules);
+	return sysfs_emit(page, "%d\n", cfs_agent(item).max_cls_rules);
 }
 
 static ssize_t np_cfs_max_resp_rules_show(struct config_item *item, char *page)
 {
-	return sprintf(page, "%d\n", cfs_agent(item).max_resp_rules);
+	return sysfs_emit(page, "%d\n", cfs_agent(item).max_resp_rules);
 }
 
 static ssize_t np_cfs_rules_group_show(struct config_item *item, char *page)
 {
-	return sprintf(page, "%d\n", cfs_rules(item).group);
+	return sysfs_emit(page, "%d\n", cfs_rules(item).group);
 }
 
 static ssize_t np_cfs_rules_group_store(struct config_item *item,
@@ -62,7 +62,7 @@ static ssize_t np_cfs_rules_group_store(struct config_item *item,
 
 static ssize_t np_cfs_rules_type_show(struct config_item *item, char *page)
 {
-	return sprintf(page, "%d\n", cfs_rules(item).type);
+	return sysfs_emit(page, "%d\n", cfs_rules(item).type);
 }
 
 static ssize_t np_cfs_rules_type_store(struct config_item *item,
@@ -82,7 +82,7 @@ static ssize_t np_cfs_rules_type_store(struct config_item *item,
 
 static ssize_t np_cfs_rules_offset_show(struct config_item *item, char *page)
 {
-	return sprintf(page, "%d\n", cfs_rules(item).offset);
+	return sysfs_emit(page, "%d\n", cfs_rules(item).offset);
 }
 
 static ssize_t np_cfs_rules_offset_store(struct config_item *item,
@@ -107,7 +107,7 @@ static ssize_t np_cfs_rules_offset_store(struct config_item *item,
 
 static ssize_t np_cfs_rules_size_show(struct config_item *item, char *page)
 {
-	return sprintf(page, "%d\n", cfs_rules(item).size);
+	return sysfs_emit(page, "%d\n", cfs_rules(item).size);
 }
 
 static ssize_t np_cfs_rules_size_store(struct config_item *item,
@@ -164,7 +164,7 @@ static ssize_t np_cfs_rules_value_store(struct config_item *item,
 	int ret;
 
 	/* allocate rule, value is dynamic size according to count */
-	size = (sizeof(struct np_rules) + count);
+	size = sizeof(struct np_rules) + count;
 	rule = kzalloc(size, GFP_KERNEL);
 	if (!rule)
 		return -ENOMEM;
diff --git a/include/linux/network_proxy.h b/include/linux/network_proxy.h
index 4536d76b9b1e..30dcc8e93e02 100644
--- a/include/linux/network_proxy.h
+++ b/include/linux/network_proxy.h
@@ -34,23 +34,48 @@ struct np_netdev {
 	void (*proxy_wakeup_enable)(struct net_device *netdev, bool enable);
 };
 
+/* Network Device for Network Proxy Agent */
+struct np_configfs {
+	void (*agent_info)(struct np_agent_info *info);
+};
+
 /* Network Proxy Context */
 struct np_context {
 	enum np_host_state host_state;
 	enum np_agent_state agent_state;
 	struct np_ipcdev *np_ipcdev;
 	struct np_netdev *np_netdev;
+	struct np_configfs *np_configfs;
+	struct np_agent_info np_agent_info;
 };
 
 int netprox_agent_is_ready(void);
 int netprox_host_proxy_enter(void);
 int netprox_host_proxy_exit(void);
 int netprox_send_ipc_msg(int cmd, const char *msg, int size);
+int netprox_read_rule(struct np_rules *rule, void *ptr, int *size);
+int netprox_write_rule(struct np_rules *rule, int size);
 int netprox_ipc_recv(int cmd, unsigned char *payload, int size);
 int netprox_register_ipcdev(struct np_ipcdev *np_ipcdev);
 int netprox_deregister_ipcdev(struct np_ipcdev *np_ipcdev);
 int netprox_register_netdev(struct np_netdev *np_netdev, void *config,
 			    int size);
 int netprox_deregister_netdev(struct np_netdev *np_netdev);
+int netprox_register_configfs(struct np_configfs *np_cfs);
+int netprox_deregister_configfs(struct np_configfs *np_cfs);
+
+static inline int np_cfs_agent_info(struct np_context *ctx,
+				    struct np_agent_info np_agent_info)
+{
+	if (ctx->np_configfs && np_agent_info.major) {
+		ctx->np_configfs->agent_info(&np_agent_info);
+
+		return 0;
+	}
+
+	pr_err("Network Proxy Configfs registration fail.\n");
+
+	return -ENODEV;
+}
 
 #endif /* __NETWORK_PROXY_H__ */
diff --git a/include/linux/network_proxy_common.h b/include/linux/network_proxy_common.h
index ab4345a31e18..3890bbdca709 100644
--- a/include/linux/network_proxy_common.h
+++ b/include/linux/network_proxy_common.h
@@ -7,6 +7,38 @@
 #define NP_CMD_MASK			0x7F
 #define NP_IS_RESPONSE			0x80
 
+/* Network Proxy Rules Group */
+#define NP_RL_G_CLS			1
+#define NP_RL_G_RSP			2
+#define NP_RL_G_MIB			3
+
+/* Network Proxy Rules Type */
+#define NP_RL_T_PROGAMMABLE		1
+#define NP_RL_T_MAC_ADDR		2
+#define NP_RL_T_IPV4			3
+#define NP_RL_T_IPV6			4
+#define NP_RL_T_TCP_WAKE_PORT		5
+#define NP_RL_T_UDP_WAKE_PORT		6
+#define NP_RL_T_SNMP			7
+#define NP_RL_T_SNMP_COMMUNITY_STR	8
+#define NP_RL_T_SNMP_WRITE_OID_TREE	9
+#define NP_RL_T_SNMP_READ_OID_TREE	10
+#define NP_RL_T_MDNS			11
+#define NP_RL_T_MDNS_WRITE_RR		12
+#define NP_RL_T_MDNS_READ_RR		13
+#define NP_RL_T_IPV4_SUBNET		14
+
+/* Network Proxy Fixed Classifier Value (2 bytes) */
+#define NP_RL_CLS_ENABLE		BIT(15)
+#define NP_RL_CLS_DROP			BIT(1)
+#define NP_RL_CLS_RESP			BIT(2)
+#define NP_RL_CLS_WAKE			BIT(3)
+#define NP_RL_CLS_A2H			BIT(4)
+/* Wake-up host when SNMP GetRequest packet with unknown OID is received */
+#define NP_RL_CLS_SUPP_SNMP_GALL	BIT(5)
+/* Wake-up host when SNMP SetRequest packet is received */
+#define NP_RL_CLS_SUPP_SNMP_SET		BIT(6)
+
 /* IPC Message and Payload Size Limit */
 #define NP_IPC_MSG_MAX		256
 #define NP_IPC_PYLD_MAX		(NP_IPC_MSG_MAX - sizeof(struct np_ipc_hdr))
@@ -41,6 +73,34 @@ struct np_mib {
 	unsigned short tcp_port[NP_TCP_PORT_ARRAY];
 	unsigned int ipv6_addr_sz;
 	unsigned int tcp_port_sz;
+	unsigned char ipv4_subnet[NP_IPV4_ADDR_BYTES];
+};
+
+/* Network Proxy Agent Info */
+struct np_agent_info {
+	/* Version major.minor.revision */
+	unsigned short major;
+	unsigned short minor;
+	unsigned short revision;
+	unsigned short resv;
+	/* Max # Classifier Rules */
+	unsigned int max_cls_rules;
+	/* Max # Responder Rules */
+	unsigned int max_resp_rules;
+};
+
+/* Network Proxy Rules Info */
+struct np_rules {
+	/* Group NP_RL_G */
+	unsigned short group;
+	/* Type NP_RL_T */
+	unsigned short type;
+	/* Offset in Byte */
+	unsigned int offset;
+	/* Size in Byte */
+	unsigned int size;
+	/* Content */
+	unsigned int value[0];
 };
 
 /* Commands from Network Proxy Host to Agent */
@@ -51,6 +111,12 @@ enum np_h2a_cmd {
 	NP_H2A_CMD_PROXY_ENTER,
 	/* Exit Network Proxy Mode */
 	NP_H2A_CMD_PROXY_EXIT,
+	/* Read/Write Classifier Rule */
+	NP_H2A_CMD_READ_CLS_RULE,
+	NP_H2A_CMD_WRITE_CLS_RULE,
+	/* Read/Write Responder rule */
+	NP_H2A_CMD_READ_RESP_RULE,
+	NP_H2A_CMD_WRITE_RESP_RULE,
 	NP_H2A_CMD_MAX,
 };
 
@@ -58,6 +124,10 @@ enum np_h2a_cmd {
 enum np_a2h_cmd {
 	/* Network Proxy Agent is ready */
 	NP_A2H_CMD_AGENT_READY = 1,
+	/* Network Proxy Agent Firmware Version and Info */
+	NP_A2H_CMD_AGENT_INFO,
+	/* Network Proxy Reply Rule Result */
+	NP_A2H_CMD_READ_CLS_RULE_RESULT,
 	/* Is Host Awake? */
 	NP_A2H_CMD_HOST_IS_AWAKE,
 	/* Network Proxy Mode Exited */
-- 
2.25.1

