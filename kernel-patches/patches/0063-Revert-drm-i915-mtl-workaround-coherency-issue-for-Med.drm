From e978e02daa7ead388413faf410a90f8865489bc4 Mon Sep 17 00:00:00 2001
From: Junxiao Chang <junxiao.chang@intel.com>
Date: Thu, 6 Jul 2023 15:04:15 +0800
Subject: [PATCH 0063/2351] Revert "drm/i915/mtl: workaround coherency issue
 for Media"

This reverts commit 1f563f1ec67daf955429f9b53b4cfe255204d43b.
---
 drivers/gpu/drm/i915/gem/i915_gem_pages.c |  7 +------
 drivers/gpu/drm/i915/gt/uc/intel_gsc_fw.c | 13 -------------
 drivers/gpu/drm/i915/gt/uc/intel_guc.c    |  7 -------
 drivers/gpu/drm/i915/gt/uc/intel_guc_ct.c | 14 --------------
 4 files changed, 1 insertion(+), 40 deletions(-)

diff --git a/drivers/gpu/drm/i915/gem/i915_gem_pages.c b/drivers/gpu/drm/i915/gem/i915_gem_pages.c
index 44712db493674..ecd86130b74f1 100644
--- a/drivers/gpu/drm/i915/gem/i915_gem_pages.c
+++ b/drivers/gpu/drm/i915/gem/i915_gem_pages.c
@@ -469,12 +469,7 @@ enum i915_map_type i915_coherent_map_type(struct drm_i915_private *i915,
 					  struct drm_i915_gem_object *obj,
 					  bool always_coherent)
 {
-	/*
-	 * Wa_22016122933: FIXME: always return I915_MAP_WC for MTL
-	 * Issue is expected to be tracked as Wa_22016122933, but not
-	 * finalized by hardware team yet. So marked as fixme as well.
-	 */
-	if (i915_gem_object_is_lmem(obj) || IS_METEORLAKE(i915))
+	if (i915_gem_object_is_lmem(obj))
 		return I915_MAP_WC;
 	if (HAS_LLC(i915) || always_coherent)
 		return I915_MAP_WB;
diff --git a/drivers/gpu/drm/i915/gt/uc/intel_gsc_fw.c b/drivers/gpu/drm/i915/gt/uc/intel_gsc_fw.c
index ab7aa1bb485c6..e73d4440c5e82 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_gsc_fw.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_gsc_fw.c
@@ -110,13 +110,6 @@ static int gsc_fw_load_prepare(struct intel_gsc_uc *gsc)
 	if (obj->base.size < gsc->fw.size)
 		return -ENOSPC;
 
-	/*
-	 * Wa_22016122933: For MTL the shared memory needs to be mapped
-	 * as WC on CPU side and UC (PAT index 2) on GPU side
-	 */
-	if (IS_METEORLAKE(i915))
-		i915_gem_object_set_cache_coherency(obj, I915_CACHE_NONE);
-
 	dst = i915_gem_object_pin_map_unlocked(obj,
 					       i915_coherent_map_type(i915, obj, true));
 	if (IS_ERR(dst))
@@ -132,12 +125,6 @@ static int gsc_fw_load_prepare(struct intel_gsc_uc *gsc)
 	memset(dst, 0, obj->base.size);
 	memcpy(dst, src, gsc->fw.size);
 
-	/*
-	 * Wa_22016122933: Making sure the data in dst is
-	 * visible to GSC right away
-	 */
-	intel_guc_write_barrier(&gt->uc.guc);
-
 	i915_gem_object_unpin_map(gsc->fw.obj);
 	i915_gem_object_unpin_map(obj);
 
diff --git a/drivers/gpu/drm/i915/gt/uc/intel_guc.c b/drivers/gpu/drm/i915/gt/uc/intel_guc.c
index f9bddaa876d9b..d76508fa3af7f 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_guc.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_guc.c
@@ -743,13 +743,6 @@ struct i915_vma *intel_guc_allocate_vma(struct intel_guc *guc, u32 size)
 	if (IS_ERR(obj))
 		return ERR_CAST(obj);
 
-	/*
-	 * Wa_22016122933: For MTL the shared memory needs to be mapped
-	 * as WC on CPU side and UC (PAT index 2) on GPU side
-	 */
-	if (IS_METEORLAKE(gt->i915))
-		i915_gem_object_set_cache_coherency(obj, I915_CACHE_NONE);
-
 	vma = i915_vma_instance(obj, &gt->ggtt->vm, NULL);
 	if (IS_ERR(vma))
 		goto err;
diff --git a/drivers/gpu/drm/i915/gt/uc/intel_guc_ct.c b/drivers/gpu/drm/i915/gt/uc/intel_guc_ct.c
index 48f868281195c..5071b8a5ba56b 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_guc_ct.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_guc_ct.c
@@ -481,14 +481,6 @@ static int ct_write(struct intel_guc_ct *ct,
 		}
 	}
 
-	/* Wa_22016122933: Theoretically write combining buffer flush is
-	 * needed here to make the tail update visible to GuC right away,
-	 * but ct_write is always followed by a MMIO write which triggers
-	 * the interrupt to GuC, so an explicit flush is not required.
-	 * Just leave a comment here for now.
-	 */
-	/* intel_guc_write_barrier(ct_to_guc(ct)); */
-
 	return 0;
 
 corrupted:
@@ -962,12 +954,6 @@ static int ct_read(struct intel_guc_ct *ct, struct ct_incoming_msg **msg)
 	/* now update descriptor */
 	WRITE_ONCE(desc->head, head);
 
-	/*
-	 * Wa_22016122933: Making sure the head update is
-	 * visible to GuC right away
-	 */
-	intel_guc_write_barrier(ct_to_guc(ct));
-
 	return available - len;
 
 corrupted:
-- 
2.25.1

