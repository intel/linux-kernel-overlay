From 0bc4771b2cf4d6d78e709cc2035caad837dbc875 Mon Sep 17 00:00:00 2001
From: Ricardo Neri <ricardo.neri-calderon@linux.intel.com>
Date: Sat, 28 Mar 2020 15:41:46 -0700
Subject: [PATCH 28/41] DEBUG: thermal: intel: hfi: Add debugfs entries

Cc: Andi Kleen <ak@linux.intel.com>
Cc: Aubrey Li <aubrey.li@intel.com>
Cc: Len Brown <len.brown@intel.com>
Cc: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Cc: Tim Chen <tim.c.chen@linux.intel.com>
Cc: "Ravi V. Shankar" <ravi.v.shankar@intel.com>
Signed-off-by: Ricardo Neri <ricardo.neri-calderon@linux.intel.com>
---
 drivers/thermal/intel/intel_hfi.c | 179 ++++++++++++++++++++++++++++++
 1 file changed, 179 insertions(+)

diff --git a/drivers/thermal/intel/intel_hfi.c b/drivers/thermal/intel/intel_hfi.c
index 3b4b8c1d7fa6..c82b76089441 100644
--- a/drivers/thermal/intel/intel_hfi.c
+++ b/drivers/thermal/intel/intel_hfi.c
@@ -22,6 +22,7 @@
 #define pr_fmt(fmt)  "intel-hfi: " fmt
 
 #include <linux/bits.h>
+#include <linux/debugfs.h>
 #include <linux/io.h>
 #include <linux/slab.h>
 
@@ -169,6 +170,172 @@ static DEFINE_MUTEX(hfi_lock);
 #define HFI_UPDATE_INTERVAL	HZ
 #define HFI_MAX_THERM_NOTIFY_COUNT	16
 
+#ifdef CONFIG_DEBUG_FS
+
+static int hfi_features_show(struct seq_file *s, void *unused)
+{
+	union cpuid6_edx edx;
+
+	edx.full = cpuid_edx(CPUID_HFI_LEAF);
+
+	seq_printf(s, "EHFI supported: \t%u\n", boot_cpu_has(X86_FEATURE_EHFI));
+	seq_printf(s, "HRESET supported: \t%u\n", boot_cpu_has(X86_FEATURE_HRESET));
+	if (boot_cpu_has(X86_FEATURE_HRESET))
+		seq_printf(s, "HRESET features:\t0x%x\n", hreset_features);
+	seq_printf(s, "Number of classes:\t%u\n", hfi_features.nr_classes);
+	seq_printf(s, "Capabilities:\t\tP:%d EE:%d R:%d\n",
+		   edx.split.capabilities.split.performance,
+		   edx.split.capabilities.split.energy_efficiency,
+		   edx.split.capabilities.split.__reserved);
+	seq_printf(s, "Table pages:\t\t%d\n", hfi_features.nr_table_pages);
+	seq_printf(s, "CPU stride:\t\t0x%x\n", hfi_features.cpu_stride);
+	seq_printf(s, "Class class stride:\t0x%x\n", hfi_features.class_stride);
+
+	return 0;
+}
+DEFINE_SHOW_ATTRIBUTE(hfi_features);
+
+static int hfi_state_show(struct seq_file *s, void *unused)
+{
+	struct hfi_instance *hfi_instance = s->private;
+	struct hfi_hdr *hfi_hdr;
+	int cpu, i, j;
+	u64 msr_val;
+
+	cpu = cpumask_first(hfi_instance->cpus);
+
+	/* Dump the relevant registers */
+	rdmsrl_on_cpu(cpu, MSR_IA32_PACKAGE_THERM_STATUS, &msr_val);
+	seq_printf(s, "MSR_IA32_PACKAGE_THERM_STATUS:\t\t0x%llx HFI status:%lld\n",
+		   msr_val, (msr_val & 0x4000000) >> 26);
+
+	rdmsrl_on_cpu(cpu, MSR_IA32_PACKAGE_THERM_INTERRUPT, &msr_val);
+	seq_printf(s, "MSR_IA32_PACKAGE_THERM_INTERRUPT:\t0x%llx HFI intr: %lld \n",
+		   msr_val, (msr_val & 0x2000000) >> 25);
+
+	rdmsrl_on_cpu(cpu, MSR_IA32_HW_FEEDBACK_PTR, &msr_val);
+	seq_printf(s, "MSR_IA32_HW_FEEDBACK_PTR:\t\t0x%llx\n", msr_val);
+
+	rdmsrl_on_cpu(cpu, MSR_IA32_HW_FEEDBACK_CONFIG, &msr_val);
+	seq_printf(s, "MSR_IA32_HW_FEEDBACK_CONFIG:\t\t0x%llx\n", msr_val);
+	if (boot_cpu_has(X86_FEATURE_EHFI)) {
+		seq_printf(s, "\nCPU\tMSR_IA32_HW_HRESET_ENABLE\tMSR_IA32_HW_FEEDBACK_THREAD_CONFIG\n");
+		for_each_cpu(i, hfi_instance->cpus) {
+			u64 hreset_en, thr_cfg;
+
+			rdmsrl_on_cpu(i, MSR_IA32_HW_HRESET_ENABLE, &hreset_en);
+			rdmsrl_on_cpu(i, MSR_IA32_HW_FEEDBACK_THREAD_CONFIG, &thr_cfg);
+			seq_printf(s, "%4d\t\t0x%llx\t\t\t\t0x%llx\n", i, hreset_en, thr_cfg);
+		}
+		seq_printf(s, "\n");
+	}
+
+	/* Dump the HFI table parameters */
+	seq_printf(s, "\nInitialized:\t%d\n", hfi_instance->initialized);
+	seq_printf(s, "Table base:\t0x%lx\n", (unsigned long)hfi_instance->local_table);
+	seq_printf(s, "Headers base:\t0x%lx\n", (unsigned long)hfi_instance->hdr);
+	seq_printf(s, "Data base:\t0x%lx\n", (unsigned long)hfi_instance->data);
+	seq_printf(s, "Die id:\t\t%u\n",
+		   topology_logical_die_id(cpumask_first(hfi_instance->cpus)));
+	seq_printf(s, "CPUs:\t\t%*pbl\n", cpumask_pr_args(hfi_instance->cpus));
+	seq_printf(s, "Timestamp:\t%lld\n", *hfi_instance->timestamp);
+	seq_printf(s, "\nPer-CPU data:\n");
+	seq_printf(s, "CPU\tAddress\n");
+	for_each_cpu(i, hfi_instance->cpus) {
+		seq_printf(s, "%4d\t%p\n", i, per_cpu(hfi_cpu_info, i).hfi_instance);
+	}
+
+	/* Dump the performance capability change indication */
+	seq_printf(s, "\nPerf Cap Change Indication:\n");
+	hfi_hdr = hfi_instance->hdr;
+	for (i = 0; i < hfi_features.nr_classes; i++) {
+		struct hfi_hdr *hdr_data = hfi_hdr;
+
+		seq_printf(s, "Class%d:%u\t", i, hdr_data->perf_updated);
+		hfi_hdr++;
+	}
+
+
+	/* Dump the energy efficiency capability change indication */
+	seq_printf(s, "\n\nEnergy Efficiency Cap Change Indication:\n");
+	hfi_hdr = hfi_instance->hdr;
+	for (i = 0; i < hfi_features.nr_classes; i++) {
+		struct hfi_hdr *hdr_data = hfi_hdr;
+
+		seq_printf(s, "Class%d:%u\t", i, hdr_data->ee_updated);
+		hfi_hdr++;
+	}
+
+	/* Dump the HFI table */
+	seq_printf(s, "\nHFI table:\n");
+	seq_printf(s, "CPU\tIndex");
+	for (i = 0; i < hfi_features.nr_classes; i++)
+		seq_printf(s, "\tPe%u Ef%u", i, i);
+	seq_printf(s, "\n");
+
+	for_each_cpu(i, hfi_instance->cpus) {
+		s16 index = per_cpu(hfi_cpu_info, i).index;
+		void *data_ptr = hfi_instance->data +
+				       index * hfi_features.cpu_stride;
+
+		seq_printf(s, "%4u\t%4d", i, index);
+		for (j = 0; j < hfi_features.nr_classes; j++) {
+			struct hfi_cpu_data *data = data_ptr +
+						    j * hfi_features.class_stride;
+
+			seq_printf(s, "\t%3u %3u", data->perf_cap, data->ee_cap);
+		}
+
+		seq_printf(s, "\n");
+	}
+
+	return 0;
+}
+
+static int hfi_state_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, hfi_state_show, inode->i_private);
+}
+
+static const struct file_operations hfi_state_ops = {
+	.open		= hfi_state_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static struct dentry *hfi_debugfs_dir;
+
+static void hfi_dbgfs_unregister(void)
+{
+	debugfs_remove_recursive(hfi_debugfs_dir);
+}
+
+static void hfi_dbgfs_register(void)
+{
+	struct dentry *f;
+
+	hfi_debugfs_dir = debugfs_create_dir("intel_hw_feedback", NULL);
+	if (!hfi_debugfs_dir)
+		return;
+
+	f = debugfs_create_file("features", 0444, hfi_debugfs_dir,
+				NULL, &hfi_features_fops);
+	if (!f)
+		goto err;
+
+	return;
+err:
+	hfi_dbgfs_unregister();
+	return;
+}
+#else
+static void hfi_dbgfs_register(void)
+{
+	return;
+}
+#endif /* CONFIG_DEBUG_FS */
+
 static void get_one_hfi_cap(struct hfi_instance *hfi_instance, s16 index,
 			    struct hfi_cpu_data *hfi_caps, int classid)
 {
@@ -458,6 +625,16 @@ void intel_hfi_online(unsigned int cpu)
 	cpumask_set_cpu(cpu, hfi_instance->cpus);
 	info->hfi_instance = hfi_instance;
 
+#ifdef CONFIG_DEBUG_FS
+	if (hfi_debugfs_dir) {
+		char name[64];
+
+		snprintf(name, 64, "hw_state%u", die_id);
+		debugfs_create_file(name, 0444, hfi_debugfs_dir, hfi_instance,
+				    &hfi_state_ops);
+	}
+#endif
+
 	/*
 	 * Enable the hardware feedback interface and never disable it. See
 	 * comment on programming the address of the table.
@@ -600,6 +777,8 @@ void __init intel_hfi_init(void)
 			goto err_nomem;
 	}
 
+	hfi_dbgfs_register();
+
 	return;
 
 err_nomem:
-- 
2.32.0

