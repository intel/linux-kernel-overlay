From ec9d20c12e70d131b58986f2733a29de50bc7ae5 Mon Sep 17 00:00:00 2001
From: "Baindur, GauravX" <gauravx.baindur@intel.com>
Date: Fri, 10 Mar 2023 12:13:58 +0530
Subject: [PATCH] Added spi_set_cs to driver code for more stable performance

Signed-off-by: Baindur, GauravX <gauravx.baindur@intel.com>
---
 drivers/spi/spi-pxa2xx.c | 9 +++++++++
 drivers/spi/spi.c        | 3 ++-
 include/linux/spi/spi.h  | 2 ++
 3 files changed, 13 insertions(+), 1 deletion(-)

diff --git a/drivers/spi/spi-pxa2xx.c b/drivers/spi/spi-pxa2xx.c
index 2bf21c2e7a52..373e9d1f1fc0 100644
--- a/drivers/spi/spi-pxa2xx.c
+++ b/drivers/spi/spi-pxa2xx.c
@@ -1082,6 +1082,13 @@ static int pxa2xx_spi_transfer_one(struct spi_controller *controller,
 	if (!pxa25x_ssp_comp(drv_data))
 		pxa2xx_spi_write(drv_data, SSTO, chip->timeout);
 
+	/*
+	* This SPI controller needs the chip select asserted only after the SPI
+	* controller is configured and enabled for stable functionality.
+	* Hence, deasserting the chip select here.
+	* */
+	spi_set_cs(spi, false, false);
+
 	/* First set CR1 without interrupt and service enables */
 	pxa2xx_spi_update(drv_data, SSCR1, change_mask, cr1);
 
@@ -1091,6 +1098,8 @@ static int pxa2xx_spi_transfer_one(struct spi_controller *controller,
 	/* Restart the SSP */
 	pxa_ssp_enable(drv_data->ssp);
 
+	spi_set_cs(spi, true, false);
+
 	if (is_mmp2_ssp(drv_data)) {
 		u8 tx_level = read_SSSR_bits(drv_data, SSSR_TFL_MASK) >> 8;
 
diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 5f9aedd1f0b6..b80333919533 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -950,7 +950,7 @@ static void spi_res_release(struct spi_controller *ctlr, struct spi_message *mes
 
 /*-------------------------------------------------------------------------*/
 
-static void spi_set_cs(struct spi_device *spi, bool enable, bool force)
+void spi_set_cs(struct spi_device *spi, bool enable, bool force)
 {
 	bool activate = enable;
 
@@ -1008,6 +1008,7 @@ static void spi_set_cs(struct spi_device *spi, bool enable, bool force)
 			spi_delay_exec(&spi->cs_inactive, NULL);
 	}
 }
+EXPORT_SYMBOL_GPL(spi_set_cs);
 
 #ifdef CONFIG_HAS_DMA
 static int spi_map_buf_attrs(struct spi_controller *ctlr, struct device *dev,
diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index fbf8c0d95968..ce889cc5ba15 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -727,6 +727,8 @@ static inline bool spi_controller_is_slave(struct spi_controller *ctlr)
 	return IS_ENABLED(CONFIG_SPI_SLAVE) && ctlr->slave;
 }
 
+extern void spi_set_cs(struct spi_device *spi, bool enable, bool force);
+
 /* PM calls that need to be issued by the driver */
 extern int spi_controller_suspend(struct spi_controller *ctlr);
 extern int spi_controller_resume(struct spi_controller *ctlr);
-- 
2.25.1

