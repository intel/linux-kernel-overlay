From 8278889913553db3c4b2e903afbf65f738ee0438 Mon Sep 17 00:00:00 2001
From: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date: Wed, 19 May 2021 10:51:45 -0400
Subject: [PATCH 2619/2740] drm/amd/display: Add DCN3.1 DCCG

Add programming of the DCCG (Display Controller Clock Generator) block:

HW Blocks:

    +--------+
    |  DCCG  |
    +--------+

Acked-by: Huang Rui <ray.huang@amd.com>
Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
---
 .../gpu/drm/amd/display/dc/dcn20/dcn20_dccg.h |  54 ++++
 .../gpu/drm/amd/display/dc/dcn31/dcn31_dccg.c | 279 ++++++++++++++++++
 .../gpu/drm/amd/display/dc/dcn31/dcn31_dccg.h | 147 +++++++++
 drivers/gpu/drm/amd/display/dc/inc/hw/dccg.h  |  56 ++++
 4 files changed, 536 insertions(+)
 create mode 100644 drivers/gpu/drm/amd/display/dc/dcn31/dcn31_dccg.c
 create mode 100644 drivers/gpu/drm/amd/display/dc/dcn31/dcn31_dccg.h

diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_dccg.h b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_dccg.h
index d407f33308b9..e5aa2da3176d 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_dccg.h
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_dccg.h
@@ -84,14 +84,53 @@
 	type PHYCSYMCLK_FORCE_EN;\
 	type PHYCSYMCLK_FORCE_SRC_SEL;
 
+#if defined(CONFIG_DRM_AMD_DC_DCN3_1)
+#define DCCG31_REG_FIELD_LIST(type) \
+	type PHYDSYMCLK_FORCE_EN;\
+	type PHYDSYMCLK_FORCE_SRC_SEL;\
+	type PHYESYMCLK_FORCE_EN;\
+	type PHYESYMCLK_FORCE_SRC_SEL;\
+	type DPSTREAMCLK_PIPE0_EN;\
+	type DPSTREAMCLK_PIPE1_EN;\
+	type DPSTREAMCLK_PIPE2_EN;\
+	type DPSTREAMCLK_PIPE3_EN;\
+	type HDMISTREAMCLK0_SRC_SEL;\
+	type HDMISTREAMCLK0_DTO_FORCE_DIS;\
+	type SYMCLK32_SE0_SRC_SEL;\
+	type SYMCLK32_SE1_SRC_SEL;\
+	type SYMCLK32_SE2_SRC_SEL;\
+	type SYMCLK32_SE3_SRC_SEL;\
+	type SYMCLK32_SE0_EN;\
+	type SYMCLK32_SE1_EN;\
+	type SYMCLK32_SE2_EN;\
+	type SYMCLK32_SE3_EN;\
+	type SYMCLK32_LE0_SRC_SEL;\
+	type SYMCLK32_LE1_SRC_SEL;\
+	type SYMCLK32_LE0_EN;\
+	type SYMCLK32_LE1_EN;\
+	type DTBCLK_DTO_ENABLE[MAX_PIPES];\
+	type DTBCLKDTO_ENABLE_STATUS[MAX_PIPES];\
+	type PIPE_DTO_SRC_SEL[MAX_PIPES];\
+	type DTBCLK_DTO_DIV[MAX_PIPES];\
+	type DCCG_AUDIO_DTO_SEL;\
+	type DCCG_AUDIO_DTO0_SOURCE_SEL;\
+	type DENTIST_DISPCLK_CHG_MODE;
+#endif
+
 struct dccg_shift {
 	DCCG_REG_FIELD_LIST(uint8_t)
 	DCCG3_REG_FIELD_LIST(uint8_t)
+#if defined(CONFIG_DRM_AMD_DC_DCN3_1)
+	DCCG31_REG_FIELD_LIST(uint8_t)
+#endif
 };
 
 struct dccg_mask {
 	DCCG_REG_FIELD_LIST(uint32_t)
 	DCCG3_REG_FIELD_LIST(uint32_t)
+#if defined(CONFIG_DRM_AMD_DC_DCN3_1)
+	DCCG31_REG_FIELD_LIST(uint32_t)
+#endif
 };
 
 struct dccg_registers {
@@ -102,6 +141,21 @@ struct dccg_registers {
 	uint32_t PHYASYMCLK_CLOCK_CNTL;
 	uint32_t PHYBSYMCLK_CLOCK_CNTL;
 	uint32_t PHYCSYMCLK_CLOCK_CNTL;
+#if defined(CONFIG_DRM_AMD_DC_DCN3_1)
+	uint32_t PHYDSYMCLK_CLOCK_CNTL;
+	uint32_t PHYESYMCLK_CLOCK_CNTL;
+	uint32_t OTG_PIXEL_RATE_CNTL[MAX_PIPES];
+	uint32_t DTBCLK_DTO_MODULO[MAX_PIPES];
+	uint32_t DTBCLK_DTO_PHASE[MAX_PIPES];
+	uint32_t DCCG_AUDIO_DTBCLK_DTO_MODULO;
+	uint32_t DCCG_AUDIO_DTBCLK_DTO_PHASE;
+	uint32_t DCCG_AUDIO_DTO_SOURCE;
+	uint32_t DPSTREAMCLK_CNTL;
+	uint32_t HDMISTREAMCLK_CNTL;
+	uint32_t SYMCLK32_SE_CNTL;
+	uint32_t SYMCLK32_LE_CNTL;
+	uint32_t DENTIST_DISPCLK_CNTL;
+#endif
 };
 
 struct dcn_dccg {
diff --git a/drivers/gpu/drm/amd/display/dc/dcn31/dcn31_dccg.c b/drivers/gpu/drm/amd/display/dc/dcn31/dcn31_dccg.c
new file mode 100644
index 000000000000..696c9307715d
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dcn31/dcn31_dccg.c
@@ -0,0 +1,279 @@
+/*
+ * Copyright 2018 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#include "reg_helper.h"
+#include "core_types.h"
+#include "dcn31_dccg.h"
+
+#define TO_DCN_DCCG(dccg)\
+	container_of(dccg, struct dcn_dccg, base)
+
+#define REG(reg) \
+	(dccg_dcn->regs->reg)
+
+#undef FN
+#define FN(reg_name, field_name) \
+	dccg_dcn->dccg_shift->field_name, dccg_dcn->dccg_mask->field_name
+
+#define CTX \
+	dccg_dcn->base.ctx
+#define DC_LOGGER \
+	dccg->ctx->logger
+
+void dccg31_set_physymclk(
+		struct dccg *dccg,
+		int phy_inst,
+		enum physymclk_clock_source clk_src,
+		bool force_enable)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+
+	/* Force PHYSYMCLK on and Select phyd32clk as the source of clock which is output to PHY through DCIO */
+	switch (phy_inst) {
+	case 0:
+		if (force_enable)
+			REG_UPDATE_2(PHYASYMCLK_CLOCK_CNTL,
+					PHYASYMCLK_FORCE_EN, 1,
+					PHYASYMCLK_FORCE_SRC_SEL, clk_src);
+		else
+			REG_UPDATE_2(PHYASYMCLK_CLOCK_CNTL,
+					PHYASYMCLK_FORCE_EN, 0,
+					PHYASYMCLK_FORCE_SRC_SEL, 0);
+		break;
+	case 1:
+		if (force_enable)
+			REG_UPDATE_2(PHYBSYMCLK_CLOCK_CNTL,
+					PHYBSYMCLK_FORCE_EN, 1,
+					PHYBSYMCLK_FORCE_SRC_SEL, clk_src);
+		else
+			REG_UPDATE_2(PHYBSYMCLK_CLOCK_CNTL,
+					PHYBSYMCLK_FORCE_EN, 0,
+					PHYBSYMCLK_FORCE_SRC_SEL, 0);
+		break;
+	case 2:
+		if (force_enable)
+			REG_UPDATE_2(PHYCSYMCLK_CLOCK_CNTL,
+					PHYCSYMCLK_FORCE_EN, 1,
+					PHYCSYMCLK_FORCE_SRC_SEL, clk_src);
+		else
+			REG_UPDATE_2(PHYCSYMCLK_CLOCK_CNTL,
+					PHYCSYMCLK_FORCE_EN, 0,
+					PHYCSYMCLK_FORCE_SRC_SEL, 0);
+		break;
+	case 3:
+		if (force_enable)
+			REG_UPDATE_2(PHYDSYMCLK_CLOCK_CNTL,
+					PHYDSYMCLK_FORCE_EN, 1,
+					PHYDSYMCLK_FORCE_SRC_SEL, clk_src);
+		else
+			REG_UPDATE_2(PHYDSYMCLK_CLOCK_CNTL,
+					PHYDSYMCLK_FORCE_EN, 0,
+					PHYDSYMCLK_FORCE_SRC_SEL, 0);
+		break;
+	case 4:
+		if (force_enable)
+			REG_UPDATE_2(PHYESYMCLK_CLOCK_CNTL,
+					PHYESYMCLK_FORCE_EN, 1,
+					PHYESYMCLK_FORCE_SRC_SEL, clk_src);
+		else
+			REG_UPDATE_2(PHYESYMCLK_CLOCK_CNTL,
+					PHYESYMCLK_FORCE_EN, 0,
+					PHYESYMCLK_FORCE_SRC_SEL, 0);
+		break;
+	default:
+		BREAK_TO_DEBUGGER();
+		return;
+	}
+}
+
+/* Controls the generation of pixel valid for OTG in (OTG -> HPO case) */
+void dccg31_set_dtbclk_dto(
+		struct dccg *dccg,
+		int dtbclk_inst,
+		int req_dtbclk_khz,
+		int num_odm_segments,
+		const struct dc_crtc_timing *timing)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+	uint32_t dtbdto_div;
+
+	/* Mode	                DTBDTO Rate       DTBCLK_DTO<x>_DIV Register
+	 * ODM 4:1 combine      pixel rate/4      2
+	 * ODM 2:1 combine      pixel rate/2      4
+	 * non-DSC 4:2:0 mode   pixel rate/2      4
+	 * DSC native 4:2:0     pixel rate/2      4
+	 * DSC native 4:2:2     pixel rate/2      4
+	 * Other modes          pixel rate        8
+	 */
+	if (num_odm_segments == 4) {
+		dtbdto_div = 2;
+		req_dtbclk_khz = req_dtbclk_khz / 4;
+	} else if ((num_odm_segments == 2) ||
+			(timing->pixel_encoding == PIXEL_ENCODING_YCBCR420) ||
+			(timing->flags.DSC && timing->pixel_encoding == PIXEL_ENCODING_YCBCR422
+					&& !timing->dsc_cfg.ycbcr422_simple)) {
+		dtbdto_div = 4;
+		req_dtbclk_khz = req_dtbclk_khz / 2;
+	} else
+		dtbdto_div = 8;
+
+	if (dccg->ref_dtbclk_khz && req_dtbclk_khz) {
+		uint32_t modulo, phase;
+
+		// phase / modulo = dtbclk / dtbclk ref
+		modulo = dccg->ref_dtbclk_khz * 1000;
+		phase = div_u64((((unsigned long long)modulo * req_dtbclk_khz) + dccg->ref_dtbclk_khz - 1),
+			dccg->ref_dtbclk_khz);
+
+		REG_UPDATE(OTG_PIXEL_RATE_CNTL[dtbclk_inst],
+				DTBCLK_DTO_DIV[dtbclk_inst], dtbdto_div);
+
+		REG_WRITE(DTBCLK_DTO_MODULO[dtbclk_inst], modulo);
+		REG_WRITE(DTBCLK_DTO_PHASE[dtbclk_inst], phase);
+
+		REG_UPDATE(OTG_PIXEL_RATE_CNTL[dtbclk_inst],
+				DTBCLK_DTO_ENABLE[dtbclk_inst], 1);
+
+		REG_WAIT(OTG_PIXEL_RATE_CNTL[dtbclk_inst],
+				DTBCLKDTO_ENABLE_STATUS[dtbclk_inst], 1,
+				1, 100);
+
+		/* The recommended programming sequence to enable DTBCLK DTO to generate
+		 * valid pixel HPO DPSTREAM ENCODER, specifies that DTO source select should
+		 * be set only after DTO is enabled
+		 */
+		REG_UPDATE(OTG_PIXEL_RATE_CNTL[dtbclk_inst],
+				PIPE_DTO_SRC_SEL[dtbclk_inst], 1);
+
+		dccg->dtbclk_khz[dtbclk_inst] = req_dtbclk_khz;
+	} else {
+		REG_UPDATE_3(OTG_PIXEL_RATE_CNTL[dtbclk_inst],
+				DTBCLK_DTO_ENABLE[dtbclk_inst], 0,
+				PIPE_DTO_SRC_SEL[dtbclk_inst], 0,
+				DTBCLK_DTO_DIV[dtbclk_inst], dtbdto_div);
+
+		REG_WRITE(DTBCLK_DTO_MODULO[dtbclk_inst], 0);
+		REG_WRITE(DTBCLK_DTO_PHASE[dtbclk_inst], 0);
+
+		dccg->dtbclk_khz[dtbclk_inst] = 0;
+	}
+}
+
+void dccg31_set_audio_dtbclk_dto(
+		struct dccg *dccg,
+		uint32_t req_audio_dtbclk_khz)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+
+	if (dccg->ref_dtbclk_khz && req_audio_dtbclk_khz) {
+		uint32_t modulo, phase;
+
+		// phase / modulo = dtbclk / dtbclk ref
+		modulo = dccg->ref_dtbclk_khz * 1000;
+		phase = div_u64((((unsigned long long)modulo * req_audio_dtbclk_khz) + dccg->ref_dtbclk_khz - 1),
+			dccg->ref_dtbclk_khz);
+
+
+		REG_WRITE(DCCG_AUDIO_DTBCLK_DTO_MODULO, modulo);
+		REG_WRITE(DCCG_AUDIO_DTBCLK_DTO_PHASE, phase);
+
+		//REG_UPDATE(DCCG_AUDIO_DTO_SOURCE,
+		//		DCCG_AUDIO_DTBCLK_DTO_USE_512FBR_DTO, 1);
+
+		REG_UPDATE(DCCG_AUDIO_DTO_SOURCE,
+				DCCG_AUDIO_DTO_SEL, 4);  //  04 - DCCG_AUDIO_DTO_SEL_AUDIO_DTO_DTBCLK
+
+		dccg->audio_dtbclk_khz = req_audio_dtbclk_khz;
+	} else {
+		REG_WRITE(DCCG_AUDIO_DTBCLK_DTO_PHASE, 0);
+		REG_WRITE(DCCG_AUDIO_DTBCLK_DTO_MODULO, 0);
+
+		REG_UPDATE(DCCG_AUDIO_DTO_SOURCE,
+				DCCG_AUDIO_DTO_SEL, 3);  //  03 - DCCG_AUDIO_DTO_SEL_NO_AUDIO_DTO
+
+		dccg->audio_dtbclk_khz = 0;
+	}
+}
+
+static void dccg31_get_dccg_ref_freq(struct dccg *dccg,
+		unsigned int xtalin_freq_inKhz,
+		unsigned int *dccg_ref_freq_inKhz)
+{
+	/*
+	 * Assume refclk is sourced from xtalin
+	 * expect 24MHz
+	 */
+	*dccg_ref_freq_inKhz = xtalin_freq_inKhz;
+	return;
+}
+
+static void dccg31_set_dispclk_change_mode(
+	struct dccg *dccg,
+	enum dentist_dispclk_change_mode change_mode)
+{
+	struct dcn_dccg *dccg_dcn = TO_DCN_DCCG(dccg);
+
+	REG_UPDATE(DENTIST_DISPCLK_CNTL, DENTIST_DISPCLK_CHG_MODE,
+		   change_mode == DISPCLK_CHANGE_MODE_RAMPING ? 2 : 0);
+}
+
+void dccg31_init(struct dccg *dccg)
+{
+}
+
+static const struct dccg_funcs dccg31_funcs = {
+	.update_dpp_dto = dccg2_update_dpp_dto,
+	.get_dccg_ref_freq = dccg31_get_dccg_ref_freq,
+	.dccg_init = dccg31_init,
+	.set_physymclk = dccg31_set_physymclk,
+	.set_dtbclk_dto = dccg31_set_dtbclk_dto,
+	.set_audio_dtbclk_dto = dccg31_set_audio_dtbclk_dto,
+	.set_dispclk_change_mode = dccg31_set_dispclk_change_mode,
+};
+
+struct dccg *dccg31_create(
+	struct dc_context *ctx,
+	const struct dccg_registers *regs,
+	const struct dccg_shift *dccg_shift,
+	const struct dccg_mask *dccg_mask)
+{
+	struct dcn_dccg *dccg_dcn = kzalloc(sizeof(*dccg_dcn), GFP_KERNEL);
+	struct dccg *base;
+
+	if (dccg_dcn == NULL) {
+		BREAK_TO_DEBUGGER();
+		return NULL;
+	}
+
+	base = &dccg_dcn->base;
+	base->ctx = ctx;
+	base->funcs = &dccg31_funcs;
+
+	dccg_dcn->regs = regs;
+	dccg_dcn->dccg_shift = dccg_shift;
+	dccg_dcn->dccg_mask = dccg_mask;
+
+	return &dccg_dcn->base;
+}
diff --git a/drivers/gpu/drm/amd/display/dc/dcn31/dcn31_dccg.h b/drivers/gpu/drm/amd/display/dc/dcn31/dcn31_dccg.h
new file mode 100644
index 000000000000..706ad80ba873
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dcn31/dcn31_dccg.h
@@ -0,0 +1,147 @@
+/*
+ * Copyright 2018 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#ifndef __DCN31_DCCG_H__
+#define __DCN31_DCCG_H__
+
+#include "dcn30/dcn30_dccg.h"
+
+#define DCCG_SFII(block, reg_name, field_prefix, field_name, inst, post_fix)\
+	.field_prefix ## _ ## field_name[inst] = block ## inst ## _ ## reg_name ## __ ## field_prefix ## inst ## _ ## field_name ## post_fix
+
+
+#define DCCG_REG_LIST_DCN31() \
+	SR(DPPCLK_DTO_CTRL),\
+	DCCG_SRII(DTO_PARAM, DPPCLK, 0),\
+	DCCG_SRII(DTO_PARAM, DPPCLK, 1),\
+	DCCG_SRII(DTO_PARAM, DPPCLK, 2),\
+	DCCG_SRII(DTO_PARAM, DPPCLK, 3),\
+	SR(PHYASYMCLK_CLOCK_CNTL),\
+	SR(PHYBSYMCLK_CLOCK_CNTL),\
+	SR(PHYCSYMCLK_CLOCK_CNTL),\
+	SR(PHYDSYMCLK_CLOCK_CNTL),\
+	SR(PHYESYMCLK_CLOCK_CNTL),\
+	SR(DPSTREAMCLK_CNTL),\
+	SR(SYMCLK32_SE_CNTL),\
+	SR(SYMCLK32_LE_CNTL),\
+	DCCG_SRII(PIXEL_RATE_CNTL, OTG, 0),\
+	DCCG_SRII(PIXEL_RATE_CNTL, OTG, 1),\
+	DCCG_SRII(PIXEL_RATE_CNTL, OTG, 2),\
+	DCCG_SRII(PIXEL_RATE_CNTL, OTG, 3),\
+	DCCG_SRII(MODULO, DTBCLK_DTO, 0),\
+	DCCG_SRII(MODULO, DTBCLK_DTO, 1),\
+	DCCG_SRII(MODULO, DTBCLK_DTO, 2),\
+	DCCG_SRII(MODULO, DTBCLK_DTO, 3),\
+	DCCG_SRII(PHASE, DTBCLK_DTO, 0),\
+	DCCG_SRII(PHASE, DTBCLK_DTO, 1),\
+	DCCG_SRII(PHASE, DTBCLK_DTO, 2),\
+	DCCG_SRII(PHASE, DTBCLK_DTO, 3),\
+	SR(DCCG_AUDIO_DTBCLK_DTO_MODULO),\
+	SR(DCCG_AUDIO_DTBCLK_DTO_PHASE),\
+	SR(DCCG_AUDIO_DTO_SOURCE),\
+	SR(DENTIST_DISPCLK_CNTL)
+
+
+#define DCCG_MASK_SH_LIST_DCN31(mask_sh) \
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_ENABLE, DPPCLK, 0, mask_sh),\
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 0, mask_sh),\
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_ENABLE, DPPCLK, 1, mask_sh),\
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 1, mask_sh),\
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_ENABLE, DPPCLK, 2, mask_sh),\
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 2, mask_sh),\
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_ENABLE, DPPCLK, 3, mask_sh),\
+	DCCG_SFI(DPPCLK_DTO_CTRL, DTO_DB_EN, DPPCLK, 3, mask_sh),\
+	DCCG_SF(DPPCLK0_DTO_PARAM, DPPCLK0_DTO_PHASE, mask_sh),\
+	DCCG_SF(DPPCLK0_DTO_PARAM, DPPCLK0_DTO_MODULO, mask_sh),\
+	DCCG_SF(PHYASYMCLK_CLOCK_CNTL, PHYASYMCLK_FORCE_EN, mask_sh),\
+	DCCG_SF(PHYASYMCLK_CLOCK_CNTL, PHYASYMCLK_FORCE_SRC_SEL, mask_sh),\
+	DCCG_SF(PHYBSYMCLK_CLOCK_CNTL, PHYBSYMCLK_FORCE_EN, mask_sh),\
+	DCCG_SF(PHYBSYMCLK_CLOCK_CNTL, PHYBSYMCLK_FORCE_SRC_SEL, mask_sh),\
+	DCCG_SF(PHYCSYMCLK_CLOCK_CNTL, PHYCSYMCLK_FORCE_EN, mask_sh),\
+	DCCG_SF(PHYCSYMCLK_CLOCK_CNTL, PHYCSYMCLK_FORCE_SRC_SEL, mask_sh),\
+	DCCG_SF(PHYDSYMCLK_CLOCK_CNTL, PHYDSYMCLK_FORCE_EN, mask_sh),\
+	DCCG_SF(PHYDSYMCLK_CLOCK_CNTL, PHYDSYMCLK_FORCE_SRC_SEL, mask_sh),\
+	DCCG_SF(PHYESYMCLK_CLOCK_CNTL, PHYESYMCLK_FORCE_EN, mask_sh),\
+	DCCG_SF(PHYESYMCLK_CLOCK_CNTL, PHYESYMCLK_FORCE_SRC_SEL, mask_sh),\
+	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK_PIPE0_EN, mask_sh),\
+	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK_PIPE1_EN, mask_sh),\
+	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK_PIPE2_EN, mask_sh),\
+	DCCG_SF(DPSTREAMCLK_CNTL, DPSTREAMCLK_PIPE3_EN, mask_sh),\
+	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE0_SRC_SEL, mask_sh),\
+	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE1_SRC_SEL, mask_sh),\
+	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE2_SRC_SEL, mask_sh),\
+	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE3_SRC_SEL, mask_sh),\
+	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE0_EN, mask_sh),\
+	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE1_EN, mask_sh),\
+	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE2_EN, mask_sh),\
+	DCCG_SF(SYMCLK32_SE_CNTL, SYMCLK32_SE3_EN, mask_sh),\
+	DCCG_SF(SYMCLK32_LE_CNTL, SYMCLK32_LE0_SRC_SEL, mask_sh),\
+	DCCG_SF(SYMCLK32_LE_CNTL, SYMCLK32_LE1_SRC_SEL, mask_sh),\
+	DCCG_SF(SYMCLK32_LE_CNTL, SYMCLK32_LE0_EN, mask_sh),\
+	DCCG_SF(SYMCLK32_LE_CNTL, SYMCLK32_LE1_EN, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLK_DTO, ENABLE, 0, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLK_DTO, ENABLE, 1, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLK_DTO, ENABLE, 2, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLK_DTO, ENABLE, 3, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLKDTO, ENABLE_STATUS, 0, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLKDTO, ENABLE_STATUS, 1, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLKDTO, ENABLE_STATUS, 2, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLKDTO, ENABLE_STATUS, 3, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, PIPE, DTO_SRC_SEL, 0, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, PIPE, DTO_SRC_SEL, 1, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, PIPE, DTO_SRC_SEL, 2, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, PIPE, DTO_SRC_SEL, 3, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLK_DTO, DIV, 0, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLK_DTO, DIV, 1, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLK_DTO, DIV, 2, mask_sh),\
+	DCCG_SFII(OTG, PIXEL_RATE_CNTL, DTBCLK_DTO, DIV, 3, mask_sh),\
+	DCCG_SF(DCCG_AUDIO_DTO_SOURCE, DCCG_AUDIO_DTO_SEL, mask_sh),\
+	DCCG_SF(DCCG_AUDIO_DTO_SOURCE, DCCG_AUDIO_DTO0_SOURCE_SEL, mask_sh),\
+	DCCG_SF(DENTIST_DISPCLK_CNTL, DENTIST_DISPCLK_CHG_MODE, mask_sh)
+
+
+struct dccg *dccg31_create(
+	struct dc_context *ctx,
+	const struct dccg_registers *regs,
+	const struct dccg_shift *dccg_shift,
+	const struct dccg_mask *dccg_mask);
+
+void dccg31_init(struct dccg *dccg);
+
+void dccg31_set_physymclk(
+		struct dccg *dccg,
+		int phy_inst,
+		enum physymclk_clock_source clk_src,
+		bool force_enable);
+
+void dccg31_set_audio_dtbclk_dto(
+		struct dccg *dccg,
+		uint32_t req_audio_dtbclk_khz);
+
+void dccg31_set_hdmistreamclk(
+		struct dccg *dccg,
+		enum hdmistreamclk_source src);
+
+#endif //__DCN31_DCCG_H__
diff --git a/drivers/gpu/drm/amd/display/dc/inc/hw/dccg.h b/drivers/gpu/drm/amd/display/dc/inc/hw/dccg.h
index 336c80a18175..f7aa703e3175 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/hw/dccg.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/hw/dccg.h
@@ -29,11 +29,44 @@
 #include "dc_types.h"
 #include "hw_shared.h"
 
+#if defined(CONFIG_DRM_AMD_DC_DCN3_1)
+enum phyd32clk_clock_source {
+	PHYD32CLKA,
+	PHYD32CLKB,
+	PHYD32CLKC,
+	PHYD32CLKD,
+	PHYD32CLKE,
+	PHYD32CLKF,
+	PHYD32CLKG,
+};
+
+enum physymclk_clock_source {
+	PHYSYMCLK_FORCE_SRC_SYMCLK,    // Select symclk as source of clock which is output to PHY through DCIO.
+	PHYSYMCLK_FORCE_SRC_PHYD18CLK, // Select phyd18clk as the source of clock which is output to PHY through DCIO.
+	PHYSYMCLK_FORCE_SRC_PHYD32CLK, // Select phyd32clk as the source of clock which is output to PHY through DCIO.
+};
+
+enum hdmistreamclk_source {
+	REFCLK,                   // Selects REFCLK as source for hdmistreamclk.
+	DTBCLK0,                  // Selects DTBCLK0 as source for hdmistreamclk.
+};
+
+enum dentist_dispclk_change_mode {
+	DISPCLK_CHANGE_MODE_IMMEDIATE,
+	DISPCLK_CHANGE_MODE_RAMPING,
+};
+#endif
+
 struct dccg {
 	struct dc_context *ctx;
 	const struct dccg_funcs *funcs;
 	int pipe_dppclk_khz[MAX_PIPES];
 	int ref_dppclk;
+#if defined(CONFIG_DRM_AMD_DC_DCN3_1)
+	int dtbclk_khz[MAX_PIPES];
+	int audio_dtbclk_khz;
+	int ref_dtbclk_khz;
+#endif
 };
 
 struct dccg_funcs {
@@ -44,6 +77,29 @@ struct dccg_funcs {
 			unsigned int xtalin_freq_inKhz,
 			unsigned int *dccg_ref_freq_inKhz);
 	void (*dccg_init)(struct dccg *dccg);
+#if defined(CONFIG_DRM_AMD_DC_DCN3_1)
+
+	void (*set_physymclk)(
+			struct dccg *dccg,
+			int phy_inst,
+			enum physymclk_clock_source clk_src,
+			bool force_enable);
+
+	void (*set_dtbclk_dto)(
+			struct dccg *dccg,
+			int dtbclk_inst,
+			int req_dtbclk_khz,
+			int num_odm_segments,
+			const struct dc_crtc_timing *timing);
+
+	void (*set_audio_dtbclk_dto)(
+			struct dccg *dccg,
+			uint32_t req_audio_dtbclk_khz);
+
+	void (*set_dispclk_change_mode)(
+			struct dccg *dccg,
+			enum dentist_dispclk_change_mode change_mode);
+#endif
 };
 
 #endif //__DAL_DCCG_H__
-- 
2.25.1

