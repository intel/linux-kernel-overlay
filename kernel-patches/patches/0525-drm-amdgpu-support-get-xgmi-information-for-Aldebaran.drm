From ddf87f7de0c927544c00d0d22f4dcb60c6ec7422 Mon Sep 17 00:00:00 2001
From: Rajneesh Bhardwaj <rajneesh.bhardwaj@amd.com>
Date: Thu, 30 Apr 2020 02:34:57 -0400
Subject: [PATCH 0525/2740] drm/amdgpu: support get xgmi information for
 Aldebaran

Aldebaran uses registers defined in header gc_9_4_2 but much of the xgmi
related functionality can be obtained by reusing the exisitng definition
from gfxhub_v1_1_get_xgmi_info. While adding support for Aldebaran, also
refactored code to better handle the new scenario.

Signed-off-by: Rajneesh Bhardwaj <rajneesh.bhardwaj@amd.com>
Reviewed-by: Hawking Zhang <Hawking.Zhang@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
---
 drivers/gpu/drm/amd/amdgpu/gfxhub_v1_1.c | 58 +++++++++++++++++++-----
 1 file changed, 47 insertions(+), 11 deletions(-)

diff --git a/drivers/gpu/drm/amd/amdgpu/gfxhub_v1_1.c b/drivers/gpu/drm/amd/amdgpu/gfxhub_v1_1.c
index c0ab71df0d90..3b4193ca2a47 100644
--- a/drivers/gpu/drm/amd/amdgpu/gfxhub_v1_1.c
+++ b/drivers/gpu/drm/amd/amdgpu/gfxhub_v1_1.c
@@ -28,13 +28,42 @@
 
 #include "soc15_common.h"
 
+#define mmMC_VM_XGMI_LFB_CNTL_ALDE			0x0978
+#define mmMC_VM_XGMI_LFB_CNTL_ALDE_BASE_IDX		0
+#define mmMC_VM_XGMI_LFB_SIZE_ALDE			0x0979
+#define mmMC_VM_XGMI_LFB_SIZE_ALDE_BASE_IDX		0
+//MC_VM_XGMI_LFB_CNTL
+#define MC_VM_XGMI_LFB_CNTL_ALDE__PF_LFB_REGION__SHIFT	0x0
+#define MC_VM_XGMI_LFB_CNTL_ALDE__PF_MAX_REGION__SHIFT	0x4
+#define MC_VM_XGMI_LFB_CNTL_ALDE__PF_LFB_REGION_MASK	0x0000000FL
+#define MC_VM_XGMI_LFB_CNTL_ALDE__PF_MAX_REGION_MASK	0x000000F0L
+//MC_VM_XGMI_LFB_SIZE
+#define MC_VM_XGMI_LFB_SIZE_ALDE__PF_LFB_SIZE__SHIFT	0x0
+#define MC_VM_XGMI_LFB_SIZE_ALDE__PF_LFB_SIZE_MASK	0x0001FFFFL
+
 int gfxhub_v1_1_get_xgmi_info(struct amdgpu_device *adev)
 {
-	u32 xgmi_lfb_cntl = RREG32_SOC15(GC, 0, mmMC_VM_XGMI_LFB_CNTL);
-	u32 max_region =
+	u32 max_num_physical_nodes;
+	u32 max_physical_node_id;
+	u32 xgmi_lfb_cntl;
+	u32 max_region;
+	u64 seg_size;
+
+	if (adev->asic_type == CHIP_ALDEBARAN) {
+		xgmi_lfb_cntl = RREG32_SOC15(GC, 0, mmMC_VM_XGMI_LFB_CNTL_ALDE);
+		seg_size = REG_GET_FIELD(
+			RREG32_SOC15(GC, 0, mmMC_VM_XGMI_LFB_SIZE_ALDE),
+			MC_VM_XGMI_LFB_SIZE, PF_LFB_SIZE) << 24;
+	} else {
+		xgmi_lfb_cntl = RREG32_SOC15(GC, 0, mmMC_VM_XGMI_LFB_CNTL);
+		seg_size = REG_GET_FIELD(
+			RREG32_SOC15(GC, 0, mmMC_VM_XGMI_LFB_SIZE),
+			MC_VM_XGMI_LFB_SIZE, PF_LFB_SIZE) << 24;
+	}
+
+	max_region =
 		REG_GET_FIELD(xgmi_lfb_cntl, MC_VM_XGMI_LFB_CNTL, PF_MAX_REGION);
-	u32 max_num_physical_nodes   = 0;
-	u32 max_physical_node_id     = 0;
+
 
 	switch (adev->asic_type) {
 	case CHIP_VEGA20:
@@ -45,23 +74,30 @@ int gfxhub_v1_1_get_xgmi_info(struct amdgpu_device *adev)
 		max_num_physical_nodes   = 8;
 		max_physical_node_id     = 7;
 		break;
+	case CHIP_ALDEBARAN:
+		/* just using duplicates for Aldebaran support, revisit later */
+		max_num_physical_nodes   = 8;
+		max_physical_node_id     = 7;
+		break;
 	default:
 		return -EINVAL;
 	}
 
 	/* PF_MAX_REGION=0 means xgmi is disabled */
-	if (max_region) {
+	if (max_region || adev->gmc.xgmi.connected_to_cpu) {
 		adev->gmc.xgmi.num_physical_nodes = max_region + 1;
+
 		if (adev->gmc.xgmi.num_physical_nodes > max_num_physical_nodes)
-			return -EINVAL;
+		return -EINVAL;
 
 		adev->gmc.xgmi.physical_node_id =
-			REG_GET_FIELD(xgmi_lfb_cntl, MC_VM_XGMI_LFB_CNTL, PF_LFB_REGION);
+		REG_GET_FIELD(xgmi_lfb_cntl, MC_VM_XGMI_LFB_CNTL,
+			      PF_LFB_REGION);
+
 		if (adev->gmc.xgmi.physical_node_id > max_physical_node_id)
-			return -EINVAL;
-		adev->gmc.xgmi.node_segment_size = REG_GET_FIELD(
-			RREG32_SOC15(GC, 0, mmMC_VM_XGMI_LFB_SIZE),
-			MC_VM_XGMI_LFB_SIZE, PF_LFB_SIZE) << 24;
+		return -EINVAL;
+
+		adev->gmc.xgmi.node_segment_size = seg_size;
 	}
 
 	return 0;
-- 
2.25.1

