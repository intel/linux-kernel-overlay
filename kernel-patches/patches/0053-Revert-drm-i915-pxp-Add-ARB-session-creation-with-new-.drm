From c01dc99f4f1903234c63fb01a5f6f218f663729d Mon Sep 17 00:00:00 2001
From: Junxiao Chang <junxiao.chang@intel.com>
Date: Thu, 6 Jul 2023 15:03:02 +0800
Subject: [PATCH 0053/2351] Revert "drm/i915/pxp: Add ARB session creation with
 new PXP API Ver4.3"

This reverts commit 2bd2005af9ac7e9cb9deefad31ba139bd10466e4.
---
 drivers/gpu/drm/i915/pxp/intel_pxp.c          |  9 +---
 .../drm/i915/pxp/intel_pxp_cmd_interface_43.h | 21 --------
 drivers/gpu/drm/i915/pxp/intel_pxp_gsccs.c    | 54 +------------------
 drivers/gpu/drm/i915/pxp/intel_pxp_gsccs.h    |  2 -
 drivers/gpu/drm/i915/pxp/intel_pxp_session.c  |  6 +--
 5 files changed, 5 insertions(+), 87 deletions(-)

diff --git a/drivers/gpu/drm/i915/pxp/intel_pxp.c b/drivers/gpu/drm/i915/pxp/intel_pxp.c
index 2f54eb3201a15..9f83f09cc69a5 100644
--- a/drivers/gpu/drm/i915/pxp/intel_pxp.c
+++ b/drivers/gpu/drm/i915/pxp/intel_pxp.c
@@ -351,13 +351,8 @@ int intel_pxp_start(struct intel_pxp *pxp)
 	if (!intel_pxp_is_enabled(pxp))
 		return -ENODEV;
 
-	if (HAS_ENGINE(pxp->ctrl_gt, GSC0)) {
-		if (wait_for(intel_uc_fw_is_running(&pxp->ctrl_gt->uc.gsc.fw), 250))
-			return -ENXIO;
-	} else {
-		if (wait_for(pxp_component_bound(pxp), 250))
-			return -ENXIO;
-	}
+	if (wait_for(pxp_component_bound(pxp), 250))
+		return -ENXIO;
 
 	mutex_lock(&pxp->arb_mutex);
 
diff --git a/drivers/gpu/drm/i915/pxp/intel_pxp_cmd_interface_43.h b/drivers/gpu/drm/i915/pxp/intel_pxp_cmd_interface_43.h
index 9089e02a8c2d6..b2523d6918c77 100644
--- a/drivers/gpu/drm/i915/pxp/intel_pxp_cmd_interface_43.h
+++ b/drivers/gpu/drm/i915/pxp/intel_pxp_cmd_interface_43.h
@@ -11,7 +11,6 @@
 
 /* PXP-Cmd-Op definitions */
 #define PXP43_CMDID_START_HUC_AUTH 0x0000003A
-#define PXP43_CMDID_INIT_SESSION 0x00000036
 
 /* PXP-Packet sizes for MTL's GSCCS-HECI instruction */
 #define PXP43_MAX_HECI_IN_SIZE (SZ_32K)
@@ -28,24 +27,4 @@ struct pxp43_start_huc_auth_out {
 	struct pxp_cmd_header header;
 } __packed;
 
-/* PXP-Input-Packet: Init PXP session */
-struct pxp43_create_arb_in {
-	struct pxp_cmd_header header;
-		/* header.stream_id fields for vesion 4.3 of Init PXP session: */
-		#define PXP43_INIT_SESSION_VALID BIT(0)
-		#define PXP43_INIT_SESSION_APPTYPE BIT(1)
-		#define PXP43_INIT_SESSION_APPID GENMASK(17, 2)
-	u32 protection_mode;
-		#define PXP43_INIT_SESSION_PROTECTION_ARB 0x2
-	u32 sub_session_id;
-	u32 init_flags;
-	u32 rsvd[12];
-} __packed;
-
-/* PXP-Input-Packet: Init PXP session */
-struct pxp43_create_arb_out {
-	struct pxp_cmd_header header;
-	u32 rsvd[8];
-} __packed;
-
 #endif /* __INTEL_PXP_FW_INTERFACE_43_H__ */
diff --git a/drivers/gpu/drm/i915/pxp/intel_pxp_gsccs.c b/drivers/gpu/drm/i915/pxp/intel_pxp_gsccs.c
index 066df4fc001ff..35b6bfa55dfcc 100644
--- a/drivers/gpu/drm/i915/pxp/intel_pxp_gsccs.c
+++ b/drivers/gpu/drm/i915/pxp/intel_pxp_gsccs.c
@@ -13,11 +13,11 @@
 #include "intel_pxp_gsccs.h"
 #include "intel_pxp_types.h"
 
+__maybe_unused
 static int gsccs_send_message(struct intel_pxp *pxp,
 			      void *msg_in, size_t msg_in_size,
 			      void *msg_out, size_t msg_out_size_max,
-			      size_t *msg_out_len,
-			      u64 *gsc_msg_handle_retry)
+			      size_t *msg_out_len)
 {
 	struct intel_gt *gt = pxp->ctrl_gt;
 	struct drm_i915_private *i915 = gt->i915;
@@ -46,9 +46,6 @@ static int gsccs_send_message(struct intel_pxp *pxp,
 					      msg_in_size + sizeof(*header),
 					      exec->host_session_handle);
 
-	/* copy caller provided gsc message handle if this is polling for a prior msg completion */
-	header->gsc_message_handle = *gsc_msg_handle_retry;
-
 	memcpy(exec->pkt_vaddr + sizeof(*header), msg_in, msg_in_size);
 
 	pkt.addr_in = i915_vma_offset(exec->pkt_vma);
@@ -82,13 +79,6 @@ static int gsccs_send_message(struct intel_pxp *pxp,
 	}
 	if (header->flags & GSC_HECI_FLAG_MSG_PENDING) {
 		drm_dbg(&i915->drm, "gsc PXP reply is busy\n");
-		/*
-		 * When the GSC firmware replies with pending bit, it means that the requested
-		 * operation has begun but the completion is pending and the caller needs
-		 * to re-request with the gsc_message_handle that was returned by the firmware.
-		 * until the pending bit is turned off.
-		 */
-		*gsc_msg_handle_retry = header->gsc_message_handle;
 		ret = -EAGAIN;
 		goto unlock;
 	}
@@ -113,46 +103,6 @@ static int gsccs_send_message(struct intel_pxp *pxp,
 	return ret;
 }
 
-int intel_pxp_gsccs_create_session(struct intel_pxp *pxp,
-				   int arb_session_id)
-{
-	struct gsccs_session_resources *exec =  &pxp->gsccs_res;
-	struct pxp43_create_arb_in msg_in = {0};
-	struct pxp43_create_arb_out msg_out = {0};
-	u64 gsc_session_retry = 0;
-	int ret, tries = 0;
-
-	/* get a unique host-session-handle (used later in HW cmds) at time of session creation */
-	get_random_bytes(&exec->host_session_handle, sizeof(exec->host_session_handle));
-
-	msg_in.header.api_version = PXP_APIVER(4, 3);
-	msg_in.header.command_id = PXP43_CMDID_INIT_SESSION;
-	msg_in.header.stream_id = (FIELD_PREP(PXP43_INIT_SESSION_APPID, arb_session_id) |
-				   FIELD_PREP(PXP43_INIT_SESSION_VALID, 1) |
-				   FIELD_PREP(PXP43_INIT_SESSION_APPTYPE, 0));
-	msg_in.header.buffer_len = sizeof(msg_in) - sizeof(msg_in.header);
-	msg_in.protection_mode = PXP43_INIT_SESSION_PROTECTION_ARB;
-
-	/*
-	 * Keep sending request if GSC firmware was busy.
-	 * Based on specs, we can expects a worst case pending-bit
-	 * delay of 2000 milisecs.
-	 */
-	do {
-		ret = gsccs_send_message(pxp,
-					 &msg_in, sizeof(msg_in),
-					 &msg_out, sizeof(msg_out), NULL,
-					 &gsc_session_retry);
-		/* Only try again if gsc says so */
-		if (ret != -EAGAIN)
-			break;
-
-		msleep(20);
-	} while (++tries < 100);
-
-	return ret;
-}
-
 static int
 gsccs_create_buffer(struct intel_gt *gt,
 		    const char *bufname, size_t size,
diff --git a/drivers/gpu/drm/i915/pxp/intel_pxp_gsccs.h b/drivers/gpu/drm/i915/pxp/intel_pxp_gsccs.h
index 4a381ede00f53..354ea9a8f9403 100644
--- a/drivers/gpu/drm/i915/pxp/intel_pxp_gsccs.h
+++ b/drivers/gpu/drm/i915/pxp/intel_pxp_gsccs.h
@@ -11,8 +11,6 @@
 struct intel_pxp;
 
 #ifdef CONFIG_DRM_I915_PXP
-int intel_pxp_gsccs_create_session(struct intel_pxp *pxp,
-				   int arb_session_id);
 void intel_pxp_gsccs_fini(struct intel_pxp *pxp);
 int intel_pxp_gsccs_init(struct intel_pxp *pxp);
 
diff --git a/drivers/gpu/drm/i915/pxp/intel_pxp_session.c b/drivers/gpu/drm/i915/pxp/intel_pxp_session.c
index 07f5f563d3e62..b8fa6df7141b6 100644
--- a/drivers/gpu/drm/i915/pxp/intel_pxp_session.c
+++ b/drivers/gpu/drm/i915/pxp/intel_pxp_session.c
@@ -7,7 +7,6 @@
 
 #include "intel_pxp.h"
 #include "intel_pxp_cmd.h"
-#include "intel_pxp_gsccs.h"
 #include "intel_pxp_session.h"
 #include "intel_pxp_tee.h"
 #include "intel_pxp_types.h"
@@ -63,10 +62,7 @@ static int pxp_create_arb_session(struct intel_pxp *pxp)
 		return -EEXIST;
 	}
 
-	if (HAS_ENGINE(pxp->ctrl_gt, GSC0))
-		ret = intel_pxp_gsccs_create_session(pxp, ARB_SESSION);
-	else
-		ret = intel_pxp_tee_cmd_create_arb_session(pxp, ARB_SESSION);
+	ret = intel_pxp_tee_cmd_create_arb_session(pxp, ARB_SESSION);
 	if (ret) {
 		drm_err(&gt->i915->drm, "tee cmd for arb session creation failed\n");
 		return ret;
-- 
2.25.1

