From 42f4aa2f6714b273bf84a8c8dc3986631795034b Mon Sep 17 00:00:00 2001
From: Chen Meng J <meng.j.chen@intel.com>
Date: Wed, 12 Jul 2023 14:20:54 +0800
Subject: [PATCH 31/43] media: acpi: Add ipu6-acpi identifier into logs

add more logs for easier debugging

Signed-off-by: Ng Khai Wen <khai.wen.ng@intel.com>
Signed-off-by: zouxiaoh <xiaohong.zou@intel.com>
Signed-off-by: Chen Meng J <meng.j.chen@intel.com>
---
 .../media/platform/intel/ipu6-acpi-common.c   | 70 +++++++++++--------
 .../media/platform/intel/ipu6-acpi-pdata.c    | 29 +++++---
 drivers/media/platform/intel/ipu6-acpi.c      |  9 ++-
 3 files changed, 63 insertions(+), 45 deletions(-)

diff --git a/drivers/media/platform/intel/ipu6-acpi-common.c b/drivers/media/platform/intel/ipu6-acpi-common.c
index dd17d4e29d40..6869675b2db3 100644
--- a/drivers/media/platform/intel/ipu6-acpi-common.c
+++ b/drivers/media/platform/intel/ipu6-acpi-common.c
@@ -25,10 +25,9 @@ static int get_integer_dsdt_data(struct device *dev, const u8 *dsdt,
 
 	obj = acpi_evaluate_dsm(dev_handle, (void *)dsdt, 0, func, NULL);
 	if (!obj) {
-		dev_err(dev, "No dsdt\n");
+		pr_err("IPU6 ACPI: Could not find corresponding DSM\n");
 		return -ENODEV;
 	}
-	dev_dbg(dev, "ACPI type %d", obj->type);
 
 	if (obj->type != ACPI_TYPE_INTEGER) {
 		ACPI_FREE(obj);
@@ -48,18 +47,20 @@ static int read_acpi_block(struct device *dev, char *id, void *data, u32 size)
 	u32 buffer_length;
 
 	status = acpi_evaluate_object(dev_handle, id, NULL, &buffer);
-	if (!ACPI_SUCCESS(status))
+	if (!ACPI_SUCCESS(status)) {
+		pr_err("IPU6 ACPI: Could not find ACPI block");
 		return -ENODEV;
+	}
 
 	obj = (union acpi_object *)buffer.pointer;
 	if (!obj || obj->type != ACPI_TYPE_BUFFER) {
-		dev_err(dev, "Could't read acpi buffer\n");
+		pr_err("IPU6 ACPI: Could not read ACPI buffer\n");
 		status = -ENODEV;
 		goto err;
 	}
 
 	if (obj->buffer.length > size) {
-		dev_err(dev, "Given buffer is too small\n");
+		pr_err("IPU6 ACPI: Given buffer is too small\n");
 		status = -ENODEV;
 		goto err;
 	}
@@ -83,15 +84,16 @@ int ipu_acpi_get_gpio_data(struct device *dev, struct ipu_gpio_info *gpio, int s
 
 	int i = 0, j = 0, retries = 0, loop = 0;
 	u64 num_gpio;
+	int rval;
 
-	int rval = get_integer_dsdt_data(dev, dsdt_cam_gpio, 1, &num_gpio);
+	rval = get_integer_dsdt_data(dev, dsdt_cam_gpio, 1, &num_gpio);
 
 	if (rval < 0) {
-		dev_err(dev, "Failed to get number of GPIO pins\n");
+		pr_err("IPU6 ACPI: Failed to get number of GPIO pins\n");
 		return rval;
 	}
 
-	dev_dbg(dev, "Num of gpio found = %lld", num_gpio);
+	pr_info("IPU6 APCI: Num of gpio found = %lld", num_gpio);
 
 	if (num_gpio == 0) {
 		*gpio_num = num_gpio;
@@ -99,7 +101,7 @@ int ipu_acpi_get_gpio_data(struct device *dev, struct ipu_gpio_info *gpio, int s
 	}
 
 	if (num_gpio > size) {
-		dev_err(dev, "Incorrect number of GPIO pins\n");
+		pr_err("IPU6 ACPI: Incorrect number of GPIO pins\n");
 		return rval;
 	}
 
@@ -111,7 +113,7 @@ int ipu_acpi_get_gpio_data(struct device *dev, struct ipu_gpio_info *gpio, int s
 		rval = get_integer_dsdt_data(dev, dsdt_cam_gpio, i + 2, &data);
 
 		if (rval < 0) {
-			dev_err(dev, "No gpio data\n");
+			pr_err("IPU6 ACPI: Failed to get GPIO data\n");
 			return -ENODEV;
 		}
 
@@ -143,6 +145,7 @@ int ipu_acpi_get_gpio_data(struct device *dev, struct ipu_gpio_info *gpio, int s
 
 			/* save into array */
 			if (save == TRUE) {
+				pr_info("IPU6 ACPI: DSM: Pin number = %lld. Func = %x.", pin, gpio[i].func);
 				gpio[i].pin = pin;
 				gpio[i].valid = TRUE;
 				gpiod_put(desc);
@@ -165,10 +168,12 @@ int ipu_acpi_get_i2c_info(struct device *dev, struct ipu_i2c_info *i2c, int size
 
 	u64 num_i2c;
 	int i;
-	int rval = get_integer_dsdt_data(dev, dsdt_cam_i2c, 1, &num_i2c);
+	int rval;
+
+	rval = get_integer_dsdt_data(dev, dsdt_cam_i2c, 1, &num_i2c);
 
 	if (rval < 0) {
-		dev_err(dev, "Failed to get number of I2C\n");
+		pr_err("IPU6 ACPI: Failed to get number of I2C\n");
 		return -ENODEV;
 	}
 
@@ -179,14 +184,14 @@ int ipu_acpi_get_i2c_info(struct device *dev, struct ipu_i2c_info *i2c, int size
 					     &data);
 
 		if (rval < 0) {
-			dev_err(dev, "Failed to get I2C data\n");
+			pr_err("IPU6 ACPI: Failed to get I2C data\n");
 			return -ENODEV;
 		}
 
 		i2c[i].bus = ((data >> 24) & 0xff);
 		i2c[i].addr = (data >> 8) & 0xff;
 
-		dev_dbg(dev, "ACPI camera option: i2c bus %d addr %x",
+		pr_info("IPU6 ACPI: DSM: i2c bus %d addr %x",
 			i2c[i].bus, i2c[i].addr);
 	}
 
@@ -205,11 +210,13 @@ int ipu_acpi_get_control_logic_data(struct device *dev,
 {
 	/* CLDB data */
 	struct control_logic_data_packed ctl_logic_data;
-	int ret = read_acpi_block(dev, "CLDB", &ctl_logic_data,
+	int ret;
+
+	ret = read_acpi_block(dev, "CLDB", &ctl_logic_data,
 				sizeof(ctl_logic_data));
 
 	if (ret < 0) {
-		dev_err(dev, "no such CLDB block");
+		pr_err("IPU6 ACPI: Fail to read from CLDB");
 		return ret;
 	}
 
@@ -217,7 +224,7 @@ int ipu_acpi_get_control_logic_data(struct device *dev,
 	(*ctl_data)->id = ctl_logic_data.controllogicid;
 	(*ctl_data)->sku = ctl_logic_data.sensorcardsku;
 
-	dev_dbg(dev, "CLDB data version %d clid %d cltype %d sku %d",
+	pr_info("IPU6 ACPI: CLDB: version %d clid %d cltype %d sku %d",
 		ctl_logic_data.version,
 		ctl_logic_data.controllogicid,
 		ctl_logic_data.controllogictype,
@@ -246,7 +253,7 @@ int ipu_acpi_get_dep_data(struct device *dev,
 	ctl_data->completed = false;
 
 	if (!acpi_has_method(dev_handle, "_DEP")) {
-		dev_err(dev, "ACPI does not have _DEP method");
+		pr_err("IPU6 ACPI: %s does not have _DEP method", dev_name(dev));
 		return 0;
 	}
 
@@ -254,7 +261,7 @@ int ipu_acpi_get_dep_data(struct device *dev,
 					 &dep_devices);
 
 	if (ACPI_FAILURE(status)) {
-		dev_err(dev, "Failed to evaluate _DEP.\n");
+		pr_err("IPU6 ACPI: %s failed to evaluate _DEP", dev_name(dev));
 		return -ENODEV;
 	}
 
@@ -266,7 +273,7 @@ int ipu_acpi_get_dep_data(struct device *dev,
 
 		status = acpi_get_object_info(dep_devices.handles[i], &info);
 		if (ACPI_FAILURE(status)) {
-			dev_err(dev, "Error reading _DEP device info\n");
+			pr_err("IPU6 ACPI: %s error reading _DEP device info", dev_name(dev));
 			continue;
 		}
 
@@ -281,36 +288,36 @@ int ipu_acpi_get_dep_data(struct device *dev,
 		/* Process device IN3472 created by acpi */
 		device = acpi_fetch_acpi_dev(dep_devices.handles[i]);
 		if (!device) {
-			dev_err(dev, "INT3472 does not have dep device");
+			pr_err("IPU6 ACPI: Failed to get ACPI device");
 			return -ENODEV;
 		}
 
-		dev_dbg(dev, "Depend ACPI device found: %s\n",
+		pr_info("IPU6 ACPI: Dependent ACPI device found: %s\n",
 			dev_name(&device->dev));
 
 		p_dev = bus_find_device(&platform_bus_type, NULL,
 					&device->fwnode, match_depend);
 
 		if (p_dev) {
-			dev_err(dev, "Dependent platform device found %s\n",
+			pr_info("IPU6 ACPI: Dependent platform device found %s\n",
 				dev_name(p_dev));
 
 			/* obtain Control Logic Data from BIOS */
 			rval = ipu_acpi_get_control_logic_data(p_dev, &ctl_data);
 
 			if (rval) {
-				dev_err(dev, "Error getting Control Logic Data");
+				pr_err("IPU6 ACPI: Error getting Control Logic Data");
 				return rval;
 			}
 
 			ctl_data->completed = true;
 		} else
-			dev_err(dev, "Dependent platform device not found\n");
+			pr_err("IPU6 ACPI: Dependent platform device not found for %s\n", dev_name(dev));
 	}
 
 	if (!ctl_data->completed) {
 		ctl_data->type = CL_EMPTY;
-		dev_err(dev, "No control logic data available");
+		pr_err("IPU6 APCI: No control logic data available");
 	}
 
 	return 0;
@@ -322,12 +329,13 @@ int ipu_acpi_get_cam_data(struct device *dev,
 {
 	/* SSDB */
 	struct sensor_bios_data_packed sensor_data;
+	int ret;
 
-	int ret = read_acpi_block(dev, "SSDB", &sensor_data,
+	ret = read_acpi_block(dev, "SSDB", &sensor_data,
 				  sizeof(sensor_data));
 
 	if (ret < 0) {
-		dev_err(dev, "Fail to read from SSDB");
+		pr_err("IPU6 ACPI: Fail to read from SSDB");
 		return ret;
 	}
 
@@ -337,14 +345,16 @@ int ipu_acpi_get_cam_data(struct device *dev,
 	sensor->pprval = sensor_data.pprval;
 	sensor->pprunit = sensor_data.pprunit;
 
-	dev_dbg(dev, "sensor ACPI data: name %s link %d, lanes %d pprval %d pprunit %x",
+	pr_info("IPU6 ACPI: SSDB: name %s. link %d. lanes %d. pprval %d. pprunit %x",
 		dev_name(dev), sensor->link, sensor->lanes, sensor->pprval, sensor->pprunit);
 
 	/* I2C */
 	ret = ipu_acpi_get_i2c_info(dev, sensor->i2c, ARRAY_SIZE(sensor->i2c), &sensor->i2c_num);
 
-	if (ret < 0)
+	if (ret < 0) {
+		pr_err("IPU6 ACPI: Failed to get I2C info");
 		return ret;
+	}
 
 	return 0;
 }
diff --git a/drivers/media/platform/intel/ipu6-acpi-pdata.c b/drivers/media/platform/intel/ipu6-acpi-pdata.c
index d2beeb22f80c..515d27ec518c 100644
--- a/drivers/media/platform/intel/ipu6-acpi-pdata.c
+++ b/drivers/media/platform/intel/ipu6-acpi-pdata.c
@@ -90,7 +90,7 @@ void print_serdes_subdev(struct ipu_isys_subdev_info *sd)
 		return;
 	}
 
-	pr_debug("IPU6 ACPI %s", __func__);
+	pr_debug("IPU6 ACPI: %s", __func__);
 	pr_debug("sd_csi2");
 	pr_debug("\t\tnlanes \t\t\t= %d", sd->csi2->nlanes);
 	pr_debug("\t\tport \t\t\t= %d", sd->csi2->port);
@@ -124,11 +124,11 @@ void print_subdev(struct ipu_isys_subdev_info *sd)
 	int i;
 
 	if (!spdata) {
-		pr_err("Empty sensor subdev");
+		pr_err("IPU6 ACPI: Empty sensor subdev");
 		return;
 	}
 
-	pr_debug("IPU6 ACPI %s", __func__);
+	pr_debug("IPU6 ACPI: %s", __func__);
 	pr_debug("sd->csi2");
 	pr_debug("\t\tnlanes \t\t\t= %d", sd->csi2->nlanes);
 	pr_debug("\t\tport \t\t\t= %d", sd->csi2->port);
@@ -444,10 +444,10 @@ void update_pdata(struct device *dev,
 		/* does not have existing pdata */
 		/* print new subdev */
 		if (connect == TYPE_DIRECT) {
-			dev_dbg(dev, "New sensor subdev\n");
+			pr_debug("New sensor subdev\n");
 			print_subdev(acpi_subdev);
 		} else {
-			dev_dbg(dev, "New serdes subdev\n");
+			pr_debug("New serdes subdev\n");
 			print_serdes_subdev(acpi_subdev);
 		}
 	}
@@ -641,6 +641,8 @@ int set_pdata(struct ipu_isys_subdev_info **sensor_sd,
 		pdata = kzalloc(sizeof(*pdata), GFP_KERNEL);
 		if (!pdata)
 			return -ENOMEM;
+
+		pr_debug("IPU6 ACPI: %s - Direct connection", __func__);
 		/* use ascii */
 		/* port for start from 0 */
 		if (port >= 0)
@@ -666,13 +668,15 @@ int set_pdata(struct ipu_isys_subdev_info **sensor_sd,
 		if (!pdata)
 			return -ENOMEM;
 
+		pr_debug("IPU6 ACPI: %s - Serdes connection", __func__);
+
 		/* use ascii */
 		if (!strcmp(sensor_name, D457_NAME) && port >= 0)
 			pdata->suffix = serdes_info.deser_num + SUFFIX_BASE + 1;
 		else if (port > 0)
 			pdata->suffix = port + SUFFIX_BASE;
 		else
-			dev_err(dev, "INVALID MIPI PORT");
+			pr_err("IPU6 ACPI: Invalid MIPI Port : %d", port);
 
 		if (!strcmp(sensor_name, IMX390_NAME))
 			set_ti960_gpio(ctl_data, &pdata);
@@ -723,6 +727,8 @@ int populate_dummy(struct device *dev,
 	unsigned short addr_dummy = 0x11;
 	int ret;
 
+	pr_debug("IPU6 ACPI: %s", __func__);
+
 	dummy = kzalloc(sizeof(*dummy), GFP_KERNEL);
 	if (!dummy)
 		return -ENOMEM;
@@ -765,9 +771,11 @@ int populate_sensor_pdata(struct device *dev,
 
 		/* sensor i2c info */
 		if (cam_data->i2c_num == MIN_SENSOR_I2C) {
+			pr_debug("IPU6 ACPI: num of I2C device for Direct connection: %lld is Correct.",
+				cam_data->i2c_num);
 			set_i2c(sensor_sd, dev, sensor_name, cam_data->i2c[0].addr);
 		} else {
-			dev_err(dev, "IPU6 ACPI: Incorrect number of I2C device for sensor (%lld)",
+			pr_err("IPU6 ACPI: num of I2C device for Direct connection : %lld is Incorrect",
 				cam_data->i2c_num);
 			return -1;
 		}
@@ -780,17 +788,18 @@ int populate_sensor_pdata(struct device *dev,
 
 		/* Use DISCRETE Control Logic or No Control Logic for serdes */
 		if (ctl_data->type != CL_DISCRETE && ctl_data->type != CL_EMPTY) {
-			dev_err(dev, "IPU6 ACPI: Incorrect Control Logic Type for serdes (%d)",
+			pr_err("IPU6 ACPI: Control Logic Type for serdes: %d is Incorrect",
 				ctl_data->type);
 			return -1;
 		}
 
 		/* serdes i2c info */
 		if (cam_data->i2c_num == MIN_SERDES_I2C) {
-			dev_info(dev, "IPU6 ACPI: Detected minimum number of i2c device for serdes");
+			pr_debug("IPU6 ACPI: num of I2C device for Serdes connection: %lld is Correct",
+				cam_data->i2c_num);
 			set_i2c(sensor_sd, dev, serdes_name, cam_data->i2c[0].addr);
 		} else {
-			dev_err(dev, "IPU6 ACPI: Incorrect number of I2C device for serdes (%lld)",
+			pr_err("IPU6 ACPI: num of I2C device for Serdes connection: %lld is Incorrect",
 				cam_data->i2c_num);
 			return -1;
 		}
diff --git a/drivers/media/platform/intel/ipu6-acpi.c b/drivers/media/platform/intel/ipu6-acpi.c
index 695855b2e135..58355758a505 100644
--- a/drivers/media/platform/intel/ipu6-acpi.c
+++ b/drivers/media/platform/intel/ipu6-acpi.c
@@ -100,8 +100,7 @@ static int ipu_acpi_get_pdata(struct i2c_client *client,
 	int index = get_table_index(&client->dev, acpi_id->id);
 
 	if (index < 0) {
-		dev_err(&client->dev,
-			"Device is not in supported devices list\n");
+		pr_err("Device is not in supported devices list\n");
 		return -ENODEV;
 	}
 
@@ -112,7 +111,7 @@ static int ipu_acpi_get_pdata(struct i2c_client *client,
 	strlcpy(client->name, supported_devices[index].real_driver,
 		sizeof(client->name));
 
-	dev_info(&client->dev, "Getting BIOS data for %s", client->name);
+	pr_info("IPU6 ACPI: Getting BIOS data for %s (%s)", client->name, dev_name(&client->dev));
 
 	supported_devices[index].get_platform_data(
 		client, camdata, helper,
@@ -139,7 +138,7 @@ static int ipu_i2c_test(struct device *dev, void *priv)
 
 	acpi_id = acpi_match_device(ipu_acpi_match, dev);
 	if (!acpi_id) {
-		dev_err(dev, "acpi id not found, return 0");
+		pr_err("IPU6 ACPI: ACPI device NOT supported in IPU6 ACPI driver");
 		return 0;
 	}
 
@@ -152,7 +151,7 @@ static int ipu_i2c_test(struct device *dev, void *priv)
 
 	/* Looks that we got what we are looking for */
 	if (ipu_acpi_get_pdata(client, acpi_id, priv))
-		dev_err(dev, "Failed to process ACPI data");
+		pr_err("IPU6 ACPI: Failed to process ACPI data");
 
 	/* Don't return error since we want to process remaining devices */
 
-- 
2.25.1

