From 820392887f29e354b3faf95da6ef8490da8beb3e Mon Sep 17 00:00:00 2001
From: Muhammad Husaini Zulkifli <muhammad.husaini.zulkifli@intel.com>
Date: Fri, 28 Oct 2022 12:45:16 +0800
Subject: [PATCH 29/47] taprio: Add bitmask checking based on the traffic class

Random bitmask value of preempt may be entered by the user.
Current code does not check whether the bitmask value is support
or not based on the traffic class.

This patch add the check to see if bitmask value enter by user is
greater than traffic class or vice versa before final conversion of
preempt bitmask from traffic class to queues.

Signed-off-by: Muhammad Husaini Zulkifli <muhammad.husaini.zulkifli@intel.com>
---
 net/sched/sch_taprio.c | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/net/sched/sch_taprio.c b/net/sched/sch_taprio.c
index 76fff56789e8..97fd8e22f6ef 100644
--- a/net/sched/sch_taprio.c
+++ b/net/sched/sch_taprio.c
@@ -1935,6 +1935,7 @@ static int taprio_change(struct Qdisc *sch, struct nlattr *opt,
 		u32 preempt = nla_get_u32(tb[TCA_TAPRIO_ATTR_PREEMPT_TCS]);
 		struct tc_preempt_qopt_offload qopt = { };
 		u32 all_tcs_mask = GENMASK(dev->num_tc, 0);
+		int bitmask = (int)__ilog2_u32(preempt);
 
 		if ((preempt & all_tcs_mask) == all_tcs_mask) {
 			NL_SET_ERR_MSG(extack, "At least one queue must be not be preemptible");
@@ -1942,6 +1943,12 @@ static int taprio_change(struct Qdisc *sch, struct nlattr *opt,
 			goto free_sched;
 		}
 
+		if (bitmask > dev->num_tc) {
+			NL_SET_ERR_MSG(extack, "Bitmask set must not greater than traffic class");
+			err = -EOPNOTSUPP;
+			goto free_sched;
+		}
+
 		qopt.preemptible_queues = netdev_tc_map_to_queue_mask(dev, preempt);
 
 		err = dev->netdev_ops->ndo_setup_tc(dev, TC_SETUP_PREEMPT,
-- 
2.25.1

