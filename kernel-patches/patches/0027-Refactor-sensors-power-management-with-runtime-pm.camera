From 17d6353369a73125f2e6b281cb9663e5bf9552d7 Mon Sep 17 00:00:00 2001
From: Chen Meng J <meng.j.chen@intel.com>
Date: Wed, 12 Jul 2023 14:20:48 +0800
Subject: [PATCH 27/43] Refactor sensors power management with runtime pm

Signed-off-by: Hao Yao <hao.yao@intel.com>
Signed-off-by: Chen Meng J <meng.j.chen@intel.com>
---
 drivers/media/i2c/hm11b1.c  | 119 ++++++++++++++-----------
 drivers/media/i2c/ov01a10.c |   8 +-
 drivers/media/i2c/ov01a1s.c | 170 ++++++++++++++++++++++++------------
 drivers/media/i2c/ov02c10.c |   9 +-
 4 files changed, 193 insertions(+), 113 deletions(-)

diff --git a/drivers/media/i2c/hm11b1.c b/drivers/media/i2c/hm11b1.c
index 60e7ed474729..96139d931592 100644
--- a/drivers/media/i2c/hm11b1.c
+++ b/drivers/media/i2c/hm11b1.c
@@ -470,8 +470,6 @@ struct hm11b1 {
 	struct gpio_desc *powerdown_gpio;
 	/* Clock provider */
 	struct clk *clk;
-	/* GPIO for privacy LED */
-	struct gpio_desc *pled_gpio;
 #endif
 
 	/* Streaming on/off */
@@ -501,24 +499,6 @@ static u64 to_pixels_per_line(u32 hts, u32 f_index)
 	return ppl;
 }
 
-static void hm11b1_set_power(struct hm11b1 *hm11b1, int on)
-{
-#if IS_ENABLED(CONFIG_INTEL_SKL_INT3472)
-	if (!(hm11b1->reset_gpio && hm11b1->powerdown_gpio))
-		return;
-	gpiod_set_value_cansleep(hm11b1->reset_gpio, on);
-	gpiod_set_value_cansleep(hm11b1->powerdown_gpio, on);
-	if (on)
-		clk_prepare_enable(hm11b1->clk);
-	else
-		clk_disable_unprepare(hm11b1->clk);
-	gpiod_set_value_cansleep(hm11b1->pled_gpio, on);
-	msleep(20);
-#elif IS_ENABLED(CONFIG_POWER_CTRL_LOGIC)
-	power_ctrl_logic_set_power(on);
-#endif
-}
-
 static int hm11b1_read_reg(struct hm11b1 *hm11b1, u16 reg, u16 len, u32 *val)
 {
 	struct i2c_client *client = hm11b1->client;
@@ -774,7 +754,6 @@ static int hm11b1_start_streaming(struct hm11b1 *hm11b1)
 	int link_freq_index;
 	int ret = 0;
 
-	hm11b1_set_power(hm11b1, 1);
 	link_freq_index = hm11b1->cur_mode->link_freq_index;
 	reg_list = &link_freq_configs[link_freq_index].reg_list;
 	ret = hm11b1_write_reg_list(hm11b1, reg_list);
@@ -809,7 +788,6 @@ static void hm11b1_stop_streaming(struct hm11b1 *hm11b1)
 	if (hm11b1_write_reg(hm11b1, HM11B1_REG_MODE_SELECT, 1,
 			     HM11B1_MODE_STANDBY))
 		dev_err(&client->dev, "failed to stop streaming");
-	hm11b1_set_power(hm11b1, 0);
 }
 
 static int hm11b1_set_stream(struct v4l2_subdev *sd, int enable)
@@ -847,6 +825,42 @@ static int hm11b1_set_stream(struct v4l2_subdev *sd, int enable)
 	return ret;
 }
 
+static int hm11b1_power_off(struct device *dev)
+{
+	struct v4l2_subdev *sd = dev_get_drvdata(dev);
+	struct hm11b1 *hm11b1 = to_hm11b1(sd);
+	int ret = 0;
+
+#if IS_ENABLED(CONFIG_INTEL_SKL_INT3472)
+	gpiod_set_value_cansleep(hm11b1->reset_gpio, 1);
+	gpiod_set_value_cansleep(hm11b1->powerdown_gpio, 1);
+	clk_disable_unprepare(hm11b1->clk);
+	msleep(20);
+#elif IS_ENABLED(CONFIG_POWER_CTRL_LOGIC)
+	ret = power_ctrl_logic_set_power(0);
+#endif
+
+	return ret;
+}
+
+static int hm11b1_power_on(struct device *dev)
+{
+	struct v4l2_subdev *sd = dev_get_drvdata(dev);
+	struct hm11b1 *hm11b1 = to_hm11b1(sd);
+	int ret = 0;
+
+#if IS_ENABLED(CONFIG_INTEL_SKL_INT3472)
+	ret = clk_prepare_enable(hm11b1->clk);
+	gpiod_set_value_cansleep(hm11b1->powerdown_gpio, 0);
+	gpiod_set_value_cansleep(hm11b1->reset_gpio, 0);
+	msleep(20);
+#elif IS_ENABLED(CONFIG_POWER_CTRL_LOGIC)
+	ret = power_ctrl_logic_set_power(1);
+#endif
+
+	return ret;
+}
+
 static int __maybe_unused hm11b1_suspend(struct device *dev)
 {
 	struct i2c_client *client = to_i2c_client(dev);
@@ -1041,33 +1055,33 @@ static void hm11b1_remove(struct i2c_client *client)
 }
 
 #if IS_ENABLED(CONFIG_INTEL_SKL_INT3472)
-static int hm11b1_parse_dt(struct hm11b1 *hm11b1)
+static int hm11b1_parse_power(struct hm11b1 *hm11b1)
 {
 	struct device *dev = &hm11b1->client->dev;
-	int ret;
-
-	hm11b1->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
-	ret = PTR_ERR_OR_ZERO(hm11b1->reset_gpio);
-	if (ret < 0) {
-		dev_err(dev, "error while getting reset gpio: %d\n", ret);
-		return ret;
+	long ret;
+
+	hm11b1->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_LOW);
+	if (IS_ERR(hm11b1->reset_gpio)) {
+		ret = PTR_ERR(hm11b1->reset_gpio);
+		dev_err(dev, "error while getting reset gpio: %ld\n", ret);
+		hm11b1->reset_gpio = NULL;
+		return (int)ret;
 	}
 
-	hm11b1->powerdown_gpio = devm_gpiod_get(dev, "powerdown", GPIOD_OUT_HIGH);
-	ret = PTR_ERR_OR_ZERO(hm11b1->powerdown_gpio);
-	if (ret < 0) {
-		dev_err(dev, "error while getting powerdown gpio: %d\n", ret);
+	hm11b1->powerdown_gpio =
+		devm_gpiod_get_optional(dev, "powerdown", GPIOD_OUT_LOW);
+	if (IS_ERR(hm11b1->powerdown_gpio)) {
+		ret = PTR_ERR(hm11b1->powerdown_gpio);
+		dev_err(dev, "error while getting powerdown gpio: %ld\n", ret);
+		hm11b1->powerdown_gpio = NULL;
 		return ret;
 	}
 
 	hm11b1->clk = devm_clk_get_optional(dev, "clk");
-	if (IS_ERR(hm11b1->clk))
-		return dev_err_probe(dev, PTR_ERR(hm11b1->clk), "getting clk\n");
-
-	hm11b1->pled_gpio = devm_gpiod_get(dev, "pled", GPIOD_OUT_HIGH);
-	ret = PTR_ERR_OR_ZERO(hm11b1->pled_gpio);
-	if (ret < 0) {
-		dev_err(dev, "error while getting pled gpio: %d\n", ret);
+	if (IS_ERR(hm11b1->clk)) {
+		ret = PTR_ERR(hm11b1->clk);
+		dev_err(dev, "error while getting clk: %ld\n", ret);
+		hm11b1->clk = NULL;
 		return ret;
 	}
 
@@ -1085,17 +1099,21 @@ static int hm11b1_probe(struct i2c_client *client)
 		return -ENOMEM;
 	hm11b1->client = client;
 
+	v4l2_i2c_subdev_init(&hm11b1->sd, client, &hm11b1_subdev_ops);
+
 #if IS_ENABLED(CONFIG_INTEL_SKL_INT3472)
-	ret = hm11b1_parse_dt(hm11b1);
-	if (ret < 0)
-		return -EPROBE_DEFER;
+	ret = hm11b1_parse_power(hm11b1);
+	if (ret)
+		return ret;
+	ret = hm11b1_power_on(&client->dev);
+	if (ret)
+		return ret;
 #elif IS_ENABLED(CONFIG_POWER_CTRL_LOGIC)
-	if (power_ctrl_logic_set_power(1))
-		return -EPROBE_DEFER;
+	ret = power_ctrl_logic_set_power(1);
+	if (ret)
+		return ret;
 #endif
-	hm11b1_set_power(hm11b1, 1);
 
-	v4l2_i2c_subdev_init(&hm11b1->sd, client, &hm11b1_subdev_ops);
 	ret = hm11b1_identify_module(hm11b1);
 	if (ret) {
 		dev_err(&client->dev, "failed to find sensor: %d", ret);
@@ -1136,7 +1154,6 @@ static int hm11b1_probe(struct i2c_client *client)
 	pm_runtime_enable(&client->dev);
 	pm_runtime_idle(&client->dev);
 
-	hm11b1_set_power(hm11b1, 0);
 	return 0;
 
 probe_error_media_entity_cleanup:
@@ -1147,12 +1164,14 @@ static int hm11b1_probe(struct i2c_client *client)
 	mutex_destroy(&hm11b1->mutex);
 
 probe_error_power_off:
-	hm11b1_set_power(hm11b1, 0);
+	hm11b1_power_off(&client->dev);
+
 	return ret;
 }
 
 static const struct dev_pm_ops hm11b1_pm_ops = {
 	SET_SYSTEM_SLEEP_PM_OPS(hm11b1_suspend, hm11b1_resume)
+	SET_RUNTIME_PM_OPS(hm11b1_power_off, hm11b1_power_on, NULL)
 };
 
 #ifdef CONFIG_ACPI
diff --git a/drivers/media/i2c/ov01a10.c b/drivers/media/i2c/ov01a10.c
index b1e2eb07852e..f14650dd3ae3 100644
--- a/drivers/media/i2c/ov01a10.c
+++ b/drivers/media/i2c/ov01a10.c
@@ -556,6 +556,7 @@ static int ov01a10_start_streaming(struct ov01a10 *ov01a10)
 	const struct ov01a10_reg_list *reg_list;
 	int link_freq_index;
 	int ret = 0;
+
 	link_freq_index = ov01a10->cur_mode->link_freq_index;
 	reg_list = &link_freq_configs[link_freq_index].reg_list;
 	ret = ov01a10_write_reg_list(ov01a10, reg_list);
@@ -826,10 +827,8 @@ static int ov01a10_probe(struct i2c_client *client)
 	int ret = 0;
 
 	ov01a10 = devm_kzalloc(&client->dev, sizeof(*ov01a10), GFP_KERNEL);
-	if (!ov01a10) {
-		ret = -ENOMEM;
-		goto probe_error_ret;
-	}
+	if (!ov01a10)
+		return -ENOMEM;
 
 	v4l2_i2c_subdev_init(&ov01a10->sd, client, &ov01a10_subdev_ops);
 
@@ -883,6 +882,7 @@ static int ov01a10_probe(struct i2c_client *client)
 	mutex_destroy(&ov01a10->mutex);
 
 probe_error_ret:
+
 	return ret;
 }
 
diff --git a/drivers/media/i2c/ov01a1s.c b/drivers/media/i2c/ov01a1s.c
index 01fdf1d15936..3318b248c6c4 100644
--- a/drivers/media/i2c/ov01a1s.c
+++ b/drivers/media/i2c/ov01a1s.c
@@ -314,12 +314,19 @@ struct ov01a1s {
 	struct gpio_desc *reset_gpio;
 	/* GPIO for powerdown */
 	struct gpio_desc *powerdown_gpio;
+	/* Power enable */
+	struct regulator *avdd;
 	/* Clock provider */
 	struct clk *clk;
-	/* GPIO for privacy LED */
-	struct gpio_desc *pled_gpio;
 #endif
 
+	enum {
+		OV01A1S_USE_DEFAULT = 0,
+#if IS_ENABLED(CONFIG_INTEL_SKL_INT3472) || IS_ENABLED(CONFIG_POWER_CTRL_LOGIC)
+		OV01A1S_USE_INT3472 = 1,
+#endif
+	} power_type;
+
 	/* Streaming on/off */
 	bool streaming;
 };
@@ -329,24 +336,6 @@ static inline struct ov01a1s *to_ov01a1s(struct v4l2_subdev *subdev)
 	return container_of(subdev, struct ov01a1s, sd);
 }
 
-static void ov01a1s_set_power(struct ov01a1s *ov01a1s, int on)
-{
-#if IS_ENABLED(CONFIG_INTEL_SKL_INT3472)
-	if (!(ov01a1s->reset_gpio && ov01a1s->powerdown_gpio))
-		return;
-	gpiod_set_value_cansleep(ov01a1s->reset_gpio, on);
-	gpiod_set_value_cansleep(ov01a1s->powerdown_gpio, on);
-	if (on)
-		clk_prepare_enable(ov01a1s->clk);
-	else
-		clk_disable_unprepare(ov01a1s->clk);
-	gpiod_set_value_cansleep(ov01a1s->pled_gpio, on);
-	msleep(20);
-#elif IS_ENABLED(CONFIG_POWER_CTRL_LOGIC)
-	power_ctrl_logic_set_power(on);
-#endif
-}
-
 static int ov01a1s_read_reg(struct ov01a1s *ov01a1s, u16 reg, u16 len, u32 *val)
 {
 	struct i2c_client *client = ov01a1s->client;
@@ -601,7 +590,7 @@ static int ov01a1s_start_streaming(struct ov01a1s *ov01a1s)
 	const struct ov01a1s_reg_list *reg_list;
 	int link_freq_index;
 	int ret = 0;
-	ov01a1s_set_power(ov01a1s, 1);
+
 	link_freq_index = ov01a1s->cur_mode->link_freq_index;
 	reg_list = &link_freq_configs[link_freq_index].reg_list;
 	ret = ov01a1s_write_reg_list(ov01a1s, reg_list);
@@ -638,7 +627,6 @@ static void ov01a1s_stop_streaming(struct ov01a1s *ov01a1s)
 				OV01A1S_MODE_STANDBY);
 	if (ret)
 		dev_err(&client->dev, "failed to stop streaming");
-	ov01a1s_set_power(ov01a1s, 0);
 }
 
 static int ov01a1s_set_stream(struct v4l2_subdev *sd, int enable)
@@ -676,6 +664,56 @@ static int ov01a1s_set_stream(struct v4l2_subdev *sd, int enable)
 	return ret;
 }
 
+static int ov01a1s_power_off(struct device *dev)
+{
+	struct v4l2_subdev *sd = dev_get_drvdata(dev);
+	struct ov01a1s *ov01a1s = to_ov01a1s(sd);
+	int ret = 0;
+
+#if IS_ENABLED(CONFIG_INTEL_SKL_INT3472)
+	if (ov01a1s->power_type == OV01A1S_USE_INT3472) {
+		gpiod_set_value_cansleep(ov01a1s->reset_gpio, 1);
+		gpiod_set_value_cansleep(ov01a1s->powerdown_gpio, 1);
+		regulator_disable(ov01a1s->avdd);
+		clk_disable_unprepare(ov01a1s->clk);
+		msleep(20);
+	}
+#elif IS_ENABLED(CONFIG_POWER_CTRL_LOGIC)
+	if (ov01a1s->power_type == OV01A1S_USE_INT3472)
+		ret = power_ctrl_logic_set_power(0);
+#endif
+
+	return ret;
+}
+
+static int ov01a1s_power_on(struct device *dev)
+{
+	struct v4l2_subdev *sd = dev_get_drvdata(dev);
+	struct ov01a1s *ov01a1s = to_ov01a1s(sd);
+	int ret = 0;
+
+#if IS_ENABLED(CONFIG_INTEL_SKL_INT3472)
+	if (ov01a1s->power_type == OV01A1S_USE_INT3472) {
+		ret = clk_prepare_enable(ov01a1s->clk);
+		if (ret)
+			return ret;
+		if (ov01a1s->avdd) {
+			ret = regulator_enable(ov01a1s->avdd);
+			if (ret)
+				return ret;
+		}
+		gpiod_set_value_cansleep(ov01a1s->powerdown_gpio, 0);
+		gpiod_set_value_cansleep(ov01a1s->reset_gpio, 0);
+		msleep(20);
+	}
+#elif IS_ENABLED(CONFIG_POWER_CTRL_LOGIC)
+	if (ov01a1s->power_type == OV01A1S_USE_INT3472)
+		ret = power_ctrl_logic_set_power(1);
+#endif
+
+	return ret;
+}
+
 static int __maybe_unused ov01a1s_suspend(struct device *dev)
 {
 	struct i2c_client *client = to_i2c_client(dev);
@@ -868,33 +906,40 @@ static void ov01a1s_remove(struct i2c_client *client)
 }
 
 #if IS_ENABLED(CONFIG_INTEL_SKL_INT3472)
-static int ov01a1s_parse_dt(struct ov01a1s *ov01a1s)
+static int ov01a1s_parse_gpio(struct ov01a1s *ov01a1s)
 {
 	struct device *dev = &ov01a1s->client->dev;
-	int ret;
 
-	ov01a1s->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
-	ret = PTR_ERR_OR_ZERO(ov01a1s->reset_gpio);
-	if (ret < 0) {
-		dev_err(dev, "error while getting reset gpio: %d\n", ret);
+	ov01a1s->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_LOW);
+	if (IS_ERR(ov01a1s->reset_gpio)) {
+		dev_warn(dev, "error while getting reset gpio: %ld\n",
+			 PTR_ERR(ov01a1s->reset_gpio));
+		ov01a1s->reset_gpio = NULL;
 		return -EPROBE_DEFER;
 	}
 
-	ov01a1s->powerdown_gpio = devm_gpiod_get(dev, "powerdown", GPIOD_OUT_HIGH);
-	ret = PTR_ERR_OR_ZERO(ov01a1s->powerdown_gpio);
-	if (ret < 0) {
-		dev_err(dev, "error while getting powerdown gpio: %d\n", ret);
+	ov01a1s->powerdown_gpio =
+		devm_gpiod_get_optional(dev, "powerdown", GPIOD_OUT_LOW);
+	if (IS_ERR(ov01a1s->powerdown_gpio)) {
+		dev_warn(dev, "error while getting powerdown gpio: %ld\n",
+			 PTR_ERR(ov01a1s->powerdown_gpio));
+		ov01a1s->powerdown_gpio = NULL;
 		return -EPROBE_DEFER;
 	}
 
-	ov01a1s->clk = devm_clk_get_optional(dev, "clk");
-	if (IS_ERR(ov01a1s->clk))
-		return dev_err_probe(dev, PTR_ERR(ov01a1s->clk), "getting clk\n");
+	ov01a1s->avdd = devm_regulator_get_optional(dev, "avdd");
+	if (IS_ERR(ov01a1s->avdd)) {
+		dev_warn(dev, "error while getting regulator avdd: %ld\n",
+			 PTR_ERR(ov01a1s->avdd));
+		ov01a1s->avdd = NULL;
+		return -EPROBE_DEFER;
+	}
 
-	ov01a1s->pled_gpio = devm_gpiod_get(dev, "pled", GPIOD_OUT_HIGH);
-	ret = PTR_ERR_OR_ZERO(ov01a1s->pled_gpio);
-	if (ret < 0) {
-		dev_err(dev, "error while getting pled gpio: %d\n", ret);
+	ov01a1s->clk = devm_clk_get_optional(dev, "clk");
+	if (IS_ERR(ov01a1s->clk)) {
+		dev_warn(dev, "error while getting clk: %ld\n",
+			 PTR_ERR(ov01a1s->clk));
+		ov01a1s->clk = NULL;
 		return -EPROBE_DEFER;
 	}
 
@@ -902,6 +947,27 @@ static int ov01a1s_parse_dt(struct ov01a1s *ov01a1s)
 }
 #endif
 
+static int ov01a1s_parse_power(struct ov01a1s *ov01a1s)
+{
+	int ret = 0;
+
+#if IS_ENABLED(CONFIG_INTEL_SKL_INT3472)
+	ret = ov01a1s_parse_gpio(ov01a1s);
+#elif IS_ENABLED(CONFIG_POWER_CTRL_LOGIC)
+	ret = power_ctrl_logic_set_power(1);
+#endif
+#if IS_ENABLED(CONFIG_INTEL_SKL_INT3472) || IS_ENABLED(CONFIG_POWER_CTRL_LOGIC)
+	if (!ret) {
+		ov01a1s->power_type = OV01A1S_USE_INT3472;
+		return 0;
+	}
+#endif
+	if (ret == -EAGAIN)
+		return -EPROBE_DEFER;
+
+	return ret;
+}
+
 static int ov01a1s_probe(struct i2c_client *client)
 {
 	struct ov01a1s *ov01a1s;
@@ -910,23 +976,18 @@ static int ov01a1s_probe(struct i2c_client *client)
 	ov01a1s = devm_kzalloc(&client->dev, sizeof(*ov01a1s), GFP_KERNEL);
 	if (!ov01a1s)
 		return -ENOMEM;
-	ov01a1s->client = client;
 
-#if IS_ENABLED(CONFIG_INTEL_SKL_INT3472)
-	if (ret == -EAGAIN)
-		ret = ov01a1s_parse_dt(ov01a1s);
-#elif IS_ENABLED(CONFIG_POWER_CTRL_LOGIC)
-	if (ret == -EAGAIN)
-		ret = power_ctrl_logic_set_power(1);
-#endif
-	if (ret == -EAGAIN)
-		return -EPROBE_DEFER;
-	else if (ret)
+	ov01a1s->client = client;
+	ret = ov01a1s_parse_power(ov01a1s);
+	if (ret)
 		return ret;
 
-	ov01a1s_set_power(ov01a1s, 1);
-
 	v4l2_i2c_subdev_init(&ov01a1s->sd, client, &ov01a1s_subdev_ops);
+#if IS_ENABLED(CONFIG_INTEL_SKL_INT3472)
+	/* In other cases, power is up in ov01a1s_parse_power */
+	if (ov01a1s->power_type == OV01A1S_USE_INT3472)
+		ov01a1s_power_on(&client->dev);
+#endif
 	ret = ov01a1s_identify_module(ov01a1s);
 	if (ret) {
 		dev_err(&client->dev, "failed to find sensor: %d", ret);
@@ -967,7 +1028,6 @@ static int ov01a1s_probe(struct i2c_client *client)
 	pm_runtime_enable(&client->dev);
 	pm_runtime_idle(&client->dev);
 
-	ov01a1s_set_power(ov01a1s, 0);
 	return 0;
 
 probe_error_media_entity_cleanup:
@@ -978,12 +1038,14 @@ static int ov01a1s_probe(struct i2c_client *client)
 	mutex_destroy(&ov01a1s->mutex);
 
 probe_error_power_off:
-	ov01a1s_set_power(ov01a1s, 0);
+	ov01a1s_power_off(&client->dev);
+
 	return ret;
 }
 
 static const struct dev_pm_ops ov01a1s_pm_ops = {
 	SET_SYSTEM_SLEEP_PM_OPS(ov01a1s_suspend, ov01a1s_resume)
+	SET_RUNTIME_PM_OPS(ov01a1s_power_off, ov01a1s_power_on, NULL)
 };
 
 #ifdef CONFIG_ACPI
diff --git a/drivers/media/i2c/ov02c10.c b/drivers/media/i2c/ov02c10.c
index c0f3990aa152..8d63394b9f45 100644
--- a/drivers/media/i2c/ov02c10.c
+++ b/drivers/media/i2c/ov02c10.c
@@ -892,6 +892,7 @@ static int ov02c10_start_streaming(struct ov02c10 *ov02c10)
 	const struct ov02c10_reg_list *reg_list;
 	int link_freq_index;
 	int ret = 0;
+
 	link_freq_index = ov02c10->cur_mode->link_freq_index;
 	reg_list = &link_freq_configs[link_freq_index].reg_list;
 	ret = ov02c10_write_reg_list(ov02c10, reg_list);
@@ -1139,7 +1140,6 @@ static void ov02c10_read_mipi_lanes(struct ov02c10 *ov02c10)
 	union acpi_object *obj;
 	acpi_status status;
 
-	ov02c10->mipi_lanes = OV02C10_DATA_LANES;
 	if (!adev) {
 		dev_info(&client->dev, "Not ACPI device\n");
 		return;
@@ -1210,10 +1210,8 @@ static int ov02c10_probe(struct i2c_client *client)
 	int ret = 0;
 
 	ov02c10 = devm_kzalloc(&client->dev, sizeof(*ov02c10), GFP_KERNEL);
-	if (!ov02c10) {
-		ret = -ENOMEM;
-		goto probe_error_ret;
-	}
+	if (!ov02c10)
+		return -ENOMEM;
 
 	v4l2_i2c_subdev_init(&ov02c10->sd, client, &ov02c10_subdev_ops);
 
@@ -1270,6 +1268,7 @@ static int ov02c10_probe(struct i2c_client *client)
 	mutex_destroy(&ov02c10->mutex);
 
 probe_error_ret:
+
 	return ret;
 }
 
-- 
2.25.1

