From 43431351aed7da79cc2e92523a54eda5bb5c30ce Mon Sep 17 00:00:00 2001
From: Chris Morgan <macromorgan@hotmail.com>
Date: Fri, 2 Sep 2022 10:39:06 -0500
Subject: [PATCH 2813/2871] drm/bridge: chrontel-ch7033: Add byteswap order
 setting

Add the option to set the byteswap order in the devicetree. For the
official HDMI DIP for the NTC CHIP the byteswap order needs to be
RGB, however the driver sets it as BGR. With this patch the driver
will remain at BGR unless manually specified via devicetree.

Signed-off-by: Chris Morgan <macromorgan@hotmail.com>
Reviewed-by: Robert Foss <robert.foss@linaro.org>
Signed-off-by: Robert Foss <robert.foss@linaro.org>
Link: https://patchwork.freedesktop.org/patch/msgid/20220902153906.31000-3-macroalpha82@gmail.com
---
 drivers/gpu/drm/bridge/chrontel-ch7033.c | 15 +++++++++++++--
 1 file changed, 13 insertions(+), 2 deletions(-)

diff --git a/drivers/gpu/drm/bridge/chrontel-ch7033.c b/drivers/gpu/drm/bridge/chrontel-ch7033.c
index 486f405c2e16..88175b7e80d4 100644
--- a/drivers/gpu/drm/bridge/chrontel-ch7033.c
+++ b/drivers/gpu/drm/bridge/chrontel-ch7033.c
@@ -67,6 +67,7 @@ enum {
 	BYTE_SWAP_GBR	= 3,
 	BYTE_SWAP_BRG	= 4,
 	BYTE_SWAP_BGR	= 5,
+	BYTE_SWAP_MAX	= 6,
 };
 
 /* Page 0, Register 0x19 */
@@ -354,6 +355,8 @@ static void ch7033_bridge_mode_set(struct drm_bridge *bridge,
 	int hsynclen = mode->hsync_end - mode->hsync_start;
 	int vbporch = mode->vsync_start - mode->vdisplay;
 	int vsynclen = mode->vsync_end - mode->vsync_start;
+	u8 byte_swap;
+	int ret;
 
 	/*
 	 * Page 4
@@ -397,8 +400,16 @@ static void ch7033_bridge_mode_set(struct drm_bridge *bridge,
 	regmap_write(priv->regmap, 0x15, vbporch);
 	regmap_write(priv->regmap, 0x16, vsynclen);
 
-	/* Input color swap. */
-	regmap_update_bits(priv->regmap, 0x18, SWAP, BYTE_SWAP_BGR);
+	/* Input color swap. Byte order is optional and will default to
+	 * BYTE_SWAP_BGR to preserve backwards compatibility with existing
+	 * driver.
+	 */
+	ret = of_property_read_u8(priv->bridge.of_node, "chrontel,byteswap",
+				  &byte_swap);
+	if (!ret && byte_swap < BYTE_SWAP_MAX)
+		regmap_update_bits(priv->regmap, 0x18, SWAP, byte_swap);
+	else
+		regmap_update_bits(priv->regmap, 0x18, SWAP, BYTE_SWAP_BGR);
 
 	/* Input clock and sync polarity. */
 	regmap_update_bits(priv->regmap, 0x19, 0x1, mode->clock >> 16);
-- 
2.25.1

