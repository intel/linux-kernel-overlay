From 502969167e7e133ddd6955513bc721ab67397825 Mon Sep 17 00:00:00 2001
From: "Stanley.Yang" <Stanley.Yang@amd.com>
Date: Wed, 26 Jan 2022 16:00:39 +0800
Subject: [PATCH 0804/2251] drm/amdgpu: print more error info

print more error info when deferred uncorrectable ras error

changed from V1:
    move Defferred error msg into query uncorrectable error
    count function.

Signed-off-by: Stanley.Yang <Stanley.Yang@amd.com>
Reviewed-by: Hawking Zhang <Hawking.Zhang@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
---
 drivers/gpu/drm/amd/amdgpu/umc_v6_7.c         | 72 ++++++++++++++++++-
 .../include/asic_reg/umc/umc_6_7_0_offset.h   |  6 ++
 2 files changed, 76 insertions(+), 2 deletions(-)

diff --git a/drivers/gpu/drm/amd/amdgpu/umc_v6_7.c b/drivers/gpu/drm/amd/amdgpu/umc_v6_7.c
index 87e4ef18e151..c45d9c14ecbc 100644
--- a/drivers/gpu/drm/amd/amdgpu/umc_v6_7.c
+++ b/drivers/gpu/drm/amd/amdgpu/umc_v6_7.c
@@ -87,8 +87,14 @@ static void umc_v6_7_ecc_info_querry_uncorrectable_error_count(struct amdgpu_dev
 {
 	uint64_t mc_umc_status;
 	uint32_t eccinfo_table_idx;
+	uint32_t umc_reg_offset;
+	uint32_t mc_umc_addr;
+	uint64_t reg_value;
 	struct amdgpu_ras *ras = amdgpu_ras_get_context(adev);
 
+	umc_reg_offset = get_umc_v6_7_reg_offset(adev,
+						umc_inst, ch_inst);
+
 	eccinfo_table_idx = umc_inst * adev->umc.channel_inst_num + ch_inst;
 	/* check the MCUMC_STATUS */
 	mc_umc_status = ras->umc_ecc.ecc[eccinfo_table_idx].mca_umc_status;
@@ -97,8 +103,36 @@ static void umc_v6_7_ecc_info_querry_uncorrectable_error_count(struct amdgpu_dev
 	    REG_GET_FIELD(mc_umc_status, MCA_UMC_UMC0_MCUMC_STATUST0, UECC) == 1 ||
 	    REG_GET_FIELD(mc_umc_status, MCA_UMC_UMC0_MCUMC_STATUST0, PCC) == 1 ||
 	    REG_GET_FIELD(mc_umc_status, MCA_UMC_UMC0_MCUMC_STATUST0, UC) == 1 ||
-	    REG_GET_FIELD(mc_umc_status, MCA_UMC_UMC0_MCUMC_STATUST0, TCC) == 1))
+	    REG_GET_FIELD(mc_umc_status, MCA_UMC_UMC0_MCUMC_STATUST0, TCC) == 1)) {
 		*error_count += 1;
+
+		if (REG_GET_FIELD(mc_umc_status, MCA_UMC_UMC0_MCUMC_STATUST0, Deferred) == 1)
+			dev_info(adev->dev, "Deferred error, no user action is needed.\n");
+
+		if (mc_umc_status)
+			dev_info(adev->dev, "MCA STATUS 0x%llx, umc_reg_offset 0x%x\n", mc_umc_status, umc_reg_offset);
+
+		/* print IPID registers value */
+		mc_umc_addr =
+			SOC15_REG_OFFSET(UMC, 0, regMCA_UMC_UMC0_MCUMC_IPIDT0);
+		reg_value = RREG64_PCIE((mc_umc_addr + umc_reg_offset) * 4);
+		if (reg_value)
+			dev_info(adev->dev, "MCA IPID 0x%llx, umc_reg_offset 0x%x\n", reg_value, umc_reg_offset);
+
+		/* print SYND registers value */
+		mc_umc_addr =
+			SOC15_REG_OFFSET(UMC, 0, regMCA_UMC_UMC0_MCUMC_SYNDT0);
+		reg_value = RREG64_PCIE((mc_umc_addr + umc_reg_offset) * 4);
+		if (reg_value)
+			dev_info(adev->dev, "MCA SYND 0x%llx, umc_reg_offset 0x%x\n", reg_value, umc_reg_offset);
+
+		/* print MISC0 registers value */
+		mc_umc_addr =
+			SOC15_REG_OFFSET(UMC, 0, regMCA_UMC_UMC0_MCUMC_MISC0T0);
+		reg_value = RREG64_PCIE((mc_umc_addr + umc_reg_offset) * 4);
+		if (reg_value)
+			dev_info(adev->dev, "MCA MISC0 0x%llx, umc_reg_offset 0x%x\n", reg_value, umc_reg_offset);
+	}
 }
 
 static void umc_v6_7_ecc_info_query_ras_error_count(struct amdgpu_device *adev,
@@ -168,11 +202,13 @@ static void umc_v6_7_ecc_info_query_error_address(struct amdgpu_device *adev,
 			/* loop for all possibilities of [C4 C3 C2] */
 			for (column = 0; column < UMC_V6_7_NA_MAP_PA_NUM; column++) {
 				retired_page = soc_pa | (column << UMC_V6_7_PA_C2_BIT);
+				dev_info(adev->dev, "Error Address(PA): 0x%llx\n", retired_page);
 				amdgpu_umc_fill_error_record(err_data, err_addr,
 					retired_page, channel_index, umc_inst);
 
 				/* shift R14 bit */
 				retired_page ^= (0x1ULL << UMC_V6_7_PA_R14_BIT);
+				dev_info(adev->dev, "Error Address(PA): 0x%llx\n", retired_page);
 				amdgpu_umc_fill_error_record(err_data, err_addr,
 					retired_page, channel_index, umc_inst);
 			}
@@ -251,6 +287,8 @@ static void umc_v6_7_querry_uncorrectable_error_count(struct amdgpu_device *adev
 {
 	uint64_t mc_umc_status;
 	uint32_t mc_umc_status_addr;
+	uint32_t mc_umc_addr;
+	uint64_t reg_value;
 
 	mc_umc_status_addr =
 		SOC15_REG_OFFSET(UMC, 0, regMCA_UMC_UMC0_MCUMC_STATUST0);
@@ -262,8 +300,36 @@ static void umc_v6_7_querry_uncorrectable_error_count(struct amdgpu_device *adev
 	    REG_GET_FIELD(mc_umc_status, MCA_UMC_UMC0_MCUMC_STATUST0, UECC) == 1 ||
 	    REG_GET_FIELD(mc_umc_status, MCA_UMC_UMC0_MCUMC_STATUST0, PCC) == 1 ||
 	    REG_GET_FIELD(mc_umc_status, MCA_UMC_UMC0_MCUMC_STATUST0, UC) == 1 ||
-	    REG_GET_FIELD(mc_umc_status, MCA_UMC_UMC0_MCUMC_STATUST0, TCC) == 1))
+	    REG_GET_FIELD(mc_umc_status, MCA_UMC_UMC0_MCUMC_STATUST0, TCC) == 1)) {
 		*error_count += 1;
+
+		if (REG_GET_FIELD(mc_umc_status, MCA_UMC_UMC0_MCUMC_STATUST0, Deferred) == 1)
+			dev_info(adev->dev, "Deferred error, no user action is needed.\n");
+
+		if (mc_umc_status)
+			dev_info(adev->dev, "MCA STATUS 0x%llx, umc_reg_offset 0x%x\n", mc_umc_status, umc_reg_offset);
+
+		/* print IPID registers value */
+		mc_umc_addr =
+			SOC15_REG_OFFSET(UMC, 0, regMCA_UMC_UMC0_MCUMC_IPIDT0);
+		reg_value = RREG64_PCIE((mc_umc_addr + umc_reg_offset) * 4);
+		if (reg_value)
+			dev_info(adev->dev, "MCA IPID 0x%llx, umc_reg_offset 0x%x\n", reg_value, umc_reg_offset);
+
+		/* print SYND registers value */
+		mc_umc_addr =
+			SOC15_REG_OFFSET(UMC, 0, regMCA_UMC_UMC0_MCUMC_SYNDT0);
+		reg_value = RREG64_PCIE((mc_umc_addr + umc_reg_offset) * 4);
+		if (reg_value)
+			dev_info(adev->dev, "MCA SYND 0x%llx, umc_reg_offset 0x%x\n", reg_value, umc_reg_offset);
+
+		/* print MISC0 registers value */
+		mc_umc_addr =
+			SOC15_REG_OFFSET(UMC, 0, regMCA_UMC_UMC0_MCUMC_MISC0T0);
+		reg_value = RREG64_PCIE((mc_umc_addr + umc_reg_offset) * 4);
+		if (reg_value)
+			dev_info(adev->dev, "MCA MISC0 0x%llx, umc_reg_offset 0x%x\n", reg_value, umc_reg_offset);
+	}
 }
 
 static void umc_v6_7_reset_error_count_per_channel(struct amdgpu_device *adev,
@@ -403,11 +469,13 @@ static void umc_v6_7_query_error_address(struct amdgpu_device *adev,
 			/* loop for all possibilities of [C4 C3 C2] */
 			for (column = 0; column < UMC_V6_7_NA_MAP_PA_NUM; column++) {
 				retired_page = soc_pa | (column << UMC_V6_7_PA_C2_BIT);
+				dev_info(adev->dev, "Error Address(PA): 0x%llx\n", retired_page);
 				amdgpu_umc_fill_error_record(err_data, err_addr,
 					retired_page, channel_index, umc_inst);
 
 				/* shift R14 bit */
 				retired_page ^= (0x1ULL << UMC_V6_7_PA_R14_BIT);
+				dev_info(adev->dev, "Error Address(PA): 0x%llx\n", retired_page);
 				amdgpu_umc_fill_error_record(err_data, err_addr,
 					retired_page, channel_index, umc_inst);
 			}
diff --git a/drivers/gpu/drm/amd/include/asic_reg/umc/umc_6_7_0_offset.h b/drivers/gpu/drm/amd/include/asic_reg/umc/umc_6_7_0_offset.h
index 912955f75b14..37d89a3f336a 100644
--- a/drivers/gpu/drm/amd/include/asic_reg/umc/umc_6_7_0_offset.h
+++ b/drivers/gpu/drm/amd/include/asic_reg/umc/umc_6_7_0_offset.h
@@ -31,6 +31,12 @@
 #define regMCA_UMC_UMC0_MCUMC_STATUST0_BASE_IDX                                                         0
 #define regMCA_UMC_UMC0_MCUMC_ADDRT0                                                                    0x03c4
 #define regMCA_UMC_UMC0_MCUMC_ADDRT0_BASE_IDX                                                           0
+#define regMCA_UMC_UMC0_MCUMC_MISC0T0                                                                   0x03c6
+#define regMCA_UMC_UMC0_MCUMC_MISC0T0_BASE_IDX                                                          0
+#define regMCA_UMC_UMC0_MCUMC_IPIDT0                                                                    0x03ca
+#define regMCA_UMC_UMC0_MCUMC_IPIDT0_BASE_IDX                                                           0
+#define regMCA_UMC_UMC0_MCUMC_SYNDT0                                                                    0x03cc
+#define regMCA_UMC_UMC0_MCUMC_SYNDT0_BASE_IDX                                                           0
 
 
 // addressBlock: umc_w_phy_umc0_umcch0_umcchdec
-- 
2.25.1

