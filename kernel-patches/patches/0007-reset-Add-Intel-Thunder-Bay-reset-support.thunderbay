From 9be43a46f6071c3e70b49cb3e1a2439ce32fce5a Mon Sep 17 00:00:00 2001
From: "MP, Sureshkumar" <sureshkumar.mp@intel.com>
Date: Tue, 18 May 2021 15:13:00 +0530
Subject: [PATCH 07/29] reset: Add Intel Thunder Bay reset support

Add reset driver support for Intel Thunder Bay SoC's
peripherals with memory mapped reset-registers.

Signed-off-by: MP, Sureshkumar <sureshkumar.mp@intel.com>
---
 MAINTAINERS                               |  13 ++
 drivers/reset/Kconfig                     |   9 ++
 drivers/reset/Makefile                    |   1 +
 drivers/reset/reset-thunderbay.c          | 164 ++++++++++++++++++++++
 include/linux/reset/reset-thunderbay-ss.h | 136 ++++++++++++++++++
 include/linux/reset/reset-thunderbay.h    |  32 +++++
 6 files changed, 355 insertions(+)
 create mode 100644 drivers/reset/reset-thunderbay.c
 create mode 100644 include/linux/reset/reset-thunderbay-ss.h
 create mode 100644 include/linux/reset/reset-thunderbay.h

diff --git a/MAINTAINERS b/MAINTAINERS
index d1032e761220..99a77fb25e4a 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -9677,6 +9677,19 @@ S:	Maintained
 F:	arch/x86/include/asm/intel_telemetry.h
 F:	drivers/platform/x86/intel/telemetry/
 
+INTEL THUNDER BAY RESET DRIVER
+M:	MP Sureshkumar <sureshkumar.mp@intel.com>
+M:	Shruthi Sanil <shruthi.sanil@intel.com>
+L:	linux-kernel@vger.kernel.org
+S:	Maintained
+F:	Documentation/devicetree/bindings/reset/intel,thunderbay-reset.yaml
+F:	drivers/reset/Kconfig
+F:	drivers/reset/Makefile
+F:	drivers/reset/reset-thunderbay.c
+F:	include/dt-bindings/reset/thunderbay-reset.h
+F:	include/linux/reset/reset-thunderbay-ss.h
+F:	include/linux/reset/reset-thunderbay.h
+
 INTEL UNCORE FREQUENCY CONTROL
 M:	Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
 L:	platform-driver-x86@vger.kernel.org
diff --git a/drivers/reset/Kconfig b/drivers/reset/Kconfig
index b0056ae5d463..1983da69c722 100644
--- a/drivers/reset/Kconfig
+++ b/drivers/reset/Kconfig
@@ -231,6 +231,15 @@ config RESET_SUNXI
 	help
 	  This enables the reset driver for Allwinner SoCs.
 
+config RESET_THUNDERBAY
+	tristate "Intel Thunder Bay SoC reset driver"
+	depends on ARCH_THUNDERBAY || COMPILE_TEST
+	help
+	  This enables the reset driver support for Intel Thunder Bay SoC
+	  peripherals with memory mapped reset-registers. If you wish to use
+	  the reset framework for such memory-mapped devices, say Y here.
+	  Otherwise, say N.
+
 config RESET_TI_SCI
 	tristate "TI System Control Interface (TI-SCI) reset driver"
 	depends on TI_SCI_PROTOCOL
diff --git a/drivers/reset/Makefile b/drivers/reset/Makefile
index 21d46d8869ff..82cfae776809 100644
--- a/drivers/reset/Makefile
+++ b/drivers/reset/Makefile
@@ -30,6 +30,7 @@ obj-$(CONFIG_RESET_SCMI) += reset-scmi.o
 obj-$(CONFIG_RESET_SIMPLE) += reset-simple.o
 obj-$(CONFIG_RESET_SOCFPGA) += reset-socfpga.o
 obj-$(CONFIG_RESET_SUNXI) += reset-sunxi.o
+obj-$(CONFIG_RESET_THUNDERBAY) += reset-thunderbay.o
 obj-$(CONFIG_RESET_TI_SCI) += reset-ti-sci.o
 obj-$(CONFIG_RESET_TI_SYSCON) += reset-ti-syscon.o
 obj-$(CONFIG_RESET_UNIPHIER) += reset-uniphier.o
diff --git a/drivers/reset/reset-thunderbay.c b/drivers/reset/reset-thunderbay.c
new file mode 100644
index 000000000000..b63daf128d9a
--- /dev/null
+++ b/drivers/reset/reset-thunderbay.c
@@ -0,0 +1,164 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Intel Thunder Bay Harbor Reset driver.
+ *
+ * Copyright (C) 2020 Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2, as published
+ * by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/reset-controller.h>
+#include <linux/reset/reset-thunderbay.h>
+
+#define get_thunderbay_reset_data(x)  container_of(x, struct thunderbay_rst, rcdev)
+
+struct thunderbay_rst {
+	struct reset_controller_dev rcdev;
+	struct device *dev;
+	void __iomem *reg_base;
+	const struct thunderbay_rst_data *rst_data;
+};
+
+/**
+ * thunderbay_control_assert() - assert device reset
+ * @rcdev: reset controller entity
+ * @id: Device reset ID to be asserted
+ *
+ * This function keeps a device under reset.
+ *
+ * Return: 0 for always.
+ */
+static int thunderbay_control_assert(struct reset_controller_dev *rcdev,
+				     unsigned long id)
+{
+	struct thunderbay_rst *data = get_thunderbay_reset_data(rcdev);
+	const struct thunderbay_rst_map *mmap = &data->rst_data->resets[id];
+
+	writel(1 << mmap->bit, data->reg_base + mmap->reg + THUNDERBAY_RESET_CLEAR_OFFSET);
+
+	return 0;
+}
+
+/**
+ * thunderbay_control_deassert() - deassert device reset
+ * @rcdev: reset controller entity
+ * @id: Device reset ID to be deasserted
+ *
+ * This function releases a device from reset.
+ *
+ * Return: 0 for always.
+ */
+static int thunderbay_control_deassert(struct reset_controller_dev *rcdev,
+				       unsigned long id)
+{
+	struct thunderbay_rst *data = get_thunderbay_reset_data(rcdev);
+	const struct thunderbay_rst_map *mmap = &data->rst_data->resets[id];
+
+	writel(1 << mmap->bit, data->reg_base + mmap->reg + THUNDERBAY_RESET_SET_OFFSET);
+
+	return 0;
+}
+
+static const struct reset_control_ops thunderbay_rst_ops = {
+	.assert = thunderbay_control_assert,
+	.deassert = thunderbay_control_deassert,
+};
+
+static int thunderbay_rst_probe(struct platform_device *pdev)
+{
+	const struct thunderbay_rst_data *data;
+	struct device *dev = &pdev->dev;
+	struct thunderbay_rst *rst;
+	int ret;
+
+	rst = devm_kzalloc(dev, sizeof(*rst), GFP_KERNEL);
+	if (!rst)
+		return -ENOMEM;
+
+	rst->reg_base = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(rst->reg_base)) {
+		dev_err(dev, "Failed to remap resource.\n");
+		return PTR_ERR(rst->reg_base);
+	}
+
+	data = of_device_get_match_data(dev);
+	if (!data) {
+		dev_err(dev, "Failed to get data.\n");
+		return -EINVAL;
+	}
+
+	rst->rcdev.owner = THIS_MODULE;
+	rst->rcdev.ops = &thunderbay_rst_ops;
+	rst->rcdev.of_node = dev->of_node;
+	rst->rcdev.nr_resets = data->n_resets;
+	rst->dev = dev;
+	rst->rst_data = data;
+
+	ret = devm_reset_controller_register(dev, &rst->rcdev);
+	if (ret) {
+		dev_err(dev, "Failed to register reset device.\n");
+		return ret;
+	}
+
+	dev_info(dev, "Reset Driver registered successfully.\n");
+
+	return 0;
+}
+
+static const struct of_device_id thunderbay_rst_match[] = {
+	{
+		.compatible = "intel,thunderbay-cpuss-rst",
+		.data = &thunderbay_cpuss_reset_data,
+	},
+	{
+		.compatible = "intel,thunderbay-pss-rst1",
+		.data = &thunderbay_pss_reset_data1,
+	},
+	{
+		.compatible = "intel,thunderbay-pss-rst2",
+		.data = &thunderbay_pss_reset_data2,
+	},
+	{
+		.compatible = "intel,thunderbay-pcie-rst",
+		.data = &thunderbay_pcie_reset_data,
+	},
+	{
+		.compatible = "intel,thunderbay-comss-rst",
+		.data = &thunderbay_comss_reset_data,
+	},
+	{
+		.compatible = "intel,thunderbay-memss-rst",
+		.data = &thunderbay_memss_reset_data,
+	},
+	{ },
+};
+
+MODULE_DEVICE_TABLE(of, thunderbay_rst_match);
+
+static struct platform_driver thunderbay_reset_driver = {
+	.probe	= thunderbay_rst_probe,
+	.driver	= {
+		.name		= "thunderbay_reset",
+		.of_match_table = thunderbay_rst_match,
+	},
+};
+
+module_platform_driver(thunderbay_reset_driver);
+
+MODULE_DESCRIPTION("Intel Thunder Bay Reset Driver");
+MODULE_AUTHOR("Shruthi Sanil <shruthi.sanil@intel.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/include/linux/reset/reset-thunderbay-ss.h b/include/linux/reset/reset-thunderbay-ss.h
new file mode 100644
index 000000000000..0cbb8f25ce50
--- /dev/null
+++ b/include/linux/reset/reset-thunderbay-ss.h
@@ -0,0 +1,136 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2020 Intel Corporation
+ */
+
+#include <dt-bindings/reset/thunderbay-reset.h>
+
+/* CPUSS reset data */
+static const struct thunderbay_rst_map thunderbay_cpuss_resets[] = {
+	[TBH_CPUSS_OCS_RST] = THUNDERBAY_RESET(0x0, 2),
+};
+
+static const struct thunderbay_rst_data thunderbay_cpuss_reset_data = {
+	.resets = thunderbay_cpuss_resets,
+	.n_resets = ARRAY_SIZE(thunderbay_cpuss_resets),
+};
+
+/* PSS reset data */
+static const struct thunderbay_rst_map thunderbay_pss_resets1[] = {
+	[TBH_PSS_EFUSE_PRSTN] = THUNDERBAY_RESET(0x0000, 0),
+	[TBH_PSS_GPIO_RST_N] = THUNDERBAY_RESET(0x1000, 0),
+	[TBH_PSS_I2C_INST_0_RST_N] = THUNDERBAY_RESET(0x9000, 0),
+	[TBH_PSS_I2C_INST_1_RST_N] = THUNDERBAY_RESET(0xA000, 0),
+	[TBH_PSS_I2C_INST_2_RST_N] = THUNDERBAY_RESET(0xB000, 0),
+	[TBH_PSS_I2C_INST_3_RST_N] = THUNDERBAY_RESET(0xC000, 0),
+	[TBH_PSS_I2C_INST_4_RST_N] = THUNDERBAY_RESET(0xD000, 0),
+	[TBH_PSS_UART_INST_0_RST_N] = THUNDERBAY_RESET(0xE000, 0),
+	[TBH_PSS_UART_INST_1_RST_N] = THUNDERBAY_RESET(0xF000, 0),
+	[TBH_PSS_EMMC_RST_N] = THUNDERBAY_RESET(0x10000, 0),
+};
+
+static const struct thunderbay_rst_data thunderbay_pss_reset_data1 = {
+	.resets = thunderbay_pss_resets1,
+	.n_resets = ARRAY_SIZE(thunderbay_pss_resets1),
+};
+
+static const struct thunderbay_rst_map thunderbay_pss_resets2[] = {
+	[TBH_PSS_SSI_INST_0_RST_N] = THUNDERBAY_RESET(0x0, 0),
+	[TBH_PSS_SSI_INST_1_RST_N] = THUNDERBAY_RESET(0x1000, 0),
+	[TBH_PSS_SMBUS_RST_N] = THUNDERBAY_RESET(0x2000, 0),
+	[TBH_PSS_DMAC_INST_0_RST_N] = THUNDERBAY_RESET(0x3000, 0),
+	[TBH_PSS_TRNG_RST_N] = THUNDERBAY_RESET(0x4000, 0),
+	[TBH_PSS_ETHERNET_INST_0_RST_N] = THUNDERBAY_RESET(0x5000, 0),
+	[TBH_PSS_ETHERNET_INST_1_RST_N] = THUNDERBAY_RESET(0x6000, 0),
+	[TBH_PSS_DMAC_SECURE_RST_N] = THUNDERBAY_RESET(0x9000, 0),
+};
+
+static const struct thunderbay_rst_data thunderbay_pss_reset_data2 = {
+	.resets = thunderbay_pss_resets2,
+	.n_resets = ARRAY_SIZE(thunderbay_pss_resets2),
+};
+
+/* PCIe reset data */
+static const struct thunderbay_rst_map thunderbay_pcie_resets[] = {
+	[TBH_PCIE_POWER_ON_RST] = THUNDERBAY_RESET(0x0, 0),
+	[TBH_PCIE_SUBSYSTEM_RST] = THUNDERBAY_RESET(0x0, 1),
+	[TBH_PCIE_PHY_RST] = THUNDERBAY_RESET(0x0, 2),
+	[TBH_PCIE_CTRL0_RST] = THUNDERBAY_RESET(0x0, 3),
+	[TBH_PCIE_CTRL1_RST] = THUNDERBAY_RESET(0x0, 4),
+};
+
+static const struct thunderbay_rst_data thunderbay_pcie_reset_data = {
+	.resets = thunderbay_pcie_resets,
+	.n_resets = ARRAY_SIZE(thunderbay_pcie_resets),
+};
+
+/* COMSS reset data */
+static const struct thunderbay_rst_map thunderbay_comss_resets[] = {
+	[TBH_COMSS_VPU_VPU_RESET_N] = THUNDERBAY_RESET(0x00, 0),
+	[TBH_COMSS_OCS_OCS_RESET_N] = THUNDERBAY_RESET(0x100, 0),
+	[TBH_COMSS_MEDIA_VCEJ_CORERST_N] = THUNDERBAY_RESET(0X1000, 0),
+	[TBH_COMSS_MEDIA_VCEJ_ARESET_N] = THUNDERBAY_RESET(0X1000, 1),
+	[TBH_COMSS_MEDIA_VCEJ_PRESET_N] = THUNDERBAY_RESET(0X1000, 2),
+	[TBH_COMSS_MEDIA_VCE_CORERST_N] = THUNDERBAY_RESET(0X1000, 3),
+	[TBH_COMSS_MEDIA_VCE_ARESET_N] = THUNDERBAY_RESET(0X1000, 4),
+	[TBH_COMSS_MEDIA_VCE_PRESET_N] = THUNDERBAY_RESET(0X1000, 5),
+	[TBH_COMSS_MEDIA_VCDA_CORERST_N] = THUNDERBAY_RESET(0X1000, 6),
+	[TBH_COMSS_MEDIA_VCDA_ARESET_N] = THUNDERBAY_RESET(0X1000, 7),
+	[TBH_COMSS_MEDIA_VCDA_PRESET_N] = THUNDERBAY_RESET(0X1000, 8),
+	[TBH_COMSS_MEDIA_VCDB_CORERST_N] = THUNDERBAY_RESET(0X1000, 9),
+	[TBH_COMSS_MEDIA_VCDB_ARESET_N] = THUNDERBAY_RESET(0X1000, 10),
+	[TBH_COMSS_MEDIA_VCDB_PRESET_N] = THUNDERBAY_RESET(0X1000, 11),
+	[TBH_COMSS_MEDIA_TBU0_ARESET_N] = THUNDERBAY_RESET(0X1000, 12),
+	[TBH_COMSS_MEDIA_TBU1_ARESET_N] = THUNDERBAY_RESET(0X1000, 13),
+	[TBH_COMSS_MEDIA_TBU2_ARESET_N] = THUNDERBAY_RESET(0X1000, 14),
+	[TBH_COMSS_MEDIA_TBU3_ARESET_N] = THUNDERBAY_RESET(0X1000, 15),
+	[TBH_COMSS_MEDIA_TBU4_ARESET_N] = THUNDERBAY_RESET(0X1000, 16),
+	[TBH_COMSS_MEDIA_TCU_ARESET_N] = THUNDERBAY_RESET(0X1000, 17),
+	[TBH_COMSS_MEDIA_DTI_ARESET_N] = THUNDERBAY_RESET(0X1000, 18),
+	[TBH_COMSS_MEDIA_PVT_ARESET_N] = THUNDERBAY_RESET(0X1000, 19),
+	[TBH_COMSS_MEDIA_PVT_PRESET_N] = THUNDERBAY_RESET(0X1000, 20),
+};
+
+static const struct thunderbay_rst_data thunderbay_comss_reset_data = {
+	.resets = thunderbay_comss_resets,
+	.n_resets = ARRAY_SIZE(thunderbay_comss_resets),
+};
+
+/* MEMSS reset data */
+static const struct thunderbay_rst_map thunderbay_memss_resets[] = {
+	[TBH_MEMSS_MC_MC_U1_CORE_DDRC_RSTN] = THUNDERBAY_RESET(0x0, 0),
+	[TBH_MEMSS_MC_MC_U2_CORE_DDRC_RSTN] = THUNDERBAY_RESET(0x0, 1),
+	[TBH_MEMSS_MC_MC_U1_SBR_RESETN] = THUNDERBAY_RESET(0x0, 2),
+	[TBH_MEMSS_MC_MC_U2_SBR_RESETN] = THUNDERBAY_RESET(0x0, 3),
+	[TBH_MEMSS_MC_MC_U1_ARESETN_0] = THUNDERBAY_RESET(0x0, 4),
+	[TBH_MEMSS_MC_MC_U2_ARESETN_0] = THUNDERBAY_RESET(0x0, 5),
+	[TBH_MEMSS_MC_MC_U1_PRESETN] = THUNDERBAY_RESET(0x0, 6),
+	[TBH_MEMSS_MC_MC_U2_PRESETN] = THUNDERBAY_RESET(0x0, 7),
+	[TBH_MEMSS_MC_MC_U1_SCAN_RESETN] = THUNDERBAY_RESET(0x0, 8),
+	[TBH_MEMSS_MC_MC_U2_SCAN_RESETN] = THUNDERBAY_RESET(0x0, 9),
+	[TBH_MEMSS_MC_PHY_U1_PRESETN_APB] = THUNDERBAY_RESET(0x0, 10),
+	[TBH_MEMSS_MC_PHY_U1_PWROKIN] = THUNDERBAY_RESET(0x0, 11),
+	[TBH_MEMSS_MC_PHY_U1_RESET] = THUNDERBAY_RESET(0x0, 12),
+	[TBH_MEMSS_MC_PHY_U1_WRSTN] = THUNDERBAY_RESET(0x0, 13),
+	[TBH_MEMSS_MC_DDRSS_APB_REGS_U1_I_PRESETN] = THUNDERBAY_RESET(0x0, 14),
+	[TBH_MEMSS_MC_DDRSS_APB_REGS_U1_I_RSTN] = THUNDERBAY_RESET(0x0, 15),
+	[TBH_MEMSS_MC_MC_COUNTER_TOP_U1_I_MCA_RSTN] = THUNDERBAY_RESET(0x0, 16),
+	[TBH_MEMSS_MC_MC_COUNTER_TOP_U1_I_MCB_RSTN] = THUNDERBAY_RESET(0x0, 17),
+	[TBH_MEMSS_MC_DDRSS_GLUE_U1_I_MCA_RSTN] = THUNDERBAY_RESET(0x0, 18),
+	[TBH_MEMSS_MC_DDRSS_GLUE_U1_I_MCB_RSTN] = THUNDERBAY_RESET(0x0, 19),
+	[TBH_MEMSS_PHY_PHY_U1_PRESETN_APB] = THUNDERBAY_RESET(0x10, 0),
+	[TBH_MEMSS_PHY_PHY_U1_PWROKIN] = THUNDERBAY_RESET(0x10, 1),
+	[TBH_MEMSS_PHY_PHY_U1_RESET] = THUNDERBAY_RESET(0x10, 2),
+	[TBH_MEMSS_PHY_PHY_U1_WRSTN] = THUNDERBAY_RESET(0x10, 3),
+	[TBH_MEMSS_MISC_DDRSS_APB_REGS_U1_I_PRESETN] = THUNDERBAY_RESET(0x20, 0),
+	[TBH_MEMSS_MISC_DDRSS_APB_REGS_U1_I_RSTN] = THUNDERBAY_RESET(0x20, 1),
+	[TBH_MEMSS_MISC_MC_COUNTER_TOP_U1_I_MCA_RSTN] = THUNDERBAY_RESET(0x20, 2),
+	[TBH_MEMSS_MISC_MC_COUNTER_TOP_U1_I_MCB_RSTN] = THUNDERBAY_RESET(0x20, 3),
+	[TBH_MEMSS_MISC_DDRSS_GLUE_U1_I_MCA_RSTN] = THUNDERBAY_RESET(0x20, 4),
+	[TBH_MEMSS_MISC_DDRSS_GLUE_U1_I_MCB_RSTN] = THUNDERBAY_RESET(0x20, 5),
+};
+
+static const struct thunderbay_rst_data thunderbay_memss_reset_data = {
+	.resets = thunderbay_memss_resets,
+	.n_resets = ARRAY_SIZE(thunderbay_memss_resets),
+};
diff --git a/include/linux/reset/reset-thunderbay.h b/include/linux/reset/reset-thunderbay.h
new file mode 100644
index 000000000000..ae6c2d6b1734
--- /dev/null
+++ b/include/linux/reset/reset-thunderbay.h
@@ -0,0 +1,32 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2020 Intel Corporation
+ */
+
+#ifndef _LINUX_RESET_THUNDERBAY_H_
+#define _LINUX_RESET_THUNDERBAY_H_
+
+#define THUNDERBAY_RESET_EN_OFFSET     0x0
+/* deassert register offset */
+#define THUNDERBAY_RESET_SET_OFFSET    0x4
+/* assert register offset */
+#define THUNDERBAY_RESET_CLEAR_OFFSET  0x8
+
+#define THUNDERBAY_RESET(_reg, _bit)	\
+	{				\
+		.reg = (_reg),		\
+		.bit = (_bit),		\
+	}
+
+struct thunderbay_rst_map {
+	unsigned int reg;
+	unsigned int bit;
+};
+
+struct thunderbay_rst_data {
+	const struct thunderbay_rst_map *resets;
+	size_t n_resets;
+};
+
+#include <linux/reset/reset-thunderbay-ss.h>
+#endif
-- 
2.25.1

