From 58c734d72ddd7925f25317bb1b235c37538e8584 Mon Sep 17 00:00:00 2001
From: Aman Kumar <aman.kumar@intel.com>
Date: Tue, 22 Jun 2021 12:42:03 +0530
Subject: [PATCH 8/8] serial: 8250: Implement uart sw half duplex mode

Added code for enabling software half duplex mode
in UART.

Signed-off-by: Aman Kumar <aman.kumar@intel.com>
---
 drivers/tty/serial/8250/8250_dwlib.c | 29 +++++++++++++++++++++++-----
 include/uapi/linux/serial.h          |  2 ++
 2 files changed, 26 insertions(+), 5 deletions(-)

diff --git a/drivers/tty/serial/8250/8250_dwlib.c b/drivers/tty/serial/8250/8250_dwlib.c
index 0530c9431bfe..411de7ef5c85 100644
--- a/drivers/tty/serial/8250/8250_dwlib.c
+++ b/drivers/tty/serial/8250/8250_dwlib.c
@@ -107,12 +107,15 @@ void dw8250_do_set_termios(struct uart_port *p, struct ktermios *termios, struct
 EXPORT_SYMBOL_GPL(dw8250_do_set_termios);
 static int dw8250_rs485_config(struct uart_port *p, struct serial_rs485 *rs485)
 {
+	u32 re_en, de_en;
 	u32 lcr = 0;
 	u32 tcr;
 
 	/* Clearing unsupported flags. */
 	rs485->flags &= SER_RS485_ENABLED | SER_RS485_9BIT_ENABLED |
-			SER_RS485_9BIT_TX_ADDR | SER_RS485_9BIT_RX_ADDR | SER_RS485_RX_DURING_TX;
+			SER_RS485_9BIT_TX_ADDR | SER_RS485_9BIT_RX_ADDR |
+			SER_RS485_RX_DURING_TX | SER_RS485_RX_OR_TX |
+			SER_RS485_SW_TX_MODE;
 
 	tcr = dw8250_readl_ext(p, DW_UART_TCR);
 	/* Reset previous Transfer Mode */
@@ -122,12 +125,28 @@ static int dw8250_rs485_config(struct uart_port *p, struct serial_rs485 *rs485)
 	if (rs485->flags & SER_RS485_ENABLED) {
 
 		/* Using SER_RS485_RX_DURING_TX to indicate Full Duplex Mode */
-		if (rs485->flags & SER_RS485_RX_DURING_TX)
+		if (rs485->flags & SER_RS485_RX_DURING_TX) {
 			tcr |= DW_UART_TCR_RS485_EN | DW_UART_TCR_XFER_MODE(0);
-		else
+			re_en = 1;
+			de_en = 1;
+		}
+		/* Using SER_RS485_RX_OR_TX to indicate SW Half Duplex Mode */
+		else if (rs485->flags & SER_RS485_RX_OR_TX) {
+			tcr |= DW_UART_TCR_RS485_EN | DW_UART_TCR_XFER_MODE(1);
+			if (rs485->flags & SER_RS485_SW_TX_MODE) {
+				re_en = 0;
+				de_en = 1;
+			} else {
+				re_en = 1;
+				de_en = 0;
+			}
+		} else {
 			tcr |= DW_UART_TCR_RS485_EN | DW_UART_TCR_XFER_MODE(2);
-		dw8250_writel_ext(p, DW_UART_DE_EN, 1);
-		dw8250_writel_ext(p, DW_UART_RE_EN, 1);
+			re_en = 1;
+			de_en = 1;
+		}
+		dw8250_writel_ext(p, DW_UART_DE_EN, de_en);
+		dw8250_writel_ext(p, DW_UART_RE_EN, re_en);
 	} else {
 		tcr &= ~(DW_UART_TCR_RS485_EN | DW_UART_TCR_XFER_MODE(3));
 		dw8250_writel_ext(p, DW_UART_DE_EN, 0);
diff --git a/include/uapi/linux/serial.h b/include/uapi/linux/serial.h
index 5dd48c2d520f..61b49689248a 100644
--- a/include/uapi/linux/serial.h
+++ b/include/uapi/linux/serial.h
@@ -122,6 +122,7 @@ struct serial_rs485 {
 							   sending */
 #define SER_RS485_RTS_AFTER_SEND	(1 << 2)	/* Logical level for
 							   RTS pin after sent*/
+#define SER_RS485_RX_OR_TX		(1 << 3)
 #define SER_RS485_RX_DURING_TX		(1 << 4)
 #define SER_RS485_TERMINATE_BUS		(1 << 5)	/* Enable bus
 							   termination
@@ -132,6 +133,7 @@ struct serial_rs485 {
 							   in padding */
 #define SER_RS485_9BIT_RX_ADDR		(1 << 8)	/* RX address available
 							   in padding */
+#define SER_RS485_SW_TX_MODE		(1 << 9)
 	__u32	delay_rts_before_send;	/* Delay before send (milliseconds) */
 	__u32	delay_rts_after_send;	/* Delay after send (milliseconds) */
 	__u32	padding[5];		/* Memory is cheap, new structs
-- 
2.25.1

