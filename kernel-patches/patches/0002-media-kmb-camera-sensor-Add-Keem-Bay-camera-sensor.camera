From 0e67e4d0a435bdc23e98a7390e9811fd5d053bd6 Mon Sep 17 00:00:00 2001
From: Martina Krasteva <martinax.krasteva@intel.com>
Date: Fri, 26 Jun 2020 11:36:02 +0100
Subject: [PATCH 02/42] media: kmb-camera-sensor: Add Keem Bay camera sensor

The KeemBay Sensor is a dummy device driver used for memory to memory
processing.

Signed-off-by: Martina Krasteva <martinax.krasteva@intel.com>
Signed-off-by: Daniele Alessandrelli <daniele.alessandrelli@intel.com>
---
 drivers/media/i2c/Kconfig      |  12 +
 drivers/media/i2c/Makefile     |   2 +
 drivers/media/i2c/kmb-sensor.c | 533 +++++++++++++++++++++++++++++++++
 drivers/media/i2c/kmb-sensor.h |  90 ++++++
 4 files changed, 637 insertions(+)
 create mode 100644 drivers/media/i2c/kmb-sensor.c
 create mode 100644 drivers/media/i2c/kmb-sensor.h

diff --git a/drivers/media/i2c/Kconfig b/drivers/media/i2c/Kconfig
index 6157e73eef24..479d1965a18d 100644
--- a/drivers/media/i2c/Kconfig
+++ b/drivers/media/i2c/Kconfig
@@ -896,6 +896,18 @@ config VIDEO_OV02A10
 	  To compile this driver as a module, choose M here: the
 	  module will be called ov02a10.
 
+config VIDEO_INTEL_KMB_SENSOR
+	tristate "Keem Bay Camera V4L2 sensor device"
+	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+	depends on MEDIA_CONTROLLER
+	select V4L2_FWNODE
+	help
+	  This is a V4L2 sensor-level driver for Keem Bay camera
+	  sensor.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called kmb-sensor.
+
 config VIDEO_OV2640
 	tristate "OmniVision OV2640 sensor support"
 	depends on VIDEO_V4L2 && I2C
diff --git a/drivers/media/i2c/Makefile b/drivers/media/i2c/Makefile
index 83268f20aa3a..2b0ab51bca2a 100644
--- a/drivers/media/i2c/Makefile
+++ b/drivers/media/i2c/Makefile
@@ -134,3 +134,5 @@ obj-$(CONFIG_VIDEO_RDACM20)	+= rdacm20.o
 obj-$(CONFIG_VIDEO_RDACM21)	+= rdacm21.o
 obj-$(CONFIG_VIDEO_ST_MIPID02) += st-mipid02.o
 obj-$(CONFIG_SDR_MAX2175) += max2175.o
+
+obj-$(CONFIG_VIDEO_INTEL_KMB_SENSOR)    += kmb-sensor.o
diff --git a/drivers/media/i2c/kmb-sensor.c b/drivers/media/i2c/kmb-sensor.c
new file mode 100644
index 000000000000..23e8df5848b1
--- /dev/null
+++ b/drivers/media/i2c/kmb-sensor.c
@@ -0,0 +1,533 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * kmb-sensor.c - KeemBay Camera Sensor Driver.
+ *
+ * Copyright (C) 2018-2019 Intel Corporation
+ */
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-event.h>
+#include <media/v4l2-image-sizes.h>
+
+#include "kmb-sensor.h"
+
+#define KMB_SENSOR_SIZE_WIDHT	(640)
+#define KMB_SENSOR_SIZE_HEIGHT	(480)
+
+/**
+ * kmb_sensor_set_params - Set stream parameters
+ * @kmb_sensor: pointer to kmb sensor device
+ *
+ * Return: 0 if successful
+ */
+static int kmb_sensor_set_params(struct kmb_sensor *kmb_sensor)
+{
+	dev_dbg(kmb_sensor->subdev.dev, "%s\n", __func__);
+	return 0;
+}
+
+/**
+ * kmb_sensor_enum_mbus_code - Enum mbus format code
+ * @sd: pointer to V4L2 sub-device
+ * @cfg: pointer to sub-device pad information
+ * @code: pointer to media bus format code enumeration
+ *
+ * VIDIOC_SUBDEV_ENUM_MBUS_CODE ioctl handler
+ *
+ * Return: 0 if successful
+ */
+static int kmb_sensor_enum_mbus_code(struct v4l2_subdev *sd,
+		struct v4l2_subdev_pad_config *cfg,
+		struct v4l2_subdev_mbus_code_enum *code)
+{
+	struct kmb_sensor *kmb_sensor =
+			container_of(sd, struct kmb_sensor, subdev);
+
+	dev_dbg(sd->dev, "%s\n", __func__);
+
+	if (code->index > 0)
+		return -EINVAL;
+
+	mutex_lock(&kmb_sensor->lock);
+	code->code = kmb_sensor->curr_fmt.code;
+	mutex_unlock(&kmb_sensor->lock);
+
+	return 0;
+}
+
+/**
+ * kmb_sensor_enum_frame_sizes - Enum frame sizes
+ * @sd: pointer to V4L2 sub-device
+ * @cfg: pointer to sub-device pad information
+ * @fse: pointer to media bus format enumeration
+ *
+ * VIDIOC_SUBDEV_ENUM_FRAME_SIZE ioctl handler
+ *
+ * Return: 0 if successful
+ */
+static int kmb_sensor_enum_frame_sizes(struct v4l2_subdev *sd,
+		struct v4l2_subdev_pad_config *cfg,
+		struct v4l2_subdev_frame_size_enum *fse)
+{
+	struct kmb_sensor *kmb_sensor =
+			container_of(sd, struct kmb_sensor, subdev);
+
+	mutex_lock(&kmb_sensor->lock);
+
+	if (fse->index > 0) {
+		mutex_unlock(&kmb_sensor->lock);
+		return -EINVAL;
+	}
+
+	fse->min_width = KMB_SENSOR_SIZE_WIDHT;
+	fse->max_width = fse->min_width;
+	fse->min_height = KMB_SENSOR_SIZE_HEIGHT;
+	fse->max_height = fse->min_height;
+
+	mutex_unlock(&kmb_sensor->lock);
+
+	return 0;
+}
+
+/**
+ * kmb_sensor_get_fmt - Get mbus format
+ * @sd: pointer to V4L2 sub-device
+ * @cfg: pointer to sub-device pad information
+ * @fmt: pointer to pad-level media bus format
+ *
+ * VIDIOC_SUBDEV_G_FMT ioctl handler
+ *
+ * Return: 0 if successful
+ */
+static int kmb_sensor_get_fmt(struct v4l2_subdev *sd,
+		struct v4l2_subdev_pad_config *cfg,
+		struct v4l2_subdev_format *fmt)
+{
+	struct kmb_sensor *kmb_sensor =
+			container_of(sd, struct kmb_sensor, subdev);
+
+	dev_dbg(sd->dev, "%s\n", __func__);
+
+	mutex_lock(&kmb_sensor->lock);
+	fmt->format = kmb_sensor->curr_fmt;
+	mutex_unlock(&kmb_sensor->lock);
+
+	return 0;
+}
+
+/**
+ * kmb_sensor_set_fmt - Set mbus format
+ * @sd: pointer to V4L2 sub-device
+ * @cfg: pointer to sub-device pad information
+ * @fmt: pointer to pad-level media bus format
+ *
+ * VIDIOC_SUBDEV_S_FMT ioctl handler
+ *
+ * Return: 0 if successful
+ */
+static int kmb_sensor_set_fmt(struct v4l2_subdev *sd,
+		struct v4l2_subdev_pad_config *cfg,
+		struct v4l2_subdev_format *fmt)
+{
+	struct kmb_sensor *kmb_sensor =
+			container_of(sd, struct kmb_sensor, subdev);
+
+	dev_dbg(sd->dev, "%s\n", __func__);
+
+	mutex_lock(&kmb_sensor->lock);
+	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY)
+		cfg->try_fmt = fmt->format;
+	else
+		kmb_sensor->curr_fmt = fmt->format;
+	mutex_unlock(&kmb_sensor->lock);
+
+	return 0;
+}
+
+/**
+ * kmb_sensor_s_stream - Set video stream stop/start
+ * @sd: pointer to V4L2 sub-device
+ * @enable: stream state
+ *
+ * Return: 0 if successful
+ */
+static int kmb_sensor_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct kmb_sensor *kmb_sensor =
+			container_of(sd, struct kmb_sensor, subdev);
+	struct kmb_sensor_ctrls *ctrls = &kmb_sensor->ctrls;
+	int ret = 0;
+
+	dev_dbg(kmb_sensor->subdev.dev, "%s: Set stream on %d\n",
+			__func__, enable);
+
+	mutex_lock(&kmb_sensor->lock);
+	if (kmb_sensor->streaming != enable) {
+		if (enable)
+			ret = kmb_sensor_set_params(kmb_sensor);
+
+		if (!ret && ctrls->update) {
+			mutex_unlock(&kmb_sensor->lock);
+			ret = v4l2_ctrl_handler_setup(&ctrls->handler);
+			mutex_lock(&kmb_sensor->lock);
+			if (!ret)
+				ctrls->update = 0;
+		}
+		/* Write register settings */
+	}
+
+	if (!ret)
+		kmb_sensor->streaming = enable ? true : false;
+
+	mutex_unlock(&kmb_sensor->lock);
+	return ret;
+}
+
+/**
+ * kmb_sensor_get_default_format - Get default media bus format
+ * @mbus_fmt: pointer to media bus format
+ *
+ * Return: none
+ */
+static void kmb_sensor_get_default_format(struct v4l2_mbus_framefmt *mbus_fmt)
+{
+	mbus_fmt->width = 2616;
+	mbus_fmt->height = 1964;
+	mbus_fmt->colorspace = V4L2_COLORSPACE_SRGB;
+	mbus_fmt->code = MEDIA_BUS_FMT_SRGGB12_1X12;
+	mbus_fmt->field = V4L2_FIELD_NONE;
+}
+
+/**
+ * kmb_sensor_open - Sub-device node open
+ * @sd: pointer to V4L2 sub-device
+ * @fh: pointer to V4L2 sub-device file handle
+ *
+ * Return: 0 if successful
+ */
+static int kmb_sensor_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct kmb_sensor *kmb_sensor =
+			container_of(sd, struct kmb_sensor, subdev);
+
+	dev_dbg(sd->dev, "%s wxh %dx%d cspc %d\n", __func__,
+			kmb_sensor->curr_fmt.width, kmb_sensor->curr_fmt.height,
+			kmb_sensor->curr_fmt.colorspace);
+
+	return 0;
+}
+
+/**
+ * kmb_sensor_close - Sub-device node close
+ * @sd: pointer to V4L2 sub-device
+ * @fh: pointer to V4L2 sub-device file handle
+ *
+ * Return: 0 if successful
+ */
+static int kmb_sensor_close(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	dev_dbg(sd->dev, "%s\n", __func__);
+	return 0;
+}
+
+/**
+ * kmb_sensor_ioctl - Private ioctl handling
+ * @sd: pointer to V4L2 sub-device
+ * @cmd: ioctl command
+ * @arg: pointer to ioctl arguments
+ *
+ * Return: 0 if successful, -ENOTTY if command is not supported
+ */
+static long kmb_sensor_ioctl(struct v4l2_subdev *sd,
+		unsigned int cmd, void *arg)
+{
+	int ret = 0;
+
+	switch (cmd) {
+	default:
+		dev_dbg(sd->dev, "%s: Unknown cmd 0x%x\n", __func__, cmd);
+		ret = -ENOTTY;
+		break;
+	}
+
+	return ret;
+}
+
+/**
+ * kmb_sensor_s_power - Put device in power saving or normal mode
+ * @sd: pointer to V4L2 sub-device
+ * @on: power state (0 - power saving mode, 1 - normal operation mode)
+ *
+ * Return: 0 if successful
+ */
+static int kmb_sensor_s_power(struct v4l2_subdev *sd, int on)
+{
+	struct kmb_sensor *kmb_sensor =
+			container_of(sd, struct kmb_sensor, subdev);
+
+	mutex_lock(&kmb_sensor->lock);
+	if (kmb_sensor->power_on != on) {
+		dev_dbg(sd->dev, "%s: Set power_on %d\n", __func__, on);
+		kmb_sensor->power_on = on;
+	}
+	kmb_sensor->streaming = false;
+	mutex_unlock(&kmb_sensor->lock);
+
+	dev_dbg(sd->dev, "%s: Set power_on %d\n", __func__, on);
+	return 0;
+}
+
+/**
+ * kmb_sensor_s_ctrl - Set new control value
+ * @ctrl: pointer to control structure
+ *
+ * Return: 0 if successful
+ */
+static int kmb_sensor_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct v4l2_subdev *sd =
+			&(container_of(ctrl->handler, struct kmb_sensor,
+					ctrls.handler)->subdev);
+	struct kmb_sensor *kmb_sensor =
+			container_of(sd, struct kmb_sensor, subdev);
+	int ret = 0;
+
+	dev_dbg(sd->dev, "s_ctrl: %s, value: %d. power: %d\n",
+			 ctrl->name, ctrl->val, kmb_sensor->power_on);
+
+	mutex_lock(&kmb_sensor->lock);
+
+	switch (ctrl->id) {
+	case V4L2_CID_EXPOSURE_ABSOLUTE:
+		dev_dbg(sd->dev, "%s: set exposure\n", __func__);
+		break;
+	case V4L2_CID_GAIN:
+		dev_dbg(sd->dev, "%s: set gain\n", __func__);
+		break;
+	default:
+		dev_dbg(sd->dev, "%s: KMB sensor set %d\n", __func__, ctrl->id);
+	}
+
+	mutex_unlock(&kmb_sensor->lock);
+	return ret;
+}
+
+/* sub-device internal operations */
+static const struct v4l2_subdev_internal_ops kmb_sensor_sd_internal_ops = {
+	.open = kmb_sensor_open,
+	.close = kmb_sensor_close,
+};
+
+/* sub-device core operations */
+static const struct v4l2_subdev_core_ops kmb_sensor_core_ops = {
+	.ioctl = kmb_sensor_ioctl,
+	.s_power = kmb_sensor_s_power,
+	.log_status = v4l2_ctrl_subdev_log_status,
+	.subscribe_event = v4l2_ctrl_subdev_subscribe_event,
+	.unsubscribe_event = v4l2_event_subdev_unsubscribe,
+};
+
+/* sub-device pad operations */
+static const struct v4l2_subdev_pad_ops kmb_sensor_pad_ops = {
+	.enum_mbus_code = kmb_sensor_enum_mbus_code,
+	.enum_frame_size = kmb_sensor_enum_frame_sizes,
+	.get_fmt = kmb_sensor_get_fmt,
+	.set_fmt = kmb_sensor_set_fmt,
+};
+
+/* sub-device video operations */
+static const struct v4l2_subdev_video_ops kmb_sensor_video_ops = {
+	.s_stream = kmb_sensor_s_stream,
+};
+
+/* sub-device operations */
+static const struct v4l2_subdev_ops kmb_sensor_subdev_ops = {
+	.core = &kmb_sensor_core_ops,
+	.pad = &kmb_sensor_pad_ops,
+	.video = &kmb_sensor_video_ops,
+};
+
+/* V4L2 control operations */
+static const struct v4l2_ctrl_ops kmb_sensor_ctrl_ops = {
+	.s_ctrl = kmb_sensor_s_ctrl,
+};
+
+/**
+ * kmb_sensor_initialize_controls - Initialize handled sensor controls
+ * @kmb_sensor: pointer to sensor device
+ *
+ * Return: 0 if successful
+ */
+static int kmb_sensor_initialize_controls(struct kmb_sensor *kmb_sensor)
+{
+	const struct v4l2_ctrl_ops *ops = &kmb_sensor_ctrl_ops;
+	struct kmb_sensor_ctrls *ctrls = &kmb_sensor->ctrls;
+	int ret;
+
+	ret = v4l2_ctrl_handler_init(&ctrls->handler, 16);
+	if (ret < 0)
+		return ret;
+
+	ctrls->exposure = v4l2_ctrl_new_std(&ctrls->handler, ops,
+			V4L2_CID_EXPOSURE_ABSOLUTE,
+			2, 1500, 1, 500);
+
+	ctrls->gain = v4l2_ctrl_new_std(&ctrls->handler, ops,
+			V4L2_CID_GAIN, 16, 64 * (16 + 15), 1, 64 * 16);
+
+	/* Read only controls */
+	ctrls->pclk = v4l2_ctrl_new_std(&ctrls->handler, ops,
+			V4L2_CID_PIXEL_RATE,
+			594000000, 594000000, 1, 594000000);
+	if (ctrls->pclk)
+		ctrls->pclk->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	if (ctrls->handler.error) {
+		ret = ctrls->handler.error;
+		v4l2_ctrl_handler_free(&ctrls->handler);
+		return ret;
+	}
+
+	kmb_sensor->subdev.ctrl_handler = &ctrls->handler;
+	return ret;
+}
+
+/**
+ * kmb_sensor_detect - Detect V4L2 sub-device
+ * @sd: pointer to V4L2 sub-device
+ *
+ * Return: 0 if successful, -ENODEV if there is no device
+ */
+static int kmb_sensor_detect(struct v4l2_subdev *sd)
+{
+	dev_dbg(sd->dev, "%s\n", __func__);
+
+	kmb_sensor_s_power(sd, 1);
+	usleep_range(25000, 26000);
+
+	/* Check sensor revision */
+
+	kmb_sensor_s_power(sd, 0);
+
+	return 0;
+}
+
+/**
+ * kmb_sensor_probe - I2C client device binding
+ * @client: pointer to i2c client device
+ * @id: pointer to i2c device id
+ *
+ * Return: 0 if successful, -ENOMEM if there is not enough memory
+ */
+static int kmb_sensor_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct v4l2_subdev *sd;
+	struct kmb_sensor *kmb_sensor;
+	struct media_pad *pads;
+	int ret;
+
+	dev_dbg(&client->dev, "%s: Probe KMB sensor\n", __func__);
+
+	kmb_sensor = devm_kzalloc(&client->dev,
+			sizeof(*kmb_sensor), GFP_KERNEL);
+	if (!kmb_sensor)
+		return -ENOMEM;
+
+	mutex_init(&kmb_sensor->lock);
+	kmb_sensor->client = client;
+
+	sd = &kmb_sensor->subdev;
+	v4l2_i2c_subdev_init(&kmb_sensor->subdev, client,
+			&kmb_sensor_subdev_ops);
+	v4l2_subdev_init(&kmb_sensor->subdev, &kmb_sensor_subdev_ops);
+	strlcpy(sd->name, KMB_SENSOR_DRV_NAME, sizeof(sd->name));
+	v4l2_set_subdevdata(sd, client);
+
+	kmb_sensor->subdev.internal_ops = &kmb_sensor_sd_internal_ops;
+	kmb_sensor->subdev.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE |
+				V4L2_SUBDEV_FL_HAS_EVENTS;
+	kmb_sensor->subdev.entity.function = MEDIA_ENT_F_CAM_SENSOR;
+	strlcpy(kmb_sensor->subdev.name, KMB_SENSOR_DRV_NAME,
+			sizeof(kmb_sensor->subdev.name));
+
+	pads = kmb_sensor->pads;
+	pads[0].flags = MEDIA_PAD_FL_SOURCE;
+
+	ret = media_entity_pads_init(&kmb_sensor->subdev.entity,
+				     KMB_SENSOR_PADS_NUM, pads);
+	if (ret < 0)
+		return ret;
+
+	ret = kmb_sensor_initialize_controls(kmb_sensor);
+	if (ret < 0)
+		goto error_media_entity_cleanup;
+
+	kmb_sensor_get_default_format(kmb_sensor->formats);
+	kmb_sensor->curr_fmt = kmb_sensor->formats[0];
+
+	kmb_sensor_detect(sd);
+
+	v4l2_set_subdev_hostdata(sd, &kmb_sensor->subdev);
+
+	ret = v4l2_async_register_subdev_sensor_common(sd);
+	if (ret < 0)
+		goto error_free_ctrl_handler;
+
+	return 0;
+
+error_free_ctrl_handler:
+	v4l2_ctrl_handler_free(sd->ctrl_handler);
+error_media_entity_cleanup:
+	media_entity_cleanup(&sd->entity);
+	return ret;
+}
+
+/**
+ * kmb_sensor_remove - I2C client device unbinding
+ * @client: pointer to I2C client device
+ *
+ * Return: 0 if successful
+ */
+static int kmb_sensor_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct kmb_sensor *kmb_sensor =
+			container_of(sd, struct kmb_sensor, subdev);
+
+	dev_dbg(sd->dev, "%s: Remove KMB sensor\n", __func__);
+
+	mutex_destroy(&kmb_sensor->lock);
+	v4l2_async_unregister_subdev(sd);
+	v4l2_ctrl_handler_free(sd->ctrl_handler);
+	media_device_unregister_entity(&sd->entity);
+	media_entity_cleanup(&sd->entity);
+
+	return 0;
+}
+
+static const struct i2c_device_id kmb_sensor_id_table[] = {
+	{KMB_SENSOR_DRV_NAME, 0},
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, kmb_sensor_id_table);
+
+static struct i2c_driver kmb_sensor_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = KMB_SENSOR_DRV_NAME,
+	},
+	.probe = kmb_sensor_probe,
+	.remove = kmb_sensor_remove,
+	.id_table = kmb_sensor_id_table,
+};
+
+module_i2c_driver(kmb_sensor_i2c_driver);
+
+MODULE_DESCRIPTION("KeemBay I2C Sensor driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/i2c/kmb-sensor.h b/drivers/media/i2c/kmb-sensor.h
new file mode 100644
index 000000000000..75a11e2d31a1
--- /dev/null
+++ b/drivers/media/i2c/kmb-sensor.h
@@ -0,0 +1,90 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * kmb-sensor.h - KeemBay Camera Sensor Driver.
+ *
+ * Copyright (C) 2018-2019 Intel Corporation
+ */
+#ifndef KMB_SENSOR_H
+#define KMB_SENSOR_H
+
+#define KMB_SENSOR_DRV_NAME	"kmb-camera-sensor"
+
+#define KMB_SENSOR_SRC_PAD	0
+#define KMB_SENSOR_PADS_NUM	1
+
+/**
+ * struct kmb_sensor_ctrls - KMB Camera Sensor controls structure
+ * @handler: control handler
+ * @exposure: exposure control
+ * @gain: gain control
+ * @pclk: pixel clock
+ * @update: update flag
+ */
+struct kmb_sensor_ctrls {
+	struct v4l2_ctrl_handler handler;
+	struct v4l2_ctrl *exposure;
+	struct v4l2_ctrl *gain;
+	struct v4l2_ctrl *pclk;
+	u8 update;
+};
+
+/**
+ * struct kmb_sensor_framesize - KMB Camera Sensor frame sizes
+ * @width: frame width
+ * @height: frame height
+ * @max_exp_lines: maximum exposure lines
+ * @regs: registers
+ */
+struct kmb_sensor_framesize {
+	u16 width;
+	u16 height;
+	u16 max_exp_lines;
+	const u8 *regs;
+};
+
+/**
+ * struct i2c_arr - Array representation of address - value pair
+ * @addr: address
+ * @val: value
+ */
+struct i2c_arr {
+	u16 addr;
+	u16 val;
+};
+
+/**
+ * struct kmb_sensor - KMB Camera Sensor device structure
+ * @client: pointer to i2c client device
+ * @lock: mutex
+ * @subdev: V4L2 sub-device
+ * @pads: array of media pad graph objects
+ * @formats: array of frame formats on the media bus
+ * @bus_type: media bus type
+ * @curr_fmt: current frame format
+ * @ctrls: sensor controls
+ * @exp_row_interval: exposure row intervals in us
+ * @frame_size: pointer to KMB camera sensor frame sizes
+ * @tslb_reg: YUVY sequence (pixel format) control register
+ * @streaming: streaming state flag
+ * @power_on: power on flag
+ */
+struct kmb_sensor {
+	struct i2c_client *client;
+	struct mutex lock;
+
+	struct v4l2_subdev subdev;
+	struct media_pad pads[KMB_SENSOR_PADS_NUM];
+	struct v4l2_mbus_framefmt formats[KMB_SENSOR_PADS_NUM];
+	enum v4l2_mbus_type bus_type;
+	struct v4l2_mbus_framefmt curr_fmt;
+	struct kmb_sensor_ctrls ctrls;
+
+	u32 exp_row_interval;
+	const struct kmb_sensor_framesize *frame_size;
+	u8 tslb_reg;
+
+	bool streaming;
+	bool power_on;
+};
+
+#endif /* KMB_SENSOR_H */
-- 
2.17.1

