From cbb53e56bf4cdb4f2d9677233d03f914c31ae554 Mon Sep 17 00:00:00 2001
From: Ankit Nautiyal <ankit.k.nautiyal@intel.com>
Date: Sat, 2 Apr 2022 12:22:10 +0530
Subject: [PATCH 1068/1096] drm/i915/hdmi21/mtl: Compute output format for
 HDMI2.1 FRL mode

If the source and sink support FRL, then compute output format
that can support HDMI2.1 FRL mode. This in turn calculates the FRL
configuration, clocks etc required to support a video mode with
FRL transmission.

Signed-off-by: Ankit Nautiyal <ankit.k.nautiyal@intel.com>
---
 drivers/gpu/drm/i915/display/intel_hdmi.c | 38 ++++++++++++++++-------
 1 file changed, 26 insertions(+), 12 deletions(-)

diff --git a/drivers/gpu/drm/i915/display/intel_hdmi.c b/drivers/gpu/drm/i915/display/intel_hdmi.c
index b844bd310ea2..03c4f7c8caff 100644
--- a/drivers/gpu/drm/i915/display/intel_hdmi.c
+++ b/drivers/gpu/drm/i915/display/intel_hdmi.c
@@ -2772,18 +2772,33 @@ int intel_hdmi_compute_config(struct intel_encoder *encoder,
 		intel_hdmi_has_audio(encoder, pipe_config, conn_state) &&
 		intel_audio_compute_config(encoder, pipe_config, conn_state);
 
-	/*
-	 * Try to respect downstream TMDS clock limits first, if
-	 * that fails assume the user might know something we don't.
-	 */
-	ret = intel_hdmi_compute_output_format(encoder, pipe_config, conn_state, true, false);
-	if (ret)
-		ret = intel_hdmi_compute_output_format(encoder, pipe_config, conn_state, false, false);
-	if (ret) {
+	if (intel_bios_hdmi_max_frl_rate(encoder) &&
+	    intel_hdmi->has_sink_hdmi_21 &&
+	    intel_hdmi_compute_output_format(encoder, pipe_config, conn_state, false, true) == 0) {
 		drm_dbg_kms(&dev_priv->drm,
-			    "unsupported HDMI clock (%d kHz), rejecting mode\n",
-			    pipe_config->hw.adjusted_mode.crtc_clock);
-		return ret;
+			    "Enabling FRL mode with lanes = %d rate = %d\n",
+			    pipe_config->frl.required_lanes,
+			    pipe_config->frl.required_rate);
+
+		pipe_config->frl.enable = true;
+		pipe_config->lane_count = pipe_config->frl.required_lanes;
+	} else {
+		/*
+		 * Try to respect downstream TMDS clock limits first, if
+		 * that fails assume the user might know something we don't.
+		 */
+		ret = intel_hdmi_compute_output_format(encoder, pipe_config, conn_state, true, false);
+		if (ret)
+			ret = intel_hdmi_compute_output_format(encoder, pipe_config, conn_state,
+							       false, false);
+		if (ret) {
+			drm_dbg_kms(&dev_priv->drm,
+				    "unsupported HDMI clock (%d kHz), rejecting mode\n",
+				    pipe_config->hw.adjusted_mode.crtc_clock);
+			return ret;
+		}
+		pipe_config->frl.enable = false;
+		pipe_config->lane_count = 4;
 	}
 
 	if (intel_hdmi_is_ycbcr420(pipe_config)) {
@@ -2799,7 +2814,6 @@ int intel_hdmi_compute_config(struct intel_encoder *encoder,
 		adjusted_mode->picture_aspect_ratio =
 			conn_state->picture_aspect_ratio;
 
-	pipe_config->lane_count = 4;
 
 	if (scdc->scrambling.supported && source_supports_scrambling(encoder) &&
 	    !pipe_config->frl.enable) {
-- 
2.25.1

