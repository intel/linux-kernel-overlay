From 7baf8162b7763ed6221bd56d7eceff79ce00a084 Mon Sep 17 00:00:00 2001
From: Alexander Usyskin <alexander.usyskin@intel.com>
Date: Thu, 6 Oct 2022 14:04:00 +0300
Subject: [PATCH 19/27] INTEL_DII: mei: add force wake workaround in resume

Upon force wake assert the firmware goes into reset.
Forcew ake FW on resume to allow uninterrupted
init flow on resume.

Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
---
 drivers/misc/mei/gsc-me.c | 15 +++++++++++----
 1 file changed, 11 insertions(+), 4 deletions(-)

diff --git a/drivers/misc/mei/gsc-me.c b/drivers/misc/mei/gsc-me.c
index 5ec334c8a2ef..8a78420f2e01 100644
--- a/drivers/misc/mei/gsc-me.c
+++ b/drivers/misc/mei/gsc-me.c
@@ -485,6 +485,7 @@ static int mei_gsc_probe(struct auxiliary_device *aux_dev,
 
 	pm_runtime_set_autosuspend_delay(device, MEI_GSC_RPM_TIMEOUT);
 	pm_runtime_use_autosuspend(device);
+	dev_pm_set_driver_flags(device, DPM_FLAG_NO_DIRECT_COMPLETE);
 
 	ret = mei_register(dev, device);
 	if (ret)
@@ -555,12 +556,18 @@ static int __maybe_unused mei_gsc_pm_resume(struct device *device)
 	struct mei_device *dev = dev_get_drvdata(device);
 	struct auxiliary_device *aux_dev;
 	struct mei_aux_device *adev;
-	int err;
+	int ret;
 	struct mei_me_hw *hw;
 
 	if (!dev)
 		return -ENODEV;
 
+	mutex_lock(&dev->device_lock);
+	ret = mei_gsc_forcewake_get_and_wait(dev, false);
+	mutex_unlock(&dev->device_lock);
+	if (ret)
+		return ret;
+
 	hw = to_me_hw(dev);
 	aux_dev = to_auxiliary_dev(device);
 	adev = auxiliary_dev_to_mei_aux_dev(aux_dev);
@@ -569,9 +576,9 @@ static int __maybe_unused mei_gsc_pm_resume(struct device *device)
 		dev->pxp_mode = MEI_DEV_PXP_INIT;
 	}
 
-	err = mei_restart(dev);
-	if (err)
-		return err;
+	ret = mei_restart(dev);
+	if (ret)
+		return ret;
 
 	/* Start timer if stopped in suspend */
 	schedule_delayed_work(&dev->timer_work, HZ);
-- 
2.25.1

