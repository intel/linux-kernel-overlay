From 35a874da573fa5fd9fc84f14f3c948f80a4ff613 Mon Sep 17 00:00:00 2001
From: Chen Meng J <meng.j.chen@intel.com>
Date: Wed, 12 Jul 2023 14:20:32 +0800
Subject: [PATCH 19/43] media: i2c: d4xx: update workaroud for unstable preview

Change Description:
instead of previous WA of hard code MAX9296/9295/D457 i2c addr,
reassign MAX9295 to MAX9296 addr + 1, avoid default 0x40 conlict,
and use dynamic i2c addr configuration from ACPI.

Test Platform:
IoTG Realsense

Signed-off-by: Chen Meng J <meng.j.chen@intel.com>
---
 drivers/media/i2c/d4xx.c | 213 +++++++++++++++++++++++----------------
 1 file changed, 128 insertions(+), 85 deletions(-)

diff --git a/drivers/media/i2c/d4xx.c b/drivers/media/i2c/d4xx.c
index ef8ac81f6eb2..e7b12a22586c 100644
--- a/drivers/media/i2c/d4xx.c
+++ b/drivers/media/i2c/d4xx.c
@@ -140,7 +140,22 @@
 //#define DS5_DEBUG_VCHAN_N		1
 //#define DS5_MOTION_T_VCHAN_N		2
 
-#define D4XX_I2C_ADDRESS_1	0x12
+#define MAX9295_REG0	0x0000
+#define MAX9295_I2C_4	0x0044
+#define MAX9295_I2C_5	0x0045
+
+#define MAX9296_CTRL0	0x0010
+#define RESET_LINK	(0x1 << 6)
+#define RESET_ONESHOT	(0x1 << 5)
+#define AUTO_LINK	(0x1 << 4)
+#define DUAL_LINK	(0x0)
+#define LINK_A		(0x1)
+#define LINK_B		(0x2)
+#define SPLITTER	(0x3)
+#define MAX9296_NUM	(4)
+
+#define MAX9295_I2C_ADDR_DEF	0x40
+#define D457_I2C_ADDR	0x10
 
 enum ds5_mux_pad {
 	DS5_MUX_PAD_EXTERNAL,
@@ -497,6 +512,9 @@ static int max9296_write_8(struct ds5 *state, u16 reg, u8 val)
 			dev_dbg(&state->client->dev, "%s(): i2c write 0x%04x: 0x%x\n",
 				 __func__, reg, val);
 
+	dev_dbg(&state->client->dev, "%s(): (%d), 0x%02x 0x%04x = 0x%02x\n",
+		__func__, ret, state->client->addr, reg, val);
+
 	return ret;
 }
 
@@ -513,6 +531,9 @@ static int max9296_read_8(struct ds5 *state, u16 reg, u8 *val)
 			dev_info(&state->client->dev, "%s(): i2c read 0x%04x = 0x%x\n",
 				 __func__, reg, *val);
 
+	dev_dbg(&state->client->dev, "%s(): (%d), 0x%02x 0x%04x = 0x%02x\n",
+		__func__, ret, state->client->addr, reg, *val);
+
 	return ret;
 }
 static int max9295_write_8(struct ds5 *state, u16 reg, u8 val)
@@ -528,6 +549,28 @@ static int max9295_write_8(struct ds5 *state, u16 reg, u8 val)
 			dev_info(&state->client->dev, "%s(): i2c write 0x%04x: 0x%x\n",
 				 __func__, reg, val);
 
+	dev_dbg(&state->client->dev, "%s(): (%d), 0x%02x 0x%04x = 0x%02x\n",
+		__func__, ret, state->client->addr, reg, val);
+
+	return ret;
+}
+
+static int max9295_read_8(struct ds5 *state, u16 reg, u8 *val)
+{
+	int ret;
+
+	ret = regmap_raw_read(state->regmap_max9295, reg, val, 1);
+	if (ret < 0)
+		dev_err(&state->client->dev, "%s(): i2c read failed %d, 0x%04x\n",
+			__func__, ret, reg);
+	else
+		if (state->dfu_dev.dfu_state_flag == DS5_DFU_IDLE)
+			dev_info(&state->client->dev, "%s(): i2c read 0x%04x = 0x%x\n",
+				 __func__, reg, *val);
+
+	dev_dbg(&state->client->dev, "%s(): (%d), 0x%02x 0x%04x = 0x%02x\n",
+		__func__, ret, state->client->addr, reg, *val);
+
 	return ret;
 }
 
@@ -3377,22 +3420,18 @@ static int ds5_mux_s_frame_interval(struct v4l2_subdev *sd,
 
 int d4xx_reset_oneshot(struct ds5 *state)
 {
+	struct d4xx_pdata *dpdata = state->client->dev.platform_data;
+	struct i2c_board_info *deser = dpdata->deser_board_info;
+
 	int s_addr = state->client->addr;
-	int n_addr = 0;
+	int n_addr = deser->addr;
 	int ret = 0;
 
-	if (s_addr == 0x12)
-		n_addr = 0x48;
-	if (s_addr == 0x14)
-		n_addr = 0x4a;
-	if (s_addr == 0x16)
-		n_addr = 0x68;
-	if (s_addr == 0x18)
-		n_addr = 0x6c;
 	if (n_addr) {
 		state->client->addr = n_addr;
 		dev_warn(&state->client->dev, "One-shot reset 0x%x enable auto-link\n", n_addr);
-		ret = max9296_write_8(state, 0x0010, 0x31); // One-shot reset  enable auto-link
+		/* One-shot reset  enable auto-link */
+		ret = max9296_write_8(state, MAX9296_CTRL0, RESET_ONESHOT | AUTO_LINK | LINK_A);
 		state->client->addr = s_addr;
 		/* delay to settle link */
 		msleep(100);
@@ -4578,67 +4617,82 @@ static const struct regmap_config ds5_regmap_max9295 = {
 	.val_format_endian = REGMAP_ENDIAN_NATIVE,
 };
 
-#define RESET_LINK	(0x1 << 6)
-#define RESET_ONESHOT	(0x1 << 5)
-#define AUTO_LINK	(0x1 << 4)
-#define DUAL_LINK	(0x0)
-#define LINK_A		(0x1)
-#define LINK_B		(0x2)
-#define SPLITTER	(0x3)
 static int ds5_i2c_addr_setting(struct i2c_client *c, struct ds5 *state)
 {
-	c->addr = 0x48;
-	max9296_write_8(state, 0x0010, 0x40);
-	c->addr = 0x4a;
-	max9296_write_8(state, 0x0010, 0x40);
-	c->addr = 0x68;
-	max9296_write_8(state, 0x0010, 0x40);
-	c->addr = 0x6c;
-	max9296_write_8(state, 0x0010, 0x40);
-
-	c->addr = 0x6c;
-	max9296_write_8(state, 0x0010, 0x32);
-	msleep_range(1000);
-
-	c->addr = 0x40;
-	max9295_write_8(state, 0x0000, 0xc8); // 0x64
-	c->addr = 0x64;
-	msleep_range(1000);
-
-	max9295_write_8(state, 0x0044, 0x30); // 0x18
-	max9295_write_8(state, 0x0045, 0x20);
-
-	c->addr = 0x68;
-	max9296_write_8(state, 0x0010, 0x32);
-	msleep_range(1000);
-
-	c->addr = 0x40;
-	max9295_write_8(state, 0x0000, 0xc4); // 0x62
-	c->addr = 0x62;
-	max9295_write_8(state, 0x0044, 0x2c); // 0x16
-	max9295_write_8(state, 0x0045, 0x20);
-
-	c->addr = 0x4a;
-	max9296_write_8(state, 0x0010, 0x32);
-	msleep_range(1000);
-
-	c->addr = 0x40;
-	max9295_write_8(state, 0x0000, 0x88); // 0x44
-	c->addr = 0x44;
-	max9295_write_8(state, 0x0044, 0x28); // 0x14
-	max9295_write_8(state, 0x0045, 0x20);
-
-	c->addr = 0x48;
-	max9296_write_8(state, 0x0010, 0x32);
-	msleep_range(1000);
-
-	c->addr = 0x40;
-	max9295_write_8(state, 0x0000, 0x84); // 0x42
-	c->addr = 0x42;
-	max9295_write_8(state, 0x0044, 0x24); // 0x12
-	max9295_write_8(state, 0x0045, 0x20);
-
-	c->addr = 0x12;
+	int curr_max9296 = c->addr;
+	int max9296_addrs[MAX9296_NUM] = {0x48, 0x4a, 0x68, 0x6c};
+	int i;
+	u8 val;
+	int ret;
+	struct d4xx_pdata *dpdata = c->dev.platform_data;
+	unsigned short ser_alias;
+	unsigned short sensor_alias;
+
+	/* TODO: 2x D457 subdev connect to MAX9296 */
+	if (dpdata->subdev_num >= 1) {
+		curr_max9296 = c->addr;
+		sensor_alias = dpdata->subdev_info[0].board_info.addr;
+		ser_alias = dpdata->subdev_info[0].ser_alias;
+	} else {
+		dev_err(&c->dev, "no subdev found!\n");
+		return -EINVAL;
+	}
+
+	dev_dbg(&c->dev, "curr_max9296 0x%02x, sensor_alias 0x%02x, ser_alias 0x%02x\n",
+		curr_max9296, sensor_alias, ser_alias);
+
+	/*
+	 * don't reset link,
+	 * check max9296 i2c addr + 1,
+	 * max9295 i2c addr reassigned already.
+	 */
+	c->addr = curr_max9296 + 1;
+	ret = max9295_read_8(state, MAX9295_REG0, &val);
+	if (!ret) {
+		max9295_write_8(state, MAX9295_REG0, ser_alias << 1);
+		msleep_range(1000); /* need this? */
+		c->addr = ser_alias;
+		max9295_write_8(state, MAX9295_I2C_4, sensor_alias << 1);
+		max9295_write_8(state, MAX9295_I2C_5, D457_I2C_ADDR << 1);
+		c->addr = sensor_alias;
+		return 0;
+	}
+
+	/* i2c addr reassignment for all max9295 */
+	for (i = 0; i < MAX9296_NUM; i++) {
+		c->addr = max9296_addrs[i];
+		max9296_write_8(state, MAX9296_CTRL0, RESET_LINK);
+	}
+
+	for (i = 0; i < MAX9296_NUM; i++) {
+		/* release reset */
+		c->addr = max9296_addrs[i];
+		max9296_write_8(state, MAX9296_CTRL0, AUTO_LINK | LINK_A);
+		msleep_range(1000);
+
+		if (curr_max9296 == max9296_addrs[i]) {
+			c->addr = MAX9295_I2C_ADDR_DEF;
+			ret = max9295_read_8(state, MAX9295_REG0, &val);
+			if (ret < 0) {
+				dev_err(&c->dev, "no max9295 found for max9296 %x\n", curr_max9296);
+				continue;
+			}
+			max9295_write_8(state, MAX9295_REG0, ser_alias << 1);
+			msleep_range(1000); // need this?
+			c->addr = ser_alias;
+			max9295_write_8(state, MAX9295_I2C_4, sensor_alias << 1);
+			max9295_write_8(state, MAX9295_I2C_5, D457_I2C_ADDR << 1);
+			continue;
+		}
+
+		c->addr = MAX9295_I2C_ADDR_DEF;
+		ret = max9295_read_8(state, MAX9295_REG0, &val);
+		if (ret < 0)
+			continue;
+		max9295_write_8(state, MAX9295_REG0, (max9296_addrs[i] + 1)  << 1);
+	}
+
+	c->addr = sensor_alias;
 
 	return 0;
 }
@@ -4683,15 +4737,6 @@ static int ds5_probe(struct i2c_client *c, const struct i2c_device_id *id)
 		goto e_regulator;
 	}
 
-	if (c->addr == 0x48)
-		c->addr = 0x12;
-	if (c->addr == 0x4a)
-		c->addr = 0x14;
-	if (c->addr == 0x68)
-		c->addr = 0x16;
-	if (c->addr == 0x6c)
-		c->addr = 0x18;
-
 	state->regmap_max9296 = devm_regmap_init_i2c(c, &ds5_regmap_max9296);
 	if (IS_ERR(state->regmap_max9296)) {
 		ret = PTR_ERR(state->regmap_max9296);
@@ -4706,12 +4751,10 @@ static int ds5_probe(struct i2c_client *c, const struct i2c_device_id *id)
 		return ret;
 	}
 
-	if (c->addr == 0x12) {
-		ret = ds5_i2c_addr_setting(c, state);
-		if (ret) {
-			dev_err(&c->dev, "failed apply i2c addr setting\n");
-			return ret;
-		}
+	ret = ds5_i2c_addr_setting(c, state);
+	if (ret) {
+		dev_err(&c->dev, "failed apply i2c addr setting\n");
+		return ret;
 	}
 
 	// Verify communication
-- 
2.25.1

