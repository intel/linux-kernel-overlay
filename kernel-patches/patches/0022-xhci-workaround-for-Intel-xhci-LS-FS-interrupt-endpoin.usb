From 7687e4f0fbdedc7c2a9a9620285f369ba3116d3b Mon Sep 17 00:00:00 2001
From: Mathias Nyman <mathias.nyman@linux.intel.com>
Date: Mon, 25 Oct 2021 12:39:39 +0300
Subject: [PATCH 22/23] xhci: workaround for Intel xhci LS/FS interrupt
 endpoint power saving errata

The power saving features of Intel xhci controllers have caused issues
on interrupt endpoints on full-speed and low-speed devices connected
behind a high-speed hub (thus using a transaction translator)

Work around this by setting the Intel vendor specific HSII bit at
offset 0x8144 when there is an active FS/LS endpoint behind a HS hub.

To save power we clear the HSII bit if no such endpoint is active.

Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
---
 drivers/usb/host/xhci-mem.c |  1 +
 drivers/usb/host/xhci.c     | 57 ++++++++++++++++++++++++++++++++++++-
 drivers/usb/host/xhci.h     |  1 +
 3 files changed, 58 insertions(+), 1 deletion(-)

diff --git a/drivers/usb/host/xhci-mem.c b/drivers/usb/host/xhci-mem.c
index 4d0b1c0e61a8..854bb1486c95 100644
--- a/drivers/usb/host/xhci-mem.c
+++ b/drivers/usb/host/xhci-mem.c
@@ -1915,6 +1915,7 @@ void xhci_mem_cleanup(struct xhci_hcd *xhci)
 	xhci->usb2_rhub.num_ports = 0;
 	xhci->usb3_rhub.num_ports = 0;
 	xhci->num_active_eps = 0;
+	xhci->num_active_tt_intr_eps = 0;
 	kfree(xhci->usb2_rhub.ports);
 	kfree(xhci->usb3_rhub.ports);
 	kfree(xhci->hw_ports);
diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c
index 68920cb96044..cd83a4627b0c 100644
--- a/drivers/usb/host/xhci.c
+++ b/drivers/usb/host/xhci.c
@@ -1941,6 +1941,53 @@ int xhci_add_endpoint(struct usb_hcd *hcd, struct usb_device *udev,
 }
 EXPORT_SYMBOL_GPL(xhci_add_endpoint);
 
+/*
+ * Workaround Intel host LS/FS interrupt endpoint issue.
+ *
+ * Out of order TRB are seen after split transaction errors on active LS/FS
+ * interrupt endpoints behind HS hubs.
+ *
+ * This can be mitigated by setting HSII (HS interrupt in alarm) bit 8 in a
+ * Intel specific register at offset 0x8144 when such endpoints are active.
+ * Keeping HSII on at all time has additional power consumption cost, so clear
+ * it if no LS/FS  interrupt endpoints are active behid HS hubs.
+ *
+ * Older Intel hosts have HSII set all the time, so don't touch those.
+ */
+static void xhci_track_intr_eps_quirk(struct xhci_hcd *xhci, struct xhci_virt_ep *ep, int change)
+{
+	struct usb_device *udev;
+	unsigned long flags;
+	void __iomem *reg;
+	u32 val;
+
+	if (!(xhci->quirks & XHCI_INTEL_HOST) || !(xhci->hci_version >= 0x110))
+		return;
+
+	if (!ep->ring || ep->ring->type != TYPE_INTR || !change)
+		return;
+
+	udev = ep->vdev->udev;
+	reg = (void __iomem *) xhci->cap_regs + 0x8144;
+
+	/* Full or Low speed device endpoint behind HS hub */
+	if (udev && udev->tt && udev->tt->hub->parent) {
+		spin_lock_irqsave(&xhci->lock, flags);
+		xhci->num_active_tt_intr_eps += change;
+		val = readl(reg);
+
+		if (xhci->num_active_tt_intr_eps == 0)
+			writel(val & ~BIT(8), reg);
+		else if (xhci->num_active_tt_intr_eps == change)
+			writel(val | BIT(8), reg);
+
+		spin_unlock_irqrestore(&xhci->lock, flags);
+
+		xhci_dbg(xhci, "active LS/FS intr eps under HS hub:%d change:%d 0x8144:0x%x\n",
+			 xhci->num_active_tt_intr_eps, change, readl(reg));
+	}
+}
+
 static void xhci_zero_in_ctx(struct xhci_hcd *xhci, struct xhci_virt_device *virt_dev)
 {
 	struct xhci_input_control_ctx *ctrl_ctx;
@@ -2937,6 +2984,7 @@ int xhci_check_bandwidth(struct usb_hcd *hcd, struct usb_device *udev)
 	for (i = 1; i < 31; i++) {
 		if ((le32_to_cpu(ctrl_ctx->drop_flags) & (1 << (i + 1))) &&
 		    !(le32_to_cpu(ctrl_ctx->add_flags) & (1 << (i + 1)))) {
+			xhci_track_intr_eps_quirk(xhci, &virt_dev->eps[i], -1);
 			xhci_free_endpoint_ring(xhci, virt_dev, i);
 			xhci_check_bw_drop_ep_streams(xhci, virt_dev, i);
 		}
@@ -2953,11 +3001,13 @@ int xhci_check_bandwidth(struct usb_hcd *hcd, struct usb_device *udev)
 		 * It may not if this is the first add of an endpoint.
 		 */
 		if (virt_dev->eps[i].ring) {
+			xhci_track_intr_eps_quirk(xhci, &virt_dev->eps[i], -1);
 			xhci_free_endpoint_ring(xhci, virt_dev, i);
 		}
 		xhci_check_bw_drop_ep_streams(xhci, virt_dev, i);
 		virt_dev->eps[i].ring = virt_dev->eps[i].new_ring;
 		virt_dev->eps[i].new_ring = NULL;
+		xhci_track_intr_eps_quirk(xhci, &virt_dev->eps[i], 1);
 		xhci_debugfs_create_endpoint(xhci, virt_dev, i);
 	}
 command_cleanup:
@@ -3776,6 +3826,7 @@ static int xhci_discover_or_reset_device(struct usb_hcd *hcd,
 
 		if (ep->ring) {
 			xhci_debugfs_remove_endpoint(xhci, virt_dev, i);
+			xhci_track_intr_eps_quirk(xhci, ep, -1);
 			xhci_free_endpoint_ring(xhci, virt_dev, i);
 		}
 		if (!list_empty(&virt_dev->eps[i].bw_endpoint_list))
@@ -3830,8 +3881,12 @@ static void xhci_free_dev(struct usb_hcd *hcd, struct usb_device *udev)
 	trace_xhci_free_dev(slot_ctx);
 
 	/* Stop any wayward timer functions (which may grab the lock) */
-	for (i = 0; i < 31; i++)
+	for (i = 0; i < 31; i++) {
 		virt_dev->eps[i].ep_state &= ~EP_STOP_CMD_PENDING;
+		/* eps should be dropped, but if not then track them correctly */
+		xhci_track_intr_eps_quirk(xhci, &virt_dev->eps[i], -1);
+	}
+
 	virt_dev->udev = NULL;
 	xhci_disable_slot(xhci, udev->slot_id);
 
diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 7749499ed32a..7b1c7ef944db 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1905,6 +1905,7 @@ struct xhci_hcd {
 #define XHCI_ZHAOXIN_HOST	BIT_ULL(46)
 
 	unsigned int		num_active_eps;
+	unsigned int		num_active_tt_intr_eps;
 	unsigned int		limit_active_eps;
 	struct xhci_port	*hw_ports;
 	struct xhci_hub		usb2_rhub;
-- 
2.25.1

