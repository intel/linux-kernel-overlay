From 0c51766a7f12c98b2faff72562110141fad8006a Mon Sep 17 00:00:00 2001
From: Wyatt Wood <wyatt.wood@amd.com>
Date: Wed, 24 Nov 2021 12:50:20 -0500
Subject: [PATCH 2019/2399] drm/amd/display: Prevent PSR disable/reenable in
 HPD IRQ

[Why]
When HPD IRQ occurs, it triggers a PSR disable and reenable
directly through dc layer.
Since it does not pass through the power layer, the layer
that tracks whether PSR is enabled or disabled and which
masks are set, this layer is now out of sync with the real
PSR state in FW.
Theoretically PSR can be enabled during hw programming
sequences or any other situation where we must disable PSR.

[How]
Check if PSR is enabled before doing PSR disable/reenable.

Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
Acked-by: Pavle Kotarac <Pavle.Kotarac@amd.com>
Signed-off-by: Wyatt Wood <wyatt.wood@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
---
 drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c | 11 ++++++-----
 1 file changed, 6 insertions(+), 5 deletions(-)

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c
index 0534f17e3676..ed949717e90d 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c
@@ -3841,7 +3841,6 @@ static bool handle_hpd_irq_psr_sink(struct dc_link *link)
 		&psr_configuration.raw,
 		sizeof(psr_configuration.raw));
 
-
 	if (psr_configuration.bits.ENABLE) {
 		unsigned char dpcdbuf[3] = {0};
 		union psr_error_status psr_error_status;
@@ -3873,10 +3872,12 @@ static bool handle_hpd_irq_psr_sink(struct dc_link *link)
 				sizeof(psr_error_status.raw));
 
 			/* PSR error, disable and re-enable PSR */
-			allow_active = false;
-			dc_link_set_psr_allow_active(link, &allow_active, true, false, NULL);
-			allow_active = true;
-			dc_link_set_psr_allow_active(link, &allow_active, true, false, NULL);
+			if (link->psr_settings.psr_allow_active) {
+				allow_active = false;
+				dc_link_set_psr_allow_active(link, &allow_active, true, false, NULL);
+				allow_active = true;
+				dc_link_set_psr_allow_active(link, &allow_active, true, false, NULL);
+			}
 
 			return true;
 		} else if (psr_sink_psr_status.bits.SINK_SELF_REFRESH_STATUS ==
-- 
2.25.1

