From b92925c98ba21c9260c923b0d4689798a7849332 Mon Sep 17 00:00:00 2001
From: Zhengjun Xing <zhengjun.xing@linux.intel.com>
Date: Tue, 29 Mar 2022 00:20:05 +0800
Subject: [PATCH 07/20] =?UTF-8?q?perf=20stat:=20Add=20topdown=20metrics=20?=
 =?UTF-8?q?in=20default=20=E2=80=98perf=20stat=E2=80=99=20on=20the=20hybri?=
 =?UTF-8?q?d=20machine?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Topdwon metrics is missed in default ‘perf stat’ on the hybrid machine,
add topdown metrics in default ‘perf stat’for hybrid systems.

In the default perf stat only support topdown events on the cpu_core.
For the cpu_atom, we should not enable all topdown events as default
perf stat because of the multiplexing for now. Widen the size of the
event name column by 7 chars, so that all metrics after the # become
aligned again.

Perf should not trigger any warning or multiplexing for the default
of perf stat. So the warning message will not print for the default
of the perf stat.

Before:
 # perf stat     /bin/true

 Performance counter stats for '/bin/true':

              0.51 msec task-clock                #    0.455 CPUs utilized
                 0      context-switches          #    0.000 /sec
                 0      cpu-migrations            #    0.000 /sec
                43      page-faults               #   83.680 K/sec
           691,740      cpu_core/cycles/          #    1.346 G/sec
     <not counted>      cpu_atom/cycles/                                              (0.00%)
           723,832      cpu_core/instructions/    #    1.409 G/sec
     <not counted>      cpu_atom/instructions/                                        (0.00%)
           144,017      cpu_core/branches/        #  280.262 M/sec
     <not counted>      cpu_atom/branches/                                            (0.00%)
             4,617      cpu_core/branch-misses/   #    8.985 M/sec
     <not counted>      cpu_atom/branch-misses/                                       (0.00%)

       0.001129270 seconds time elapsed

       0.001190000 seconds user
       0.000000000 seconds sys

After:
 # ./perf stat     /bin/true

 Performance counter stats for 'system wide':

             31.77 msec cpu-clock                        #   24.396 CPUs utilized
                72      context-switches                 #    2.266 K/sec
                24      cpu-migrations                   #  755.340 /sec
                 1      page-faults                      #   31.472 /sec
         1,567,769      cpu_core/cycles/                 #   49.342 M/sec
           859,364      cpu_core/instructions/           #   27.046 M/sec
           170,712      cpu_core/branches/               #    5.373 M/sec
             6,424      cpu_core/branch-misses/          #  202.179 K/sec
         7,305,978      cpu_core/slots/                  #  229.937 M/sec
         1,075,531      cpu_core/topdown-retiring/       #     14.7% retiring
           513,565      cpu_core/topdown-bad-spec/       #      7.0% bad speculation
         3,231,017      cpu_core/topdown-fe-bound/       #     44.2% frontend bound
         2,486,414      cpu_core/topdown-be-bound/       #     34.0% backend bound
           294,774      cpu_core/topdown-heavy-ops/      #      4.0% heavy operations       #     10.7% light operations
           497,022      cpu_core/topdown-br-mispredict/  #      6.8% branch mispredict      #      0.2% machine clears
         2,429,919      cpu_core/topdown-fetch-lat/      #     33.3% fetch latency          #     11.0% fetch bandwidth
         1,180,796      cpu_core/topdown-mem-bound/      #     16.2% memory bound           #     17.9% Core bound

       0.001302422 seconds time elapsed

       0.000000000 seconds user
       0.000000000 seconds sys

Signed-off-by: Zhengjun Xing <zhengjun.xing@linux.intel.com>
---
 tools/perf/arch/x86/util/evlist.c | 32 ++++++++++++++++++++-----
 tools/perf/builtin-stat.c         | 39 ++++++++++++++++++-------------
 tools/perf/util/evlist.c          |  2 +-
 tools/perf/util/evlist.h          |  2 +-
 tools/perf/util/stat-display.c    |  2 +-
 5 files changed, 52 insertions(+), 25 deletions(-)

diff --git a/tools/perf/arch/x86/util/evlist.c b/tools/perf/arch/x86/util/evlist.c
index cfc208d71f00..69ebce5e066e 100644
--- a/tools/perf/arch/x86/util/evlist.c
+++ b/tools/perf/arch/x86/util/evlist.c
@@ -5,17 +5,37 @@
 #include "util/parse-events.h"
 
 #define TOPDOWN_L1_EVENTS	"{slots,topdown-retiring,topdown-bad-spec,topdown-fe-bound,topdown-be-bound}"
+#define TOPDOWN_L1_EVENTS_ATOM  "{cpu_atom/topdown-retiring/,cpu_atom/topdown-bad-spec/,cpu_atom/topdown-fe-bound/,cpu_atom/topdown-be-bound/}"
+#define TOPDOWN_L1_EVENTS_CORE  "{slots,cpu_core/topdown-retiring/,cpu_core/topdown-bad-spec/,cpu_core/topdown-fe-bound/,cpu_core/topdown-be-bound/}"
 #define TOPDOWN_L2_EVENTS	"{slots,topdown-retiring,topdown-bad-spec,topdown-fe-bound,topdown-be-bound,topdown-heavy-ops,topdown-br-mispredict,topdown-fetch-lat,topdown-mem-bound}"
+#define TOPDOWN_L2_EVENTS_ATOM  "{cpu_atom/topdown-retiring/,cpu_atom/topdown-bad-spec/,cpu_atom/topdown-fe-bound/,cpu_atom/topdown-be-bound/,cpu_atom/topdown-heavy-ops/,cpu_atom/topdown-br-mispredict/,cpu_atom/topdown-fetch-lat/,cpu_atom/topdown-mem-bound/}"
+#define TOPDOWN_L2_EVENTS_CORE  "{slots,cpu_core/topdown-retiring/,cpu_core/topdown-bad-spec/,cpu_core/topdown-fe-bound/,cpu_core/topdown-be-bound/,cpu_core/topdown-heavy-ops/,cpu_core/topdown-br-mispredict/,cpu_core/topdown-fetch-lat/,cpu_core/topdown-mem-bound/}"
 
-int arch_evlist__add_default_attrs(struct evlist *evlist)
+int arch_evlist__add_default_attrs(struct evlist *evlist, const char *pmu_name)
 {
-	if (!pmu_have_event("cpu", "slots"))
+	const char *topdown_events;
+
+	if (!pmu_name)
 		return 0;
+	if (strcmp(pmu_name, "cpu_atom") && !pmu_have_event(pmu_name, "slots"))
+		return 0;
+	if (pmu_have_event(pmu_name, "topdown-heavy-ops")){
+		if(!strcmp(pmu_name, "cpu_core"))
+			topdown_events = TOPDOWN_L2_EVENTS_CORE;
+		else if(!strcmp(pmu_name, "cpu_atom"))
+			topdown_events = TOPDOWN_L2_EVENTS_ATOM;
+		else
+			topdown_events = TOPDOWN_L2_EVENTS;
+	}else{
+		if(!strcmp(pmu_name, "cpu_core"))
+			topdown_events = TOPDOWN_L1_EVENTS_CORE;
+		else if(!strcmp(pmu_name, "cpu_atom"))
+			topdown_events = TOPDOWN_L1_EVENTS_ATOM;
+		else
+			topdown_events = TOPDOWN_L1_EVENTS;
+	}
 
-	if (pmu_have_event("cpu", "topdown-heavy-ops"))
-		return parse_events(evlist, TOPDOWN_L2_EVENTS, NULL);
-	else
-		return parse_events(evlist, TOPDOWN_L1_EVENTS, NULL);
+	return parse_events(evlist, topdown_events, NULL);
 }
 
 struct evsel *arch_evlist__leader(struct list_head *list)
diff --git a/tools/perf/builtin-stat.c b/tools/perf/builtin-stat.c
index 2b73daafdcfd..b7fe88beb584 100644
--- a/tools/perf/builtin-stat.c
+++ b/tools/perf/builtin-stat.c
@@ -98,6 +98,7 @@
 #define FREEZE_ON_SMI_PATH	"devices/cpu/freeze_on_smi"
 
 static void print_counters(struct timespec *ts, int argc, const char **argv);
+const char * get_topdown_pmu_name(bool pr_warn);
 
 /* Default events used for perf stat -T */
 static const char *transaction_attrs = {
@@ -1640,6 +1641,20 @@ static int perf_stat_init_aggr_mode_file(struct perf_stat *st)
 	return 0;
 }
 
+const char * get_topdown_pmu_name(bool pr_warn)
+{
+	const char *pmu_name = "cpu";
+	if (perf_pmu__has_hybrid()) {
+		if (!evsel_list->hybrid_pmu_name) {
+			if(pr_warn)
+				pr_warning("WARNING: default to use cpu_core topdown events\n");
+			evsel_list->hybrid_pmu_name = perf_pmu__hybrid_type_to_pmu("core");
+		}
+		pmu_name = evsel_list->hybrid_pmu_name;
+	}
+	return pmu_name;
+}
+
 /*
  * Add default attributes, if there were no attributes specified or
  * if -d/--detailed, -d -d or -d -d -d is used:
@@ -1843,22 +1858,11 @@ static int add_default_attributes(void)
 		unsigned int max_level = 1;
 		char *str = NULL;
 		bool warn = false;
-		const char *pmu_name = "cpu";
+		const char *pmu_name = get_topdown_pmu_name(true);
 
 		if (!force_metric_only)
 			stat_config.metric_only = true;
 
-		if (perf_pmu__has_hybrid()) {
-			if (!evsel_list->hybrid_pmu_name) {
-				pr_warning("WARNING: default to use cpu_core topdown events\n");
-				evsel_list->hybrid_pmu_name = perf_pmu__hybrid_type_to_pmu("core");
-			}
-
-			pmu_name = evsel_list->hybrid_pmu_name;
-			if (!pmu_name)
-				return -1;
-		}
-
 		if (pmu_have_event(pmu_name, topdown_metric_L2_attrs[5])) {
 			metric_attrs = topdown_metric_L2_attrs;
 			max_level = 2;
@@ -1932,7 +1936,7 @@ static int add_default_attributes(void)
 		if (perf_pmu__has_hybrid()) {
 			struct parse_events_error errinfo;
 			const char *hybrid_str = "cycles,instructions,branches,branch-misses";
-
+			target.system_wide = true;
 			if (target__has_cpu(&target))
 				default_sw_attrs[0].config = PERF_COUNT_SW_CPU_CLOCK;
 
@@ -1950,7 +1954,10 @@ static int add_default_attributes(void)
 				parse_events_error__print(&errinfo, hybrid_str);
 			}
 			parse_events_error__exit(&errinfo);
-			return err ? -1 : 0;
+			if(err)
+				return -1;
+			else
+				goto default_topdown;
 		}
 
 		if (target__has_cpu(&target))
@@ -1968,9 +1975,9 @@ static int add_default_attributes(void)
 		}
 		if (evlist__add_default_attrs(evsel_list, default_attrs1) < 0)
 			return -1;
-
+default_topdown:
 		stat_config.topdown_level = TOPDOWN_MAX_LEVEL;
-		if (arch_evlist__add_default_attrs(evsel_list) < 0)
+		if (arch_evlist__add_default_attrs(evsel_list, get_topdown_pmu_name(false)) < 0)
 			return -1;
 	}
 
diff --git a/tools/perf/util/evlist.c b/tools/perf/util/evlist.c
index 52ea004ba01e..450783bdc0ab 100644
--- a/tools/perf/util/evlist.c
+++ b/tools/perf/util/evlist.c
@@ -291,7 +291,7 @@ int __evlist__add_default_attrs(struct evlist *evlist, struct perf_event_attr *a
 	return evlist__add_attrs(evlist, attrs, nr_attrs);
 }
 
-__weak int arch_evlist__add_default_attrs(struct evlist *evlist __maybe_unused)
+__weak int arch_evlist__add_default_attrs(struct evlist *evlist __maybe_unused, const char *pmu_name __maybe_unused)
 {
 	return 0;
 }
diff --git a/tools/perf/util/evlist.h b/tools/perf/util/evlist.h
index a21daaa5fc1b..80cb1e604b18 100644
--- a/tools/perf/util/evlist.h
+++ b/tools/perf/util/evlist.h
@@ -110,7 +110,7 @@ int __evlist__add_default_attrs(struct evlist *evlist,
 #define evlist__add_default_attrs(evlist, array) \
 	__evlist__add_default_attrs(evlist, array, ARRAY_SIZE(array))
 
-int arch_evlist__add_default_attrs(struct evlist *evlist);
+int arch_evlist__add_default_attrs(struct evlist *evlist, const char *pmu_name);
 struct evsel *arch_evlist__leader(struct list_head *list);
 
 int evlist__add_dummy(struct evlist *evlist);
diff --git a/tools/perf/util/stat-display.c b/tools/perf/util/stat-display.c
index 53bc45bf1691..9378cd31099c 100644
--- a/tools/perf/util/stat-display.c
+++ b/tools/perf/util/stat-display.c
@@ -374,7 +374,7 @@ static void abs_printout(struct perf_stat_config *config,
 			config->csv_output ? 0 : config->unit_width,
 			evsel->unit, config->csv_sep);
 
-	fprintf(output, "%-*s", config->csv_output ? 0 : 25, evsel__name(evsel));
+	fprintf(output, "%-*s", config->csv_output ? 0 : 32, evsel__name(evsel));
 
 	print_cgroup(config, evsel);
 }
-- 
2.25.1

