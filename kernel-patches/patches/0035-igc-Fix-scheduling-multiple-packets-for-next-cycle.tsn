From 7278510702824640122dbb7501a7015db460c0bd Mon Sep 17 00:00:00 2001
From: Aravindhan Gunasekaran <aravindhan.gunasekaran@intel.com>
Date: Fri, 22 Oct 2021 20:19:19 +0530
Subject: [PATCH 35/40] igc: Fix scheduling multiple packets for next cycle

If we need to schedule multiple packets for the next
cycle, "First flag" to be set only on the first packet.
Following packets shall have inactive first flag. Two
consecutive packets both having "First flag" arriving
in current cycle, first packet gets scheduled for next
cycle and second one next-to-next cycle.

Packet with launchtime greater than cycle-time is not
supported. So, we will not have a case where more than
one packet in a cycle has an active "First flag".

Signed-off-by: Aravindhan Gunasekaran <aravindhan.gunasekaran@intel.com>
---
 drivers/net/ethernet/intel/igc/igc.h      | 1 +
 drivers/net/ethernet/intel/igc/igc_main.c | 9 ++++++---
 2 files changed, 7 insertions(+), 3 deletions(-)

diff --git a/drivers/net/ethernet/intel/igc/igc.h b/drivers/net/ethernet/intel/igc/igc.h
index 65862f60467d..80d0f6c40038 100644
--- a/drivers/net/ethernet/intel/igc/igc.h
+++ b/drivers/net/ethernet/intel/igc/igc.h
@@ -98,6 +98,7 @@ struct igc_ring {
 	bool launchtime_enable;         /* true if LaunchTime is enabled */
 	bool preemptible;               /* true if not express */
 	ktime_t last_tx_cycle;          /* end of the cycle with a launchtime transmission */
+	ktime_t last_ff_cycle;          /* Last cycle with an active first flag */
 
 	u32 start_time;
 	u32 end_time;
diff --git a/drivers/net/ethernet/intel/igc/igc_main.c b/drivers/net/ethernet/intel/igc/igc_main.c
index b82a8414aadc..d307799fe4c5 100644
--- a/drivers/net/ethernet/intel/igc/igc_main.c
+++ b/drivers/net/ethernet/intel/igc/igc_main.c
@@ -1022,10 +1022,13 @@ static __le32 igc_tx_launchtime(struct igc_ring *ring, ktime_t txtime,
 	end_of_cycle = ktime_add_ns(baset_est, cycle_time);
 
 	if (ktime_compare(txtime, end_of_cycle) >= 0) {
-		*first_flag = true;
+		if (baset_est != ring->last_ff_cycle) {
+			*first_flag = true;
+			ring->last_ff_cycle = baset_est;
 
-		if (ktime_compare(txtime, ring->last_tx_cycle) > 0)
-			*insert_empty = true;
+			if (ktime_compare(txtime, ring->last_tx_cycle) > 0)
+				*insert_empty = true;
+		}
 	}
 
 	ring->last_tx_cycle = end_of_cycle;
-- 
2.25.1

