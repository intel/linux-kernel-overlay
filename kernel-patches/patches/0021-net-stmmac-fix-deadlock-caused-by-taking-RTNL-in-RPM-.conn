From e7cc78d28fbf787890bb1882760f3b223345b59b Mon Sep 17 00:00:00 2001
From: "Goh, Wei Sheng" <wei.sheng.goh@intel.com>
Date: Wed, 6 Jul 2022 10:51:49 +0800
Subject: [PATCH 21/40] net: stmmac: fix deadlock caused by taking RTNL in RPM
 resume path

Adding a layer of control logic to prevent
deadlock occurrence in RPM resume path for stmmac.

Fixes: fb754f7c89df ("net: stmmac: enable runtime power management support")
Signed-off-by: Goh, Wei Sheng <wei.sheng.goh@intel.com>
Signed-off-by: Noor Azura Ahmad Tarmizi <noor.azura.ahmad.tarmizi@intel.com>
---
 .../net/ethernet/stmicro/stmmac/dwmac-intel.c | 20 +++++++++++---
 drivers/net/ethernet/stmicro/stmmac/stmmac.h  |  1 +
 .../net/ethernet/stmicro/stmmac/stmmac_main.c | 26 ++++++++++++++-----
 3 files changed, 38 insertions(+), 9 deletions(-)

diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac-intel.c b/drivers/net/ethernet/stmicro/stmmac/dwmac-intel.c
index 34c0039cbae36..aeca1fc675be9 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac-intel.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac-intel.c
@@ -1250,13 +1250,26 @@ static int __maybe_unused intel_eth_runtime_resume(struct device *dev)
 	struct pci_dev *pdev = to_pci_dev(dev);
 	struct net_device *ndev = dev_get_drvdata(&pdev->dev);
 	struct stmmac_priv *priv = netdev_priv(ndev);
+	bool lock;
 	int ret;
 
-	ret = intel_eth_pci_resume(dev);
+	lock = !!rtnl_is_locked();
+
+	pci_restore_state(pdev);
+	pci_set_power_state(pdev, PCI_D0);
+
+	ret = pcim_enable_device(pdev);
+	if (ret)
+		return ret;
+
+	pci_set_master(pdev);
+
+	ret = stmmac_resume_runtime(dev, lock);
 	if (!ret)
 		dev_info(dev, "%s: Device is runtime resumed.\n", __func__);
 
-	rtnl_lock();
+	if (!lock)
+		rtnl_lock();
 	/* Restore saved WoL operation */
 #ifdef CONFIG_PM
 	wol.wolopts = priv->saved_wolopts;
@@ -1265,7 +1278,8 @@ static int __maybe_unused intel_eth_runtime_resume(struct device *dev)
 #ifdef CONFIG_PM
 	priv->saved_wolopts = 0;
 #endif
-	rtnl_unlock();
+	if (!lock)
+		rtnl_unlock();
 
 	if (!wol.wolopts)
 		device_set_wakeup_enable(priv->device, 0);
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac.h b/drivers/net/ethernet/stmicro/stmmac/stmmac.h
index 6a56d163e6a4e..a1c4b4441bdfd 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac.h
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac.h
@@ -354,6 +354,7 @@ void stmmac_ptp_unregister(struct stmmac_priv *priv);
 int stmmac_xdp_open(struct net_device *dev);
 void stmmac_xdp_release(struct net_device *dev);
 int stmmac_resume(struct device *dev);
+int stmmac_resume_runtime(struct device *dev, bool rpm);
 int stmmac_suspend(struct device *dev);
 int stmmac_dvr_remove(struct device *dev);
 int stmmac_dvr_probe(struct device *device,
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
index 1e60860d4e066..ddb7a81fd4e53 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
@@ -7603,12 +7603,13 @@ static void stmmac_reset_queues_param(struct stmmac_priv *priv)
 }
 
 /**
- * stmmac_resume - resume callback
+ * stmmac_resume_runtime - resume callback
  * @dev: device pointer
+ * @rpm: rtnl_lock check
  * Description: when resume this function is invoked to setup the DMA and CORE
  * in a usable state.
  */
-int stmmac_resume(struct device *dev)
+int stmmac_resume_runtime(struct device *dev, bool rpm)
 {
 	struct net_device *ndev = dev_get_drvdata(dev);
 	struct stmmac_priv *priv = netdev_priv(ndev);
@@ -7643,7 +7644,8 @@ int stmmac_resume(struct device *dev)
 			return ret;
 	}
 
-	rtnl_lock();
+	if (!rpm)
+		rtnl_lock();
 	if (device_may_wakeup(priv->device) && priv->plat->pmt) {
 		phylink_resume(priv->phylink);
 	} else {
@@ -7651,9 +7653,7 @@ int stmmac_resume(struct device *dev)
 		if (device_may_wakeup(priv->device))
 			phylink_speed_up(priv->phylink);
 	}
-	rtnl_unlock();
 
-	rtnl_lock();
 	mutex_lock(&priv->lock);
 
 	stmmac_reset_queues_param(priv);
@@ -7671,12 +7671,26 @@ int stmmac_resume(struct device *dev)
 	stmmac_enable_all_dma_irq(priv);
 
 	mutex_unlock(&priv->lock);
-	rtnl_unlock();
+	if (!rpm)
+		rtnl_unlock();
+
 
 	netif_device_attach(ndev);
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(stmmac_resume_runtime);
+
+/**
+ * stmmac_resume - resume callback
+ * @dev: device pointer
+ * Description: when resume this function is invoked to setup the DMA and CORE
+ * in a usable state.
+ */
+int stmmac_resume(struct device *dev)
+{
+	return stmmac_resume_runtime(dev, false);
+}
 EXPORT_SYMBOL_GPL(stmmac_resume);
 
 #ifndef MODULE
-- 
2.25.1

