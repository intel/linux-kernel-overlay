From 872737c4cf90e060008c1045ab608f691bfbc464 Mon Sep 17 00:00:00 2001
From: Ankit Nautiyal <ankit.k.nautiyal@intel.com>
Date: Tue, 24 Jan 2023 20:03:53 +0530
Subject: [PATCH 1077/1096] drm/i915/vrr/mtl: Calculate Vmax Vmin for HDMI2.1

Currently Vmax and Vmin are calculated for DP. Add function
to calculate VMax and Vmin as per HDMI2.1 spec

v2: Dropped the adjustment for fractional rates.
Added comment for cases where VRR max is taken as BRR. (Manasi)
Corrected the Vmax calculation. (Manasi).

Signed-off-by: Ankit Nautiyal <ankit.k.nautiyal@intel.com>
Reviewed-by: Manasi Navare <manasi.d.navare@intel.com>
---
 drivers/gpu/drm/i915/display/intel_vrr.c | 56 +++++++++++++++++++++---
 1 file changed, 51 insertions(+), 5 deletions(-)

diff --git a/drivers/gpu/drm/i915/display/intel_vrr.c b/drivers/gpu/drm/i915/display/intel_vrr.c
index 55f9ef585dc5..b69e9ab6a7cd 100644
--- a/drivers/gpu/drm/i915/display/intel_vrr.c
+++ b/drivers/gpu/drm/i915/display/intel_vrr.c
@@ -112,6 +112,47 @@ int intel_vrr_vmax_vblank_start(const struct intel_crtc_state *crtc_state)
 	return crtc_state->vrr.vmax - intel_vrr_vblank_exit_length(crtc_state);
 }
 
+static void
+intel_vrr_hdmi_get_vmin_max(struct drm_display_mode *adjusted_mode,
+			    struct intel_connector *connector,
+			    int *vmin, int *vmax)
+{
+	struct drm_display_info *info = &connector->base.display_info;
+	struct drm_hdmi_info *hdmi = &info->hdmi;
+	int brr, vrr_max;
+
+	brr = drm_mode_vrefresh(adjusted_mode);
+	vrr_max = hdmi->vrr_cap.vrr_max;
+	/*
+	 * As per HDMI2.1 spec, VRR max is optional and lowest valid value is
+	 * 100 Hz. For cases where VRR max is not given or when BRR
+	 * (Base Refresh-Rate) is less than or equal to VRR max, the
+	 * upper-limit is taken as the BRR only.
+	 * Vmin in that case will be equal to VTotal.
+	 */
+	if (vrr_max < 100 || brr <= vrr_max)
+		*vmin = adjusted_mode->crtc_vtotal;
+	else
+		*vmin = DIV_ROUND_UP(adjusted_mode->crtc_clock * 1000,
+				     adjusted_mode->crtc_htotal * vrr_max);
+
+	*vmax = adjusted_mode->crtc_clock * 1000 /
+		(adjusted_mode->crtc_htotal * hdmi->vrr_cap.vrr_min);
+}
+
+static void
+intel_vrr_dp_get_vmin_max(struct drm_display_mode *adjusted_mode,
+			  struct intel_connector *connector,
+			  int *vmin, int *vmax)
+{
+	const struct drm_display_info *info = &connector->base.display_info;
+
+	*vmin = DIV_ROUND_UP(adjusted_mode->crtc_clock * 1000,
+			     adjusted_mode->crtc_htotal * info->monitor_range.max_vfreq);
+	*vmax = adjusted_mode->crtc_clock * 1000 /
+		(adjusted_mode->crtc_htotal * info->monitor_range.min_vfreq);
+}
+
 void
 intel_vrr_compute_config(struct intel_crtc_state *crtc_state,
 			 struct drm_connector_state *conn_state)
@@ -121,7 +162,6 @@ intel_vrr_compute_config(struct intel_crtc_state *crtc_state,
 	struct intel_connector *connector =
 		to_intel_connector(conn_state->connector);
 	struct drm_display_mode *adjusted_mode = &crtc_state->hw.adjusted_mode;
-	const struct drm_display_info *info = &connector->base.display_info;
 	int vmin, vmax;
 
 	if (!intel_vrr_is_capable(connector))
@@ -133,10 +173,16 @@ intel_vrr_compute_config(struct intel_crtc_state *crtc_state,
 	if (!crtc_state->uapi.vrr_enabled)
 		return;
 
-	vmin = DIV_ROUND_UP(adjusted_mode->crtc_clock * 1000,
-			    adjusted_mode->crtc_htotal * info->monitor_range.max_vfreq);
-	vmax = adjusted_mode->crtc_clock * 1000 /
-		(adjusted_mode->crtc_htotal * info->monitor_range.min_vfreq);
+	if (connector->base.connector_type == DRM_MODE_CONNECTOR_eDP ||
+	    connector->base.connector_type == DRM_MODE_CONNECTOR_DisplayPort)
+		intel_vrr_dp_get_vmin_max(adjusted_mode, connector, &vmin, &vmax);
+
+	else if (connector->base.connector_type == DRM_MODE_CONNECTOR_HDMIA ||
+		 connector->base.connector_type == DRM_MODE_CONNECTOR_HDMIB)
+		intel_vrr_hdmi_get_vmin_max(adjusted_mode, connector, &vmin, &vmax);
+
+	else
+		return;
 
 	vmin = max_t(int, vmin, adjusted_mode->crtc_vtotal);
 	vmax = max_t(int, vmax, adjusted_mode->crtc_vtotal);
-- 
2.25.1

