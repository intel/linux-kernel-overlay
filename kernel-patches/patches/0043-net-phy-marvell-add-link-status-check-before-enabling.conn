From 3bd51986b32893f8fdd4821a39c1bad68d462863 Mon Sep 17 00:00:00 2001
From: Aminuddin Jamaluddin <aminuddin.jamaluddin@intel.com>
Date: Mon, 25 Jul 2022 13:30:11 +0800
Subject: [PATCH 43/54] net: phy: marvell: add link status check before
 enabling phy loopback

Add link status checking in m88e1510_loopback(),
master/slave training by calling the
__genphy_setup_master_slave() for 1Gbps link speed
before enabling phy loopback and msleep() for 100ms
after phy loopback bit set. All this step were
to ensure the stability and consistency when running
the test.

Signed-off-by: Muhammad Husaini Zulkifli <muhammad.husaini.zulkifli@intel.com>
Signed-off-by: Aminuddin Jamaluddin <aminuddin.jamaluddin@intel.com>
---
 drivers/net/phy/marvell.c | 27 +++++++++++++++++++++------
 include/linux/phy.h       |  3 +++
 2 files changed, 24 insertions(+), 6 deletions(-)

diff --git a/drivers/net/phy/marvell.c b/drivers/net/phy/marvell.c
index 4d726ee03ce2..d9e50400f40f 100644
--- a/drivers/net/phy/marvell.c
+++ b/drivers/net/phy/marvell.c
@@ -1947,6 +1947,7 @@ static int m88e1510_loopback(struct phy_device *phydev, bool enable)
 
 	if (enable) {
 		u16 bmcr_ctl = 0, mscr2_ctl = 0;
+		int val = 0;
 
 		if (phydev->speed == SPEED_1000)
 			bmcr_ctl = BMCR_SPEED1000;
@@ -1976,14 +1977,28 @@ static int m88e1510_loopback(struct phy_device *phydev, bool enable)
 		if (err < 0)
 			return err;
 
-		/* FIXME: Based on trial and error test, it seem 1G need to have
-		 * delay between soft reset and loopback enablement.
-		 */
-		if (phydev->speed == SPEED_1000)
-			msleep(1000);
+		if (phydev->speed == SPEED_1000) {
+			/* Setting up the master/slave training for 1Gbps */
+			err = __genphy_setup_master_slave(phydev);
+			if (err)
+				return err;
+
+			err = phy_read_poll_timeout(phydev, MII_BMSR, val, val & BMSR_LSTATUS,
+						    PHY_LOOP_BACK_SLEEP,
+						    PHY_LOOP_BACK_TIMEOUT, true);
+			if (err)
+				return err;
+		}
 
-		return phy_modify(phydev, MII_BMCR, BMCR_LOOPBACK,
+		err =  phy_modify(phydev, MII_BMCR, BMCR_LOOPBACK,
 				  BMCR_LOOPBACK);
+		if (!err) {
+			/* It takes some time for PHY device to switch
+			 * into/out-of loopback mode.
+			 */
+			msleep(100);
+		}
+		return err;
 	} else {
 		err = phy_modify(phydev, MII_BMCR, BMCR_LOOPBACK, 0);
 		if (err < 0)
diff --git a/include/linux/phy.h b/include/linux/phy.h
index f1b64db5ef69..76836d723d5b 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -242,6 +242,9 @@ static inline const char *phy_modes(phy_interface_t interface)
 #define PHY_INIT_TIMEOUT	100000
 #define PHY_FORCE_TIMEOUT	10
 
+#define PHY_LOOP_BACK_SLEEP	1000000
+#define PHY_LOOP_BACK_TIMEOUT	8000000
+
 #define PHY_MAX_ADDR	32
 
 /* Used when trying to connect to a specific phy (mii bus id:phy device id) */
-- 
2.25.1

