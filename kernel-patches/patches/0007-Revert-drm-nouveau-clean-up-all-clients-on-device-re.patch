From fef4ddf0b001475ae820b908522d01b376745fd9 Mon Sep 17 00:00:00 2001
From: Ranjan Dutta <ranjan.dutta@intel.com>
Date: Tue, 7 Dec 2021 01:20:56 +0800
Subject: [PATCH 07/33] Revert "drm/nouveau: clean up all clients on device
 removal"

This reverts commit 82de15ca6b5574fc0e2f54daa1de00b5b2dcf32f.
---
 drivers/gpu/drm/nouveau/nouveau_drm.c | 30 ---------------------------
 1 file changed, 30 deletions(-)

diff --git a/drivers/gpu/drm/nouveau/nouveau_drm.c b/drivers/gpu/drm/nouveau/nouveau_drm.c
index ac96b6ab44c0..8201e9d11df9 100644
--- a/drivers/gpu/drm/nouveau/nouveau_drm.c
+++ b/drivers/gpu/drm/nouveau/nouveau_drm.c
@@ -628,7 +628,6 @@ nouveau_drm_device_init(struct drm_device *dev)
 static void
 nouveau_drm_device_fini(struct drm_device *dev)
 {
-	struct nouveau_cli *cli, *temp_cli;
 	struct nouveau_drm *drm = nouveau_drm(dev);
 
 	if (nouveau_pmops_runtime()) {
@@ -653,24 +652,6 @@ nouveau_drm_device_fini(struct drm_device *dev)
 	nouveau_ttm_fini(drm);
 	nouveau_vga_fini(drm);
 
-	/*
-	 * There may be existing clients from as-yet unclosed files. For now,
-	 * clean them up here rather than deferring until the file is closed,
-	 * but this likely not correct if we want to support hot-unplugging
-	 * properly.
-	 */
-	mutex_lock(&drm->clients_lock);
-	list_for_each_entry_safe(cli, temp_cli, &drm->clients, head) {
-		list_del(&cli->head);
-		mutex_lock(&cli->mutex);
-		if (cli->abi16)
-			nouveau_abi16_fini(cli->abi16);
-		mutex_unlock(&cli->mutex);
-		nouveau_cli_fini(cli);
-		kfree(cli);
-	}
-	mutex_unlock(&drm->clients_lock);
-
 	nouveau_cli_fini(&drm->client);
 	nouveau_cli_fini(&drm->master);
 	nvif_parent_dtor(&drm->parent);
@@ -1127,16 +1108,6 @@ nouveau_drm_postclose(struct drm_device *dev, struct drm_file *fpriv)
 {
 	struct nouveau_cli *cli = nouveau_cli(fpriv);
 	struct nouveau_drm *drm = nouveau_drm(dev);
-	int dev_index;
-
-	/*
-	 * The device is gone, and as it currently stands all clients are
-	 * cleaned up in the removal codepath. In the future this may change
-	 * so that we can support hot-unplugging, but for now we immediately
-	 * return to avoid a double-free situation.
-	 */
-	if (!drm_dev_enter(dev, &dev_index))
-		return;
 
 	pm_runtime_get_sync(dev->dev);
 
@@ -1153,7 +1124,6 @@ nouveau_drm_postclose(struct drm_device *dev, struct drm_file *fpriv)
 	kfree(cli);
 	pm_runtime_mark_last_busy(dev->dev);
 	pm_runtime_put_autosuspend(dev->dev);
-	drm_dev_exit(dev_index);
 }
 
 static const struct drm_ioctl_desc
-- 
2.27.0

