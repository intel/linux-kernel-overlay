From 92135e4d8d845acc9507d94e05d2eee42b6e589c Mon Sep 17 00:00:00 2001
From: Zhengjun Xing <zhengjun.xing@linux.intel.com>
Date: Tue, 8 Feb 2022 18:07:08 +0800
Subject: [PATCH 05/20] perf record: Support sample-read topdown metric group
 for hybrid platforms

With the hardware TopDown metrics feature, sample-read feature should be
supported for a topdown group, e.g., sample a non-topdown event and read
a topdown metric group. But the current perf record code errors out.

For a topdown metric group, the slots event must be the leader of the
group, but the leader slots event doesn't support sampling.

To support sample-read the topdown metric group, use the 2nd event of
the group as the "leader" for the purposes of sampling.

Only the platform with Topdown metic feature supports sample-read the
topdown group. In commit acb65150a47c ("perf record: Support sample-read
topdown metric group"), it adds arch_topdown_sample_read() to indicate
whether the topdown group supports sample-read, but it should only handle
the non-hybrid case,this patch adds the support on hybrid platforms.

Fixes: acb65150a47c ("perf record: Support sample-read topdown metric
group")
Signed-off-by: Zhengjun Xing <zhengjun.xing@linux.intel.com>
---
 tools/perf/arch/x86/util/topdown.c | 10 +++++-----
 tools/perf/util/record.c           | 13 ++++++++++++-
 tools/perf/util/topdown.c          |  3 ++-
 tools/perf/util/topdown.h          |  2 +-
 4 files changed, 20 insertions(+), 8 deletions(-)

diff --git a/tools/perf/arch/x86/util/topdown.c b/tools/perf/arch/x86/util/topdown.c
index 2f3d96aa92a5..e673564b6775 100644
--- a/tools/perf/arch/x86/util/topdown.c
+++ b/tools/perf/arch/x86/util/topdown.c
@@ -30,12 +30,12 @@ void arch_topdown_group_warn(void)
 
 #define TOPDOWN_SLOTS		0x0400
 
-static bool is_topdown_slots_event(struct evsel *counter)
+static bool is_topdown_slots_event(struct evsel *counter, const char *pmu_name)
 {
 	if (!counter->pmu_name)
 		return false;
 
-	if (strcmp(counter->pmu_name, "cpu"))
+	if (strcmp(counter->pmu_name, pmu_name))
 		return false;
 
 	if (counter->core.attr.config == TOPDOWN_SLOTS)
@@ -51,12 +51,12 @@ static bool is_topdown_slots_event(struct evsel *counter)
  * event must be the leader of the topdown group.
  */
 
-bool arch_topdown_sample_read(struct evsel *leader)
+bool arch_topdown_sample_read(struct evsel *leader, const char *pmu_name)
 {
-	if (!pmu_have_event("cpu", "slots"))
+	if (!pmu_have_event(pmu_name, "slots"))
 		return false;
 
-	if (is_topdown_slots_event(leader))
+	if (is_topdown_slots_event(leader, pmu_name))
 		return true;
 
 	return false;
diff --git a/tools/perf/util/record.c b/tools/perf/util/record.c
index 5b09ecbb05dc..f5d1fd414f99 100644
--- a/tools/perf/util/record.c
+++ b/tools/perf/util/record.c
@@ -17,6 +17,8 @@
 #include "topdown.h"
 #include "map_symbol.h"
 #include "mem-events.h"
+#include "util/pmu.h"
+#include "util/pmu-hybrid.h"
 
 /*
  * evsel__config_leader_sampling() uses special rules for leader sampling.
@@ -26,8 +28,17 @@
 static struct evsel *evsel__read_sampler(struct evsel *evsel, struct evlist *evlist)
 {
 	struct evsel *leader = evsel__leader(evsel);
+	const char *pmu_name = "cpu";
 
-	if (evsel__is_aux_event(leader) || arch_topdown_sample_read(leader) ||
+	if (perf_pmu__has_hybrid()) {
+		if (!evlist->hybrid_pmu_name) {
+			pr_warning("WARNING: default to read cpu_core events\n");
+			evlist->hybrid_pmu_name = perf_pmu__hybrid_type_to_pmu("core");
+		}
+		pmu_name = evlist->hybrid_pmu_name;
+	}
+
+	if (evsel__is_aux_event(leader) || arch_topdown_sample_read(leader, pmu_name) ||
 	    is_mem_loads_aux_event(leader)) {
 		evlist__for_each_entry(evlist, evsel) {
 			if (evsel__leader(evsel) == leader && evsel != evsel__leader(evsel))
diff --git a/tools/perf/util/topdown.c b/tools/perf/util/topdown.c
index 3c8bf47488cc..ee9ec6a3aa3c 100644
--- a/tools/perf/util/topdown.c
+++ b/tools/perf/util/topdown.c
@@ -61,7 +61,8 @@ __weak void arch_topdown_group_warn(void)
 {
 }
 
-__weak bool arch_topdown_sample_read(struct evsel *leader __maybe_unused)
+__weak bool arch_topdown_sample_read(struct evsel *leader __maybe_unused,
+				     const char *pmu_name __maybe_unused)
 {
 	return false;
 }
diff --git a/tools/perf/util/topdown.h b/tools/perf/util/topdown.h
index 118e75281f93..134b7c85f66a 100644
--- a/tools/perf/util/topdown.h
+++ b/tools/perf/util/topdown.h
@@ -5,7 +5,7 @@
 
 bool arch_topdown_check_group(bool *warn);
 void arch_topdown_group_warn(void);
-bool arch_topdown_sample_read(struct evsel *leader);
+bool arch_topdown_sample_read(struct evsel *leader, const char *pmu_name);
 
 int topdown_filter_events(const char **attr, char **str, bool use_group,
 			  const char *pmu_name);
-- 
2.25.1

