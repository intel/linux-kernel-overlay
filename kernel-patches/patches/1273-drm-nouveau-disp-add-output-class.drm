From 2caaabcb092f4e5840aabce488b488f8cf7e68b6 Mon Sep 17 00:00:00 2001
From: Ben Skeggs <bskeggs@redhat.com>
Date: Wed, 1 Jun 2022 20:46:31 +1000
Subject: [PATCH 1273/2779] drm/nouveau/disp: add output class

Will be used to more cleanly implement existing method interfaces that
take some confusing (IEDTkey, inherited from VBIOS, which RM no longer
uses on Ampere) match values to determine which display path to operate
on.

Methods will be protected from racing with supervisor, and from being
called where they shouldn't be (ie. without an OR assigned).

v2:
- use ?: (lyude)
v3:
- fix return code if noacquire() method fails

Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
Signed-off-by: Dave Airlie <airlied@redhat.com>
---
 drivers/gpu/drm/nouveau/dispnv50/disp.c       |  18 ++-
 drivers/gpu/drm/nouveau/include/nvif/class.h  |   1 +
 drivers/gpu/drm/nouveau/include/nvif/disp.h   |   1 +
 drivers/gpu/drm/nouveau/include/nvif/if0010.h |   1 +
 drivers/gpu/drm/nouveau/include/nvif/if0012.h |  12 ++
 drivers/gpu/drm/nouveau/include/nvif/outp.h   |  13 +++
 .../nouveau/include/nvkm/subdev/bios/dcb.h    |   1 +
 drivers/gpu/drm/nouveau/nouveau_bios.c        |   2 +
 drivers/gpu/drm/nouveau/nouveau_encoder.h     |   3 +-
 drivers/gpu/drm/nouveau/nvif/Kbuild           |   1 +
 drivers/gpu/drm/nouveau/nvif/disp.c           |   4 +-
 drivers/gpu/drm/nouveau/nvif/outp.c           |  48 ++++++++
 .../gpu/drm/nouveau/nvkm/engine/disp/Kbuild   |   1 +
 .../gpu/drm/nouveau/nvkm/engine/disp/outp.h   |   4 +-
 .../gpu/drm/nouveau/nvkm/engine/disp/priv.h   |   1 +
 .../gpu/drm/nouveau/nvkm/engine/disp/udisp.c  |  12 ++
 .../gpu/drm/nouveau/nvkm/engine/disp/uoutp.c  | 104 ++++++++++++++++++
 17 files changed, 221 insertions(+), 6 deletions(-)
 create mode 100644 drivers/gpu/drm/nouveau/include/nvif/if0012.h
 create mode 100644 drivers/gpu/drm/nouveau/include/nvif/outp.h
 create mode 100644 drivers/gpu/drm/nouveau/nvif/outp.c
 create mode 100644 drivers/gpu/drm/nouveau/nvkm/engine/disp/uoutp.c

diff --git a/drivers/gpu/drm/nouveau/dispnv50/disp.c b/drivers/gpu/drm/nouveau/dispnv50/disp.c
index f4d0bc362c89..e094fb074105 100644
--- a/drivers/gpu/drm/nouveau/dispnv50/disp.c
+++ b/drivers/gpu/drm/nouveau/dispnv50/disp.c
@@ -563,6 +563,10 @@ nv50_dac_help = {
 static void
 nv50_dac_destroy(struct drm_encoder *encoder)
 {
+	struct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);
+
+	nvif_outp_dtor(&nv_encoder->outp);
+
 	drm_encoder_cleanup(encoder);
 	kfree(encoder);
 }
@@ -576,6 +580,7 @@ static int
 nv50_dac_create(struct drm_connector *connector, struct dcb_output *dcbe)
 {
 	struct nouveau_drm *drm = nouveau_drm(connector->dev);
+	struct nv50_disp *disp = nv50_disp(connector->dev);
 	struct nvkm_i2c *i2c = nvxx_i2c(&drm->client.device);
 	struct nvkm_i2c_bus *bus;
 	struct nouveau_encoder *nv_encoder;
@@ -599,7 +604,7 @@ nv50_dac_create(struct drm_connector *connector, struct dcb_output *dcbe)
 	drm_encoder_helper_add(encoder, &nv50_dac_help);
 
 	drm_connector_attach_encoder(connector, encoder);
-	return 0;
+	return nvif_outp_ctor(disp->disp, nv_encoder->base.base.name, dcbe->id, &nv_encoder->outp);
 }
 
 /*
@@ -1822,6 +1827,9 @@ static void
 nv50_sor_destroy(struct drm_encoder *encoder)
 {
 	struct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);
+
+	nvif_outp_dtor(&nv_encoder->outp);
+
 	nv50_mstm_del(&nv_encoder->dp.mstm);
 	drm_encoder_cleanup(encoder);
 
@@ -1918,7 +1926,7 @@ nv50_sor_create(struct drm_connector *connector, struct dcb_output *dcbe)
 			nv_encoder->i2c = &bus->i2c;
 	}
 
-	return 0;
+	return nvif_outp_ctor(disp->disp, nv_encoder->base.base.name, dcbe->id, &nv_encoder->outp);
 }
 
 /******************************************************************************
@@ -1999,6 +2007,10 @@ nv50_pior_help = {
 static void
 nv50_pior_destroy(struct drm_encoder *encoder)
 {
+	struct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);
+
+	nvif_outp_dtor(&nv_encoder->outp);
+
 	drm_encoder_cleanup(encoder);
 	kfree(encoder);
 }
@@ -2056,7 +2068,7 @@ nv50_pior_create(struct drm_connector *connector, struct dcb_output *dcbe)
 	disp->core->func->pior->get_caps(disp, nv_encoder, ffs(dcbe->or) - 1);
 	nv50_outp_dump_caps(drm, nv_encoder);
 
-	return 0;
+	return nvif_outp_ctor(disp->disp, nv_encoder->base.base.name, dcbe->id, &nv_encoder->outp);
 }
 
 /******************************************************************************
diff --git a/drivers/gpu/drm/nouveau/include/nvif/class.h b/drivers/gpu/drm/nouveau/include/nvif/class.h
index c7dab84e0a30..8641db649f48 100644
--- a/drivers/gpu/drm/nouveau/include/nvif/class.h
+++ b/drivers/gpu/drm/nouveau/include/nvif/class.h
@@ -34,6 +34,7 @@
 
 #define NVIF_CLASS_DISP                              /* if0010.h */  0x80000010
 #define NVIF_CLASS_CONN                              /* if0011.h */  0x80000011
+#define NVIF_CLASS_OUTP                              /* if0012.h */  0x80000012
 #define NVIF_CLASS_DISP_CHAN                         /* if0014.h */  0x80000014
 
 /* the below match nvidia-assigned (either in hw, or sw) class numbers */
diff --git a/drivers/gpu/drm/nouveau/include/nvif/disp.h b/drivers/gpu/drm/nouveau/include/nvif/disp.h
index a93055b781f2..742632ad3bea 100644
--- a/drivers/gpu/drm/nouveau/include/nvif/disp.h
+++ b/drivers/gpu/drm/nouveau/include/nvif/disp.h
@@ -6,6 +6,7 @@ struct nvif_device;
 struct nvif_disp {
 	struct nvif_object object;
 	unsigned long conn_mask;
+	unsigned long outp_mask;
 };
 
 int nvif_disp_ctor(struct nvif_device *, const char *name, s32 oclass,
diff --git a/drivers/gpu/drm/nouveau/include/nvif/if0010.h b/drivers/gpu/drm/nouveau/include/nvif/if0010.h
index 3af495dbd4c6..fc236ef28965 100644
--- a/drivers/gpu/drm/nouveau/include/nvif/if0010.h
+++ b/drivers/gpu/drm/nouveau/include/nvif/if0010.h
@@ -7,6 +7,7 @@ union nvif_disp_args {
 		__u8 version;
 		__u8 pad01[3];
 		__u32 conn_mask;
+		__u32 outp_mask;
 	} v0;
 };
 #endif
diff --git a/drivers/gpu/drm/nouveau/include/nvif/if0012.h b/drivers/gpu/drm/nouveau/include/nvif/if0012.h
new file mode 100644
index 000000000000..c0793e0f902f
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/include/nvif/if0012.h
@@ -0,0 +1,12 @@
+/* SPDX-License-Identifier: MIT */
+#ifndef __NVIF_IF0012_H__
+#define __NVIF_IF0012_H__
+
+union nvif_outp_args {
+	struct nvif_outp_v0 {
+		__u8 version;
+		__u8 id;	/* DCB device index. */
+		__u8 pad02[6];
+	} v0;
+};
+#endif
diff --git a/drivers/gpu/drm/nouveau/include/nvif/outp.h b/drivers/gpu/drm/nouveau/include/nvif/outp.h
new file mode 100644
index 000000000000..64d2131058d5
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/include/nvif/outp.h
@@ -0,0 +1,13 @@
+/* SPDX-License-Identifier: MIT */
+#ifndef __NVIF_OUTP_H__
+#define __NVIF_OUTP_H__
+#include <nvif/object.h>
+struct nvif_disp;
+
+struct nvif_outp {
+	struct nvif_object object;
+};
+
+int nvif_outp_ctor(struct nvif_disp *, const char *name, int id, struct nvif_outp *);
+void nvif_outp_dtor(struct nvif_outp *);
+#endif
diff --git a/drivers/gpu/drm/nouveau/include/nvkm/subdev/bios/dcb.h b/drivers/gpu/drm/nouveau/include/nvkm/subdev/bios/dcb.h
index a27a0f3fe7aa..73f9d9947e7e 100644
--- a/drivers/gpu/drm/nouveau/include/nvkm/subdev/bios/dcb.h
+++ b/drivers/gpu/drm/nouveau/include/nvkm/subdev/bios/dcb.h
@@ -54,6 +54,7 @@ struct dcb_output {
 		} tmdsconf;
 	};
 	bool i2c_upper_default;
+	int id;
 };
 
 u16 dcb_table(struct nvkm_bios *, u8 *ver, u8 *hdr, u8 *ent, u8 *len);
diff --git a/drivers/gpu/drm/nouveau/nouveau_bios.c b/drivers/gpu/drm/nouveau/nouveau_bios.c
index 41b78e9ecd4e..189903b65edc 100644
--- a/drivers/gpu/drm/nouveau/nouveau_bios.c
+++ b/drivers/gpu/drm/nouveau/nouveau_bios.c
@@ -1801,6 +1801,8 @@ parse_dcb_entry(struct drm_device *dev, void *data, int idx, u8 *outp)
 			ret = parse_dcb20_entry(dev, dcb, conn, conf, entry);
 		else
 			ret = parse_dcb15_entry(dev, dcb, conn, conf, entry);
+		entry->id = idx;
+
 		if (!ret)
 			return 1; /* stop parsing */
 
diff --git a/drivers/gpu/drm/nouveau/nouveau_encoder.h b/drivers/gpu/drm/nouveau/nouveau_encoder.h
index c2f5f0cb70d5..b72e5783a00f 100644
--- a/drivers/gpu/drm/nouveau/nouveau_encoder.h
+++ b/drivers/gpu/drm/nouveau/nouveau_encoder.h
@@ -26,7 +26,7 @@
 
 #ifndef __NOUVEAU_ENCODER_H__
 #define __NOUVEAU_ENCODER_H__
-
+#include <nvif/outp.h>
 #include <subdev/bios/dcb.h>
 
 #include <drm/display/drm_dp_helper.h>
@@ -46,6 +46,7 @@ struct nouveau_encoder {
 	struct drm_encoder_slave base;
 
 	struct dcb_output *dcb;
+	struct nvif_outp outp;
 	int or;
 	int link;
 
diff --git a/drivers/gpu/drm/nouveau/nvif/Kbuild b/drivers/gpu/drm/nouveau/nvif/Kbuild
index 576237f47d8d..6abc4bc42e35 100644
--- a/drivers/gpu/drm/nouveau/nvif/Kbuild
+++ b/drivers/gpu/drm/nouveau/nvif/Kbuild
@@ -9,6 +9,7 @@ nvif-y += nvif/fifo.o
 nvif-y += nvif/mem.o
 nvif-y += nvif/mmu.o
 nvif-y += nvif/notify.o
+nvif-y += nvif/outp.o
 nvif-y += nvif/timer.o
 nvif-y += nvif/vmm.o
 
diff --git a/drivers/gpu/drm/nouveau/nvif/disp.c b/drivers/gpu/drm/nouveau/nvif/disp.c
index b8e98070c77e..926b0c04b1e8 100644
--- a/drivers/gpu/drm/nouveau/nvif/disp.c
+++ b/drivers/gpu/drm/nouveau/nvif/disp.c
@@ -72,7 +72,9 @@ nvif_disp_ctor(struct nvif_device *device, const char *name, s32 oclass, struct
 	if (ret)
 		return ret;
 
-	NVIF_DEBUG(&disp->object, "[NEW] conn_mask:%08x", args.conn_mask);
+	NVIF_DEBUG(&disp->object, "[NEW] conn_mask:%08x outp_mask:%08x",
+		   args.conn_mask, args.outp_mask);
 	disp->conn_mask = args.conn_mask;
+	disp->outp_mask = args.outp_mask;
 	return 0;
 }
diff --git a/drivers/gpu/drm/nouveau/nvif/outp.c b/drivers/gpu/drm/nouveau/nvif/outp.c
new file mode 100644
index 000000000000..5a231bf7db96
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/nvif/outp.c
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2021 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+#include <nvif/outp.h>
+#include <nvif/disp.h>
+#include <nvif/printf.h>
+
+#include <nvif/class.h>
+#include <nvif/if0012.h>
+
+void
+nvif_outp_dtor(struct nvif_outp *outp)
+{
+	nvif_object_dtor(&outp->object);
+}
+
+int
+nvif_outp_ctor(struct nvif_disp *disp, const char *name, int id, struct nvif_outp *outp)
+{
+	struct nvif_outp_v0 args;
+	int ret;
+
+	args.version = 0;
+	args.id = id;
+
+	ret = nvif_object_ctor(&disp->object, name ?: "nvifOutp", id, NVIF_CLASS_OUTP,
+			       &args, sizeof(args), &outp->object);
+	NVIF_ERRON(ret, &disp->object, "[NEW outp id:%d]", id);
+	return ret;
+}
diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/Kbuild b/drivers/gpu/drm/nouveau/nvkm/engine/disp/Kbuild
index a5accccf88ea..600072a904be 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/Kbuild
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/Kbuild
@@ -33,3 +33,4 @@ nvkm-y += nvkm/engine/disp/rootnv50.o
 
 nvkm-y += nvkm/engine/disp/udisp.o
 nvkm-y += nvkm/engine/disp/uconn.o
+nvkm-y += nvkm/engine/disp/uoutp.o
diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.h b/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.h
index a72c123e9ca5..3f3924c41957 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.h
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.h
@@ -1,7 +1,7 @@
 /* SPDX-License-Identifier: MIT */
 #ifndef __NVKM_DISP_OUTP_H__
 #define __NVKM_DISP_OUTP_H__
-#include <engine/disp.h>
+#include "priv.h"
 #include <core/notify.h>
 
 #include <subdev/bios.h>
@@ -53,6 +53,8 @@ struct nvkm_outp {
 			} lt;
 		} dp;
 	};
+
+	struct nvkm_object object;
 };
 
 int nvkm_outp_new_(const struct nvkm_outp_func *, struct nvkm_disp *, int index,
diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/priv.h b/drivers/gpu/drm/nouveau/nvkm/engine/disp/priv.h
index d023ca634c83..cb25dfe849f0 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/priv.h
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/priv.h
@@ -85,4 +85,5 @@ extern const struct nvkm_event_func gv100_disp_chan_uevent;
 
 int nvkm_udisp_new(const struct nvkm_oclass *, void *, u32, struct nvkm_object **);
 int nvkm_uconn_new(const struct nvkm_oclass *, void *, u32, struct nvkm_object **);
+int nvkm_uoutp_new(const struct nvkm_oclass *, void *, u32, struct nvkm_object **);
 #endif
diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/udisp.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/udisp.c
index 82e052950a32..0841e7ce0343 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/udisp.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/udisp.c
@@ -21,6 +21,7 @@
  */
 #include "priv.h"
 #include "conn.h"
+#include "outp.h"
 
 #include <nvif/class.h>
 #include <nvif/if0010.h>
@@ -36,6 +37,12 @@ nvkm_udisp_sclass(struct nvkm_object *object, int index, struct nvkm_oclass *scl
 		return 0;
 	}
 
+	if (index-- == 0) {
+		sclass->base = (struct nvkm_sclass) { 0, 0, NVIF_CLASS_OUTP };
+		sclass->ctor = nvkm_uoutp_new;
+		return 0;
+	}
+
 	if (disp->func->user[index].ctor) {
 		sclass->base = disp->func->user[index].base;
 		sclass->ctor = disp->func->user[index].ctor;
@@ -81,6 +88,7 @@ nvkm_udisp_new(const struct nvkm_oclass *oclass, void *argv, u32 argc, struct nv
 {
 	struct nvkm_disp *disp = nvkm_disp(oclass->engine);
 	struct nvkm_conn *conn;
+	struct nvkm_outp *outp;
 	union nvif_disp_args *args = argv;
 
 	if (argc != sizeof(args->v0) || args->v0.version != 0)
@@ -99,5 +107,9 @@ nvkm_udisp_new(const struct nvkm_oclass *oclass, void *argv, u32 argc, struct nv
 	list_for_each_entry(conn, &disp->conns, head)
 		args->v0.conn_mask |= BIT(conn->index);
 
+	args->v0.outp_mask = 0;
+	list_for_each_entry(outp, &disp->outps, head)
+		args->v0.outp_mask |= BIT(outp->index);
+
 	return 0;
 }
diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/uoutp.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/uoutp.c
new file mode 100644
index 000000000000..1ea144ecdb31
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/uoutp.c
@@ -0,0 +1,104 @@
+/*
+ * Copyright 2021 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+#define nvkm_uoutp(p) container_of((p), struct nvkm_outp, object)
+#include "outp.h"
+
+#include <nvif/if0012.h>
+
+static int
+nvkm_uoutp_mthd_noacquire(struct nvkm_outp *outp, u32 mthd, void *argv, u32 argc)
+{
+	switch (mthd) {
+	default:
+		break;
+	}
+
+	return 1;
+}
+
+static int
+nvkm_uoutp_mthd(struct nvkm_object *object, u32 mthd, void *argv, u32 argc)
+{
+	struct nvkm_outp *outp = nvkm_uoutp(object);
+	struct nvkm_disp *disp = outp->disp;
+	int ret;
+
+	mutex_lock(&disp->super.mutex);
+
+	ret = nvkm_uoutp_mthd_noacquire(outp, mthd, argv, argc);
+	if (ret <= 0)
+		goto done;
+
+done:
+	mutex_unlock(&disp->super.mutex);
+	return ret;
+}
+
+static void *
+nvkm_uoutp_dtor(struct nvkm_object *object)
+{
+	struct nvkm_outp *outp = nvkm_uoutp(object);
+	struct nvkm_disp *disp = outp->disp;
+
+	spin_lock(&disp->client.lock);
+	outp->object.func = NULL;
+	spin_unlock(&disp->client.lock);
+	return NULL;
+}
+
+static const struct nvkm_object_func
+nvkm_uoutp = {
+	.dtor = nvkm_uoutp_dtor,
+	.mthd = nvkm_uoutp_mthd,
+};
+
+int
+nvkm_uoutp_new(const struct nvkm_oclass *oclass, void *argv, u32 argc, struct nvkm_object **pobject)
+{
+	struct nvkm_disp *disp = nvkm_udisp(oclass->parent);
+	struct nvkm_outp *outt, *outp = NULL;
+	union nvif_outp_args *args = argv;
+	int ret;
+
+	if (argc != sizeof(args->v0) || args->v0.version != 0)
+		return -ENOSYS;
+
+	list_for_each_entry(outt, &disp->outps, head) {
+		if (outt->index == args->v0.id) {
+			outp = outt;
+			break;
+		}
+	}
+
+	if (!outp)
+		return -EINVAL;
+
+	ret = -EBUSY;
+	spin_lock(&disp->client.lock);
+	if (!outp->object.func) {
+		nvkm_object_ctor(&nvkm_uoutp, oclass, &outp->object);
+		*pobject = &outp->object;
+		ret = 0;
+	}
+	spin_unlock(&disp->client.lock);
+	return ret;
+}
-- 
2.25.1

