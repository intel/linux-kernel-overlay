From 182cb51017c612d6ed5ec8a24cb3e154cad6353f Mon Sep 17 00:00:00 2001
From: Prike Liang <Prike.Liang@amd.com>
Date: Fri, 11 Feb 2022 11:28:47 +0800
Subject: [PATCH 1021/2251] drm/amd/pm: validate SMU feature enable message for
 getting feature enabled mask

There's always miss the SMU feature enabled checked in the NPI phase,
so let validate the SMU feature enable message directly rather than
add more and more MP1 version check.

Signed-off-by: Prike Liang <Prike.Liang@amd.com>
Signed-off-by: Lijo Lazar <Lijo.Lazar@amd.com>
Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
---
 .../amd/pm/swsmu/smu11/cyan_skillfish_ppt.c   | 12 ++++-
 .../gpu/drm/amd/pm/swsmu/smu12/renoir_ppt.c   | 12 ++++-
 drivers/gpu/drm/amd/pm/swsmu/smu_cmn.c        | 48 ++++++++-----------
 3 files changed, 43 insertions(+), 29 deletions(-)

diff --git a/drivers/gpu/drm/amd/pm/swsmu/smu11/cyan_skillfish_ppt.c b/drivers/gpu/drm/amd/pm/swsmu/smu11/cyan_skillfish_ppt.c
index b3a0f3fb3e65..f1a4a720d426 100644
--- a/drivers/gpu/drm/amd/pm/swsmu/smu11/cyan_skillfish_ppt.c
+++ b/drivers/gpu/drm/amd/pm/swsmu/smu11/cyan_skillfish_ppt.c
@@ -552,6 +552,16 @@ static int cyan_skillfish_get_dpm_ultimate_freq(struct smu_context *smu,
 	return 0;
 }
 
+static int cyan_skillfish_get_enabled_mask(struct smu_context *smu,
+					   uint64_t *feature_mask)
+{
+	if (!feature_mask)
+		return -EINVAL;
+	memset(feature_mask, 0xff, sizeof(*feature_mask));
+
+	return 0;
+}
+
 static const struct pptable_funcs cyan_skillfish_ppt_funcs = {
 
 	.check_fw_status = smu_v11_0_check_fw_status,
@@ -562,7 +572,7 @@ static const struct pptable_funcs cyan_skillfish_ppt_funcs = {
 	.fini_smc_tables = smu_v11_0_fini_smc_tables,
 	.read_sensor = cyan_skillfish_read_sensor,
 	.print_clk_levels = cyan_skillfish_print_clk_levels,
-	.get_enabled_mask = smu_cmn_get_enabled_mask,
+	.get_enabled_mask = cyan_skillfish_get_enabled_mask,
 	.is_dpm_running = cyan_skillfish_is_dpm_running,
 	.get_gpu_metrics = cyan_skillfish_get_gpu_metrics,
 	.od_edit_dpm_table = cyan_skillfish_od_edit_dpm_table,
diff --git a/drivers/gpu/drm/amd/pm/swsmu/smu12/renoir_ppt.c b/drivers/gpu/drm/amd/pm/swsmu/smu12/renoir_ppt.c
index 05c8b9d3f2d7..012e3bd99cc2 100644
--- a/drivers/gpu/drm/amd/pm/swsmu/smu12/renoir_ppt.c
+++ b/drivers/gpu/drm/amd/pm/swsmu/smu12/renoir_ppt.c
@@ -1394,6 +1394,16 @@ static int renoir_gfx_state_change_set(struct smu_context *smu, uint32_t state)
 	return 0;
 }
 
+static int renoir_get_enabled_mask(struct smu_context *smu,
+				   uint64_t *feature_mask)
+{
+	if (!feature_mask)
+		return -EINVAL;
+	memset(feature_mask, 0xff, sizeof(*feature_mask));
+
+	return 0;
+}
+
 static const struct pptable_funcs renoir_ppt_funcs = {
 	.set_power_state = NULL,
 	.print_clk_levels = renoir_print_clk_levels,
@@ -1418,7 +1428,7 @@ static const struct pptable_funcs renoir_ppt_funcs = {
 	.init_smc_tables = renoir_init_smc_tables,
 	.fini_smc_tables = smu_v12_0_fini_smc_tables,
 	.set_default_dpm_table = smu_v12_0_set_default_dpm_tables,
-	.get_enabled_mask = smu_cmn_get_enabled_mask,
+	.get_enabled_mask = renoir_get_enabled_mask,
 	.feature_is_enabled = smu_cmn_feature_is_enabled,
 	.disable_all_features_with_exception = smu_cmn_disable_all_features_with_exception,
 	.get_dpm_ultimate_freq = renoir_get_dpm_ultimate_freq,
diff --git a/drivers/gpu/drm/amd/pm/swsmu/smu_cmn.c b/drivers/gpu/drm/amd/pm/swsmu/smu_cmn.c
index 606b275a2e94..dec102bf21aa 100644
--- a/drivers/gpu/drm/amd/pm/swsmu/smu_cmn.c
+++ b/drivers/gpu/drm/amd/pm/swsmu/smu_cmn.c
@@ -70,6 +70,12 @@ static const char * const __smu_message_names[] = {
 	SMU_MESSAGE_TYPES
 };
 
+#define smu_cmn_call_asic_func(intf, smu, args...)                             \
+	((smu)->ppt_funcs ? ((smu)->ppt_funcs->intf ?                          \
+				     (smu)->ppt_funcs->intf(smu, ##args) :     \
+				     -ENOTSUPP) :                              \
+			    -EINVAL)
+
 static const char *smu_get_message_name(struct smu_context *smu,
 					enum smu_message_type type)
 {
@@ -517,6 +523,12 @@ int smu_cmn_feature_is_supported(struct smu_context *smu,
 	return test_bit(feature_id, feature->supported);
 }
 
+int __smu_get_enabled_features(struct smu_context *smu,
+			       uint64_t *enabled_features)
+{
+	return smu_cmn_call_asic_func(get_enabled_mask, smu, enabled_features);
+}
+
 int smu_cmn_feature_is_enabled(struct smu_context *smu,
 			       enum smu_feature_mask mask)
 {
@@ -524,7 +536,7 @@ int smu_cmn_feature_is_enabled(struct smu_context *smu,
 	uint64_t enabled_features;
 	int feature_id;
 
-	if (smu_cmn_get_enabled_mask(smu, &enabled_features)) {
+	if (__smu_get_enabled_features(smu, &enabled_features)) {
 		dev_err(adev->dev, "Failed to retrieve enabled ppfeatures!\n");
 		return 0;
 	}
@@ -576,10 +588,9 @@ bool smu_cmn_clk_dpm_is_enabled(struct smu_context *smu,
 int smu_cmn_get_enabled_mask(struct smu_context *smu,
 			     uint64_t *feature_mask)
 {
-	struct amdgpu_device *adev = smu->adev;
 	uint32_t *feature_mask_high;
 	uint32_t *feature_mask_low;
-	int ret = 0;
+	int ret = 0, index = 0;
 
 	if (!feature_mask)
 		return -EINVAL;
@@ -587,12 +598,10 @@ int smu_cmn_get_enabled_mask(struct smu_context *smu,
 	feature_mask_low = &((uint32_t *)feature_mask)[0];
 	feature_mask_high = &((uint32_t *)feature_mask)[1];
 
-	switch (adev->ip_versions[MP1_HWIP][0]) {
-	/* For Vangogh and Yellow Carp */
-	case IP_VERSION(11, 5, 0):
-	case IP_VERSION(13, 0, 1):
-	case IP_VERSION(13, 0, 3):
-	case IP_VERSION(13, 0, 8):
+	index = smu_cmn_to_asic_specific_index(smu,
+						CMN2ASIC_MAPPING_MSG,
+						SMU_MSG_GetEnabledSmuFeatures);
+	if (index > 0) {
 		ret = smu_cmn_send_smc_msg_with_param(smu,
 						      SMU_MSG_GetEnabledSmuFeatures,
 						      0,
@@ -604,19 +613,7 @@ int smu_cmn_get_enabled_mask(struct smu_context *smu,
 						      SMU_MSG_GetEnabledSmuFeatures,
 						      1,
 						      feature_mask_high);
-		break;
-	/*
-	 * For Cyan Skillfish and Renoir, there is no interface provided by PMFW
-	 * to retrieve the enabled features. So, we assume all features are enabled.
-	 * TODO: add other APU ASICs which suffer from the same issue here
-	 */
-	case IP_VERSION(11, 0, 8):
-	case IP_VERSION(12, 0, 0):
-	case IP_VERSION(12, 0, 1):
-		memset(feature_mask, 0xff, sizeof(*feature_mask));
-		break;
-	/* other dGPU ASICs */
-	default:
+	} else {
 		ret = smu_cmn_send_smc_msg(smu,
 					   SMU_MSG_GetEnabledSmuFeaturesHigh,
 					   feature_mask_high);
@@ -626,7 +623,6 @@ int smu_cmn_get_enabled_mask(struct smu_context *smu,
 		ret = smu_cmn_send_smc_msg(smu,
 					   SMU_MSG_GetEnabledSmuFeaturesLow,
 					   feature_mask_low);
-		break;
 	}
 
 	return ret;
@@ -720,8 +716,7 @@ size_t smu_cmn_get_pp_feature_mask(struct smu_context *smu,
 	int ret = 0, i;
 	int feature_id;
 
-	ret = smu_cmn_get_enabled_mask(smu,
-				       &feature_mask);
+	ret = __smu_get_enabled_features(smu, &feature_mask);
 	if (ret)
 		return 0;
 
@@ -773,8 +768,7 @@ int smu_cmn_set_pp_feature_mask(struct smu_context *smu,
 	uint64_t feature_2_enabled = 0;
 	uint64_t feature_2_disabled = 0;
 
-	ret = smu_cmn_get_enabled_mask(smu,
-				       &feature_mask);
+	ret = __smu_get_enabled_features(smu, &feature_mask);
 	if (ret)
 		return ret;
 
-- 
2.25.1

