From b8b5e4bfe0b4202946758a9cd10eb3aa953ad9ae Mon Sep 17 00:00:00 2001
From: Thomas Zimmermann <tzimmermann@suse.de>
Date: Mon, 17 Apr 2023 14:56:42 +0200
Subject: [PATCH 1752/2071] video: Remove trailing whitespaces

Fix trailing whitespaces. No functional changes.

Signed-off-by: Thomas Zimmermann <tzimmermann@suse.de>
Acked-by: Arnd Bergmann <arnd@arndb.de>
Acked-by: Helge Deller <deller@gmx.de>
Link: https://patchwork.freedesktop.org/patch/msgid/20230417125651.25126-11-tzimmermann@suse.de
---
 drivers/video/console/sticon.c  |   4 +-
 drivers/video/console/sticore.c | 102 ++++++++++++++++----------------
 drivers/video/fbdev/sticore.h   |  14 ++---
 3 files changed, 60 insertions(+), 60 deletions(-)

diff --git a/drivers/video/console/sticon.c b/drivers/video/console/sticon.c
index 2cea69418a83..89ad7ade6cf9 100644
--- a/drivers/video/console/sticon.c
+++ b/drivers/video/console/sticon.c
@@ -282,7 +282,7 @@ static void sticon_init(struct vc_data *c, int init)
     vc_cols = sti_onscreen_x(sti) / sti->font->width;
     vc_rows = sti_onscreen_y(sti) / sti->font->height;
     c->vc_can_do_color = 1;
-    
+
     if (init) {
 	c->vc_cols = vc_cols;
 	c->vc_rows = vc_rows;
@@ -374,7 +374,7 @@ static const struct consw sti_con = {
 	.con_font_set		= sticon_font_set,
 	.con_font_default	= sticon_font_default,
 	.con_build_attr		= sticon_build_attr,
-	.con_invert_region	= sticon_invert_region, 
+	.con_invert_region	= sticon_invert_region,
 };
 
 
diff --git a/drivers/video/console/sticore.c b/drivers/video/console/sticore.c
index db568f67e4dc..6ea9596a3c4b 100644
--- a/drivers/video/console/sticore.c
+++ b/drivers/video/console/sticore.c
@@ -6,12 +6,12 @@
  *	Copyright (C) 2000 Philipp Rumpf <prumpf@tux.org>
  *	Copyright (C) 2001-2020 Helge Deller <deller@gmx.de>
  *	Copyright (C) 2001-2002 Thomas Bogendoerfer <tsbogend@alpha.franken.de>
- * 
+ *
  * TODO:
  * - call STI in virtual mode rather than in real mode
- * - screen blanking with state_mgmt() in text mode STI ? 
+ * - screen blanking with state_mgmt() in text mode STI ?
  * - try to make it work on m68k hp workstations ;)
- * 
+ *
  */
 
 #define pr_fmt(fmt) "%s: " fmt, KBUILD_MODNAME
@@ -66,12 +66,12 @@ static const u8 col_trans[8] = {
 #define c_index(sti, c) ((c) & 0xff)
 
 static const struct sti_init_flags default_init_flags = {
-	.wait	= STI_WAIT, 
+	.wait	= STI_WAIT,
 	.reset	= 1,
-	.text	= 1, 
+	.text	= 1,
 	.nontext = 1,
-	.no_chg_bet = 1, 
-	.no_chg_bei = 1, 
+	.no_chg_bet = 1,
+	.no_chg_bei = 1,
 	.init_cmap_tx = 1,
 };
 
@@ -104,7 +104,7 @@ static int sti_init_graph(struct sti_struct *sti)
 		pr_err("STI init_graph failed (ret %d, errno %d)\n", ret, err);
 		return -1;
 	}
-	
+
 	return 0;
 }
 
@@ -120,7 +120,7 @@ static void sti_inq_conf(struct sti_struct *sti)
 	s32 ret;
 
 	outptr->ext_ptr = STI_PTR(&sti->sti_data->inq_outptr_ext);
-	
+
 	do {
 		spin_lock_irqsave(&sti->lock, flags);
 		memset(inptr, 0, sizeof(*inptr));
@@ -162,9 +162,9 @@ sti_putc(struct sti_struct *sti, int c, int y, int x,
 }
 
 static const struct sti_blkmv_flags clear_blkmv_flags = {
-	.wait	= STI_WAIT, 
-	.color	= 1, 
-	.clear	= 1, 
+	.wait	= STI_WAIT,
+	.color	= 1,
+	.clear	= 1,
 };
 
 void
@@ -185,7 +185,7 @@ sti_set(struct sti_struct *sti, int src_y, int src_x,
 	struct sti_blkmv_outptr *outptr = &sti->sti_data->blkmv_outptr;
 	s32 ret;
 	unsigned long flags;
-	
+
 	do {
 		spin_lock_irqsave(&sti->lock, flags);
 		*inptr = inptr_default;
@@ -224,7 +224,7 @@ sti_clear(struct sti_struct *sti, int src_y, int src_x,
 }
 
 static const struct sti_blkmv_flags default_blkmv_flags = {
-	.wait = STI_WAIT, 
+	.wait = STI_WAIT,
 };
 
 void
@@ -291,14 +291,14 @@ static int __init sti_setup(char *str)
 {
 	if (str)
 		strscpy(default_sti_path, str, sizeof(default_sti_path));
-	
+
 	return 1;
 }
 
 /*	Assuming the machine has multiple STI consoles (=graphic cards) which
  *	all get detected by sticon, the user may define with the linux kernel
  *	parameter sti=<x> which of them will be the initial boot-console.
- *	<x> is a number between 0 and MAX_STI_ROMS, with 0 as the default 
+ *	<x> is a number between 0 and MAX_STI_ROMS, with 0 as the default
  *	STI screen.
  */
 __setup("sti=", sti_setup);
@@ -341,13 +341,13 @@ static int sti_font_setup(char *str)
  *	should be used by the sticon driver to draw characters to the screen.
  *	Possible values are:
  *	- sti_font=<fb_fontname>:
- *		<fb_fontname> is the name of one of the linux-kernel built-in 
- *		framebuffer font names (e.g. VGA8x16, SUN22x18). 
- *		This is only available if the fonts have been statically compiled 
+ *		<fb_fontname> is the name of one of the linux-kernel built-in
+ *		framebuffer font names (e.g. VGA8x16, SUN22x18).
+ *		This is only available if the fonts have been statically compiled
  *		in with e.g. the CONFIG_FONT_8x16 or CONFIG_FONT_SUN12x22 options.
  *	- sti_font=<number>	(<number> = 1,2,3,...)
  *		most STI ROMs have built-in HP specific fonts, which can be selected
- *		by giving the desired number to the sticon driver. 
+ *		by giving the desired number to the sticon driver.
  *		NOTE: This number is machine and STI ROM dependend.
  *	- sti_font=<height>x<width>  (e.g. sti_font=16x8)
  *		<height> and <width> gives hints to the height and width of the
@@ -359,12 +359,12 @@ __setup("sti_font=", sti_font_setup);
 #endif
 
 
-	
+
 static void sti_dump_globcfg(struct sti_glob_cfg *glob_cfg,
 			     unsigned int sti_mem_request)
 {
 	struct sti_glob_cfg_ext *cfg;
-	
+
 	pr_debug("%d text planes\n"
 		"%4d x %4d screen resolution\n"
 		"%4d x %4d offscreen\n"
@@ -384,7 +384,7 @@ static void sti_dump_globcfg(struct sti_glob_cfg *glob_cfg,
 		glob_cfg->reent_lvl,
 		glob_cfg->save_addr);
 
-	/* dump extended cfg */ 
+	/* dump extended cfg */
 	cfg = PTR_STI((unsigned long)glob_cfg->ext_ptr);
 	pr_debug("monitor %d\n"
 		"in friendly mode: %d\n"
@@ -437,10 +437,10 @@ static int sti_init_glob_cfg(struct sti_struct *sti, unsigned long rom_address,
 	glob_cfg->save_addr = STI_PTR(save_addr);
 	for (i=0; i<8; i++) {
 		unsigned long newhpa, len;
-	       
+
 		if (sti->pd) {
 			unsigned char offs = sti->rm_entry[i];
-				
+
 			if (offs == 0)
 				continue;
 			if (offs != PCI_ROM_ADDRESS &&
@@ -456,18 +456,18 @@ static int sti_init_glob_cfg(struct sti_struct *sti, unsigned long rom_address,
 
 		sti->regions_phys[i] =
 			REGION_OFFSET_TO_PHYS(sti->regions[i], newhpa);
-		
+
 		len = sti->regions[i].region_desc.length * 4096;
 		if (len)
 			glob_cfg->region_ptrs[i] = sti->regions_phys[i];
-		
+
 		pr_debug("region #%d: phys %08lx, region_ptr %08x, len=%lukB, "
 			 "btlb=%d, sysonly=%d, cache=%d, last=%d\n",
 			i, sti->regions_phys[i], glob_cfg->region_ptrs[i],
 			len/1024,
 			sti->regions[i].region_desc.btlb,
 			sti->regions[i].region_desc.sys_only,
-			sti->regions[i].region_desc.cache, 
+			sti->regions[i].region_desc.cache,
 			sti->regions[i].region_desc.last);
 
 		/* last entry reached ? */
@@ -482,7 +482,7 @@ static int sti_init_glob_cfg(struct sti_struct *sti, unsigned long rom_address,
 	glob_cfg_ext->sti_mem_addr = STI_PTR(sti_mem_addr);
 
 	sti->glob_cfg = glob_cfg;
-	
+
 	return 0;
 }
 
@@ -495,7 +495,7 @@ sti_select_fbfont(struct sti_cooked_rom *cooked_rom, const char *fbfont_name)
 	void *dest;
 	struct sti_rom_font *nf;
 	struct sti_cooked_font *cooked_font;
-	
+
 	if (fbfont_name && strlen(fbfont_name))
 		fbfont = find_font(fbfont_name);
 	if (!fbfont)
@@ -505,8 +505,8 @@ sti_select_fbfont(struct sti_cooked_rom *cooked_rom, const char *fbfont_name)
 
 	pr_info("    using %ux%u framebuffer font %s\n",
 			fbfont->width, fbfont->height, fbfont->name);
-			
-	bpc = ((fbfont->width+7)/8) * fbfont->height; 
+
+	bpc = ((fbfont->width+7)/8) * fbfont->height;
 	size = bpc * fbfont->charcount;
 	size += sizeof(struct sti_rom_font);
 
@@ -533,7 +533,7 @@ sti_select_fbfont(struct sti_cooked_rom *cooked_rom, const char *fbfont_name)
 		kfree(nf);
 		return NULL;
 	}
-	
+
 	cooked_font->raw = nf;
 	cooked_font->raw_ptr = nf;
 	cooked_font->next_font = NULL;
@@ -617,9 +617,9 @@ static void sti_dump_rom(struct sti_struct *sti)
 	int nr;
 
 	pr_info("  id %04x-%04x, conforms to spec rev. %d.%02x\n",
-		rom->graphics_id[0], 
+		rom->graphics_id[0],
 		rom->graphics_id[1],
-		rom->revno[0] >> 4, 
+		rom->revno[0] >> 4,
 		rom->revno[0] & 0x0f);
 	pr_debug("  supports %d monitors\n", rom->num_mons);
 	pr_debug("  font start %08x\n", rom->font_start);
@@ -647,7 +647,7 @@ static int sti_cook_fonts(struct sti_cooked_rom *cooked_rom,
 {
 	struct sti_rom_font *raw_font, *font_start;
 	struct sti_cooked_font *cooked_font;
-	
+
 	cooked_font = kzalloc(sizeof(*cooked_font), GFP_KERNEL);
 	if (!cooked_font)
 		return 0;
@@ -745,7 +745,7 @@ static struct sti_rom *sti_get_bmode_rom (unsigned long address)
 
 		raw_font = ((void *)raw) + raw->font_start;
 		font_start = raw_font;
-		
+
 		while (raw_font->next_font) {
 			BMODE_RELOCATE (raw_font->next_font);
 			raw_font = ((void *)font_start) + raw_font->next_font;
@@ -759,7 +759,7 @@ static struct sti_rom *sti_get_wmode_rom(unsigned long address)
 	struct sti_rom *raw;
 	unsigned long size;
 
-	/* read the ROM size directly from the struct in ROM */ 
+	/* read the ROM size directly from the struct in ROM */
 	size = gsc_readl(address + offsetof(struct sti_rom,last_addr));
 
 	raw = kmalloc(size, STI_LOWMEM);
@@ -869,7 +869,7 @@ static struct sti_struct *sti_try_rom_generic(unsigned long address,
 		pr_warn("maximum number of STI ROMS reached !\n");
 		return NULL;
 	}
-	
+
 	sti = kzalloc(sizeof(*sti), GFP_KERNEL);
 	if (!sti)
 		return NULL;
@@ -890,19 +890,19 @@ static struct sti_struct *sti_try_rom_generic(unsigned long address,
 		u32 *rm;
 		i = gsc_readl(address+0x04);
 		if (i != 1) {
-			/* The ROM could have multiple architecture 
+			/* The ROM could have multiple architecture
 			 * dependent images (e.g. i386, parisc,...) */
 			pr_warn("PCI ROM is not a STI ROM type image (0x%8x)\n", i);
 			goto out_err;
 		}
-		
+
 		sti->pd = pd;
 
 		i = gsc_readl(address+0x0c);
 		pr_debug("PCI ROM size (from header) = %d kB\n",
 			le16_to_cpu(i>>16)*512/1024);
 		rm_offset = le16_to_cpu(i & 0xffff);
-		if (rm_offset) { 
+		if (rm_offset) {
 			/* read 16 bytes from the pci region mapper array */
 			rm = (u32*) &sti->rm_entry;
 			*rm++ = gsc_readl(address+rm_offset+0x00);
@@ -915,9 +915,9 @@ static struct sti_struct *sti_try_rom_generic(unsigned long address,
 		pr_debug("sig %04x, PCI STI ROM at %08lx\n", sig, address);
 		goto test_rom;
 	}
-	
+
 	ok = 0;
-	
+
 	if ((sig & 0xff) == 0x01) {
 		pr_debug("    byte mode ROM at %08lx, hpa at %08lx\n",
 		       address, hpa);
@@ -941,7 +941,7 @@ static struct sti_struct *sti_try_rom_generic(unsigned long address,
 	 */
 	if (sti->pd) {
 		unsigned long rom_base;
-		rom_base = pci_resource_start(sti->pd, PCI_ROM_RESOURCE);	
+		rom_base = pci_resource_start(sti->pd, PCI_ROM_RESOURCE);
 		pci_write_config_dword(sti->pd, PCI_ROM_ADDRESS, rom_base & ~PCI_ROM_ADDRESS_ENABLE);
 		pr_debug("STI PCI ROM disabled\n");
 	}
@@ -952,13 +952,13 @@ static struct sti_struct *sti_try_rom_generic(unsigned long address,
 	sti_inq_conf(sti);
 	sti_dump_globcfg(sti->glob_cfg, sti->sti_mem_request);
 	sti_dump_outptr(sti);
-	
+
 	pr_info("    graphics card name: %s\n",
 		sti->sti_data->inq_outptr.dev_name);
 
 	sti_roms[num_sti_roms] = sti;
 	num_sti_roms++;
-	
+
 	return sti;
 
 out_err:
@@ -974,9 +974,9 @@ static void sticore_check_for_default_sti(struct sti_struct *sti, char *path)
 }
 
 /*
- * on newer systems PDC gives the address of the ROM 
+ * on newer systems PDC gives the address of the ROM
  * in the additional address field addr[1] while on
- * older Systems the PDC stores it in page0->proc_sti 
+ * older Systems the PDC stores it in page0->proc_sti
  */
 static int __init sticore_pa_init(struct parisc_device *dev)
 {
@@ -1005,7 +1005,7 @@ static int sticore_pci_init(struct pci_dev *pd, const struct pci_device_id *ent)
 	unsigned int fb_len, rom_len;
 	int err;
 	struct sti_struct *sti;
-	
+
 	err = pci_enable_device(pd);
 	if (err < 0) {
 		dev_err(&pd->dev, "Cannot enable PCI device\n");
@@ -1032,7 +1032,7 @@ static int sticore_pci_init(struct pci_dev *pd, const struct pci_device_id *ent)
 		print_pci_hwpath(pd, sti->pa_path);
 		sticore_check_for_default_sti(sti, sti->pa_path);
 	}
-	
+
 	if (!sti) {
 		pr_warn("Unable to handle STI device '%s'\n", pci_name(pd));
 		return -ENODEV;
diff --git a/drivers/video/fbdev/sticore.h b/drivers/video/fbdev/sticore.h
index 0ebdd28a0b81..c0879352cde4 100644
--- a/drivers/video/fbdev/sticore.h
+++ b/drivers/video/fbdev/sticore.h
@@ -27,11 +27,11 @@
  *
  * Probably the best solution to all this is have the generic code manage
  * the screen buffer and a kernel thread to call STI occasionally.
- * 
+ *
  * Luckily, the frame buffer guys have the same problem so we can just wait
  * for them to fix it and steal their solution.   prumpf
  */
- 
+
 #include <asm/io.h>
 
 #define STI_WAIT 1
@@ -56,7 +56,7 @@
 /* STI function configuration structs */
 
 typedef union region {
-	struct { 
+	struct {
 		u32 offset	: 14;	/* offset in 4kbyte page */
 		u32 sys_only	: 1;	/* don't map to user space */
 		u32 cache	: 1;	/* map to data cache */
@@ -154,7 +154,7 @@ struct sti_conf_inptr {
 };
 
 struct sti_conf_outptr_ext {
-	u32 crt_config[3];	/* hardware specific X11/OGL information */	
+	u32 crt_config[3];	/* hardware specific X11/OGL information */
 	u32 crt_hdw[3];
 	u32 future_ptr;
 };
@@ -211,7 +211,7 @@ struct sti_rom {
 	u32 set_cm_entry;
 	u32 dma_ctrl;
 	 u8 res040[7 * 4];
-	
+
 	u32 init_graph_addr;
 	u32 state_mgmt_addr;
 	u32 font_unp_addr;
@@ -271,7 +271,7 @@ struct sti_font_flags {
 	u32 pad : 30;		/* pad to word boundary */
 	u32 future_ptr; 	/* pointer to future data */
 };
-	
+
 struct sti_font_outptr {
 	s32 errno;		/* error number on failure */
 	u32 future_ptr; 	/* pointer to future data */
@@ -338,7 +338,7 @@ struct sti_all_data {
 
 struct sti_struct {
 	spinlock_t lock;
-		
+
 	/* char **mon_strings; */
 	int sti_mem_request;
 	u32 graphics_id[2];
-- 
2.25.1

