From f45cfceef54035e63e51609fc71ac3d17c1baa39 Mon Sep 17 00:00:00 2001
From: Martina Krasteva <martinax.krasteva@intel.com>
Date: Fri, 26 Jun 2020 12:51:09 +0100
Subject: [PATCH 06/42] media: kmb-flash: Add Keem Bay camera flash

Add support for Keem Bay camera flash.

Signed-off-by: Martina Krasteva <martinax.krasteva@intel.com>
Signed-off-by: Daniele Alessandrelli <daniele.alessandrelli@intel.com>
---
 drivers/media/i2c/Kconfig     |  11 +
 drivers/media/i2c/Makefile    |   1 +
 drivers/media/i2c/kmb-flash.c | 425 ++++++++++++++++++++++++++++++++++
 drivers/media/i2c/kmb-flash.h |  78 +++++++
 4 files changed, 515 insertions(+)
 create mode 100644 drivers/media/i2c/kmb-flash.c
 create mode 100644 drivers/media/i2c/kmb-flash.h

diff --git a/drivers/media/i2c/Kconfig b/drivers/media/i2c/Kconfig
index 81a27c38e323..af3ff488a0d7 100644
--- a/drivers/media/i2c/Kconfig
+++ b/drivers/media/i2c/Kconfig
@@ -1509,6 +1509,17 @@ config VIDEO_LM3646
 	help
 	  This is a driver for the lm3646 dual flash controllers. It controls
 	  flash, torch LEDs.
+
+config VIDEO_INTEL_KMB_FLASH
+	tristate "Keem Bay Camera flash driver support"
+	depends on I2C && VIDEO_V4L2 && MEDIA_CONTROLLER
+	select V4L2_FWNODE
+	help
+	  This is a driver for the Keem Bay camera flash led.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called kmb-flash.
+
 endmenu
 
 endif # VIDEO_V4L2
diff --git a/drivers/media/i2c/Makefile b/drivers/media/i2c/Makefile
index e51cae3ec98c..29bd8182f543 100644
--- a/drivers/media/i2c/Makefile
+++ b/drivers/media/i2c/Makefile
@@ -137,3 +137,4 @@ obj-$(CONFIG_SDR_MAX2175) += max2175.o
 
 obj-$(CONFIG_VIDEO_INTEL_KMB_SENSOR)    += kmb-sensor.o
 obj-$(CONFIG_VIDEO_INTEL_KMB_IMX327)    += kmb-imx327.o
+obj-$(CONFIG_VIDEO_INTEL_KMB_FLASH)	+= kmb-flash.o
diff --git a/drivers/media/i2c/kmb-flash.c b/drivers/media/i2c/kmb-flash.c
new file mode 100644
index 000000000000..3045b4a3b70c
--- /dev/null
+++ b/drivers/media/i2c/kmb-flash.c
@@ -0,0 +1,425 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * kmb-flash.c - KeemBay Camera Flash Driver.
+ *
+ * Copyright (C) 2019 Intel Corporation
+ */
+#include <linux/regulator/consumer.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-subdev.h>
+
+#include "kmb-flash.h"
+
+#define ON			1
+#define OFF			0
+
+/**
+ * kmb_flash_open - Sub-device node open
+ * @sd: pointer to V4L2 sub-device
+ * @fh: pointer to V4L2 sub-device file handle
+ *
+ * Return: 0 if successful
+ */
+static int kmb_flash_open(struct v4l2_subdev *sd,
+			struct v4l2_subdev_fh *fh)
+{
+	struct kmb_flash *kmb_flash = v4l2_get_subdevdata(sd);
+
+	dev_dbg(kmb_flash->subdev.dev, "Open not yet implemented\n");
+	return 0;
+}
+
+/**
+ * kmb_flash_close - Sub-device node close
+ * @sd: pointer to V4L2 sub-device
+ * @fh: pointer to V4L2 sub-device file handle
+ *
+ * Return: 0 if successful
+ */
+static int kmb_flash_close(struct v4l2_subdev *sd,
+			 struct v4l2_subdev_fh *fh)
+{
+	struct kmb_flash *kmb_flash = v4l2_get_subdevdata(sd);
+
+	cancel_work_sync(&kmb_flash->work_flash);
+	dev_dbg(kmb_flash->subdev.dev, "Close not yet implemented\n");
+	return 0;
+}
+
+/**
+ * kmb_flash_g_ctrl - Get new value for the control passed as argument
+ * @ctrl: pointer to control structure
+ *
+ * Return: 0 if successful
+ */
+static int kmb_flash_g_ctrl(struct v4l2_ctrl *ctrl)
+{
+	if (ctrl->id != V4L2_CID_FLASH_FAULT)
+		return -EINVAL;
+
+	return 0;
+}
+
+/**
+ * kmb_flash_set_led_mode - Set flash led mode
+ * @kmb_flash: pointer to kmb flash device
+ * @mode: flash led mode
+ *
+ * Return 0 if successful
+ */
+static int kmb_flash_set_led_mode(struct kmb_flash *kmb_flash, int mode)
+{
+	int ret = 0;
+
+	switch (mode) {
+	case V4L2_FLASH_LED_MODE_NONE:
+		gpiod_set_value_cansleep(kmb_flash->led_gpio, OFF);
+		break;
+	case V4L2_FLASH_LED_MODE_TORCH:
+		gpiod_set_value_cansleep(kmb_flash->led_gpio, ON);
+		break;
+	default:
+		dev_err(kmb_flash->subdev.dev,
+			"%s: unsupported flash mode\n", __func__);
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+/**
+ * kmb_flash_fire - Launches the flash
+ * @work: pointer to work struct
+ *
+ * Return: 0 if successful
+ */
+static void kmb_flash_fire(struct work_struct *work)
+{
+	struct kmb_flash *kmb_flash = container_of(work, struct kmb_flash,
+						   work_flash);
+	unsigned long duration = atomic_read(&kmb_flash->duration);
+
+	gpiod_set_value_cansleep(kmb_flash->led_gpio, ON);
+	usleep_range(duration, duration + 1);
+	gpiod_set_value_cansleep(kmb_flash->led_gpio, OFF);
+}
+
+/**
+ * kmb_flash_s_ctrl - Set new control value
+ * @ctrl: pointer to control structure
+ *
+ * Return: 0 if successful
+ */
+static int kmb_flash_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+	struct v4l2_subdev *sd = &(container_of(ctrl->handler, struct kmb_flash,
+			ctrls.handler)->subdev);
+	struct kmb_flash *kmb_flash = v4l2_get_subdevdata(sd);
+
+	mutex_lock(&kmb_flash->lock);
+	switch (ctrl->id) {
+	case V4L2_CID_FLASH_LED_MODE:
+		ret = kmb_flash_set_led_mode(kmb_flash, ctrl->val);
+		break;
+	case V4L2_CID_FLASH_STROBE_SOURCE:
+		break;
+	case V4L2_CID_FLASH_STROBE:
+		break;
+	case V4L2_CID_FLASH_STROBE_STOP:
+		break;
+	case V4L2_CID_FLASH_TIMEOUT:
+		atomic_set(&kmb_flash->duration, ctrl->val);
+		queue_work(kmb_flash->wq, &kmb_flash->work_flash);
+
+		break;
+	case V4L2_CID_FLASH_INTENSITY:
+	case V4L2_CID_FLASH_TORCH_INTENSITY:
+		ret = 0;
+		break;
+	default:
+		dev_dbg(kmb_flash->subdev.dev, "%s: set %s . Not handled.\n",
+				__func__, v4l2_ctrl_get_name(ctrl->id));
+		ret = -EINVAL;
+	}
+
+	mutex_unlock(&kmb_flash->lock);
+	return ret;
+}
+
+/* V4L2 control operations */
+static const struct v4l2_ctrl_ops kmb_flash_ctrl_ops = {
+	.g_volatile_ctrl = kmb_flash_g_ctrl,
+	.s_ctrl = kmb_flash_s_ctrl,
+};
+
+/**
+ * kmb_flash_initialize_controls - Initialize handled flash controls
+ * @kmb_flash: pointer to kmb flash device
+ *
+ * Return: 0 if successful
+ */
+static int kmb_flash_initialize_controls(struct kmb_flash *kmb_flash)
+{
+	struct kmb_flash_ctrls *ctrls = &kmb_flash->ctrls;
+	struct v4l2_ctrl *fault;
+	int ret;
+
+	dev_dbg(kmb_flash->subdev.dev, "%s\n", __func__);
+
+	v4l2_ctrl_handler_init(&ctrls->handler, 7);
+
+	ctrls->led_mode = v4l2_ctrl_new_std_menu(
+			&ctrls->handler, &kmb_flash_ctrl_ops,
+			V4L2_CID_FLASH_LED_MODE,
+			V4L2_FLASH_LED_MODE_TORCH, 0, V4L2_FLASH_LED_MODE_NONE);
+	ctrls->strobe_source = v4l2_ctrl_new_std_menu(
+			&ctrls->handler, &kmb_flash_ctrl_ops,
+			V4L2_CID_FLASH_STROBE_SOURCE,
+			V4L2_FLASH_STROBE_SOURCE_SOFTWARE, 0, 0);
+	ctrls->strobe = v4l2_ctrl_new_std(
+			&ctrls->handler, &kmb_flash_ctrl_ops,
+			V4L2_CID_FLASH_STROBE,
+			0, 0, 0, 0);
+	ctrls->strobe_stop = v4l2_ctrl_new_std(
+			&ctrls->handler, &kmb_flash_ctrl_ops,
+			V4L2_CID_FLASH_STROBE_STOP,
+			0, 0, 0, 0);
+	ctrls->timeout = v4l2_ctrl_new_std(
+			&ctrls->handler, &kmb_flash_ctrl_ops,
+			V4L2_CID_FLASH_TIMEOUT,
+			10, 500000, 10, 10000);
+	ctrls->timeout->flags |= V4L2_CTRL_FLAG_VOLATILE |
+			V4L2_CTRL_FLAG_EXECUTE_ON_WRITE;
+	ctrls->intensity = v4l2_ctrl_new_std(
+			&ctrls->handler, &kmb_flash_ctrl_ops,
+			V4L2_CID_FLASH_INTENSITY,
+			62500, 999999, 62500, 80000);
+	ctrls->torch_intensity = v4l2_ctrl_new_std(
+			&ctrls->handler, &kmb_flash_ctrl_ops,
+			V4L2_CID_FLASH_TORCH_INTENSITY,
+			31250, 999999, 31250, 40000);
+	fault = v4l2_ctrl_new_std(&ctrls->handler, &kmb_flash_ctrl_ops,
+			V4L2_CID_FLASH_FAULT, 0,
+			V4L2_FLASH_FAULT_OVER_VOLTAGE
+			| V4L2_FLASH_FAULT_OVER_TEMPERATURE
+			| V4L2_FLASH_FAULT_SHORT_CIRCUIT
+			| V4L2_FLASH_FAULT_TIMEOUT, 0, 0);
+
+	if (fault != NULL)
+		fault->flags |= V4L2_CTRL_FLAG_VOLATILE;
+
+	if (ctrls->handler.error) {
+		ret = ctrls->handler.error;
+		v4l2_ctrl_handler_free(&ctrls->handler);
+		dev_err(kmb_flash->subdev.dev, "%s %d ret = %d\n"
+				, __func__, __LINE__, ret);
+		return ret;
+	}
+
+	kmb_flash->subdev.ctrl_handler = &ctrls->handler;
+	return 0;
+}
+
+/**
+ * kmb_flash_s_stream - Set video stream stop/start
+ * @sd: pointer to V4L2 sub-device
+ * @enable: stream state
+ *
+ * Return: 0 if successful
+ */
+static int kmb_flash_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct kmb_flash *kmb_flash = v4l2_get_subdevdata(sd);
+
+	dev_dbg(kmb_flash->subdev.dev, "%s\n", __func__);
+	return 0;
+}
+
+/**
+ * kmb_flash_set_power - Set power state helper function
+ * @kmb_flash: pointer to kmb flash device
+ * @on: power state
+ *
+ * Return: 0 if successful
+ */
+static int kmb_flash_set_power(struct kmb_flash *kmb_flash, bool on)
+{
+	dev_dbg(kmb_flash->subdev.dev, "%s: Set power to %d\n", __func__, on);
+	return 0;
+}
+
+/**
+ * kmb_flash_s_power - Put device in power saving or normal mode
+ * @sd: pointer to V4L2 sub-device
+ * @on: power state (0 - power saving mode, 1 - normal operation mode)
+ *
+ * Return: 0 if successful, else - error
+ */
+static int kmb_flash_s_power(struct v4l2_subdev *sd, int on)
+{
+	struct kmb_flash *kmb_flash = v4l2_get_subdevdata(sd);
+	int ret;
+
+	dev_dbg(kmb_flash->subdev.dev, "%s Power on %d\n", __func__, on);
+
+	mutex_lock(&kmb_flash->power_lock);
+
+	if (kmb_flash->power_on != on) {
+		ret = kmb_flash_set_power(kmb_flash, on);
+		if (!ret) {
+			mutex_unlock(&kmb_flash->power_lock);
+			return ret;
+		}
+	}
+
+	kmb_flash->power_on = on;
+
+	mutex_unlock(&kmb_flash->power_lock);
+
+	return 0;
+}
+
+/* sub-device internal operations */
+static const struct v4l2_subdev_internal_ops kmb_flash_sd_internal_ops = {
+	.open = kmb_flash_open,
+	.close = kmb_flash_close,
+};
+
+/* sub-device core operations */
+static struct v4l2_subdev_core_ops kmb_flash_subdev_core_ops = {
+	.s_power = kmb_flash_s_power,
+};
+
+/* sub-device video operations */
+static struct v4l2_subdev_video_ops kmb_flash_subdev_video_ops = {
+	.s_stream = kmb_flash_s_stream,
+};
+
+/* sub-device operations */
+static const struct v4l2_subdev_ops kmb_flash_subdev_ops = {
+	.core = &kmb_flash_subdev_core_ops,
+	.video = &kmb_flash_subdev_video_ops,
+};
+
+/**
+ * kmb_flash_probe - I2C client device binding
+ * @client: pointer to i2c client device
+ * @id: pointer to i2c device id
+ *
+ * Return: 0 if successful, -ENOMEM if there is not enough memory
+ */
+static int kmb_flash_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	int ret = 0;
+	struct v4l2_subdev *sd;
+	struct kmb_flash *kmb_flash;
+
+	dev_dbg(&client->dev, "%s: Probe KMB flash\n", __func__);
+
+	kmb_flash = devm_kzalloc(&client->dev,
+			sizeof(*kmb_flash), GFP_KERNEL);
+	if (!kmb_flash)
+		return -ENOMEM;
+
+	mutex_init(&kmb_flash->lock);
+	kmb_flash->client = client;
+
+	kmb_flash->led_gpio = devm_gpiod_get_optional(&client->dev, "flash",
+						      GPIOD_OUT_LOW);
+
+	if (kmb_flash->led_gpio == NULL) {
+		dev_err(&client->dev, "no flash has been detected");
+	} else if (IS_ERR(kmb_flash->led_gpio)) {
+		dev_err(&client->dev, "failed to request flash gpio %d", ret);
+		return PTR_ERR(kmb_flash->led_gpio);
+	}
+
+	sd = &kmb_flash->subdev;
+	v4l2_i2c_subdev_init(&kmb_flash->subdev, client,
+			&kmb_flash_subdev_ops);
+	v4l2_subdev_init(&kmb_flash->subdev, &kmb_flash_subdev_ops);
+	strlcpy(sd->name, KMB_FLASH_DRV_NAME, sizeof(sd->name));
+	sd->internal_ops = &kmb_flash_sd_internal_ops;
+	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE |
+				V4L2_SUBDEV_FL_HAS_EVENTS;
+	sd->entity.function = MEDIA_ENT_F_FLASH;
+
+	v4l2_set_subdevdata(sd, kmb_flash);
+
+	kmb_flash->wq = alloc_workqueue("flash_work_queue", WQ_UNBOUND, 1);
+	if (kmb_flash->wq == NULL) {
+		ret = -ENOMEM;
+		dev_err(&client->dev, "cannot create flash workqueue");
+	}
+
+	INIT_WORK(&kmb_flash->work_flash, kmb_flash_fire);
+	atomic_set(&kmb_flash->duration, 0);
+
+	ret = kmb_flash_initialize_controls(kmb_flash);
+	if (ret < 0)
+		goto error_media_entity_cleanup;
+
+	v4l2_set_subdev_hostdata(sd, &kmb_flash->subdev);
+
+	ret = v4l2_async_register_subdev(sd);
+	if (ret < 0)
+		goto error_free_ctrl_handler;
+
+	return 0;
+
+error_free_ctrl_handler:
+	v4l2_ctrl_handler_free(sd->ctrl_handler);
+error_media_entity_cleanup:
+	media_entity_cleanup(&sd->entity);
+	return ret;
+}
+
+/**
+ * kmb_flash_remove - I2C client device unbinding
+ * @client: pointer to I2C client device
+ *
+ * Return: 0 if successful
+ */
+static int kmb_flash_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct kmb_flash *kmb_flash = v4l2_get_subdevdata(sd);
+
+	dev_info(sd->dev, "%s: Remove KMB flash\n", __func__);
+
+	mutex_destroy(&kmb_flash->lock);
+	v4l2_async_unregister_subdev(sd);
+	v4l2_ctrl_handler_free(sd->ctrl_handler);
+	media_device_unregister_entity(&sd->entity);
+	media_entity_cleanup(&sd->entity);
+
+	return 0;
+}
+
+static const struct i2c_device_id kmb_flash_id_table[] = {
+	{KMB_FLASH_DRV_NAME, 0},
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, kmb_flash_id_table);
+
+static struct i2c_driver kmb_flash_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = KMB_FLASH_DRV_NAME,
+	},
+	.probe = kmb_flash_probe,
+	.remove = kmb_flash_remove,
+	.id_table = kmb_flash_id_table,
+};
+
+module_i2c_driver(kmb_flash_i2c_driver);
+
+MODULE_DESCRIPTION("KeemBay I2C Flash driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/i2c/kmb-flash.h b/drivers/media/i2c/kmb-flash.h
new file mode 100644
index 000000000000..1f8b89406ecd
--- /dev/null
+++ b/drivers/media/i2c/kmb-flash.h
@@ -0,0 +1,78 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * kmb-flash.h - KeemBay Camera Flash Driver.
+ *
+ * Copyright (C) 2019 Intel Corporation
+ */
+#ifndef KMB_FLASH_H
+#define KMB_FLASH_H
+
+#include <linux/atomic.h>
+#include <linux/workqueue.h>
+
+#define KMB_FLASH_DRV_NAME "kmb-camera-flash"
+
+/**
+ * struct kmb_flash_ctrls - KMB Camera Flash controls structure
+ * @handler: control handler
+ * @led_mode: led mode control
+ * @strobe_source: strobe source control
+ * @strobe: strobe control
+ * @strobe_stop: strobe stop control
+ * @timeout: timeout control
+ * @intensity: intensity control
+ * @torch_intensity: torch intensity control
+ * @update: update flag
+ */
+struct kmb_flash_ctrls {
+	struct v4l2_ctrl_handler handler;
+	struct v4l2_ctrl *led_mode;
+	struct v4l2_ctrl *strobe_source;
+	struct v4l2_ctrl *strobe;
+	struct v4l2_ctrl *strobe_stop;
+	struct v4l2_ctrl *timeout;
+	struct v4l2_ctrl *intensity;
+	struct v4l2_ctrl *torch_intensity;
+	u8 update;
+};
+
+/**
+ * struct i2c_arr - Array representation of address - value pair
+ * @addr: address
+ * @val: value
+ */
+struct i2c_arr {
+	u16 addr;
+	u16 val;
+};
+
+/**
+ * struct kmb_flash - KMB Camera Flash device structure
+ * @client: pointer to i2c client device
+ * @lock: mutex
+ * @wq: pointer to work queue
+ * @work_flash: job to be done
+ * @subdev: V4L2 sub-device
+ * @led_gpio: gpio for controlling a led
+ * @ctrls: flash controls
+ * @power_lock: mutex to protect power settings
+ * @power_on: power on flag
+ * @duration: duration in us
+ */
+struct kmb_flash {
+	struct i2c_client *client;
+	struct mutex lock;
+
+	struct workqueue_struct *wq;
+	struct work_struct work_flash;
+
+	struct v4l2_subdev subdev;
+	struct gpio_desc *led_gpio;
+	struct kmb_flash_ctrls ctrls;
+
+	struct mutex power_lock;
+	bool power_on;
+	atomic_t duration;
+};
+
+#endif /* KMB_FLASH_H */
-- 
2.17.1

