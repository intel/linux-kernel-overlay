From d6d46e55132cad8d2eb1c34fa4e75e8ee353212e Mon Sep 17 00:00:00 2001
From: Vandita Kulkarni <vandita.kulkarni@intel.com>
Date: Sat, 2 Apr 2022 12:22:19 +0530
Subject: [PATCH 1072/1096] drm/i915/hdmi21/mtl: Add support for dsc mode valid

With the best fit compression bpp, check if the
mode can be supported with dsc.

v2: Fixed the dsc_bit_rate calculation and other minor refactoring (Uma)
Add check for port clock valid with DSC enabled. (Ankit)

v3: Rebase and moved get_dsc_slice_count, before intel_hdmi_mode_valid

Signed-off-by: Vandita Kulkarni <vandita.kulkarni@intel.com>
Signed-off-by: Ankit Nautiyal <ankit.k.nautiyal@intel.com>
Reviewed-by: Uma Shankar <uma.shankar@intel.com>
---
 drivers/gpu/drm/i915/display/intel_hdmi.c | 93 ++++++++++++++++++++++-
 1 file changed, 90 insertions(+), 3 deletions(-)

diff --git a/drivers/gpu/drm/i915/display/intel_hdmi.c b/drivers/gpu/drm/i915/display/intel_hdmi.c
index 5a20c4496c55..5f7c786ec0aa 100644
--- a/drivers/gpu/drm/i915/display/intel_hdmi.c
+++ b/drivers/gpu/drm/i915/display/intel_hdmi.c
@@ -80,6 +80,11 @@ static void
 get_dsc_min_max_bpp(enum intel_output_format output_format, u8 bpc,
 		    bool hdmi_all_bpp, int *min_dsc_bpp, int *max_dsc_bpp);
 
+static int get_dsc_slice_count(struct intel_hdmi *intel_hdmi,
+			       const struct drm_display_mode *mode,
+			       enum intel_output_format output_format,
+			       bool use_bigjoiner);
+
 inline struct drm_i915_private *intel_hdmi_to_i915(struct intel_hdmi *intel_hdmi)
 {
 	return to_i915(hdmi_to_dig_port(intel_hdmi)->base.base.dev);
@@ -2137,6 +2142,78 @@ intel_hdmi_mode_clock_valid(struct drm_connector *connector, int clock,
 	return status;
 }
 
+static enum drm_mode_status
+intel_hdmi_dsc_mode_valid(struct drm_connector *connector,
+			  struct drm_display_mode *mode, int clock,
+			  bool ycbcr420_only)
+{
+	struct intel_hdmi *hdmi = intel_attached_hdmi(to_intel_connector(connector));
+	int slice_count, slice_width, src_frc_bpp;
+	int pixel_rate_kbps, dsc_frl_rate_kbps, hdmi_max_chunk_bytes;
+	int compressed_bpp_x16, frl_symbol_clock, frl_bit_rate_required;
+	bool hdmi_all_bpp, bigjoiner;
+	u8 min_bpc;
+
+	/* TBD: get the lowest dsc bpc from the common pool of src and sink */
+	min_bpc = 8;
+
+	/* TBD: bigjoiner support */
+	bigjoiner = false;
+	 /* TBD: need to add dsc support for other formats*/
+	if (ycbcr420_only)
+		return MODE_CLOCK_HIGH;
+
+	slice_count = get_dsc_slice_count(hdmi, mode, INTEL_OUTPUT_FORMAT_RGB,
+					  bigjoiner);
+	if (slice_count == 0)
+		return MODE_CLOCK_HIGH;
+
+	slice_width = mode->hdisplay / slice_count;
+	src_frc_bpp = 0;
+
+	hdmi_max_chunk_bytes =
+			connector->display_info.hdmi.dsc_cap.total_chunk_kbytes * 1024;
+	hdmi_all_bpp = connector->display_info.hdmi.dsc_cap.all_bpp;
+
+	/*
+	 * Check if we get a valid compressed bpp with the min bpc for the given
+	 * mode, and src/sink capabilities. If we do not get a valid compressed
+	 * bpp with the min bpc, then the mode cannot be supported.
+	 */
+	compressed_bpp_x16 = intel_hdmi_dsc_get_bpp(src_frc_bpp, slice_width, slice_count,
+						    INTEL_OUTPUT_FORMAT_RGB, min_bpc,
+						    hdmi_all_bpp, hdmi_max_chunk_bytes);
+	if (compressed_bpp_x16 == 0)
+		return MODE_CLOCK_HIGH;
+
+	pixel_rate_kbps = clock * DIV_ROUND_UP(compressed_bpp_x16, 16);
+
+	dsc_frl_rate_kbps = hdmi->max_dsc_frl_rate * 1000000;
+
+	/* Check if mode can be supported with max available dsc rate */
+	if (pixel_rate_kbps > dsc_frl_rate_kbps)
+		return MODE_CLOCK_HIGH;
+
+	/*
+	 * Check if mode can be supported by the port clock.
+	 * First get the required Fixed rate that will support the given b/w
+	 * with compression.
+	 * Next, get the frl symbol clock and see it its supported by our port
+	 * clock.
+	 */
+	frl_bit_rate_required = intel_hdmi_frl_required_bitrate(pixel_rate_kbps);
+
+	frl_symbol_clock = DIV_ROUND_UP(frl_bit_rate_required, 18);
+
+	return hdmi_port_frl_clock_valid(hdmi, frl_symbol_clock);
+}
+
+static bool
+intel_hdmi_src_dsc_supported(struct drm_i915_private *dev_priv)
+{
+	return DISPLAY_VER(dev_priv) >= 14;
+}
+
 static enum drm_mode_status
 intel_hdmi_mode_valid(struct drm_connector *connector,
 		      struct drm_display_mode *mode)
@@ -2147,7 +2224,10 @@ intel_hdmi_mode_valid(struct drm_connector *connector,
 	int clock = mode->clock;
 	int max_dotclk = to_i915(connector->dev)->max_dotclk_freq;
 	bool has_hdmi_sink = intel_has_hdmi_sink(hdmi, connector->state);
-	bool ycbcr_420_only;
+	bool ycbcr_420_only, dsc;
+
+	dsc = intel_hdmi_src_dsc_supported(dev_priv) &&
+		connector->display_info.hdmi.dsc_cap.v_1p2;
 
 	if ((mode->flags & DRM_MODE_FLAG_3D_MASK) == DRM_MODE_FLAG_3D_FRAME_PACKING)
 		clock *= 2;
@@ -2176,14 +2256,21 @@ intel_hdmi_mode_valid(struct drm_connector *connector,
 	if (status != MODE_OK) {
 		if (ycbcr_420_only ||
 		    !connector->ycbcr_420_allowed ||
-		    !drm_mode_is_420_also(&connector->display_info, mode))
+		    !drm_mode_is_420_also(&connector->display_info, mode) ||
+		    !dsc)
 			return status;
 
 		status = intel_hdmi_mode_clock_valid(connector, clock, has_hdmi_sink, true);
-		if (status != MODE_OK)
+		if (status != MODE_OK || !dsc)
 			return status;
 	}
 
+	if (status != MODE_OK && dsc)
+		status = intel_hdmi_dsc_mode_valid(connector, mode, clock, ycbcr_420_only);
+
+	if (status != MODE_OK)
+		return status;
+
 	return intel_mode_valid_max_plane_size(dev_priv, mode, false);
 }
 
-- 
2.25.1

