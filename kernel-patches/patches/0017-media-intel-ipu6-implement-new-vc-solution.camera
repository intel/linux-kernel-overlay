From cfb5743695d51c3d275a3646d140336c6e515358 Mon Sep 17 00:00:00 2001
From: zouxiaoh <xiaohong.zou@intel.com>
Date: Mon, 28 Nov 2022 17:23:43 +0800
Subject: [PATCH 17/21] media: intel-ipu6: implement new vc solution

Signed-off-by: zouxiaoh <xiaohong.zou@intel.com>
---
 drivers/media/i2c/ar0234.c                    |  148 +-
 drivers/media/i2c/d4xx.c                      | 4298 +++++++++++++++++
 drivers/media/i2c/hm11b1.c                    | 1185 +++++
 drivers/media/i2c/lt6911uxc.c                 |  190 +-
 drivers/media/i2c/ov01a10.c                   |  917 ++++
 drivers/media/i2c/ov01a1s.c                   | 1017 ++++
 drivers/media/i2c/ov02c10.c                   | 1304 +++++
 drivers/media/i2c/ov13858_intel.c             | 2067 ++++++++
 drivers/media/i2c/ov8856.c                    | 2357 +++------
 drivers/media/i2c/power_ctrl_logic.c          |  149 +
 drivers/media/i2c/power_ctrl_logic.h          |    9 +
 drivers/media/pci/intel/Kconfig               |    6 +-
 drivers/media/pci/intel/ipu-buttress.c        |   95 +-
 drivers/media/pci/intel/ipu-buttress.h        |    3 +-
 drivers/media/pci/intel/ipu-cpd.c             |    9 +-
 drivers/media/pci/intel/ipu-dma.c             |  162 +-
 drivers/media/pci/intel/ipu-fw-com.c          |   13 +-
 drivers/media/pci/intel/ipu-fw-isys.h         |    6 -
 drivers/media/pci/intel/ipu-fw-psys.c         |   32 -
 .../media/pci/intel/ipu-isys-csi2-be-soc.c    |  169 +-
 drivers/media/pci/intel/ipu-isys-csi2-be.c    |   14 +-
 drivers/media/pci/intel/ipu-isys-csi2-be.h    |   15 +-
 drivers/media/pci/intel/ipu-isys-csi2.c       |  439 +-
 drivers/media/pci/intel/ipu-isys-csi2.h       |   29 +-
 drivers/media/pci/intel/ipu-isys-queue.c      |   74 +-
 drivers/media/pci/intel/ipu-isys-queue.h      |    1 +
 drivers/media/pci/intel/ipu-isys-subdev.c     |  357 +-
 drivers/media/pci/intel/ipu-isys-subdev.h     |   22 +-
 drivers/media/pci/intel/ipu-isys-tpg.c        |    6 +-
 drivers/media/pci/intel/ipu-isys-video.c      |  606 ++-
 drivers/media/pci/intel/ipu-isys-video.h      |   52 +-
 drivers/media/pci/intel/ipu-isys.c            |  657 +--
 drivers/media/pci/intel/ipu-isys.h            |   73 +-
 drivers/media/pci/intel/ipu-pdata.h           |   13 +-
 drivers/media/pci/intel/ipu-psys.c            |  103 +-
 drivers/media/pci/intel/ipu-psys.h            |   10 -
 drivers/media/pci/intel/ipu-trace-event.h     |  136 -
 drivers/media/pci/intel/ipu-trace.c           |   43 +-
 drivers/media/pci/intel/ipu-trace.h           |    1 +
 drivers/media/pci/intel/ipu.c                 |  110 +-
 drivers/media/pci/intel/ipu.h                 |    3 +
 drivers/media/pci/intel/ipu6/Makefile         |    7 +-
 .../intel/ipu6/ipu-platform-buttress-regs.h   |   11 +
 .../intel/ipu6/ipu-platform-isys-csi2-reg.h   |    6 +-
 .../media/pci/intel/ipu6/ipu-platform-isys.h  |    6 +-
 .../media/pci/intel/ipu6/ipu-platform-regs.h  |   15 +
 drivers/media/pci/intel/ipu6/ipu-platform.h   |    4 +
 drivers/media/pci/intel/ipu6/ipu-resources.c  |   27 +-
 .../media/pci/intel/ipu6/ipu6-fw-resources.c  |    5 +-
 drivers/media/pci/intel/ipu6/ipu6-isys-csi2.c |  237 +-
 .../media/pci/intel/ipu6/ipu6-isys-dwc-phy.c  |  539 +++
 .../media/pci/intel/ipu6/ipu6-isys-dwc-phy.h  |   15 +
 drivers/media/pci/intel/ipu6/ipu6-isys-phy.c  |   70 +
 drivers/media/pci/intel/ipu6/ipu6-isys-phy.h  |    5 +
 drivers/media/pci/intel/ipu6/ipu6-isys.c      |  204 +-
 drivers/media/pci/intel/ipu6/ipu6-psys.c      |   44 -
 drivers/media/pci/intel/ipu6/ipu6.c           |   33 +-
 drivers/media/platform/intel/Kconfig          |   17 +-
 drivers/media/platform/intel/Makefile         |    5 +-
 .../media/platform/intel/ipu6-acpi-common.c   |  355 ++
 .../media/platform/intel/ipu6-acpi-pdata.c    |  843 ++++
 drivers/media/platform/intel/ipu6-acpi.c      |  833 +---
 .../media/platform/intel/ipu6-adlrvp-pdata.c  |  130 +-
 .../media/platform/intel/ipu6-tglrvp-pdata.c  |   82 +-
 include/media/ar0234.h                        |    2 +
 include/media/d4xx.h                          |   23 +
 include/media/imx390.h                        |    2 +
 include/media/ipu-acpi-pdata.h                |   76 +
 include/media/ipu-acpi.h                      |   72 +-
 include/media/ipu-isys.h                      |    8 +
 include/uapi/linux/ipu-isys.h                 |    5 +-
 71 files changed, 15319 insertions(+), 5262 deletions(-)
 create mode 100644 drivers/media/i2c/d4xx.c
 create mode 100644 drivers/media/i2c/hm11b1.c
 create mode 100644 drivers/media/i2c/ov01a10.c
 create mode 100644 drivers/media/i2c/ov01a1s.c
 create mode 100644 drivers/media/i2c/ov02c10.c
 create mode 100644 drivers/media/i2c/ov13858_intel.c
 create mode 100644 drivers/media/i2c/power_ctrl_logic.c
 create mode 100644 drivers/media/i2c/power_ctrl_logic.h
 delete mode 100644 drivers/media/pci/intel/ipu-trace-event.h
 create mode 100644 drivers/media/pci/intel/ipu6/ipu6-isys-dwc-phy.c
 create mode 100644 drivers/media/pci/intel/ipu6/ipu6-isys-dwc-phy.h
 create mode 100644 drivers/media/platform/intel/ipu6-acpi-common.c
 create mode 100644 drivers/media/platform/intel/ipu6-acpi-pdata.c
 create mode 100644 include/media/d4xx.h
 create mode 100644 include/media/ipu-acpi-pdata.h

diff --git a/drivers/media/i2c/ar0234.c b/drivers/media/i2c/ar0234.c
index fd72f0aaa15f..611451bcb87c 100644
--- a/drivers/media/i2c/ar0234.c
+++ b/drivers/media/i2c/ar0234.c
@@ -14,7 +14,9 @@
 #include <media/v4l2-device.h>
 #include <media/v4l2-fwnode.h>
 #include <media/ar0234.h>
+#include <linux/version.h>
 
+#include <linux/ipu-isys.h>
 
 #define AR0234_REG_VALUE_08BIT		1
 #define AR0234_REG_VALUE_16BIT		2
@@ -1338,7 +1340,6 @@ struct ar0234 {
 
 	/* V4L2 Controls */
 	struct v4l2_ctrl *link_freq;
-	struct v4l2_ctrl *mipi_lanes;
 	struct v4l2_ctrl *vblank;
 	struct v4l2_ctrl *exposure;
 	struct v4l2_ctrl *analogue_gain;
@@ -1357,6 +1358,8 @@ struct ar0234 {
 	struct v4l2_ctrl *hblank;
 	struct v4l2_ctrl *vflip;
 	struct v4l2_ctrl *hflip;
+	struct v4l2_ctrl *query_sub_stream;
+	struct v4l2_ctrl *set_sub_stream;
 
 	/* Current mode */
 	const struct ar0234_mode *cur_mode;
@@ -1493,6 +1496,8 @@ static u64 get_hblank(struct ar0234 *ar0234)
 	return hblank;
 }
 
+static int ar0234_set_stream(struct v4l2_subdev *sd, int enable);
+
 static int ar0234_set_ctrl(struct v4l2_ctrl *ctrl)
 {
 	struct ar0234 *ar0234 = container_of(ctrl->handler,
@@ -1502,6 +1507,15 @@ static int ar0234_set_ctrl(struct v4l2_ctrl *ctrl)
 	int ret = 0;
 	u32 val;
 
+	if (ctrl->id == V4L2_CID_IPU_SET_SUB_STREAM) {
+		val = (*ctrl->p_new.p_s64 & 0xFFFF);
+		dev_info(&client->dev, "V4L2_CID_IPU_SET_SUB_STREAM %x\n", val);
+		mutex_unlock(&ar0234->mutex);
+		ret = ar0234_set_stream(&ar0234->sd, val & 0x00FF);
+		mutex_lock(&ar0234->mutex);
+		return ret;
+	}
+
 	/* Propagate change of current control to all related controls */
 	if (ctrl->id == V4L2_CID_VBLANK) {
 		/* Update max exposure while meeting expected vblanking */
@@ -1540,11 +1554,6 @@ static int ar0234_set_ctrl(struct v4l2_ctrl *ctrl)
 				       ar0234->cur_mode->height + ctrl->val);
 		dev_dbg(&client->dev, "set vblank %d\n", ar0234->cur_mode->height + ctrl->val);
 		break;
-
-	case V4L2_CID_MIPI_LANES:
-		dev_dbg(&client->dev, "set mipi lane %d\n", ctrl->val);
-		break;
-
 	case V4L2_CID_FLASH_STROBE_SOURCE:
 		dev_dbg(&client->dev, "set led flash source %d\n", ctrl->val);
 		break;
@@ -1600,7 +1609,11 @@ static int ar0234_set_ctrl(struct v4l2_ctrl *ctrl)
 				val);
 		dev_info(&client->dev, "set hflip %d\n", ctrl->val);
 		break;
+	case V4L2_CID_IPU_QUERY_SUB_STREAM:
+		dev_dbg(&client->dev, "query stream\n");
+		break;
 	default:
+		dev_err(&client->dev, "unexpected ctrl id 0x%08x\n", ctrl->id);
 		ret = -EINVAL;
 		break;
 	}
@@ -1686,6 +1699,83 @@ static struct v4l2_ctrl_config ar0234_frame_interval = {
 	.flags	= V4L2_CTRL_FLAG_READ_ONLY,
 };
 
+static struct v4l2_ctrl_config ar0234_q_sub_stream = {
+	.ops = &ar0234_ctrl_ops,
+	.id = V4L2_CID_IPU_QUERY_SUB_STREAM,
+	.name = "query virtual channel",
+	.type = V4L2_CTRL_TYPE_INTEGER_MENU,
+	.max = 1,
+	.min = 0,
+	.def = 0,
+	.menu_skip_mask = 0,
+	.qmenu_int = NULL,
+};
+
+static const struct v4l2_ctrl_config ar0234_s_sub_stream = {
+	.ops = &ar0234_ctrl_ops,
+	.id = V4L2_CID_IPU_SET_SUB_STREAM,
+	.name = "set virtual channel",
+	.type = V4L2_CTRL_TYPE_INTEGER64,
+	.max = 0xFFFF,
+	.min = 0,
+	.def = 0,
+	.step = 1,
+};
+
+#define MIPI_CSI2_TYPE_RAW8    0x2a
+#define MIPI_CSI2_TYPE_RAW10   0x2b
+
+static unsigned int mbus_code_to_mipi(u32 code)
+{
+	switch (code) {
+	case MEDIA_BUS_FMT_SGRBG10_1X10:
+		return MIPI_CSI2_TYPE_RAW10;
+	case MEDIA_BUS_FMT_SGRBG8_1X8:
+		return MIPI_CSI2_TYPE_RAW8;
+	default:
+		WARN_ON(1);
+		return -EINVAL;
+	}
+}
+
+static void set_sub_stream_fmt(s64 *sub_stream, u32 code)
+{
+       *sub_stream &= 0xFFFFFFFFFFFF0000;
+       *sub_stream |= code;
+}
+
+static void set_sub_stream_h(s64 *sub_stream, u32 height)
+{
+       s64 val = height;
+       val &= 0xFFFF;
+       *sub_stream &= 0xFFFFFFFF0000FFFF;
+       *sub_stream |= val << 16;
+}
+
+static void set_sub_stream_w(s64 *sub_stream, u32 width)
+{
+       s64 val = width;
+       val &= 0xFFFF;
+       *sub_stream &= 0xFFFF0000FFFFFFFF;
+       *sub_stream |= val << 32;
+}
+
+static void set_sub_stream_dt(s64 *sub_stream, u32 dt)
+{
+       s64 val = dt;
+       val &= 0xFF;
+       *sub_stream &= 0xFF00FFFFFFFFFFFF;
+       *sub_stream |= val << 48;
+}
+
+static void set_sub_stream_vc_id(s64 *sub_stream, u32 vc_id)
+{
+       s64 val = vc_id;
+       val &= 0xFF;
+       *sub_stream &= 0x00FFFFFFFFFFFFFF;
+       *sub_stream |= val << 56;
+}
+
 static int ar0234_init_controls(struct ar0234 *ar0234)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(&ar0234->sd);
@@ -1725,14 +1815,6 @@ static int ar0234_init_controls(struct ar0234 *ar0234)
 					     AR0234_EXPOSURE_MIN, exposure_max,
 					     AR0234_EXPOSURE_STEP,
 					     exposure_max);
-	cfg.ops = &ar0234_ctrl_ops;
-	cfg.id = V4L2_CID_MIPI_LANES;
-	cfg.name = "V4L2_CID_MIPI_LANES";
-	cfg.type = V4L2_CTRL_TYPE_INTEGER;
-	cfg.max = 4; cfg.min = 2; cfg.step = 2; cfg.def = 4;
-	cfg.qmenu = 0; cfg.elem_size = 0;
-	ar0234->mipi_lanes = v4l2_ctrl_new_custom(ctrl_hdlr, &cfg, NULL);
-
 	ar0234->strobe_source = v4l2_ctrl_new_std_menu(
 			ctrl_hdlr, &ar0234_ctrl_ops,
 			V4L2_CID_FLASH_STROBE_SOURCE,
@@ -1776,12 +1858,31 @@ static int ar0234_init_controls(struct ar0234 *ar0234)
 	ar0234->hflip = v4l2_ctrl_new_std(ctrl_hdlr, &ar0234_ctrl_ops,
 					  V4L2_CID_HFLIP, 0, 1, 1, 0);
 
+	ar0234_q_sub_stream.qmenu_int = devm_kzalloc(&client->dev, sizeof(s64), GFP_KERNEL);
+	if (!ar0234_q_sub_stream.qmenu_int) {
+		dev_dbg(&client->dev, "failed alloc mem for query sub stream.\n");
+		return -ENOMEM;
+	}
+	ar0234->query_sub_stream = v4l2_ctrl_new_custom(ctrl_hdlr, &ar0234_q_sub_stream, NULL);
+	if (ctrl_hdlr->error) {
+		dev_dbg(&client->dev, "new query sub stream ctrl, error = %d.\n",
+			ctrl_hdlr->error);
+		return ctrl_hdlr->error;
+	}
+
+	ar0234->set_sub_stream = v4l2_ctrl_new_custom(ctrl_hdlr, &ar0234_s_sub_stream, NULL);
+	if (ctrl_hdlr->error) {
+		dev_dbg(&client->dev, "new set sub stream ctrl, error = %d.\n",
+			ctrl_hdlr->error);
+		return ctrl_hdlr->error;
+	}
+
 	if (ctrl_hdlr->error)
 		return ctrl_hdlr->error;
 
 	ar0234->sd.ctrl_handler = ctrl_hdlr;
 
-	return 0;
+	return ret;
 }
 
 static void ar0234_update_pad_format(const struct ar0234_mode *mode,
@@ -1816,7 +1917,9 @@ static int ar0234_start_streaming(struct ar0234 *ar0234)
 		}
 	}
 
+	ar0234->set_sub_stream->flags |= V4L2_CTRL_FLAG_READ_ONLY;
 	ret = __v4l2_ctrl_handler_setup(ar0234->sd.ctrl_handler);
+	ar0234->set_sub_stream->flags &= ~V4L2_CTRL_FLAG_READ_ONLY;
 	if (ret)
 		return ret;
 
@@ -1849,7 +1952,6 @@ static int ar0234_set_stream(struct v4l2_subdev *sd, int enable)
 	struct ar0234 *ar0234 = to_ar0234(sd);
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
 	int ret = 0;
-
 	if (ar0234->streaming == enable)
 		return 0;
 
@@ -1939,9 +2041,8 @@ static int ar0234_set_format(struct v4l2_subdev *sd,
 	s32 vblank_def;
 	s64 hblank;
 	int i;
-	s32 mipi_lanes;
+	s64 *sub_stream;
 
-	mipi_lanes = ar0234->mipi_lanes->val;
 	for (i = 0; i < ARRAY_SIZE(supported_modes); i++) {
 		if (supported_modes[i].width != fmt->format.width
 			|| supported_modes[i].height != fmt->format.height) {
@@ -1952,10 +2053,6 @@ static int ar0234_set_format(struct v4l2_subdev *sd,
 			dev_dbg(&client->dev, "pixel format doesn't match\n");
 			continue;
 		}
-		if (supported_modes[i].lanes != mipi_lanes) {
-			dev_dbg(&client->dev, "mipi lanes doesn't match\n");
-			continue;
-		}
 		mode = &supported_modes[i];
 		break;
 	}
@@ -1994,6 +2091,13 @@ static int ar0234_set_format(struct v4l2_subdev *sd,
 		__v4l2_ctrl_s_ctrl(ar0234->fps, mode->fps);
 
 		__v4l2_ctrl_s_ctrl(ar0234->frame_interval, 1000 / mode->fps);
+
+		sub_stream = ar0234->query_sub_stream->qmenu_int;
+		set_sub_stream_fmt(sub_stream, mode->code);
+		set_sub_stream_h(sub_stream, mode->height);
+		set_sub_stream_w(sub_stream, mode->width);
+		set_sub_stream_dt(sub_stream, mbus_code_to_mipi(mode->code));
+		set_sub_stream_vc_id(sub_stream, 0);
 	}
 
 	mutex_unlock(&ar0234->mutex);
diff --git a/drivers/media/i2c/d4xx.c b/drivers/media/i2c/d4xx.c
new file mode 100644
index 000000000000..c423c5342878
--- /dev/null
+++ b/drivers/media/i2c/d4xx.c
@@ -0,0 +1,4298 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * ds5.c - Intel(R) RealSense(TM) D4XX camera driver
+ *
+ * Copyright (c) 2017-2022, INTEL CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/kernel.h>
+#include <linux/media.h>
+#include <linux/module.h>
+#include <linux/of_gpio.h>
+#include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/videodev2.h>
+#include <linux/version.h>
+
+#include <linux/ipu-isys.h>
+
+#include <media/media-entity.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-mediabus.h>
+#include <media/d4xx.h>
+
+//#define DS5_DRIVER_NAME "DS5 RealSense camera driver"
+#define DS5_DRIVER_NAME "d4xx"
+#define DS5_DRIVER_NAME_AWG "d4xx-awg"
+#define DS5_DRIVER_NAME_ASR "d4xx-asr"
+#define DS5_DRIVER_NAME_CLASS "d4xx-class"
+#define DS5_DRIVER_NAME_DFU "d4xx-dfu"
+
+#define DS5_MIPI_SUPPORT_LINES		0x0300
+#define DS5_MIPI_SUPPORT_PHY		0x0304
+#define DS5_MIPI_DATARATE_MIN		0x0308
+#define DS5_MIPI_DATARATE_MAX		0x030A
+#define DS5_FW_VERSION			0x030C
+#define DS5_FW_BUILD			0x030E
+#define DS5_DEVICE_TYPE			0x0310
+#define DS5_DEVICE_TYPE_D45X		6
+#define DS5_DEVICE_TYPE_D43X		5
+#define DS5_DEVICE_TYPE_D46X		4
+
+#define DS5_MIPI_LANE_NUMS		0x0400
+#define DS5_MIPI_LANE_DATARATE		0x0402
+#define DS5_MIPI_CONF_STATUS		0x0500
+
+#define DS5_START_STOP_STREAM		0x1000
+#define DS5_DEPTH_STREAM_STATUS		0x1004
+#define DS5_RGB_STREAM_STATUS		0x1008
+#define DS5_IMU_STREAM_STATUS		0x100C
+#define DS5_IR_STREAM_STATUS		0x1014
+
+#define DS5_STREAM_DEPTH		0x0
+#define DS5_STREAM_RGB			0x1
+#define DS5_STREAM_IMU			0x2
+#define DS5_STREAM_IR			0x4
+#define DS5_STREAM_STOP			0x100
+#define DS5_STREAM_START		0x200
+#define DS5_STREAM_IDLE			0x1
+#define DS5_STREAM_STREAMING		0x2
+
+#define DS5_DEPTH_STREAM_DT		0x4000
+#define DS5_DEPTH_STREAM_MD		0x4002
+#define DS5_DEPTH_RES_WIDTH		0x4004
+#define DS5_DEPTH_RES_HEIGHT		0x4008
+#define DS5_DEPTH_FPS			0x400C
+#define DS5_DEPTH_OVERRIDE		0x401C
+
+#define DS5_RGB_STREAM_DT		0x4020
+#define DS5_RGB_STREAM_MD		0x4022
+#define DS5_RGB_RES_WIDTH		0x4024
+#define DS5_RGB_RES_HEIGHT		0x4028
+#define DS5_RGB_FPS			0x402C
+
+#define DS5_IMU_STREAM_DT		0x4040
+#define DS5_IMU_STREAM_MD		0x4042
+#define DS5_IMU_RES_WIDTH		0x4044
+#define DS5_IMU_RES_HEIGHT		0x4048
+#define DS5_IMU_FPS			0x404C
+
+#define DS5_IR_STREAM_DT		0x4080
+#define DS5_IR_STREAM_MD		0x4082
+#define DS5_IR_RES_WIDTH		0x4084
+#define DS5_IR_RES_HEIGHT		0x4088
+#define DS5_IR_FPS			0x408C
+#define DS5_IR_OVERRIDE			0x409C
+
+#define DS5_DEPTH_CONTROL_BASE		0x4100
+#define DS5_RGB_CONTROL_BASE		0x4200
+#define DS5_MANUAL_EXPOSURE_LSB		0x0000
+#define DS5_MANUAL_EXPOSURE_MSB		0x0002
+#define DS5_MANUAL_GAIN			0x0004
+#define DS5_LASER_POWER			0x0008
+#define DS5_AUTO_EXPOSURE_MODE		0x000C
+#define DS5_EXPOSURE_ROI_TOP		0x0010
+#define DS5_EXPOSURE_ROI_LEFT		0x0014
+#define DS5_EXPOSURE_ROI_BOTTOM		0x0018
+#define DS5_EXPOSURE_ROI_RIGHT		0x001C
+#define DS5_MANUAL_LASER_POWER		0x0024
+
+#define DS5_DEPTH_CONFIG_STATUS		0x4800
+#define DS5_RGB_CONFIG_STATUS		0x4802
+#define DS5_IMU_CONFIG_STATUS		0x4804
+#define DS5_IR_CONFIG_STATUS		0x4808
+
+#define DS5_STATUS_STREAMING		0x1
+#define DS5_STATUS_INVALID_DT		0x2
+#define DS5_STATUS_INVALID_RES		0x4
+#define DS5_STATUS_INVALID_FPS		0x8
+
+#define MIPI_LANE_RATE			1000
+
+#define MAX_DEPTH_EXP			2000
+#define MAX_RGB_EXP			10000
+#define DEF_DEPTH_EXP			330
+#define DEF_RGB_EXP			1660
+
+/* Currently both depth and IR use VC 0 */
+#define DS5_DEPTH_VCHAN_N		0
+#define DS5_MOTION_T_VCHAN_N		0
+//#define DS5_DEBUG_VCHAN_N		1
+//#define DS5_MOTION_T_VCHAN_N		2
+
+#define D4XX_I2C_ADDRESS_1	0x12
+
+enum ds5_mux_pad {
+	DS5_MUX_PAD_EXTERNAL,
+	DS5_MUX_PAD_DEPTH_A,
+	DS5_MUX_PAD_RGB_A,
+	DS5_MUX_PAD_MOTION_T_A,
+	DS5_MUX_PAD_DEPTH_B,
+	DS5_MUX_PAD_RGB_B,
+	DS5_MUX_PAD_MOTION_T_B,
+	DS5_MUX_PAD_IMU,
+	DS5_MUX_PAD_COUNT,
+};
+
+#define DS5_N_CONTROLS			8
+
+#define CSI2_MAX_VIRTUAL_CHANNELS	4
+
+#define DFU_WAIT_RET_LEN 6
+
+#define DS5_START_POLL_TIME	10
+#define DS5_START_MAX_TIME	1000
+#define DS5_START_MAX_COUNT	(DS5_START_MAX_TIME / DS5_START_POLL_TIME)
+
+/* DFU definition section */
+#define DFU_MAGIC_NUMBER "/0x01/0x02/0x03/0x04"
+#define DFU_BLOCK_SIZE 1024
+#define ds5_read_with_check(state, addr, val) {\
+	if (ds5_read(state, addr, val))	\
+		return -EINVAL; \
+	}
+#define ds5_raw_read_with_check(state, addr, buf, size)	{\
+	if (ds5_raw_read(state, addr, buf, size))	\
+		return -EINVAL; \
+	}
+#define ds5_write_with_check(state, addr, val) {\
+	if (ds5_write(state, addr, val))	\
+		return -EINVAL; \
+	}
+#define ds5_raw_write_with_check(state, addr, buf, size) {\
+	if (ds5_raw_write(state, addr, buf, size)) \
+		return -EINVAL; \
+	}
+#define D4XX_LINK_FREQ_360MHZ		360000000ULL
+#define D4XX_LINK_FREQ_300MHZ		300000000ULL
+#define D4XX_LINK_FREQ_288MHZ		288000000ULL
+#define D4XX_LINK_FREQ_240MHZ		240000000ULL
+#define D4XX_LINK_FREQ_225MHZ		22500000ULL
+
+enum dfu_fw_state {
+	appIDLE			= 0x0000,
+	appDETACH		= 0x0001,
+	dfuIDLE			= 0x0002,
+	dfuDNLOAD_SYNC		= 0x0003,
+	dfuDNBUSY		= 0x0004,
+	dfuDNLOAD_IDLE		= 0x0005,
+	dfuMANIFEST_SYNC	= 0x0006,
+	dfuMANIFEST		= 0x0007,
+	dfuMANIFEST_WAIT_RESET	= 0x0008,
+	dfuUPLOAD_IDLE		= 0x0009,
+	dfuERROR		= 0x000a
+};
+
+enum dfu_state {
+	DS5_DFU_IDLE = 0,
+	DS5_DFU_RECOVERY,
+	DS5_DFU_OPEN,
+	DS5_DFU_IN_PROGRESS,
+	DS5_DFU_DONE,
+	DS5_DFU_ERROR
+} dfu_state_t;
+
+struct hwm_cmd {
+	u16 header;
+	u16 magic_word;
+	u32 opcode;
+	u32 param1;
+	u32 param2;
+	u32 param3;
+	u32 param4;
+	unsigned char Data[0];
+};
+
+static const struct hwm_cmd cmd_switch_to_dfu = {
+	.header = 0x14,
+	.magic_word = 0xCDAB,
+	.opcode = 0x1e,
+	.param1 = 0x01,
+};
+
+enum table_id {
+	COEF_CALIBRATION_ID = 0x19,
+	DEPTH_CALIBRATION_ID = 0x1f,
+	RGB_CALIBRATION_ID = 0x20,
+	IMU_CALIBRATION_ID = 0x22
+} table_id_t;
+
+static const struct hwm_cmd get_calib_data = {
+	.header = 0x14,
+	.magic_word = 0xCDAB,
+	.opcode = 0x15,
+	.param1 = 0x00,	//table_id
+};
+
+static const struct hwm_cmd set_calib_data = {
+	.header = 0x0114,
+	.magic_word = 0xCDAB,
+	.opcode = 0x62,
+	.param1 = 0x00,	//table_id
+	.param2 = 0x02,	//region
+};
+
+static const struct hwm_cmd gvd = {
+	.header = 0x14,
+	.magic_word = 0xCDAB,
+	.opcode = 0x10,
+};
+
+static const struct hwm_cmd set_ae_roi = {
+	.header = 0x14,
+	.magic_word = 0xCDAB,
+	.opcode = 0x44,
+};
+
+static const struct hwm_cmd get_ae_roi = {
+	.header = 0x014,
+	.magic_word = 0xCDAB,
+	.opcode = 0x45,
+};
+
+static const struct hwm_cmd set_ae_setpoint = {
+	.header = 0x18,
+	.magic_word = 0xCDAB,
+	.opcode = 0x2B,
+	.param1 = 0xa, // AE control
+};
+
+static const struct hwm_cmd get_ae_setpoint = {
+	.header = 0x014,
+	.magic_word = 0xCDAB,
+	.opcode = 0x2C,
+	.param1 = 0xa, // AE control
+	.param2 = 0, // get current
+};
+
+static const struct hwm_cmd erb = {
+	.header = 0x14,
+	.magic_word = 0xCDAB,
+	.opcode = 0x17,
+};
+
+static const struct hwm_cmd ewb = {
+	.header = 0x14,
+	.magic_word = 0xCDAB,
+	.opcode = 0x18,
+};
+
+static const s64 link_freq_menu_items[] = {
+	D4XX_LINK_FREQ_360MHZ,
+	D4XX_LINK_FREQ_300MHZ,
+	D4XX_LINK_FREQ_288MHZ,
+	D4XX_LINK_FREQ_240MHZ,
+	D4XX_LINK_FREQ_225MHZ,
+};
+
+struct __fw_status {
+	uint32_t	spare1;
+	uint32_t	FW_lastVersion;
+	uint32_t	FW_highestVersion;
+	uint16_t	FW_DownloadStatus;
+	uint16_t	DFU_isLocked;
+	uint16_t	DFU_version;
+	uint8_t		ivcamSerialNum[8];
+	uint8_t		spare2[42];
+};
+
+/*************************/
+
+struct ds5_ctrls {
+	struct v4l2_ctrl_handler handler;
+	struct {
+		struct v4l2_ctrl *log;
+		struct v4l2_ctrl *fw_version;
+		struct v4l2_ctrl *gvd;
+		struct v4l2_ctrl *get_depth_calib;
+		struct v4l2_ctrl *set_depth_calib;
+		struct v4l2_ctrl *get_coeff_calib;
+		struct v4l2_ctrl *set_coeff_calib;
+		struct v4l2_ctrl *ae_roi_get;
+		struct v4l2_ctrl *ae_roi_set;
+		struct v4l2_ctrl *ae_setpoint_get;
+		struct v4l2_ctrl *ae_setpoint_set;
+		struct v4l2_ctrl *erb;
+		struct v4l2_ctrl *ewb;
+		struct v4l2_ctrl *hwmc;
+		struct v4l2_ctrl *laser_power;
+		struct v4l2_ctrl *manual_laser_power;
+		struct v4l2_ctrl *auto_exp;
+		struct v4l2_ctrl *exposure;
+		/* in DS5 manual gain only works with manual exposure */
+		struct v4l2_ctrl *gain;
+		struct v4l2_ctrl *link_freq;
+		struct v4l2_ctrl *query_sub_stream;
+		struct v4l2_ctrl *set_sub_stream;
+	};
+};
+
+struct ds5_resolution {
+	u16 width;
+	u16 height;
+	u8 n_framerates;
+	const u16 *framerates;
+};
+
+struct ds5_format {
+	unsigned int n_resolutions;
+	const struct ds5_resolution *resolutions;
+	u32 mbus_code;
+	u8 data_type;
+};
+
+struct ds5_sensor {
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_mbus_framefmt format;
+	u16 mux_pad;
+	struct {
+		const struct ds5_format *format;
+		const struct ds5_resolution *resolution;
+		u16 framerate;
+	} config;
+	bool streaming;
+	/*struct ds5_vchan *vchan;*/
+	const struct ds5_format *formats;
+	unsigned int n_formats;
+};
+
+struct ds5_des {
+	struct v4l2_subdev sd;
+	struct media_pad pads[2];
+	struct v4l2_mbus_framefmt format;
+	u16 mux_pad;
+};
+
+#ifdef CONFIG_TEGRA_CAMERA_PLATFORM
+#include <media/camera_common.h>
+#define ds5_mux_subdev camera_common_data
+#else
+struct ds5_mux_subdev {
+	struct v4l2_subdev subdev;
+};
+#endif
+
+struct ds5_variant {
+	const struct ds5_format *formats;
+	unsigned int n_formats;
+};
+
+struct ds5_dfu_dev {
+	struct cdev ds5_cdev;
+	struct class *ds5_class;
+	int device_open_count;
+	enum dfu_state dfu_state_flag;
+	unsigned char *dfu_msg;
+	u16 msg_write_once;
+	unsigned char init_v4l_f;
+};
+
+enum {
+	DS5_DS5U,
+	DS5_ASR,
+	DS5_AWG,
+};
+
+#define NR_OF_DS5_PADS 7
+#define NR_OF_DS5_STREAMS (NR_OF_DS5_PADS - 1)
+
+struct v4l2_mbus_framefmt ds5_ffmts[NR_OF_DS5_PADS];
+
+struct ds5 {
+	struct {
+		struct ds5_sensor sensor;
+	} depth;
+	struct {
+		struct ds5_sensor sensor;
+	} motion_t;
+	struct {
+		struct ds5_sensor sensor;
+	} rgb;
+	struct {
+		struct ds5_sensor sensor;
+	} imu;
+	struct {
+		struct ds5_des des;
+	} max9296;
+	struct {
+		struct ds5_mux_subdev sd;
+		struct media_pad pads[DS5_MUX_PAD_COUNT];
+		struct ds5_sensor *last_set;
+	} mux;
+	struct ds5_ctrls ctrls;
+	struct ds5_dfu_dev dfu_dev;
+	bool power;
+	struct i2c_client *client;
+	/*struct ds5_vchan virtual_channels[CSI2_MAX_VIRTUAL_CHANNELS];*/
+	/* All below pointers are used for writing, cannot be const */
+	struct mutex lock;
+	struct regmap *regmap;
+	struct regulator *vcc;
+	const struct ds5_variant *variant;
+	int is_depth;
+	int is_y8;
+	int is_rgb;
+	int is_imu;
+	u16 fw_version;
+	u16 fw_build;
+};
+
+struct ds5_counters {
+	unsigned int n_res;
+	unsigned int n_fmt;
+	unsigned int n_ctrl;
+};
+
+#define ds5_from_depth_sd(sd) container_of(sd, struct ds5, depth.sd)
+#define ds5_from_motion_t_sd(sd) container_of(sd, struct ds5, motion_t.sd)
+#define ds5_from_rgb_sd(sd) container_of(sd, struct ds5, rgb.sd)
+
+static inline void msleep_range(unsigned int delay_base)
+{
+	usleep_range(delay_base * 1000, delay_base * 1000 + 500);
+}
+
+static int ds5_write_8(struct ds5 *state, u16 reg, u8 val)
+{
+	int ret;
+
+	ret = regmap_raw_write(state->regmap, reg, &val, 1);
+	if (ret < 0)
+		dev_err(&state->client->dev, "%s(): i2c write failed %d, 0x%04x = 0x%x\n",
+			__func__, ret, reg, val);
+	else
+		if (state->dfu_dev.dfu_state_flag == DS5_DFU_IDLE)
+			dev_info(&state->client->dev, "%s(): i2c write 0x%04x: 0x%x\n",
+				 __func__, reg, val);
+
+	return ret;
+}
+
+static int ds5_write(struct ds5 *state, u16 reg, u16 val)
+{
+	int ret;
+	u8 value[2];
+
+	value[1] = val >> 8;
+	value[0] = val & 0x00FF;
+
+	dev_info(&state->client->dev, "%s(): writing to register: 0x%04x, value1: 0x%x, value2:0x%x\n",
+				 __func__, reg, value[1], value[0]);
+
+	ret = regmap_raw_write(state->regmap, reg, value, sizeof(value));
+	if (ret < 0)
+		dev_err(&state->client->dev, "%s(): i2c write failed %d, 0x%04x = 0x%x\n",
+			__func__, ret, reg, val);
+	else
+		if (state->dfu_dev.dfu_state_flag == DS5_DFU_IDLE)
+			dev_info(&state->client->dev, "%s(): i2c write 0x%04x: 0x%x\n",
+				 __func__, reg, val);
+
+	return ret;
+}
+
+static int ds5_raw_write(struct ds5 *state, u16 reg, const void *val, size_t val_len)
+{
+	int ret;
+
+	ret = regmap_raw_write(state->regmap, reg, val, val_len);
+	if (ret < 0)
+		dev_err(&state->client->dev, "%s(): i2c raw write failed %d, %04x size(%d) bytes\n",
+			__func__, ret, reg, (int)val_len);
+	else
+		if (state->dfu_dev.dfu_state_flag == DS5_DFU_IDLE)
+			dev_info(&state->client->dev, "%s(): i2c raw write 0x%04x: %d bytes\n",
+				 __func__, reg, (int)val_len);
+
+	return ret;
+}
+
+static int ds5_read(struct ds5 *state, u16 reg, u16 *val)
+{
+	int ret;
+
+	ret = regmap_raw_read(state->regmap, reg, val, 2);
+	if (ret < 0)
+		dev_err(&state->client->dev, "%s(): i2c read failed %d, 0x%04x\n",
+				__func__, ret, reg);
+	else {
+		if (state->dfu_dev.dfu_state_flag == DS5_DFU_IDLE)
+			dev_info(&state->client->dev, "%s(): i2c read 0x%04x: 0x%x\n",
+					__func__, reg, *val);
+	}
+
+	return ret;
+}
+
+static int ds5_raw_read(struct ds5 *state, u16 reg, void *val, size_t val_len)
+{
+	int ret;
+
+	ret = regmap_raw_read(state->regmap, reg, val, val_len);
+	if (ret < 0)
+		dev_err(&state->client->dev, "%s(): i2c read failed %d, 0x%04x\n",
+			__func__, ret, reg);
+
+	return ret;
+}
+
+static int pad_to_substream[DS5_MUX_PAD_COUNT];
+
+static s64 d4xx_query_sub_stream[] = {
+	0, 0, 0, 0, 0
+};
+
+static void set_sub_stream_fmt(int index, u32 code)
+{
+       d4xx_query_sub_stream[index] &= 0xFFFFFFFFFFFF0000;
+       d4xx_query_sub_stream[index] |= code;
+}
+
+static void set_sub_stream_h(int index, u32 height)
+{
+       s64 val = height;
+       val &= 0xFFFF;
+       d4xx_query_sub_stream[index] &= 0xFFFFFFFF0000FFFF;
+       d4xx_query_sub_stream[index] |= val << 16;
+}
+
+static void set_sub_stream_w(int index, u32 width)
+{
+       s64 val = width;
+       val &= 0xFFFF;
+       d4xx_query_sub_stream[index] &= 0xFFFF0000FFFFFFFF;
+       d4xx_query_sub_stream[index] |= val << 32;
+}
+
+static void set_sub_stream_dt(int index, u32 dt)
+{
+       s64 val = dt;
+       val &= 0xFF;
+       d4xx_query_sub_stream[index] &= 0xFF00FFFFFFFFFFFF;
+       d4xx_query_sub_stream[index] |= val << 48;
+}
+
+static void set_sub_stream_vc_id(int index, u32 vc_id)
+{
+       s64 val = vc_id;
+       val &= 0xFF;
+       d4xx_query_sub_stream[index] &= 0x00FFFFFFFFFFFFFF;
+       d4xx_query_sub_stream[index] |= val << 56;
+}
+
+static u8 d4xx_set_sub_stream[] = {
+       0, 0, 0, 0, 0, 0
+};
+
+static int ds5_mux_s_stream_vc(struct ds5 *state, u16 vc_id, u16 on);
+
+/* Pad ops */
+
+static const u16 ds5_default_framerate = 30;
+
+// **********************
+// FIXME: D16 width must be doubled, because an 8-bit format is used. Check how
+// the Tegra driver propagates resolutions and formats.
+// **********************
+
+//TODO: keep 6, till 5 is supported by FW
+static const u16 ds5_framerates[] = {5, 30};
+
+#define DS5_FRAMERATE_DEFAULT_IDX 1
+
+static const u16 ds5_framerate_30 = 30;
+
+static const u16 ds5_framerate_15_30[] = {15, 30};
+
+static const u16 ds5_framerate_25 = 25;
+
+static const u16 ds5_depth_framerate_to_30[] = {5, 15, 30};
+static const u16 ds5_framerate_to_30[] = {5, 10, 15, 30};
+static const u16 ds5_framerate_to_60[] = {5, 15, 30, 60};
+static const u16 ds5_framerate_to_90[] = {5, 15, 30, 60, 90};
+static const u16 ds5_framerate_100[] = {100};
+static const u16 ds5_framerate_90[] = {90};
+static const u16 ds5_imu_framerates[] = {50, 100, 200, 400};
+
+static const struct ds5_resolution d43x_depth_sizes[] = {
+	{
+		.width = 1280,
+		.height = 720,
+		.framerates = ds5_depth_framerate_to_30,
+		.n_framerates = ARRAY_SIZE(ds5_depth_framerate_to_30),
+	}, {
+		.width =  848,
+		.height = 480,
+		.framerates = ds5_framerate_to_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_90),
+	}, {
+		.width =  848,
+		.height = 100,
+		.framerates = ds5_framerate_100,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_100),
+	}, {
+		.width =  640,
+		.height = 480,
+		.framerates = ds5_framerate_to_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_90),
+	}, {
+		.width =  640,
+		.height = 360,
+		.framerates = ds5_framerate_to_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_90),
+	}, {
+		.width =  480,
+		.height = 270,
+		.framerates = ds5_framerate_to_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_90),
+	}, {
+		.width =  424,
+		.height = 240,
+		.framerates = ds5_framerate_to_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_90),
+	}, {
+		.width =  256,
+		.height = 144,
+		.framerates = ds5_framerate_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_90),
+	},
+};
+
+static const struct ds5_resolution d46x_depth_sizes[] = {
+	{
+		.width = 1280,
+		.height = 960,
+		.framerates = ds5_framerates,
+		.n_framerates = ARRAY_SIZE(ds5_framerates),
+	}, {
+		.width =  640,
+		.height = 480,
+		.framerates = ds5_framerates,
+		.n_framerates = ARRAY_SIZE(ds5_framerates),
+	},
+};
+
+static const struct ds5_resolution y8_sizes[] = {
+	{
+		.width = 1280,
+		.height = 720,
+		.framerates = ds5_depth_framerate_to_30,
+		.n_framerates = ARRAY_SIZE(ds5_depth_framerate_to_30),
+	}, {
+		.width =  848,
+		.height = 480,
+		.framerates = ds5_framerate_to_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_90),
+	}, {
+		.width =  640,
+		.height = 480,
+		.framerates = ds5_framerate_to_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_90),
+	}, {
+		.width =  640,
+		.height = 360,
+		.framerates = ds5_framerate_to_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_90),
+	}, {
+		.width =  480,
+		.height = 270,
+		.framerates = ds5_framerate_to_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_90),
+	}, {
+		.width =  424,
+		.height = 240,
+		.framerates = ds5_framerate_to_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_90),
+	}
+};
+
+static const struct ds5_resolution ds5_rlt_rgb_sizes[] = {
+	{
+		.width = 1280,
+		.height = 800,
+		.framerates = ds5_framerate_to_30,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_30),
+	}, {
+		.width = 1280,
+		.height = 720,
+		.framerates = ds5_framerate_to_30,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_30),
+	}, {
+		.width = 848,
+		.height = 480,
+		.framerates = ds5_framerate_to_60,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_60),
+	}, {
+		.width = 640,
+		.height = 480,
+		.framerates = ds5_framerate_to_60,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_60),
+	}, {
+		.width = 640,
+		.height = 360,
+		.framerates = ds5_framerate_to_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_90),
+	}, {
+		.width = 480,
+		.height = 270,
+		.framerates = ds5_framerate_to_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_90),
+	}, {
+		.width = 424,
+		.height = 240,
+		.framerates = ds5_framerate_to_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_90),
+	},
+};
+
+static const struct ds5_resolution ds5_onsemi_rgb_sizes[] = {
+	{
+		.width = 640,
+		.height = 480,
+		.framerates = ds5_framerate_to_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_90),
+	}, {
+		.width = 960,
+		.height = 720,
+		.framerates = ds5_framerate_to_60,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_60),
+	}, {
+		.width = 1280,
+		.height = 720,
+		.framerates = ds5_framerates,
+		.n_framerates = ARRAY_SIZE(ds5_framerates),
+	}, {
+		.width = 1920,
+		.height = 1080,
+		.framerates = ds5_framerates,
+		.n_framerates = ARRAY_SIZE(ds5_framerates),
+	}, {
+		.width = 2048,
+		.height = 1536,
+		.framerates = ds5_framerates,
+		.n_framerates = ARRAY_SIZE(ds5_framerates),
+	},
+};
+
+static const struct ds5_resolution ds5_size_w10 = {
+	.width =  1920,
+	.height = 1080,
+	.framerates = &ds5_framerate_30,
+	.n_framerates = 1,
+};
+
+static const struct ds5_resolution d43x_calibration_sizes[] = {
+	{
+		.width =  1280,
+		.height = 800,
+		.framerates = ds5_framerate_15_30,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_15_30),
+	},
+};
+
+static const struct ds5_resolution d46x_calibration_sizes[] = {
+	{
+		.width =  1600,
+		.height = 1300,
+		.framerates = ds5_framerate_15_30,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_15_30),
+	},
+};
+
+static const struct ds5_resolution ds5_size_imu[] = {
+	{
+	.width =  32,
+	.height = 1,
+	.framerates = ds5_imu_framerates,
+	.n_framerates = ARRAY_SIZE(ds5_imu_framerates),
+	},
+};
+
+static const struct ds5_format ds5_depth_formats_d43x[] = {
+	{
+		// TODO: 0x31 is replaced with 0x1e since it caused low FPS in Jetson.
+		.data_type = 0x1e,	/* UYVY */
+		.mbus_code = MEDIA_BUS_FMT_UYVY8_1X16,
+		.n_resolutions = ARRAY_SIZE(d43x_depth_sizes),
+		.resolutions = d43x_depth_sizes,
+	}, {
+		.data_type = 0x2a,	/* Y8 */
+		.mbus_code = MEDIA_BUS_FMT_Y8_1X8,
+		.n_resolutions = ARRAY_SIZE(d43x_depth_sizes),
+		.resolutions = d43x_depth_sizes,
+	}, {
+		.data_type = 0x24,	/* 24-bit Calibration */
+		.mbus_code = MEDIA_BUS_FMT_RGB888_1X24,	/* FIXME */
+		.n_resolutions = ARRAY_SIZE(d43x_calibration_sizes),
+		.resolutions = d43x_calibration_sizes,
+	},
+};
+
+static const struct ds5_format ds5_depth_formats_d46x[] = {
+	{
+		// TODO: 0x31 is replaced with 0x1e since it caused low FPS in Jetson.
+		.data_type = 0x1e,	/* Z16 */
+		.mbus_code = MEDIA_BUS_FMT_UYVY8_1X16,
+		.n_resolutions = ARRAY_SIZE(d46x_depth_sizes),
+		.resolutions = d46x_depth_sizes,
+	}, {
+		/* First format: default */
+		.data_type = 0x2a,	/* Y8 */
+		.mbus_code = MEDIA_BUS_FMT_Y8_1X8,
+		.n_resolutions = ARRAY_SIZE(d46x_depth_sizes),
+		.resolutions = d46x_depth_sizes,
+	}, {
+		.data_type = 0x24,	/* 24-bit Calibration */
+		.mbus_code = MEDIA_BUS_FMT_RGB888_1X24,	/* FIXME */
+		.n_resolutions = ARRAY_SIZE(d46x_calibration_sizes),
+		.resolutions = d46x_calibration_sizes,
+	},
+};
+
+#define DS5_DEPTH_N_FORMATS 1
+
+static const struct ds5_format ds5_y_formats_ds5u[] = {
+	{
+		/* First format: default */
+		.data_type = 0x1e,	/* Y8 */
+		//.mbus_code = MEDIA_BUS_FMT_SGRBG8_1X8,
+		.mbus_code = MEDIA_BUS_FMT_UYVY8_1X16,
+		.n_resolutions = ARRAY_SIZE(y8_sizes),
+		.resolutions = y8_sizes,
+	}, {
+		.data_type = 0x1e,	/* Y8I */
+		.mbus_code = MEDIA_BUS_FMT_VYUY8_1X16,
+		.n_resolutions = ARRAY_SIZE(y8_sizes),
+		.resolutions = y8_sizes,
+	}, {
+		.data_type = 0x24,	/* 24-bit Calibration */
+		.mbus_code = MEDIA_BUS_FMT_RGB888_1X24,	/* FIXME */
+		.n_resolutions = ARRAY_SIZE(d46x_calibration_sizes),
+		.resolutions = d46x_calibration_sizes,
+	},
+};
+
+static const struct ds5_format ds5_rlt_rgb_format = {
+	.data_type = 0x1e,	/* UYVY */
+	.mbus_code = MEDIA_BUS_FMT_YUYV8_1X16,
+	.n_resolutions = ARRAY_SIZE(ds5_rlt_rgb_sizes),
+	.resolutions = ds5_rlt_rgb_sizes,
+};
+#define DS5_RLT_RGB_N_FORMATS 1
+
+static const struct ds5_format ds5_onsemi_rgb_format = {
+	.data_type = 0x1e,	/* UYVY */
+	.mbus_code = MEDIA_BUS_FMT_YUYV8_1X16,
+	.n_resolutions = ARRAY_SIZE(ds5_onsemi_rgb_sizes),
+	.resolutions = ds5_onsemi_rgb_sizes,
+};
+#define DS5_ONSEMI_RGB_N_FORMATS 1
+
+static const struct ds5_variant ds5_variants[] = {
+	[DS5_DS5U] = {
+		.formats = ds5_y_formats_ds5u,
+		.n_formats = ARRAY_SIZE(ds5_y_formats_ds5u),
+	},
+};
+
+static const struct ds5_format ds5_imu_formats[] = {
+	{
+		/* First format: default */
+		.data_type = 0x2a,	/* IMU DT */
+		.mbus_code = MEDIA_BUS_FMT_Y8_1X8,
+		.n_resolutions = ARRAY_SIZE(ds5_size_imu),
+		.resolutions = ds5_size_imu,
+	},
+};
+
+static const struct v4l2_mbus_framefmt ds5_mbus_framefmt_template = {
+	.width = 0,
+	.height = 0,
+	.code = MEDIA_BUS_FMT_FIXED,
+	.field = V4L2_FIELD_NONE,
+	.colorspace = V4L2_COLORSPACE_DEFAULT,
+	.ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT,
+	.quantization = V4L2_QUANTIZATION_DEFAULT,
+	.xfer_func = V4L2_XFER_FUNC_DEFAULT,
+};
+
+/* This is needed for .get_fmt() and if streaming is started without .set_fmt() */
+static void ds5_sensor_format_init(struct ds5_sensor *sensor)
+{
+	const struct ds5_format *fmt;
+	struct v4l2_mbus_framefmt *ffmt;
+	unsigned int i;
+
+	if (sensor->config.format)
+		return;
+
+	dev_info(sensor->sd.dev, "%s(): on pad %u\n", __func__, sensor->mux_pad);
+
+	ffmt = &sensor->format;
+	*ffmt = ds5_mbus_framefmt_template;
+	/* Use the first format */
+	fmt = sensor->formats;
+	ffmt->code = fmt->mbus_code;
+	/* and the first resolution */
+	ffmt->width = fmt->resolutions->width;
+	ffmt->height = fmt->resolutions->height;
+
+	sensor->config.format = fmt;
+	sensor->config.resolution = fmt->resolutions;
+	/* Set default framerate to 30, or to 1st one if not supported */
+	for (i = 0; i < fmt->resolutions->n_framerates; i++) {
+		if (fmt->resolutions->framerates[i] == ds5_framerate_30 /* fps */) {
+			sensor->config.framerate = ds5_framerate_30;
+			return;
+		}
+	}
+	sensor->config.framerate = fmt->resolutions->framerates[0];
+}
+
+/* No locking needed for enumeration methods */
+static int ds5_sensor_enum_mbus_code(struct v4l2_subdev *sd,
+				     struct v4l2_subdev_state *v4l2_state,
+				     struct v4l2_subdev_mbus_code_enum *mce)
+{
+	struct ds5_sensor *sensor = container_of(sd, struct ds5_sensor, sd);
+	//struct ds5_vchan *vchan = sensor->vchan;
+dev_info(sensor->sd.dev, "%s(): sensor %s \n", __func__, sensor->sd.name);
+	if (mce->pad)
+		return -EINVAL;
+
+	if (mce->index >= sensor->n_formats)
+		return -EINVAL;
+
+	mce->code = sensor->formats[mce->index].mbus_code;
+
+	return 0;
+}
+
+static int ds5_sensor_enum_frame_size(struct v4l2_subdev *sd,
+				     struct v4l2_subdev_state *v4l2_state,
+				      struct v4l2_subdev_frame_size_enum *fse)
+{
+	struct ds5_sensor *sensor = container_of(sd, struct ds5_sensor, sd);
+	struct ds5 *state = v4l2_get_subdevdata(sd);
+	const struct ds5_format *fmt;
+	unsigned int i;
+
+	dev_info(sensor->sd.dev, "%s(): sensor %s \n", __func__, sensor->sd.name);
+	dev_info(sensor->sd.dev, "%s(): state->is_rgb %d\n", __func__, state->is_rgb);
+	dev_info(sensor->sd.dev, "%s(): state->is_depth %d\n", __func__, state->is_depth);
+	dev_info(sensor->sd.dev, "%s(): state->is_y8 %d\n", __func__, state->is_y8);
+	dev_info(sensor->sd.dev, "%s(): state->is_imu %d\n", __func__, state->is_imu);
+
+	for (i = 0, fmt = sensor->formats; i < sensor->n_formats; i++, fmt++)
+		if (fse->code == fmt->mbus_code)
+			break;
+
+	if (i == sensor->n_formats)
+		return -EINVAL;
+
+	if (fse->index >= fmt->n_resolutions)
+		return -EINVAL;
+
+	fse->min_width = fse->max_width = fmt->resolutions[fse->index].width;
+	fse->min_height = fse->max_height = fmt->resolutions[fse->index].height;
+
+	return 0;
+}
+
+static int ds5_sensor_enum_frame_interval(struct v4l2_subdev *sd,
+				     struct v4l2_subdev_state *v4l2_state,
+					  struct v4l2_subdev_frame_interval_enum *fie)
+{
+	struct ds5_sensor *sensor = container_of(sd, struct ds5_sensor, sd);
+	const struct ds5_format *fmt;
+	const struct ds5_resolution *res;
+	unsigned int i;
+
+	//if (fie->pad)
+	//	return -EINVAL;
+
+	for (i = 0, fmt = sensor->formats; i < sensor->n_formats; i++, fmt++)
+		if (fie->code == fmt->mbus_code)
+			break;
+
+	if (i == sensor->n_formats)
+		return -EINVAL;
+
+	for (i = 0, res = fmt->resolutions; i < fmt->n_resolutions; i++, res++)
+		if (res->width == fie->width && res->height == fie->height)
+			break;
+
+	if (i == fmt->n_resolutions)
+		return -EINVAL;
+
+	if (fie->index >= res->n_framerates)
+		return -EINVAL;
+
+	fie->interval.numerator = 1;
+	fie->interval.denominator = res->framerates[fie->index];
+
+	return 0;
+}
+
+static int ds5_sensor_get_fmt(struct v4l2_subdev *sd,
+				     struct v4l2_subdev_state *v4l2_state,
+			      struct v4l2_subdev_format *fmt)
+{
+	struct ds5_sensor *sensor = container_of(sd, struct ds5_sensor, sd);
+	struct ds5 *state = v4l2_get_subdevdata(sd);
+
+	//fmt->pad = sensor->mux_pad;
+
+	if (fmt->pad)
+		return -EINVAL;
+
+	mutex_lock(&state->lock);
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY)
+		fmt->format = *v4l2_subdev_get_try_format(sd, v4l2_state, fmt->pad);
+	else
+		fmt->format = sensor->format;
+
+	mutex_unlock(&state->lock);
+
+	dev_info(sd->dev, "%s(): pad %x, code %x, res %ux%u\n", __func__, fmt->pad, fmt->format.code,
+		 fmt->format.width, fmt->format.height);
+
+	return 0;
+}
+
+/* Called with lock held */
+static const struct ds5_format *ds5_sensor_find_format(struct ds5_sensor *sensor,
+						struct v4l2_mbus_framefmt *ffmt,
+						const struct ds5_resolution **best)
+{
+	const struct ds5_resolution *res;
+	const struct ds5_format *fmt;
+	unsigned long best_delta = ~0;
+	unsigned int i;
+
+	for (i = 0, fmt = sensor->formats; i < sensor->n_formats; i++, fmt++) {
+		if (fmt->mbus_code == ffmt->code)
+			break;
+	}
+	dev_info(sensor->sd.dev, "%s(): mbus_code = %x, code = %x \n", __func__,
+				fmt->mbus_code, ffmt->code);
+
+	if (i == sensor->n_formats)
+		/* Not found, use default */
+		fmt = sensor->formats;
+
+	for (i = 0, res = fmt->resolutions; i < fmt->n_resolutions; i++, res++) {
+		unsigned long delta = abs(ffmt->width * ffmt->height -
+					  res->width * res->height);
+		if (delta < best_delta) {
+			best_delta = delta;
+			*best = res;
+		}
+	}
+
+	ffmt->code = fmt->mbus_code;
+	ffmt->width = (*best)->width;
+	ffmt->height = (*best)->height;
+
+	ffmt->field = V4L2_FIELD_NONE;
+	/* Should we use V4L2_COLORSPACE_RAW for Y12I? */
+	ffmt->colorspace = V4L2_COLORSPACE_SRGB;
+
+	return fmt;
+}
+
+#define MIPI_CSI2_TYPE_NULL	0x10
+#define MIPI_CSI2_TYPE_BLANKING		0x11
+#define MIPI_CSI2_TYPE_EMBEDDED8	0x12
+#define MIPI_CSI2_TYPE_YUV422_8		0x1e
+#define MIPI_CSI2_TYPE_YUV422_10	0x1f
+#define MIPI_CSI2_TYPE_RGB565	0x22
+#define MIPI_CSI2_TYPE_RGB888	0x24
+#define MIPI_CSI2_TYPE_RAW6	0x28
+#define MIPI_CSI2_TYPE_RAW7	0x29
+#define MIPI_CSI2_TYPE_RAW8	0x2a
+#define MIPI_CSI2_TYPE_RAW10	0x2b
+#define MIPI_CSI2_TYPE_RAW12	0x2c
+#define MIPI_CSI2_TYPE_RAW14	0x2d
+/* 1-8 */
+#define MIPI_CSI2_TYPE_USER_DEF(i)	(0x30 + (i) - 1)
+
+static unsigned int mbus_code_to_mipi(u32 code)
+{
+	switch (code) {
+	case MEDIA_BUS_FMT_RGB565_1X16:
+		return MIPI_CSI2_TYPE_RGB565;
+	case MEDIA_BUS_FMT_RGB888_1X24:
+		return MIPI_CSI2_TYPE_RGB888;
+	case MEDIA_BUS_FMT_YUYV10_1X20:
+		return MIPI_CSI2_TYPE_YUV422_10;
+	case MEDIA_BUS_FMT_UYVY8_1X16:
+	case MEDIA_BUS_FMT_YUYV8_1X16:
+		return MIPI_CSI2_TYPE_YUV422_8;
+	case MEDIA_BUS_FMT_SBGGR12_1X12:
+	case MEDIA_BUS_FMT_SGBRG12_1X12:
+	case MEDIA_BUS_FMT_SGRBG12_1X12:
+	case MEDIA_BUS_FMT_SRGGB12_1X12:
+		return MIPI_CSI2_TYPE_RAW12;
+	case MEDIA_BUS_FMT_Y10_1X10:
+	case MEDIA_BUS_FMT_SBGGR10_1X10:
+	case MEDIA_BUS_FMT_SGBRG10_1X10:
+	case MEDIA_BUS_FMT_SGRBG10_1X10:
+	case MEDIA_BUS_FMT_SRGGB10_1X10:
+		return MIPI_CSI2_TYPE_RAW10;
+	case MEDIA_BUS_FMT_SBGGR8_1X8:
+	case MEDIA_BUS_FMT_SGBRG8_1X8:
+	case MEDIA_BUS_FMT_SGRBG8_1X8:
+	case MEDIA_BUS_FMT_SRGGB8_1X8:
+		return MIPI_CSI2_TYPE_RAW8;
+	case MEDIA_BUS_FMT_SBGGR10_DPCM8_1X8:
+	case MEDIA_BUS_FMT_SGBRG10_DPCM8_1X8:
+	case MEDIA_BUS_FMT_SGRBG10_DPCM8_1X8:
+	case MEDIA_BUS_FMT_SRGGB10_DPCM8_1X8:
+		return MIPI_CSI2_TYPE_USER_DEF(1);
+	default:
+		WARN_ON(1);
+		return -EINVAL;
+	}
+}
+
+static int __ds5_sensor_set_fmt(struct ds5 *state, struct ds5_sensor *sensor,
+				     struct v4l2_subdev_state *v4l2_state,
+				struct v4l2_subdev_format *fmt)
+{
+	struct v4l2_mbus_framefmt *mf;// = &fmt->format;
+	//unsigned r;
+
+	dev_info(sensor->sd.dev, "%s(): state %p\n", __func__, state);
+	dev_info(sensor->sd.dev, "%s(): sensor %p\n", __func__, sensor);
+	dev_info(sensor->sd.dev, "%s(): fmt %p\n", __func__, fmt);
+	dev_info(sensor->sd.dev, "%s(): fmt->format %p\n", __func__, &fmt->format);
+
+	mf = &fmt->format;
+
+	if (fmt->pad)
+		return -EINVAL;
+
+	mutex_lock(&state->lock);
+
+	sensor->config.format = ds5_sensor_find_format(sensor, mf,
+						&sensor->config.resolution);
+	//r = DS5_FRAMERATE_DEFAULT_IDX < sensor->config.resolution->n_framerates ?
+	//	DS5_FRAMERATE_DEFAULT_IDX : 0;
+	/* FIXME: check if a framerate has been set */
+	//sensor->config.framerate = sensor->config.resolution->framerates[r];
+
+	if (v4l2_state && fmt->which == V4L2_SUBDEV_FORMAT_TRY)
+		*v4l2_subdev_get_try_format(&sensor->sd, v4l2_state, fmt->pad) = *mf;
+
+	else
+// FIXME: use this format in .s_stream()
+		sensor->format = *mf;
+
+	state->mux.last_set = sensor;
+
+	mutex_unlock(&state->lock);
+
+	dev_info(sensor->sd.dev, "%s(): pad: %x, code: %x, %ux%u\n", __func__, fmt->pad, fmt->format.code,
+		 fmt->format.width, fmt->format.height);
+
+	return 0;
+}
+
+static int ds5_sensor_set_fmt(struct v4l2_subdev *sd,
+				     struct v4l2_subdev_state *v4l2_state,
+			      struct v4l2_subdev_format *fmt)
+{
+	struct ds5_sensor *sensor = container_of(sd, struct ds5_sensor, sd);
+	struct ds5 *state = v4l2_get_subdevdata(sd);
+
+	return __ds5_sensor_set_fmt(state, sensor, v4l2_state, fmt);
+}
+
+static int ds5_configure(struct ds5 *state)
+{
+	struct ds5_sensor *sensor;
+	u16 fmt, md_fmt, vc_id;
+	u16 dt_addr, md_addr, override_addr, fps_addr, width_addr, height_addr;
+	int ret;
+
+	// if (state->is_depth) {
+		sensor = &state->depth.sensor;
+		dt_addr = DS5_DEPTH_STREAM_DT;
+		md_addr = DS5_DEPTH_STREAM_MD;
+		override_addr = DS5_DEPTH_OVERRIDE;
+		fps_addr = DS5_DEPTH_FPS;
+		width_addr = DS5_DEPTH_RES_WIDTH;
+		height_addr = DS5_DEPTH_RES_HEIGHT;
+		// TODO: read VC from device tree
+		vc_id = 0;
+		md_fmt = 0x12;
+
+	fmt = sensor->streaming ? sensor->config.format->data_type : 0;
+
+	/*
+	 * Set depth stream Z16 data type as 0x31
+	 * Set IR stream Y8I data type as 0x32
+	 */
+	if (fmt != 0)
+		ret = ds5_write(state, dt_addr, 0x31);
+	if (ret < 0)
+		return ret;
+
+	ret = ds5_write(state, md_addr, (vc_id << 8) | md_fmt);
+	if (ret < 0)
+		return ret;
+
+	if (override_addr != 0) {
+		ret = ds5_write(state, override_addr, fmt);
+		if (ret < 0)
+			return ret;
+	}
+
+	ret = ds5_write(state, fps_addr, sensor->config.framerate);
+	if (ret < 0)
+		return ret;
+
+	ret = ds5_write(state, width_addr, sensor->config.resolution->width);
+	if (ret < 0)
+		return ret;
+
+	ret = ds5_write(state, height_addr, sensor->config.resolution->height);
+	if (ret < 0)
+		return ret;
+
+	// } else if (state->is_rgb) {
+		sensor = &state->rgb.sensor;
+		dt_addr = DS5_RGB_STREAM_DT;
+		md_addr = DS5_RGB_STREAM_MD;
+		override_addr = 0;
+		fps_addr = DS5_RGB_FPS;
+		width_addr = DS5_RGB_RES_WIDTH;
+		height_addr = DS5_RGB_RES_HEIGHT;
+		vc_id = 1;
+		md_fmt = 0x12;
+
+	fmt = sensor->streaming ? sensor->config.format->data_type : 0;
+
+	/*
+	 * Set depth stream Z16 data type as 0x31
+	 * Set IR stream Y8I data type as 0x32
+	 */
+	ret = ds5_write(state, dt_addr, fmt);
+	if (ret < 0)
+		return ret;
+
+	ret = ds5_write(state, md_addr, (vc_id << 8) | md_fmt);
+	if (ret < 0)
+		return ret;
+
+	if (override_addr != 0) {
+		ret = ds5_write(state, override_addr, fmt);
+		if (ret < 0)
+			return ret;
+	}
+
+	ret = ds5_write(state, fps_addr, sensor->config.framerate);
+	if (ret < 0)
+		return ret;
+
+	ret = ds5_write(state, width_addr, sensor->config.resolution->width);
+	if (ret < 0)
+		return ret;
+
+	ret = ds5_write(state, height_addr, sensor->config.resolution->height);
+	if (ret < 0)
+		return ret;
+
+	// } else if (state->is_y8) {
+		sensor = &state->motion_t.sensor;
+		dt_addr = DS5_IR_STREAM_DT;
+		md_addr = DS5_IR_STREAM_MD;
+		override_addr = DS5_IR_OVERRIDE;
+		fps_addr = DS5_IR_FPS;
+		width_addr = DS5_IR_RES_WIDTH;
+		height_addr = DS5_IR_RES_HEIGHT;
+		vc_id = 2;
+		md_fmt = 0x12;
+
+	fmt = sensor->streaming ? sensor->config.format->data_type : 0;
+
+	/*
+	 * Set depth stream Z16 data type as 0x31
+	 * Set IR stream Y8I data type as 0x32
+	 */
+	if (fmt != 0 &&
+		 sensor->config.format->data_type == 0x1e)
+		ret = ds5_write(state, dt_addr, 0x32);
+	if (ret < 0)
+		return ret;
+
+	ret = ds5_write(state, md_addr, (vc_id << 8) | md_fmt);
+	if (ret < 0)
+		return ret;
+
+	if (override_addr != 0) {
+		ret = ds5_write(state, override_addr, fmt);
+		if (ret < 0)
+			return ret;
+	}
+
+	ret = ds5_write(state, fps_addr, sensor->config.framerate);
+	if (ret < 0)
+		return ret;
+
+	ret = ds5_write(state, width_addr, sensor->config.resolution->width);
+	if (ret < 0)
+		return ret;
+
+	ret = ds5_write(state, height_addr, sensor->config.resolution->height);
+	if (ret < 0)
+		return ret;
+
+	// } else if (state->is_imu) {
+		sensor = &state->imu.sensor;
+		dt_addr = DS5_IMU_STREAM_DT;
+		md_addr = DS5_IMU_STREAM_MD;
+		override_addr = 0;
+		fps_addr = DS5_IMU_FPS;
+		width_addr = DS5_IMU_RES_WIDTH;
+		height_addr = DS5_IMU_RES_HEIGHT;
+		vc_id = 3;
+		md_fmt = 0x0;
+
+	fmt = sensor->streaming ? sensor->config.format->data_type : 0;
+
+	/*
+	 * Set depth stream Z16 data type as 0x31
+	 * Set IR stream Y8I data type as 0x32
+	 */
+	ret = ds5_write(state, dt_addr, fmt);
+	if (ret < 0)
+		return ret;
+
+	ret = ds5_write(state, md_addr, (vc_id << 8) | md_fmt);
+	if (ret < 0)
+		return ret;
+
+	if (override_addr != 0) {
+		ret = ds5_write(state, override_addr, fmt);
+		if (ret < 0)
+			return ret;
+	}
+
+	ret = ds5_write(state, fps_addr, sensor->config.framerate);
+	if (ret < 0)
+		return ret;
+
+	ret = ds5_write(state, width_addr, sensor->config.resolution->width);
+	if (ret < 0)
+		return ret;
+
+	ret = ds5_write(state, height_addr, sensor->config.resolution->height);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int ds5_configure_depth(struct ds5 *state)
+{
+	struct ds5_sensor *sensor;
+	u16 fmt, md_fmt, vc_id;
+	u16 dt_addr, md_addr, override_addr, fps_addr, width_addr, height_addr;
+	int ret;
+
+	// if (state->is_depth) {
+		sensor = &state->depth.sensor;
+		dt_addr = DS5_DEPTH_STREAM_DT;
+		md_addr = DS5_DEPTH_STREAM_MD;
+		override_addr = DS5_DEPTH_OVERRIDE;
+		fps_addr = DS5_DEPTH_FPS;
+		width_addr = DS5_DEPTH_RES_WIDTH;
+		height_addr = DS5_DEPTH_RES_HEIGHT;
+		// TODO: read VC from device tree
+		vc_id = 0;
+		md_fmt = 0x12;
+
+	fmt = 0x1e;
+
+	/*
+	 * Set depth stream Z16 data type as 0x31
+	 * Set IR stream Y8I data type as 0x32
+	 */
+	//if (fmt != 0)
+		ret = ds5_write(state, dt_addr, 0x31);
+	if (ret < 0)
+		return ret;
+
+	ret = ds5_write(state, md_addr, (vc_id << 8) | md_fmt);
+	if (ret < 0)
+		return ret;
+
+	if (override_addr != 0) {
+		ret = ds5_write(state, override_addr, fmt);
+		if (ret < 0)
+			return ret;
+	}
+
+	ret = ds5_write(state, fps_addr, sensor->config.framerate);
+	if (ret < 0)
+		return ret;
+
+	ret = ds5_write(state, width_addr, sensor->config.resolution->width);
+	if (ret < 0)
+		return ret;
+
+	ret = ds5_write(state, height_addr, sensor->config.resolution->height);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+static int ds5_configure_rgb(struct ds5 *state)
+{
+	struct ds5_sensor *sensor;
+	u16 fmt, md_fmt, vc_id;
+	u16 dt_addr, md_addr, override_addr, fps_addr, width_addr, height_addr;
+	int ret;
+
+	// } else if (state->is_rgb) {
+		sensor = &state->rgb.sensor;
+		dt_addr = DS5_RGB_STREAM_DT;
+		md_addr = DS5_RGB_STREAM_MD;
+		override_addr = 0;
+		fps_addr = DS5_RGB_FPS;
+		width_addr = DS5_RGB_RES_WIDTH;
+		height_addr = DS5_RGB_RES_HEIGHT;
+		vc_id = 1;
+		md_fmt = 0x12;
+
+	fmt = sensor->streaming ? sensor->config.format->data_type : 0;
+
+	/*
+	 * Set depth stream Z16 data type as 0x31
+	 * Set IR stream Y8I data type as 0x32
+	 */
+	dev_info(NULL, "%s, fmt 0x%08x, data_type 0x%08x\n", __func__, fmt, sensor->config.format->data_type);
+//	ret = ds5_write(state, dt_addr, fmt);
+	ret = ds5_write(state, dt_addr, 0x1e);
+	if (ret < 0)
+		return ret;
+
+	ret = ds5_write(state, md_addr, (vc_id << 8) | md_fmt);
+	if (ret < 0)
+		return ret;
+
+	if (override_addr != 0) {
+		ret = ds5_write(state, override_addr, fmt);
+		if (ret < 0)
+			return ret;
+	}
+
+	ret = ds5_write(state, fps_addr, sensor->config.framerate);
+	if (ret < 0)
+		return ret;
+
+	//ret = ds5_write(state, width_addr, 480);
+	ret = ds5_write(state, width_addr, sensor->config.resolution->width);
+	if (ret < 0)
+		return ret;
+
+	//ret = ds5_write(state, height_addr, 270);
+	ret = ds5_write(state, height_addr, sensor->config.resolution->height);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int ds5_configure_ir(struct ds5 *state)
+{
+	struct ds5_sensor *sensor;
+	u16 fmt, md_fmt, vc_id;
+	u16 dt_addr, md_addr, override_addr, fps_addr, width_addr, height_addr;
+	int ret;
+
+	// } else if (state->is_y8) {
+		sensor = &state->motion_t.sensor;
+		dt_addr = DS5_IR_STREAM_DT;
+		md_addr = DS5_IR_STREAM_MD;
+		override_addr = DS5_IR_OVERRIDE;
+		fps_addr = DS5_IR_FPS;
+		width_addr = DS5_IR_RES_WIDTH;
+		height_addr = DS5_IR_RES_HEIGHT;
+		vc_id = 2;
+		md_fmt = 0x12;
+
+	fmt = sensor->config.format->data_type;
+
+	/*
+	 * Set depth stream Z16 data type as 0x31
+	 * Set IR stream Y8I data type as 0x32
+	 */
+	//if (sensor->config.format->data_type == 0x1e)
+		ret = ds5_write(state, dt_addr, 0x32);
+	if (ret < 0)
+		return ret;
+
+	ret = ds5_write(state, md_addr, (vc_id << 8) | md_fmt);
+	if (ret < 0)
+		return ret;
+
+	if (override_addr != 0) {
+		ret = ds5_write(state, override_addr, fmt);
+		if (ret < 0)
+			return ret;
+	}
+
+	ret = ds5_write(state, fps_addr, sensor->config.framerate);
+	if (ret < 0)
+		return ret;
+
+	ret = ds5_write(state, width_addr, sensor->config.resolution->width);
+	if (ret < 0)
+		return ret;
+
+	ret = ds5_write(state, height_addr, sensor->config.resolution->height);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static const struct v4l2_subdev_pad_ops ds5_depth_pad_ops = {
+	.enum_mbus_code		= ds5_sensor_enum_mbus_code,
+	.enum_frame_size	= ds5_sensor_enum_frame_size,
+	.enum_frame_interval	= ds5_sensor_enum_frame_interval,
+	.get_fmt		= ds5_sensor_get_fmt,
+	.set_fmt		= ds5_sensor_set_fmt,
+};
+
+static int ds5_sensor_s_stream(struct v4l2_subdev *sd, int on)
+{
+	struct ds5_sensor *sensor = container_of(sd, struct ds5_sensor, sd);
+
+	dev_info(sensor->sd.dev, "%s(): sensor: name=%s state=%d\n", __func__, sensor->sd.name, on);
+
+	sensor->streaming = on;
+
+	return 0;
+}
+
+static const struct v4l2_subdev_video_ops ds5_sensor_video_ops = {
+	.s_stream		= ds5_sensor_s_stream,
+};
+
+static const struct v4l2_subdev_ops ds5_depth_subdev_ops = {
+	.pad = &ds5_depth_pad_ops,
+	.video = &ds5_sensor_video_ops,
+};
+
+/* Motion detection */
+
+/* FIXME: identical to ds5_depth_pad_ops, use one for both */
+static const struct v4l2_subdev_pad_ops ds5_motion_t_pad_ops = {
+	.enum_mbus_code		= ds5_sensor_enum_mbus_code,
+	.enum_frame_size	= ds5_sensor_enum_frame_size,
+	.enum_frame_interval	= ds5_sensor_enum_frame_interval,
+	.get_fmt		= ds5_sensor_get_fmt,
+	.set_fmt		= ds5_sensor_set_fmt,
+};
+
+static const struct v4l2_subdev_ops ds5_motion_t_subdev_ops = {
+	.pad = &ds5_motion_t_pad_ops,
+	.video = &ds5_sensor_video_ops,
+};
+
+/* FIXME: identical to ds5_depth_pad_ops, use one for both? */
+static const struct v4l2_subdev_pad_ops ds5_rgb_pad_ops = {
+	.enum_mbus_code		= ds5_sensor_enum_mbus_code,
+	.enum_frame_size	= ds5_sensor_enum_frame_size,
+	.enum_frame_interval	= ds5_sensor_enum_frame_interval,
+	.get_fmt		= ds5_sensor_get_fmt,
+	.set_fmt		= ds5_sensor_set_fmt,
+};
+
+static const struct v4l2_subdev_ops ds5_rgb_subdev_ops = {
+	.pad = &ds5_rgb_pad_ops,
+	.video = &ds5_sensor_video_ops,
+};
+
+static const struct v4l2_subdev_pad_ops ds5_imu_pad_ops = {
+	.enum_mbus_code		= ds5_sensor_enum_mbus_code,
+	.enum_frame_size	= ds5_sensor_enum_frame_size,
+	.enum_frame_interval	= ds5_sensor_enum_frame_interval,
+	.get_fmt		= ds5_sensor_get_fmt,
+	.set_fmt		= ds5_sensor_set_fmt,
+};
+
+static const struct v4l2_subdev_ops ds5_imu_subdev_ops = {
+	.pad = &ds5_imu_pad_ops,
+	.video = &ds5_sensor_video_ops,
+};
+
+static int ds5_hw_set_auto_exposure(struct ds5 *state, u32 base, u32 val)
+{
+	if (val != V4L2_EXPOSURE_APERTURE_PRIORITY &&
+	    val != V4L2_EXPOSURE_MANUAL)
+		return -EINVAL;
+
+	/*
+	 * In firmware color auto exposure setting follow the uvc_menu_info
+	 * exposure_auto_controls numbers, in drivers/media/usb/uvc/uvc_ctrl.c.
+	 */
+	if (state->is_rgb && val == V4L2_EXPOSURE_APERTURE_PRIORITY)
+		val = 8;
+
+	/*
+	 * In firmware depth auto exposure on: 1, off: 0.
+	 */
+	if (!state->is_rgb) {
+		if (val == V4L2_EXPOSURE_APERTURE_PRIORITY)
+			val = 1;
+		else if (val == V4L2_EXPOSURE_MANUAL)
+			val = 0;
+	}
+
+	return ds5_write(state, base | DS5_AUTO_EXPOSURE_MODE, val);
+}
+
+/*
+ * Manual exposure in us
+ * Depth/Y8: between 100 and 200000 (200ms)
+ * Color: between 100 and 1000000 (1s)
+ */
+static int ds5_hw_set_exposure(struct ds5 *state, u32 base, u32 val)
+{
+	int ret;
+
+	if (val < 1)
+		val = 1;
+	if ((state->is_depth || state->is_y8) && val > MAX_DEPTH_EXP)
+		val = MAX_DEPTH_EXP;
+	if (state->is_rgb && val > MAX_RGB_EXP)
+		val = MAX_RGB_EXP;
+
+	/*
+	 * Color and depth uses different unit:
+	 *	Color: 1 is 100 us
+	 *	Depth: 1 is 1 us
+	 */
+	if (!state->is_rgb)
+		val *= 100;
+
+	ret = ds5_write(state, base | DS5_MANUAL_EXPOSURE_MSB, val >> 16);
+	if (!ret)
+		ret = ds5_write(state, base | DS5_MANUAL_EXPOSURE_LSB,
+				val & 0xffff);
+
+	return ret;
+}
+
+#define DS5_MAX_LOG_WAIT 200
+#define DS5_MAX_LOG_SLEEP 10
+#define DS5_MAX_LOG_POLL (DS5_MAX_LOG_WAIT / DS5_MAX_LOG_SLEEP)
+
+// TODO: why to use DS5_DEPTH_Y_STREAMS_DT?
+#define DS5_CAMERA_CID_BASE	(V4L2_CTRL_CLASS_CAMERA | DS5_DEPTH_STREAM_DT)
+
+#define DS5_CAMERA_CID_LOG			(DS5_CAMERA_CID_BASE+0)
+#define DS5_CAMERA_CID_LASER_POWER		(DS5_CAMERA_CID_BASE+1)
+#define DS5_CAMERA_CID_MANUAL_LASER_POWER	(DS5_CAMERA_CID_BASE+2)
+#define DS5_CAMERA_DEPTH_CALIBRATION_TABLE_GET	(DS5_CAMERA_CID_BASE+3)
+#define DS5_CAMERA_DEPTH_CALIBRATION_TABLE_SET	(DS5_CAMERA_CID_BASE+4)
+#define DS5_CAMERA_COEFF_CALIBRATION_TABLE_GET	(DS5_CAMERA_CID_BASE+5)
+#define DS5_CAMERA_COEFF_CALIBRATION_TABLE_SET	(DS5_CAMERA_CID_BASE+6)
+#define DS5_CAMERA_CID_FW_VERSION		(DS5_CAMERA_CID_BASE+7)
+#define DS5_CAMERA_CID_GVD			(DS5_CAMERA_CID_BASE+8)
+#define DS5_CAMERA_CID_AE_ROI_GET		(DS5_CAMERA_CID_BASE+9)
+#define DS5_CAMERA_CID_AE_ROI_SET		(DS5_CAMERA_CID_BASE+10)
+#define DS5_CAMERA_CID_AE_SETPOINT_GET		(DS5_CAMERA_CID_BASE+11)
+#define DS5_CAMERA_CID_AE_SETPOINT_SET		(DS5_CAMERA_CID_BASE+12)
+#define DS5_CAMERA_CID_ERB			(DS5_CAMERA_CID_BASE+13)
+#define DS5_CAMERA_CID_EWB			(DS5_CAMERA_CID_BASE+14)
+#define DS5_CAMERA_CID_HWMC			(DS5_CAMERA_CID_BASE+15)
+
+static int ds5_send_hwmc(struct ds5 *state, u16 cmdLen, struct hwm_cmd *cmd,
+			 bool isRead, u16 *dataLen)
+{
+	int ret = 0;
+	u16 status = 2;
+	int retries = 20;
+	int errorCode;
+
+	dev_info(&state->client->dev,
+		"%s(): HWMC header: 0x%x, magic: 0x%x, opcode: 0x%x, param1: %d, param2: %d, param3: %d, param4: %d\n",
+		__func__,
+		cmd->header, cmd->magic_word, cmd->opcode, cmd->param1, cmd->param2, cmd->param3, cmd->param4);
+
+	ds5_raw_write_with_check(state, 0x4900, cmd, cmdLen);
+
+	ds5_write_with_check(state, 0x490C, 0x01); /* execute cmd */
+	do {
+		if (retries != 5)
+			msleep_range(50);
+		ret = ds5_read(state, 0x4904, &status);
+	} while (retries-- && status != 0);
+
+	if (ret || status != 0) {
+		ds5_raw_read(state, 0x4900, &errorCode, 4);
+		dev_err(&state->client->dev, "%s(): HWMC failed, ret: %d, status: %x, error code: %d\n",
+					__func__, ret, status, errorCode);
+		ret = -EAGAIN;
+	}
+
+	if (isRead) {
+		if (*dataLen == 0) {
+			ret = regmap_raw_read(state->regmap, 0x4908, dataLen, sizeof(u16));
+			if (ret)
+				return -EAGAIN;
+		}
+
+		dev_err(&state->client->dev, "%s(): HWMC read len: %d\n",
+					__func__, *dataLen);
+		// First 4 bytes of cmd->Data after read will include opcode
+		ds5_raw_read_with_check(state, 0x4900, cmd->Data, *dataLen);
+
+		/*This is neede for libreealsense, to align there code with UVC*/
+		cmd->Data[1000] = (unsigned char)((*dataLen) & 0x00FF);
+		cmd->Data[1001] = (unsigned char)(((*dataLen) & 0xFF00) >> 8);
+	}
+
+	return 0;
+}
+
+static int ds5_set_calibration_data(struct ds5 *state, struct hwm_cmd *cmd, u16 length)
+{
+	int ret;
+	int retries = 10;
+	u16 status = 2;
+
+	ds5_raw_write_with_check(state, 0x4900, cmd, length);
+
+	ds5_write_with_check(state, 0x490c, 0x01); /* execute cmd */
+	do {
+		if (retries != 10)
+			msleep_range(200);
+		ret = ds5_read(state, 0x4904, &status);
+	} while (retries-- && status != 0);
+
+	if (ret || status != 0) {
+		dev_err(&state->client->dev, "%s(): Failed to set calibration table %d, ret: %d, fw error: %x\n",
+				__func__, cmd->param1, ret, status);
+	}
+
+	return -EINVAL;
+}
+
+static int ds5_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct ds5 *state = container_of(ctrl->handler, struct ds5,
+					 ctrls.handler);
+	struct v4l2_subdev *sd = &state->mux.sd.subdev;
+	int ret = -EINVAL;
+	u16 base = DS5_DEPTH_CONTROL_BASE;
+	u32 val;
+	u16 on;
+	u16 vc_id;
+
+	if (state->is_rgb)
+		base = DS5_RGB_CONTROL_BASE;
+	else if (state->is_imu)
+		return ret;
+
+	v4l2_dbg(1, 1, sd, "ctrl: %s, value: %d\n", ctrl->name, ctrl->val);
+
+	mutex_lock(&state->lock);
+
+	switch (ctrl->id) {
+	case V4L2_CID_ANALOGUE_GAIN:
+		ret = ds5_write(state, base | DS5_MANUAL_GAIN, ctrl->val);
+		break;
+
+	case V4L2_CID_EXPOSURE_AUTO:
+		ret = ds5_hw_set_auto_exposure(state, base, ctrl->val);
+		break;
+
+	case V4L2_CID_EXPOSURE_ABSOLUTE:
+		ret = ds5_hw_set_exposure(state, base, ctrl->val);
+		break;
+	case DS5_CAMERA_CID_LASER_POWER:
+		if (!state->is_rgb)
+			ret = ds5_write(state, base | DS5_LASER_POWER,
+					ctrl->val);
+		break;
+	case DS5_CAMERA_CID_MANUAL_LASER_POWER:
+		if (!state->is_rgb)
+			ret = ds5_write(state, base | DS5_MANUAL_LASER_POWER,
+					ctrl->val);
+		break;
+	case DS5_CAMERA_DEPTH_CALIBRATION_TABLE_SET: {
+		struct hwm_cmd *calib_cmd;
+
+		dev_info(&state->client->dev, "%s(): DS5_CAMERA_DEPTH_CALIBRATION_TABLE_SET \n", __func__);
+		dev_info(&state->client->dev, "%s(): table id: 0x%x\n", __func__, *((u8 *)ctrl->p_new.p + 2));
+		if (ctrl->p_new.p && DEPTH_CALIBRATION_ID == *((u8 *)ctrl->p_new.p + 2)) {
+			calib_cmd = devm_kzalloc(&state->client->dev, sizeof(struct hwm_cmd) + 256, GFP_KERNEL);
+			memcpy(calib_cmd, &set_calib_data, sizeof(set_calib_data));
+			calib_cmd->header = 276;
+			calib_cmd->param1 = DEPTH_CALIBRATION_ID;
+			memcpy(calib_cmd->Data, (u8 *)ctrl->p_new.p, 256);
+			ret = ds5_set_calibration_data(state, calib_cmd, sizeof(struct hwm_cmd) + 256);
+			devm_kfree(&state->client->dev, calib_cmd);
+		}
+		break;
+		}
+	case DS5_CAMERA_COEFF_CALIBRATION_TABLE_SET: {
+			struct hwm_cmd *calib_cmd;
+
+			dev_info(&state->client->dev, "%s(): DS5_CAMERA_COEFF_CALIBRATION_TABLE_SET \n", __func__);
+			dev_info(&state->client->dev, "%s(): table id %d\n", __func__, *((u8 *)ctrl->p_new.p + 2));
+			if (ctrl->p_new.p && COEF_CALIBRATION_ID == *((u8 *)ctrl->p_new.p + 2)) {
+				calib_cmd = devm_kzalloc(&state->client->dev, sizeof(struct hwm_cmd) + 512, GFP_KERNEL);
+				memcpy(calib_cmd, &set_calib_data, sizeof(set_calib_data));
+				calib_cmd->header = 532;
+				calib_cmd->param1 = COEF_CALIBRATION_ID;
+				memcpy(calib_cmd->Data, (u8 *)ctrl->p_new.p, 512);
+				ret = ds5_set_calibration_data(state, calib_cmd, sizeof(struct hwm_cmd) + 512);
+				devm_kfree(&state->client->dev, calib_cmd);
+			}
+		}
+		break;
+	case DS5_CAMERA_CID_AE_ROI_SET: {
+		struct hwm_cmd ae_roi_cmd;
+
+		memcpy(&ae_roi_cmd, &set_ae_roi, sizeof(ae_roi_cmd));
+		ae_roi_cmd.param1 = *((u16 *)ctrl->p_new.p_u16);
+		ae_roi_cmd.param2 = *((u16 *)ctrl->p_new.p_u16 + 1);
+		ae_roi_cmd.param3 = *((u16 *)ctrl->p_new.p_u16 + 2);
+		ae_roi_cmd.param4 = *((u16 *)ctrl->p_new.p_u16 + 3);
+		ret = ds5_send_hwmc(state, sizeof(struct hwm_cmd), &ae_roi_cmd, false, NULL);
+		break;
+		}
+	case DS5_CAMERA_CID_AE_SETPOINT_SET: {
+		struct hwm_cmd *ae_setpoint_cmd;
+
+		if (ctrl->p_new.p_s32) {
+			dev_err(&state->client->dev, "%s():0x%x \n", __func__,
+					*(ctrl->p_new.p_s32));
+			ae_setpoint_cmd = devm_kzalloc(&state->client->dev, sizeof(struct hwm_cmd) + 4, GFP_KERNEL);
+			memcpy(ae_setpoint_cmd, &set_ae_setpoint, sizeof(set_ae_setpoint));
+			memcpy(ae_setpoint_cmd->Data, (u8 *)ctrl->p_new.p_s32, 4);
+			ret = ds5_send_hwmc(state, sizeof(struct hwm_cmd) + 4, ae_setpoint_cmd, false, NULL);
+			devm_kfree(&state->client->dev, ae_setpoint_cmd);
+		}
+		break;
+	}
+	case DS5_CAMERA_CID_ERB:
+		if (ctrl->p_new.p_u8) {
+			u16 offset = 0;
+			u16 size = 0;
+			struct hwm_cmd *erb_cmd;
+
+			offset = *(ctrl->p_new.p_u8) << 8;
+			offset |= *(ctrl->p_new.p_u8 + 1);
+			size = *(ctrl->p_new.p_u8 + 2) << 8;
+			size |= *(ctrl->p_new.p_u8 + 3);
+
+			dev_err(&state->client->dev, "%s(): offset %x, size: %x\n",
+							__func__, offset, size);
+
+			erb_cmd = devm_kzalloc(&state->client->dev, sizeof(struct hwm_cmd) + size, GFP_KERNEL);
+			memcpy(erb_cmd, &erb, sizeof(struct hwm_cmd));
+			erb_cmd->param1 = offset;
+			erb_cmd->param2 = size;
+			ret = ds5_send_hwmc(state, sizeof(struct hwm_cmd), erb_cmd, true, &size);
+
+			if (ret) {
+				dev_err(&state->client->dev, "%s(): ERB cmd failed, ret: %d, requested size: %d, actual size: %d\n",
+								__func__, ret, erb_cmd->param2, size);
+				devm_kfree(&state->client->dev, erb_cmd);
+				return -EAGAIN;
+			}
+
+			// Actual size returned from FW
+			*(ctrl->p_new.p_u8 + 2) = (size & 0xFF00) >> 8;
+			*(ctrl->p_new.p_u8 + 3) = (size & 0x00FF);
+
+			memcpy(ctrl->p_new.p_u8 + 4, erb_cmd->Data + 4, size - 4);
+			dev_info(&state->client->dev, "%s(): 0x%x 0x%x 0x%x 0x%x \n",
+				__func__,
+				*(ctrl->p_new.p_u8),
+				*(ctrl->p_new.p_u8+1),
+				*(ctrl->p_new.p_u8+2),
+				*(ctrl->p_new.p_u8+3));
+			devm_kfree(&state->client->dev, erb_cmd);
+		}
+		break;
+	case DS5_CAMERA_CID_EWB:
+		if (ctrl->p_new.p_u8) {
+			u16 offset = 0;
+			u16 size = 0;
+			struct hwm_cmd *ewb_cmd;
+
+			offset = *((u8 *)ctrl->p_new.p_u8) << 8;
+			offset |= *((u8 *)ctrl->p_new.p_u8 + 1);
+			size = *((u8 *)ctrl->p_new.p_u8 + 2) << 8;
+			size |= *((u8 *)ctrl->p_new.p_u8 + 3);
+
+			dev_err(&state->client->dev, "%s():0x%x 0x%x 0x%x 0x%x\n", __func__,
+					*((u8 *)ctrl->p_new.p_u8),
+					*((u8 *)ctrl->p_new.p_u8 + 1),
+					*((u8 *)ctrl->p_new.p_u8 + 2),
+					*((u8 *)ctrl->p_new.p_u8 + 3));
+
+			ewb_cmd = devm_kzalloc(&state->client->dev, sizeof(struct hwm_cmd) + size, GFP_KERNEL);
+			memcpy(ewb_cmd, &ewb, sizeof(ewb));
+			ewb_cmd->header = 0x14 + size;
+			ewb_cmd->param1 = offset; // start index
+			ewb_cmd->param2 = size; // size
+			memcpy(ewb_cmd->Data, (u8 *)ctrl->p_new.p_u8 + 4, size);
+			ret = ds5_send_hwmc(state, sizeof(struct hwm_cmd) + size, ewb_cmd, false, NULL);
+
+			if (ret) {
+				dev_err(&state->client->dev, "%s(): EWB cmd failed, ret: %d, requested size: %d, actual size: %d\n",
+								__func__, ret, ewb_cmd->param2, size);
+				devm_kfree(&state->client->dev, ewb_cmd);
+				return -EAGAIN;
+			}
+
+			devm_kfree(&state->client->dev, ewb_cmd);
+		}
+		break;
+	case DS5_CAMERA_CID_HWMC:
+		if (ctrl->p_new.p_u8) {
+			u16 dataLen = 0;
+			u16 size = 0;
+
+			size = *((u8 *)ctrl->p_new.p_u8 + 1) << 8;
+			size |= *((u8 *)ctrl->p_new.p_u8 + 0);
+			dev_err(&state->client->dev, "%s(): HWMC size %d\n", __func__, size);
+			ret = ds5_send_hwmc(state, size + 4, (struct hwm_cmd *)ctrl->p_new.p_u8, true, &dataLen);
+		}
+		break;
+	case V4L2_CID_IPU_SET_SUB_STREAM:
+		val = (*ctrl->p_new.p_s64 & 0xFFFF);
+		dev_info(&state->client->dev, "V4L2_CID_IPU_SET_SUB_STREAM %x\n", val);
+		vc_id = (val >> 8) & 0x00FF;
+		on = val & 0x00FF;
+		if (vc_id > NR_OF_DS5_STREAMS - 1)
+			dev_err(&state->client->dev, "invalid vc %d\n", vc_id);
+		else
+			d4xx_set_sub_stream[vc_id] = on;
+
+		ret = ds5_mux_s_stream_vc(state, vc_id, on);
+
+		break;
+	}
+
+	mutex_unlock(&state->lock);
+
+	return ret;
+}
+
+static int ds5_get_calibration_data(struct ds5 *state, enum table_id id, unsigned char *table, unsigned int length)
+{
+	struct hwm_cmd *cmd;
+	int ret;
+	int retries = 3;
+	u16 status = 2;
+	u16 table_length;
+
+	cmd = devm_kzalloc(&state->client->dev, sizeof(struct hwm_cmd) + length + 4, GFP_KERNEL);
+	memcpy(cmd, &get_calib_data, sizeof(get_calib_data));
+	cmd->param1 = id;
+	ds5_raw_write_with_check(state, 0x4900, cmd, sizeof(struct hwm_cmd));
+	ds5_write_with_check(state, 0x490c, 0x01); /* execute cmd */
+	do {
+		if (retries != 3)
+			msleep_range(10);
+		ret = ds5_read(state, 0x4904, &status);
+	} while (ret && retries-- && status != 0);
+
+	if (ret || status != 0) {
+		dev_err(&state->client->dev,
+		    "%s(): Failed to get calibration table %d, fw error: %x\n", __func__, id, status);
+		devm_kfree(&state->client->dev, cmd);
+		return status;
+	}
+
+	// get table length from fw
+	ret = regmap_raw_read(state->regmap, 0x4908, &table_length, sizeof(table_length));
+
+	// read table
+	ds5_raw_read_with_check(state, 0x4900, cmd->Data, table_length);
+
+	// first 4 bytes are opcode HWM, not part of calibration table
+	memcpy(table, cmd->Data + 4, length);
+	devm_kfree(&state->client->dev, cmd);
+	return 0;
+}
+
+static int ds5_gvd(struct ds5 *state, unsigned char *data)
+{
+	struct hwm_cmd cmd;
+	int ret;
+	u16 length = 0;
+	u16 status = 2;
+	u8 retries = 3;
+
+	memcpy(&cmd, &gvd, sizeof(gvd));
+	ds5_raw_write_with_check(state, 0x4900, &cmd, sizeof(cmd));
+	ds5_write_with_check(state, 0x490c, 0x01); /* execute cmd */
+	do {
+		if (retries != 3)
+			msleep_range(10);
+
+		ret = ds5_read(state, 0x4904, &status);
+	} while (ret && retries-- && status != 0);
+
+	if (ret || status != 0) {
+		dev_err(&state->client->dev, "%s(): Failed to read GVD, HWM cmd status: %x\n", __func__, status);
+		return status;
+	}
+
+	ret = regmap_raw_read(state->regmap, 0x4908, &length, sizeof(length));
+	ds5_raw_read_with_check(state, 0x4900, data, length);
+
+	return ret;
+}
+
+static int ds5_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct ds5 *state = container_of(ctrl->handler, struct ds5,
+					 ctrls.handler);
+	u16 log_prepare[] = {0x0014, 0xcdab, 0x000f, 0x0000, 0x0400, 0x0000,
+			     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000};
+	u16 execute_cmd = 0x0001;
+	unsigned int i;
+	u32 data;
+	int ret = 0;
+
+	switch (ctrl->id) {
+	case DS5_CAMERA_CID_LOG:
+		// TODO: wrap HWMonitor command
+		//       1. prepare and send command
+		//       2. send command
+		//       3. execute command
+		//       4. wait for ccompletion
+		ret = regmap_raw_write(state->regmap, 0x4900,
+				       log_prepare, sizeof(log_prepare));
+		if (ret < 0)
+			return ret;
+
+		ret = regmap_raw_write(state->regmap, 0x490C,
+				&execute_cmd, sizeof(execute_cmd));
+		if (ret < 0)
+			return ret;
+
+		for (i = 0; i < DS5_MAX_LOG_POLL; i++) {
+			ret = regmap_raw_read(state->regmap, 0x4904,
+					      &data, sizeof(data));
+			dev_info(&state->client->dev, "%s(): log ready 0x%x\n",
+				 __func__, data);
+			if (ret < 0)
+				return ret;
+			if (!data)
+				break;
+			msleep_range(5);
+		}
+
+//		if (i == DS5_MAX_LOG_POLL)
+//			return -ETIMEDOUT;
+
+		ret = regmap_raw_read(state->regmap, 0x4908,
+				      &data, sizeof(data));
+		dev_info(&state->client->dev, "%s(): log size 0x%x\n",
+			 __func__, data);
+		if (ret < 0)
+			return ret;
+		if (!data)
+			return 0;
+		if (data > 1024)
+			return -ENOBUFS;
+		ret = regmap_raw_read(state->regmap, 0x4900,
+				ctrl->p_new.p_u8, data);
+		break;
+	case DS5_CAMERA_DEPTH_CALIBRATION_TABLE_GET:
+		ret = ds5_get_calibration_data(state, DEPTH_CALIBRATION_ID, ctrl->p_new.p_u8, 256);
+		break;
+	case DS5_CAMERA_COEFF_CALIBRATION_TABLE_GET:
+		ret = ds5_get_calibration_data(state, COEF_CALIBRATION_ID, ctrl->p_new.p_u8, 512);
+		break;
+	case DS5_CAMERA_CID_FW_VERSION:
+		*ctrl->p_new.p_u32 = state->fw_version << 16;
+		*ctrl->p_new.p_u32 |= state->fw_build;
+		break;
+	case DS5_CAMERA_CID_GVD:
+		ret = ds5_gvd(state, ctrl->p_new.p_u8);
+		break;
+	case DS5_CAMERA_CID_AE_ROI_GET: {
+		u16 len = 0;
+		struct hwm_cmd *ae_roi_cmd;
+
+		ae_roi_cmd = devm_kzalloc(&state->client->dev, sizeof(struct hwm_cmd) + 12, GFP_KERNEL);
+		memcpy(ae_roi_cmd, &get_ae_roi, sizeof(struct hwm_cmd));
+		ret = ds5_send_hwmc(state, sizeof(struct hwm_cmd), ae_roi_cmd, true, &len);
+		memcpy(ctrl->p_new.p_u16, ae_roi_cmd->Data + 4, 8);
+		devm_kfree(&state->client->dev, ae_roi_cmd);
+		}
+		break;
+	case DS5_CAMERA_CID_AE_SETPOINT_GET: {
+		u16 len = 0;
+		struct hwm_cmd *ae_setpoint_cmd;
+
+		ae_setpoint_cmd = devm_kzalloc(&state->client->dev, sizeof(struct hwm_cmd) + 8, GFP_KERNEL);
+		memcpy(ae_setpoint_cmd, &get_ae_setpoint, sizeof(struct hwm_cmd));
+		ret = ds5_send_hwmc(state, sizeof(struct hwm_cmd), ae_setpoint_cmd, true, &len);
+		memcpy(ctrl->p_new.p_s32, ae_setpoint_cmd->Data + 4, 4);
+		dev_info(&state->client->dev, "%s(): 0x%x \n",
+					__func__,
+					*(ctrl->p_new.p_s32));
+		devm_kfree(&state->client->dev, ae_setpoint_cmd);
+		}
+		break;
+	}
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops ds5_ctrl_ops = {
+	.s_ctrl	= ds5_s_ctrl,
+	.g_volatile_ctrl = ds5_g_volatile_ctrl,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_log = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_CID_LOG,
+	.name = "Logger",
+	.type = V4L2_CTRL_TYPE_U8,
+	.dims = {1024},
+	.elem_size = sizeof(u8),
+	.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
+	.step = 1,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_laser_power = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_CID_LASER_POWER,
+	.name = "Laser power on/off",
+	.type = V4L2_CTRL_TYPE_BOOLEAN,
+	.min = 0,
+	.max = 1,
+	.step = 1,
+	.def = 1,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_manual_laser_power = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_CID_MANUAL_LASER_POWER,
+	.name = "Manual laser power",
+	.type = V4L2_CTRL_TYPE_INTEGER,
+	.min = 0,
+	.max = 360,
+	.step = 30,
+	.def = 240,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_fw_version = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_CID_FW_VERSION,
+	.name = "fw version",
+	.type = V4L2_CTRL_TYPE_U32,
+	.dims = {1},
+	.elem_size = sizeof(u32),
+	.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
+	.step = 1,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_gvd = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_CID_GVD,
+	.name = "GVD",
+	.type = V4L2_CTRL_TYPE_U8,
+	.dims = {239},
+	.elem_size = sizeof(u8),
+	.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
+	.step = 1,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_get_depth_calib = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_DEPTH_CALIBRATION_TABLE_GET,
+	.name = "get depth calib",
+	.type = V4L2_CTRL_TYPE_U8,
+	.dims = {256},
+	.elem_size = sizeof(u8),
+	.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
+	.step = 1,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_set_depth_calib = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_DEPTH_CALIBRATION_TABLE_SET,
+	.name = "set depth calib",
+	.type = V4L2_CTRL_TYPE_U8,
+	.dims = {256},
+	.elem_size = sizeof(u8),
+	.min = 0,
+	.max = 0xFFFFFFFF,
+	.def = 240,
+	.step = 1,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_get_coeff_calib = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_COEFF_CALIBRATION_TABLE_GET,
+	.name = "get coeff calib",
+	.type = V4L2_CTRL_TYPE_U8,
+	.dims = {512},
+	.elem_size = sizeof(u8),
+	.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
+	.step = 1,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_set_coeff_calib = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_COEFF_CALIBRATION_TABLE_SET,
+	.name = "set coeff calib",
+	.type = V4L2_CTRL_TYPE_U8,
+	.dims = {512},
+	.elem_size = sizeof(u8),
+	.min = 0,
+	.max = 0xFFFFFFFF,
+	.def = 240,
+	.step = 1,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_ae_roi_get = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_CID_AE_ROI_GET,
+	.name = "ae roi get",
+	.type = V4L2_CTRL_TYPE_U8,
+	.dims = {8},
+	.elem_size = sizeof(u16),
+	.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
+	.step = 1,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_ae_roi_set = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_CID_AE_ROI_SET,
+	.name = "ae roi set",
+	.type = V4L2_CTRL_TYPE_U8,
+	.dims = {8},
+	.elem_size = sizeof(u16),
+	.min = 0,
+	.max = 0xFFFFFFFF,
+	.def = 240,
+	.step = 1,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_ae_setpoint_get = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_CID_AE_SETPOINT_GET,
+	.name = "ae setpoint get",
+	.type = V4L2_CTRL_TYPE_INTEGER,
+	.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
+	.step = 1,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_ae_setpoint_set = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_CID_AE_SETPOINT_SET,
+	.name = "ae setpoint set",
+	.type = V4L2_CTRL_TYPE_INTEGER,
+	.min = 0,
+	.max = 4095,
+	.step = 1,
+	.def = 0,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_erb = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_CID_ERB,
+	.name = "ERB eeprom read",
+	.type = V4L2_CTRL_TYPE_U8,
+	.dims = {1020},
+	.elem_size = sizeof(u8),
+	.min = 0,
+	.max = 0xFFFFFFFF,
+	.def = 240,
+	.step = 1,
+	.step = 1,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_ewb = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_CID_EWB,
+	.name = "EWB eeprom write",
+	.type = V4L2_CTRL_TYPE_U8,
+	.dims = {1020},
+	.elem_size = sizeof(u8),
+	.min = 0,
+	.max = 0xFFFFFFFF,
+	.def = 240,
+	.step = 1,
+	.step = 1,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_hwmc = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_CID_HWMC,
+	.name = "HWMC",
+	.type = V4L2_CTRL_TYPE_U8,
+	.dims = {1028},
+	.elem_size = sizeof(u8),
+	.min = 0,
+	.max = 0xFFFFFFFF,
+	.def = 240,
+	.step = 1,
+	.step = 1,
+};
+
+static const struct v4l2_ctrl_config d4xx_controls_link_freq = {
+	.ops = &ds5_ctrl_ops,
+	.id = V4L2_CID_LINK_FREQ,
+	.name = "V4L2_CID_LINK_FREQ",
+	.type = V4L2_CTRL_TYPE_INTEGER_MENU,
+	.max = ARRAY_SIZE(link_freq_menu_items) - 1,
+	.min =  0,
+	.step  = 0,
+	.def = 1,
+	.qmenu_int = link_freq_menu_items,
+};
+
+static const struct v4l2_ctrl_config d4xx_controls_q_sub_stream = {
+	.ops = &ds5_ctrl_ops,
+	.id = V4L2_CID_IPU_QUERY_SUB_STREAM,
+	.name = "query virtual channel",
+	.type = V4L2_CTRL_TYPE_INTEGER_MENU,
+	.max = ARRAY_SIZE(d4xx_query_sub_stream) - 1,
+	.min = 0,
+	.def = 0,
+	.menu_skip_mask = 0,
+	.qmenu_int = d4xx_query_sub_stream,
+};
+
+static const struct v4l2_ctrl_config d4xx_controls_s_sub_stream = {
+	.ops = &ds5_ctrl_ops,
+	.id = V4L2_CID_IPU_SET_SUB_STREAM,
+	.name = "set virtual channel",
+	.type = V4L2_CTRL_TYPE_INTEGER64,
+	.max = 0xFFFF,
+	.min = 0,
+	.def = 0,
+	.step = 1,
+};
+
+static int ds5_mux_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct ds5 *state = v4l2_get_subdevdata(sd);
+
+	dev_info(sd->dev, "%s(): %s (%p)\n", __func__, sd->name, fh);
+	if (state->dfu_dev.dfu_state_flag)
+		return -EBUSY;
+	try_module_get(THIS_MODULE);
+	state->dfu_dev.device_open_count++;
+
+	return 0;
+};
+
+static int ds5_mux_close(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct ds5 *state = v4l2_get_subdevdata(sd);
+
+	dev_info(sd->dev, "%s(): %s (%p)\n", __func__, sd->name, fh);
+	state->dfu_dev.device_open_count--;
+	module_put(THIS_MODULE);
+	return 0;
+};
+
+static const struct v4l2_subdev_internal_ops ds5_sensor_internal_ops = {
+	.open = ds5_mux_open,
+	.close = ds5_mux_close,
+};
+
+static int ds5_ctrl_init(struct ds5 *state)
+{
+	const struct v4l2_ctrl_ops *ops = &ds5_ctrl_ops;
+	struct ds5_ctrls *ctrls = &state->ctrls;
+	struct v4l2_ctrl_handler *hdl = &ctrls->handler;
+	struct v4l2_subdev *sd = &state->mux.sd.subdev;
+	int ret;
+
+	dev_info(NULL, "%s(), line %d\n", __func__, __LINE__);
+	ret = v4l2_ctrl_handler_init(hdl, DS5_N_CONTROLS);
+	if (ret < 0) {
+		v4l2_err(sd, "cannot init ctrl handler (%d)\n", ret);
+		return ret;
+	}
+
+	ctrls->log = v4l2_ctrl_new_custom(hdl, &ds5_ctrl_log, NULL);
+	ctrls->fw_version = v4l2_ctrl_new_custom(hdl, &ds5_ctrl_fw_version, NULL);
+	ctrls->gvd = v4l2_ctrl_new_custom(hdl, &ds5_ctrl_gvd, NULL);
+	ctrls->get_depth_calib = v4l2_ctrl_new_custom(hdl, &ds5_ctrl_get_depth_calib, NULL);
+	ctrls->set_depth_calib = v4l2_ctrl_new_custom(hdl, &ds5_ctrl_set_depth_calib, NULL);
+	ctrls->get_coeff_calib = v4l2_ctrl_new_custom(hdl, &ds5_ctrl_get_coeff_calib, NULL);
+	ctrls->set_coeff_calib = v4l2_ctrl_new_custom(hdl, &ds5_ctrl_set_coeff_calib, NULL);
+	ctrls->ae_roi_get = v4l2_ctrl_new_custom(hdl, &ds5_ctrl_ae_roi_get, NULL);
+	ctrls->ae_roi_set = v4l2_ctrl_new_custom(hdl, &ds5_ctrl_ae_roi_set, NULL);
+	ctrls->ae_setpoint_get = v4l2_ctrl_new_custom(hdl, &ds5_ctrl_ae_setpoint_get, NULL);
+	ctrls->ae_setpoint_set = v4l2_ctrl_new_custom(hdl, &ds5_ctrl_ae_setpoint_set, NULL);
+	ctrls->erb = v4l2_ctrl_new_custom(hdl, &ds5_ctrl_erb, NULL);
+	ctrls->ewb = v4l2_ctrl_new_custom(hdl, &ds5_ctrl_ewb, NULL);
+	ctrls->hwmc = v4l2_ctrl_new_custom(hdl, &ds5_ctrl_hwmc, NULL);
+
+	// TODO: wait for decision from FW if to replace with one control
+	//       should report as cluster?
+	ctrls->laser_power = v4l2_ctrl_new_custom(hdl, &ds5_ctrl_laser_power, NULL);
+	ctrls->manual_laser_power = v4l2_ctrl_new_custom(hdl, &ds5_ctrl_manual_laser_power, NULL);
+
+	/* Total gain */
+		ctrls->gain = v4l2_ctrl_new_std(hdl, ops,
+						V4L2_CID_ANALOGUE_GAIN,
+						16, 248, 1, 16);
+
+	ctrls->link_freq = v4l2_ctrl_new_custom(hdl, &d4xx_controls_link_freq, NULL);
+	dev_info(sd->dev, "%s(): %p\n", __func__, ctrls->link_freq);
+	if (ctrls->link_freq)
+	    ctrls->link_freq->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	ctrls->auto_exp = v4l2_ctrl_new_std_menu(hdl, ops,
+				V4L2_CID_EXPOSURE_AUTO,
+				V4L2_EXPOSURE_APERTURE_PRIORITY,
+				~((1 << V4L2_EXPOSURE_MANUAL) |
+				  (1 << V4L2_EXPOSURE_APERTURE_PRIORITY)),
+				V4L2_EXPOSURE_APERTURE_PRIORITY);
+
+	/* Exposure time: V4L2_CID_EXPOSURE_ABSOLUTE unit: 100 us. */
+		ctrls->exposure = v4l2_ctrl_new_std(hdl, ops,
+					V4L2_CID_EXPOSURE_ABSOLUTE,
+					1, MAX_DEPTH_EXP, 1, DEF_DEPTH_EXP);
+
+	ctrls->query_sub_stream = v4l2_ctrl_new_custom(hdl, &d4xx_controls_q_sub_stream, NULL);
+	ctrls->set_sub_stream = v4l2_ctrl_new_custom(hdl, &d4xx_controls_s_sub_stream, NULL);
+	dev_info(NULL, "%s(), line %d\n", __func__, __LINE__);
+	if (hdl->error) {
+		v4l2_err(sd, "error creating controls (%d)\n", hdl->error);
+		ret = hdl->error;
+		v4l2_ctrl_handler_free(hdl);
+		return ret;
+	}
+
+	// TODO: consider invoking v4l2_ctrl_handler_setup(hdl);
+
+	state->mux.sd.subdev.ctrl_handler = hdl;
+
+	dev_info(NULL, "%s(), line %d\n", __func__, __LINE__);
+	return 0;
+}
+
+static int ds5_sensor_init(struct i2c_client *c, struct ds5 *state,
+		struct ds5_sensor *sensor, const struct v4l2_subdev_ops *ops,
+		const char *name)
+{
+	struct v4l2_subdev *sd = &sensor->sd;
+	struct media_entity *entity = &sensor->sd.entity;
+	struct media_pad *pad = &sensor->pad;
+	dev_t *dev_num = &state->client->dev.devt;
+
+	dev_info(sd->dev, "%s(): %p %s %p %p", __func__, c, c->name, state, state->client);
+
+	struct d4xx_pdata *dpdata = c->dev.platform_data;
+	v4l2_i2c_subdev_init(sd, c, ops);
+	sd->owner = THIS_MODULE;
+	sd->internal_ops = &ds5_sensor_internal_ops;
+	sd->grp_id = *dev_num;
+	v4l2_set_subdevdata(sd, state);
+	snprintf(sd->name, sizeof(sd->name), "D4XX %s %c", name, dpdata->suffix);
+
+	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	pad->flags = MEDIA_PAD_FL_SOURCE;
+	entity->obj_type = MEDIA_ENTITY_TYPE_V4L2_SUBDEV;
+	entity->function = MEDIA_ENT_F_CAM_SENSOR;
+	return media_entity_pads_init(entity, 1, pad);
+}
+
+static int ds5_sensor_register(struct ds5 *state, struct ds5_sensor *sensor)
+{
+	struct v4l2_subdev *sd = &sensor->sd;
+	struct media_entity *entity = &sensor->sd.entity;
+	int ret;
+
+	// FIXME: is async needed?
+	ret = v4l2_device_register_subdev(state->mux.sd.subdev.v4l2_dev, sd);
+	if (ret < 0) {
+		dev_err(sd->dev, "%s(): %d: %d\n", __func__, __LINE__, ret);
+		return ret;
+	}
+
+	ret = media_create_pad_link(entity, 0, &state->mux.sd.subdev.entity, sensor->mux_pad,
+				       MEDIA_LNK_FL_IMMUTABLE | MEDIA_LNK_FL_ENABLED);
+	if (ret < 0) {
+		dev_err(sd->dev, "%s(): %d: %d\n", __func__, __LINE__, ret);
+		goto e_sd;
+	}
+
+	dev_info(sd->dev, "%s(): 0 -> %d\n", __func__, sensor->mux_pad);
+
+	return 0;
+
+e_sd:
+	v4l2_device_unregister_subdev(sd);
+
+	return ret;
+}
+
+static void ds5_sensor_remove(struct ds5_sensor *sensor)
+{
+	v4l2_device_unregister_subdev(&sensor->sd);
+// FIXME: test rmmod, unbind, init failures to make sure the entity is always freed
+	media_entity_cleanup(&sensor->sd.entity);
+}
+
+static int ds5_depth_init(struct i2c_client *c, struct ds5 *state)
+{
+	/* Which mux pad we're connecting to */
+	state->depth.sensor.mux_pad = DS5_MUX_PAD_DEPTH_A;
+	return ds5_sensor_init(c, state, &state->depth.sensor,
+			       &ds5_depth_subdev_ops, "depth");
+}
+
+static int ds5_motion_t_init(struct i2c_client *c, struct ds5 *state)
+{
+	state->motion_t.sensor.mux_pad = DS5_MUX_PAD_MOTION_T_A;
+	return ds5_sensor_init(c, state, &state->motion_t.sensor,
+			       &ds5_motion_t_subdev_ops, "motion detection");
+}
+
+static int ds5_rgb_init(struct i2c_client *c, struct ds5 *state)
+{
+	state->rgb.sensor.mux_pad = DS5_MUX_PAD_RGB_A;
+	return ds5_sensor_init(c, state, &state->rgb.sensor,
+			       &ds5_rgb_subdev_ops, "rgb");
+}
+
+static int ds5_imu_init(struct i2c_client *c, struct ds5 *state)
+{
+	state->imu.sensor.mux_pad = DS5_MUX_PAD_IMU;
+	return ds5_sensor_init(c, state, &state->imu.sensor,
+			       &ds5_imu_subdev_ops, "imu");
+}
+
+/* No locking needed */
+static int ds5_mux_enum_mbus_code(struct v4l2_subdev *sd,
+				     struct v4l2_subdev_state *v4l2_state,
+				  struct v4l2_subdev_mbus_code_enum *mce)
+{
+	struct ds5 *state = container_of(sd, struct ds5, mux.sd.subdev);
+	struct v4l2_subdev_mbus_code_enum tmp = *mce;
+	struct v4l2_subdev *remote_sd;
+	int ret;
+
+	dev_info(&state->client->dev, "%s(): %s \n", __func__, sd->name);
+	switch (mce->pad) {
+	case DS5_MUX_PAD_MOTION_T_A:
+		remote_sd = &state->motion_t.sensor.sd;
+		break;
+	case DS5_MUX_PAD_DEPTH_A:
+		remote_sd = &state->depth.sensor.sd;
+		break;
+	case DS5_MUX_PAD_RGB_A:
+		remote_sd = &state->rgb.sensor.sd;
+		break;
+	case DS5_MUX_PAD_IMU:
+		remote_sd = &state->imu.sensor.sd;
+		break;
+	case DS5_MUX_PAD_EXTERNAL:
+		if (mce->index >= state->motion_t.sensor.n_formats +
+		    state->depth.sensor.n_formats)
+			return -EINVAL;
+
+		/*
+		 * First list Left node / Motion Tracker formats, then depth.
+		 * This should also help because D16 doesn't have a direct
+		 * analog in MIPI CSI-2.
+		 */
+		if (mce->index < state->motion_t.sensor.n_formats) {
+			remote_sd = &state->motion_t.sensor.sd;
+		} else {
+			tmp.index = mce->index - state->motion_t.sensor.n_formats;
+			remote_sd = &state->depth.sensor.sd;
+		}
+
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	tmp.pad = 0;
+	if (state->is_rgb)
+		remote_sd = &state->rgb.sensor.sd;
+	if (state->is_depth)
+		remote_sd = &state->depth.sensor.sd;
+	if (state->is_y8)
+		remote_sd = &state->motion_t.sensor.sd;
+	if (state->is_imu)
+		remote_sd = &state->imu.sensor.sd;
+
+	/* Locks internally */
+	ret = ds5_sensor_enum_mbus_code(remote_sd, v4l2_state, &tmp);
+	if (!ret)
+		mce->code = tmp.code;
+
+	return ret;
+}
+
+/* No locking needed */
+static int ds5_mux_enum_frame_size(struct v4l2_subdev *sd,
+				     struct v4l2_subdev_state *v4l2_state,
+				   struct v4l2_subdev_frame_size_enum *fse)
+{
+	struct ds5 *state = container_of(sd, struct ds5, mux.sd.subdev);
+	struct v4l2_subdev_frame_size_enum tmp = *fse;
+	struct v4l2_subdev *remote_sd;
+	u32 pad = fse->pad;
+	int ret;
+
+	tmp.pad = 0;
+
+	if (state->is_depth)
+		pad = DS5_MUX_PAD_DEPTH_A;
+	if (state->is_y8)
+		pad = DS5_MUX_PAD_MOTION_T_A;
+	if (state->is_rgb)
+		pad = DS5_MUX_PAD_RGB_A;
+	if (state->is_imu)
+		pad = DS5_MUX_PAD_IMU;
+
+	switch (pad) {
+	case DS5_MUX_PAD_MOTION_T_A:
+		remote_sd = &state->motion_t.sensor.sd;
+		break;
+	case DS5_MUX_PAD_DEPTH_A:
+		remote_sd = &state->depth.sensor.sd;
+		break;
+	case DS5_MUX_PAD_RGB_A:
+		remote_sd = &state->rgb.sensor.sd;
+		break;
+	case DS5_MUX_PAD_IMU:
+		remote_sd = &state->imu.sensor.sd;
+		break;
+	case DS5_MUX_PAD_EXTERNAL:
+		/*
+		 * Assume, that different sensors don't support the same formats
+		 * Try the Depth sensor first, then the Motion Tracker
+		 */
+		remote_sd = &state->depth.sensor.sd;
+		ret = ds5_sensor_enum_frame_size(remote_sd, NULL, &tmp);
+		if (!ret) {
+			*fse = tmp;
+			fse->pad = pad;
+			return 0;
+		}
+
+		remote_sd = &state->motion_t.sensor.sd;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* Locks internally */
+	ret = ds5_sensor_enum_frame_size(remote_sd, NULL, &tmp);
+	if (!ret) {
+		*fse = tmp;
+		fse->pad = pad;
+	}
+
+	return ret;
+}
+
+/* No locking needed */
+static int ds5_mux_enum_frame_interval(struct v4l2_subdev *sd,
+				     struct v4l2_subdev_state *v4l2_state,
+				       struct v4l2_subdev_frame_interval_enum *fie)
+{
+	struct ds5 *state = container_of(sd, struct ds5, mux.sd.subdev);
+	struct v4l2_subdev_frame_interval_enum tmp = *fie;
+	struct v4l2_subdev *remote_sd;
+	u32 pad = fie->pad;
+	int ret;
+
+	tmp.pad = 0;
+
+	dev_err(state->depth.sensor.sd.dev, "%s(): pad %d code %x width %d height %d\n", __func__,
+				pad, tmp.code, tmp.width, tmp.height);
+
+	if (state->is_depth)
+		pad = DS5_MUX_PAD_DEPTH_A;
+	if (state->is_y8)
+		pad = DS5_MUX_PAD_MOTION_T_A;
+	if (state->is_rgb)
+		pad = DS5_MUX_PAD_RGB_A;
+	if (state->is_imu)
+		pad = DS5_MUX_PAD_IMU;
+
+	switch (pad) {
+	case DS5_MUX_PAD_MOTION_T_A:
+		remote_sd = &state->motion_t.sensor.sd;
+		break;
+	case DS5_MUX_PAD_DEPTH_A:
+		remote_sd = &state->depth.sensor.sd;
+		break;
+	case DS5_MUX_PAD_RGB_A:
+		remote_sd = &state->rgb.sensor.sd;
+		break;
+	case DS5_MUX_PAD_IMU:
+		remote_sd = &state->imu.sensor.sd;
+		break;
+	case DS5_MUX_PAD_EXTERNAL:
+		/* Similar to ds5_mux_enum_frame_size() above */
+		if (state->is_rgb)
+			remote_sd = &state->rgb.sensor.sd;
+		else
+			remote_sd = &state->motion_t.sensor.sd;
+		ret = ds5_sensor_enum_frame_interval(remote_sd, NULL, &tmp);
+		if (!ret) {
+			*fie = tmp;
+			fie->pad = pad;
+			return 0;
+		}
+
+		remote_sd = &state->motion_t.sensor.sd;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* Locks internally */
+	ret = ds5_sensor_enum_frame_interval(remote_sd, NULL, &tmp);
+	if (!ret) {
+		*fie = tmp;
+		fie->pad = pad;
+	}
+
+	return ret;
+}
+
+/* No locking needed */
+static int ds5_mux_set_fmt(struct v4l2_subdev *sd,
+		struct v4l2_subdev_state *v4l2_state,
+		struct v4l2_subdev_format *fmt)
+{
+	struct ds5 *state = container_of(sd, struct ds5, mux.sd.subdev);
+	struct v4l2_mbus_framefmt *ffmt;
+	u32 pad = fmt->pad;
+	int ret = 0;
+	int substream;
+	dev_info(sd->dev, "%s(): pad: %d, %d: %ux%u\n", __func__, pad, fmt->format.code,
+		 fmt->format.width, fmt->format.height);
+
+	switch (pad) {
+	case DS5_MUX_PAD_DEPTH_A:
+	case DS5_MUX_PAD_MOTION_T_A:
+	case DS5_MUX_PAD_RGB_A:
+		ffmt = &ds5_ffmts[pad];
+		break;
+	case DS5_MUX_PAD_EXTERNAL:
+		ffmt = &ds5_ffmts[pad];
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+		ffmt->width = fmt->format.width;
+		ffmt->height = fmt->format.height;
+		ffmt->code = fmt->format.code;
+	}
+	fmt->format = *ffmt;
+
+	substream = pad_to_substream[fmt->pad];
+	if (substream != -1) {
+		set_sub_stream_fmt(substream, ffmt->code);
+		set_sub_stream_h(substream, ffmt->height);
+		set_sub_stream_w(substream, ffmt->width);
+		set_sub_stream_dt(substream, mbus_code_to_mipi(ffmt->code));
+	}
+
+	return ret;
+}
+
+/* No locking needed */
+static int ds5_mux_get_fmt(struct v4l2_subdev *sd,
+				     struct v4l2_subdev_state *v4l2_state,
+			   struct v4l2_subdev_format *fmt)
+{
+	struct ds5 *state = container_of(sd, struct ds5, mux.sd.subdev);
+	u32 pad = fmt->pad;
+	int ret = 0;
+
+	dev_info(sd->dev, "%s(): %u %p\n", __func__, pad, state->mux.last_set);
+
+	switch (pad) {
+	case DS5_MUX_PAD_DEPTH_A:
+	case DS5_MUX_PAD_MOTION_T_A:
+	case DS5_MUX_PAD_RGB_A:
+		fmt->format = ds5_ffmts[pad];
+		break;
+	case DS5_MUX_PAD_EXTERNAL:
+	fmt->format = ds5_ffmts[pad];
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	dev_info(sd->dev, "%s(): pad:%u size:%d-%d, code:%d field:%d, color:%d\n", __func__, fmt->pad,
+		fmt->format.width, fmt->format.height, fmt->format.code, fmt->format.field, fmt->format.colorspace);
+	return ret;
+}
+
+/* Video ops */
+static int ds5_mux_g_frame_interval(struct v4l2_subdev *sd,
+				    struct v4l2_subdev_frame_interval *fi)
+{
+	struct ds5 *state = container_of(sd, struct ds5, mux.sd.subdev);
+	struct ds5_sensor *sensor = NULL;
+
+	if (NULL == sd || NULL == fi)
+		return -EINVAL;
+
+	sensor = state->mux.last_set;
+
+	fi->interval.numerator = 1;
+	fi->interval.denominator = sensor->config.framerate;
+
+	dev_info(sd->dev, "%s(): %s %u\n", __func__, sd->name,
+		 fi->interval.denominator);
+
+	return 0;
+}
+
+static u16 __ds5_probe_framerate(const struct ds5_resolution *res, u16 target)
+{
+	int i;
+	u16 framerate;
+
+	for (i = 0; i < res->n_framerates; i++) {
+		framerate = res->framerates[i];
+		if (target <= framerate)
+			return framerate;
+	}
+
+	return res->framerates[res->n_framerates - 1];
+}
+
+static int ds5_mux_s_frame_interval(struct v4l2_subdev *sd,
+				    struct v4l2_subdev_frame_interval *fi)
+{
+	struct ds5 *state = container_of(sd, struct ds5, mux.sd.subdev);
+	struct ds5_sensor *sensor = NULL;
+	u16 framerate = 1;
+
+	if (NULL == sd || NULL == fi || fi->interval.numerator == 0)
+		return -EINVAL;
+
+	sensor = state->mux.last_set;
+
+	framerate = fi->interval.denominator / fi->interval.numerator;
+	framerate = __ds5_probe_framerate(sensor->config.resolution, framerate);
+	sensor->config.framerate = framerate;
+	fi->interval.numerator = 1;
+	fi->interval.denominator = framerate;
+
+	dev_info(sd->dev, "%s(): %s %u\n", __func__, sd->name, framerate);
+
+	return 0;
+}
+
+static int ds5_mux_s_stream(struct v4l2_subdev *sd, int on)
+{
+	struct ds5 *state = container_of(sd, struct ds5, mux.sd.subdev);
+	u16 streaming_depth, streaming_rgb, streaming_y8, rate, depth_status, rgb_status, y8_status, s_stream;
+	int ret = 0;
+	u16 streaming, status;
+	u16 config_status_base, stream_status_base, stream_id;
+	unsigned int i = 0;
+
+	dev_info(&state->client->dev, "%s(): %s on = %d\n", __func__, state->mux.last_set->sd.name, on);
+
+	state->mux.last_set->streaming = on;
+
+	//if (on)
+	//	ret = ds5_configure(state);
+
+	// TODO: remove, workaround for FW crash in start
+	msleep_range(100);
+
+	if (!on) {
+		ds5_read(state, 0x1004, &streaming_depth);
+		ds5_read(state, 0x4800, &depth_status);
+		ds5_read(state, 0x4802, &rgb_status);
+
+		msleep_range(100);
+		ret = ds5_write(state, DS5_START_STOP_STREAM,
+				DS5_STREAM_STOP | DS5_STREAM_DEPTH);
+		msleep_range(100);
+		ret = ds5_write(state, DS5_START_STOP_STREAM,
+				DS5_STREAM_STOP | DS5_STREAM_RGB);
+		msleep_range(100);
+		ret = ds5_write(state, DS5_START_STOP_STREAM,
+				DS5_STREAM_STOP | DS5_STREAM_IMU);
+		msleep_range(100);
+		ret = ds5_write(state, DS5_START_STOP_STREAM,
+				DS5_STREAM_STOP | DS5_STREAM_IR);
+
+		return 0;
+	}
+#if 1 /* depth */
+	msleep_range(100);
+	if (on)
+		ret = ds5_configure_depth(state);
+	msleep_range(100);
+	ds5_write(state, 0x1000,  on ? 0x200 : 0x100);
+
+		config_status_base = DS5_DEPTH_CONFIG_STATUS;
+		stream_status_base = DS5_DEPTH_STREAM_STATUS;
+		// check streaming status from FW
+		for (i = 0; i < DS5_START_MAX_COUNT; i++) {
+			ds5_read(state, stream_status_base, &streaming);
+			ds5_read(state, config_status_base, &status);
+			if ((status & DS5_STATUS_STREAMING) &&
+			    streaming == DS5_STREAM_STREAMING)
+				break;
+
+			msleep_range(DS5_START_POLL_TIME);
+		}
+
+		if (i == DS5_START_MAX_COUNT) {
+			dev_err(&state->client->dev,
+				"start depth streaming failed, exit on timeout\n");
+		}
+#endif
+
+#if 1 /* RGB */
+	msleep_range(100);
+	if (on)
+		ret = ds5_configure_rgb(state);
+	msleep_range(100);
+	/* RGB */
+	ds5_write(state, 0x1000,  on ? 0x201 : 0x101);
+
+		config_status_base = DS5_RGB_CONFIG_STATUS;
+		stream_status_base = DS5_RGB_STREAM_STATUS;
+		// check streaming status from FW
+		for (i = 0; i < DS5_START_MAX_COUNT; i++) {
+			ds5_read(state, stream_status_base, &streaming);
+			ds5_read(state, config_status_base, &status);
+			if ((status & DS5_STATUS_STREAMING) &&
+			    streaming == DS5_STREAM_STREAMING)
+				break;
+
+			msleep_range(DS5_START_POLL_TIME);
+		}
+
+		if (i == DS5_START_MAX_COUNT) {
+			dev_err(&state->client->dev,
+				"start RGB streaming failed, exit on timeout\n");
+		}
+#endif
+	//ds5_write(state, 0x1000,  on ? 0x201 : 0x102);
+
+	/* IR */
+	msleep_range(100);
+	if (on)
+		ret = ds5_configure_ir(state);
+	msleep_range(100);
+	ds5_write(state, 0x1000,  on ? 0x204 : 0x104);
+
+		config_status_base = DS5_IR_CONFIG_STATUS;
+		stream_status_base = DS5_IR_STREAM_STATUS;
+		stream_id = DS5_STREAM_IR;
+
+		// check streaming status from FW
+		for (i = 0; i < DS5_START_MAX_COUNT; i++) {
+			ds5_read(state, stream_status_base, &streaming);
+			ds5_read(state, config_status_base, &status);
+			if ((status & DS5_STATUS_STREAMING) &&
+			    streaming == DS5_STREAM_STREAMING)
+				break;
+
+			msleep_range(DS5_START_POLL_TIME);
+		}
+
+		if (DS5_START_MAX_COUNT == i) {
+			dev_err(&state->client->dev,
+				"start imu streaming failed, exit on timeout\n");
+		}
+
+	u16 err_status;
+	// TODO: this read seems to cause FW crash, need to debug
+	//ds5_read(state, 0x402, &rate);
+	rate = 0;
+	u16 tmp;
+
+	ds5_read(state, 0x401a, &err_status);
+	ds5_read(state, 0x1004, &streaming_depth);
+	ds5_read(state, 0x1008, &streaming_rgb);
+	ds5_read(state, 0x1010, &streaming_y8);
+	ds5_read(state, 0x4800, &depth_status);
+	ds5_read(state, 0x4802, &rgb_status);
+	ds5_read(state, 0x4808, &y8_status);
+	ds5_read(state, 0x4002, &tmp);
+	ds5_read(state, 0x4022, &tmp);
+	ds5_read(state, 0x4082, &tmp);
+
+	//ds5_write(state, 0x4002,  0x100 );
+	//ds5_write(state, 0x4022,  0x0 );
+	//ds5_read(state, 0x4002, &tmp);
+	//ds5_read(state, 0x4022, &tmp);
+	msleep_range(DS5_START_POLL_TIME*50);
+
+	dev_info(&state->client->dev, "%s(): streaming %x-%x-%x depth status 0x%04x, rgb status 0x%04x, rate %u\n", __func__,
+		 streaming_depth, streaming_rgb, streaming_y8, depth_status, rgb_status, rate);
+
+	return ret;
+}
+
+static int ds5_mux_s_stream_vc(struct ds5 *state, u16 vc_id, u16 on)
+{
+	u16 streaming_depth, streaming_rgb, streaming_y8, rate, depth_status, rgb_status, y8_status, s_stream;
+	int ret = 0;
+	u16 streaming, status;
+	u16 config_status_base, stream_status_base, stream_id;
+	unsigned int i = 0;
+
+	dev_info(&state->client->dev, "%s(): %s on = %d\n", __func__, state->mux.last_set->sd.name, on);
+
+	state->mux.last_set->streaming = on;
+
+	//if (on)
+	//	ret = ds5_configure(state);
+
+	// TODO: remove, workaround for FW crash in start
+	msleep_range(100);
+
+	if (!on) {
+		ds5_read(state, 0x1004, &streaming_depth);
+		ds5_read(state, 0x4800, &depth_status);
+		ds5_read(state, 0x4802, &rgb_status);
+
+		if ((vc_id == DS5_MUX_PAD_DEPTH_A - 1) || (vc_id == DS5_MUX_PAD_DEPTH_B - 1)) {
+		msleep_range(100);
+		ret = ds5_write(state, DS5_START_STOP_STREAM,
+				DS5_STREAM_STOP | DS5_STREAM_DEPTH);
+}
+		if ((vc_id == DS5_MUX_PAD_RGB_A - 1) || (vc_id == DS5_MUX_PAD_RGB_B - 1)) {
+		msleep_range(100);
+		ret = ds5_write(state, DS5_START_STOP_STREAM,
+				DS5_STREAM_STOP | DS5_STREAM_RGB);
+}
+/*
+		msleep_range(100);
+		ret = ds5_write(state, DS5_START_STOP_STREAM,
+				DS5_STREAM_STOP | DS5_STREAM_IMU);
+*/
+		if ((vc_id == DS5_MUX_PAD_MOTION_T_A - 1) || (vc_id == DS5_MUX_PAD_MOTION_T_B - 1)) {
+		msleep_range(100);
+		ret = ds5_write(state, DS5_START_STOP_STREAM,
+				DS5_STREAM_STOP | DS5_STREAM_IR);
+}
+		return 0;
+	}
+#if 1 /* depth */
+	msleep_range(100);
+	if ((on) && ((vc_id == DS5_MUX_PAD_DEPTH_A - 1) || (vc_id == DS5_MUX_PAD_DEPTH_B - 1))) {
+		ret = ds5_configure_depth(state);
+	msleep_range(100);
+	ds5_write(state, 0x1000,  on ? 0x200 : 0x100);
+
+		config_status_base = DS5_DEPTH_CONFIG_STATUS;
+		stream_status_base = DS5_DEPTH_STREAM_STATUS;
+		// check streaming status from FW
+		for (i = 0; i < DS5_START_MAX_COUNT; i++) {
+			ds5_read(state, stream_status_base, &streaming);
+			ds5_read(state, config_status_base, &status);
+			if ((status & DS5_STATUS_STREAMING) &&
+			    streaming == DS5_STREAM_STREAMING)
+				break;
+
+			msleep_range(DS5_START_POLL_TIME);
+		}
+
+		if (DS5_START_MAX_COUNT == i) {
+			dev_err(&state->client->dev,
+				"start depth streaming failed, exit on timeout\n");
+		}
+	}
+#endif
+
+#if 1 /* RGB */
+	if ((on) && ((vc_id == DS5_MUX_PAD_RGB_A - 1) || (vc_id == DS5_MUX_PAD_RGB_B - 1))) {
+	msleep_range(100);
+	if (on)
+		ret = ds5_configure_rgb(state);
+	msleep_range(100);
+	/* RGB */
+	ds5_write(state, 0x1000,  on ? 0x201 : 0x101);
+
+		config_status_base = DS5_RGB_CONFIG_STATUS;
+		stream_status_base = DS5_RGB_STREAM_STATUS;
+		// check streaming status from FW
+		for (i = 0; i < DS5_START_MAX_COUNT; i++) {
+			ds5_read(state, stream_status_base, &streaming);
+			ds5_read(state, config_status_base, &status);
+			if ((status & DS5_STATUS_STREAMING) &&
+			    streaming == DS5_STREAM_STREAMING)
+				break;
+
+			msleep_range(DS5_START_POLL_TIME);
+		}
+
+		if (DS5_START_MAX_COUNT == i) {
+			dev_err(&state->client->dev,
+				"start RGB streaming failed, exit on timeout\n");
+		}
+}
+#endif
+	//ds5_write(state, 0x1000,  on ? 0x201 : 0x102);
+
+	if ((on) && ((vc_id == DS5_MUX_PAD_MOTION_T_A - 1) || (vc_id == DS5_MUX_PAD_MOTION_T_B - 1))) {
+	msleep_range(100);
+	if (on)
+		ret = ds5_configure_ir(state);
+	msleep_range(100);
+	ds5_write(state, 0x1000,  on ? 0x204 : 0x104);
+
+		config_status_base = DS5_IR_CONFIG_STATUS;
+		stream_status_base = DS5_IR_STREAM_STATUS;
+		stream_id = DS5_STREAM_IR;
+
+		// check streaming status from FW
+		for (i = 0; i < DS5_START_MAX_COUNT; i++) {
+			ds5_read(state, stream_status_base, &streaming);
+			ds5_read(state, config_status_base, &status);
+			if ((status & DS5_STATUS_STREAMING) &&
+			    streaming == DS5_STREAM_STREAMING)
+				break;
+
+			msleep_range(DS5_START_POLL_TIME);
+		}
+
+		if (DS5_START_MAX_COUNT == i) {
+			dev_err(&state->client->dev,
+				"start imu streaming failed, exit on timeout\n");
+		}
+}
+
+	    u16 err_status;
+	// TODO: this read seems to cause FW crash, need to debug
+	//ds5_read(state, 0x402, &rate);
+	rate = 0;
+    u16 tmp;
+    ds5_read(state, 0x401a, &err_status);
+
+	ds5_read(state, 0x1004, &streaming_depth);
+	ds5_read(state, 0x1008, &streaming_rgb);
+	ds5_read(state, 0x1010, &streaming_y8);
+	ds5_read(state, 0x4800, &depth_status);
+	ds5_read(state, 0x4802, &rgb_status);
+	ds5_read(state, 0x4808, &y8_status);
+    ds5_read(state, 0x4002, &tmp);
+    ds5_read(state, 0x4022, &tmp);
+    ds5_read(state, 0x4082, &tmp);
+
+    //ds5_write(state, 0x4002,  0x100 );
+   //ds5_write(state, 0x4022,  0x0 );
+    //ds5_read(state, 0x4002, &tmp);
+    //ds5_read(state, 0x4022, &tmp);
+	msleep_range(DS5_START_POLL_TIME*50);
+
+	dev_info(&state->client->dev, "%s(): streaming %x-%x-%x depth status 0x%04x, rgb status 0x%04x, rate %u\n", __func__,
+		 streaming_depth, streaming_rgb, streaming_y8, depth_status, rgb_status, rate);
+
+	return 0;
+	return ret;
+}
+
+//static int ds5_set_power(struct ds5 *state, int on)
+//{
+//	int ret = 0;
+//
+//	mutex_lock(&state->lock);
+//
+//	if (state->power != !on) {
+//		mutex_unlock(&state->lock);
+//		return 0;
+//	}
+//
+////	gpio_set_value_cansleep(state->pwdn_gpio, on);
+//
+//	dev_info(&state->client->dev, "%s(): power %d\n", __func__, on);
+//
+//	usleep_range(100, 200);
+//
+//	if (on) {
+//		state->power = true;
+//	} else {
+//		state->power = false;
+//	}
+//
+//	mutex_unlock(&state->lock);
+//
+//	/* TODO: Restore controls when powering on */
+//	//if (on)
+//	//	ret = v4l2_ctrl_handler_setup(&state->ctrls.handler);
+//
+//	return ret;
+//}
+
+/* Core ops */
+/*static int ds5_mux_set_power(struct v4l2_subdev *sd, int on)
+{
+	struct ds5 *state = container_of(sd, struct ds5, mux.sd.subdev);
+
+	return ds5_set_power(state, on);
+}*/
+
+#define DS5_N_STREAMS 4
+#define DS5_PAD_SOURCE 0
+
+static int ds5_mux_get_frame_desc(struct v4l2_subdev *sd,
+	unsigned int pad, struct v4l2_mbus_frame_desc *desc)
+{
+	unsigned int i;
+
+	desc->num_entries = V4L2_FRAME_DESC_ENTRY_MAX;
+
+	for (i = 0; i < desc->num_entries; i++) {
+		desc->entry[i].flags = 0;
+		desc->entry[i].pixelcode = MEDIA_BUS_FMT_FIXED;
+		desc->entry[i].length = 0;
+		if (i == desc->num_entries - 1) {
+			desc->entry[i].pixelcode = 0x12;
+			desc->entry[i].length = 68;
+		}
+	}
+	return 0;
+}
+
+static const struct v4l2_subdev_pad_ops ds5_mux_pad_ops = {
+	.enum_mbus_code		= ds5_mux_enum_mbus_code,
+	.enum_frame_size	= ds5_mux_enum_frame_size,
+	.enum_frame_interval	= ds5_mux_enum_frame_interval,
+	.get_fmt		= ds5_mux_get_fmt,
+	.set_fmt		= ds5_mux_set_fmt,
+	.get_frame_desc		= ds5_mux_get_frame_desc,
+};
+
+static const struct v4l2_subdev_core_ops ds5_mux_core_ops = {
+	//.s_power = ds5_mux_set_power,
+	.log_status = v4l2_ctrl_subdev_log_status,
+};
+
+static const struct v4l2_subdev_video_ops ds5_mux_video_ops = {
+	.g_frame_interval	= ds5_mux_g_frame_interval,
+	.s_frame_interval	= ds5_mux_s_frame_interval,
+	.s_stream		= ds5_mux_s_stream,
+};
+
+static const struct v4l2_subdev_ops ds5_mux_subdev_ops = {
+	.core = &ds5_mux_core_ops,
+	.pad = &ds5_mux_pad_ops,
+	.video = &ds5_mux_video_ops,
+};
+
+static int ds5_des_register(struct ds5 *state, struct ds5_des *des)
+{
+	struct v4l2_subdev *sd = &des->sd;
+	struct media_entity *entity = &des->sd.entity;
+	int ret;
+
+	// FIXME: is async needed?
+	ret = v4l2_device_register_subdev(state->mux.sd.subdev.v4l2_dev, sd);
+	if (ret < 0) {
+		dev_err(sd->dev, "%s(): %d: %d\n", __func__, __LINE__, ret);
+		return ret;
+	}
+
+	//ret = media_create_pad_link(entity, 1, &state->mux.sd.subdev.entity, des->mux_pad,
+	//			       MEDIA_LNK_FL_IMMUTABLE | MEDIA_LNK_FL_ENABLED);
+	//if (ret < 0) {
+	//	dev_err(sd->dev, "%s(): %d: %d\n", __func__, __LINE__, ret);
+	//	goto e_sd;
+       // }
+
+	dev_info(sd->dev, "%s(): 0 -> %d\n", __func__, des->mux_pad);
+
+	return 0;
+
+e_sd:
+	v4l2_device_unregister_subdev(sd);
+
+	return ret;
+}
+
+static int ds5_mux_registered(struct v4l2_subdev *sd)
+{
+	struct ds5 *state = v4l2_get_subdevdata(sd);
+	int ret;
+
+	ret = ds5_sensor_register(state, &state->depth.sensor);
+	if (ret < 0)
+		return ret;
+
+	ret = ds5_sensor_register(state, &state->motion_t.sensor);
+	if (ret < 0)
+		goto e_depth;
+
+	ret = ds5_sensor_register(state, &state->rgb.sensor);
+	if (ret < 0)
+		goto e_rgb;
+
+	ret = ds5_sensor_register(state, &state->imu.sensor);
+	if (ret < 0)
+		goto e_imu;
+
+	return 0;
+
+e_imu:
+	v4l2_device_unregister_subdev(&state->rgb.sensor.sd);
+
+e_rgb:
+	v4l2_device_unregister_subdev(&state->motion_t.sensor.sd);
+
+e_depth:
+	v4l2_device_unregister_subdev(&state->depth.sensor.sd);
+
+	return ret;
+}
+
+static void ds5_mux_unregistered(struct v4l2_subdev *sd)
+{
+	struct ds5 *state = v4l2_get_subdevdata(sd);
+
+	ds5_sensor_remove(&state->imu.sensor);
+	ds5_sensor_remove(&state->rgb.sensor);
+	ds5_sensor_remove(&state->motion_t.sensor);
+	ds5_sensor_remove(&state->depth.sensor);
+}
+
+static const struct v4l2_subdev_internal_ops ds5_mux_internal_ops = {
+	.open = ds5_mux_open,
+	.close = ds5_mux_close,
+	.registered = ds5_mux_registered,
+	.unregistered = ds5_mux_unregistered,
+};
+
+static int ds5_mux_register(struct i2c_client *c, struct ds5 *state)
+{
+	return v4l2_async_register_subdev(&state->mux.sd.subdev);
+}
+
+static int ds5_hw_init(struct i2c_client *c, struct ds5 *state)
+{
+	struct v4l2_subdev *sd = &state->mux.sd.subdev;
+	u16 mipi_status, n_lanes, phy, drate_min, drate_max;
+	int ret;
+
+	dev_info(NULL, "%s(), line %d\n", __func__, __LINE__);
+
+	ret = ds5_read(state, DS5_MIPI_SUPPORT_LINES, &n_lanes);
+	if (!ret)
+		ret = ds5_read(state, DS5_MIPI_SUPPORT_PHY, &phy);
+
+	if (!ret)
+		ret = ds5_read(state, DS5_MIPI_DATARATE_MIN, &drate_min);
+
+	if (!ret)
+		ret = ds5_read(state, DS5_MIPI_DATARATE_MAX, &drate_max);
+
+	if (!ret)
+		dev_info(sd->dev, "%s(): %d: %u lanes, phy %x, data rate %u-%u\n",
+			 __func__, __LINE__, n_lanes, phy, drate_min, drate_max);
+
+	dev_info(NULL, "%s(), line %d, set 2 lanes\n", __func__, __LINE__);
+	// mjchen: 4 or 2 ?
+	n_lanes = 2;
+
+	ret = ds5_write(state, DS5_MIPI_LANE_NUMS, n_lanes - 1);
+	if (!ret)
+		ret = ds5_write(state, DS5_MIPI_LANE_DATARATE, MIPI_LANE_RATE);
+
+	ret = ds5_read(state, DS5_MIPI_CONF_STATUS, &mipi_status);
+
+	dev_info(sd->dev, "%s(): %d status %x\n", __func__, __LINE__,
+		 mipi_status);
+//	dev_info(sd->dev, "%s(): %d phandle %x node %s status %x\n", __func__, __LINE__,
+//		 c->dev.of_node->phandle, c->dev.of_node->full_name, mipi_status);
+
+	return ret;
+}
+static int ds5_des_init(struct i2c_client *c, struct ds5 *state)
+{
+	struct v4l2_subdev *sd = &state->max9296.des.sd;
+	struct media_entity *entity = &state->max9296.des.sd.entity;
+	struct media_pad *pads = state->max9296.des.pads;
+	dev_t *dev_num = &state->client->dev.devt;
+
+	state->max9296.des.mux_pad = DS5_MUX_PAD_EXTERNAL;
+
+	dev_info(sd->dev, "%s(): %p %s %p %p", __func__, c, c->name, state, state->client);
+
+	v4l2_i2c_subdev_init(sd, c, &ds5_mux_subdev_ops);
+	sd->owner = THIS_MODULE;
+	sd->internal_ops = &ds5_sensor_internal_ops;
+	sd->grp_id = *dev_num;
+	v4l2_set_subdevdata(sd, state);
+	snprintf(sd->name, sizeof(sd->name), "D4XX %s %d-%04x",
+		"max9296", i2c_adapter_id(c->adapter), 0x48);
+
+	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	pads[0].flags = MEDIA_PAD_FL_SOURCE;
+	pads[1].flags = MEDIA_PAD_FL_SINK;
+	entity->obj_type = MEDIA_ENTITY_TYPE_V4L2_SUBDEV;
+	entity->function = MEDIA_ENT_F_CAM_SENSOR;
+	return media_entity_pads_init(entity, 2, pads);
+}
+static int ds5_mux_init(struct i2c_client *c, struct ds5 *state)
+{
+	struct v4l2_subdev *sd = &state->mux.sd.subdev;
+	struct media_entity *entity = &state->mux.sd.subdev.entity;
+	struct media_pad *pads = state->mux.pads, *pad;
+	unsigned int i;
+	int ret;
+
+	struct d4xx_pdata *dpdata = c->dev.platform_data;
+	v4l2_i2c_subdev_init(sd, c, &ds5_mux_subdev_ops);
+	sd->owner = THIS_MODULE;
+	sd->internal_ops = &ds5_mux_internal_ops;
+	v4l2_set_subdevdata(sd, state);
+	snprintf(sd->name, sizeof(sd->name), "DS5 mux %c", dpdata->suffix);
+
+	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	entity->obj_type = MEDIA_ENTITY_TYPE_V4L2_SUBDEV;
+	entity->function = MEDIA_ENT_F_CAM_SENSOR;
+
+	pads[0].flags = MEDIA_PAD_FL_SOURCE;
+	for (i = 1, pad = pads + 1; i < ARRAY_SIZE(state->mux.pads); i++, pad++)
+		pad->flags = MEDIA_PAD_FL_SINK;
+
+	ret = media_entity_pads_init(entity, ARRAY_SIZE(state->mux.pads), pads);
+	if (ret < 0)
+		return ret;
+
+	// FIXME: this is most likely different for depth and motion detection
+	ret = ds5_ctrl_init(state);
+	if (ret < 0)
+		return ret;
+
+	state->mux.last_set = &state->motion_t.sensor;
+
+#ifdef CONFIG_TEGRA_CAMERA_PLATFORM
+	state->mux.sd.dev = &c->dev;
+	ret = camera_common_initialize(&state->mux.sd, "d4xx");
+	if (ret) {
+		dev_err(&c->dev, "Failed to initialize d4xx.\n");
+		goto e_ctrl;
+	}
+#endif
+
+	return 0;
+
+#ifdef CONFIG_TEGRA_CAMERA_PLATFORM
+e_ctrl:
+	v4l2_ctrl_handler_free(sd->ctrl_handler);
+#endif
+e_entity:
+	media_entity_cleanup(entity);
+
+	return ret;
+}
+
+#define USE_Y
+
+static int ds5_fixed_configuration(struct i2c_client *client, struct ds5 *state)
+{
+	struct ds5_sensor *sensor;
+	u16 cfg0, cfg0_md, cfg1, cfg1_md, dw, dh, yw, yh, dev_type;
+	int ret;
+
+	ret = ds5_read(state, DS5_DEPTH_STREAM_DT, &cfg0);
+	if (!ret)
+		ret = ds5_read(state, DS5_DEPTH_STREAM_MD, &cfg0_md);
+	if (!ret)
+		ret = ds5_read(state, DS5_DEPTH_RES_WIDTH, &dw);
+	if (!ret)
+		ret = ds5_read(state, DS5_DEPTH_RES_HEIGHT, &dh);
+	if (!ret)
+		ret = ds5_read(state, DS5_IR_STREAM_DT, &cfg1);
+	if (!ret)
+		ret = ds5_read(state, DS5_IR_STREAM_MD, &cfg1_md);
+	if (!ret)
+		ret = ds5_read(state, DS5_IR_RES_WIDTH, &yw);
+	if (!ret)
+		ret = ds5_read(state, DS5_IR_RES_HEIGHT, &yh);
+	if (!ret)
+		ret = ds5_read(state, DS5_DEVICE_TYPE, &dev_type);
+	if (ret < 0)
+		return ret;
+
+	dev_info(&client->dev, "%s(): cfg0 %x %ux%u cfg0_md %x %ux%u\n", __func__,
+		 cfg0, dw, dh, cfg0_md, yw, yh);
+
+	dev_info(&client->dev, "%s(): cfg1 %x %ux%u cfg1_md %x %ux%u\n", __func__,
+		 cfg1, dw, dh, cfg1_md, yw, yh);
+
+	sensor = &state->depth.sensor;
+	switch (dev_type) {
+	case DS5_DEVICE_TYPE_D43X:
+	case DS5_DEVICE_TYPE_D45X:
+		sensor->formats = ds5_depth_formats_d43x;
+		break;
+	case DS5_DEVICE_TYPE_D46X:
+		sensor->formats = ds5_depth_formats_d46x;
+		break;
+	default:
+		sensor->formats = ds5_depth_formats_d46x;
+	}
+	sensor->n_formats = 1;
+	sensor->mux_pad = DS5_MUX_PAD_DEPTH_A;
+
+	sensor = &state->motion_t.sensor;
+	sensor->formats = state->variant->formats;
+	sensor->n_formats = state->variant->n_formats;
+	sensor->mux_pad = DS5_MUX_PAD_MOTION_T_A;
+	switch (dev_type) {
+	// case DS5_DEVICE_TYPE_D45X:
+	case DS5_DEVICE_TYPE_D43X: {
+		unsigned int *calib_resolutions_size =
+			(unsigned int *)&(sensor->formats[ARRAY_SIZE(ds5_y_formats_ds5u)-1].n_resolutions);
+		const struct ds5_resolution **calib_resolutions = (const struct ds5_resolution **)
+					    &(sensor->formats[ARRAY_SIZE(ds5_y_formats_ds5u)-1].resolutions);
+		*calib_resolutions_size = ARRAY_SIZE(d43x_calibration_sizes),
+		*calib_resolutions = d43x_calibration_sizes;
+		break;
+	}
+	case DS5_DEVICE_TYPE_D46X: {
+		dev_info(&client->dev, "%s(): DS5_DEVICE_TYPE_D46X for calib\n", __func__);
+		/*unsigned int *calib_resolutions_size =
+		 *	(unsigned int *)&(sensor->formats[ARRAY_SIZE(ds5_y_formats_ds5u)-1].n_resolutions);
+		 *const struct ds5_resolution **calib_resolutions = (const struct ds5_resolution**)
+		 *			    &(sensor->formats[ARRAY_SIZE(ds5_y_formats_ds5u)-1].resolutions);
+		 **calib_resolutions_size = ARRAY_SIZE(d46x_calibration_sizes),
+		 **calib_resolutions = d46x_calibration_sizes;
+		 */
+		break;
+	}
+	}
+
+	dev_info(NULL, "%s(), line %d\n", __func__, __LINE__);
+	sensor = &state->rgb.sensor;
+	switch (dev_type) {
+	case DS5_DEVICE_TYPE_D43X:
+	case DS5_DEVICE_TYPE_D46X:
+		sensor->formats = &ds5_onsemi_rgb_format;
+		sensor->n_formats = DS5_ONSEMI_RGB_N_FORMATS;
+		break;
+	case DS5_DEVICE_TYPE_D45X:
+		sensor->formats = &ds5_rlt_rgb_format;
+		sensor->n_formats = DS5_RLT_RGB_N_FORMATS;
+		break;
+	default:
+		sensor->formats = &ds5_onsemi_rgb_format;
+		sensor->n_formats = DS5_ONSEMI_RGB_N_FORMATS;
+	}
+	sensor->mux_pad = DS5_MUX_PAD_RGB_A;
+
+	/*sensor->formats = &ds5_onsemi_rgb_format;
+	 *sensor->n_formats = DS5_RGB_N_FORMATS;
+	 *sensor->mux_pad = DS5_MUX_PAD_RGB;
+	 */
+
+	sensor = &state->imu.sensor;
+	sensor->formats = ds5_imu_formats;
+	sensor->n_formats = 1;
+	sensor->mux_pad = DS5_MUX_PAD_IMU;
+
+	dev_info(NULL, "%s(), line %d\n", __func__, __LINE__);
+	/* Development: set a configuration during probing */
+	if ((cfg0 & 0xff00) == 0x1800) {
+		/* MIPI CSI-2 YUV420 isn't supported by V4L, reconfigure to Y8 */
+		struct v4l2_subdev_format fmt = {
+			.which = V4L2_SUBDEV_FORMAT_ACTIVE,
+			.pad = 0,
+			/* Use template to fill in .field, .colorspace etc. */
+			.format = ds5_mbus_framefmt_template,
+		};
+
+//#undef USE_Y
+		/* Override .width, .height, .code */
+		fmt.format.width = yw;
+		fmt.format.height = yh;
+		fmt.format.code = MEDIA_BUS_FMT_UYVY8_2X8;
+
+		//state->mux.sd.mode_prop_idx = 0;
+		state->motion_t.sensor.streaming = true;
+		state->depth.sensor.streaming = true;
+		ret = __ds5_sensor_set_fmt(state, &state->motion_t.sensor, NULL, &fmt);
+		if (ret < 0)
+			return ret;
+	}
+
+	dev_info(NULL, "%s(), line %d\n", __func__, __LINE__);
+	return 0;
+}
+
+static int ds5_parse_cam(struct i2c_client *client, struct ds5 *state)
+{
+	dev_info(NULL, "%s(), line %d\n", __func__, __LINE__);
+	int ret;
+
+	ret = ds5_fixed_configuration(client, state);
+	if (ret < 0)
+		return ret;
+
+	dev_info(NULL, "%s(), line %d\n", __func__, __LINE__);
+	ds5_sensor_format_init(&state->depth.sensor);
+	dev_info(NULL, "%s(), line %d\n", __func__, __LINE__);
+	ds5_sensor_format_init(&state->motion_t.sensor);
+	dev_info(NULL, "%s(), line %d\n", __func__, __LINE__);
+	ds5_sensor_format_init(&state->rgb.sensor);
+	dev_info(NULL, "%s(), line %d\n", __func__, __LINE__);
+	ds5_sensor_format_init(&state->imu.sensor);
+	dev_info(NULL, "%s(), line %d\n", __func__, __LINE__);
+
+	return 0;
+}
+
+static void ds5_mux_remove(struct ds5 *state)
+{
+#ifdef CONFIG_TEGRA_CAMERA_PLATFORM
+	camera_common_cleanup(&state->mux.sd);
+#endif
+	v4l2_async_unregister_subdev(&state->mux.sd.subdev);
+	v4l2_ctrl_handler_free(state->mux.sd.subdev.ctrl_handler);
+	media_entity_cleanup(&state->mux.sd.subdev.entity);
+}
+
+static const struct regmap_config ds5_regmap_config = {
+	.reg_bits = 16,
+	.val_bits = 8,
+	.reg_format_endian = REGMAP_ENDIAN_NATIVE,
+	.val_format_endian = REGMAP_ENDIAN_NATIVE,
+};
+
+static int ds5_dfu_wait_for_status(struct ds5 *state)
+{
+	int i, ret = 0;
+	u16 status;
+
+	for (i = 0; i < DS5_START_MAX_COUNT; i++) {
+		ds5_read(state, 0x5000, &status);
+		if (status == 0x0001 || status == 0x0002) {
+			dev_err(&state->client->dev, "%s(): dfu failed status(0x%4x)\n", __func__, status);
+			ret = -EREMOTEIO;
+			break;
+		}
+		if (!status)
+			break;
+		msleep_range(DS5_START_POLL_TIME);
+	}
+
+	return ret;
+};
+
+static int ds5_dfu_switch_to_dfu(struct ds5 *state)
+{
+	int ret;
+	int i = DS5_START_MAX_COUNT;
+	u16 status;
+
+	ds5_raw_write_with_check(state, 0x4900, &cmd_switch_to_dfu, sizeof(cmd_switch_to_dfu));
+	ds5_write_with_check(state, 0x490c, 0x01); /* execute cmd */
+	/*Wait for DFU fw to boot*/
+	do {
+		msleep_range(DS5_START_POLL_TIME*10);
+		ret = ds5_read(state, 0x5000, &status);
+	} while (ret && i--);
+	return ret;
+};
+
+static int ds5_dfu_wait_for_get_dfu_status(struct ds5 *state, enum dfu_fw_state exp_state)
+{
+	int ret = 0;
+	u16 status, dfu_state_len = 0x0000;
+	unsigned char dfu_asw_buf[DFU_WAIT_RET_LEN];
+	unsigned int dfu_wr_wait_msec = 0;
+
+	do {
+		ds5_write_with_check(state, 0x5008, 0x0003); // Get Write state
+		do {
+			ds5_read_with_check(state, 0x5000, &status);
+			if (status == 0x0001) {
+				dev_err(&state->client->dev,
+						"%s(): Write status error I2C_STATUS_ERROR(1)\n", __func__);
+				return -EINVAL;
+			} else
+				if (status == 0x0002 && dfu_wr_wait_msec)
+					msleep_range(dfu_wr_wait_msec);
+					/*
+					 *dev_notice(&state->client->dev,
+					 *	"%s():waiting (%x)\n", __func__, dfu_wr_wait_msec);
+					 */
+
+		} while (status);
+
+		ds5_read_with_check(state, 0x5004, &dfu_state_len);
+		if (dfu_state_len != DFU_WAIT_RET_LEN) {
+			dev_err(&state->client->dev, "%s(): Wrong answer len (%d)\n", __func__, dfu_state_len);
+			return -EINVAL;
+		}
+		ds5_raw_read_with_check(state, 0x4e00, &dfu_asw_buf, DFU_WAIT_RET_LEN);
+		if (dfu_asw_buf[0]) {
+			dev_err(&state->client->dev, "%s(): Wrong dfu_status (%d)\n", __func__, dfu_asw_buf[0]);
+			return -EINVAL;
+		}
+		dfu_wr_wait_msec = (((unsigned int)dfu_asw_buf[3]) << 16)
+			| (((unsigned int)dfu_asw_buf[2]) << 8) | dfu_asw_buf[1];
+	} while (dfu_asw_buf[4] == dfuDNBUSY && exp_state == dfuDNLOAD_IDLE);
+
+	if  (dfu_asw_buf[4] != exp_state) {
+		dev_notice(&state->client->dev,
+				"%s(): Wrong dfu_state (%d) while expected(%d)\n", __func__, dfu_asw_buf[4], exp_state);
+		ret =  -EINVAL;
+	}
+	return ret;
+};
+
+static int ds5_dfu_get_dev_info(struct ds5 *state, struct __fw_status *buf)
+{
+	int ret;
+	u16 len;
+
+	ret = ds5_write(state, 0x5008, 0x0002); //Upload DFU cmd
+	if (!ret)
+		ret = ds5_dfu_wait_for_status(state);
+	if (!ret)
+		ds5_read_with_check(state, 0x5004, &len);
+	/*Sanity check*/
+	if (len == sizeof(struct __fw_status)) {
+		ds5_raw_read_with_check(state, 0x4e00, buf, len);
+	} else {
+		dev_err(&state->client->dev, "%s(): Wrong state size (%d)\n", __func__, len);
+		ret = -EINVAL;
+	}
+	return ret;
+};
+
+static int ds5_dfu_detach(struct ds5 *state)
+{
+	int ret;
+	struct __fw_status buf;
+
+	ds5_write_with_check(state, 0x500c, 0x00);
+	ret = ds5_dfu_wait_for_get_dfu_status(state, dfuIDLE);
+	if (!ret)
+		ret = ds5_dfu_get_dev_info(state, &buf);
+	dev_notice(&state->client->dev, "%s():DFU ver (0x%x) received\n", __func__, buf.DFU_version);
+	dev_notice(&state->client->dev, "%s():FW last version (0x%x) received\n", __func__, buf.FW_lastVersion);
+	dev_notice(&state->client->dev, "%s():FW status (%s)\n", __func__, buf.DFU_isLocked ? "locked" : "unlocked");
+	return ret;
+};
+
+/* When a process reads from our device, this gets called. */
+static ssize_t device_read(struct file *flip, char __user *buffer, size_t len, loff_t *offset)
+{
+	struct ds5 *state = flip->private_data;
+	u16 fw_ver;
+	char msg[20];
+	int ret = 0;
+
+	if (mutex_lock_interruptible(&state->lock))
+		return -ERESTARTSYS;
+	ret = ds5_read(state, DS5_FW_VERSION, &fw_ver);
+	if (ret < 0)
+		goto e_dfu_read_failed;
+	sprintf(msg, "DFU info: \tver: (0x%x)\n", fw_ver);
+	if (copy_to_user(buffer, msg, strlen(msg)))
+		ret = -EFAULT;
+	else {
+		state->dfu_dev.msg_write_once = ~state->dfu_dev.msg_write_once;
+		ret = strlen(msg) & state->dfu_dev.msg_write_once;
+	}
+
+e_dfu_read_failed:
+	mutex_unlock(&state->lock);
+	return ret;
+};
+
+static ssize_t device_write(struct file *flip, const char __user *buffer, size_t len, loff_t *offset)
+{
+	struct ds5 *state = flip->private_data;
+	int ret = 0;
+
+	if (mutex_lock_interruptible(&state->lock))
+		return -ERESTARTSYS;
+	switch (state->dfu_dev.dfu_state_flag) {
+
+	case DS5_DFU_OPEN:
+		ret = ds5_dfu_switch_to_dfu(state);
+		if (ret < 0) {
+			dev_err(&state->client->dev, "%s(): Switch to dfu failed (%d)\n", __func__, ret);
+			goto dfu_write_error;
+		}
+		/*no break - proceed to recovery*/
+	case DS5_DFU_RECOVERY:
+		ret = ds5_dfu_detach(state);
+		if (ret < 0) {
+			dev_err(&state->client->dev, "%s(): Detach failed (%d)\n", __func__, ret);
+			goto dfu_write_error;
+		}
+		state->dfu_dev.dfu_state_flag = DS5_DFU_IN_PROGRESS;
+		state->dfu_dev.init_v4l_f = 1;
+
+		/*no break - proceed to download*/
+	case DS5_DFU_IN_PROGRESS: {
+		unsigned int dfu_full_blocks = len / DFU_BLOCK_SIZE;
+		unsigned int dfu_part_blocks = len % DFU_BLOCK_SIZE;
+
+		while (dfu_full_blocks--) {
+			if (copy_from_user(state->dfu_dev.dfu_msg, buffer, DFU_BLOCK_SIZE)) {
+				ret = -EFAULT;
+				goto dfu_write_error;
+			}
+			ret = ds5_raw_write(state, 0x4a00, state->dfu_dev.dfu_msg, DFU_BLOCK_SIZE);
+			if (ret < 0)
+				goto dfu_write_error;
+			ret = ds5_dfu_wait_for_get_dfu_status(state, dfuDNLOAD_IDLE);
+			if (ret < 0)
+				goto dfu_write_error;
+			buffer += DFU_BLOCK_SIZE;
+		}
+		if (copy_from_user(state->dfu_dev.dfu_msg, buffer, dfu_part_blocks)) {
+			ret = -EFAULT;
+			goto dfu_write_error;
+		}
+		if (dfu_part_blocks) {
+			ret = ds5_raw_write(state, 0x4a00, state->dfu_dev.dfu_msg, dfu_part_blocks);
+			if (!ret)
+				ret = ds5_dfu_wait_for_get_dfu_status(state, dfuDNLOAD_IDLE);
+			if (!ret)
+				ret = ds5_write(state, 0x4a04, 0x00); /*Download complete */
+			if (!ret)
+				ret = ds5_dfu_wait_for_get_dfu_status(state, dfuMANIFEST);
+			if (ret < 0)
+				goto dfu_write_error;
+			state->dfu_dev.dfu_state_flag = DS5_DFU_DONE;
+		}
+		dev_notice(&state->client->dev, "%s(): DFU block (%d) bytes written\n", __func__, (int)len);
+		break;
+	}
+	default:
+		dev_err(&state->client->dev, "%s(): Wrong state (%d)\n", __func__, state->dfu_dev.dfu_state_flag);
+		ret =  -EINVAL;
+		goto dfu_write_error;
+
+	};
+	mutex_unlock(&state->lock);
+	return len;
+
+dfu_write_error:
+	//TODO: Reset device here
+	state->dfu_dev.dfu_state_flag = DS5_DFU_ERROR;
+	mutex_unlock(&state->lock);
+	return ret;
+};
+
+static int device_open(struct inode *inode, struct file *file)
+{
+	struct ds5 *state = container_of(inode->i_cdev, struct ds5, dfu_dev.ds5_cdev);
+
+	try_module_get(THIS_MODULE);
+	if (state->dfu_dev.device_open_count)
+		return -EBUSY;
+	state->dfu_dev.device_open_count++;
+	if (state->dfu_dev.dfu_state_flag  != DS5_DFU_RECOVERY)
+		state->dfu_dev.dfu_state_flag = DS5_DFU_OPEN;
+	state->dfu_dev.dfu_msg = devm_kzalloc(&state->client->dev, DFU_BLOCK_SIZE, GFP_KERNEL);
+	file->private_data = state;
+	return 0;
+};
+
+static int ds5_v4l_init(struct i2c_client *c, struct ds5 *state)
+{
+	u16 fw_ver;
+	u16 fw_build;
+	int ret;
+
+	ret = ds5_parse_cam(c, state);
+	if (ret < 0)
+		return ret;
+
+	ds5_read_with_check(state, DS5_FW_VERSION, &fw_ver);
+	ds5_read_with_check(state, DS5_FW_BUILD, &fw_build);
+	state->fw_version = fw_ver;
+	state->fw_build = fw_build;
+
+	ret = ds5_depth_init(c, state);
+	if (ret < 0)
+		return ret;
+
+	ret = ds5_motion_t_init(c, state);
+	if (ret < 0)
+		goto e_depth;
+
+	ret = ds5_rgb_init(c, state);
+	if (ret < 0)
+		goto e_motion_t;
+
+	ret = ds5_imu_init(c, state);
+	if (ret < 0)
+		goto e_rgb;
+
+	ret = ds5_mux_init(c, state);
+	if (ret < 0)
+		goto e_imu;
+
+	ret = ds5_hw_init(c, state);
+	if (ret < 0)
+		goto e_mux;
+
+	ret = ds5_mux_register(c, state);
+	if (ret < 0)
+		goto e_mux;
+
+	return 0;
+e_mux:
+	ds5_mux_remove(state);
+e_imu:
+	media_entity_cleanup(&state->imu.sensor.sd.entity);
+e_rgb:
+	media_entity_cleanup(&state->rgb.sensor.sd.entity);
+e_motion_t:
+	media_entity_cleanup(&state->motion_t.sensor.sd.entity);
+e_depth:
+	media_entity_cleanup(&state->depth.sensor.sd.entity);
+	return ret;
+}
+
+static int device_release(struct inode *inode, struct file *file)
+{
+	struct ds5 *state = container_of(inode->i_cdev, struct ds5, dfu_dev.ds5_cdev);
+
+	state->dfu_dev.device_open_count--;
+	if (state->dfu_dev.dfu_state_flag  != DS5_DFU_RECOVERY)
+		state->dfu_dev.dfu_state_flag = DS5_DFU_IDLE;
+	if (state->dfu_dev.dfu_state_flag == DS5_DFU_DONE && state->dfu_dev.init_v4l_f)
+		ds5_v4l_init(state->client, state);
+	state->dfu_dev.init_v4l_f = 0;
+	if (state->dfu_dev.dfu_msg)
+		devm_kfree(&state->client->dev, state->dfu_dev.dfu_msg);
+	state->dfu_dev.dfu_msg = NULL;
+	module_put(THIS_MODULE);
+	return 0;
+};
+
+static const struct file_operations ds5_device_file_ops = {
+	.owner  = THIS_MODULE,
+	.read = &device_read,
+	.write = &device_write,
+	.open = &device_open,
+	.release = &device_release
+};
+
+struct class *g_ds5_class;
+atomic_t primary_chardev = ATOMIC_INIT(0);
+
+static int ds5_chrdev_init(struct i2c_client *c, struct ds5 *state)
+{
+	struct cdev *ds5_cdev = &state->dfu_dev.ds5_cdev;
+	struct class **ds5_class = &state->dfu_dev.ds5_class;
+	struct device *chr_dev;
+	char dev_name[sizeof(DS5_DRIVER_NAME_DFU) + 5];
+	dev_t *dev_num = &c->dev.devt;
+	int ret;
+
+	dev_info(&c->dev, "%s()\n", __func__);
+	/* Request the kernel for N_MINOR devices */
+	ret = alloc_chrdev_region(dev_num, 0, 1, DS5_DRIVER_NAME_DFU);
+	if (ret < 0)
+		return ret;
+
+	if (!atomic_cmpxchg(&primary_chardev, 0, MAJOR(*dev_num))) {
+		dev_info(&c->dev, "%s(): <Major, Minor>: <%d, %d>\n", __func__, MAJOR(*dev_num), MINOR(*dev_num));
+		/* Create a class : appears at /sys/class */
+		*ds5_class = class_create(THIS_MODULE, DS5_DRIVER_NAME_CLASS);
+		if (IS_ERR(*ds5_class)) {
+			dev_err(&c->dev, "Could not create class device\n");
+			unregister_chrdev_region(0, 1);
+			ret = PTR_ERR(*ds5_class);
+			return ret;
+		}
+		g_ds5_class = *ds5_class;
+	} else
+		*ds5_class = g_ds5_class;
+	/* Associate the cdev with a set of file_operations */
+	cdev_init(ds5_cdev, &ds5_device_file_ops);
+	/* Build up the current device number. To be used further */
+	*dev_num = MKDEV(MAJOR(*dev_num), MINOR(*dev_num));
+	/* Create a device node for this device. Look, the class is
+	 * being used here. The same class is associated with N_MINOR
+	 * devices. Once the function returns, device nodes will be
+	 * created as /dev/my_dev0, /dev/my_dev1,... You can also view
+	 * the devices under /sys/class/my_driver_class.
+	 */
+	sprintf(dev_name, "%s%d", DS5_DRIVER_NAME_DFU, MAJOR(*dev_num));
+	chr_dev = device_create(*ds5_class, NULL, *dev_num, NULL, dev_name);
+	if (IS_ERR(chr_dev)) {
+		ret = PTR_ERR(chr_dev);
+		dev_err(&c->dev, "Could not create device\n");
+		class_destroy(*ds5_class);
+		unregister_chrdev_region(0, 1);
+		return ret;
+	}
+	/* Now make the device live for the users to access */
+	cdev_add(ds5_cdev, *dev_num, 1);
+	return 0;
+};
+
+static int ds5_chrdev_remove(struct ds5 *state)
+{
+	struct class **ds5_class = &state->dfu_dev.ds5_class;
+	dev_t *dev_num = &state->client->dev.devt;
+
+	dev_info(&state->client->dev, "%s()\n", __func__);
+	unregister_chrdev_region(*dev_num, 1);
+	device_destroy(*ds5_class, *dev_num);
+	if (atomic_cmpxchg(&primary_chardev, MAJOR(*dev_num), 0) == MAJOR(*dev_num))
+		class_destroy(*ds5_class);
+	return 0;
+}
+
+static void ds5_substream_init(void)
+{
+	int i;
+
+	/*
+	 * 0, vc 0, depth
+	 * 1, vc 0, meta data
+	 * 2, vc 1, RGB
+	 * 3, vc 1, meta data
+	 * 4, vc 2, IR
+	 */
+	set_sub_stream_fmt(0, MEDIA_BUS_FMT_UYVY8_1X16);
+	set_sub_stream_h(0, 480);
+	set_sub_stream_w(0, 640);
+	set_sub_stream_dt(0, mbus_code_to_mipi(MEDIA_BUS_FMT_UYVY8_1X16));
+	set_sub_stream_vc_id(0, 0);
+
+	set_sub_stream_fmt(1, MEDIA_BUS_FMT_SGRBG8_1X8);
+	set_sub_stream_h(1, 1);
+	set_sub_stream_w(1, 68);
+	set_sub_stream_dt(1, MIPI_CSI2_TYPE_EMBEDDED8);
+	set_sub_stream_vc_id(1, 0);
+
+	set_sub_stream_fmt(2, MEDIA_BUS_FMT_UYVY8_1X16);
+	set_sub_stream_h(2, 640);
+	set_sub_stream_w(2, 480);
+	set_sub_stream_dt(2, mbus_code_to_mipi(MEDIA_BUS_FMT_UYVY8_1X16));
+	set_sub_stream_vc_id(2, 1);
+
+	set_sub_stream_fmt(3, MEDIA_BUS_FMT_SGRBG8_1X8);
+	set_sub_stream_h(3, 1);
+	set_sub_stream_w(3, 68);
+	set_sub_stream_dt(3, MIPI_CSI2_TYPE_EMBEDDED8);
+	set_sub_stream_vc_id(3, 1);
+
+	set_sub_stream_fmt(4, MEDIA_BUS_FMT_UYVY8_1X16);
+	set_sub_stream_h(4, 640);
+	set_sub_stream_w(4, 480);
+	set_sub_stream_dt(4, mbus_code_to_mipi(MEDIA_BUS_FMT_UYVY8_1X16));
+	set_sub_stream_vc_id(4, 2);
+
+	for (i = 0; i < DS5_MUX_PAD_COUNT; i++)
+		pad_to_substream[i] = -1;
+
+	pad_to_substream[DS5_MUX_PAD_DEPTH_A] = 0;
+	pad_to_substream[DS5_MUX_PAD_RGB_A] = 2;
+	pad_to_substream[DS5_MUX_PAD_MOTION_T_A] = 4;
+}
+
+static int ds5_probe(struct i2c_client *c, const struct i2c_device_id *id)
+{
+	struct ds5 *state = devm_kzalloc(&c->dev, sizeof(*state), GFP_KERNEL);
+	u16 rec_state;
+	int ret, err = 0;
+	const char *str;
+
+	if (!state)
+		return -ENOMEM;
+
+	mutex_init(&state->lock);
+
+	dev_warn(&c->dev, "Driver addr 0x%x\n", c->addr);
+
+	state->client = c;
+	dev_warn(&c->dev, "Driver data NAEL %d\n", (int)id->driver_data);
+	state->variant = ds5_variants + id->driver_data;
+
+	state->vcc = devm_regulator_get(&c->dev, "vcc");
+	if (IS_ERR(state->vcc)) {
+		ret = PTR_ERR(state->vcc);
+		dev_warn(&c->dev, "failed %d to get vcc regulator\n", ret);
+		return ret;
+	}
+
+	if (state->vcc) {
+		ret = regulator_enable(state->vcc);
+		if (ret < 0) {
+			dev_warn(&c->dev, "failed %d to enable the vcc regulator\n", ret);
+			return ret;
+		}
+	}
+	state->regmap = devm_regmap_init_i2c(c, &ds5_regmap_config);
+	if (IS_ERR(state->regmap)) {
+		ret = PTR_ERR(state->regmap);
+		dev_err(&c->dev, "regmap init failed: %d\n", ret);
+		goto e_regulator;
+	}
+	ret = ds5_chrdev_init(c, state);
+	if (ret < 0)
+		goto e_regulator;
+	// The default addr is 0x10 for sensors on the same i2c.
+	// map their addr// to 0x12/0x14 by configuring 9259/9296.
+	if (c->addr == D4XX_I2C_ADDRESS_1) {
+		c->addr = 0x48;
+		ds5_write_8(state, 0x1000, 0x23);
+
+		c->addr = 0x4a;
+		ds5_write_8(state, 0x1000, 0x23);
+		ds5_write_8(state, 0x1000, 0x22);
+		msleep_range(1000);
+
+		c->addr = 0x40;
+		ds5_write_8(state, 0x0000, 0x88);
+		c->addr = 0x44;
+		msleep_range(1000);
+
+		ds5_write_8(state, 0x4400, 0x28);
+		ds5_write_8(state, 0x4500, 0x20);
+
+		c->addr = 0x48;
+		ds5_write_8(state, 0x1000, 0x22);
+		msleep_range(1000);
+
+		c->addr = 0x40;
+		ds5_write_8(state, 0x0000, 0x84);
+		c->addr = 0x42;
+		ds5_write_8(state, 0x4400, 0x24);
+		ds5_write_8(state, 0x4500, 0x20);
+
+		c->addr = 0x12;
+	}
+	ret = ds5_read(state, 0x5020, &rec_state);
+	if (ret < 0) {
+		dev_err(&c->dev, "%s(): cannot communicate with D4XX: %d\n", __func__, ret);
+		goto e_chardev;
+	}
+
+	if (rec_state == 0x201) {
+		dev_info(&c->dev, "%s(): D4XX recovery state\n", __func__);
+		state->dfu_dev.dfu_state_flag = DS5_DFU_RECOVERY;
+		return 0;
+	}
+
+	err = of_property_read_string(c->dev.of_node, "cam-type",
+			&str);
+	if (!err && !strncmp(str, "RGB", strlen("RGB")))
+		state->is_rgb = 1;
+
+	ret = ds5_v4l_init(c, state);
+	dev_info(NULL, "%s(), line %d\n", __func__, __LINE__);
+	if (ret < 0)
+		goto e_chardev;
+	/* Override I2C drvdata */
+	/* i2c_set_clientdata(c, state); */
+
+/*	regulators? clocks?
+ *	devm_regulator_bulk_get(&c->dev, DS5_N_SUPPLIES, state->supplies);
+ *	state->clock = devm_clk_get(&c->dev, DS5_CLK_NAME);
+ *	if (IS_ERR(state->clock)) {
+ *		ret = -EPROBE_DEFER;
+ *		goto err;
+ *	}
+ */
+	ds5_substream_init();
+	return 0;
+
+e_chardev:
+	ds5_chrdev_remove(state);
+e_regulator:
+	if (state->vcc)
+		regulator_disable(state->vcc);
+	return ret;
+}
+
+static int ds5_remove(struct i2c_client *c)
+{
+	struct ds5 *state = container_of(i2c_get_clientdata(c), struct ds5, mux.sd.subdev);
+
+	dev_info(&c->dev, "%s()\n", __func__);
+	if (state->vcc)
+		regulator_disable(state->vcc);
+	/* gpio_free(state->pwdn_gpio); */
+	ds5_chrdev_remove(state);
+	if (state->dfu_dev.dfu_state_flag != DS5_DFU_RECOVERY)
+		ds5_mux_remove(state);
+	return 0;
+}
+
+static const struct i2c_device_id ds5_id[] = {
+	{ DS5_DRIVER_NAME, DS5_DS5U },
+	{ DS5_DRIVER_NAME_ASR, DS5_ASR },
+	{ DS5_DRIVER_NAME_AWG, DS5_AWG },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, ds5_id);
+
+static struct i2c_driver ds5_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = DS5_DRIVER_NAME
+	},
+	.probe		= ds5_probe,
+	.remove		= ds5_remove,
+	.id_table	= ds5_id,
+};
+
+module_i2c_driver(ds5_i2c_driver);
+
+MODULE_DESCRIPTION("Intel D4XX camera driver");
+MODULE_AUTHOR("Guennadi Liakhovetski (guennadi.liakhovetski@intel.com)");
+MODULE_LICENSE("GPL v2");
+MODULE_VERSION("0.16.1.0");
diff --git a/drivers/media/i2c/hm11b1.c b/drivers/media/i2c/hm11b1.c
new file mode 100644
index 000000000000..7d71817eeed4
--- /dev/null
+++ b/drivers/media/i2c/hm11b1.c
@@ -0,0 +1,1185 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (c) 2020-2022 Intel Corporation.
+
+#include <asm/unaligned.h>
+#include <linux/acpi.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/version.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-fwnode.h>
+#if IS_ENABLED(CONFIG_INTEL_SKL_INT3472)
+#include <linux/clk.h>
+#include <linux/gpio/consumer.h>
+#elif IS_ENABLED(CONFIG_POWER_CTRL_LOGIC)
+#include "power_ctrl_logic.h"
+#endif
+
+#define HM11B1_LINK_FREQ_384MHZ		384000000ULL
+#define HM11B1_SCLK			72000000LL
+#define HM11B1_MCLK			19200000
+#define HM11B1_DATA_LANES		1
+#define HM11B1_RGB_DEPTH		10
+
+#define HM11B1_REG_CHIP_ID		0x0000
+#define HM11B1_CHIP_ID			0x11B1
+
+#define HM11B1_REG_MODE_SELECT		0x0100
+#define HM11B1_MODE_STANDBY		0x00
+#define HM11B1_MODE_STREAMING		0x01
+
+/* vertical-timings from sensor */
+#define HM11B1_REG_VTS			0x3402
+#define HM11B1_VTS_DEF			0x037d
+#define HM11B1_VTS_MIN			0x0346
+#define HM11B1_VTS_MAX			0xffff
+
+/* horizontal-timings from sensor */
+#define HM11B1_REG_HTS			0x3404
+
+/* Exposure controls from sensor */
+#define HM11B1_REG_EXPOSURE		0x0202
+#define HM11B1_EXPOSURE_MIN		2
+#define HM11B1_EXPOSURE_MAX_MARGIN	2
+#define HM11B1_EXPOSURE_STEP		1
+
+/* Analog gain controls from sensor */
+#define HM11B1_REG_ANALOG_GAIN		0x0205
+#define HM11B1_REG_ANALOG_GAIN_IR	0x0206
+#define HM11B1_ANAL_GAIN_MIN		0
+#define HM11B1_ANAL_GAIN_MAX		0xFF
+#define HM11B1_ANAL_GAIN_STEP		1
+
+/* Digital gain controls from sensor */
+#define HM11B1_REG_DGTL_GAIN		0x0207
+#define HM11B1_REG_DGTL_GAIN_IR		0x0209
+#define HM11B1_DGTL_GAIN_MIN		0x0
+#define HM11B1_DGTL_GAIN_MAX		0x3FF
+#define HM11B1_DGTL_GAIN_STEP		1
+#define HM11B1_DGTL_GAIN_DEFAULT	0x100
+/* register update control */
+#define HM11B1_REG_COMMAND_UPDATE	0x104
+
+/* Test Pattern Control */
+#define HM11B1_REG_TEST_PATTERN		0x0601
+#define HM11B1_TEST_PATTERN_ENABLE	1
+#define HM11B1_TEST_PATTERN_BAR_SHIFT	1
+
+enum {
+	HM11B1_LINK_FREQ_384MHZ_INDEX,
+};
+
+struct hm11b1_reg {
+	u16 address;
+	u8 val;
+};
+
+struct hm11b1_reg_list {
+	u32 num_of_regs;
+	const struct hm11b1_reg *regs;
+};
+
+struct hm11b1_link_freq_config {
+	const struct hm11b1_reg_list reg_list;
+};
+
+struct hm11b1_mode {
+	/* Frame width in pixels */
+	u32 width;
+
+	/* Frame height in pixels */
+	u32 height;
+
+	/* Horizontal timining size */
+	u32 hts;
+
+	/* Default vertical timining size */
+	u32 vts_def;
+
+	/* Min vertical timining size */
+	u32 vts_min;
+
+	/* Link frequency needed for this resolution */
+	u32 link_freq_index;
+
+	/* Sensor register settings for this resolution */
+	const struct hm11b1_reg_list reg_list;
+};
+
+static const struct hm11b1_reg mipi_data_rate_384mbps[] = {
+};
+
+//RAW 10bit 1292x800_30fps_MIPI 384Mbps/lane
+static const struct hm11b1_reg sensor_1292x800_30fps_setting[] = {
+	{0x0103, 0x00},
+	{0x0102, 0x01},
+	{0x0202, 0x03},
+	{0x0203, 0x7C},
+	{0x0205, 0x20},
+	{0x0207, 0x01},
+	{0x0208, 0x00},
+	{0x0209, 0x01},
+	{0x020A, 0x00},
+	{0x0300, 0x91},
+	{0x0301, 0x0A},
+	{0x0302, 0x02},
+	{0x0303, 0x2E},
+	{0x0304, 0x43},
+	{0x0306, 0x00},
+	{0x0307, 0x00},
+	{0x0340, 0x03},
+	{0x0341, 0x60},
+	{0x0342, 0x05},
+	{0x0343, 0xA0},
+	{0x0344, 0x00},
+	{0x0345, 0x00},
+	{0x0346, 0x03},
+	{0x0347, 0x2F},
+	{0x0350, 0xFF},
+	{0x0351, 0x00},
+	{0x0352, 0x00},
+	{0x0370, 0x00},
+	{0x0371, 0x00},
+	{0x0380, 0x00},
+	{0x0381, 0x00},
+	{0x0382, 0x00},
+	{0x1000, 0xC3},
+	{0x1001, 0xD0},
+	{0x100A, 0x13},
+	{0x2000, 0x00},
+	{0x2061, 0x01},
+	{0x2062, 0x00},
+	{0x2063, 0xC8},
+	{0x2100, 0x03},
+	{0x2101, 0xF0},
+	{0x2102, 0xF0},
+	{0x2103, 0x01},
+	{0x2104, 0x10},
+	{0x2105, 0x10},
+	{0x2106, 0x02},
+	{0x2107, 0x0A},
+	{0x2108, 0x10},
+	{0x2109, 0x15},
+	{0x210A, 0x1A},
+	{0x210B, 0x20},
+	{0x210C, 0x08},
+	{0x210D, 0x0A},
+	{0x210E, 0x0F},
+	{0x210F, 0x12},
+	{0x2110, 0x1C},
+	{0x2111, 0x20},
+	{0x2112, 0x23},
+	{0x2113, 0x2A},
+	{0x2114, 0x30},
+	{0x2115, 0x10},
+	{0x2116, 0x00},
+	{0x2117, 0x01},
+	{0x2118, 0x00},
+	{0x2119, 0x06},
+	{0x211A, 0x00},
+	{0x211B, 0x00},
+	{0x2615, 0x08},
+	{0x2616, 0x00},
+	{0x2700, 0x01},
+	{0x2711, 0x01},
+	{0x272F, 0x01},
+	{0x2800, 0x29},
+	{0x2821, 0xCE},
+	{0x2839, 0x27},
+	{0x283A, 0x01},
+	{0x2842, 0x01},
+	{0x2843, 0x00},
+	{0x3022, 0x11},
+	{0x3024, 0x30},
+	{0x3025, 0x12},
+	{0x3026, 0x00},
+	{0x3027, 0x81},
+	{0x3028, 0x01},
+	{0x3029, 0x00},
+	{0x302A, 0x30},
+	{0x3030, 0x00},
+	{0x3032, 0x00},
+	{0x3035, 0x01},
+	{0x303E, 0x00},
+	{0x3051, 0x00},
+	{0x3082, 0x0E},
+	{0x3084, 0x0D},
+	{0x30A8, 0x03},
+	{0x30C4, 0xA0},
+	{0x30D5, 0xC1},
+	{0x30D8, 0x00},
+	{0x30D9, 0x0D},
+	{0x30DB, 0xC2},
+	{0x30DE, 0x25},
+	{0x30E1, 0xC3},
+	{0x30E4, 0x25},
+	{0x30E7, 0xC4},
+	{0x30EA, 0x25},
+	{0x30ED, 0xC5},
+	{0x30F0, 0x25},
+	{0x30F2, 0x0C},
+	{0x30F3, 0x85},
+	{0x30F6, 0x25},
+	{0x30F8, 0x0C},
+	{0x30F9, 0x05},
+	{0x30FB, 0x40},
+	{0x30FC, 0x25},
+	{0x30FD, 0x54},
+	{0x30FE, 0x0C},
+	{0x3100, 0xC2},
+	{0x3103, 0x00},
+	{0x3104, 0x2B},
+	{0x3106, 0xC3},
+	{0x3109, 0x25},
+	{0x310C, 0xC4},
+	{0x310F, 0x25},
+	{0x3112, 0xC5},
+	{0x3115, 0x25},
+	{0x3117, 0x0C},
+	{0x3118, 0x85},
+	{0x311B, 0x25},
+	{0x311D, 0x0C},
+	{0x311E, 0x05},
+	{0x3121, 0x25},
+	{0x3123, 0x0C},
+	{0x3124, 0x0D},
+	{0x3126, 0x40},
+	{0x3127, 0x25},
+	{0x3128, 0x54},
+	{0x3129, 0x0C},
+	{0x3130, 0x20},
+	{0x3134, 0x60},
+	{0x3135, 0xC2},
+	{0x3139, 0x12},
+	{0x313A, 0x07},
+	{0x313F, 0x52},
+	{0x3140, 0x34},
+	{0x3141, 0x2E},
+	{0x314F, 0x07},
+	{0x3151, 0x47},
+	{0x3153, 0xB0},
+	{0x3154, 0x4A},
+	{0x3155, 0xC0},
+	{0x3157, 0x55},
+	{0x3158, 0x01},
+	{0x3165, 0xFF},
+	{0x316B, 0x12},
+	{0x316E, 0x12},
+	{0x3176, 0x12},
+	{0x3178, 0x01},
+	{0x317C, 0x10},
+	{0x317D, 0x05},
+	{0x317F, 0x07},
+	{0x3182, 0x07},
+	{0x3183, 0x11},
+	{0x3184, 0x88},
+	{0x3186, 0x28},
+	{0x3191, 0x00},
+	{0x3192, 0x20},
+	{0x3400, 0x48},
+	{0x3401, 0x00},
+	{0x3402, 0x06},
+	{0x3403, 0xFA},
+	{0x3404, 0x05},
+	{0x3405, 0x40},
+	{0x3406, 0x00},
+	{0x3407, 0x00},
+	{0x3408, 0x03},
+	{0x3409, 0x2F},
+	{0x340A, 0x00},
+	{0x340B, 0x00},
+	{0x340C, 0x00},
+	{0x340D, 0x00},
+	{0x340E, 0x00},
+	{0x340F, 0x00},
+	{0x3410, 0x00},
+	{0x3411, 0x01},
+	{0x3412, 0x00},
+	{0x3413, 0x03},
+	{0x3414, 0xB0},
+	{0x3415, 0x4A},
+	{0x3416, 0xC0},
+	{0x3418, 0x55},
+	{0x3419, 0x03},
+	{0x341B, 0x7D},
+	{0x341C, 0x00},
+	{0x341F, 0x03},
+	{0x3420, 0x00},
+	{0x3421, 0x02},
+	{0x3422, 0x00},
+	{0x3423, 0x02},
+	{0x3424, 0x01},
+	{0x3425, 0x02},
+	{0x3426, 0x00},
+	{0x3427, 0xA2},
+	{0x3428, 0x01},
+	{0x3429, 0x06},
+	{0x342A, 0xF8},
+	{0x3440, 0x01},
+	{0x3441, 0xBE},
+	{0x3442, 0x02},
+	{0x3443, 0x18},
+	{0x3444, 0x03},
+	{0x3445, 0x0C},
+	{0x3446, 0x06},
+	{0x3447, 0x18},
+	{0x3448, 0x09},
+	{0x3449, 0x24},
+	{0x344A, 0x08},
+	{0x344B, 0x08},
+	{0x345C, 0x00},
+	{0x345D, 0x44},
+	{0x345E, 0x02},
+	{0x345F, 0x43},
+	{0x3460, 0x04},
+	{0x3461, 0x3B},
+	{0x3466, 0xF8},
+	{0x3467, 0x43},
+	{0x347D, 0x02},
+	{0x3483, 0x05},
+	{0x3484, 0x0C},
+	{0x3485, 0x03},
+	{0x3486, 0x20},
+	{0x3487, 0x00},
+	{0x3488, 0x00},
+	{0x3489, 0x00},
+	{0x348A, 0x09},
+	{0x348B, 0x00},
+	{0x348C, 0x00},
+	{0x348D, 0x02},
+	{0x348E, 0x01},
+	{0x348F, 0x40},
+	{0x3490, 0x00},
+	{0x3491, 0xC8},
+	{0x3492, 0x00},
+	{0x3493, 0x02},
+	{0x3494, 0x00},
+	{0x3495, 0x02},
+	{0x3496, 0x02},
+	{0x3497, 0x06},
+	{0x3498, 0x05},
+	{0x3499, 0x04},
+	{0x349A, 0x09},
+	{0x349B, 0x05},
+	{0x349C, 0x17},
+	{0x349D, 0x05},
+	{0x349E, 0x00},
+	{0x349F, 0x00},
+	{0x34A0, 0x00},
+	{0x34A1, 0x00},
+	{0x34A2, 0x08},
+	{0x34A3, 0x08},
+	{0x34A4, 0x00},
+	{0x34A5, 0x0B},
+	{0x34A6, 0x0C},
+	{0x34A7, 0x32},
+	{0x34A8, 0x10},
+	{0x34A9, 0xE0},
+	{0x34AA, 0x52},
+	{0x34AB, 0x00},
+	{0x34AC, 0x60},
+	{0x34AD, 0x2B},
+	{0x34AE, 0x25},
+	{0x34AF, 0x48},
+	{0x34B1, 0x06},
+	{0x34B2, 0xF8},
+	{0x34C3, 0xB0},
+	{0x34C4, 0x4A},
+	{0x34C5, 0xC0},
+	{0x34C7, 0x55},
+	{0x34C8, 0x03},
+	{0x34CB, 0x00},
+	{0x353A, 0x00},
+	{0x355E, 0x48},
+	{0x3572, 0xB0},
+	{0x3573, 0x4A},
+	{0x3574, 0xC0},
+	{0x3576, 0x55},
+	{0x3577, 0x03},
+	{0x357A, 0x00},
+	{0x35DA, 0x00},
+	{0x4003, 0x02},
+	{0x4004, 0x02},
+};
+
+static const char * const hm11b1_test_pattern_menu[] = {
+	"Disabled",
+	"Solid Color",
+	"Color Bar",
+	"Color Bar Blending",
+	"PN11",
+};
+
+static const s64 link_freq_menu_items[] = {
+	HM11B1_LINK_FREQ_384MHZ,
+};
+
+static const struct hm11b1_link_freq_config link_freq_configs[] = {
+	[HM11B1_LINK_FREQ_384MHZ_INDEX] = {
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(mipi_data_rate_384mbps),
+			.regs = mipi_data_rate_384mbps,
+		}
+	},
+};
+
+static const struct hm11b1_mode supported_modes[] = {
+	{
+		.width = 1292,
+		.height = 800,
+		.hts = 1344,
+		.vts_def = HM11B1_VTS_DEF,
+		.vts_min = HM11B1_VTS_MIN,
+		.reg_list = {
+			.num_of_regs =
+				ARRAY_SIZE(sensor_1292x800_30fps_setting),
+			.regs = sensor_1292x800_30fps_setting,
+		},
+		.link_freq_index = HM11B1_LINK_FREQ_384MHZ_INDEX,
+	},
+};
+
+struct hm11b1 {
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_ctrl_handler ctrl_handler;
+
+	/* V4L2 Controls */
+	struct v4l2_ctrl *link_freq;
+	struct v4l2_ctrl *pixel_rate;
+	struct v4l2_ctrl *vblank;
+	struct v4l2_ctrl *hblank;
+	struct v4l2_ctrl *exposure;
+
+	/* Current mode */
+	const struct hm11b1_mode *cur_mode;
+
+	/* To serialize asynchronus callbacks */
+	struct mutex mutex;
+
+	/* i2c client */
+	struct i2c_client *client;
+
+#if IS_ENABLED(CONFIG_INTEL_SKL_INT3472)
+	/* GPIO for reset */
+	struct gpio_desc *reset_gpio;
+	/* GPIO for powerdown */
+	struct gpio_desc *powerdown_gpio;
+	/* GPIO for clock enable */
+	struct gpio_desc *clken_gpio;
+	/* GPIO for privacy LED */
+	struct gpio_desc *pled_gpio;
+#endif
+
+	/* Streaming on/off */
+	bool streaming;
+};
+
+static inline struct hm11b1 *to_hm11b1(struct v4l2_subdev *subdev)
+{
+	return container_of(subdev, struct hm11b1, sd);
+}
+
+static u64 to_pixel_rate(u32 f_index)
+{
+	u64 pixel_rate = link_freq_menu_items[f_index] * 2 * HM11B1_DATA_LANES;
+
+	do_div(pixel_rate, HM11B1_RGB_DEPTH);
+
+	return pixel_rate;
+}
+
+static u64 to_pixels_per_line(u32 hts, u32 f_index)
+{
+	u64 ppl = hts * to_pixel_rate(f_index);
+
+	do_div(ppl, HM11B1_SCLK);
+
+	return ppl;
+}
+
+static void hm11b1_set_power(struct hm11b1 *hm11b1, int on)
+{
+#if IS_ENABLED(CONFIG_INTEL_SKL_INT3472)
+	if (!(hm11b1->reset_gpio && hm11b1->powerdown_gpio))
+		return;
+	gpiod_set_value_cansleep(hm11b1->reset_gpio, on);
+	gpiod_set_value_cansleep(hm11b1->powerdown_gpio, on);
+	gpiod_set_value_cansleep(hm11b1->clken_gpio, on);
+	gpiod_set_value_cansleep(hm11b1->pled_gpio, on);
+	msleep(20);
+#elif IS_ENABLED(CONFIG_POWER_CTRL_LOGIC)
+	power_ctrl_logic_set_power(on);
+#endif
+}
+
+static int hm11b1_read_reg(struct hm11b1 *hm11b1, u16 reg, u16 len, u32 *val)
+{
+	struct i2c_client *client = hm11b1->client;
+	struct i2c_msg msgs[2];
+	u8 addr_buf[2];
+	u8 data_buf[4] = {0};
+	int ret = 0;
+
+	if (len > sizeof(data_buf))
+		return -EINVAL;
+
+	put_unaligned_be16(reg, addr_buf);
+	msgs[0].addr = client->addr;
+	msgs[0].flags = 0;
+	msgs[0].len = sizeof(addr_buf);
+	msgs[0].buf = addr_buf;
+	msgs[1].addr = client->addr;
+	msgs[1].flags = I2C_M_RD;
+	msgs[1].len = len;
+	msgs[1].buf = &data_buf[sizeof(data_buf) - len];
+
+	ret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));
+	if (ret != ARRAY_SIZE(msgs))
+		return ret < 0 ? ret : -EIO;
+
+	*val = get_unaligned_be32(data_buf);
+
+	return 0;
+}
+
+static int hm11b1_write_reg(struct hm11b1 *hm11b1, u16 reg, u16 len, u32 val)
+{
+	struct i2c_client *client = hm11b1->client;
+	u8 buf[6];
+	int ret = 0;
+
+	if (len > 4)
+		return -EINVAL;
+
+	put_unaligned_be16(reg, buf);
+	put_unaligned_be32(val << 8 * (4 - len), buf + 2);
+
+	ret = i2c_master_send(client, buf, len + 2);
+	if (ret != len + 2)
+		return ret < 0 ? ret : -EIO;
+
+	return 0;
+}
+
+static int hm11b1_write_reg_list(struct hm11b1 *hm11b1,
+				 const struct hm11b1_reg_list *r_list)
+{
+	struct i2c_client *client = hm11b1->client;
+	unsigned int i;
+	int ret = 0;
+
+	for (i = 0; i < r_list->num_of_regs; i++) {
+		ret = hm11b1_write_reg(hm11b1, r_list->regs[i].address, 1,
+				       r_list->regs[i].val);
+		if (ret) {
+			dev_err_ratelimited(&client->dev,
+					    "write reg 0x%4.4x return err = %d",
+					    r_list->regs[i].address, ret);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int hm11b1_update_digital_gain(struct hm11b1 *hm11b1, u32 d_gain)
+{
+	struct i2c_client *client = hm11b1->client;
+	int ret = 0;
+
+	ret = hm11b1_write_reg(hm11b1, HM11B1_REG_DGTL_GAIN, 2, d_gain);
+	if (ret) {
+		dev_err(&client->dev, "failed to set HM11B1_REG_DGTL_GAIN");
+		return ret;
+	}
+
+	ret = hm11b1_write_reg(hm11b1, HM11B1_REG_DGTL_GAIN_IR, 2, d_gain);
+	if (ret) {
+		dev_err(&client->dev, "failed to set HM11B1_REG_DGTL_GAIN_IR");
+		return ret;
+	}
+
+	return ret;
+}
+
+static int hm11b1_test_pattern(struct hm11b1 *hm11b1, u32 pattern)
+{
+	if (pattern)
+		pattern = pattern << HM11B1_TEST_PATTERN_BAR_SHIFT |
+			  HM11B1_TEST_PATTERN_ENABLE;
+
+	return hm11b1_write_reg(hm11b1, HM11B1_REG_TEST_PATTERN, 1, pattern);
+}
+
+static int hm11b1_set_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct hm11b1 *hm11b1 = container_of(ctrl->handler,
+					     struct hm11b1, ctrl_handler);
+	struct i2c_client *client = hm11b1->client;
+	s64 exposure_max;
+	int ret = 0;
+
+	/* Propagate change of current control to all related controls */
+	if (ctrl->id == V4L2_CID_VBLANK) {
+		/* Update max exposure while meeting expected vblanking */
+		exposure_max = hm11b1->cur_mode->height + ctrl->val -
+			       HM11B1_EXPOSURE_MAX_MARGIN;
+		__v4l2_ctrl_modify_range(hm11b1->exposure,
+					 hm11b1->exposure->minimum,
+					 exposure_max, hm11b1->exposure->step,
+					 exposure_max);
+	}
+
+	/* V4L2 controls values will be applied only when power is already up */
+	if (!pm_runtime_get_if_in_use(&client->dev))
+		return 0;
+
+	ret = hm11b1_write_reg(hm11b1, HM11B1_REG_COMMAND_UPDATE, 1, 1);
+	if (ret) {
+		dev_err(&client->dev, "failed to enable HM11B1_REG_COMMAND_UPDATE");
+		pm_runtime_put(&client->dev);
+		return ret;
+	}
+	switch (ctrl->id) {
+	case V4L2_CID_ANALOGUE_GAIN:
+		ret = hm11b1_write_reg(hm11b1, HM11B1_REG_ANALOG_GAIN, 1,
+				       ctrl->val);
+		ret |= hm11b1_write_reg(hm11b1, HM11B1_REG_ANALOG_GAIN_IR, 1,
+					ctrl->val);
+		break;
+
+	case V4L2_CID_DIGITAL_GAIN:
+		ret = hm11b1_update_digital_gain(hm11b1, ctrl->val);
+		break;
+
+	case V4L2_CID_EXPOSURE:
+		/* 4 least significant bits of expsoure are fractional part */
+		ret = hm11b1_write_reg(hm11b1, HM11B1_REG_EXPOSURE, 2,
+				       ctrl->val);
+		break;
+
+	case V4L2_CID_VBLANK:
+		ret = hm11b1_write_reg(hm11b1, HM11B1_REG_VTS, 2,
+				       hm11b1->cur_mode->height + ctrl->val);
+		break;
+
+	case V4L2_CID_TEST_PATTERN:
+		ret = hm11b1_test_pattern(hm11b1, ctrl->val);
+		break;
+
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	ret |= hm11b1_write_reg(hm11b1, HM11B1_REG_COMMAND_UPDATE, 1, 0);
+	pm_runtime_put(&client->dev);
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops hm11b1_ctrl_ops = {
+	.s_ctrl = hm11b1_set_ctrl,
+};
+
+static int hm11b1_init_controls(struct hm11b1 *hm11b1)
+{
+	struct v4l2_ctrl_handler *ctrl_hdlr;
+	const struct hm11b1_mode *cur_mode;
+	s64 exposure_max, h_blank, pixel_rate;
+	u32 vblank_min, vblank_max, vblank_default;
+	int size;
+	int ret = 0;
+
+	ctrl_hdlr = &hm11b1->ctrl_handler;
+	ret = v4l2_ctrl_handler_init(ctrl_hdlr, 8);
+	if (ret)
+		return ret;
+
+	ctrl_hdlr->lock = &hm11b1->mutex;
+	cur_mode = hm11b1->cur_mode;
+	size = ARRAY_SIZE(link_freq_menu_items);
+
+	hm11b1->link_freq = v4l2_ctrl_new_int_menu(ctrl_hdlr, &hm11b1_ctrl_ops,
+						   V4L2_CID_LINK_FREQ,
+						   size - 1, 0,
+						   link_freq_menu_items);
+	if (hm11b1->link_freq)
+		hm11b1->link_freq->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	pixel_rate = to_pixel_rate(HM11B1_LINK_FREQ_384MHZ_INDEX);
+	hm11b1->pixel_rate = v4l2_ctrl_new_std(ctrl_hdlr, &hm11b1_ctrl_ops,
+					       V4L2_CID_PIXEL_RATE, 0,
+					       pixel_rate, 1, pixel_rate);
+
+	vblank_min = cur_mode->vts_min - cur_mode->height;
+	vblank_max = HM11B1_VTS_MAX - cur_mode->height;
+	vblank_default = cur_mode->vts_def - cur_mode->height;
+	hm11b1->vblank = v4l2_ctrl_new_std(ctrl_hdlr, &hm11b1_ctrl_ops,
+					   V4L2_CID_VBLANK, vblank_min,
+					   vblank_max, 1, vblank_default);
+
+	h_blank = to_pixels_per_line(cur_mode->hts, cur_mode->link_freq_index);
+	h_blank -= cur_mode->width;
+	hm11b1->hblank = v4l2_ctrl_new_std(ctrl_hdlr, &hm11b1_ctrl_ops,
+					   V4L2_CID_HBLANK, h_blank, h_blank, 1,
+					   h_blank);
+	if (hm11b1->hblank)
+		hm11b1->hblank->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	v4l2_ctrl_new_std(ctrl_hdlr, &hm11b1_ctrl_ops, V4L2_CID_ANALOGUE_GAIN,
+			  HM11B1_ANAL_GAIN_MIN, HM11B1_ANAL_GAIN_MAX,
+			  HM11B1_ANAL_GAIN_STEP, HM11B1_ANAL_GAIN_MIN);
+	v4l2_ctrl_new_std(ctrl_hdlr, &hm11b1_ctrl_ops, V4L2_CID_DIGITAL_GAIN,
+			  HM11B1_DGTL_GAIN_MIN, HM11B1_DGTL_GAIN_MAX,
+			  HM11B1_DGTL_GAIN_STEP, HM11B1_DGTL_GAIN_DEFAULT);
+	exposure_max = cur_mode->vts_def - HM11B1_EXPOSURE_MAX_MARGIN;
+	hm11b1->exposure = v4l2_ctrl_new_std(ctrl_hdlr, &hm11b1_ctrl_ops,
+					     V4L2_CID_EXPOSURE,
+					     HM11B1_EXPOSURE_MIN, exposure_max,
+					     HM11B1_EXPOSURE_STEP,
+					     exposure_max);
+	v4l2_ctrl_new_std_menu_items(ctrl_hdlr, &hm11b1_ctrl_ops,
+				     V4L2_CID_TEST_PATTERN,
+				     ARRAY_SIZE(hm11b1_test_pattern_menu) - 1,
+				     0, 0, hm11b1_test_pattern_menu);
+	if (ctrl_hdlr->error)
+		return ctrl_hdlr->error;
+
+	hm11b1->sd.ctrl_handler = ctrl_hdlr;
+
+	return 0;
+}
+
+static void hm11b1_update_pad_format(const struct hm11b1_mode *mode,
+				     struct v4l2_mbus_framefmt *fmt)
+{
+	fmt->width = mode->width;
+	fmt->height = mode->height;
+	fmt->code = MEDIA_BUS_FMT_SGRBG10_1X10;
+	fmt->field = V4L2_FIELD_NONE;
+}
+
+static int hm11b1_start_streaming(struct hm11b1 *hm11b1)
+{
+	struct i2c_client *client = hm11b1->client;
+	const struct hm11b1_reg_list *reg_list;
+	int link_freq_index;
+	int ret = 0;
+
+	hm11b1_set_power(hm11b1, 1);
+	link_freq_index = hm11b1->cur_mode->link_freq_index;
+	reg_list = &link_freq_configs[link_freq_index].reg_list;
+	ret = hm11b1_write_reg_list(hm11b1, reg_list);
+	if (ret) {
+		dev_err(&client->dev, "failed to set plls");
+		return ret;
+	}
+
+	reg_list = &hm11b1->cur_mode->reg_list;
+	ret = hm11b1_write_reg_list(hm11b1, reg_list);
+	if (ret) {
+		dev_err(&client->dev, "failed to set mode");
+		return ret;
+	}
+
+	ret = __v4l2_ctrl_handler_setup(hm11b1->sd.ctrl_handler);
+	if (ret)
+		return ret;
+
+	ret = hm11b1_write_reg(hm11b1, HM11B1_REG_MODE_SELECT, 1,
+			       HM11B1_MODE_STREAMING);
+	if (ret)
+		dev_err(&client->dev, "failed to start streaming");
+
+	return ret;
+}
+
+static void hm11b1_stop_streaming(struct hm11b1 *hm11b1)
+{
+	struct i2c_client *client = hm11b1->client;
+
+	if (hm11b1_write_reg(hm11b1, HM11B1_REG_MODE_SELECT, 1,
+			     HM11B1_MODE_STANDBY))
+		dev_err(&client->dev, "failed to stop streaming");
+	hm11b1_set_power(hm11b1, 0);
+}
+
+static int hm11b1_set_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct hm11b1 *hm11b1 = to_hm11b1(sd);
+	struct i2c_client *client = hm11b1->client;
+	int ret = 0;
+
+	if (hm11b1->streaming == enable)
+		return 0;
+
+	mutex_lock(&hm11b1->mutex);
+	if (enable) {
+		ret = pm_runtime_get_sync(&client->dev);
+		if (ret < 0) {
+			pm_runtime_put_noidle(&client->dev);
+			mutex_unlock(&hm11b1->mutex);
+			return ret;
+		}
+
+		ret = hm11b1_start_streaming(hm11b1);
+		if (ret) {
+			enable = 0;
+			hm11b1_stop_streaming(hm11b1);
+			pm_runtime_put(&client->dev);
+		}
+	} else {
+		hm11b1_stop_streaming(hm11b1);
+		pm_runtime_put(&client->dev);
+	}
+
+	hm11b1->streaming = enable;
+	mutex_unlock(&hm11b1->mutex);
+
+	return ret;
+}
+
+static int __maybe_unused hm11b1_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct hm11b1 *hm11b1 = to_hm11b1(sd);
+
+	mutex_lock(&hm11b1->mutex);
+	if (hm11b1->streaming)
+		hm11b1_stop_streaming(hm11b1);
+
+	mutex_unlock(&hm11b1->mutex);
+
+	return 0;
+}
+
+static int __maybe_unused hm11b1_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct hm11b1 *hm11b1 = to_hm11b1(sd);
+	int ret = 0;
+
+	mutex_lock(&hm11b1->mutex);
+	if (!hm11b1->streaming)
+		goto exit;
+
+	ret = hm11b1_start_streaming(hm11b1);
+	if (ret) {
+		hm11b1->streaming = false;
+		hm11b1_stop_streaming(hm11b1);
+	}
+
+exit:
+	mutex_unlock(&hm11b1->mutex);
+	return ret;
+}
+
+static int hm11b1_set_format(struct v4l2_subdev *sd,
+			     struct v4l2_subdev_state *sd_state,
+			     struct v4l2_subdev_format *fmt)
+{
+	struct hm11b1 *hm11b1 = to_hm11b1(sd);
+	const struct hm11b1_mode *mode;
+	s32 vblank_def, h_blank;
+
+	mode = v4l2_find_nearest_size(supported_modes,
+				      ARRAY_SIZE(supported_modes), width,
+				      height, fmt->format.width,
+				      fmt->format.height);
+
+	mutex_lock(&hm11b1->mutex);
+	hm11b1_update_pad_format(mode, &fmt->format);
+	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {
+		*v4l2_subdev_get_try_format(sd, sd_state, fmt->pad) = fmt->format;
+	} else {
+		hm11b1->cur_mode = mode;
+		__v4l2_ctrl_s_ctrl(hm11b1->link_freq, mode->link_freq_index);
+		__v4l2_ctrl_s_ctrl_int64(hm11b1->pixel_rate,
+					 to_pixel_rate(mode->link_freq_index));
+
+		/* Update limits and set FPS to default */
+		vblank_def = mode->vts_def - mode->height;
+		__v4l2_ctrl_modify_range(hm11b1->vblank,
+					 mode->vts_min - mode->height,
+					 HM11B1_VTS_MAX - mode->height, 1,
+					 vblank_def);
+		__v4l2_ctrl_s_ctrl(hm11b1->vblank, vblank_def);
+		h_blank = to_pixels_per_line(mode->hts, mode->link_freq_index) -
+			  mode->width;
+		__v4l2_ctrl_modify_range(hm11b1->hblank, h_blank, h_blank, 1,
+					 h_blank);
+	}
+	mutex_unlock(&hm11b1->mutex);
+
+	return 0;
+}
+
+static int hm11b1_get_format(struct v4l2_subdev *sd,
+			     struct v4l2_subdev_state *sd_state,
+			     struct v4l2_subdev_format *fmt)
+{
+	struct hm11b1 *hm11b1 = to_hm11b1(sd);
+
+	mutex_lock(&hm11b1->mutex);
+	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY)
+		fmt->format = *v4l2_subdev_get_try_format(&hm11b1->sd,
+							  sd_state, fmt->pad);
+	else
+		hm11b1_update_pad_format(hm11b1->cur_mode, &fmt->format);
+
+	mutex_unlock(&hm11b1->mutex);
+
+	return 0;
+}
+
+static int hm11b1_enum_mbus_code(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_state *sd_state,
+				 struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->index > 0)
+		return -EINVAL;
+
+	code->code = MEDIA_BUS_FMT_SGRBG10_1X10;
+
+	return 0;
+}
+
+static int hm11b1_enum_frame_size(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_state *sd_state,
+				  struct v4l2_subdev_frame_size_enum *fse)
+{
+	if (fse->index >= ARRAY_SIZE(supported_modes))
+		return -EINVAL;
+
+	if (fse->code != MEDIA_BUS_FMT_SGRBG10_1X10)
+		return -EINVAL;
+
+	fse->min_width = supported_modes[fse->index].width;
+	fse->max_width = fse->min_width;
+	fse->min_height = supported_modes[fse->index].height;
+	fse->max_height = fse->min_height;
+
+	return 0;
+}
+
+static int hm11b1_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct hm11b1 *hm11b1 = to_hm11b1(sd);
+
+	mutex_lock(&hm11b1->mutex);
+	hm11b1_update_pad_format(&supported_modes[0],
+				 v4l2_subdev_get_try_format(sd, fh->state, 0));
+	mutex_unlock(&hm11b1->mutex);
+
+	return 0;
+}
+
+static const struct v4l2_subdev_video_ops hm11b1_video_ops = {
+	.s_stream = hm11b1_set_stream,
+};
+
+static const struct v4l2_subdev_pad_ops hm11b1_pad_ops = {
+	.set_fmt = hm11b1_set_format,
+	.get_fmt = hm11b1_get_format,
+	.enum_mbus_code = hm11b1_enum_mbus_code,
+	.enum_frame_size = hm11b1_enum_frame_size,
+};
+
+static const struct v4l2_subdev_ops hm11b1_subdev_ops = {
+	.video = &hm11b1_video_ops,
+	.pad = &hm11b1_pad_ops,
+};
+
+static const struct media_entity_operations hm11b1_subdev_entity_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+static const struct v4l2_subdev_internal_ops hm11b1_internal_ops = {
+	.open = hm11b1_open,
+};
+
+static int hm11b1_identify_module(struct hm11b1 *hm11b1)
+{
+	struct i2c_client *client = hm11b1->client;
+	int ret;
+	u32 val;
+
+	ret = hm11b1_read_reg(hm11b1, HM11B1_REG_CHIP_ID, 2, &val);
+	if (ret)
+		return ret;
+
+	if (val != HM11B1_CHIP_ID) {
+		dev_err(&client->dev, "chip id mismatch: %x!=%x",
+			HM11B1_CHIP_ID, val);
+		return -ENXIO;
+	}
+
+	return 0;
+}
+
+static int hm11b1_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct hm11b1 *hm11b1 = to_hm11b1(sd);
+
+	v4l2_async_unregister_subdev(sd);
+	media_entity_cleanup(&sd->entity);
+	v4l2_ctrl_handler_free(sd->ctrl_handler);
+	pm_runtime_disable(&client->dev);
+	mutex_destroy(&hm11b1->mutex);
+
+	return 0;
+}
+
+#if IS_ENABLED(CONFIG_INTEL_SKL_INT3472)
+static int hm11b1_parse_dt(struct hm11b1 *hm11b1)
+{
+	struct device *dev = &hm11b1->client->dev;
+	int ret;
+
+	hm11b1->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	ret = PTR_ERR_OR_ZERO(hm11b1->reset_gpio);
+	if (ret < 0) {
+		dev_err(dev, "error while getting reset gpio: %d\n", ret);
+		return ret;
+	}
+
+	hm11b1->powerdown_gpio = devm_gpiod_get(dev, "powerdown", GPIOD_OUT_HIGH);
+	ret = PTR_ERR_OR_ZERO(hm11b1->powerdown_gpio);
+	if (ret < 0) {
+		dev_err(dev, "error while getting powerdown gpio: %d\n", ret);
+		return ret;
+	}
+
+	hm11b1->clken_gpio = devm_gpiod_get(dev, "clken", GPIOD_OUT_HIGH);
+	ret = PTR_ERR_OR_ZERO(hm11b1->clken_gpio);
+	if (ret < 0) {
+		dev_err(dev, "error while getting clken_gpio gpio: %d\n", ret);
+		return ret;
+	}
+
+	hm11b1->pled_gpio = devm_gpiod_get(dev, "pled", GPIOD_OUT_HIGH);
+	ret = PTR_ERR_OR_ZERO(hm11b1->pled_gpio);
+	if (ret < 0) {
+		dev_err(dev, "error while getting pled gpio: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+#endif
+
+static int hm11b1_probe(struct i2c_client *client)
+{
+	struct hm11b1 *hm11b1;
+	int ret = 0;
+
+	hm11b1 = devm_kzalloc(&client->dev, sizeof(*hm11b1), GFP_KERNEL);
+	if (!hm11b1)
+		return -ENOMEM;
+	hm11b1->client = client;
+
+#if IS_ENABLED(CONFIG_INTEL_SKL_INT3472)
+	ret = hm11b1_parse_dt(hm11b1);
+	if (ret < 0)
+		return -EPROBE_DEFER;
+#elif IS_ENABLED(CONFIG_POWER_CTRL_LOGIC)
+	if (power_ctrl_logic_set_power(1))
+		return -EPROBE_DEFER;
+#endif
+	hm11b1_set_power(hm11b1, 1);
+
+	v4l2_i2c_subdev_init(&hm11b1->sd, client, &hm11b1_subdev_ops);
+	ret = hm11b1_identify_module(hm11b1);
+	if (ret) {
+		dev_err(&client->dev, "failed to find sensor: %d", ret);
+		goto probe_error_power_off;
+	}
+
+	mutex_init(&hm11b1->mutex);
+	hm11b1->cur_mode = &supported_modes[0];
+	ret = hm11b1_init_controls(hm11b1);
+	if (ret) {
+		dev_err(&client->dev, "failed to init controls: %d", ret);
+		goto probe_error_v4l2_ctrl_handler_free;
+	}
+
+	hm11b1->sd.internal_ops = &hm11b1_internal_ops;
+	hm11b1->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	hm11b1->sd.entity.ops = &hm11b1_subdev_entity_ops;
+	hm11b1->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;
+	hm11b1->pad.flags = MEDIA_PAD_FL_SOURCE;
+	ret = media_entity_pads_init(&hm11b1->sd.entity, 1, &hm11b1->pad);
+	if (ret) {
+		dev_err(&client->dev, "failed to init entity pads: %d", ret);
+		goto probe_error_v4l2_ctrl_handler_free;
+	}
+
+	ret = v4l2_async_register_subdev_sensor(&hm11b1->sd);
+	if (ret < 0) {
+		dev_err(&client->dev, "failed to register V4L2 subdev: %d",
+			ret);
+		goto probe_error_media_entity_cleanup;
+	}
+
+	/*
+	 * Device is already turned on by i2c-core with ACPI domain PM.
+	 * Enable runtime PM and turn off the device.
+	 */
+	pm_runtime_set_active(&client->dev);
+	pm_runtime_enable(&client->dev);
+	pm_runtime_idle(&client->dev);
+
+	hm11b1_set_power(hm11b1, 0);
+	return 0;
+
+probe_error_media_entity_cleanup:
+	media_entity_cleanup(&hm11b1->sd.entity);
+
+probe_error_v4l2_ctrl_handler_free:
+	v4l2_ctrl_handler_free(hm11b1->sd.ctrl_handler);
+	mutex_destroy(&hm11b1->mutex);
+
+probe_error_power_off:
+	hm11b1_set_power(hm11b1, 0);
+	return ret;
+}
+
+static const struct dev_pm_ops hm11b1_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(hm11b1_suspend, hm11b1_resume)
+};
+
+#ifdef CONFIG_ACPI
+static const struct acpi_device_id hm11b1_acpi_ids[] = {
+	{"HIMX11B1"},
+	{}
+};
+
+MODULE_DEVICE_TABLE(acpi, hm11b1_acpi_ids);
+#endif
+
+static struct i2c_driver hm11b1_i2c_driver = {
+	.driver = {
+		.name = "hm11b1",
+		.pm = &hm11b1_pm_ops,
+		.acpi_match_table = ACPI_PTR(hm11b1_acpi_ids),
+	},
+	.probe_new = hm11b1_probe,
+	.remove = hm11b1_remove,
+};
+
+module_i2c_driver(hm11b1_i2c_driver);
+
+MODULE_AUTHOR("Qiu, Tianshu <tian.shu.qiu@intel.com>");
+MODULE_AUTHOR("Shawn Tu <shawnx.tu@intel.com>");
+MODULE_AUTHOR("Bingbu Cao <bingbu.cao@intel.com>");
+MODULE_AUTHOR("Lai, Jim <jim.lai@intel.com>");
+MODULE_DESCRIPTION("Himax HM11B1 sensor driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/i2c/lt6911uxc.c b/drivers/media/i2c/lt6911uxc.c
index 17393b1abd5a..f1d495e001af 100644
--- a/drivers/media/i2c/lt6911uxc.c
+++ b/drivers/media/i2c/lt6911uxc.c
@@ -24,6 +24,8 @@
 #include <linux/version.h>
 #include <media/lt6911uxc.h>
 
+#include <linux/ipu-isys.h>
+
 /* v4l2 debug level */
 static int debug;
 module_param(debug, int, 0644);
@@ -185,7 +187,6 @@ struct lt6911uxc_state {
 	struct v4l2_ctrl *frame_interval;
 	struct v4l2_ctrl *pixel_rate;
 	struct v4l2_ctrl *link_freq;
-	struct v4l2_ctrl *mipi_lanes;
 	struct v4l2_ctrl *vblank;
 	struct v4l2_ctrl *exposure;
 	struct v4l2_ctrl *analogue_gain;
@@ -195,6 +196,8 @@ struct lt6911uxc_state {
 	struct v4l2_ctrl *strobe_stop;
 	struct v4l2_ctrl *timeout;
 	struct v4l2_ctrl *hblank;
+	struct v4l2_ctrl *query_sub_stream;
+	struct v4l2_ctrl *set_sub_stream;
 
 	struct v4l2_dv_timings timings;
 	struct v4l2_dv_timings detected_timings;
@@ -218,6 +221,8 @@ struct lt6911uxc_state {
 	u32 thread_run;
 	struct task_struct *poll_task;
 	bool auxiliary_port;
+
+	s64 sub_stream;
 };
 
 static const struct v4l2_event lt6911uxc_ev_source_change = {
@@ -596,11 +601,6 @@ static int lt6911uxc_set_ctrl(struct v4l2_ctrl *ctrl)
 		dev_dbg(&client->dev, "set vblank %d\n",
 			lt6911uxc->cur_mode->height + ctrl->val);
 		break;
-
-	case V4L2_CID_MIPI_LANES:
-		dev_dbg(&client->dev, "set mipi lane %d\n", ctrl->val);
-		break;
-
 	case V4L2_CID_FLASH_STROBE_SOURCE:
 		dev_dbg(&client->dev, "set led flash source %d\n", ctrl->val);
 		break;
@@ -703,6 +703,29 @@ static struct v4l2_ctrl_config lt6911uxc_frame_interval = {
 	.flags	= V4L2_CTRL_FLAG_READ_ONLY,
 };
 
+static struct v4l2_ctrl_config lt6911uxc_q_sub_stream = {
+	.ops = &lt6911uxc_ctrl_ops,
+	.id = V4L2_CID_IPU_QUERY_SUB_STREAM,
+	.name = "query virtual channel",
+	.type = V4L2_CTRL_TYPE_INTEGER_MENU,
+	.max = 1,
+	.min = 0,
+	.def = 0,
+	.menu_skip_mask = 0,
+	.qmenu_int = NULL,
+};
+
+static const struct v4l2_ctrl_config lt6911uxc_s_sub_stream = {
+	.ops = &lt6911uxc_ctrl_ops,
+	.id = V4L2_CID_IPU_SET_SUB_STREAM,
+	.name = "set virtual channel",
+	.type = V4L2_CTRL_TYPE_INTEGER64,
+	.max = 0xFFFF,
+	.min = 0,
+	.def = 0,
+	.step = 1,
+};
+
 static u64 get_pixel_rate(struct lt6911uxc_state *lt6911uxc)
 {
 	if (lt6911uxc->cur_mode->lanes)
@@ -712,12 +735,62 @@ static u64 get_pixel_rate(struct lt6911uxc_state *lt6911uxc)
 		return 995328000; /* default value: 4K@30 */
 }
 
+#define MIPI_CSI2_TYPE_YUV422_8         0x1e
+
+static unsigned int mbus_code_to_mipi(u32 code)
+{
+	switch (code) {
+	case MEDIA_BUS_FMT_UYVY8_1X16:
+		return MIPI_CSI2_TYPE_YUV422_8;
+	default:
+		WARN_ON(1);
+		return -EINVAL;
+	}
+}
+
+static void set_sub_stream_fmt(s64 *sub_stream, u32 code)
+{
+       *sub_stream &= 0xFFFFFFFFFFFF0000;
+       *sub_stream |= code;
+}
+
+static void set_sub_stream_h(s64 *sub_stream, u32 height)
+{
+       s64 val = height;
+       val &= 0xFFFF;
+       *sub_stream &= 0xFFFFFFFF0000FFFF;
+       *sub_stream |= val << 16;
+}
+
+static void set_sub_stream_w(s64 *sub_stream, u32 width)
+{
+       s64 val = width;
+       val &= 0xFFFF;
+       *sub_stream &= 0xFFFF0000FFFFFFFF;
+       *sub_stream |= val << 32;
+}
+
+static void set_sub_stream_dt(s64 *sub_stream, u32 dt)
+{
+       s64 val = dt;
+       val &= 0xFF;
+       *sub_stream &= 0xFF00FFFFFFFFFFFF;
+       *sub_stream |= val << 48;
+}
+
+static void set_sub_stream_vc_id(s64 *sub_stream, u32 vc_id)
+{
+       s64 val = vc_id;
+       val &= 0xFF;
+       *sub_stream &= 0x00FFFFFFFFFFFFFF;
+       *sub_stream |= val << 56;
+}
+
 static int lt6911uxc_init_controls(struct lt6911uxc_state *lt6911uxc)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(&lt6911uxc->sd);
 	struct v4l2_ctrl_handler *ctrl_hdlr;
 	s64 hblank;
-	struct v4l2_ctrl_config cfg = { 0 };
 	int ret;
 
 	ctrl_hdlr = &lt6911uxc->ctrl_handler;
@@ -775,20 +848,6 @@ static int lt6911uxc_init_controls(struct lt6911uxc_state *lt6911uxc)
 			ctrl_hdlr->error);
 		return ctrl_hdlr->error;
 	}
-
-	cfg.ops = &lt6911uxc_ctrl_ops;
-	cfg.id = V4L2_CID_MIPI_LANES;
-	cfg.name = "V4L2_CID_MIPI_LANES";
-	cfg.type = V4L2_CTRL_TYPE_INTEGER;
-	cfg.max = 4; cfg.min = 2; cfg.step = 2; cfg.def = 4;
-	cfg.qmenu = 0; cfg.elem_size = 0;
-	lt6911uxc->mipi_lanes = v4l2_ctrl_new_custom(ctrl_hdlr, &cfg, NULL);
-	if (ctrl_hdlr->error) {
-		dev_dbg(&client->dev, "Set ctrl_hdlr, err=%d.\n",
-			ctrl_hdlr->error);
-		return ctrl_hdlr->error;
-	}
-
 	lt6911uxc_csi_port.def = lt6911uxc->platform_data->port;
 	lt6911uxc->csi_port =
 		v4l2_ctrl_new_custom(ctrl_hdlr, &lt6911uxc_csi_port, NULL);
@@ -889,6 +948,20 @@ static int lt6911uxc_init_controls(struct lt6911uxc_state *lt6911uxc)
 		return ctrl_hdlr->error;
 	}
 
+	lt6911uxc_q_sub_stream.qmenu_int = &lt6911uxc->sub_stream;
+	lt6911uxc->query_sub_stream = v4l2_ctrl_new_custom(ctrl_hdlr, &lt6911uxc_q_sub_stream, NULL);
+	if (ctrl_hdlr->error) {
+		dev_dbg(&client->dev, "Set query sub stream ctrl, error = %d.\n",
+			ctrl_hdlr->error);
+		return ctrl_hdlr->error;
+	}
+	lt6911uxc->set_sub_stream = v4l2_ctrl_new_custom(ctrl_hdlr, &lt6911uxc_s_sub_stream, NULL);
+	if (ctrl_hdlr->error) {
+		dev_dbg(&client->dev, "Set set sub stream ctrl, error = %d.\n",
+			ctrl_hdlr->error);
+		return ctrl_hdlr->error;
+	}
+
 	lt6911uxc->sd.ctrl_handler = ctrl_hdlr;
 	return 0;
 }
@@ -912,7 +985,6 @@ static int lt6911uxc_start_streaming(struct lt6911uxc_state *lt6911uxc)
 	lt6911uxc_ext_control(lt6911uxc, true);
 	lt6911uxc_csi_enable(&lt6911uxc->sd, true);
 	lt6911uxc_ext_control(lt6911uxc, false);
-	lt6911uxc->streaming = true;
 
 	ret = __v4l2_ctrl_handler_setup(lt6911uxc->sd.ctrl_handler);
 	if (ret)
@@ -930,8 +1002,6 @@ static void lt6911uxc_stop_streaming(struct lt6911uxc_state *lt6911uxc)
 	lt6911uxc_ext_control(lt6911uxc, true);
 	lt6911uxc_csi_enable(&lt6911uxc->sd, false);
 	lt6911uxc_ext_control(lt6911uxc, false);
-
-	lt6911uxc->streaming = false;
 }
 
 static int lt6911uxc_set_stream(struct v4l2_subdev *sd, int enable)
@@ -945,15 +1015,21 @@ static int lt6911uxc_set_stream(struct v4l2_subdev *sd, int enable)
 	if (lt6911uxc->auxiliary_port == true)
 		return 0;
 
+	mutex_lock(&lt6911uxc->mutex);
 	if (enable) {
 		dev_dbg(sd->dev, "[%s()], start streaming.\n", __func__);
 		ret = lt6911uxc_start_streaming(lt6911uxc);
-		if (ret)
+		if (ret) {
+			enable = 0;
 			lt6911uxc_stop_streaming(lt6911uxc);
+		}
 	} else {
 		dev_dbg(sd->dev, "[%s()], stop streaming.\n", __func__);
 		lt6911uxc_stop_streaming(lt6911uxc);
 	}
+	mutex_unlock(&lt6911uxc->mutex);
+
+	lt6911uxc->streaming = enable;
 
 	return ret;
 }
@@ -970,16 +1046,6 @@ static int lt6911uxc_g_frame_interval(struct v4l2_subdev *sd,
 	return 0;
 }
 
-static int __maybe_unused lt6911uxc_suspend(struct device *dev)
-{
-	return 0;
-}
-
-static int __maybe_unused lt6911uxc_resume(struct device *dev)
-{
-	return 0;
-}
-
 static int lt6911uxc_set_format(struct v4l2_subdev *sd,
 				struct v4l2_subdev_state *sd_state,
 			     struct v4l2_subdev_format *fmt)
@@ -1021,6 +1087,11 @@ static int lt6911uxc_set_format(struct v4l2_subdev *sd,
 		else
 			__v4l2_ctrl_s_ctrl(lt6911uxc->frame_interval, 33);
 	}
+	set_sub_stream_fmt(&lt6911uxc->sub_stream, fmt->format.code);
+	set_sub_stream_h(&lt6911uxc->sub_stream, fmt->format.height);
+	set_sub_stream_w(&lt6911uxc->sub_stream, fmt->format.width);
+	set_sub_stream_dt(&lt6911uxc->sub_stream, mbus_code_to_mipi(fmt->format.code));
+	set_sub_stream_vc_id(&lt6911uxc->sub_stream, 0);
 	mutex_unlock(&lt6911uxc->mutex);
 
 	return 0;
@@ -1516,6 +1587,55 @@ static int lt6911uxc_probe(struct i2c_client *client)
 	return ret;
 }
 
+static int lt6911uxc_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct lt6911uxc_state *lt6911uxc = to_state(sd);
+
+	if (-1 != lt6911uxc->platform_data->reset_pin)
+		if (gpio_get_value(lt6911uxc->platform_data->reset_pin))
+			gpio_set_value(lt6911uxc->platform_data->reset_pin, 0);
+
+	mutex_lock(&lt6911uxc->mutex);
+	if (lt6911uxc->streaming)
+		lt6911uxc_stop_streaming(lt6911uxc);
+
+	mutex_unlock(&lt6911uxc->mutex);
+	dev_dbg(sd->dev, "suspend streaming...\n");
+	return 0;
+}
+
+static int lt6911uxc_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct lt6911uxc_state *lt6911uxc = to_state(sd);
+	int ret;
+
+	if (-1 != lt6911uxc->platform_data->reset_pin)
+		if (!gpio_get_value(lt6911uxc->platform_data->reset_pin))
+			gpio_set_value(lt6911uxc->platform_data->reset_pin, 1);
+
+	usleep_range(200000, 205000);
+	//recheck the current HDMI status in case changed
+	lt6911uxc_check_status(lt6911uxc);
+
+	mutex_lock(&lt6911uxc->mutex);
+	if (lt6911uxc->streaming) {
+		ret = lt6911uxc_start_streaming(lt6911uxc);
+		if (ret) {
+			lt6911uxc->streaming = false;
+			lt6911uxc_stop_streaming(lt6911uxc);
+			mutex_unlock(&lt6911uxc->mutex);
+			return ret;
+		}
+	}
+	mutex_unlock(&lt6911uxc->mutex);
+	dev_dbg(sd->dev, "resume streaming...\n");
+	return 0;
+}
+
 static const struct dev_pm_ops lt6911uxc_pm_ops = {
 	SET_SYSTEM_SLEEP_PM_OPS(lt6911uxc_suspend, lt6911uxc_resume)
 };
diff --git a/drivers/media/i2c/ov01a10.c b/drivers/media/i2c/ov01a10.c
new file mode 100644
index 000000000000..4db6405fe4ee
--- /dev/null
+++ b/drivers/media/i2c/ov01a10.c
@@ -0,0 +1,917 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (c) 2020-2021 Intel Corporation.
+
+#include <asm/unaligned.h>
+#include <linux/acpi.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/version.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-fwnode.h>
+
+#define OV01A10_LINK_FREQ_400MHZ	400000000ULL
+#define OV01A10_SCLK			40000000LL
+#define OV01A10_MCLK			19200000
+#define OV01A10_DATA_LANES		1
+#define OV01A10_RGB_DEPTH		10
+
+#define OV01A10_REG_CHIP_ID		0x300a
+#define OV01A10_CHIP_ID			0x560141
+
+#define OV01A10_REG_MODE_SELECT		0x0100
+#define OV01A10_MODE_STANDBY		0x00
+#define OV01A10_MODE_STREAMING		0x01
+
+/* vertical-timings from sensor */
+#define OV01A10_REG_VTS			0x380e
+#define OV01A10_VTS_DEF			0x0380
+#define OV01A10_VTS_MIN			0x0380
+#define OV01A10_VTS_MAX			0xffff
+
+/* Exposure controls from sensor */
+#define OV01A10_REG_EXPOSURE		0x3501
+#define OV01A10_EXPOSURE_MIN		4
+#define OV01A10_EXPOSURE_MAX_MARGIN	8
+#define OV01A10_EXPOSURE_STEP		1
+
+/* Analog gain controls from sensor */
+#define OV01A10_REG_ANALOG_GAIN		0x3508
+#define OV01A10_ANAL_GAIN_MIN		0x100
+#define OV01A10_ANAL_GAIN_MAX		0xffff
+#define OV01A10_ANAL_GAIN_STEP		1
+
+/* Digital gain controls from sensor */
+#define OV01A10_REG_DIGILAL_GAIN_B	0x350A
+#define OV01A10_REG_DIGITAL_GAIN_GB	0x3510
+#define OV01A10_REG_DIGITAL_GAIN_GR	0x3513
+#define OV01A10_REG_DIGITAL_GAIN_R	0x3516
+#define OV01A10_DGTL_GAIN_MIN		0
+#define OV01A10_DGTL_GAIN_MAX		0x3ffff
+#define OV01A10_DGTL_GAIN_STEP		1
+#define OV01A10_DGTL_GAIN_DEFAULT	1024
+
+/* Test Pattern Control */
+#define OV01A10_REG_TEST_PATTERN		0x4503
+#define OV01A10_TEST_PATTERN_ENABLE	BIT(7)
+#define OV01A10_TEST_PATTERN_BAR_SHIFT	0
+
+enum {
+	OV01A10_LINK_FREQ_400MHZ_INDEX,
+};
+
+struct ov01a10_reg {
+	u16 address;
+	u8 val;
+};
+
+struct ov01a10_reg_list {
+	u32 num_of_regs;
+	const struct ov01a10_reg *regs;
+};
+
+struct ov01a10_link_freq_config {
+	const struct ov01a10_reg_list reg_list;
+};
+
+struct ov01a10_mode {
+	/* Frame width in pixels */
+	u32 width;
+
+	/* Frame height in pixels */
+	u32 height;
+
+	/* Horizontal timining size */
+	u32 hts;
+
+	/* Default vertical timining size */
+	u32 vts_def;
+
+	/* Min vertical timining size */
+	u32 vts_min;
+
+	/* Link frequency needed for this resolution */
+	u32 link_freq_index;
+
+	/* Sensor register settings for this resolution */
+	const struct ov01a10_reg_list reg_list;
+};
+
+static const struct ov01a10_reg mipi_data_rate_720mbps[] = {
+};
+
+static const struct ov01a10_reg sensor_1280x800_setting[] = {
+	{0x0103, 0x01},
+	{0x0302, 0x00},
+	{0x0303, 0x06},
+	{0x0304, 0x01},
+	{0x0305, 0xe0},
+	{0x0306, 0x00},
+	{0x0308, 0x01},
+	{0x0309, 0x00},
+	{0x030c, 0x01},
+	{0x0322, 0x01},
+	{0x0323, 0x06},
+	{0x0324, 0x01},
+	{0x0325, 0x68},
+	{0x3002, 0xa1},
+	{0x301e, 0xf0},
+	{0x3022, 0x01},
+	{0x3501, 0x03},
+	{0x3502, 0x78},
+	{0x3504, 0x0c},
+	{0x3508, 0x01},
+	{0x3509, 0x00},
+	{0x3601, 0xc0},
+	{0x3603, 0x71},
+	{0x3610, 0x68},
+	{0x3611, 0x86},
+	{0x3640, 0x10},
+	{0x3641, 0x80},
+	{0x3642, 0xdc},
+	{0x3646, 0x55},
+	{0x3647, 0x57},
+	{0x364b, 0x00},
+	{0x3653, 0x10},
+	{0x3655, 0x00},
+	{0x3656, 0x00},
+	{0x365f, 0x0f},
+	{0x3661, 0x45},
+	{0x3662, 0x24},
+	{0x3663, 0x11},
+	{0x3664, 0x07},
+	{0x3709, 0x34},
+	{0x370b, 0x6f},
+	{0x3714, 0x22},
+	{0x371b, 0x27},
+	{0x371c, 0x67},
+	{0x371d, 0xa7},
+	{0x371e, 0xe7},
+	{0x3730, 0x81},
+	{0x3733, 0x10},
+	{0x3734, 0x40},
+	{0x3737, 0x04},
+	{0x3739, 0x1c},
+	{0x3767, 0x00},
+	{0x376c, 0x81},
+	{0x3772, 0x14},
+	{0x37c2, 0x04},
+	{0x37d8, 0x03},
+	{0x37d9, 0x0c},
+	{0x37e0, 0x00},
+	{0x37e1, 0x08},
+	{0x37e2, 0x10},
+	{0x37e3, 0x04},
+	{0x37e4, 0x04},
+	{0x37e5, 0x03},
+	{0x37e6, 0x04},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0x00},
+	{0x3804, 0x05},
+	{0x3805, 0x0f},
+	{0x3806, 0x03},
+	{0x3807, 0x2f},
+	{0x3808, 0x05},
+	{0x3809, 0x00},
+	{0x380a, 0x03},
+	{0x380b, 0x20},
+	{0x380c, 0x02},
+	{0x380d, 0xe8},
+	{0x380e, 0x03},
+	{0x380f, 0x80},
+	{0x3810, 0x00},
+	{0x3811, 0x09},
+	{0x3812, 0x00},
+	{0x3813, 0x08},
+	{0x3814, 0x01},
+	{0x3815, 0x01},
+	{0x3816, 0x01},
+	{0x3817, 0x01},
+	{0x3820, 0xa8},
+	{0x3822, 0x13},
+	{0x3832, 0x28},
+	{0x3833, 0x10},
+	{0x3b00, 0x00},
+	{0x3c80, 0x00},
+	{0x3c88, 0x02},
+	{0x3c8c, 0x07},
+	{0x3c8d, 0x40},
+	{0x3cc7, 0x80},
+	{0x4000, 0xc3},
+	{0x4001, 0xe0},
+	{0x4003, 0x40},
+	{0x4008, 0x02},
+	{0x4009, 0x19},
+	{0x400a, 0x01},
+	{0x400b, 0x6c},
+	{0x4011, 0x00},
+	{0x4041, 0x00},
+	{0x4300, 0xff},
+	{0x4301, 0x00},
+	{0x4302, 0x0f},
+	{0x4503, 0x00},
+	{0x4601, 0x50},
+	{0x4800, 0x64},
+	{0x481f, 0x34},
+	{0x4825, 0x33},
+	{0x4837, 0x11},
+	{0x4881, 0x40},
+	{0x4883, 0x01},
+	{0x4890, 0x00},
+	{0x4901, 0x00},
+	{0x4902, 0x00},
+	{0x4b00, 0x2a},
+	{0x4b0d, 0x00},
+	{0x450a, 0x04},
+	{0x450b, 0x00},
+	{0x5000, 0x65},
+	{0x5200, 0x18},
+	{0x5004, 0x00},
+	{0x5080, 0x40},
+	{0x0305, 0xf4},
+	{0x0325, 0xc2},
+	{0x380c, 0x05},
+	{0x380d, 0xd0},
+};
+
+static const char * const ov01a10_test_pattern_menu[] = {
+	"Disabled",
+	"Color Bar",
+	"Top-Bottom Darker Color Bar",
+	"Right-Left Darker Color Bar",
+	"Color Bar type 4",
+};
+
+static const s64 link_freq_menu_items[] = {
+	OV01A10_LINK_FREQ_400MHZ,
+};
+
+static const struct ov01a10_link_freq_config link_freq_configs[] = {
+	[OV01A10_LINK_FREQ_400MHZ_INDEX] = {
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(mipi_data_rate_720mbps),
+			.regs = mipi_data_rate_720mbps,
+		}
+	},
+};
+
+static const struct ov01a10_mode supported_modes[] = {
+	{
+		.width = 1280,
+		.height = 800,
+		.hts = 1488,
+		.vts_def = OV01A10_VTS_DEF,
+		.vts_min = OV01A10_VTS_MIN,
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(sensor_1280x800_setting),
+			.regs = sensor_1280x800_setting,
+		},
+		.link_freq_index = OV01A10_LINK_FREQ_400MHZ_INDEX,
+	},
+};
+
+struct ov01a10 {
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_ctrl_handler ctrl_handler;
+
+	/* V4L2 Controls */
+	struct v4l2_ctrl *link_freq;
+	struct v4l2_ctrl *pixel_rate;
+	struct v4l2_ctrl *vblank;
+	struct v4l2_ctrl *hblank;
+	struct v4l2_ctrl *exposure;
+
+	/* Current mode */
+	const struct ov01a10_mode *cur_mode;
+
+	/* To serialize asynchronus callbacks */
+	struct mutex mutex;
+
+	/* Streaming on/off */
+	bool streaming;
+};
+
+static inline struct ov01a10 *to_ov01a10(struct v4l2_subdev *subdev)
+{
+	return container_of(subdev, struct ov01a10, sd);
+}
+
+static int ov01a10_read_reg(struct ov01a10 *ov01a10, u16 reg, u16 len, u32 *val)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&ov01a10->sd);
+	struct i2c_msg msgs[2];
+	u8 addr_buf[2];
+	u8 data_buf[4] = {0};
+	int ret = 0;
+
+	if (len > sizeof(data_buf))
+		return -EINVAL;
+
+	put_unaligned_be16(reg, addr_buf);
+	msgs[0].addr = client->addr;
+	msgs[0].flags = 0;
+	msgs[0].len = sizeof(addr_buf);
+	msgs[0].buf = addr_buf;
+	msgs[1].addr = client->addr;
+	msgs[1].flags = I2C_M_RD;
+	msgs[1].len = len;
+	msgs[1].buf = &data_buf[sizeof(data_buf) - len];
+
+	ret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));
+
+	if (ret != ARRAY_SIZE(msgs))
+		return ret < 0 ? ret : -EIO;
+
+	*val = get_unaligned_be32(data_buf);
+
+	return 0;
+}
+
+static int ov01a10_write_reg(struct ov01a10 *ov01a10, u16 reg, u16 len, u32 val)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&ov01a10->sd);
+	u8 buf[6];
+	int ret = 0;
+
+	if (len > 4)
+		return -EINVAL;
+
+	put_unaligned_be16(reg, buf);
+	put_unaligned_be32(val << 8 * (4 - len), buf + 2);
+
+	ret = i2c_master_send(client, buf, len + 2);
+	if (ret != len + 2)
+		return ret < 0 ? ret : -EIO;
+
+	return 0;
+}
+
+static int ov01a10_write_reg_list(struct ov01a10 *ov01a10,
+				  const struct ov01a10_reg_list *r_list)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&ov01a10->sd);
+	unsigned int i;
+	int ret = 0;
+
+	for (i = 0; i < r_list->num_of_regs; i++) {
+		ret = ov01a10_write_reg(ov01a10, r_list->regs[i].address, 1,
+					r_list->regs[i].val);
+		if (ret) {
+			dev_err_ratelimited(&client->dev,
+					    "write reg 0x%4.4x return err = %d",
+					    r_list->regs[i].address, ret);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int ov01a10_update_digital_gain(struct ov01a10 *ov01a10, u32 d_gain)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&ov01a10->sd);
+	u32 real = d_gain << 6;
+	int ret = 0;
+
+	ret = ov01a10_write_reg(ov01a10, OV01A10_REG_DIGILAL_GAIN_B, 3, real);
+	if (ret) {
+		dev_err(&client->dev, "failed to set OV01A10_REG_DIGITAL_GAIN_B");
+		return ret;
+	}
+	ret = ov01a10_write_reg(ov01a10, OV01A10_REG_DIGITAL_GAIN_GB, 3, real);
+	if (ret) {
+		dev_err(&client->dev, "failed to set OV01A10_REG_DIGITAL_GAIN_GB");
+		return ret;
+	}
+	ret = ov01a10_write_reg(ov01a10, OV01A10_REG_DIGITAL_GAIN_GR, 3, real);
+	if (ret) {
+		dev_err(&client->dev, "failed to set OV01A10_REG_DIGITAL_GAIN_GR");
+		return ret;
+	}
+
+	ret = ov01a10_write_reg(ov01a10, OV01A10_REG_DIGITAL_GAIN_R, 3, real);
+	if (ret) {
+		dev_err(&client->dev, "failed to set OV01A10_REG_DIGITAL_GAIN_R");
+		return ret;
+	}
+	return ret;
+}
+
+static int ov01a10_test_pattern(struct ov01a10 *ov01a10, u32 pattern)
+{
+	if (pattern)
+		pattern = (pattern - 1) << OV01A10_TEST_PATTERN_BAR_SHIFT |
+			  OV01A10_TEST_PATTERN_ENABLE;
+
+	return ov01a10_write_reg(ov01a10, OV01A10_REG_TEST_PATTERN, 1, pattern);
+}
+
+static int ov01a10_set_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct ov01a10 *ov01a10 = container_of(ctrl->handler,
+					     struct ov01a10, ctrl_handler);
+	struct i2c_client *client = v4l2_get_subdevdata(&ov01a10->sd);
+	s64 exposure_max;
+	int ret = 0;
+
+	/* Propagate change of current control to all related controls */
+	if (ctrl->id == V4L2_CID_VBLANK) {
+		/* Update max exposure while meeting expected vblanking */
+		exposure_max = ov01a10->cur_mode->height + ctrl->val -
+			       OV01A10_EXPOSURE_MAX_MARGIN;
+		__v4l2_ctrl_modify_range(ov01a10->exposure,
+					 ov01a10->exposure->minimum,
+					 exposure_max, ov01a10->exposure->step,
+					 exposure_max);
+	}
+
+	/* V4L2 controls values will be applied only when power is already up */
+	if (!pm_runtime_get_if_in_use(&client->dev))
+		return 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_ANALOGUE_GAIN:
+		ret = ov01a10_write_reg(ov01a10, OV01A10_REG_ANALOG_GAIN, 2,
+					ctrl->val);
+		break;
+
+	case V4L2_CID_DIGITAL_GAIN:
+		ret = ov01a10_update_digital_gain(ov01a10, ctrl->val);
+		break;
+
+	case V4L2_CID_EXPOSURE:
+		ret = ov01a10_write_reg(ov01a10, OV01A10_REG_EXPOSURE, 2,
+					ctrl->val);
+		break;
+
+	case V4L2_CID_VBLANK:
+		ret = ov01a10_write_reg(ov01a10, OV01A10_REG_VTS, 2,
+					ov01a10->cur_mode->height + ctrl->val);
+		break;
+
+	case V4L2_CID_TEST_PATTERN:
+		ret = ov01a10_test_pattern(ov01a10, ctrl->val);
+		break;
+
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	pm_runtime_put(&client->dev);
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops ov01a10_ctrl_ops = {
+	.s_ctrl = ov01a10_set_ctrl,
+};
+
+static int ov01a10_init_controls(struct ov01a10 *ov01a10)
+{
+	struct v4l2_ctrl_handler *ctrl_hdlr;
+	const struct ov01a10_mode *cur_mode;
+	s64 exposure_max, h_blank;
+	u32 vblank_min, vblank_max, vblank_default;
+	int size;
+	int ret = 0;
+
+	ctrl_hdlr = &ov01a10->ctrl_handler;
+	ret = v4l2_ctrl_handler_init(ctrl_hdlr, 8);
+	if (ret)
+		return ret;
+
+	ctrl_hdlr->lock = &ov01a10->mutex;
+	cur_mode = ov01a10->cur_mode;
+	size = ARRAY_SIZE(link_freq_menu_items);
+
+	ov01a10->link_freq = v4l2_ctrl_new_int_menu(ctrl_hdlr,
+						    &ov01a10_ctrl_ops,
+						    V4L2_CID_LINK_FREQ,
+						    size - 1, 0,
+						    link_freq_menu_items);
+	if (ov01a10->link_freq)
+		ov01a10->link_freq->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	ov01a10->pixel_rate = v4l2_ctrl_new_std(ctrl_hdlr, &ov01a10_ctrl_ops,
+						V4L2_CID_PIXEL_RATE, 0,
+						OV01A10_SCLK, 1, OV01A10_SCLK);
+
+	vblank_min = cur_mode->vts_min - cur_mode->height;
+	vblank_max = OV01A10_VTS_MAX - cur_mode->height;
+	vblank_default = cur_mode->vts_def - cur_mode->height;
+	ov01a10->vblank = v4l2_ctrl_new_std(ctrl_hdlr, &ov01a10_ctrl_ops,
+					    V4L2_CID_VBLANK, vblank_min,
+					    vblank_max, 1, vblank_default);
+
+	h_blank = cur_mode->hts - cur_mode->width;
+	ov01a10->hblank = v4l2_ctrl_new_std(ctrl_hdlr, &ov01a10_ctrl_ops,
+					    V4L2_CID_HBLANK, h_blank, h_blank,
+					    1, h_blank);
+	if (ov01a10->hblank)
+		ov01a10->hblank->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	v4l2_ctrl_new_std(ctrl_hdlr, &ov01a10_ctrl_ops, V4L2_CID_ANALOGUE_GAIN,
+			  OV01A10_ANAL_GAIN_MIN, OV01A10_ANAL_GAIN_MAX,
+			  OV01A10_ANAL_GAIN_STEP, OV01A10_ANAL_GAIN_MIN);
+	v4l2_ctrl_new_std(ctrl_hdlr, &ov01a10_ctrl_ops, V4L2_CID_DIGITAL_GAIN,
+			  OV01A10_DGTL_GAIN_MIN, OV01A10_DGTL_GAIN_MAX,
+			  OV01A10_DGTL_GAIN_STEP, OV01A10_DGTL_GAIN_DEFAULT);
+	exposure_max = cur_mode->vts_def - OV01A10_EXPOSURE_MAX_MARGIN;
+	ov01a10->exposure = v4l2_ctrl_new_std(ctrl_hdlr, &ov01a10_ctrl_ops,
+					      V4L2_CID_EXPOSURE,
+					      OV01A10_EXPOSURE_MIN,
+					      exposure_max,
+					      OV01A10_EXPOSURE_STEP,
+					      exposure_max);
+	v4l2_ctrl_new_std_menu_items(ctrl_hdlr, &ov01a10_ctrl_ops,
+				     V4L2_CID_TEST_PATTERN,
+				     ARRAY_SIZE(ov01a10_test_pattern_menu) - 1,
+				     0, 0, ov01a10_test_pattern_menu);
+	if (ctrl_hdlr->error)
+		return ctrl_hdlr->error;
+
+	ov01a10->sd.ctrl_handler = ctrl_hdlr;
+
+	return 0;
+}
+
+static void ov01a10_update_pad_format(const struct ov01a10_mode *mode,
+				      struct v4l2_mbus_framefmt *fmt)
+{
+	fmt->width = mode->width;
+	fmt->height = mode->height;
+	fmt->code = MEDIA_BUS_FMT_SBGGR10_1X10;
+	fmt->field = V4L2_FIELD_NONE;
+}
+
+static int ov01a10_start_streaming(struct ov01a10 *ov01a10)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&ov01a10->sd);
+	const struct ov01a10_reg_list *reg_list;
+	int link_freq_index;
+	int ret = 0;
+	link_freq_index = ov01a10->cur_mode->link_freq_index;
+	reg_list = &link_freq_configs[link_freq_index].reg_list;
+	ret = ov01a10_write_reg_list(ov01a10, reg_list);
+	if (ret) {
+		dev_err(&client->dev, "failed to set plls");
+		return ret;
+	}
+
+	reg_list = &ov01a10->cur_mode->reg_list;
+	ret = ov01a10_write_reg_list(ov01a10, reg_list);
+	if (ret) {
+		dev_err(&client->dev, "failed to set mode");
+		return ret;
+	}
+
+	ret = __v4l2_ctrl_handler_setup(ov01a10->sd.ctrl_handler);
+	if (ret)
+		return ret;
+
+	ret = ov01a10_write_reg(ov01a10, OV01A10_REG_MODE_SELECT, 1,
+				OV01A10_MODE_STREAMING);
+	if (ret)
+		dev_err(&client->dev, "failed to start streaming");
+
+	return ret;
+}
+
+static void ov01a10_stop_streaming(struct ov01a10 *ov01a10)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&ov01a10->sd);
+	int ret = 0;
+
+	ret = ov01a10_write_reg(ov01a10, OV01A10_REG_MODE_SELECT, 1,
+				OV01A10_MODE_STANDBY);
+	if (ret)
+		dev_err(&client->dev, "failed to stop streaming");
+}
+
+static int ov01a10_set_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct ov01a10 *ov01a10 = to_ov01a10(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = 0;
+
+	if (ov01a10->streaming == enable)
+		return 0;
+
+	mutex_lock(&ov01a10->mutex);
+	if (enable) {
+		ret = pm_runtime_get_sync(&client->dev);
+		if (ret < 0) {
+			pm_runtime_put_noidle(&client->dev);
+			mutex_unlock(&ov01a10->mutex);
+			return ret;
+		}
+
+		ret = ov01a10_start_streaming(ov01a10);
+		if (ret) {
+			enable = 0;
+			ov01a10_stop_streaming(ov01a10);
+			pm_runtime_put(&client->dev);
+		}
+	} else {
+		ov01a10_stop_streaming(ov01a10);
+		pm_runtime_put(&client->dev);
+	}
+
+	ov01a10->streaming = enable;
+	mutex_unlock(&ov01a10->mutex);
+
+	return ret;
+}
+
+static int __maybe_unused ov01a10_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov01a10 *ov01a10 = to_ov01a10(sd);
+
+	mutex_lock(&ov01a10->mutex);
+	if (ov01a10->streaming)
+		ov01a10_stop_streaming(ov01a10);
+
+	mutex_unlock(&ov01a10->mutex);
+
+	return 0;
+}
+
+static int __maybe_unused ov01a10_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov01a10 *ov01a10 = to_ov01a10(sd);
+	int ret = 0;
+
+	mutex_lock(&ov01a10->mutex);
+	if (!ov01a10->streaming)
+		goto exit;
+
+	ret = ov01a10_start_streaming(ov01a10);
+	if (ret) {
+		ov01a10->streaming = false;
+		ov01a10_stop_streaming(ov01a10);
+	}
+
+exit:
+	mutex_unlock(&ov01a10->mutex);
+	return ret;
+}
+
+static int ov01a10_set_format(struct v4l2_subdev *sd,
+			      struct v4l2_subdev_state *sd_state,
+			      struct v4l2_subdev_format *fmt)
+{
+	struct ov01a10 *ov01a10 = to_ov01a10(sd);
+	const struct ov01a10_mode *mode;
+	s32 vblank_def, h_blank;
+
+	mode = v4l2_find_nearest_size(supported_modes,
+				      ARRAY_SIZE(supported_modes), width,
+				      height, fmt->format.width,
+				      fmt->format.height);
+
+	mutex_lock(&ov01a10->mutex);
+	ov01a10_update_pad_format(mode, &fmt->format);
+	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {
+		*v4l2_subdev_get_try_format(sd, sd_state, fmt->pad) = fmt->format;
+	} else {
+		ov01a10->cur_mode = mode;
+		__v4l2_ctrl_s_ctrl(ov01a10->link_freq, mode->link_freq_index);
+		__v4l2_ctrl_s_ctrl_int64(ov01a10->pixel_rate, OV01A10_SCLK);
+
+		/* Update limits and set FPS to default */
+		vblank_def = mode->vts_def - mode->height;
+		__v4l2_ctrl_modify_range(ov01a10->vblank,
+					 mode->vts_min - mode->height,
+					 OV01A10_VTS_MAX - mode->height, 1,
+					 vblank_def);
+		__v4l2_ctrl_s_ctrl(ov01a10->vblank, vblank_def);
+		h_blank = mode->hts - mode->width;
+		__v4l2_ctrl_modify_range(ov01a10->hblank, h_blank, h_blank, 1,
+					 h_blank);
+	}
+	mutex_unlock(&ov01a10->mutex);
+
+	return 0;
+}
+
+static int ov01a10_get_format(struct v4l2_subdev *sd,
+			      struct v4l2_subdev_state *sd_state,
+			      struct v4l2_subdev_format *fmt)
+{
+	struct ov01a10 *ov01a10 = to_ov01a10(sd);
+
+	mutex_lock(&ov01a10->mutex);
+	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY)
+		fmt->format = *v4l2_subdev_get_try_format(&ov01a10->sd,
+							  sd_state, fmt->pad);
+	else
+		ov01a10_update_pad_format(ov01a10->cur_mode, &fmt->format);
+
+	mutex_unlock(&ov01a10->mutex);
+
+	return 0;
+}
+
+static int ov01a10_enum_mbus_code(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_state *sd_state,
+				  struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->index > 0)
+		return -EINVAL;
+
+	code->code = MEDIA_BUS_FMT_SBGGR10_1X10;
+
+	return 0;
+}
+
+static int ov01a10_enum_frame_size(struct v4l2_subdev *sd,
+				   struct v4l2_subdev_state *sd_state,
+				   struct v4l2_subdev_frame_size_enum *fse)
+{
+	if (fse->index >= ARRAY_SIZE(supported_modes))
+		return -EINVAL;
+
+	if (fse->code != MEDIA_BUS_FMT_SBGGR10_1X10)
+		return -EINVAL;
+
+	fse->min_width = supported_modes[fse->index].width;
+	fse->max_width = fse->min_width;
+	fse->min_height = supported_modes[fse->index].height;
+	fse->max_height = fse->min_height;
+
+	return 0;
+}
+
+static int ov01a10_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct ov01a10 *ov01a10 = to_ov01a10(sd);
+
+	mutex_lock(&ov01a10->mutex);
+	ov01a10_update_pad_format(&supported_modes[0],
+				  v4l2_subdev_get_try_format(sd, fh->state, 0));
+	mutex_unlock(&ov01a10->mutex);
+
+	return 0;
+}
+
+static const struct v4l2_subdev_video_ops ov01a10_video_ops = {
+	.s_stream = ov01a10_set_stream,
+};
+
+static const struct v4l2_subdev_pad_ops ov01a10_pad_ops = {
+	.set_fmt = ov01a10_set_format,
+	.get_fmt = ov01a10_get_format,
+	.enum_mbus_code = ov01a10_enum_mbus_code,
+	.enum_frame_size = ov01a10_enum_frame_size,
+};
+
+static const struct v4l2_subdev_ops ov01a10_subdev_ops = {
+	.video = &ov01a10_video_ops,
+	.pad = &ov01a10_pad_ops,
+};
+
+static const struct media_entity_operations ov01a10_subdev_entity_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+static const struct v4l2_subdev_internal_ops ov01a10_internal_ops = {
+	.open = ov01a10_open,
+};
+
+static int ov01a10_identify_module(struct ov01a10 *ov01a10)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&ov01a10->sd);
+	int ret;
+	u32 val;
+
+	ret = ov01a10_read_reg(ov01a10, OV01A10_REG_CHIP_ID, 3, &val);
+	if (ret)
+		return ret;
+
+	if (val != OV01A10_CHIP_ID) {
+		dev_err(&client->dev, "chip id mismatch: %x!=%x",
+			OV01A10_CHIP_ID, val);
+		return -ENXIO;
+	}
+
+	return 0;
+}
+
+static int ov01a10_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov01a10 *ov01a10 = to_ov01a10(sd);
+
+	v4l2_async_unregister_subdev(sd);
+	media_entity_cleanup(&sd->entity);
+	v4l2_ctrl_handler_free(sd->ctrl_handler);
+	pm_runtime_disable(&client->dev);
+	mutex_destroy(&ov01a10->mutex);
+
+	return 0;
+}
+
+static int ov01a10_probe(struct i2c_client *client)
+{
+	struct ov01a10 *ov01a10;
+	int ret = 0;
+
+	ov01a10 = devm_kzalloc(&client->dev, sizeof(*ov01a10), GFP_KERNEL);
+	if (!ov01a10) {
+		ret = -ENOMEM;
+		goto probe_error_ret;
+	}
+
+	v4l2_i2c_subdev_init(&ov01a10->sd, client, &ov01a10_subdev_ops);
+
+	ret = ov01a10_identify_module(ov01a10);
+	if (ret) {
+		dev_err(&client->dev, "failed to find sensor: %d", ret);
+		goto probe_error_ret;
+	}
+
+	mutex_init(&ov01a10->mutex);
+	ov01a10->cur_mode = &supported_modes[0];
+	ret = ov01a10_init_controls(ov01a10);
+	if (ret) {
+		dev_err(&client->dev, "failed to init controls: %d", ret);
+		goto probe_error_v4l2_ctrl_handler_free;
+	}
+
+	ov01a10->sd.internal_ops = &ov01a10_internal_ops;
+	ov01a10->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	ov01a10->sd.entity.ops = &ov01a10_subdev_entity_ops;
+	ov01a10->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;
+	ov01a10->pad.flags = MEDIA_PAD_FL_SOURCE;
+	ret = media_entity_pads_init(&ov01a10->sd.entity, 1, &ov01a10->pad);
+	if (ret) {
+		dev_err(&client->dev, "failed to init entity pads: %d", ret);
+		goto probe_error_v4l2_ctrl_handler_free;
+	}
+
+	ret = v4l2_async_register_subdev_sensor(&ov01a10->sd);
+	if (ret < 0) {
+		dev_err(&client->dev, "failed to register V4L2 subdev: %d",
+			ret);
+		goto probe_error_media_entity_cleanup;
+	}
+
+	/*
+	 * Device is already turned on by i2c-core with ACPI domain PM.
+	 * Enable runtime PM and turn off the device.
+	 */
+	pm_runtime_set_active(&client->dev);
+	pm_runtime_enable(&client->dev);
+	pm_runtime_idle(&client->dev);
+
+	return 0;
+
+probe_error_media_entity_cleanup:
+	media_entity_cleanup(&ov01a10->sd.entity);
+
+probe_error_v4l2_ctrl_handler_free:
+	v4l2_ctrl_handler_free(ov01a10->sd.ctrl_handler);
+	mutex_destroy(&ov01a10->mutex);
+
+probe_error_ret:
+	return ret;
+}
+
+static const struct dev_pm_ops ov01a10_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(ov01a10_suspend, ov01a10_resume)
+};
+
+#ifdef CONFIG_ACPI
+static const struct acpi_device_id ov01a10_acpi_ids[] = {
+	{"OVTI01A0"},
+	{}
+};
+
+MODULE_DEVICE_TABLE(acpi, ov01a10_acpi_ids);
+#endif
+
+static struct i2c_driver ov01a10_i2c_driver = {
+	.driver = {
+		.name = "ov01a10",
+		.pm = &ov01a10_pm_ops,
+		.acpi_match_table = ACPI_PTR(ov01a10_acpi_ids),
+	},
+	.probe_new = ov01a10_probe,
+	.remove = ov01a10_remove,
+};
+
+module_i2c_driver(ov01a10_i2c_driver);
+
+MODULE_AUTHOR("Wang Yating <yating.wang@intel.com>");
+MODULE_DESCRIPTION("OmniVision OV01A10 sensor driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/i2c/ov01a1s.c b/drivers/media/i2c/ov01a1s.c
new file mode 100644
index 000000000000..d13e2398f4ad
--- /dev/null
+++ b/drivers/media/i2c/ov01a1s.c
@@ -0,0 +1,1017 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (c) 2020-2022 Intel Corporation.
+
+#include <asm/unaligned.h>
+#include <linux/acpi.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/version.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-fwnode.h>
+#if IS_ENABLED(CONFIG_INTEL_SKL_INT3472)
+#include <linux/clk.h>
+#include <linux/gpio/consumer.h>
+#elif IS_ENABLED(CONFIG_POWER_CTRL_LOGIC)
+#include "power_ctrl_logic.h"
+#endif
+
+#define OV01A1S_LINK_FREQ_400MHZ	400000000ULL
+#define OV01A1S_SCLK			40000000LL
+#define OV01A1S_MCLK			19200000
+#define OV01A1S_DATA_LANES		1
+#define OV01A1S_RGB_DEPTH		10
+
+#define OV01A1S_REG_CHIP_ID		0x300a
+#define OV01A1S_CHIP_ID			0x560141
+
+#define OV01A1S_REG_MODE_SELECT		0x0100
+#define OV01A1S_MODE_STANDBY		0x00
+#define OV01A1S_MODE_STREAMING		0x01
+
+/* vertical-timings from sensor */
+#define OV01A1S_REG_VTS			0x380e
+#define OV01A1S_VTS_DEF			0x0380
+#define OV01A1S_VTS_MIN			0x0380
+#define OV01A1S_VTS_MAX			0xffff
+
+/* Exposure controls from sensor */
+#define OV01A1S_REG_EXPOSURE		0x3501
+#define OV01A1S_EXPOSURE_MIN		4
+#define OV01A1S_EXPOSURE_MAX_MARGIN	8
+#define OV01A1S_EXPOSURE_STEP		1
+
+/* Analog gain controls from sensor */
+#define OV01A1S_REG_ANALOG_GAIN		0x3508
+#define OV01A1S_ANAL_GAIN_MIN		0x100
+#define OV01A1S_ANAL_GAIN_MAX		0xffff
+#define OV01A1S_ANAL_GAIN_STEP		1
+
+/* Digital gain controls from sensor */
+#define OV01A1S_REG_DIGILAL_GAIN_B	0x350A
+#define OV01A1S_REG_DIGITAL_GAIN_GB	0x3510
+#define OV01A1S_REG_DIGITAL_GAIN_GR	0x3513
+#define OV01A1S_REG_DIGITAL_GAIN_R	0x3516
+#define OV01A1S_DGTL_GAIN_MIN		0
+#define OV01A1S_DGTL_GAIN_MAX		0x3ffff
+#define OV01A1S_DGTL_GAIN_STEP		1
+#define OV01A1S_DGTL_GAIN_DEFAULT	1024
+
+/* Test Pattern Control */
+#define OV01A1S_REG_TEST_PATTERN		0x4503
+#define OV01A1S_TEST_PATTERN_ENABLE	BIT(7)
+#define OV01A1S_TEST_PATTERN_BAR_SHIFT	0
+
+enum {
+	OV01A1S_LINK_FREQ_400MHZ_INDEX,
+};
+
+struct ov01a1s_reg {
+	u16 address;
+	u8 val;
+};
+
+struct ov01a1s_reg_list {
+	u32 num_of_regs;
+	const struct ov01a1s_reg *regs;
+};
+
+struct ov01a1s_link_freq_config {
+	const struct ov01a1s_reg_list reg_list;
+};
+
+struct ov01a1s_mode {
+	/* Frame width in pixels */
+	u32 width;
+
+	/* Frame height in pixels */
+	u32 height;
+
+	/* Horizontal timining size */
+	u32 hts;
+
+	/* Default vertical timining size */
+	u32 vts_def;
+
+	/* Min vertical timining size */
+	u32 vts_min;
+
+	/* Link frequency needed for this resolution */
+	u32 link_freq_index;
+
+	/* Sensor register settings for this resolution */
+	const struct ov01a1s_reg_list reg_list;
+};
+
+static const struct ov01a1s_reg mipi_data_rate_720mbps[] = {
+};
+
+static const struct ov01a1s_reg sensor_1296x800_setting[] = {
+	{0x0103, 0x01},
+	{0x0302, 0x00},
+	{0x0303, 0x06},
+	{0x0304, 0x01},
+	{0x0305, 0x90},
+	{0x0306, 0x00},
+	{0x0308, 0x01},
+	{0x0309, 0x00},
+	{0x030c, 0x01},
+	{0x0322, 0x01},
+	{0x0323, 0x06},
+	{0x0324, 0x01},
+	{0x0325, 0x68},
+	{0x3002, 0xa1},
+	{0x301e, 0xf0},
+	{0x3022, 0x01},
+	{0x3501, 0x03},
+	{0x3502, 0x78},
+	{0x3504, 0x0c},
+	{0x3508, 0x01},
+	{0x3509, 0x00},
+	{0x3601, 0xc0},
+	{0x3603, 0x71},
+	{0x3610, 0x68},
+	{0x3611, 0x86},
+	{0x3640, 0x10},
+	{0x3641, 0x80},
+	{0x3642, 0xdc},
+	{0x3646, 0x55},
+	{0x3647, 0x57},
+	{0x364b, 0x00},
+	{0x3653, 0x10},
+	{0x3655, 0x00},
+	{0x3656, 0x00},
+	{0x365f, 0x0f},
+	{0x3661, 0x45},
+	{0x3662, 0x24},
+	{0x3663, 0x11},
+	{0x3664, 0x07},
+	{0x3709, 0x34},
+	{0x370b, 0x6f},
+	{0x3714, 0x22},
+	{0x371b, 0x27},
+	{0x371c, 0x67},
+	{0x371d, 0xa7},
+	{0x371e, 0xe7},
+	{0x3730, 0x81},
+	{0x3733, 0x10},
+	{0x3734, 0x40},
+	{0x3737, 0x04},
+	{0x3739, 0x1c},
+	{0x3767, 0x00},
+	{0x376c, 0x81},
+	{0x3772, 0x14},
+	{0x37c2, 0x04},
+	{0x37d8, 0x03},
+	{0x37d9, 0x0c},
+	{0x37e0, 0x00},
+	{0x37e1, 0x08},
+	{0x37e2, 0x10},
+	{0x37e3, 0x04},
+	{0x37e4, 0x04},
+	{0x37e5, 0x03},
+	{0x37e6, 0x04},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0x00},
+	{0x3804, 0x05},
+	{0x3805, 0x0f},
+	{0x3806, 0x03},
+	{0x3807, 0x2f},
+	{0x3808, 0x05},
+	{0x3809, 0x00},
+	{0x380a, 0x03},
+	{0x380b, 0x1e},
+	{0x380c, 0x05},
+	{0x380d, 0xd0},
+	{0x380e, 0x03},
+	{0x380f, 0x80},
+	{0x3810, 0x00},
+	{0x3811, 0x09},
+	{0x3812, 0x00},
+	{0x3813, 0x08},
+	{0x3814, 0x01},
+	{0x3815, 0x01},
+	{0x3816, 0x01},
+	{0x3817, 0x01},
+	{0x3820, 0xa8},
+	{0x3822, 0x03},
+	{0x3832, 0x28},
+	{0x3833, 0x10},
+	{0x3b00, 0x00},
+	{0x3c80, 0x00},
+	{0x3c88, 0x02},
+	{0x3c8c, 0x07},
+	{0x3c8d, 0x40},
+	{0x3cc7, 0x80},
+	{0x4000, 0xc3},
+	{0x4001, 0xe0},
+	{0x4003, 0x40},
+	{0x4008, 0x02},
+	{0x4009, 0x19},
+	{0x400a, 0x01},
+	{0x400b, 0x6c},
+	{0x4011, 0x00},
+	{0x4041, 0x00},
+	{0x4300, 0xff},
+	{0x4301, 0x00},
+	{0x4302, 0x0f},
+	{0x4503, 0x00},
+	{0x4601, 0x50},
+	{0x481f, 0x34},
+	{0x4825, 0x33},
+	{0x4837, 0x14},
+	{0x4881, 0x40},
+	{0x4883, 0x01},
+	{0x4890, 0x00},
+	{0x4901, 0x00},
+	{0x4902, 0x00},
+	{0x4b00, 0x2a},
+	{0x4b0d, 0x00},
+	{0x450a, 0x04},
+	{0x450b, 0x00},
+	{0x5000, 0x65},
+	{0x5004, 0x00},
+	{0x5080, 0x40},
+	{0x5200, 0x18},
+	{0x4837, 0x14},
+	{0x0305, 0xf4},
+	{0x0325, 0xc2},
+	{0x3808, 0x05},
+	{0x3809, 0x10},
+	{0x380a, 0x03},
+	{0x380b, 0x1e},
+	{0x3810, 0x00},
+	{0x3811, 0x00},
+	{0x3812, 0x00},
+	{0x3813, 0x09},
+	{0x3820, 0x88},
+	{0x373d, 0x24},
+};
+
+static const char * const ov01a1s_test_pattern_menu[] = {
+	"Disabled",
+	"Color Bar",
+	"Top-Bottom Darker Color Bar",
+	"Right-Left Darker Color Bar",
+	"Color Bar type 4",
+};
+
+static const s64 link_freq_menu_items[] = {
+	OV01A1S_LINK_FREQ_400MHZ,
+};
+
+static const struct ov01a1s_link_freq_config link_freq_configs[] = {
+	[OV01A1S_LINK_FREQ_400MHZ_INDEX] = {
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(mipi_data_rate_720mbps),
+			.regs = mipi_data_rate_720mbps,
+		}
+	},
+};
+
+static const struct ov01a1s_mode supported_modes[] = {
+	{
+		.width = 1296,
+		.height = 798,
+		.hts = 1488,
+		.vts_def = OV01A1S_VTS_DEF,
+		.vts_min = OV01A1S_VTS_MIN,
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(sensor_1296x800_setting),
+			.regs = sensor_1296x800_setting,
+		},
+		.link_freq_index = OV01A1S_LINK_FREQ_400MHZ_INDEX,
+	},
+};
+
+struct ov01a1s {
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_ctrl_handler ctrl_handler;
+
+	/* V4L2 Controls */
+	struct v4l2_ctrl *link_freq;
+	struct v4l2_ctrl *pixel_rate;
+	struct v4l2_ctrl *vblank;
+	struct v4l2_ctrl *hblank;
+	struct v4l2_ctrl *exposure;
+
+	/* Current mode */
+	const struct ov01a1s_mode *cur_mode;
+
+	/* To serialize asynchronus callbacks */
+	struct mutex mutex;
+
+	/* i2c client */
+	struct i2c_client *client;
+
+#if IS_ENABLED(CONFIG_INTEL_SKL_INT3472)
+	/* GPIO for reset */
+	struct gpio_desc *reset_gpio;
+	/* GPIO for powerdown */
+	struct gpio_desc *powerdown_gpio;
+	/* GPIO for clock enable */
+	struct gpio_desc *clken_gpio;
+	/* GPIO for privacy LED */
+	struct gpio_desc *pled_gpio;
+#endif
+
+	/* Streaming on/off */
+	bool streaming;
+};
+
+static inline struct ov01a1s *to_ov01a1s(struct v4l2_subdev *subdev)
+{
+	return container_of(subdev, struct ov01a1s, sd);
+}
+
+static void ov01a1s_set_power(struct ov01a1s *ov01a1s, int on)
+{
+#if IS_ENABLED(CONFIG_INTEL_SKL_INT3472)
+	if (!(ov01a1s->reset_gpio && ov01a1s->powerdown_gpio))
+		return;
+	gpiod_set_value_cansleep(ov01a1s->reset_gpio, on);
+	gpiod_set_value_cansleep(ov01a1s->powerdown_gpio, on);
+	gpiod_set_value_cansleep(ov01a1s->clken_gpio, on);
+	gpiod_set_value_cansleep(ov01a1s->pled_gpio, on);
+	msleep(20);
+#elif IS_ENABLED(CONFIG_POWER_CTRL_LOGIC)
+	power_ctrl_logic_set_power(on);
+#endif
+}
+
+static int ov01a1s_read_reg(struct ov01a1s *ov01a1s, u16 reg, u16 len, u32 *val)
+{
+	struct i2c_client *client = ov01a1s->client;
+	struct i2c_msg msgs[2];
+	u8 addr_buf[2];
+	u8 data_buf[4] = {0};
+	int ret = 0;
+
+	if (len > sizeof(data_buf))
+		return -EINVAL;
+
+	put_unaligned_be16(reg, addr_buf);
+	msgs[0].addr = client->addr;
+	msgs[0].flags = 0;
+	msgs[0].len = sizeof(addr_buf);
+	msgs[0].buf = addr_buf;
+	msgs[1].addr = client->addr;
+	msgs[1].flags = I2C_M_RD;
+	msgs[1].len = len;
+	msgs[1].buf = &data_buf[sizeof(data_buf) - len];
+
+	ret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));
+	if (ret != ARRAY_SIZE(msgs))
+		return ret < 0 ? ret : -EIO;
+
+	*val = get_unaligned_be32(data_buf);
+
+	return 0;
+}
+
+static int ov01a1s_write_reg(struct ov01a1s *ov01a1s, u16 reg, u16 len, u32 val)
+{
+	struct i2c_client *client = ov01a1s->client;
+	u8 buf[6];
+	int ret = 0;
+
+	if (len > 4)
+		return -EINVAL;
+
+	put_unaligned_be16(reg, buf);
+	put_unaligned_be32(val << 8 * (4 - len), buf + 2);
+
+	ret = i2c_master_send(client, buf, len + 2);
+	if (ret != len + 2)
+		return ret < 0 ? ret : -EIO;
+
+	return 0;
+}
+
+static int ov01a1s_write_reg_list(struct ov01a1s *ov01a1s,
+				  const struct ov01a1s_reg_list *r_list)
+{
+	struct i2c_client *client = ov01a1s->client;
+	unsigned int i;
+	int ret = 0;
+
+	for (i = 0; i < r_list->num_of_regs; i++) {
+		ret = ov01a1s_write_reg(ov01a1s, r_list->regs[i].address, 1,
+					r_list->regs[i].val);
+		if (ret) {
+			dev_err_ratelimited(&client->dev,
+					    "write reg 0x%4.4x return err = %d",
+					    r_list->regs[i].address, ret);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int ov01a1s_update_digital_gain(struct ov01a1s *ov01a1s, u32 d_gain)
+{
+	struct i2c_client *client = ov01a1s->client;
+	u32 real = d_gain << 6;
+	int ret = 0;
+
+	ret = ov01a1s_write_reg(ov01a1s, OV01A1S_REG_DIGILAL_GAIN_B, 3, real);
+	if (ret) {
+		dev_err(&client->dev, "failed to set OV01A1S_REG_DIGITAL_GAIN_B");
+		return ret;
+	}
+	ret = ov01a1s_write_reg(ov01a1s, OV01A1S_REG_DIGITAL_GAIN_GB, 3, real);
+	if (ret) {
+		dev_err(&client->dev, "failed to set OV01A1S_REG_DIGITAL_GAIN_GB");
+		return ret;
+	}
+	ret = ov01a1s_write_reg(ov01a1s, OV01A1S_REG_DIGITAL_GAIN_GR, 3, real);
+	if (ret) {
+		dev_err(&client->dev, "failed to set OV01A1S_REG_DIGITAL_GAIN_GR");
+		return ret;
+	}
+
+	ret = ov01a1s_write_reg(ov01a1s, OV01A1S_REG_DIGITAL_GAIN_R, 3, real);
+	if (ret) {
+		dev_err(&client->dev, "failed to set OV01A1S_REG_DIGITAL_GAIN_R");
+		return ret;
+	}
+	return ret;
+}
+
+static int ov01a1s_test_pattern(struct ov01a1s *ov01a1s, u32 pattern)
+{
+	if (pattern)
+		pattern = (pattern - 1) << OV01A1S_TEST_PATTERN_BAR_SHIFT |
+			  OV01A1S_TEST_PATTERN_ENABLE;
+
+	return ov01a1s_write_reg(ov01a1s, OV01A1S_REG_TEST_PATTERN, 1, pattern);
+}
+
+static int ov01a1s_set_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct ov01a1s *ov01a1s = container_of(ctrl->handler,
+					     struct ov01a1s, ctrl_handler);
+	struct i2c_client *client = ov01a1s->client;
+	s64 exposure_max;
+	int ret = 0;
+
+	/* Propagate change of current control to all related controls */
+	if (ctrl->id == V4L2_CID_VBLANK) {
+		/* Update max exposure while meeting expected vblanking */
+		exposure_max = ov01a1s->cur_mode->height + ctrl->val -
+			       OV01A1S_EXPOSURE_MAX_MARGIN;
+		__v4l2_ctrl_modify_range(ov01a1s->exposure,
+					 ov01a1s->exposure->minimum,
+					 exposure_max, ov01a1s->exposure->step,
+					 exposure_max);
+	}
+
+	/* V4L2 controls values will be applied only when power is already up */
+	if (!pm_runtime_get_if_in_use(&client->dev))
+		return 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_ANALOGUE_GAIN:
+		ret = ov01a1s_write_reg(ov01a1s, OV01A1S_REG_ANALOG_GAIN, 2,
+					ctrl->val);
+		break;
+
+	case V4L2_CID_DIGITAL_GAIN:
+		ret = ov01a1s_update_digital_gain(ov01a1s, ctrl->val);
+		break;
+
+	case V4L2_CID_EXPOSURE:
+		ret = ov01a1s_write_reg(ov01a1s, OV01A1S_REG_EXPOSURE, 2,
+					ctrl->val);
+		break;
+
+	case V4L2_CID_VBLANK:
+		ret = ov01a1s_write_reg(ov01a1s, OV01A1S_REG_VTS, 2,
+					ov01a1s->cur_mode->height + ctrl->val);
+		break;
+
+	case V4L2_CID_TEST_PATTERN:
+		ret = ov01a1s_test_pattern(ov01a1s, ctrl->val);
+		break;
+
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	pm_runtime_put(&client->dev);
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops ov01a1s_ctrl_ops = {
+	.s_ctrl = ov01a1s_set_ctrl,
+};
+
+static int ov01a1s_init_controls(struct ov01a1s *ov01a1s)
+{
+	struct v4l2_ctrl_handler *ctrl_hdlr;
+	const struct ov01a1s_mode *cur_mode;
+	s64 exposure_max, h_blank;
+	u32 vblank_min, vblank_max, vblank_default;
+	int size;
+	int ret = 0;
+
+	ctrl_hdlr = &ov01a1s->ctrl_handler;
+	ret = v4l2_ctrl_handler_init(ctrl_hdlr, 8);
+	if (ret)
+		return ret;
+
+	ctrl_hdlr->lock = &ov01a1s->mutex;
+	cur_mode = ov01a1s->cur_mode;
+	size = ARRAY_SIZE(link_freq_menu_items);
+
+	ov01a1s->link_freq = v4l2_ctrl_new_int_menu(ctrl_hdlr,
+						    &ov01a1s_ctrl_ops,
+						    V4L2_CID_LINK_FREQ,
+						    size - 1, 0,
+						    link_freq_menu_items);
+	if (ov01a1s->link_freq)
+		ov01a1s->link_freq->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	ov01a1s->pixel_rate = v4l2_ctrl_new_std(ctrl_hdlr, &ov01a1s_ctrl_ops,
+						V4L2_CID_PIXEL_RATE, 0,
+						OV01A1S_SCLK, 1, OV01A1S_SCLK);
+
+	vblank_min = cur_mode->vts_min - cur_mode->height;
+	vblank_max = OV01A1S_VTS_MAX - cur_mode->height;
+	vblank_default = cur_mode->vts_def - cur_mode->height;
+	ov01a1s->vblank = v4l2_ctrl_new_std(ctrl_hdlr, &ov01a1s_ctrl_ops,
+					    V4L2_CID_VBLANK, vblank_min,
+					    vblank_max, 1, vblank_default);
+
+	h_blank = cur_mode->hts - cur_mode->width;
+	ov01a1s->hblank = v4l2_ctrl_new_std(ctrl_hdlr, &ov01a1s_ctrl_ops,
+					    V4L2_CID_HBLANK, h_blank, h_blank,
+					    1, h_blank);
+	if (ov01a1s->hblank)
+		ov01a1s->hblank->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	v4l2_ctrl_new_std(ctrl_hdlr, &ov01a1s_ctrl_ops, V4L2_CID_ANALOGUE_GAIN,
+			  OV01A1S_ANAL_GAIN_MIN, OV01A1S_ANAL_GAIN_MAX,
+			  OV01A1S_ANAL_GAIN_STEP, OV01A1S_ANAL_GAIN_MIN);
+	v4l2_ctrl_new_std(ctrl_hdlr, &ov01a1s_ctrl_ops, V4L2_CID_DIGITAL_GAIN,
+			  OV01A1S_DGTL_GAIN_MIN, OV01A1S_DGTL_GAIN_MAX,
+			  OV01A1S_DGTL_GAIN_STEP, OV01A1S_DGTL_GAIN_DEFAULT);
+	exposure_max = cur_mode->vts_def - OV01A1S_EXPOSURE_MAX_MARGIN;
+	ov01a1s->exposure = v4l2_ctrl_new_std(ctrl_hdlr, &ov01a1s_ctrl_ops,
+					      V4L2_CID_EXPOSURE,
+					      OV01A1S_EXPOSURE_MIN,
+					      exposure_max,
+					      OV01A1S_EXPOSURE_STEP,
+					      exposure_max);
+	v4l2_ctrl_new_std_menu_items(ctrl_hdlr, &ov01a1s_ctrl_ops,
+				     V4L2_CID_TEST_PATTERN,
+				     ARRAY_SIZE(ov01a1s_test_pattern_menu) - 1,
+				     0, 0, ov01a1s_test_pattern_menu);
+	if (ctrl_hdlr->error)
+		return ctrl_hdlr->error;
+
+	ov01a1s->sd.ctrl_handler = ctrl_hdlr;
+
+	return 0;
+}
+
+static void ov01a1s_update_pad_format(const struct ov01a1s_mode *mode,
+				      struct v4l2_mbus_framefmt *fmt)
+{
+	fmt->width = mode->width;
+	fmt->height = mode->height;
+	fmt->code = MEDIA_BUS_FMT_SGRBG10_1X10;
+	fmt->field = V4L2_FIELD_NONE;
+}
+
+static int ov01a1s_start_streaming(struct ov01a1s *ov01a1s)
+{
+	struct i2c_client *client = ov01a1s->client;
+	const struct ov01a1s_reg_list *reg_list;
+	int link_freq_index;
+	int ret = 0;
+	ov01a1s_set_power(ov01a1s, 1);
+	link_freq_index = ov01a1s->cur_mode->link_freq_index;
+	reg_list = &link_freq_configs[link_freq_index].reg_list;
+	ret = ov01a1s_write_reg_list(ov01a1s, reg_list);
+	if (ret) {
+		dev_err(&client->dev, "failed to set plls");
+		return ret;
+	}
+
+	reg_list = &ov01a1s->cur_mode->reg_list;
+	ret = ov01a1s_write_reg_list(ov01a1s, reg_list);
+	if (ret) {
+		dev_err(&client->dev, "failed to set mode");
+		return ret;
+	}
+
+	ret = __v4l2_ctrl_handler_setup(ov01a1s->sd.ctrl_handler);
+	if (ret)
+		return ret;
+
+	ret = ov01a1s_write_reg(ov01a1s, OV01A1S_REG_MODE_SELECT, 1,
+				OV01A1S_MODE_STREAMING);
+	if (ret)
+		dev_err(&client->dev, "failed to start streaming");
+
+	return ret;
+}
+
+static void ov01a1s_stop_streaming(struct ov01a1s *ov01a1s)
+{
+	struct i2c_client *client = ov01a1s->client;
+	int ret = 0;
+
+	ret = ov01a1s_write_reg(ov01a1s, OV01A1S_REG_MODE_SELECT, 1,
+				OV01A1S_MODE_STANDBY);
+	if (ret)
+		dev_err(&client->dev, "failed to stop streaming");
+	ov01a1s_set_power(ov01a1s, 0);
+}
+
+static int ov01a1s_set_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct ov01a1s *ov01a1s = to_ov01a1s(sd);
+	struct i2c_client *client = ov01a1s->client;
+	int ret = 0;
+
+	if (ov01a1s->streaming == enable)
+		return 0;
+
+	mutex_lock(&ov01a1s->mutex);
+	if (enable) {
+		ret = pm_runtime_get_sync(&client->dev);
+		if (ret < 0) {
+			pm_runtime_put_noidle(&client->dev);
+			mutex_unlock(&ov01a1s->mutex);
+			return ret;
+		}
+
+		ret = ov01a1s_start_streaming(ov01a1s);
+		if (ret) {
+			enable = 0;
+			ov01a1s_stop_streaming(ov01a1s);
+			pm_runtime_put(&client->dev);
+		}
+	} else {
+		ov01a1s_stop_streaming(ov01a1s);
+		pm_runtime_put(&client->dev);
+	}
+
+	ov01a1s->streaming = enable;
+	mutex_unlock(&ov01a1s->mutex);
+
+	return ret;
+}
+
+static int __maybe_unused ov01a1s_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov01a1s *ov01a1s = to_ov01a1s(sd);
+
+	mutex_lock(&ov01a1s->mutex);
+	if (ov01a1s->streaming)
+		ov01a1s_stop_streaming(ov01a1s);
+
+	mutex_unlock(&ov01a1s->mutex);
+
+	return 0;
+}
+
+static int __maybe_unused ov01a1s_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov01a1s *ov01a1s = to_ov01a1s(sd);
+	int ret = 0;
+
+	mutex_lock(&ov01a1s->mutex);
+	if (!ov01a1s->streaming)
+		goto exit;
+
+	ret = ov01a1s_start_streaming(ov01a1s);
+	if (ret) {
+		ov01a1s->streaming = false;
+		ov01a1s_stop_streaming(ov01a1s);
+	}
+
+exit:
+	mutex_unlock(&ov01a1s->mutex);
+	return ret;
+}
+
+static int ov01a1s_set_format(struct v4l2_subdev *sd,
+			      struct v4l2_subdev_state *sd_state,
+			      struct v4l2_subdev_format *fmt)
+{
+	struct ov01a1s *ov01a1s = to_ov01a1s(sd);
+	const struct ov01a1s_mode *mode;
+	s32 vblank_def, h_blank;
+
+	mode = v4l2_find_nearest_size(supported_modes,
+				      ARRAY_SIZE(supported_modes), width,
+				      height, fmt->format.width,
+				      fmt->format.height);
+
+	mutex_lock(&ov01a1s->mutex);
+	ov01a1s_update_pad_format(mode, &fmt->format);
+	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {
+		*v4l2_subdev_get_try_format(sd, sd_state, fmt->pad) = fmt->format;
+	} else {
+		ov01a1s->cur_mode = mode;
+		__v4l2_ctrl_s_ctrl(ov01a1s->link_freq, mode->link_freq_index);
+		__v4l2_ctrl_s_ctrl_int64(ov01a1s->pixel_rate, OV01A1S_SCLK);
+
+		/* Update limits and set FPS to default */
+		vblank_def = mode->vts_def - mode->height;
+		__v4l2_ctrl_modify_range(ov01a1s->vblank,
+					 mode->vts_min - mode->height,
+					 OV01A1S_VTS_MAX - mode->height, 1,
+					 vblank_def);
+		__v4l2_ctrl_s_ctrl(ov01a1s->vblank, vblank_def);
+		h_blank = mode->hts - mode->width;
+		__v4l2_ctrl_modify_range(ov01a1s->hblank, h_blank, h_blank, 1,
+					 h_blank);
+	}
+	mutex_unlock(&ov01a1s->mutex);
+
+	return 0;
+}
+
+static int ov01a1s_get_format(struct v4l2_subdev *sd,
+			      struct v4l2_subdev_state *sd_state,
+			      struct v4l2_subdev_format *fmt)
+{
+	struct ov01a1s *ov01a1s = to_ov01a1s(sd);
+
+	mutex_lock(&ov01a1s->mutex);
+	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY)
+		fmt->format = *v4l2_subdev_get_try_format(&ov01a1s->sd,
+							  sd_state, fmt->pad);
+	else
+		ov01a1s_update_pad_format(ov01a1s->cur_mode, &fmt->format);
+
+	mutex_unlock(&ov01a1s->mutex);
+
+	return 0;
+}
+
+static int ov01a1s_enum_mbus_code(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_state *sd_state,
+				  struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->index > 0)
+		return -EINVAL;
+
+	code->code = MEDIA_BUS_FMT_SGRBG10_1X10;
+
+	return 0;
+}
+
+static int ov01a1s_enum_frame_size(struct v4l2_subdev *sd,
+				   struct v4l2_subdev_state *sd_state,
+				   struct v4l2_subdev_frame_size_enum *fse)
+{
+	if (fse->index >= ARRAY_SIZE(supported_modes))
+		return -EINVAL;
+
+	if (fse->code != MEDIA_BUS_FMT_SGRBG10_1X10)
+		return -EINVAL;
+
+	fse->min_width = supported_modes[fse->index].width;
+	fse->max_width = fse->min_width;
+	fse->min_height = supported_modes[fse->index].height;
+	fse->max_height = fse->min_height;
+
+	return 0;
+}
+
+static int ov01a1s_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct ov01a1s *ov01a1s = to_ov01a1s(sd);
+
+	mutex_lock(&ov01a1s->mutex);
+	ov01a1s_update_pad_format(&supported_modes[0],
+				  v4l2_subdev_get_try_format(sd, fh->state, 0));
+	mutex_unlock(&ov01a1s->mutex);
+
+	return 0;
+}
+
+static const struct v4l2_subdev_video_ops ov01a1s_video_ops = {
+	.s_stream = ov01a1s_set_stream,
+};
+
+static const struct v4l2_subdev_pad_ops ov01a1s_pad_ops = {
+	.set_fmt = ov01a1s_set_format,
+	.get_fmt = ov01a1s_get_format,
+	.enum_mbus_code = ov01a1s_enum_mbus_code,
+	.enum_frame_size = ov01a1s_enum_frame_size,
+};
+
+static const struct v4l2_subdev_ops ov01a1s_subdev_ops = {
+	.video = &ov01a1s_video_ops,
+	.pad = &ov01a1s_pad_ops,
+};
+
+static const struct media_entity_operations ov01a1s_subdev_entity_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+static const struct v4l2_subdev_internal_ops ov01a1s_internal_ops = {
+	.open = ov01a1s_open,
+};
+
+static int ov01a1s_identify_module(struct ov01a1s *ov01a1s)
+{
+	struct i2c_client *client = ov01a1s->client;
+	int ret;
+	u32 val;
+
+	ret = ov01a1s_read_reg(ov01a1s, OV01A1S_REG_CHIP_ID, 3, &val);
+	if (ret)
+		return ret;
+
+	if (val != OV01A1S_CHIP_ID) {
+		dev_err(&client->dev, "chip id mismatch: %x!=%x",
+			OV01A1S_CHIP_ID, val);
+		return -ENXIO;
+	}
+
+	return 0;
+}
+
+static int ov01a1s_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov01a1s *ov01a1s = to_ov01a1s(sd);
+
+	v4l2_async_unregister_subdev(sd);
+	media_entity_cleanup(&sd->entity);
+	v4l2_ctrl_handler_free(sd->ctrl_handler);
+	pm_runtime_disable(&client->dev);
+	mutex_destroy(&ov01a1s->mutex);
+
+	return 0;
+}
+
+#if IS_ENABLED(CONFIG_INTEL_SKL_INT3472)
+static int ov01a1s_parse_dt(struct ov01a1s *ov01a1s)
+{
+	struct device *dev = &ov01a1s->client->dev;
+	int ret;
+
+	ov01a1s->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	ret = PTR_ERR_OR_ZERO(ov01a1s->reset_gpio);
+	if (ret < 0) {
+		dev_err(dev, "error while getting reset gpio: %d\n", ret);
+		return -EPROBE_DEFER;
+	}
+
+	ov01a1s->powerdown_gpio = devm_gpiod_get(dev, "powerdown", GPIOD_OUT_HIGH);
+	ret = PTR_ERR_OR_ZERO(ov01a1s->powerdown_gpio);
+	if (ret < 0) {
+		dev_err(dev, "error while getting powerdown gpio: %d\n", ret);
+		return -EPROBE_DEFER;
+	}
+
+	ov01a1s->clken_gpio = devm_gpiod_get(dev, "clken", GPIOD_OUT_HIGH);
+	ret = PTR_ERR_OR_ZERO(ov01a1s->clken_gpio);
+	if (ret < 0) {
+		dev_err(dev, "error while getting clken_gpio gpio: %d\n", ret);
+		return -EPROBE_DEFER;
+	}
+
+	ov01a1s->pled_gpio = devm_gpiod_get(dev, "pled", GPIOD_OUT_HIGH);
+	ret = PTR_ERR_OR_ZERO(ov01a1s->pled_gpio);
+	if (ret < 0) {
+		dev_err(dev, "error while getting pled gpio: %d\n", ret);
+		return -EPROBE_DEFER;
+	}
+
+	return 0;
+}
+#endif
+
+static int ov01a1s_probe(struct i2c_client *client)
+{
+	struct ov01a1s *ov01a1s;
+	int ret = 0;
+
+	ov01a1s = devm_kzalloc(&client->dev, sizeof(*ov01a1s), GFP_KERNEL);
+	if (!ov01a1s)
+		return -ENOMEM;
+	ov01a1s->client = client;
+
+#if IS_ENABLED(CONFIG_INTEL_SKL_INT3472)
+	if (ret == -EAGAIN)
+		ret = ov01a1s_parse_dt(ov01a1s);
+#elif IS_ENABLED(CONFIG_POWER_CTRL_LOGIC)
+	if (ret == -EAGAIN)
+		ret = power_ctrl_logic_set_power(1);
+#endif
+	if (ret == -EAGAIN)
+		return -EPROBE_DEFER;
+	else if (ret)
+		return ret;
+
+	ov01a1s_set_power(ov01a1s, 1);
+
+	v4l2_i2c_subdev_init(&ov01a1s->sd, client, &ov01a1s_subdev_ops);
+	ret = ov01a1s_identify_module(ov01a1s);
+	if (ret) {
+		dev_err(&client->dev, "failed to find sensor: %d", ret);
+		goto probe_error_power_off;
+	}
+
+	mutex_init(&ov01a1s->mutex);
+	ov01a1s->cur_mode = &supported_modes[0];
+	ret = ov01a1s_init_controls(ov01a1s);
+	if (ret) {
+		dev_err(&client->dev, "failed to init controls: %d", ret);
+		goto probe_error_v4l2_ctrl_handler_free;
+	}
+
+	ov01a1s->sd.internal_ops = &ov01a1s_internal_ops;
+	ov01a1s->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	ov01a1s->sd.entity.ops = &ov01a1s_subdev_entity_ops;
+	ov01a1s->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;
+	ov01a1s->pad.flags = MEDIA_PAD_FL_SOURCE;
+	ret = media_entity_pads_init(&ov01a1s->sd.entity, 1, &ov01a1s->pad);
+	if (ret) {
+		dev_err(&client->dev, "failed to init entity pads: %d", ret);
+		goto probe_error_v4l2_ctrl_handler_free;
+	}
+
+	ret = v4l2_async_register_subdev_sensor(&ov01a1s->sd);
+	if (ret < 0) {
+		dev_err(&client->dev, "failed to register V4L2 subdev: %d",
+			ret);
+		goto probe_error_media_entity_cleanup;
+	}
+
+	/*
+	 * Device is already turned on by i2c-core with ACPI domain PM.
+	 * Enable runtime PM and turn off the device.
+	 */
+	pm_runtime_set_active(&client->dev);
+	pm_runtime_enable(&client->dev);
+	pm_runtime_idle(&client->dev);
+
+	ov01a1s_set_power(ov01a1s, 0);
+	return 0;
+
+probe_error_media_entity_cleanup:
+	media_entity_cleanup(&ov01a1s->sd.entity);
+
+probe_error_v4l2_ctrl_handler_free:
+	v4l2_ctrl_handler_free(ov01a1s->sd.ctrl_handler);
+	mutex_destroy(&ov01a1s->mutex);
+
+probe_error_power_off:
+	ov01a1s_set_power(ov01a1s, 0);
+	return ret;
+}
+
+static const struct dev_pm_ops ov01a1s_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(ov01a1s_suspend, ov01a1s_resume)
+};
+
+#ifdef CONFIG_ACPI
+static const struct acpi_device_id ov01a1s_acpi_ids[] = {
+	{ "OVTI01AS" },
+	{}
+};
+
+MODULE_DEVICE_TABLE(acpi, ov01a1s_acpi_ids);
+#endif
+
+static struct i2c_driver ov01a1s_i2c_driver = {
+	.driver = {
+		.name = "ov01a1s",
+		.pm = &ov01a1s_pm_ops,
+		.acpi_match_table = ACPI_PTR(ov01a1s_acpi_ids),
+	},
+	.probe_new = ov01a1s_probe,
+	.remove = ov01a1s_remove,
+};
+
+module_i2c_driver(ov01a1s_i2c_driver);
+
+MODULE_AUTHOR("Xu, Chongyang <chongyang.xu@intel.com>");
+MODULE_AUTHOR("Lai, Jim <jim.lai@intel.com>");
+MODULE_AUTHOR("Qiu, Tianshu <tian.shu.qiu@intel.com>");
+MODULE_AUTHOR("Shawn Tu <shawnx.tu@intel.com>");
+MODULE_AUTHOR("Bingbu Cao <bingbu.cao@intel.com>");
+MODULE_DESCRIPTION("OmniVision OV01A1S sensor driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/i2c/ov02c10.c b/drivers/media/i2c/ov02c10.c
new file mode 100644
index 000000000000..6bc22db97065
--- /dev/null
+++ b/drivers/media/i2c/ov02c10.c
@@ -0,0 +1,1304 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (c) 2022 Intel Corporation.
+
+#include <asm/unaligned.h>
+#include <linux/acpi.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/version.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-fwnode.h>
+
+#define OV02C10_LINK_FREQ_400MHZ	400000000ULL
+#define OV02C10_SCLK			80000000LL
+#define OV02C10_MCLK			19200000
+#define OV02C10_DATA_LANES		1
+#define OV02C10_RGB_DEPTH		10
+
+#define OV02C10_REG_CHIP_ID		0x300a
+#define OV02C10_CHIP_ID			0x560243
+
+#define OV02C10_REG_MODE_SELECT		0x0100
+#define OV02C10_MODE_STANDBY		0x00
+#define OV02C10_MODE_STREAMING		0x01
+
+/* vertical-timings from sensor */
+#define OV02C10_REG_VTS			0x380e
+#define OV02C10_VTS_MAX			0xffff
+
+/* Exposure controls from sensor */
+#define OV02C10_REG_EXPOSURE		0x3501
+#define OV02C10_EXPOSURE_MIN		4
+#define OV02C10_EXPOSURE_MAX_MARGIN	8
+#define OV02C10_EXPOSURE_STEP		1
+
+/* Analog gain controls from sensor */
+#define OV02C10_REG_ANALOG_GAIN		0x3508
+#define OV02C10_ANAL_GAIN_MIN		0x10
+#define OV02C10_ANAL_GAIN_MAX		0xf8
+#define OV02C10_ANAL_GAIN_STEP		1
+#define OV02C10_ANAL_GAIN_DEFAULT	0x10
+
+/* Digital gain controls from sensor */
+#define OV02C10_REG_DIGILAL_GAIN	0x350a
+#define OV02C10_DGTL_GAIN_MIN		0x0400
+#define OV02C10_DGTL_GAIN_MAX		0x3fff
+#define OV02C10_DGTL_GAIN_STEP		1
+#define OV02C10_DGTL_GAIN_DEFAULT	0x0400
+
+/* Test Pattern Control */
+#define OV02C10_REG_TEST_PATTERN		0x4503
+#define OV02C10_TEST_PATTERN_ENABLE	BIT(7)
+#define OV02C10_TEST_PATTERN_BAR_SHIFT	0
+
+enum {
+	OV02C10_LINK_FREQ_400MHZ_INDEX,
+};
+
+struct ov02c10_reg {
+	u16 address;
+	u8 val;
+};
+
+struct ov02c10_reg_list {
+	u32 num_of_regs;
+	const struct ov02c10_reg *regs;
+};
+
+struct ov02c10_link_freq_config {
+	const struct ov02c10_reg_list reg_list;
+};
+
+struct ov02c10_mode {
+	/* Frame width in pixels */
+	u32 width;
+
+	/* Frame height in pixels */
+	u32 height;
+
+	/* Horizontal timining size */
+	u32 hts;
+
+	/* Default vertical timining size */
+	u32 vts_def;
+
+	/* Min vertical timining size */
+	u32 vts_min;
+
+	/* Link frequency needed for this resolution */
+	u32 link_freq_index;
+
+	/* MIPI lanes used */
+	u8 mipi_lanes;
+
+	/* Sensor register settings for this resolution */
+	const struct ov02c10_reg_list reg_list;
+};
+
+struct mipi_camera_link_ssdb {
+	u8 version;
+	u8 sku;
+	u8 guid_csi2[16];
+	u8 devfunction;
+	u8 bus;
+	u32 dphylinkenfuses;
+	u32 clockdiv;
+	u8 link;
+	u8 lanes;
+	u32 csiparams[10];
+	u32 maxlanespeed;
+	u8 sensorcalibfileidx;
+	u8 sensorcalibfileidxInMBZ[3];
+	u8 romtype;
+	u8 vcmtype;
+	u8 platforminfo;
+	u8 platformsubinfo;
+	u8 flash;
+	u8 privacyled;
+	u8 degree;
+	u8 mipilinkdefined;
+	u32 mclkspeed;
+	u8 controllogicid;
+	u8 reserved1[3];
+	u8 mclkport;
+	u8 reserved2[13];
+} __packed;
+
+static const struct ov02c10_reg mipi_data_rate_960mbps[] = {
+};
+
+static const struct ov02c10_reg sensor_1928x1092_1lane_30fps_setting[] = {
+	{0x0301, 0x08},
+	{0x0303, 0x06},
+	{0x0304, 0x01},
+	{0x0305, 0xe0},
+	{0x0313, 0x40},
+	{0x031c, 0x4f},
+	{0x301b, 0xd2},
+	{0x3020, 0x97},
+	{0x3022, 0x01},
+	{0x3026, 0xb4},
+	{0x3027, 0xe1},
+	{0x303b, 0x00},
+	{0x303c, 0x4f},
+	{0x303d, 0xe6},
+	{0x303e, 0x00},
+	{0x303f, 0x03},
+	{0x3021, 0x23},
+	{0x3501, 0x04},
+	{0x3502, 0x6c},
+	{0x3504, 0x0c},
+	{0x3507, 0x00},
+	{0x3508, 0x08},
+	{0x3509, 0x00},
+	{0x350a, 0x01},
+	{0x350b, 0x00},
+	{0x350c, 0x41},
+	{0x3600, 0x84},
+	{0x3603, 0x08},
+	{0x3610, 0x57},
+	{0x3611, 0x1b},
+	{0x3613, 0x78},
+	{0x3623, 0x00},
+	{0x3632, 0xa0},
+	{0x3642, 0xe8},
+	{0x364c, 0x70},
+	{0x365f, 0x0f},
+	{0x3708, 0x30},
+	{0x3714, 0x24},
+	{0x3725, 0x02},
+	{0x3737, 0x08},
+	{0x3739, 0x28},
+	{0x3749, 0x32},
+	{0x374a, 0x32},
+	{0x374b, 0x32},
+	{0x374c, 0x32},
+	{0x374d, 0x81},
+	{0x374e, 0x81},
+	{0x374f, 0x81},
+	{0x3752, 0x36},
+	{0x3753, 0x36},
+	{0x3754, 0x36},
+	{0x3761, 0x00},
+	{0x376c, 0x81},
+	{0x3774, 0x18},
+	{0x3776, 0x08},
+	{0x377c, 0x81},
+	{0x377d, 0x81},
+	{0x377e, 0x81},
+	{0x37a0, 0x44},
+	{0x37a6, 0x44},
+	{0x37aa, 0x0d},
+	{0x37ae, 0x00},
+	{0x37cb, 0x03},
+	{0x37cc, 0x01},
+	{0x37d8, 0x02},
+	{0x37d9, 0x10},
+	{0x37e1, 0x10},
+	{0x37e2, 0x18},
+	{0x37e3, 0x08},
+	{0x37e4, 0x08},
+	{0x37e5, 0x02},
+	{0x37e6, 0x08},
+
+	// 1928x1092
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0x00},
+	{0x3804, 0x07},
+	{0x3805, 0x8f},
+	{0x3806, 0x04},
+	{0x3807, 0x47},
+	{0x3808, 0x07},
+	{0x3809, 0x88},
+	{0x380a, 0x04},
+	{0x380b, 0x44},
+	{0x380c, 0x08},
+	{0x380d, 0xe8},
+	{0x380e, 0x04},
+	{0x380f, 0x8c},
+	{0x3810, 0x00},
+	{0x3811, 0x03},
+	{0x3812, 0x00},
+	{0x3813, 0x03},
+	{0x3814, 0x01},
+	{0x3815, 0x01},
+	{0x3816, 0x01},
+	{0x3817, 0x01},
+
+	{0x3820, 0xa8},
+	{0x3821, 0x00},
+	{0x3822, 0x80},
+	{0x3823, 0x08},
+	{0x3824, 0x00},
+	{0x3825, 0x20},
+	{0x3826, 0x00},
+	{0x3827, 0x08},
+	{0x382a, 0x00},
+	{0x382b, 0x08},
+	{0x382d, 0x00},
+	{0x382e, 0x00},
+	{0x382f, 0x23},
+	{0x3834, 0x00},
+	{0x3839, 0x00},
+	{0x383a, 0xd1},
+	{0x383e, 0x03},
+	{0x393d, 0x29},
+	{0x393f, 0x6e},
+	{0x394b, 0x06},
+	{0x394c, 0x06},
+	{0x394d, 0x08},
+	{0x394e, 0x0b},
+	{0x394f, 0x01},
+	{0x3950, 0x01},
+	{0x3951, 0x01},
+	{0x3952, 0x01},
+	{0x3953, 0x01},
+	{0x3954, 0x01},
+	{0x3955, 0x01},
+	{0x3956, 0x01},
+	{0x3957, 0x0e},
+	{0x3958, 0x08},
+	{0x3959, 0x08},
+	{0x395a, 0x08},
+	{0x395b, 0x13},
+	{0x395c, 0x09},
+	{0x395d, 0x05},
+	{0x395e, 0x02},
+	{0x395f, 0x00},
+	{0x395f, 0x00},
+	{0x3960, 0x00},
+	{0x3961, 0x00},
+	{0x3962, 0x00},
+	{0x3963, 0x00},
+	{0x3964, 0x00},
+	{0x3965, 0x00},
+	{0x3966, 0x00},
+	{0x3967, 0x00},
+	{0x3968, 0x01},
+	{0x3969, 0x01},
+	{0x396a, 0x01},
+	{0x396b, 0x01},
+	{0x396c, 0x10},
+	{0x396d, 0xf0},
+	{0x396e, 0x11},
+	{0x396f, 0x00},
+	{0x3970, 0x37},
+	{0x3971, 0x37},
+	{0x3972, 0x37},
+	{0x3973, 0x37},
+	{0x3974, 0x00},
+	{0x3975, 0x3c},
+	{0x3976, 0x3c},
+	{0x3977, 0x3c},
+	{0x3978, 0x3c},
+	{0x3c00, 0x0f},
+	{0x3c20, 0x01},
+	{0x3c21, 0x08},
+	{0x3f00, 0x8b},
+	{0x3f02, 0x0f},
+	{0x4000, 0xc3},
+	{0x4001, 0xe0},
+	{0x4002, 0x00},
+	{0x4003, 0x40},
+	{0x4008, 0x04},
+	{0x4009, 0x23},
+	{0x400a, 0x04},
+	{0x400b, 0x01},
+	{0x4077, 0x06},
+	{0x4078, 0x00},
+	{0x4079, 0x1a},
+	{0x407a, 0x7f},
+	{0x407b, 0x01},
+	{0x4080, 0x03},
+	{0x4081, 0x84},
+	{0x4308, 0x03},
+	{0x4309, 0xff},
+	{0x430d, 0x00},
+	{0x4806, 0x00},
+	{0x4813, 0x00},
+	{0x4837, 0x10},
+	{0x4857, 0x05},
+	{0x4500, 0x07},
+	{0x4501, 0x00},
+	{0x4503, 0x00},
+	{0x450a, 0x04},
+	{0x450e, 0x00},
+	{0x450f, 0x00},
+	{0x4800, 0x24},
+	{0x4900, 0x00},
+	{0x4901, 0x00},
+	{0x4902, 0x01},
+	{0x5000, 0xf5},
+	{0x5001, 0x50},
+	{0x5006, 0x00},
+	{0x5080, 0x40},
+	{0x5181, 0x2b},
+	{0x5202, 0xa3},
+	{0x5206, 0x01},
+	{0x5207, 0x00},
+	{0x520a, 0x01},
+	{0x520b, 0x00},
+	{0x365d, 0x00},
+	{0x4815, 0x40},
+	{0x4816, 0x12},
+	{0x4f00, 0x01},
+	// plls
+	{0x0303, 0x05},
+	{0x0305, 0x90},
+	{0x0316, 0x90},
+	{0x3016, 0x12},
+};
+static const struct ov02c10_reg sensor_1928x1092_2lane_30fps_setting[] = {
+	{0x0301, 0x08},
+	{0x0303, 0x06},
+	{0x0304, 0x01},
+	{0x0305, 0xe0},
+	{0x0313, 0x40},
+	{0x031c, 0x4f},
+	{0x301b, 0xf0},
+	{0x3020, 0x97},
+	{0x3022, 0x01},
+	{0x3026, 0xb4},
+	{0x3027, 0xf1},
+	{0x303b, 0x00},
+	{0x303c, 0x4f},
+	{0x303d, 0xe6},
+	{0x303e, 0x00},
+	{0x303f, 0x03},
+	{0x3021, 0x23},
+	{0x3501, 0x04},
+	{0x3502, 0x6c},
+	{0x3504, 0x0c},
+	{0x3507, 0x00},
+	{0x3508, 0x08},
+	{0x3509, 0x00},
+	{0x350a, 0x01},
+	{0x350b, 0x00},
+	{0x350c, 0x41},
+	{0x3600, 0x84},
+	{0x3603, 0x08},
+	{0x3610, 0x57},
+	{0x3611, 0x1b},
+	{0x3613, 0x78},
+	{0x3623, 0x00},
+	{0x3632, 0xa0},
+	{0x3642, 0xe8},
+	{0x364c, 0x70},
+	{0x365f, 0x0f},
+	{0x3708, 0x30},
+	{0x3714, 0x24},
+	{0x3725, 0x02},
+	{0x3737, 0x08},
+	{0x3739, 0x28},
+	{0x3749, 0x32},
+	{0x374a, 0x32},
+	{0x374b, 0x32},
+	{0x374c, 0x32},
+	{0x374d, 0x81},
+	{0x374e, 0x81},
+	{0x374f, 0x81},
+	{0x3752, 0x36},
+	{0x3753, 0x36},
+	{0x3754, 0x36},
+	{0x3761, 0x00},
+	{0x376c, 0x81},
+	{0x3774, 0x18},
+	{0x3776, 0x08},
+	{0x377c, 0x81},
+	{0x377d, 0x81},
+	{0x377e, 0x81},
+	{0x37a0, 0x44},
+	{0x37a6, 0x44},
+	{0x37aa, 0x0d},
+	{0x37ae, 0x00},
+	{0x37cb, 0x03},
+	{0x37cc, 0x01},
+	{0x37d8, 0x02},
+	{0x37d9, 0x10},
+	{0x37e1, 0x10},
+	{0x37e2, 0x18},
+	{0x37e3, 0x08},
+	{0x37e4, 0x08},
+	{0x37e5, 0x02},
+	{0x37e6, 0x08},
+
+	// 1928x1092
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0x00},
+	{0x3804, 0x07},
+	{0x3805, 0x8f},
+	{0x3806, 0x04},
+	{0x3807, 0x47},
+	{0x3808, 0x07},
+	{0x3809, 0x88},
+	{0x380a, 0x04},
+	{0x380b, 0x44},
+	{0x380c, 0x04},
+	{0x380d, 0x74},
+	{0x380e, 0x09},
+	{0x380f, 0x18},
+	{0x3810, 0x00},
+	{0x3811, 0x03},
+	{0x3812, 0x00},
+	{0x3813, 0x03},
+	{0x3814, 0x01},
+	{0x3815, 0x01},
+	{0x3816, 0x01},
+	{0x3817, 0x01},
+
+	{0x3820, 0xa8},
+	{0x3821, 0x00},
+	{0x3822, 0x80},
+	{0x3823, 0x08},
+	{0x3824, 0x00},
+	{0x3825, 0x20},
+	{0x3826, 0x00},
+	{0x3827, 0x08},
+	{0x382a, 0x00},
+	{0x382b, 0x08},
+	{0x382d, 0x00},
+	{0x382e, 0x00},
+	{0x382f, 0x23},
+	{0x3834, 0x00},
+	{0x3839, 0x00},
+	{0x383a, 0xd1},
+	{0x383e, 0x03},
+	{0x393d, 0x29},
+	{0x393f, 0x6e},
+	{0x394b, 0x06},
+	{0x394c, 0x06},
+	{0x394d, 0x08},
+	{0x394e, 0x0a},
+	{0x394f, 0x01},
+	{0x3950, 0x01},
+	{0x3951, 0x01},
+	{0x3952, 0x01},
+	{0x3953, 0x01},
+	{0x3954, 0x01},
+	{0x3955, 0x01},
+	{0x3956, 0x01},
+	{0x3957, 0x0e},
+	{0x3958, 0x08},
+	{0x3959, 0x08},
+	{0x395a, 0x08},
+	{0x395b, 0x13},
+	{0x395c, 0x09},
+	{0x395d, 0x05},
+	{0x395e, 0x02},
+	{0x395f, 0x00},
+	{0x395f, 0x00},
+	{0x3960, 0x00},
+	{0x3961, 0x00},
+	{0x3962, 0x00},
+	{0x3963, 0x00},
+	{0x3964, 0x00},
+	{0x3965, 0x00},
+	{0x3966, 0x00},
+	{0x3967, 0x00},
+	{0x3968, 0x01},
+	{0x3969, 0x01},
+	{0x396a, 0x01},
+	{0x396b, 0x01},
+	{0x396c, 0x10},
+	{0x396d, 0xf0},
+	{0x396e, 0x11},
+	{0x396f, 0x00},
+	{0x3970, 0x37},
+	{0x3971, 0x37},
+	{0x3972, 0x37},
+	{0x3973, 0x37},
+	{0x3974, 0x00},
+	{0x3975, 0x3c},
+	{0x3976, 0x3c},
+	{0x3977, 0x3c},
+	{0x3978, 0x3c},
+	{0x3c00, 0x0f},
+	{0x3c20, 0x01},
+	{0x3c21, 0x08},
+	{0x3f00, 0x8b},
+	{0x3f02, 0x0f},
+	{0x4000, 0xc3},
+	{0x4001, 0xe0},
+	{0x4002, 0x00},
+	{0x4003, 0x40},
+	{0x4008, 0x04},
+	{0x4009, 0x23},
+	{0x400a, 0x04},
+	{0x400b, 0x01},
+	{0x4041, 0x20},
+	{0x4077, 0x06},
+	{0x4078, 0x00},
+	{0x4079, 0x1a},
+	{0x407a, 0x7f},
+	{0x407b, 0x01},
+	{0x4080, 0x03},
+	{0x4081, 0x84},
+	{0x4308, 0x03},
+	{0x4309, 0xff},
+	{0x430d, 0x00},
+	{0x4806, 0x00},
+	{0x4813, 0x00},
+	{0x4837, 0x10},
+	{0x4857, 0x05},
+	{0x4884, 0x04},
+	{0x4500, 0x07},
+	{0x4501, 0x00},
+	{0x4503, 0x00},
+	{0x450a, 0x04},
+	{0x450e, 0x00},
+	{0x450f, 0x00},
+	{0x4800, 0x64},
+	{0x4900, 0x00},
+	{0x4901, 0x00},
+	{0x4902, 0x01},
+	{0x4d00, 0x03},
+	{0x4d01, 0xd8},
+	{0x4d02, 0xba},
+	{0x4d03, 0xa0},
+	{0x4d04, 0xb7},
+	{0x4d05, 0x34},
+	{0x4d0d, 0x00},
+	{0x5000, 0xfd},
+	{0x5001, 0x50},
+	{0x5006, 0x00},
+	{0x5080, 0x40},
+	{0x5181, 0x2b},
+	{0x5202, 0xa3},
+	{0x5206, 0x01},
+	{0x5207, 0x00},
+	{0x520a, 0x01},
+	{0x520b, 0x00},
+	{0x365d, 0x00},
+	{0x4815, 0x40},
+	{0x4816, 0x12},
+	{0x481f, 0x30},
+	{0x4f00, 0x01},
+	// plls
+	{0x0303, 0x05},
+	{0x0305, 0x90},
+	{0x0316, 0x90},
+	{0x3016, 0x32},
+};
+
+static const char * const ov02c10_test_pattern_menu[] = {
+	"Disabled",
+	"Color Bar",
+	"Top-Bottom Darker Color Bar",
+	"Right-Left Darker Color Bar",
+	"Color Bar type 4",
+};
+
+static const s64 link_freq_menu_items[] = {
+	OV02C10_LINK_FREQ_400MHZ,
+};
+
+static const struct ov02c10_link_freq_config link_freq_configs[] = {
+	[OV02C10_LINK_FREQ_400MHZ_INDEX] = {
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(mipi_data_rate_960mbps),
+			.regs = mipi_data_rate_960mbps,
+		}
+	},
+};
+
+static const struct ov02c10_mode supported_modes[] = {
+	{
+		.width = 1928,
+		.height = 1092,
+		.hts = 2280,
+		.vts_def = 1164,
+		.vts_min = 1164,
+		.mipi_lanes = 1,
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(sensor_1928x1092_1lane_30fps_setting),
+			.regs = sensor_1928x1092_1lane_30fps_setting,
+		},
+		.link_freq_index = OV02C10_LINK_FREQ_400MHZ_INDEX,
+	},
+	{
+		.width = 1928,
+		.height = 1092,
+		.hts = 1140,
+		.vts_def = 2328,
+		.vts_min = 2328,
+		.mipi_lanes = 2,
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(sensor_1928x1092_2lane_30fps_setting),
+			.regs = sensor_1928x1092_2lane_30fps_setting,
+		},
+		.link_freq_index = OV02C10_LINK_FREQ_400MHZ_INDEX,
+	},
+};
+
+struct ov02c10 {
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_ctrl_handler ctrl_handler;
+
+	/* V4L2 Controls */
+	struct v4l2_ctrl *link_freq;
+	struct v4l2_ctrl *pixel_rate;
+	struct v4l2_ctrl *vblank;
+	struct v4l2_ctrl *hblank;
+	struct v4l2_ctrl *exposure;
+	/* Current mode */
+	const struct ov02c10_mode *cur_mode;
+
+	/* To serialize asynchronus callbacks */
+	struct mutex mutex;
+
+	/* MIPI lanes used */
+	u8 mipi_lanes;
+
+	/* Streaming on/off */
+	bool streaming;
+};
+
+static inline struct ov02c10 *to_ov02c10(struct v4l2_subdev *subdev)
+{
+	return container_of(subdev, struct ov02c10, sd);
+}
+
+static int ov02c10_read_reg(struct ov02c10 *ov02c10, u16 reg, u16 len, u32 *val)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&ov02c10->sd);
+	struct i2c_msg msgs[2];
+	u8 addr_buf[2];
+	u8 data_buf[4] = {0};
+	int ret = 0;
+
+	if (len > sizeof(data_buf))
+		return -EINVAL;
+
+	put_unaligned_be16(reg, addr_buf);
+	msgs[0].addr = client->addr;
+	msgs[0].flags = 0;
+	msgs[0].len = sizeof(addr_buf);
+	msgs[0].buf = addr_buf;
+	msgs[1].addr = client->addr;
+	msgs[1].flags = I2C_M_RD;
+	msgs[1].len = len;
+	msgs[1].buf = &data_buf[sizeof(data_buf) - len];
+
+	ret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));
+
+	if (ret != ARRAY_SIZE(msgs))
+		return ret < 0 ? ret : -EIO;
+
+	*val = get_unaligned_be32(data_buf);
+
+	return 0;
+}
+
+static int ov02c10_write_reg(struct ov02c10 *ov02c10, u16 reg, u16 len, u32 val)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&ov02c10->sd);
+	u8 buf[6];
+	int ret = 0;
+
+	if (len > 4)
+		return -EINVAL;
+
+	put_unaligned_be16(reg, buf);
+	put_unaligned_be32(val << 8 * (4 - len), buf + 2);
+
+	ret = i2c_master_send(client, buf, len + 2);
+	if (ret != len + 2)
+		return ret < 0 ? ret : -EIO;
+
+	return 0;
+}
+
+static int ov02c10_write_reg_list(struct ov02c10 *ov02c10,
+				  const struct ov02c10_reg_list *r_list)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&ov02c10->sd);
+	unsigned int i;
+	int ret = 0;
+
+	for (i = 0; i < r_list->num_of_regs; i++) {
+		ret = ov02c10_write_reg(ov02c10, r_list->regs[i].address, 1,
+					r_list->regs[i].val);
+		if (ret) {
+			dev_err_ratelimited(&client->dev,
+					    "write reg 0x%4.4x return err = %d",
+					    r_list->regs[i].address, ret);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int ov02c10_test_pattern(struct ov02c10 *ov02c10, u32 pattern)
+{
+	if (pattern)
+		pattern = (pattern - 1) << OV02C10_TEST_PATTERN_BAR_SHIFT |
+			  OV02C10_TEST_PATTERN_ENABLE;
+
+	return ov02c10_write_reg(ov02c10, OV02C10_REG_TEST_PATTERN, 1, pattern);
+}
+
+static int ov02c10_set_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct ov02c10 *ov02c10 = container_of(ctrl->handler,
+					     struct ov02c10, ctrl_handler);
+	struct i2c_client *client = v4l2_get_subdevdata(&ov02c10->sd);
+	s64 exposure_max;
+	int ret = 0;
+
+	/* Propagate change of current control to all related controls */
+	if (ctrl->id == V4L2_CID_VBLANK) {
+		/* Update max exposure while meeting expected vblanking */
+		exposure_max = ov02c10->cur_mode->height + ctrl->val -
+			       OV02C10_EXPOSURE_MAX_MARGIN;
+		__v4l2_ctrl_modify_range(ov02c10->exposure,
+					 ov02c10->exposure->minimum,
+					 exposure_max, ov02c10->exposure->step,
+					 exposure_max);
+	}
+
+	/* V4L2 controls values will be applied only when power is already up */
+	if (!pm_runtime_get_if_in_use(&client->dev))
+		return 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_ANALOGUE_GAIN:
+		ret = ov02c10_write_reg(ov02c10, OV02C10_REG_ANALOG_GAIN, 2,
+					ctrl->val << 4);
+		break;
+
+	case V4L2_CID_DIGITAL_GAIN:
+		ret = ov02c10_write_reg(ov02c10, OV02C10_REG_DIGILAL_GAIN, 3,
+					ctrl->val << 6);
+		break;
+
+	case V4L2_CID_EXPOSURE:
+		ret = ov02c10_write_reg(ov02c10, OV02C10_REG_EXPOSURE, 2,
+					ctrl->val);
+		break;
+
+	case V4L2_CID_VBLANK:
+		ret = ov02c10_write_reg(ov02c10, OV02C10_REG_VTS, 2,
+					ov02c10->cur_mode->height + ctrl->val);
+		break;
+
+	case V4L2_CID_TEST_PATTERN:
+		ret = ov02c10_test_pattern(ov02c10, ctrl->val);
+		break;
+
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	pm_runtime_put(&client->dev);
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops ov02c10_ctrl_ops = {
+	.s_ctrl = ov02c10_set_ctrl,
+};
+
+static int ov02c10_init_controls(struct ov02c10 *ov02c10)
+{
+	struct v4l2_ctrl_handler *ctrl_hdlr;
+	const struct ov02c10_mode *cur_mode;
+	s64 exposure_max, h_blank;
+	u32 vblank_min, vblank_max, vblank_default;
+	int size;
+	int ret = 0;
+
+	ctrl_hdlr = &ov02c10->ctrl_handler;
+	ret = v4l2_ctrl_handler_init(ctrl_hdlr, 8);
+	if (ret)
+		return ret;
+
+	ctrl_hdlr->lock = &ov02c10->mutex;
+	cur_mode = ov02c10->cur_mode;
+	size = ARRAY_SIZE(link_freq_menu_items);
+
+	ov02c10->link_freq = v4l2_ctrl_new_int_menu(ctrl_hdlr,
+						    &ov02c10_ctrl_ops,
+						    V4L2_CID_LINK_FREQ,
+						    size - 1, 0,
+						    link_freq_menu_items);
+	if (ov02c10->link_freq)
+		ov02c10->link_freq->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	ov02c10->pixel_rate = v4l2_ctrl_new_std(ctrl_hdlr, &ov02c10_ctrl_ops,
+						V4L2_CID_PIXEL_RATE, 0,
+						OV02C10_SCLK, 1, OV02C10_SCLK);
+
+	vblank_min = cur_mode->vts_min - cur_mode->height;
+	vblank_max = OV02C10_VTS_MAX - cur_mode->height;
+	vblank_default = cur_mode->vts_def - cur_mode->height;
+	ov02c10->vblank = v4l2_ctrl_new_std(ctrl_hdlr, &ov02c10_ctrl_ops,
+					    V4L2_CID_VBLANK, vblank_min,
+					    vblank_max, 1, vblank_default);
+
+	h_blank = cur_mode->hts - cur_mode->width;
+	ov02c10->hblank = v4l2_ctrl_new_std(ctrl_hdlr, &ov02c10_ctrl_ops,
+					    V4L2_CID_HBLANK, h_blank, h_blank,
+					    1, h_blank);
+	if (ov02c10->hblank)
+		ov02c10->hblank->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	v4l2_ctrl_new_std(ctrl_hdlr, &ov02c10_ctrl_ops, V4L2_CID_ANALOGUE_GAIN,
+			  OV02C10_ANAL_GAIN_MIN, OV02C10_ANAL_GAIN_MAX,
+			  OV02C10_ANAL_GAIN_STEP, OV02C10_ANAL_GAIN_DEFAULT);
+	v4l2_ctrl_new_std(ctrl_hdlr, &ov02c10_ctrl_ops, V4L2_CID_DIGITAL_GAIN,
+			  OV02C10_DGTL_GAIN_MIN, OV02C10_DGTL_GAIN_MAX,
+			  OV02C10_DGTL_GAIN_STEP, OV02C10_DGTL_GAIN_DEFAULT);
+	exposure_max = cur_mode->vts_def - OV02C10_EXPOSURE_MAX_MARGIN;
+	ov02c10->exposure = v4l2_ctrl_new_std(ctrl_hdlr, &ov02c10_ctrl_ops,
+					      V4L2_CID_EXPOSURE,
+					      OV02C10_EXPOSURE_MIN,
+					      exposure_max,
+					      OV02C10_EXPOSURE_STEP,
+					      exposure_max);
+	v4l2_ctrl_new_std_menu_items(ctrl_hdlr, &ov02c10_ctrl_ops,
+				     V4L2_CID_TEST_PATTERN,
+				     ARRAY_SIZE(ov02c10_test_pattern_menu) - 1,
+				     0, 0, ov02c10_test_pattern_menu);
+	if (ctrl_hdlr->error)
+		return ctrl_hdlr->error;
+
+	ov02c10->sd.ctrl_handler = ctrl_hdlr;
+
+	return 0;
+}
+
+static void ov02c10_update_pad_format(const struct ov02c10_mode *mode,
+				      struct v4l2_mbus_framefmt *fmt)
+{
+	fmt->width = mode->width;
+	fmt->height = mode->height;
+	fmt->code = MEDIA_BUS_FMT_SGRBG10_1X10;
+	fmt->field = V4L2_FIELD_NONE;
+}
+
+static int ov02c10_start_streaming(struct ov02c10 *ov02c10)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&ov02c10->sd);
+	const struct ov02c10_reg_list *reg_list;
+	int link_freq_index;
+	int ret = 0;
+	link_freq_index = ov02c10->cur_mode->link_freq_index;
+	reg_list = &link_freq_configs[link_freq_index].reg_list;
+	ret = ov02c10_write_reg_list(ov02c10, reg_list);
+	if (ret) {
+		dev_err(&client->dev, "failed to set plls");
+		return ret;
+	}
+
+	reg_list = &ov02c10->cur_mode->reg_list;
+	ret = ov02c10_write_reg_list(ov02c10, reg_list);
+	if (ret) {
+		dev_err(&client->dev, "failed to set mode");
+		return ret;
+	}
+
+	ret = __v4l2_ctrl_handler_setup(ov02c10->sd.ctrl_handler);
+	if (ret)
+		return ret;
+
+	ret = ov02c10_write_reg(ov02c10, OV02C10_REG_MODE_SELECT, 1,
+				OV02C10_MODE_STREAMING);
+	if (ret)
+		dev_err(&client->dev, "failed to start streaming");
+
+	return ret;
+}
+
+static void ov02c10_stop_streaming(struct ov02c10 *ov02c10)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&ov02c10->sd);
+	int ret = 0;
+
+	ret = ov02c10_write_reg(ov02c10, OV02C10_REG_MODE_SELECT, 1,
+				OV02C10_MODE_STANDBY);
+	if (ret)
+		dev_err(&client->dev, "failed to stop streaming");
+}
+
+static int ov02c10_set_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct ov02c10 *ov02c10 = to_ov02c10(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = 0;
+
+	if (ov02c10->streaming == enable)
+		return 0;
+
+	mutex_lock(&ov02c10->mutex);
+	if (enable) {
+		ret = pm_runtime_get_sync(&client->dev);
+		if (ret < 0) {
+			pm_runtime_put_noidle(&client->dev);
+			mutex_unlock(&ov02c10->mutex);
+			return ret;
+		}
+
+		ret = ov02c10_start_streaming(ov02c10);
+		if (ret) {
+			enable = 0;
+			ov02c10_stop_streaming(ov02c10);
+			pm_runtime_put(&client->dev);
+		}
+	} else {
+		ov02c10_stop_streaming(ov02c10);
+		pm_runtime_put(&client->dev);
+	}
+
+	ov02c10->streaming = enable;
+	mutex_unlock(&ov02c10->mutex);
+
+	return ret;
+}
+
+static int __maybe_unused ov02c10_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov02c10 *ov02c10 = to_ov02c10(sd);
+
+	mutex_lock(&ov02c10->mutex);
+	if (ov02c10->streaming)
+		ov02c10_stop_streaming(ov02c10);
+
+	mutex_unlock(&ov02c10->mutex);
+
+	return 0;
+}
+
+static int __maybe_unused ov02c10_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov02c10 *ov02c10 = to_ov02c10(sd);
+	int ret = 0;
+
+	mutex_lock(&ov02c10->mutex);
+	if (!ov02c10->streaming)
+		goto exit;
+
+	ret = ov02c10_start_streaming(ov02c10);
+	if (ret) {
+		ov02c10->streaming = false;
+		ov02c10_stop_streaming(ov02c10);
+	}
+
+exit:
+	mutex_unlock(&ov02c10->mutex);
+	return ret;
+}
+
+static int ov02c10_set_format(struct v4l2_subdev *sd,
+			      struct v4l2_subdev_state *sd_state,
+			      struct v4l2_subdev_format *fmt)
+{
+	struct ov02c10 *ov02c10 = to_ov02c10(sd);
+	const struct ov02c10_mode *mode;
+	s32 vblank_def, h_blank;
+
+	if (ov02c10->mipi_lanes == 1)
+		mode = &supported_modes[0];
+	else if (ov02c10->mipi_lanes == 2)
+		mode = &supported_modes[1];
+	else {
+		mode = v4l2_find_nearest_size(supported_modes,
+					      ARRAY_SIZE(supported_modes),
+					      width, height, fmt->format.width,
+					      fmt->format.height);
+	}
+
+	mutex_lock(&ov02c10->mutex);
+	ov02c10_update_pad_format(mode, &fmt->format);
+	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {
+		*v4l2_subdev_get_try_format(sd, sd_state, fmt->pad) = fmt->format;
+	} else {
+		ov02c10->cur_mode = mode;
+		__v4l2_ctrl_s_ctrl(ov02c10->link_freq, mode->link_freq_index);
+		__v4l2_ctrl_s_ctrl_int64(ov02c10->pixel_rate, OV02C10_SCLK);
+
+		/* Update limits and set FPS to default */
+		vblank_def = mode->vts_def - mode->height;
+		__v4l2_ctrl_modify_range(ov02c10->vblank,
+					 mode->vts_min - mode->height,
+					 OV02C10_VTS_MAX - mode->height, 1,
+					 vblank_def);
+		__v4l2_ctrl_s_ctrl(ov02c10->vblank, vblank_def);
+		h_blank = mode->hts - mode->width;
+		__v4l2_ctrl_modify_range(ov02c10->hblank, h_blank, h_blank, 1,
+					 h_blank);
+	}
+	mutex_unlock(&ov02c10->mutex);
+
+	return 0;
+}
+
+static int ov02c10_get_format(struct v4l2_subdev *sd,
+			      struct v4l2_subdev_state *sd_state,
+			      struct v4l2_subdev_format *fmt)
+{
+	struct ov02c10 *ov02c10 = to_ov02c10(sd);
+
+	mutex_lock(&ov02c10->mutex);
+	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY)
+		fmt->format = *v4l2_subdev_get_try_format(&ov02c10->sd,
+							  sd_state, fmt->pad);
+	else
+		ov02c10_update_pad_format(ov02c10->cur_mode, &fmt->format);
+
+	mutex_unlock(&ov02c10->mutex);
+
+	return 0;
+}
+
+static int ov02c10_enum_mbus_code(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_state *sd_state,
+				  struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->index > 0)
+		return -EINVAL;
+
+	code->code = MEDIA_BUS_FMT_SGRBG10_1X10;
+
+	return 0;
+}
+
+static int ov02c10_enum_frame_size(struct v4l2_subdev *sd,
+				   struct v4l2_subdev_state *sd_state,
+				   struct v4l2_subdev_frame_size_enum *fse)
+{
+	if (fse->index >= ARRAY_SIZE(supported_modes))
+		return -EINVAL;
+
+	if (fse->code != MEDIA_BUS_FMT_SGRBG10_1X10)
+		return -EINVAL;
+
+	fse->min_width = supported_modes[fse->index].width;
+	fse->max_width = fse->min_width;
+	fse->min_height = supported_modes[fse->index].height;
+	fse->max_height = fse->min_height;
+
+	return 0;
+}
+
+static int ov02c10_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct ov02c10 *ov02c10 = to_ov02c10(sd);
+
+	mutex_lock(&ov02c10->mutex);
+	ov02c10_update_pad_format(&supported_modes[0],
+				  v4l2_subdev_get_try_format(sd, fh->state, 0));
+	mutex_unlock(&ov02c10->mutex);
+
+	return 0;
+}
+
+static const struct v4l2_subdev_video_ops ov02c10_video_ops = {
+	.s_stream = ov02c10_set_stream,
+};
+
+static const struct v4l2_subdev_pad_ops ov02c10_pad_ops = {
+	.set_fmt = ov02c10_set_format,
+	.get_fmt = ov02c10_get_format,
+	.enum_mbus_code = ov02c10_enum_mbus_code,
+	.enum_frame_size = ov02c10_enum_frame_size,
+};
+
+static const struct v4l2_subdev_ops ov02c10_subdev_ops = {
+	.video = &ov02c10_video_ops,
+	.pad = &ov02c10_pad_ops,
+};
+
+static const struct media_entity_operations ov02c10_subdev_entity_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+static const struct v4l2_subdev_internal_ops ov02c10_internal_ops = {
+	.open = ov02c10_open,
+};
+
+static void ov02c10_read_mipi_lanes(struct ov02c10 *ov02c10)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&ov02c10->sd);
+	struct mipi_camera_link_ssdb ssdb;
+	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+	struct acpi_device *adev = ACPI_COMPANION(&client->dev);
+	union acpi_object *obj;
+	acpi_status status;
+
+	ov02c10->mipi_lanes = OV02C10_DATA_LANES;
+	if (!adev) {
+		dev_info(&client->dev, "Not ACPI device\n");
+		return;
+	}
+	status = acpi_evaluate_object(adev->handle, "SSDB", NULL, &buffer);
+	if (ACPI_FAILURE(status)) {
+		dev_info(&client->dev, "ACPI fail: %d\n", -ENODEV);
+		return;
+	}
+
+	obj = buffer.pointer;
+	if (!obj) {
+		dev_info(&client->dev, "Couldn't locate ACPI buffer\n");
+		return;
+	}
+
+	if (obj->type != ACPI_TYPE_BUFFER) {
+		dev_info(&client->dev, "Not an ACPI buffer\n");
+		goto out_free_buff;
+	}
+
+	if (obj->buffer.length > sizeof(ssdb)) {
+		dev_err(&client->dev, "Given buffer is too small\n");
+		goto out_free_buff;
+	}
+	memcpy(&ssdb, obj->buffer.pointer, obj->buffer.length);
+	ov02c10->mipi_lanes = ssdb.lanes;
+
+out_free_buff:
+	kfree(buffer.pointer);
+}
+
+static int ov02c10_identify_module(struct ov02c10 *ov02c10)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&ov02c10->sd);
+	int ret;
+	u32 val;
+
+	ret = ov02c10_read_reg(ov02c10, OV02C10_REG_CHIP_ID, 3, &val);
+	if (ret)
+		return ret;
+
+	if (val != OV02C10_CHIP_ID) {
+		dev_err(&client->dev, "chip id mismatch: %x!=%x",
+			OV02C10_CHIP_ID, val);
+		return -ENXIO;
+	}
+
+	return 0;
+}
+
+static int ov02c10_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov02c10 *ov02c10 = to_ov02c10(sd);
+
+	v4l2_async_unregister_subdev(sd);
+	media_entity_cleanup(&sd->entity);
+	v4l2_ctrl_handler_free(sd->ctrl_handler);
+	pm_runtime_disable(&client->dev);
+	mutex_destroy(&ov02c10->mutex);
+
+	return 0;
+}
+
+static int ov02c10_probe(struct i2c_client *client)
+{
+	struct ov02c10 *ov02c10;
+	int ret = 0;
+
+	ov02c10 = devm_kzalloc(&client->dev, sizeof(*ov02c10), GFP_KERNEL);
+	if (!ov02c10) {
+		ret = -ENOMEM;
+		goto probe_error_ret;
+	}
+
+	v4l2_i2c_subdev_init(&ov02c10->sd, client, &ov02c10_subdev_ops);
+
+	ret = ov02c10_identify_module(ov02c10);
+	if (ret) {
+		dev_err(&client->dev, "failed to find sensor: %d", ret);
+		goto probe_error_ret;
+	}
+
+	ov02c10_read_mipi_lanes(ov02c10);
+	mutex_init(&ov02c10->mutex);
+	ov02c10->cur_mode = &supported_modes[0];
+	if (ov02c10->mipi_lanes == 2)
+		ov02c10->cur_mode = &supported_modes[1];
+	ret = ov02c10_init_controls(ov02c10);
+	if (ret) {
+		dev_err(&client->dev, "failed to init controls: %d", ret);
+		goto probe_error_v4l2_ctrl_handler_free;
+	}
+
+	ov02c10->sd.internal_ops = &ov02c10_internal_ops;
+	ov02c10->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	ov02c10->sd.entity.ops = &ov02c10_subdev_entity_ops;
+	ov02c10->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;
+	ov02c10->pad.flags = MEDIA_PAD_FL_SOURCE;
+	ret = media_entity_pads_init(&ov02c10->sd.entity, 1, &ov02c10->pad);
+	if (ret) {
+		dev_err(&client->dev, "failed to init entity pads: %d", ret);
+		goto probe_error_v4l2_ctrl_handler_free;
+	}
+
+	ret = v4l2_async_register_subdev_sensor(&ov02c10->sd);
+	if (ret < 0) {
+		dev_err(&client->dev, "failed to register V4L2 subdev: %d",
+			ret);
+		goto probe_error_media_entity_cleanup;
+	}
+
+	/*
+	 * Device is already turned on by i2c-core with ACPI domain PM.
+	 * Enable runtime PM and turn off the device.
+	 */
+	pm_runtime_set_active(&client->dev);
+	pm_runtime_enable(&client->dev);
+	pm_runtime_idle(&client->dev);
+
+	return 0;
+
+probe_error_media_entity_cleanup:
+	media_entity_cleanup(&ov02c10->sd.entity);
+
+probe_error_v4l2_ctrl_handler_free:
+	v4l2_ctrl_handler_free(ov02c10->sd.ctrl_handler);
+	mutex_destroy(&ov02c10->mutex);
+
+probe_error_ret:
+	return ret;
+}
+
+static const struct dev_pm_ops ov02c10_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(ov02c10_suspend, ov02c10_resume)
+};
+
+#ifdef CONFIG_ACPI
+static const struct acpi_device_id ov02c10_acpi_ids[] = {
+	{"OVTI02C1"},
+	{}
+};
+
+MODULE_DEVICE_TABLE(acpi, ov02c10_acpi_ids);
+#endif
+
+static struct i2c_driver ov02c10_i2c_driver = {
+	.driver = {
+		.name = "ov02c10",
+		.pm = &ov02c10_pm_ops,
+		.acpi_match_table = ACPI_PTR(ov02c10_acpi_ids),
+	},
+	.probe_new = ov02c10_probe,
+	.remove = ov02c10_remove,
+};
+
+module_i2c_driver(ov02c10_i2c_driver);
+
+MODULE_AUTHOR("Hao Yao <hao.yao@intel.com>");
+MODULE_DESCRIPTION("OmniVision OV02C10 sensor driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/i2c/ov13858_intel.c b/drivers/media/i2c/ov13858_intel.c
new file mode 100644
index 000000000000..11bf93018bab
--- /dev/null
+++ b/drivers/media/i2c/ov13858_intel.c
@@ -0,0 +1,2067 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (c) 2022 Intel Corporation.
+
+#include <linux/acpi.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-fwnode.h>
+
+#define OV13858_REG_VALUE_08BIT		1
+#define OV13858_REG_VALUE_16BIT		2
+#define OV13858_REG_VALUE_24BIT		3
+
+#define OV13858_REG_MODE_SELECT		0x0100
+#define OV13858_MODE_STANDBY		0x00
+#define OV13858_MODE_STREAMING		0x01
+
+#define OV13858_REG_SOFTWARE_RST	0x0103
+#define OV13858_SOFTWARE_RST		0x01
+
+/* PLL1 generates PCLK and MIPI_PHY_CLK */
+#define OV13858_REG_PLL1_CTRL_0		0x0300
+#define OV13858_REG_PLL1_CTRL_1		0x0301
+#define OV13858_REG_PLL1_CTRL_2		0x0302
+#define OV13858_REG_PLL1_CTRL_3		0x0303
+#define OV13858_REG_PLL1_CTRL_4		0x0304
+#define OV13858_REG_PLL1_CTRL_5		0x0305
+
+/* PLL2 generates DAC_CLK, SCLK and SRAM_CLK */
+#define OV13858_REG_PLL2_CTRL_B		0x030b
+#define OV13858_REG_PLL2_CTRL_C		0x030c
+#define OV13858_REG_PLL2_CTRL_D		0x030d
+#define OV13858_REG_PLL2_CTRL_E		0x030e
+#define OV13858_REG_PLL2_CTRL_F		0x030f
+#define OV13858_REG_PLL2_CTRL_12	0x0312
+#define OV13858_REG_MIPI_SC_CTRL0	0x3016
+#define OV13858_REG_MIPI_SC_CTRL1	0x3022
+
+/* Chip ID */
+#define OV13858_REG_CHIP_ID		0x300a
+#define OV13858_CHIP_ID			0x00d855
+
+/* V_TIMING internal */
+#define OV13858_REG_VTS			0x380e
+#define OV13858_VTS_30FPS		0x0c8e /* 30 fps */
+#define OV13858_VTS_60FPS		0x0648 /* 60 fps */
+#define OV13858_VTS_MAX			0x7fff
+
+/* HBLANK control - read only */
+#define OV13858_PPL_270MHZ		2244
+#define OV13858_PPL_540MHZ		4488
+
+/* Exposure control */
+#define OV13858_REG_EXPOSURE		0x3500
+#define OV13858_EXPOSURE_MIN		4
+#define OV13858_EXPOSURE_STEP		1
+#define OV13858_EXPOSURE_DEFAULT	0x640
+
+/* Format1 control */
+#define OV13858_REG_FORMAT1		0x3820
+#define OV13858_FORMAT1_DFT		0xA0
+
+/* Analog gain control */
+#define OV13858_REG_ANALOG_GAIN		0x3508
+#define OV13858_ANA_GAIN_MIN		0
+#define OV13858_ANA_GAIN_MAX		0x1fff
+#define OV13858_ANA_GAIN_STEP		1
+#define OV13858_ANA_GAIN_DEFAULT	0x80
+
+/* Digital gain control */
+#define OV13858_REG_B_MWB_GAIN		0x5100
+#define OV13858_REG_G_MWB_GAIN		0x5102
+#define OV13858_REG_R_MWB_GAIN		0x5104
+#define OV13858_DGTL_GAIN_MIN		0
+#define OV13858_DGTL_GAIN_MAX		16384	/* Max = 16 X */
+#define OV13858_DGTL_GAIN_DEFAULT	1024	/* Default gain = 1 X */
+#define OV13858_DGTL_GAIN_STEP		1	/* Each step = 1/1024 */
+
+/* Test Pattern Control */
+#define OV13858_REG_TEST_PATTERN	0x4503
+#define OV13858_TEST_PATTERN_ENABLE	BIT(7)
+#define OV13858_TEST_PATTERN_MASK	0xfc
+
+/* Number of frames to skip */
+#define OV13858_NUM_OF_SKIP_FRAMES	2
+
+struct ov13858_reg {
+	u16 address;
+	u8 val;
+};
+
+struct ov13858_reg_list {
+	u32 num_of_regs;
+	const struct ov13858_reg *regs;
+};
+
+/* Link frequency config */
+struct ov13858_link_freq_config {
+	u32 pixels_per_line;
+
+	/* PLL registers for this link frequency */
+	struct ov13858_reg_list reg_list;
+};
+
+/* Mode : resolution and related config&values */
+struct ov13858_mode {
+	/* Frame width */
+	u32 width;
+	/* Frame height */
+	u32 height;
+
+	/* V-timing */
+	u32 vts_def;
+	u32 vts_min;
+
+	/* Index of Link frequency config to be used */
+	u32 link_freq_index;
+	/* Default register values */
+	struct ov13858_reg_list reg_list;
+};
+
+/* Format1: used for vertical/horizontal flip */
+union ov13858_format1 {
+	u8 val;
+	struct {
+		u8 d0     : 3; /* bit[0:2] */
+		u8 hflip  : 1; /* 0 enable,  1 disable */
+		u8 vflip  : 1; /* 0 disable, 1 enable  */
+		u8 d1     : 3; /* bit[5:7] */
+	} bits;
+};
+
+/* 4224x3136 needs 1080Mbps/lane, 4 lanes */
+static const struct ov13858_reg mipi_data_rate_1080mbps[] = {
+	/* PLL1 registers */
+	{OV13858_REG_PLL1_CTRL_0, 0x07},
+	{OV13858_REG_PLL1_CTRL_1, 0x01},
+	{OV13858_REG_PLL1_CTRL_2, 0xc2},
+	{OV13858_REG_PLL1_CTRL_3, 0x00},
+	{OV13858_REG_PLL1_CTRL_4, 0x00},
+	{OV13858_REG_PLL1_CTRL_5, 0x01},
+
+	/* PLL2 registers */
+	{OV13858_REG_PLL2_CTRL_B, 0x05},
+	{OV13858_REG_PLL2_CTRL_C, 0x01},
+	{OV13858_REG_PLL2_CTRL_D, 0x0e},
+	{OV13858_REG_PLL2_CTRL_E, 0x05},
+	{OV13858_REG_PLL2_CTRL_F, 0x01},
+	{OV13858_REG_PLL2_CTRL_12, 0x01},
+	{OV13858_REG_MIPI_SC_CTRL0, 0x72},
+	{OV13858_REG_MIPI_SC_CTRL1, 0x01},
+};
+
+/*
+ * 2112x1568, 2112x1188, 1056x784 need 540Mbps/lane,
+ * 4 lanes
+ */
+static const struct ov13858_reg mipi_data_rate_540mbps[] = {
+	/* PLL1 registers */
+	{OV13858_REG_PLL1_CTRL_0, 0x07},
+	{OV13858_REG_PLL1_CTRL_1, 0x01},
+	{OV13858_REG_PLL1_CTRL_2, 0xc2},
+	{OV13858_REG_PLL1_CTRL_3, 0x01},
+	{OV13858_REG_PLL1_CTRL_4, 0x00},
+	{OV13858_REG_PLL1_CTRL_5, 0x01},
+
+	/* PLL2 registers */
+	{OV13858_REG_PLL2_CTRL_B, 0x05},
+	{OV13858_REG_PLL2_CTRL_C, 0x01},
+	{OV13858_REG_PLL2_CTRL_D, 0x0e},
+	{OV13858_REG_PLL2_CTRL_E, 0x05},
+	{OV13858_REG_PLL2_CTRL_F, 0x01},
+	{OV13858_REG_PLL2_CTRL_12, 0x01},
+	{OV13858_REG_MIPI_SC_CTRL0, 0x72},
+	{OV13858_REG_MIPI_SC_CTRL1, 0x01},
+};
+
+static const struct ov13858_reg mode_4224x3136_regs[] = {
+	{0x3013, 0x32},
+	{0x301b, 0xf0},
+	{0x301f, 0xd0},
+	{0x3106, 0x15},
+	{0x3107, 0x23},
+	{0x350a, 0x00},
+	{0x350e, 0x00},
+	{0x3510, 0x00},
+	{0x3511, 0x02},
+	{0x3512, 0x00},
+	{0x3600, 0x2b},
+	{0x3601, 0x52},
+	{0x3602, 0x60},
+	{0x3612, 0x05},
+	{0x3613, 0xa4},
+	{0x3620, 0x80},
+	{0x3621, 0x10},
+	{0x3622, 0x30},
+	{0x3624, 0x1c},
+	{0x3640, 0x10},
+	{0x3641, 0x70},
+	{0x3660, 0x04},
+	{0x3661, 0x80},
+	{0x3662, 0x12},
+	{0x3664, 0x73},
+	{0x3665, 0xa7},
+	{0x366e, 0xff},
+	{0x366f, 0xf4},
+	{0x3674, 0x00},
+	{0x3679, 0x0c},
+	{0x367f, 0x01},
+	{0x3680, 0x0c},
+	{0x3681, 0x50},
+	{0x3682, 0x50},
+	{0x3683, 0xa9},
+	{0x3684, 0xa9},
+	{0x3709, 0x5f},
+	{0x3714, 0x24},
+	{0x371a, 0x3e},
+	{0x3737, 0x04},
+	{0x3738, 0xcc},
+	{0x3739, 0x12},
+	{0x373d, 0x26},
+	{0x3764, 0x20},
+	{0x3765, 0x20},
+	{0x37a1, 0x36},
+	{0x37a8, 0x3b},
+	{0x37ab, 0x31},
+	{0x37c2, 0x04},
+	{0x37c3, 0xf1},
+	{0x37c5, 0x00},
+	{0x37d8, 0x03},
+	{0x37d9, 0x0c},
+	{0x37da, 0xc2},
+	{0x37dc, 0x02},
+	{0x37e0, 0x00},
+	{0x37e1, 0x0a},
+	{0x37e2, 0x14},
+	{0x37e3, 0x04},
+	{0x37e4, 0x2a},
+	{0x37e5, 0x03},
+	{0x37e6, 0x04},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0x08},
+	{0x3804, 0x10},
+	{0x3805, 0x9f},
+	{0x3806, 0x0c},
+	{0x3807, 0x57},
+	{0x3808, 0x10},
+	{0x3809, 0x80},
+	{0x380a, 0x0c},
+	{0x380b, 0x40},
+	{0x380c, 0x04},
+	{0x380d, 0x62},
+	{0x380e, 0x0c},
+	{0x380f, 0x8e},
+	{0x3811, 0x04},
+	{0x3813, 0x05},
+	{0x3814, 0x01},
+	{0x3815, 0x01},
+	{0x3816, 0x01},
+	{0x3817, 0x01},
+	{0x3820, 0xa8},
+	{0x3821, 0x00},
+	{0x3822, 0xc2},
+	{0x3823, 0x18},
+	{0x3826, 0x11},
+	{0x3827, 0x1c},
+	{0x3829, 0x03},
+	{0x3832, 0x00},
+	{0x3c80, 0x00},
+	{0x3c87, 0x01},
+	{0x3c8c, 0x19},
+	{0x3c8d, 0x1c},
+	{0x3c90, 0x00},
+	{0x3c91, 0x00},
+	{0x3c92, 0x00},
+	{0x3c93, 0x00},
+	{0x3c94, 0x40},
+	{0x3c95, 0x54},
+	{0x3c96, 0x34},
+	{0x3c97, 0x04},
+	{0x3c98, 0x00},
+	{0x3d8c, 0x73},
+	{0x3d8d, 0xc0},
+	{0x3f00, 0x0b},
+	{0x3f03, 0x00},
+	{0x4001, 0xe0},
+	{0x4008, 0x00},
+	{0x4009, 0x0f},
+	{0x4011, 0xf0},
+	{0x4017, 0x08},
+	{0x4050, 0x04},
+	{0x4051, 0x0b},
+	{0x4052, 0x00},
+	{0x4053, 0x80},
+	{0x4054, 0x00},
+	{0x4055, 0x80},
+	{0x4056, 0x00},
+	{0x4057, 0x80},
+	{0x4058, 0x00},
+	{0x4059, 0x80},
+	{0x405e, 0x20},
+	{0x4500, 0x07},
+	{0x4503, 0x00},
+	{0x450a, 0x04},
+	{0x4809, 0x04},
+	{0x480c, 0x12},
+	{0x481f, 0x30},
+	{0x4833, 0x10},
+	{0x4837, 0x0e},
+	{0x4902, 0x01},
+	{0x4d00, 0x03},
+	{0x4d01, 0xc9},
+	{0x4d02, 0xbc},
+	{0x4d03, 0xd7},
+	{0x4d04, 0xf0},
+	{0x4d05, 0xa2},
+	{0x5000, 0xfd},
+	{0x5001, 0x01},
+	{0x5040, 0x39},
+	{0x5041, 0x10},
+	{0x5042, 0x10},
+	{0x5043, 0x84},
+	{0x5044, 0x62},
+	{0x5180, 0x00},
+	{0x5181, 0x10},
+	{0x5182, 0x02},
+	{0x5183, 0x0f},
+	{0x5200, 0x1b},
+	{0x520b, 0x07},
+	{0x520c, 0x0f},
+	{0x5300, 0x04},
+	{0x5301, 0x0c},
+	{0x5302, 0x0c},
+	{0x5303, 0x0f},
+	{0x5304, 0x00},
+	{0x5305, 0x70},
+	{0x5306, 0x00},
+	{0x5307, 0x80},
+	{0x5308, 0x00},
+	{0x5309, 0xa5},
+	{0x530a, 0x00},
+	{0x530b, 0xd3},
+	{0x530c, 0x00},
+	{0x530d, 0xf0},
+	{0x530e, 0x01},
+	{0x530f, 0x10},
+	{0x5310, 0x01},
+	{0x5311, 0x20},
+	{0x5312, 0x01},
+	{0x5313, 0x20},
+	{0x5314, 0x01},
+	{0x5315, 0x20},
+	{0x5316, 0x08},
+	{0x5317, 0x08},
+	{0x5318, 0x10},
+	{0x5319, 0x88},
+	{0x531a, 0x88},
+	{0x531b, 0xa9},
+	{0x531c, 0xaa},
+	{0x531d, 0x0a},
+	{0x5405, 0x02},
+	{0x5406, 0x67},
+	{0x5407, 0x01},
+	{0x5408, 0x4a},
+};
+
+static const struct ov13858_reg mode_4096x3072_regs[] = {
+	{0x3012, 0x40},
+	{0x3013, 0x72},
+	{0x301b, 0xf0},
+	{0x301f, 0xd0},
+	{0x3106, 0x15},
+	{0x3107, 0x23},
+	{0x3500, 0x00},
+	{0x3501, 0x80},
+	{0x3502, 0x00},
+	{0x3508, 0x02},
+	{0x3509, 0x00},
+	{0x350a, 0x00},
+	{0x350e, 0x00},
+	{0x3510, 0x00},
+	{0x3511, 0x02},
+	{0x3512, 0x00},
+	{0x3600, 0x2b},
+	{0x3601, 0x52},
+	{0x3602, 0x60},
+	{0x3612, 0x05},
+	{0x3613, 0xa4},
+	{0x3620, 0x80},
+	{0x3621, 0x10},
+	{0x3622, 0x30},
+	{0x3624, 0x1c},
+	{0x3640, 0x10},
+	{0x3641, 0x70},
+	{0x3660, 0x04},
+	{0x3661, 0x80},
+	{0x3662, 0x12},
+	{0x3664, 0x73},
+	{0x3665, 0xa7},
+	{0x366e, 0xff},
+	{0x366f, 0xf4},
+	{0x3674, 0x00},
+	{0x3679, 0x0c},
+	{0x367f, 0x01},
+	{0x3680, 0x0c},
+	{0x3681, 0x50},
+	{0x3682, 0x50},
+	{0x3683, 0xa9},
+	{0x3684, 0xa9},
+	{0x3706, 0x40},
+	{0x3709, 0x5f},
+	{0x3714, 0x24},
+	{0x371a, 0x3e},
+	{0x3737, 0x04},
+	{0x3738, 0xcc},
+	{0x3739, 0x12},
+	{0x373d, 0x26},
+	{0x3764, 0x20},
+	{0x3765, 0x20},
+	{0x37a1, 0x36},
+	{0x37a8, 0x3b},
+	{0x37ab, 0x31},
+	{0x37c2, 0x04},
+	{0x37c3, 0xf1},
+	{0x37c5, 0x00},
+	{0x37d8, 0x03},
+	{0x37d9, 0x0c},
+	{0x37da, 0xc2},
+	{0x37dc, 0x02},
+	{0x37e0, 0x00},
+	{0x37e1, 0x0a},
+	{0x37e2, 0x14},
+	{0x37e3, 0x04},
+	{0x37e4, 0x2a},
+	{0x37e5, 0x03},
+	{0x37e6, 0x04},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0x08},
+	{0x3804, 0x10},
+	{0x3805, 0x9f},
+	{0x3806, 0x0c},
+	{0x3807, 0x57},
+	{0x3808, 0x10},
+	{0x3809, 0x00},
+	{0x380a, 0x0c},
+	{0x380b, 0x00},
+	{0x380c, 0x04},
+	{0x380d, 0x62},
+	{0x380e, 0x0c},
+	{0x380f, 0x8e},
+	{0x3810, 0x00},
+	{0x3811, 0x50},
+	{0x3812, 0x00},
+	{0x3813, 0x29},
+	{0x3814, 0x01},
+	{0x3815, 0x01},
+	{0x3816, 0x01},
+	{0x3817, 0x01},
+	{0x3820, 0xa8},
+	{0x3821, 0x00},
+	{0x3822, 0xc2},
+	{0x3823, 0x18},
+	{0x3826, 0x11},
+	{0x3827, 0x1c},
+	{0x3829, 0x03},
+	{0x3832, 0x00},
+	{0x3c80, 0x00},
+	{0x3c87, 0x01},
+	{0x3c8c, 0x19},
+	{0x3c8d, 0x1c},
+	{0x3c90, 0x00},
+	{0x3c91, 0x00},
+	{0x3c92, 0x00},
+	{0x3c93, 0x00},
+	{0x3c94, 0x40},
+	{0x3c95, 0x54},
+	{0x3c96, 0x34},
+	{0x3c97, 0x04},
+	{0x3c98, 0x00},
+	{0x3d8c, 0x73},
+	{0x3d8d, 0xc0},
+	{0x3f00, 0x0b},
+	{0x3f03, 0x00},
+	{0x4001, 0xe0},
+	{0x4008, 0x00},
+	{0x4009, 0x0f},
+	{0x4011, 0xf0},
+	{0x4017, 0x08},
+	{0x4050, 0x04},
+	{0x4051, 0x0b},
+	{0x4052, 0x00},
+	{0x4053, 0x80},
+	{0x4054, 0x00},
+	{0x4055, 0x80},
+	{0x4056, 0x00},
+	{0x4057, 0x80},
+	{0x4058, 0x00},
+	{0x4059, 0x80},
+	{0x405e, 0x20},
+	{0x4500, 0x07},
+	{0x4503, 0x00},
+	{0x450a, 0x04},
+	{0x4809, 0x04},
+	{0x480c, 0x12},
+	{0x481f, 0x30},
+	{0x4833, 0x10},
+	{0x4837, 0x0e},
+	{0x4902, 0x01},
+	{0x4d00, 0x03},
+	{0x4d01, 0xc9},
+	{0x4d02, 0xbc},
+	{0x4d03, 0xd7},
+	{0x4d04, 0xf0},
+	{0x4d05, 0xa2},
+	{0x5000, 0xfd},
+	{0x5001, 0x01},
+	{0x5040, 0x39},
+	{0x5041, 0x10},
+	{0x5042, 0x10},
+	{0x5043, 0x84},
+	{0x5044, 0x62},
+	{0x5180, 0x00},
+	{0x5181, 0x10},
+	{0x5182, 0x02},
+	{0x5183, 0x0f},
+	{0x5200, 0x1b},
+	{0x520b, 0x07},
+	{0x520c, 0x0f},
+	{0x5300, 0x04},
+	{0x5301, 0x0c},
+	{0x5302, 0x0c},
+	{0x5303, 0x0f},
+	{0x5304, 0x00},
+	{0x5305, 0x70},
+	{0x5306, 0x00},
+	{0x5307, 0x80},
+	{0x5308, 0x00},
+	{0x5309, 0xa5},
+	{0x530a, 0x00},
+	{0x530b, 0xd3},
+	{0x530c, 0x00},
+	{0x530d, 0xf0},
+	{0x530e, 0x01},
+	{0x530f, 0x10},
+	{0x5310, 0x01},
+	{0x5311, 0x20},
+	{0x5312, 0x01},
+	{0x5313, 0x20},
+	{0x5314, 0x01},
+	{0x5315, 0x20},
+	{0x5316, 0x08},
+	{0x5317, 0x08},
+	{0x5318, 0x10},
+	{0x5319, 0x88},
+	{0x531a, 0x88},
+	{0x531b, 0xa9},
+	{0x531c, 0xaa},
+	{0x531d, 0x0a},
+	{0x5405, 0x02},
+	{0x5406, 0x67},
+	{0x5407, 0x01},
+	{0x5408, 0x4a},
+};
+
+static const struct ov13858_reg mode_2112x1568_regs[] = {
+	{0x3013, 0x32},
+	{0x301b, 0xf0},
+	{0x301f, 0xd0},
+	{0x3106, 0x15},
+	{0x3107, 0x23},
+	{0x350a, 0x00},
+	{0x350e, 0x00},
+	{0x3510, 0x00},
+	{0x3511, 0x02},
+	{0x3512, 0x00},
+	{0x3600, 0x2b},
+	{0x3601, 0x52},
+	{0x3602, 0x60},
+	{0x3612, 0x05},
+	{0x3613, 0xa4},
+	{0x3620, 0x80},
+	{0x3621, 0x10},
+	{0x3622, 0x30},
+	{0x3624, 0x1c},
+	{0x3640, 0x10},
+	{0x3641, 0x70},
+	{0x3660, 0x04},
+	{0x3661, 0x80},
+	{0x3662, 0x10},
+	{0x3664, 0x73},
+	{0x3665, 0xa7},
+	{0x366e, 0xff},
+	{0x366f, 0xf4},
+	{0x3674, 0x00},
+	{0x3679, 0x0c},
+	{0x367f, 0x01},
+	{0x3680, 0x0c},
+	{0x3681, 0x50},
+	{0x3682, 0x50},
+	{0x3683, 0xa9},
+	{0x3684, 0xa9},
+	{0x3709, 0x5f},
+	{0x3714, 0x28},
+	{0x371a, 0x3e},
+	{0x3737, 0x08},
+	{0x3738, 0xcc},
+	{0x3739, 0x20},
+	{0x373d, 0x26},
+	{0x3764, 0x20},
+	{0x3765, 0x20},
+	{0x37a1, 0x36},
+	{0x37a8, 0x3b},
+	{0x37ab, 0x31},
+	{0x37c2, 0x14},
+	{0x37c3, 0xf1},
+	{0x37c5, 0x00},
+	{0x37d8, 0x03},
+	{0x37d9, 0x0c},
+	{0x37da, 0xc2},
+	{0x37dc, 0x02},
+	{0x37e0, 0x00},
+	{0x37e1, 0x0a},
+	{0x37e2, 0x14},
+	{0x37e3, 0x08},
+	{0x37e4, 0x38},
+	{0x37e5, 0x03},
+	{0x37e6, 0x08},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0x00},
+	{0x3804, 0x10},
+	{0x3805, 0x9f},
+	{0x3806, 0x0c},
+	{0x3807, 0x5f},
+	{0x3808, 0x08},
+	{0x3809, 0x40},
+	{0x380a, 0x06},
+	{0x380b, 0x20},
+	{0x380c, 0x04},
+	{0x380d, 0x62},
+	{0x380e, 0x0c},
+	{0x380f, 0x8e},
+	{0x3811, 0x04},
+	{0x3813, 0x05},
+	{0x3814, 0x03},
+	{0x3815, 0x01},
+	{0x3816, 0x03},
+	{0x3817, 0x01},
+	{0x3820, 0xab},
+	{0x3821, 0x00},
+	{0x3822, 0xc2},
+	{0x3823, 0x18},
+	{0x3826, 0x04},
+	{0x3827, 0x90},
+	{0x3829, 0x07},
+	{0x3832, 0x00},
+	{0x3c80, 0x00},
+	{0x3c87, 0x01},
+	{0x3c8c, 0x19},
+	{0x3c8d, 0x1c},
+	{0x3c90, 0x00},
+	{0x3c91, 0x00},
+	{0x3c92, 0x00},
+	{0x3c93, 0x00},
+	{0x3c94, 0x40},
+	{0x3c95, 0x54},
+	{0x3c96, 0x34},
+	{0x3c97, 0x04},
+	{0x3c98, 0x00},
+	{0x3d8c, 0x73},
+	{0x3d8d, 0xc0},
+	{0x3f00, 0x0b},
+	{0x3f03, 0x00},
+	{0x4001, 0xe0},
+	{0x4008, 0x00},
+	{0x4009, 0x0d},
+	{0x4011, 0xf0},
+	{0x4017, 0x08},
+	{0x4050, 0x04},
+	{0x4051, 0x0b},
+	{0x4052, 0x00},
+	{0x4053, 0x80},
+	{0x4054, 0x00},
+	{0x4055, 0x80},
+	{0x4056, 0x00},
+	{0x4057, 0x80},
+	{0x4058, 0x00},
+	{0x4059, 0x80},
+	{0x405e, 0x20},
+	{0x4500, 0x07},
+	{0x4503, 0x00},
+	{0x450a, 0x04},
+	{0x4809, 0x04},
+	{0x480c, 0x12},
+	{0x481f, 0x30},
+	{0x4833, 0x10},
+	{0x4837, 0x1c},
+	{0x4902, 0x01},
+	{0x4d00, 0x03},
+	{0x4d01, 0xc9},
+	{0x4d02, 0xbc},
+	{0x4d03, 0xd7},
+	{0x4d04, 0xf0},
+	{0x4d05, 0xa2},
+	{0x5000, 0xfd},
+	{0x5001, 0x01},
+	{0x5040, 0x39},
+	{0x5041, 0x10},
+	{0x5042, 0x10},
+	{0x5043, 0x84},
+	{0x5044, 0x62},
+	{0x5180, 0x00},
+	{0x5181, 0x10},
+	{0x5182, 0x02},
+	{0x5183, 0x0f},
+	{0x5200, 0x1b},
+	{0x520b, 0x07},
+	{0x520c, 0x0f},
+	{0x5300, 0x04},
+	{0x5301, 0x0c},
+	{0x5302, 0x0c},
+	{0x5303, 0x0f},
+	{0x5304, 0x00},
+	{0x5305, 0x70},
+	{0x5306, 0x00},
+	{0x5307, 0x80},
+	{0x5308, 0x00},
+	{0x5309, 0xa5},
+	{0x530a, 0x00},
+	{0x530b, 0xd3},
+	{0x530c, 0x00},
+	{0x530d, 0xf0},
+	{0x530e, 0x01},
+	{0x530f, 0x10},
+	{0x5310, 0x01},
+	{0x5311, 0x20},
+	{0x5312, 0x01},
+	{0x5313, 0x20},
+	{0x5314, 0x01},
+	{0x5315, 0x20},
+	{0x5316, 0x08},
+	{0x5317, 0x08},
+	{0x5318, 0x10},
+	{0x5319, 0x88},
+	{0x531a, 0x88},
+	{0x531b, 0xa9},
+	{0x531c, 0xaa},
+	{0x531d, 0x0a},
+	{0x5405, 0x02},
+	{0x5406, 0x67},
+	{0x5407, 0x01},
+	{0x5408, 0x4a},
+};
+
+static const struct ov13858_reg mode_2112x1188_regs[] = {
+	{0x3013, 0x32},
+	{0x301b, 0xf0},
+	{0x301f, 0xd0},
+	{0x3106, 0x15},
+	{0x3107, 0x23},
+	{0x350a, 0x00},
+	{0x350e, 0x00},
+	{0x3510, 0x00},
+	{0x3511, 0x02},
+	{0x3512, 0x00},
+	{0x3600, 0x2b},
+	{0x3601, 0x52},
+	{0x3602, 0x60},
+	{0x3612, 0x05},
+	{0x3613, 0xa4},
+	{0x3620, 0x80},
+	{0x3621, 0x10},
+	{0x3622, 0x30},
+	{0x3624, 0x1c},
+	{0x3640, 0x10},
+	{0x3641, 0x70},
+	{0x3660, 0x04},
+	{0x3661, 0x80},
+	{0x3662, 0x10},
+	{0x3664, 0x73},
+	{0x3665, 0xa7},
+	{0x366e, 0xff},
+	{0x366f, 0xf4},
+	{0x3674, 0x00},
+	{0x3679, 0x0c},
+	{0x367f, 0x01},
+	{0x3680, 0x0c},
+	{0x3681, 0x50},
+	{0x3682, 0x50},
+	{0x3683, 0xa9},
+	{0x3684, 0xa9},
+	{0x3709, 0x5f},
+	{0x3714, 0x28},
+	{0x371a, 0x3e},
+	{0x3737, 0x08},
+	{0x3738, 0xcc},
+	{0x3739, 0x20},
+	{0x373d, 0x26},
+	{0x3764, 0x20},
+	{0x3765, 0x20},
+	{0x37a1, 0x36},
+	{0x37a8, 0x3b},
+	{0x37ab, 0x31},
+	{0x37c2, 0x14},
+	{0x37c3, 0xf1},
+	{0x37c5, 0x00},
+	{0x37d8, 0x03},
+	{0x37d9, 0x0c},
+	{0x37da, 0xc2},
+	{0x37dc, 0x02},
+	{0x37e0, 0x00},
+	{0x37e1, 0x0a},
+	{0x37e2, 0x14},
+	{0x37e3, 0x08},
+	{0x37e4, 0x38},
+	{0x37e5, 0x03},
+	{0x37e6, 0x08},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x01},
+	{0x3803, 0x84},
+	{0x3804, 0x10},
+	{0x3805, 0x9f},
+	{0x3806, 0x0a},
+	{0x3807, 0xd3},
+	{0x3808, 0x08},
+	{0x3809, 0x40},
+	{0x380a, 0x04},
+	{0x380b, 0xa4},
+	{0x380c, 0x04},
+	{0x380d, 0x62},
+	{0x380e, 0x0c},
+	{0x380f, 0x8e},
+	{0x3811, 0x08},
+	{0x3813, 0x03},
+	{0x3814, 0x03},
+	{0x3815, 0x01},
+	{0x3816, 0x03},
+	{0x3817, 0x01},
+	{0x3820, 0xab},
+	{0x3821, 0x00},
+	{0x3822, 0xc2},
+	{0x3823, 0x18},
+	{0x3826, 0x04},
+	{0x3827, 0x90},
+	{0x3829, 0x07},
+	{0x3832, 0x00},
+	{0x3c80, 0x00},
+	{0x3c87, 0x01},
+	{0x3c8c, 0x19},
+	{0x3c8d, 0x1c},
+	{0x3c90, 0x00},
+	{0x3c91, 0x00},
+	{0x3c92, 0x00},
+	{0x3c93, 0x00},
+	{0x3c94, 0x40},
+	{0x3c95, 0x54},
+	{0x3c96, 0x34},
+	{0x3c97, 0x04},
+	{0x3c98, 0x00},
+	{0x3d8c, 0x73},
+	{0x3d8d, 0xc0},
+	{0x3f00, 0x0b},
+	{0x3f03, 0x00},
+	{0x4001, 0xe0},
+	{0x4008, 0x00},
+	{0x4009, 0x0d},
+	{0x4011, 0xf0},
+	{0x4017, 0x08},
+	{0x4050, 0x04},
+	{0x4051, 0x0b},
+	{0x4052, 0x00},
+	{0x4053, 0x80},
+	{0x4054, 0x00},
+	{0x4055, 0x80},
+	{0x4056, 0x00},
+	{0x4057, 0x80},
+	{0x4058, 0x00},
+	{0x4059, 0x80},
+	{0x405e, 0x20},
+	{0x4500, 0x07},
+	{0x4503, 0x00},
+	{0x450a, 0x04},
+	{0x4809, 0x04},
+	{0x480c, 0x12},
+	{0x481f, 0x30},
+	{0x4833, 0x10},
+	{0x4837, 0x1c},
+	{0x4902, 0x01},
+	{0x4d00, 0x03},
+	{0x4d01, 0xc9},
+	{0x4d02, 0xbc},
+	{0x4d03, 0xd7},
+	{0x4d04, 0xf0},
+	{0x4d05, 0xa2},
+	{0x5000, 0xfd},
+	{0x5001, 0x01},
+	{0x5040, 0x39},
+	{0x5041, 0x10},
+	{0x5042, 0x10},
+	{0x5043, 0x84},
+	{0x5044, 0x62},
+	{0x5180, 0x00},
+	{0x5181, 0x10},
+	{0x5182, 0x02},
+	{0x5183, 0x0f},
+	{0x5200, 0x1b},
+	{0x520b, 0x07},
+	{0x520c, 0x0f},
+	{0x5300, 0x04},
+	{0x5301, 0x0c},
+	{0x5302, 0x0c},
+	{0x5303, 0x0f},
+	{0x5304, 0x00},
+	{0x5305, 0x70},
+	{0x5306, 0x00},
+	{0x5307, 0x80},
+	{0x5308, 0x00},
+	{0x5309, 0xa5},
+	{0x530a, 0x00},
+	{0x530b, 0xd3},
+	{0x530c, 0x00},
+	{0x530d, 0xf0},
+	{0x530e, 0x01},
+	{0x530f, 0x10},
+	{0x5310, 0x01},
+	{0x5311, 0x20},
+	{0x5312, 0x01},
+	{0x5313, 0x20},
+	{0x5314, 0x01},
+	{0x5315, 0x20},
+	{0x5316, 0x08},
+	{0x5317, 0x08},
+	{0x5318, 0x10},
+	{0x5319, 0x88},
+	{0x531a, 0x88},
+	{0x531b, 0xa9},
+	{0x531c, 0xaa},
+	{0x531d, 0x0a},
+	{0x5405, 0x02},
+	{0x5406, 0x67},
+	{0x5407, 0x01},
+	{0x5408, 0x4a},
+};
+
+static const struct ov13858_reg mode_1056x784_regs[] = {
+	{0x3013, 0x32},
+	{0x301b, 0xf0},
+	{0x301f, 0xd0},
+	{0x3106, 0x15},
+	{0x3107, 0x23},
+	{0x350a, 0x00},
+	{0x350e, 0x00},
+	{0x3510, 0x00},
+	{0x3511, 0x02},
+	{0x3512, 0x00},
+	{0x3600, 0x2b},
+	{0x3601, 0x52},
+	{0x3602, 0x60},
+	{0x3612, 0x05},
+	{0x3613, 0xa4},
+	{0x3620, 0x80},
+	{0x3621, 0x10},
+	{0x3622, 0x30},
+	{0x3624, 0x1c},
+	{0x3640, 0x10},
+	{0x3641, 0x70},
+	{0x3660, 0x04},
+	{0x3661, 0x80},
+	{0x3662, 0x08},
+	{0x3664, 0x73},
+	{0x3665, 0xa7},
+	{0x366e, 0xff},
+	{0x366f, 0xf4},
+	{0x3674, 0x00},
+	{0x3679, 0x0c},
+	{0x367f, 0x01},
+	{0x3680, 0x0c},
+	{0x3681, 0x50},
+	{0x3682, 0x50},
+	{0x3683, 0xa9},
+	{0x3684, 0xa9},
+	{0x3709, 0x5f},
+	{0x3714, 0x30},
+	{0x371a, 0x3e},
+	{0x3737, 0x08},
+	{0x3738, 0xcc},
+	{0x3739, 0x20},
+	{0x373d, 0x26},
+	{0x3764, 0x20},
+	{0x3765, 0x20},
+	{0x37a1, 0x36},
+	{0x37a8, 0x3b},
+	{0x37ab, 0x31},
+	{0x37c2, 0x2c},
+	{0x37c3, 0xf1},
+	{0x37c5, 0x00},
+	{0x37d8, 0x03},
+	{0x37d9, 0x06},
+	{0x37da, 0xc2},
+	{0x37dc, 0x02},
+	{0x37e0, 0x00},
+	{0x37e1, 0x0a},
+	{0x37e2, 0x14},
+	{0x37e3, 0x08},
+	{0x37e4, 0x36},
+	{0x37e5, 0x03},
+	{0x37e6, 0x08},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0x00},
+	{0x3804, 0x10},
+	{0x3805, 0x9f},
+	{0x3806, 0x0c},
+	{0x3807, 0x5f},
+	{0x3808, 0x04},
+	{0x3809, 0x20},
+	{0x380a, 0x03},
+	{0x380b, 0x10},
+	{0x380c, 0x04},
+	{0x380d, 0x62},
+	{0x380e, 0x0c},
+	{0x380f, 0x8e},
+	{0x3811, 0x04},
+	{0x3813, 0x05},
+	{0x3814, 0x07},
+	{0x3815, 0x01},
+	{0x3816, 0x07},
+	{0x3817, 0x01},
+	{0x3820, 0xac},
+	{0x3821, 0x00},
+	{0x3822, 0xc2},
+	{0x3823, 0x18},
+	{0x3826, 0x04},
+	{0x3827, 0x48},
+	{0x3829, 0x03},
+	{0x3832, 0x00},
+	{0x3c80, 0x00},
+	{0x3c87, 0x01},
+	{0x3c8c, 0x19},
+	{0x3c8d, 0x1c},
+	{0x3c90, 0x00},
+	{0x3c91, 0x00},
+	{0x3c92, 0x00},
+	{0x3c93, 0x00},
+	{0x3c94, 0x40},
+	{0x3c95, 0x54},
+	{0x3c96, 0x34},
+	{0x3c97, 0x04},
+	{0x3c98, 0x00},
+	{0x3d8c, 0x73},
+	{0x3d8d, 0xc0},
+	{0x3f00, 0x0b},
+	{0x3f03, 0x00},
+	{0x4001, 0xe0},
+	{0x4008, 0x00},
+	{0x4009, 0x05},
+	{0x4011, 0xf0},
+	{0x4017, 0x08},
+	{0x4050, 0x02},
+	{0x4051, 0x05},
+	{0x4052, 0x00},
+	{0x4053, 0x80},
+	{0x4054, 0x00},
+	{0x4055, 0x80},
+	{0x4056, 0x00},
+	{0x4057, 0x80},
+	{0x4058, 0x00},
+	{0x4059, 0x80},
+	{0x405e, 0x20},
+	{0x4500, 0x07},
+	{0x4503, 0x00},
+	{0x450a, 0x04},
+	{0x4809, 0x04},
+	{0x480c, 0x12},
+	{0x481f, 0x30},
+	{0x4833, 0x10},
+	{0x4837, 0x1e},
+	{0x4902, 0x02},
+	{0x4d00, 0x03},
+	{0x4d01, 0xc9},
+	{0x4d02, 0xbc},
+	{0x4d03, 0xd7},
+	{0x4d04, 0xf0},
+	{0x4d05, 0xa2},
+	{0x5000, 0xfd},
+	{0x5001, 0x01},
+	{0x5040, 0x39},
+	{0x5041, 0x10},
+	{0x5042, 0x10},
+	{0x5043, 0x84},
+	{0x5044, 0x62},
+	{0x5180, 0x00},
+	{0x5181, 0x10},
+	{0x5182, 0x02},
+	{0x5183, 0x0f},
+	{0x5200, 0x1b},
+	{0x520b, 0x07},
+	{0x520c, 0x0f},
+	{0x5300, 0x04},
+	{0x5301, 0x0c},
+	{0x5302, 0x0c},
+	{0x5303, 0x0f},
+	{0x5304, 0x00},
+	{0x5305, 0x70},
+	{0x5306, 0x00},
+	{0x5307, 0x80},
+	{0x5308, 0x00},
+	{0x5309, 0xa5},
+	{0x530a, 0x00},
+	{0x530b, 0xd3},
+	{0x530c, 0x00},
+	{0x530d, 0xf0},
+	{0x530e, 0x01},
+	{0x530f, 0x10},
+	{0x5310, 0x01},
+	{0x5311, 0x20},
+	{0x5312, 0x01},
+	{0x5313, 0x20},
+	{0x5314, 0x01},
+	{0x5315, 0x20},
+	{0x5316, 0x08},
+	{0x5317, 0x08},
+	{0x5318, 0x10},
+	{0x5319, 0x88},
+	{0x531a, 0x88},
+	{0x531b, 0xa9},
+	{0x531c, 0xaa},
+	{0x531d, 0x0a},
+	{0x5405, 0x02},
+	{0x5406, 0x67},
+	{0x5407, 0x01},
+	{0x5408, 0x4a},
+};
+
+static const char * const ov13858_test_pattern_menu[] = {
+	"Disabled",
+	"Vertical Color Bar Type 1",
+	"Vertical Color Bar Type 2",
+	"Vertical Color Bar Type 3",
+	"Vertical Color Bar Type 4"
+};
+
+/* Configurations for supported link frequencies */
+#define OV13858_NUM_OF_LINK_FREQS	2
+#define OV13858_LINK_FREQ_540MHZ	540000000ULL
+#define OV13858_LINK_FREQ_270MHZ	270000000ULL
+#define OV13858_LINK_FREQ_INDEX_0	0
+#define OV13858_LINK_FREQ_INDEX_1	1
+
+/*
+ * pixel_rate = link_freq * data-rate * nr_of_lanes / bits_per_sample
+ * data rate => double data rate; number of lanes => 4; bits per pixel => 10
+ */
+static u64 link_freq_to_pixel_rate(u64 f)
+{
+	f *= 2 * 4;
+	do_div(f, 10);
+
+	return f;
+}
+
+/* Menu items for LINK_FREQ V4L2 control */
+static const s64 link_freq_menu_items[OV13858_NUM_OF_LINK_FREQS] = {
+	OV13858_LINK_FREQ_540MHZ,
+	OV13858_LINK_FREQ_270MHZ
+};
+
+/* Link frequency configs */
+static const struct ov13858_link_freq_config
+			link_freq_configs[OV13858_NUM_OF_LINK_FREQS] = {
+	{
+		.pixels_per_line = OV13858_PPL_540MHZ,
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(mipi_data_rate_1080mbps),
+			.regs = mipi_data_rate_1080mbps,
+		}
+	},
+	{
+		.pixels_per_line = OV13858_PPL_270MHZ,
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(mipi_data_rate_540mbps),
+			.regs = mipi_data_rate_540mbps,
+		}
+	}
+};
+
+/* Mode configs */
+static const struct ov13858_mode supported_modes[] = {
+	{
+		.width = 4096,
+		.height = 3072,
+		.vts_def = OV13858_VTS_30FPS,
+		.vts_min = OV13858_VTS_30FPS,
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(mode_4096x3072_regs),
+			.regs = mode_4096x3072_regs,
+		},
+		.link_freq_index = OV13858_LINK_FREQ_INDEX_0,
+	},
+	{
+		.width = 4224,
+		.height = 3136,
+		.vts_def = OV13858_VTS_30FPS,
+		.vts_min = OV13858_VTS_30FPS,
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(mode_4224x3136_regs),
+			.regs = mode_4224x3136_regs,
+		},
+		.link_freq_index = OV13858_LINK_FREQ_INDEX_0,
+	},
+	{
+		.width = 2112,
+		.height = 1568,
+		.vts_def = OV13858_VTS_30FPS,
+		.vts_min = 1608,
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(mode_2112x1568_regs),
+			.regs = mode_2112x1568_regs,
+		},
+		.link_freq_index = OV13858_LINK_FREQ_INDEX_1,
+	},
+	{
+		.width = 2112,
+		.height = 1188,
+		.vts_def = OV13858_VTS_30FPS,
+		.vts_min = 1608,
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(mode_2112x1188_regs),
+			.regs = mode_2112x1188_regs,
+		},
+		.link_freq_index = OV13858_LINK_FREQ_INDEX_1,
+	},
+	{
+		.width = 1056,
+		.height = 784,
+		.vts_def = OV13858_VTS_30FPS,
+		.vts_min = 804,
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(mode_1056x784_regs),
+			.regs = mode_1056x784_regs,
+		},
+		.link_freq_index = OV13858_LINK_FREQ_INDEX_1,
+	}
+};
+
+struct ov13858 {
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+
+	struct v4l2_ctrl_handler ctrl_handler;
+	/* V4L2 Controls */
+	struct v4l2_ctrl *link_freq;
+	struct v4l2_ctrl *pixel_rate;
+	struct v4l2_ctrl *vblank;
+	struct v4l2_ctrl *hblank;
+	struct v4l2_ctrl *exposure;
+	struct v4l2_ctrl *hflip;
+	struct v4l2_ctrl *vflip;
+
+	/* Current mode */
+	const struct ov13858_mode *cur_mode;
+	/* Current format1 */
+	union ov13858_format1 fmt1;
+
+	/* Mutex for serialized access */
+	struct mutex mutex;
+
+	/* Streaming on/off */
+	bool streaming;
+};
+
+#define to_ov13858(_sd)	container_of(_sd, struct ov13858, sd)
+
+/* Read registers up to 4 at a time */
+static int ov13858_read_reg(struct ov13858 *ov13858, u16 reg, u32 len,
+			    u32 *val)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&ov13858->sd);
+	struct i2c_msg msgs[2];
+	u8 *data_be_p;
+	int ret;
+	__be32 data_be = 0;
+	__be16 reg_addr_be = cpu_to_be16(reg);
+
+	if (len > 4)
+		return -EINVAL;
+
+	data_be_p = (u8 *)&data_be;
+	/* Write register address */
+	msgs[0].addr = client->addr;
+	msgs[0].flags = 0;
+	msgs[0].len = 2;
+	msgs[0].buf = (u8 *)&reg_addr_be;
+
+	/* Read data from register */
+	msgs[1].addr = client->addr;
+	msgs[1].flags = I2C_M_RD;
+	msgs[1].len = len;
+	msgs[1].buf = &data_be_p[4 - len];
+
+	ret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));
+	if (ret != ARRAY_SIZE(msgs))
+		return -EIO;
+
+	*val = be32_to_cpu(data_be);
+
+	return 0;
+}
+
+/* Write registers up to 4 at a time */
+static int ov13858_write_reg(struct ov13858 *ov13858, u16 reg, u32 len,
+			     u32 __val)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&ov13858->sd);
+	int buf_i, val_i;
+	u8 buf[6], *val_p;
+	__be32 val;
+
+	if (len > 4)
+		return -EINVAL;
+
+	buf[0] = reg >> 8;
+	buf[1] = reg & 0xff;
+
+	val = cpu_to_be32(__val);
+	val_p = (u8 *)&val;
+	buf_i = 2;
+	val_i = 4 - len;
+
+	while (val_i < 4)
+		buf[buf_i++] = val_p[val_i++];
+
+	if (i2c_master_send(client, buf, len + 2) != len + 2)
+		return -EIO;
+
+	return 0;
+}
+
+/* Write a list of registers */
+static int ov13858_write_regs(struct ov13858 *ov13858,
+			      const struct ov13858_reg *regs, u32 len)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&ov13858->sd);
+	int ret;
+	u32 i;
+
+	for (i = 0; i < len; i++) {
+		ret = ov13858_write_reg(ov13858, regs[i].address, 1,
+					regs[i].val);
+		if (ret) {
+			dev_err_ratelimited(
+				&client->dev,
+				"Failed to write reg 0x%4.4x. error = %d\n",
+				regs[i].address, ret);
+
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int ov13858_write_reg_list(struct ov13858 *ov13858,
+				  const struct ov13858_reg_list *r_list)
+{
+	return ov13858_write_regs(ov13858, r_list->regs, r_list->num_of_regs);
+}
+
+/* Open sub-device */
+static int ov13858_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct ov13858 *ov13858 = to_ov13858(sd);
+	struct v4l2_mbus_framefmt *try_fmt = v4l2_subdev_get_try_format(sd,
+									fh->pad,
+									0);
+
+	mutex_lock(&ov13858->mutex);
+
+	/* Initialize try_fmt */
+	try_fmt->width = ov13858->cur_mode->width;
+	try_fmt->height = ov13858->cur_mode->height;
+	try_fmt->code = MEDIA_BUS_FMT_SGRBG10_1X10;
+	try_fmt->field = V4L2_FIELD_NONE;
+
+	/* No crop or compose */
+	mutex_unlock(&ov13858->mutex);
+
+	return 0;
+}
+
+static int ov13858_update_digital_gain(struct ov13858 *ov13858, u32 d_gain)
+{
+	int ret;
+
+	ret = ov13858_write_reg(ov13858, OV13858_REG_B_MWB_GAIN,
+				OV13858_REG_VALUE_16BIT, d_gain);
+	if (ret)
+		return ret;
+
+	ret = ov13858_write_reg(ov13858, OV13858_REG_G_MWB_GAIN,
+				OV13858_REG_VALUE_16BIT, d_gain);
+	if (ret)
+		return ret;
+
+	ret = ov13858_write_reg(ov13858, OV13858_REG_R_MWB_GAIN,
+				OV13858_REG_VALUE_16BIT, d_gain);
+
+	return ret;
+}
+
+static int ov13858_enable_test_pattern(struct ov13858 *ov13858, u32 pattern)
+{
+	int ret;
+	u32 val;
+
+	ret = ov13858_read_reg(ov13858, OV13858_REG_TEST_PATTERN,
+			       OV13858_REG_VALUE_08BIT, &val);
+	if (ret)
+		return ret;
+
+	if (pattern) {
+		val &= OV13858_TEST_PATTERN_MASK;
+		val |= (pattern - 1) | OV13858_TEST_PATTERN_ENABLE;
+	} else {
+		val &= ~OV13858_TEST_PATTERN_ENABLE;
+	}
+
+	return ov13858_write_reg(ov13858, OV13858_REG_TEST_PATTERN,
+				 OV13858_REG_VALUE_08BIT, val);
+}
+
+static int ov13858_set_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct ov13858 *ov13858 = container_of(ctrl->handler,
+					       struct ov13858, ctrl_handler);
+	struct i2c_client *client = v4l2_get_subdevdata(&ov13858->sd);
+	s64 max;
+	int ret;
+
+	/* Propagate change of current control to all related controls */
+	switch (ctrl->id) {
+	case V4L2_CID_VBLANK:
+		/* Update max exposure while meeting expected vblanking */
+		max = ov13858->cur_mode->height + ctrl->val - 8;
+		__v4l2_ctrl_modify_range(ov13858->exposure,
+					 ov13858->exposure->minimum,
+					 max, ov13858->exposure->step, max);
+		break;
+	}
+
+	/*
+	 * Applying V4L2 control value only happens
+	 * when power is up for streaming
+	 */
+	if (!pm_runtime_get_if_in_use(&client->dev))
+		return 0;
+
+	ret = 0;
+	switch (ctrl->id) {
+	case V4L2_CID_ANALOGUE_GAIN:
+		ret = ov13858_write_reg(ov13858, OV13858_REG_ANALOG_GAIN,
+					OV13858_REG_VALUE_16BIT, ctrl->val);
+		break;
+	case V4L2_CID_DIGITAL_GAIN:
+		ret = ov13858_update_digital_gain(ov13858, ctrl->val);
+		break;
+	case V4L2_CID_EXPOSURE:
+		ret = ov13858_write_reg(ov13858, OV13858_REG_EXPOSURE,
+					OV13858_REG_VALUE_24BIT,
+					ctrl->val << 4);
+		break;
+	case V4L2_CID_VBLANK:
+		/* Update VTS that meets expected vertical blanking */
+		ret = ov13858_write_reg(ov13858, OV13858_REG_VTS,
+					OV13858_REG_VALUE_16BIT,
+					ov13858->cur_mode->height
+					  + ctrl->val);
+		break;
+	case V4L2_CID_TEST_PATTERN:
+		ret = ov13858_enable_test_pattern(ov13858, ctrl->val);
+		break;
+	case V4L2_CID_HFLIP:
+		ov13858->fmt1.bits.hflip = !ctrl->val;
+		ret = ov13858_write_reg(ov13858, OV13858_REG_FORMAT1,
+					OV13858_REG_VALUE_08BIT, ov13858->fmt1.val);
+		break;
+	case V4L2_CID_VFLIP:
+		ov13858->fmt1.bits.vflip = ctrl->val;
+		ret = ov13858_write_reg(ov13858, OV13858_REG_FORMAT1,
+					OV13858_REG_VALUE_08BIT, ov13858->fmt1.val);
+		break;
+	default:
+		dev_info(&client->dev,
+			 "ctrl(id:0x%x,val:0x%x) is not handled\n",
+			 ctrl->id, ctrl->val);
+		break;
+	}
+
+	pm_runtime_put(&client->dev);
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops ov13858_ctrl_ops = {
+	.s_ctrl = ov13858_set_ctrl,
+};
+
+static int ov13858_enum_mbus_code(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_pad_config *cfg,
+				  struct v4l2_subdev_mbus_code_enum *code)
+{
+	/* Only one bayer order(GRBG) is supported */
+	if (code->index > 0)
+		return -EINVAL;
+
+	code->code = MEDIA_BUS_FMT_SGRBG10_1X10;
+
+	return 0;
+}
+
+static int ov13858_enum_frame_size(struct v4l2_subdev *sd,
+				   struct v4l2_subdev_pad_config *cfg,
+				   struct v4l2_subdev_frame_size_enum *fse)
+{
+	if (fse->index >= ARRAY_SIZE(supported_modes))
+		return -EINVAL;
+
+	if (fse->code != MEDIA_BUS_FMT_SGRBG10_1X10)
+		return -EINVAL;
+
+	fse->min_width = supported_modes[fse->index].width;
+	fse->max_width = fse->min_width;
+	fse->min_height = supported_modes[fse->index].height;
+	fse->max_height = fse->min_height;
+
+	return 0;
+}
+
+static void ov13858_update_pad_format(const struct ov13858_mode *mode,
+				      struct v4l2_subdev_format *fmt)
+{
+	fmt->format.width = mode->width;
+	fmt->format.height = mode->height;
+	fmt->format.code = MEDIA_BUS_FMT_SGRBG10_1X10;
+	fmt->format.field = V4L2_FIELD_NONE;
+}
+
+static int ov13858_do_get_pad_format(struct ov13858 *ov13858,
+				     struct v4l2_subdev_pad_config *cfg,
+				     struct v4l2_subdev_format *fmt)
+{
+	struct v4l2_mbus_framefmt *framefmt;
+	struct v4l2_subdev *sd = &ov13858->sd;
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {
+		framefmt = v4l2_subdev_get_try_format(sd, cfg, fmt->pad);
+		fmt->format = *framefmt;
+	} else {
+		ov13858_update_pad_format(ov13858->cur_mode, fmt);
+	}
+
+	return 0;
+}
+
+static int ov13858_get_pad_format(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_pad_config *cfg,
+				  struct v4l2_subdev_format *fmt)
+{
+	struct ov13858 *ov13858 = to_ov13858(sd);
+	int ret;
+
+	mutex_lock(&ov13858->mutex);
+	ret = ov13858_do_get_pad_format(ov13858, cfg, fmt);
+	mutex_unlock(&ov13858->mutex);
+
+	return ret;
+}
+
+static int
+ov13858_set_pad_format(struct v4l2_subdev *sd,
+		       struct v4l2_subdev_pad_config *cfg,
+		       struct v4l2_subdev_format *fmt)
+{
+	struct ov13858 *ov13858 = to_ov13858(sd);
+	const struct ov13858_mode *mode;
+	struct v4l2_mbus_framefmt *framefmt;
+	s32 vblank_def;
+	s32 vblank_min;
+	s64 h_blank;
+	s64 pixel_rate;
+	s64 link_freq;
+
+	mutex_lock(&ov13858->mutex);
+
+	/* Only one raw bayer(GRBG) order is supported */
+	if (fmt->format.code != MEDIA_BUS_FMT_SGRBG10_1X10)
+		fmt->format.code = MEDIA_BUS_FMT_SGRBG10_1X10;
+
+	mode = v4l2_find_nearest_size(supported_modes,
+				      ARRAY_SIZE(supported_modes),
+				      width, height,
+				      fmt->format.width, fmt->format.height);
+	ov13858_update_pad_format(mode, fmt);
+	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {
+		framefmt = v4l2_subdev_get_try_format(sd, cfg, fmt->pad);
+		*framefmt = fmt->format;
+	} else {
+		ov13858->cur_mode = mode;
+		__v4l2_ctrl_s_ctrl(ov13858->link_freq, mode->link_freq_index);
+		link_freq = link_freq_menu_items[mode->link_freq_index];
+		pixel_rate = link_freq_to_pixel_rate(link_freq);
+		__v4l2_ctrl_s_ctrl_int64(ov13858->pixel_rate, pixel_rate);
+
+		/* Update limits and set FPS to default */
+		vblank_def = ov13858->cur_mode->vts_def -
+			     ov13858->cur_mode->height;
+		vblank_min = ov13858->cur_mode->vts_min -
+			     ov13858->cur_mode->height;
+		__v4l2_ctrl_modify_range(
+			ov13858->vblank, vblank_min,
+			OV13858_VTS_MAX - ov13858->cur_mode->height, 1,
+			vblank_def);
+		__v4l2_ctrl_s_ctrl(ov13858->vblank, vblank_def);
+		h_blank =
+			link_freq_configs[mode->link_freq_index].pixels_per_line
+			 - ov13858->cur_mode->width;
+		__v4l2_ctrl_modify_range(ov13858->hblank, h_blank,
+					 h_blank, 1, h_blank);
+	}
+
+	mutex_unlock(&ov13858->mutex);
+
+	return 0;
+}
+
+static int ov13858_get_skip_frames(struct v4l2_subdev *sd, u32 *frames)
+{
+	*frames = OV13858_NUM_OF_SKIP_FRAMES;
+
+	return 0;
+}
+
+/* Start streaming */
+static int ov13858_start_streaming(struct ov13858 *ov13858)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&ov13858->sd);
+	const struct ov13858_reg_list *reg_list;
+	int ret, link_freq_index;
+
+	/* Get out of from software reset */
+	ret = ov13858_write_reg(ov13858, OV13858_REG_SOFTWARE_RST,
+				OV13858_REG_VALUE_08BIT, OV13858_SOFTWARE_RST);
+	if (ret) {
+		dev_err(&client->dev, "%s failed to set powerup registers\n",
+			__func__);
+		return ret;
+	}
+
+	/* Setup PLL */
+	link_freq_index = ov13858->cur_mode->link_freq_index;
+	reg_list = &link_freq_configs[link_freq_index].reg_list;
+	ret = ov13858_write_reg_list(ov13858, reg_list);
+	if (ret) {
+		dev_err(&client->dev, "%s failed to set plls\n", __func__);
+		return ret;
+	}
+
+	/* Apply default values of current mode */
+	reg_list = &ov13858->cur_mode->reg_list;
+	ret = ov13858_write_reg_list(ov13858, reg_list);
+	if (ret) {
+		dev_err(&client->dev, "%s failed to set mode\n", __func__);
+		return ret;
+	}
+
+	/* Apply customized values from user */
+	ret =  __v4l2_ctrl_handler_setup(ov13858->sd.ctrl_handler);
+	if (ret)
+		return ret;
+
+	return ov13858_write_reg(ov13858, OV13858_REG_MODE_SELECT,
+				 OV13858_REG_VALUE_08BIT,
+				 OV13858_MODE_STREAMING);
+}
+
+/* Stop streaming */
+static int ov13858_stop_streaming(struct ov13858 *ov13858)
+{
+	return ov13858_write_reg(ov13858, OV13858_REG_MODE_SELECT,
+				 OV13858_REG_VALUE_08BIT, OV13858_MODE_STANDBY);
+}
+
+static int ov13858_set_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct ov13858 *ov13858 = to_ov13858(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = 0;
+
+	mutex_lock(&ov13858->mutex);
+	if (ov13858->streaming == enable) {
+		mutex_unlock(&ov13858->mutex);
+		return 0;
+	}
+
+	if (enable) {
+		ret = pm_runtime_get_sync(&client->dev);
+		if (ret < 0) {
+			pm_runtime_put_noidle(&client->dev);
+			goto err_unlock;
+		}
+
+		/*
+		 * Apply default & customized values
+		 * and then start streaming.
+		 */
+		ret = ov13858_start_streaming(ov13858);
+		if (ret)
+			goto err_rpm_put;
+	} else {
+		ov13858_stop_streaming(ov13858);
+		pm_runtime_put(&client->dev);
+	}
+
+	ov13858->streaming = enable;
+	mutex_unlock(&ov13858->mutex);
+
+	return ret;
+
+err_rpm_put:
+	pm_runtime_put(&client->dev);
+err_unlock:
+	mutex_unlock(&ov13858->mutex);
+
+	return ret;
+}
+
+static int __maybe_unused ov13858_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov13858 *ov13858 = to_ov13858(sd);
+
+	if (ov13858->streaming)
+		ov13858_stop_streaming(ov13858);
+
+	return 0;
+}
+
+static int __maybe_unused ov13858_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov13858 *ov13858 = to_ov13858(sd);
+	int ret;
+
+	if (ov13858->streaming) {
+		ret = ov13858_start_streaming(ov13858);
+		if (ret)
+			goto error;
+	}
+
+	return 0;
+
+error:
+	ov13858_stop_streaming(ov13858);
+	ov13858->streaming = false;
+	return ret;
+}
+
+/* Verify chip ID */
+static int ov13858_identify_module(struct ov13858 *ov13858)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&ov13858->sd);
+	int ret;
+	u32 val;
+
+	ret = ov13858_read_reg(ov13858, OV13858_REG_CHIP_ID,
+			       OV13858_REG_VALUE_24BIT, &val);
+	if (ret)
+		return ret;
+
+	if (val != OV13858_CHIP_ID) {
+		dev_err(&client->dev, "chip id mismatch: %x!=%x\n",
+			OV13858_CHIP_ID, val);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static const struct v4l2_subdev_video_ops ov13858_video_ops = {
+	.s_stream = ov13858_set_stream,
+};
+
+static const struct v4l2_subdev_pad_ops ov13858_pad_ops = {
+	.enum_mbus_code = ov13858_enum_mbus_code,
+	.get_fmt = ov13858_get_pad_format,
+	.set_fmt = ov13858_set_pad_format,
+	.enum_frame_size = ov13858_enum_frame_size,
+};
+
+static const struct v4l2_subdev_sensor_ops ov13858_sensor_ops = {
+	.g_skip_frames = ov13858_get_skip_frames,
+};
+
+static const struct v4l2_subdev_ops ov13858_subdev_ops = {
+	.video = &ov13858_video_ops,
+	.pad = &ov13858_pad_ops,
+	.sensor = &ov13858_sensor_ops,
+};
+
+static const struct media_entity_operations ov13858_subdev_entity_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+static const struct v4l2_subdev_internal_ops ov13858_internal_ops = {
+	.open = ov13858_open,
+};
+
+/* Initialize control handlers */
+static int ov13858_init_controls(struct ov13858 *ov13858)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&ov13858->sd);
+	struct v4l2_fwnode_device_properties props;
+	struct v4l2_ctrl_handler *ctrl_hdlr;
+	s64 exposure_max;
+	s64 vblank_def;
+	s64 vblank_min;
+	s64 hblank;
+	s64 pixel_rate_min;
+	s64 pixel_rate_max;
+	const struct ov13858_mode *mode;
+	int ret;
+
+	ctrl_hdlr = &ov13858->ctrl_handler;
+	ret = v4l2_ctrl_handler_init(ctrl_hdlr, 10);
+	if (ret)
+		return ret;
+
+	mutex_init(&ov13858->mutex);
+	ctrl_hdlr->lock = &ov13858->mutex;
+	ov13858->link_freq = v4l2_ctrl_new_int_menu(ctrl_hdlr,
+				&ov13858_ctrl_ops,
+				V4L2_CID_LINK_FREQ,
+				OV13858_NUM_OF_LINK_FREQS - 1,
+				0,
+				link_freq_menu_items);
+	if (ov13858->link_freq)
+		ov13858->link_freq->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	pixel_rate_max = link_freq_to_pixel_rate(link_freq_menu_items[0]);
+	pixel_rate_min = link_freq_to_pixel_rate(link_freq_menu_items[1]);
+	/* By default, PIXEL_RATE is read only */
+	ov13858->pixel_rate = v4l2_ctrl_new_std(ctrl_hdlr, &ov13858_ctrl_ops,
+						V4L2_CID_PIXEL_RATE,
+						pixel_rate_min, pixel_rate_max,
+						1, pixel_rate_max);
+
+	mode = ov13858->cur_mode;
+	vblank_def = mode->vts_def - mode->height;
+	vblank_min = mode->vts_min - mode->height;
+	ov13858->vblank = v4l2_ctrl_new_std(
+				ctrl_hdlr, &ov13858_ctrl_ops, V4L2_CID_VBLANK,
+				vblank_min, OV13858_VTS_MAX - mode->height, 1,
+				vblank_def);
+
+	hblank = link_freq_configs[mode->link_freq_index].pixels_per_line -
+		 mode->width;
+	ov13858->hblank = v4l2_ctrl_new_std(
+				ctrl_hdlr, &ov13858_ctrl_ops, V4L2_CID_HBLANK,
+				hblank, hblank, 1, hblank);
+	if (ov13858->hblank)
+		ov13858->hblank->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	exposure_max = mode->vts_def - 8;
+	ov13858->exposure = v4l2_ctrl_new_std(
+				ctrl_hdlr, &ov13858_ctrl_ops,
+				V4L2_CID_EXPOSURE, OV13858_EXPOSURE_MIN,
+				exposure_max, OV13858_EXPOSURE_STEP,
+				OV13858_EXPOSURE_DEFAULT);
+
+	ov13858->hflip = v4l2_ctrl_new_std(
+				ctrl_hdlr, &ov13858_ctrl_ops,
+				V4L2_CID_HFLIP, 0, 1, 1, 0);
+
+	ov13858->vflip = v4l2_ctrl_new_std(
+				ctrl_hdlr, &ov13858_ctrl_ops,
+				V4L2_CID_VFLIP, 0, 1, 1, 0);
+	ov13858->fmt1.val =  OV13858_FORMAT1_DFT;
+
+	v4l2_ctrl_new_std(ctrl_hdlr, &ov13858_ctrl_ops, V4L2_CID_ANALOGUE_GAIN,
+			  OV13858_ANA_GAIN_MIN, OV13858_ANA_GAIN_MAX,
+			  OV13858_ANA_GAIN_STEP, OV13858_ANA_GAIN_DEFAULT);
+
+	/* Digital gain */
+	v4l2_ctrl_new_std(ctrl_hdlr, &ov13858_ctrl_ops, V4L2_CID_DIGITAL_GAIN,
+			  OV13858_DGTL_GAIN_MIN, OV13858_DGTL_GAIN_MAX,
+			  OV13858_DGTL_GAIN_STEP, OV13858_DGTL_GAIN_DEFAULT);
+
+	v4l2_ctrl_new_std_menu_items(ctrl_hdlr, &ov13858_ctrl_ops,
+				     V4L2_CID_TEST_PATTERN,
+				     ARRAY_SIZE(ov13858_test_pattern_menu) - 1,
+				     0, 0, ov13858_test_pattern_menu);
+	if (ctrl_hdlr->error) {
+		ret = ctrl_hdlr->error;
+		dev_err(&client->dev, "%s control init failed (%d)\n",
+			__func__, ret);
+		goto error;
+	}
+
+	ret = v4l2_fwnode_device_parse(&client->dev, &props);
+	if (ret)
+		goto error;
+
+	ret = v4l2_ctrl_new_fwnode_properties(ctrl_hdlr, &ov13858_ctrl_ops,
+					      &props);
+	if (ret)
+		goto error;
+
+	ov13858->sd.ctrl_handler = ctrl_hdlr;
+
+	return 0;
+
+error:
+	v4l2_ctrl_handler_free(ctrl_hdlr);
+	mutex_destroy(&ov13858->mutex);
+
+	return ret;
+}
+
+static void ov13858_free_controls(struct ov13858 *ov13858)
+{
+	v4l2_ctrl_handler_free(ov13858->sd.ctrl_handler);
+	mutex_destroy(&ov13858->mutex);
+}
+
+static int ov13858_probe(struct i2c_client *client,
+			 const struct i2c_device_id *devid)
+{
+	struct ov13858 *ov13858;
+	int ret;
+	u32 val = 0;
+
+	device_property_read_u32(&client->dev, "clock-frequency", &val);
+	if (val != 19200000)
+		return -EINVAL;
+
+	ov13858 = devm_kzalloc(&client->dev, sizeof(*ov13858), GFP_KERNEL);
+	if (!ov13858)
+		return -ENOMEM;
+
+	/* Initialize subdev */
+	v4l2_i2c_subdev_init(&ov13858->sd, client, &ov13858_subdev_ops);
+
+	/* Check module identity */
+	ret = ov13858_identify_module(ov13858);
+	if (ret) {
+		dev_err(&client->dev, "failed to find sensor: %d\n", ret);
+		return ret;
+	}
+
+	/* Set default mode to max resolution */
+	ov13858->cur_mode = &supported_modes[0];
+
+	ret = ov13858_init_controls(ov13858);
+	if (ret)
+		return ret;
+
+	/* Initialize subdev */
+	ov13858->sd.internal_ops = &ov13858_internal_ops;
+	ov13858->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	ov13858->sd.entity.ops = &ov13858_subdev_entity_ops;
+	ov13858->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;
+
+	/* Initialize source pad */
+	ov13858->pad.flags = MEDIA_PAD_FL_SOURCE;
+	ret = media_entity_pads_init(&ov13858->sd.entity, 1, &ov13858->pad);
+	if (ret) {
+		dev_err(&client->dev, "%s failed:%d\n", __func__, ret);
+		goto error_handler_free;
+	}
+
+	ret = v4l2_async_register_subdev_sensor_common(&ov13858->sd);
+	if (ret < 0)
+		goto error_media_entity;
+
+	/*
+	 * Device is already turned on by i2c-core with ACPI domain PM.
+	 * Enable runtime PM and turn off the device.
+	 */
+	pm_runtime_set_active(&client->dev);
+	pm_runtime_enable(&client->dev);
+	pm_runtime_idle(&client->dev);
+
+	return 0;
+
+error_media_entity:
+	media_entity_cleanup(&ov13858->sd.entity);
+
+error_handler_free:
+	ov13858_free_controls(ov13858);
+	dev_err(&client->dev, "%s failed:%d\n", __func__, ret);
+
+	return ret;
+}
+
+static int ov13858_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov13858 *ov13858 = to_ov13858(sd);
+
+	v4l2_async_unregister_subdev(sd);
+	media_entity_cleanup(&sd->entity);
+	ov13858_free_controls(ov13858);
+
+	pm_runtime_disable(&client->dev);
+
+	return 0;
+}
+
+static const struct i2c_device_id ov13858_id_table[] = {
+	{"ov13858", 0},
+	{},
+};
+
+MODULE_DEVICE_TABLE(i2c, ov13858_id_table);
+
+static const struct dev_pm_ops ov13858_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(ov13858_suspend, ov13858_resume)
+};
+
+#ifdef CONFIG_ACPI
+static const struct acpi_device_id ov13858_acpi_ids[] = {
+	{"OVTID858"},
+	{ /* sentinel */ }
+};
+
+MODULE_DEVICE_TABLE(acpi, ov13858_acpi_ids);
+#endif
+
+static struct i2c_driver ov13858_i2c_driver = {
+	.driver = {
+		.name = "ov13858",
+		.pm = &ov13858_pm_ops,
+		.acpi_match_table = ACPI_PTR(ov13858_acpi_ids),
+	},
+	.probe = ov13858_probe,
+	.remove = ov13858_remove,
+	.id_table = ov13858_id_table,
+};
+
+module_i2c_driver(ov13858_i2c_driver);
+
+MODULE_AUTHOR("Kan, Chris <chris.kan@intel.com>");
+MODULE_AUTHOR("Rapolu, Chiranjeevi <chiranjeevi.rapolu@intel.com>");
+MODULE_AUTHOR("Yang, Hyungwoo <hyungwoo.yang@intel.com>");
+MODULE_DESCRIPTION("Omnivision ov13858 sensor driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/i2c/ov8856.c b/drivers/media/i2c/ov8856.c
index aa74744b91c7..db52650ad512 100644
--- a/drivers/media/i2c/ov8856.c
+++ b/drivers/media/i2c/ov8856.c
@@ -1,15 +1,13 @@
 // SPDX-License-Identifier: GPL-2.0
-// Copyright (c) 2019 Intel Corporation.
+// Copyright (c) 2021 Intel Corporation.
 
 #include <asm/unaligned.h>
 #include <linux/acpi.h>
-#include <linux/clk.h>
 #include <linux/delay.h>
-#include <linux/gpio/consumer.h>
 #include <linux/i2c.h>
 #include <linux/module.h>
 #include <linux/pm_runtime.h>
-#include <linux/regulator/consumer.h>
+#include <linux/version.h>
 #include <media/v4l2-ctrls.h>
 #include <media/v4l2-device.h>
 #include <media/v4l2-fwnode.h>
@@ -18,8 +16,10 @@
 #define OV8856_REG_VALUE_16BIT		2
 #define OV8856_REG_VALUE_24BIT		3
 
+#define OV8856_LINK_FREQ_360MHZ		360000000ULL
+#define OV8856_LINK_FREQ_264MHZ		264000000ULL
 #define OV8856_SCLK			144000000ULL
-#define OV8856_XVCLK_19_2		19200000
+#define OV8856_MCLK			19200000
 #define OV8856_DATA_LANES		4
 #define OV8856_RGB_DEPTH		10
 
@@ -30,19 +30,6 @@
 #define OV8856_MODE_STANDBY		0x00
 #define OV8856_MODE_STREAMING		0x01
 
-/* module revisions */
-#define OV8856_2A_MODULE		0x01
-#define OV8856_1B_MODULE		0x02
-
-/* the OTP read-out buffer is at 0x7000 and 0xf is the offset
- * of the byte in the OTP that means the module revision
- */
-#define OV8856_MODULE_REVISION		0x700f
-#define OV8856_OTP_MODE_CTRL		0x3d84
-#define OV8856_OTP_LOAD_CTRL		0x3d81
-#define OV8856_OTP_MODE_AUTO		0x00
-#define OV8856_OTP_LOAD_CTRL_ENABLE	BIT(0)
-
 /* vertical-timings from sensor */
 #define OV8856_REG_VTS			0x380e
 #define OV8856_VTS_MAX			0x7fff
@@ -76,35 +63,24 @@
 #define OV8856_TEST_PATTERN_ENABLE	BIT(7)
 #define OV8856_TEST_PATTERN_BAR_SHIFT	2
 
-#define NUM_REGS				7
-#define NUM_MODE_REGS				187
-#define NUM_MODE_REGS_2				200
-
 /* Flip Mirror Controls from sensor */
 #define OV8856_REG_FORMAT1			0x3820
 #define OV8856_REG_FORMAT2			0x3821
-#define OV8856_REG_FORMAT1_OP_1			BIT(1)
-#define OV8856_REG_FORMAT1_OP_2			BIT(2)
-#define OV8856_REG_FORMAT1_OP_3			BIT(6)
-#define OV8856_REG_FORMAT2_OP_1			BIT(1)
-#define OV8856_REG_FORMAT2_OP_2			BIT(2)
-#define OV8856_REG_FORMAT2_OP_3			BIT(6)
-#define OV8856_REG_FLIP_OPT_1			0x376b
-#define OV8856_REG_FLIP_OPT_2			0x5001
-#define OV8856_REG_FLIP_OPT_3			0x502e
-#define OV8856_REG_MIRROR_OPT_1			0x5004
-#define OV8856_REG_FLIP_OP_0			BIT(0)
-#define OV8856_REG_FLIP_OP_1			BIT(1)
-#define OV8856_REG_FLIP_OP_2			BIT(2)
-#define OV8856_REG_MIRROR_OP_1			BIT(1)
-#define OV8856_REG_MIRROR_OP_2			BIT(2)
+#define OV8856_REG_FORMAT1_A_VFLIP		BIT(1)
+#define OV8856_REG_FORMAT1_D_VFLIP		BIT(2)
+#define OV8856_REG_FORMAT1_VFLIP_BLC		BIT(6)
+#define OV8856_REG_FORMAT2_A_HFLIP		BIT(1)
+#define OV8856_REG_FORMAT2_D_HFLIP		BIT(2)
+#define OV8856_REG_ISP_CTRL_1			0x376b
+#define OV8856_REG_ISP_CTRL_2			0x5001
+#define OV8856_REG_ISP_CTRL_3			0x5004
+#define OV8856_REG_ISP_CTRL_4			0x502e
 
 #define to_ov8856(_sd)			container_of(_sd, struct ov8856, sd)
 
-static const char * const ov8856_supply_names[] = {
-	"dovdd",	/* Digital I/O power */
-	"avdd",		/* Analog power */
-	"dvdd",		/* Digital core power */
+enum {
+	OV8856_LINK_FREQ_720MBPS,
+	OV8856_LINK_FREQ_528MBPS,
 };
 
 struct ov8856_reg {
@@ -142,1234 +118,462 @@ struct ov8856_mode {
 
 	/* Sensor register settings for this resolution */
 	const struct ov8856_reg_list reg_list;
-
-	/* Number of data lanes */
-	u8 data_lanes;
-};
-
-struct ov8856_mipi_data_rates {
-	const struct ov8856_reg regs_0[NUM_REGS];
-	const struct ov8856_reg regs_1[NUM_REGS];
-};
-
-static const struct ov8856_mipi_data_rates mipi_data_rate_lane_2 = {
-	//mipi_data_rate_1440mbps
-	{
-		{0x0103, 0x01},
-		{0x0100, 0x00},
-		{0x0302, 0x43},
-		{0x0303, 0x00},
-		{0x030b, 0x02},
-		{0x030d, 0x4b},
-		{0x031e, 0x0c}
-	},
-	//mipi_data_rate_720mbps
-	{
-		{0x0103, 0x01},
-		{0x0100, 0x00},
-		{0x0302, 0x4b},
-		{0x0303, 0x01},
-		{0x030b, 0x02},
-		{0x030d, 0x4b},
-		{0x031e, 0x0c}
-	}
-};
-
-static const struct ov8856_mipi_data_rates mipi_data_rate_lane_4 = {
-	//mipi_data_rate_720mbps
-	{
-		{0x0103, 0x01},
-		{0x0100, 0x00},
-		{0x0302, 0x4b},
-		{0x0303, 0x01},
-		{0x030b, 0x02},
-		{0x030d, 0x4b},
-		{0x031e, 0x0c}
-	},
-	//mipi_data_rate_360mbps
-	{
-		{0x0103, 0x01},
-		{0x0100, 0x00},
-		{0x0302, 0x4b},
-		{0x0303, 0x03},
-		{0x030b, 0x02},
-		{0x030d, 0x4b},
-		{0x031e, 0x0c}
-	}
-};
-
-static const struct ov8856_reg lane_2_mode_3280x2464[] = {
-	/* 3280x2464 resolution */
-		{0x3000, 0x20},
-		{0x3003, 0x08},
-		{0x300e, 0x20},
-		{0x3010, 0x00},
-		{0x3015, 0x84},
-		{0x3018, 0x32},
-		{0x3021, 0x23},
-		{0x3033, 0x24},
-		{0x3500, 0x00},
-		{0x3501, 0x9a},
-		{0x3502, 0x20},
-		{0x3503, 0x08},
-		{0x3505, 0x83},
-		{0x3508, 0x01},
-		{0x3509, 0x80},
-		{0x350c, 0x00},
-		{0x350d, 0x80},
-		{0x350e, 0x04},
-		{0x350f, 0x00},
-		{0x3510, 0x00},
-		{0x3511, 0x02},
-		{0x3512, 0x00},
-		{0x3600, 0x72},
-		{0x3601, 0x40},
-		{0x3602, 0x30},
-		{0x3610, 0xc5},
-		{0x3611, 0x58},
-		{0x3612, 0x5c},
-		{0x3613, 0xca},
-		{0x3614, 0x50},
-		{0x3628, 0xff},
-		{0x3629, 0xff},
-		{0x362a, 0xff},
-		{0x3633, 0x10},
-		{0x3634, 0x10},
-		{0x3635, 0x10},
-		{0x3636, 0x10},
-		{0x3663, 0x08},
-		{0x3669, 0x34},
-		{0x366e, 0x10},
-		{0x3706, 0x86},
-		{0x370b, 0x7e},
-		{0x3714, 0x23},
-		{0x3730, 0x12},
-		{0x3733, 0x10},
-		{0x3764, 0x00},
-		{0x3765, 0x00},
-		{0x3769, 0x62},
-		{0x376a, 0x2a},
-		{0x376b, 0x30},
-		{0x3780, 0x00},
-		{0x3781, 0x24},
-		{0x3782, 0x00},
-		{0x3783, 0x23},
-		{0x3798, 0x2f},
-		{0x37a1, 0x60},
-		{0x37a8, 0x6a},
-		{0x37ab, 0x3f},
-		{0x37c2, 0x04},
-		{0x37c3, 0xf1},
-		{0x37c9, 0x80},
-		{0x37cb, 0x16},
-		{0x37cc, 0x16},
-		{0x37cd, 0x16},
-		{0x37ce, 0x16},
-		{0x3800, 0x00},
-		{0x3801, 0x00},
-		{0x3802, 0x00},
-		{0x3803, 0x06},
-		{0x3804, 0x0c},
-		{0x3805, 0xdf},
-		{0x3806, 0x09},
-		{0x3807, 0xa7},
-		{0x3808, 0x0c},
-		{0x3809, 0xd0},
-		{0x380a, 0x09},
-		{0x380b, 0xa0},
-		{0x380c, 0x07},
-		{0x380d, 0x88},
-		{0x380e, 0x09},
-		{0x380f, 0xb8},
-		{0x3810, 0x00},
-		{0x3811, 0x00},
-		{0x3812, 0x00},
-		{0x3813, 0x01},
-		{0x3814, 0x01},
-		{0x3815, 0x01},
-		{0x3816, 0x00},
-		{0x3817, 0x00},
-		{0x3818, 0x00},
-		{0x3819, 0x00},
-		{0x3820, 0x80},
-		{0x3821, 0x46},
-		{0x382a, 0x01},
-		{0x382b, 0x01},
-		{0x3830, 0x06},
-		{0x3836, 0x02},
-		{0x3837, 0x10},
-		{0x3862, 0x04},
-		{0x3863, 0x08},
-		{0x3cc0, 0x33},
-		{0x3d85, 0x14},
-		{0x3d8c, 0x73},
-		{0x3d8d, 0xde},
-		{0x4001, 0xe0},
-		{0x4003, 0x40},
-		{0x4008, 0x00},
-		{0x4009, 0x0b},
-		{0x400a, 0x00},
-		{0x400b, 0x84},
-		{0x400f, 0x80},
-		{0x4010, 0xf0},
-		{0x4011, 0xff},
-		{0x4012, 0x02},
-		{0x4013, 0x01},
-		{0x4014, 0x01},
-		{0x4015, 0x01},
-		{0x4042, 0x00},
-		{0x4043, 0x80},
-		{0x4044, 0x00},
-		{0x4045, 0x80},
-		{0x4046, 0x00},
-		{0x4047, 0x80},
-		{0x4048, 0x00},
-		{0x4049, 0x80},
-		{0x4041, 0x03},
-		{0x404c, 0x20},
-		{0x404d, 0x00},
-		{0x404e, 0x20},
-		{0x4203, 0x80},
-		{0x4307, 0x30},
-		{0x4317, 0x00},
-		{0x4503, 0x08},
-		{0x4601, 0x80},
-		{0x4800, 0x44},
-		{0x4816, 0x53},
-		{0x481b, 0x58},
-		{0x481f, 0x27},
-		{0x4837, 0x0c},
-		{0x483c, 0x0f},
-		{0x484b, 0x05},
-		{0x5000, 0x57},
-		{0x5001, 0x0a},
-		{0x5004, 0x04},
-		{0x502e, 0x03},
-		{0x5030, 0x41},
-		{0x5795, 0x02},
-		{0x5796, 0x20},
-		{0x5797, 0x20},
-		{0x5798, 0xd5},
-		{0x5799, 0xd5},
-		{0x579a, 0x00},
-		{0x579b, 0x50},
-		{0x579c, 0x00},
-		{0x579d, 0x2c},
-		{0x579e, 0x0c},
-		{0x579f, 0x40},
-		{0x57a0, 0x09},
-		{0x57a1, 0x40},
-		{0x5780, 0x14},
-		{0x5781, 0x0f},
-		{0x5782, 0x44},
-		{0x5783, 0x02},
-		{0x5784, 0x01},
-		{0x5785, 0x01},
-		{0x5786, 0x00},
-		{0x5787, 0x04},
-		{0x5788, 0x02},
-		{0x5789, 0x0f},
-		{0x578a, 0xfd},
-		{0x578b, 0xf5},
-		{0x578c, 0xf5},
-		{0x578d, 0x03},
-		{0x578e, 0x08},
-		{0x578f, 0x0c},
-		{0x5790, 0x08},
-		{0x5791, 0x04},
-		{0x5792, 0x00},
-		{0x5793, 0x52},
-		{0x5794, 0xa3},
-		{0x59f8, 0x3d},
-		{0x5a08, 0x02},
-		{0x5b00, 0x02},
-		{0x5b01, 0x10},
-		{0x5b02, 0x03},
-		{0x5b03, 0xcf},
-		{0x5b05, 0x6c},
-		{0x5e00, 0x00}
-};
-
-static const struct ov8856_reg lane_2_mode_1640x1232[] = {
-	/* 1640x1232 resolution */
-		{0x3000, 0x20},
-		{0x3003, 0x08},
-		{0x300e, 0x20},
-		{0x3010, 0x00},
-		{0x3015, 0x84},
-		{0x3018, 0x32},
-		{0x3021, 0x23},
-		{0x3033, 0x24},
-		{0x3500, 0x00},
-		{0x3501, 0x4c},
-		{0x3502, 0xe0},
-		{0x3503, 0x08},
-		{0x3505, 0x83},
-		{0x3508, 0x01},
-		{0x3509, 0x80},
-		{0x350c, 0x00},
-		{0x350d, 0x80},
-		{0x350e, 0x04},
-		{0x350f, 0x00},
-		{0x3510, 0x00},
-		{0x3511, 0x02},
-		{0x3512, 0x00},
-		{0x3600, 0x72},
-		{0x3601, 0x40},
-		{0x3602, 0x30},
-		{0x3610, 0xc5},
-		{0x3611, 0x58},
-		{0x3612, 0x5c},
-		{0x3613, 0xca},
-		{0x3614, 0x50},
-		{0x3628, 0xff},
-		{0x3629, 0xff},
-		{0x362a, 0xff},
-		{0x3633, 0x10},
-		{0x3634, 0x10},
-		{0x3635, 0x10},
-		{0x3636, 0x10},
-		{0x3663, 0x08},
-		{0x3669, 0x34},
-		{0x366e, 0x08},
-		{0x3706, 0x86},
-		{0x370b, 0x7e},
-		{0x3714, 0x27},
-		{0x3730, 0x12},
-		{0x3733, 0x10},
-		{0x3764, 0x00},
-		{0x3765, 0x00},
-		{0x3769, 0x62},
-		{0x376a, 0x2a},
-		{0x376b, 0x30},
-		{0x3780, 0x00},
-		{0x3781, 0x24},
-		{0x3782, 0x00},
-		{0x3783, 0x23},
-		{0x3798, 0x2f},
-		{0x37a1, 0x60},
-		{0x37a8, 0x6a},
-		{0x37ab, 0x3f},
-		{0x37c2, 0x14},
-		{0x37c3, 0xf1},
-		{0x37c9, 0x80},
-		{0x37cb, 0x16},
-		{0x37cc, 0x16},
-		{0x37cd, 0x16},
-		{0x37ce, 0x16},
-		{0x3800, 0x00},
-		{0x3801, 0x00},
-		{0x3802, 0x00},
-		{0x3803, 0x00},
-		{0x3804, 0x0c},
-		{0x3805, 0xdf},
-		{0x3806, 0x09},
-		{0x3807, 0xaf},
-		{0x3808, 0x06},
-		{0x3809, 0x68},
-		{0x380a, 0x04},
-		{0x380b, 0xd0},
-		{0x380c, 0x0c},
-		{0x380d, 0x60},
-		{0x380e, 0x05},
-		{0x380f, 0xea},
-		{0x3810, 0x00},
-		{0x3811, 0x04},
-		{0x3812, 0x00},
-		{0x3813, 0x05},
-		{0x3814, 0x03},
-		{0x3815, 0x01},
-		{0x3816, 0x00},
-		{0x3817, 0x00},
-		{0x3818, 0x00},
-		{0x3819, 0x00},
-		{0x3820, 0x90},
-		{0x3821, 0x67},
-		{0x382a, 0x03},
-		{0x382b, 0x01},
-		{0x3830, 0x06},
-		{0x3836, 0x02},
-		{0x3837, 0x10},
-		{0x3862, 0x04},
-		{0x3863, 0x08},
-		{0x3cc0, 0x33},
-		{0x3d85, 0x14},
-		{0x3d8c, 0x73},
-		{0x3d8d, 0xde},
-		{0x4001, 0xe0},
-		{0x4003, 0x40},
-		{0x4008, 0x00},
-		{0x4009, 0x05},
-		{0x400a, 0x00},
-		{0x400b, 0x84},
-		{0x400f, 0x80},
-		{0x4010, 0xf0},
-		{0x4011, 0xff},
-		{0x4012, 0x02},
-		{0x4013, 0x01},
-		{0x4014, 0x01},
-		{0x4015, 0x01},
-		{0x4042, 0x00},
-		{0x4043, 0x80},
-		{0x4044, 0x00},
-		{0x4045, 0x80},
-		{0x4046, 0x00},
-		{0x4047, 0x80},
-		{0x4048, 0x00},
-		{0x4049, 0x80},
-		{0x4041, 0x03},
-		{0x404c, 0x20},
-		{0x404d, 0x00},
-		{0x404e, 0x20},
-		{0x4203, 0x80},
-		{0x4307, 0x30},
-		{0x4317, 0x00},
-		{0x4503, 0x08},
-		{0x4601, 0x80},
-		{0x4800, 0x44},
-		{0x4816, 0x53},
-		{0x481b, 0x58},
-		{0x481f, 0x27},
-		{0x4837, 0x16},
-		{0x483c, 0x0f},
-		{0x484b, 0x05},
-		{0x5000, 0x57},
-		{0x5001, 0x0a},
-		{0x5004, 0x04},
-		{0x502e, 0x03},
-		{0x5030, 0x41},
-		{0x5795, 0x00},
-		{0x5796, 0x10},
-		{0x5797, 0x10},
-		{0x5798, 0x73},
-		{0x5799, 0x73},
-		{0x579a, 0x00},
-		{0x579b, 0x28},
-		{0x579c, 0x00},
-		{0x579d, 0x16},
-		{0x579e, 0x06},
-		{0x579f, 0x20},
-		{0x57a0, 0x04},
-		{0x57a1, 0xa0},
-		{0x5780, 0x14},
-		{0x5781, 0x0f},
-		{0x5782, 0x44},
-		{0x5783, 0x02},
-		{0x5784, 0x01},
-		{0x5785, 0x01},
-		{0x5786, 0x00},
-		{0x5787, 0x04},
-		{0x5788, 0x02},
-		{0x5789, 0x0f},
-		{0x578a, 0xfd},
-		{0x578b, 0xf5},
-		{0x578c, 0xf5},
-		{0x578d, 0x03},
-		{0x578e, 0x08},
-		{0x578f, 0x0c},
-		{0x5790, 0x08},
-		{0x5791, 0x04},
-		{0x5792, 0x00},
-		{0x5793, 0x52},
-		{0x5794, 0xa3},
-		{0x59f8, 0x3d},
-		{0x5a08, 0x02},
-		{0x5b00, 0x02},
-		{0x5b01, 0x10},
-		{0x5b02, 0x03},
-		{0x5b03, 0xcf},
-		{0x5b05, 0x6c},
-		{0x5e00, 0x00}
 };
 
-static const struct ov8856_reg lane_4_mode_3280x2464[] = {
-	/* 3280x2464 resolution */
-		{0x3000, 0x20},
-		{0x3003, 0x08},
-		{0x300e, 0x20},
-		{0x3010, 0x00},
-		{0x3015, 0x84},
-		{0x3018, 0x72},
-		{0x3021, 0x23},
-		{0x3033, 0x24},
-		{0x3500, 0x00},
-		{0x3501, 0x9a},
-		{0x3502, 0x20},
-		{0x3503, 0x08},
-		{0x3505, 0x83},
-		{0x3508, 0x01},
-		{0x3509, 0x80},
-		{0x350c, 0x00},
-		{0x350d, 0x80},
-		{0x350e, 0x04},
-		{0x350f, 0x00},
-		{0x3510, 0x00},
-		{0x3511, 0x02},
-		{0x3512, 0x00},
-		{0x3600, 0x72},
-		{0x3601, 0x40},
-		{0x3602, 0x30},
-		{0x3610, 0xc5},
-		{0x3611, 0x58},
-		{0x3612, 0x5c},
-		{0x3613, 0xca},
-		{0x3614, 0x20},
-		{0x3628, 0xff},
-		{0x3629, 0xff},
-		{0x362a, 0xff},
-		{0x3633, 0x10},
-		{0x3634, 0x10},
-		{0x3635, 0x10},
-		{0x3636, 0x10},
-		{0x3663, 0x08},
-		{0x3669, 0x34},
-		{0x366e, 0x10},
-		{0x3706, 0x86},
-		{0x370b, 0x7e},
-		{0x3714, 0x23},
-		{0x3730, 0x12},
-		{0x3733, 0x10},
-		{0x3764, 0x00},
-		{0x3765, 0x00},
-		{0x3769, 0x62},
-		{0x376a, 0x2a},
-		{0x376b, 0x30},
-		{0x3780, 0x00},
-		{0x3781, 0x24},
-		{0x3782, 0x00},
-		{0x3783, 0x23},
-		{0x3798, 0x2f},
-		{0x37a1, 0x60},
-		{0x37a8, 0x6a},
-		{0x37ab, 0x3f},
-		{0x37c2, 0x04},
-		{0x37c3, 0xf1},
-		{0x37c9, 0x80},
-		{0x37cb, 0x16},
-		{0x37cc, 0x16},
-		{0x37cd, 0x16},
-		{0x37ce, 0x16},
-		{0x3800, 0x00},
-		{0x3801, 0x00},
-		{0x3802, 0x00},
-		{0x3803, 0x06},
-		{0x3804, 0x0c},
-		{0x3805, 0xdf},
-		{0x3806, 0x09},
-		{0x3807, 0xa7},
-		{0x3808, 0x0c},
-		{0x3809, 0xd0},
-		{0x380a, 0x09},
-		{0x380b, 0xa0},
-		{0x380c, 0x07},
-		{0x380d, 0x88},
-		{0x380e, 0x09},
-		{0x380f, 0xb8},
-		{0x3810, 0x00},
-		{0x3811, 0x00},
-		{0x3812, 0x00},
-		{0x3813, 0x01},
-		{0x3814, 0x01},
-		{0x3815, 0x01},
-		{0x3816, 0x00},
-		{0x3817, 0x00},
-		{0x3818, 0x00},
-		{0x3819, 0x10},
-		{0x3820, 0x80},
-		{0x3821, 0x46},
-		{0x382a, 0x01},
-		{0x382b, 0x01},
-		{0x3830, 0x06},
-		{0x3836, 0x02},
-		{0x3862, 0x04},
-		{0x3863, 0x08},
-		{0x3cc0, 0x33},
-		{0x3d85, 0x17},
-		{0x3d8c, 0x73},
-		{0x3d8d, 0xde},
-		{0x4001, 0xe0},
-		{0x4003, 0x40},
-		{0x4008, 0x00},
-		{0x4009, 0x0b},
-		{0x400a, 0x00},
-		{0x400b, 0x84},
-		{0x400f, 0x80},
-		{0x4010, 0xf0},
-		{0x4011, 0xff},
-		{0x4012, 0x02},
-		{0x4013, 0x01},
-		{0x4014, 0x01},
-		{0x4015, 0x01},
-		{0x4042, 0x00},
-		{0x4043, 0x80},
-		{0x4044, 0x00},
-		{0x4045, 0x80},
-		{0x4046, 0x00},
-		{0x4047, 0x80},
-		{0x4048, 0x00},
-		{0x4049, 0x80},
-		{0x4041, 0x03},
-		{0x404c, 0x20},
-		{0x404d, 0x00},
-		{0x404e, 0x20},
-		{0x4203, 0x80},
-		{0x4307, 0x30},
-		{0x4317, 0x00},
-		{0x4503, 0x08},
-		{0x4601, 0x80},
-		{0x4800, 0x44},
-		{0x4816, 0x53},
-		{0x481b, 0x58},
-		{0x481f, 0x27},
-		{0x4837, 0x16},
-		{0x483c, 0x0f},
-		{0x484b, 0x05},
-		{0x5000, 0x57},
-		{0x5001, 0x0a},
-		{0x5004, 0x04},
-		{0x502e, 0x03},
-		{0x5030, 0x41},
-		{0x5780, 0x14},
-		{0x5781, 0x0f},
-		{0x5782, 0x44},
-		{0x5783, 0x02},
-		{0x5784, 0x01},
-		{0x5785, 0x01},
-		{0x5786, 0x00},
-		{0x5787, 0x04},
-		{0x5788, 0x02},
-		{0x5789, 0x0f},
-		{0x578a, 0xfd},
-		{0x578b, 0xf5},
-		{0x578c, 0xf5},
-		{0x578d, 0x03},
-		{0x578e, 0x08},
-		{0x578f, 0x0c},
-		{0x5790, 0x08},
-		{0x5791, 0x04},
-		{0x5792, 0x00},
-		{0x5793, 0x52},
-		{0x5794, 0xa3},
-		{0x5795, 0x02},
-		{0x5796, 0x20},
-		{0x5797, 0x20},
-		{0x5798, 0xd5},
-		{0x5799, 0xd5},
-		{0x579a, 0x00},
-		{0x579b, 0x50},
-		{0x579c, 0x00},
-		{0x579d, 0x2c},
-		{0x579e, 0x0c},
-		{0x579f, 0x40},
-		{0x57a0, 0x09},
-		{0x57a1, 0x40},
-		{0x59f8, 0x3d},
-		{0x5a08, 0x02},
-		{0x5b00, 0x02},
-		{0x5b01, 0x10},
-		{0x5b02, 0x03},
-		{0x5b03, 0xcf},
-		{0x5b05, 0x6c},
-		{0x5e00, 0x00}
+static const struct ov8856_reg mipi_data_rate_720mbps[] = {
+	{0x0103, 0x01},
+	{0x0100, 0x00},
+	{0x0302, 0x4b},
+	{0x0303, 0x01},
+	{0x030b, 0x02},
+	{0x030d, 0x4b},
+	{0x031e, 0x0c}
 };
 
-static const struct ov8856_reg lane_4_mode_1640x1232[] = {
-	/* 1640x1232 resolution */
-		{0x3000, 0x20},
-		{0x3003, 0x08},
-		{0x300e, 0x20},
-		{0x3010, 0x00},
-		{0x3015, 0x84},
-		{0x3018, 0x72},
-		{0x3021, 0x23},
-		{0x3033, 0x24},
-		{0x3500, 0x00},
-		{0x3501, 0x4c},
-		{0x3502, 0xe0},
-		{0x3503, 0x08},
-		{0x3505, 0x83},
-		{0x3508, 0x01},
-		{0x3509, 0x80},
-		{0x350c, 0x00},
-		{0x350d, 0x80},
-		{0x350e, 0x04},
-		{0x350f, 0x00},
-		{0x3510, 0x00},
-		{0x3511, 0x02},
-		{0x3512, 0x00},
-		{0x3600, 0x72},
-		{0x3601, 0x40},
-		{0x3602, 0x30},
-		{0x3610, 0xc5},
-		{0x3611, 0x58},
-		{0x3612, 0x5c},
-		{0x3613, 0xca},
-		{0x3614, 0x20},
-		{0x3628, 0xff},
-		{0x3629, 0xff},
-		{0x362a, 0xff},
-		{0x3633, 0x10},
-		{0x3634, 0x10},
-		{0x3635, 0x10},
-		{0x3636, 0x10},
-		{0x3663, 0x08},
-		{0x3669, 0x34},
-		{0x366e, 0x08},
-		{0x3706, 0x86},
-		{0x370b, 0x7e},
-		{0x3714, 0x27},
-		{0x3730, 0x12},
-		{0x3733, 0x10},
-		{0x3764, 0x00},
-		{0x3765, 0x00},
-		{0x3769, 0x62},
-		{0x376a, 0x2a},
-		{0x376b, 0x30},
-		{0x3780, 0x00},
-		{0x3781, 0x24},
-		{0x3782, 0x00},
-		{0x3783, 0x23},
-		{0x3798, 0x2f},
-		{0x37a1, 0x60},
-		{0x37a8, 0x6a},
-		{0x37ab, 0x3f},
-		{0x37c2, 0x14},
-		{0x37c3, 0xf1},
-		{0x37c9, 0x80},
-		{0x37cb, 0x16},
-		{0x37cc, 0x16},
-		{0x37cd, 0x16},
-		{0x37ce, 0x16},
-		{0x3800, 0x00},
-		{0x3801, 0x00},
-		{0x3802, 0x00},
-		{0x3803, 0x00},
-		{0x3804, 0x0c},
-		{0x3805, 0xdf},
-		{0x3806, 0x09},
-		{0x3807, 0xaf},
-		{0x3808, 0x06},
-		{0x3809, 0x68},
-		{0x380a, 0x04},
-		{0x380b, 0xd0},
-		{0x380c, 0x0e},
-		{0x380d, 0xec},
-		{0x380e, 0x04},
-		{0x380f, 0xe8},
-		{0x3810, 0x00},
-		{0x3811, 0x04},
-		{0x3812, 0x00},
-		{0x3813, 0x05},
-		{0x3814, 0x03},
-		{0x3815, 0x01},
-		{0x3816, 0x00},
-		{0x3817, 0x00},
-		{0x3818, 0x00},
-		{0x3819, 0x10},
-		{0x3820, 0x90},
-		{0x3821, 0x67},
-		{0x382a, 0x03},
-		{0x382b, 0x01},
-		{0x3830, 0x06},
-		{0x3836, 0x02},
-		{0x3862, 0x04},
-		{0x3863, 0x08},
-		{0x3cc0, 0x33},
-		{0x3d85, 0x17},
-		{0x3d8c, 0x73},
-		{0x3d8d, 0xde},
-		{0x4001, 0xe0},
-		{0x4003, 0x40},
-		{0x4008, 0x00},
-		{0x4009, 0x05},
-		{0x400a, 0x00},
-		{0x400b, 0x84},
-		{0x400f, 0x80},
-		{0x4010, 0xf0},
-		{0x4011, 0xff},
-		{0x4012, 0x02},
-		{0x4013, 0x01},
-		{0x4014, 0x01},
-		{0x4015, 0x01},
-		{0x4042, 0x00},
-		{0x4043, 0x80},
-		{0x4044, 0x00},
-		{0x4045, 0x80},
-		{0x4046, 0x00},
-		{0x4047, 0x80},
-		{0x4048, 0x00},
-		{0x4049, 0x80},
-		{0x4041, 0x03},
-		{0x404c, 0x20},
-		{0x404d, 0x00},
-		{0x404e, 0x20},
-		{0x4203, 0x80},
-		{0x4307, 0x30},
-		{0x4317, 0x00},
-		{0x4503, 0x08},
-		{0x4601, 0x80},
-		{0x4800, 0x44},
-		{0x4816, 0x53},
-		{0x481b, 0x58},
-		{0x481f, 0x27},
-		{0x4837, 0x16},
-		{0x483c, 0x0f},
-		{0x484b, 0x05},
-		{0x5000, 0x57},
-		{0x5001, 0x0a},
-		{0x5004, 0x04},
-		{0x502e, 0x03},
-		{0x5030, 0x41},
-		{0x5780, 0x14},
-		{0x5781, 0x0f},
-		{0x5782, 0x44},
-		{0x5783, 0x02},
-		{0x5784, 0x01},
-		{0x5785, 0x01},
-		{0x5786, 0x00},
-		{0x5787, 0x04},
-		{0x5788, 0x02},
-		{0x5789, 0x0f},
-		{0x578a, 0xfd},
-		{0x578b, 0xf5},
-		{0x578c, 0xf5},
-		{0x578d, 0x03},
-		{0x578e, 0x08},
-		{0x578f, 0x0c},
-		{0x5790, 0x08},
-		{0x5791, 0x04},
-		{0x5792, 0x00},
-		{0x5793, 0x52},
-		{0x5794, 0xa3},
-		{0x5795, 0x00},
-		{0x5796, 0x10},
-		{0x5797, 0x10},
-		{0x5798, 0x73},
-		{0x5799, 0x73},
-		{0x579a, 0x00},
-		{0x579b, 0x28},
-		{0x579c, 0x00},
-		{0x579d, 0x16},
-		{0x579e, 0x06},
-		{0x579f, 0x20},
-		{0x57a0, 0x04},
-		{0x57a1, 0xa0},
-		{0x59f8, 0x3d},
-		{0x5a08, 0x02},
-		{0x5b00, 0x02},
-		{0x5b01, 0x10},
-		{0x5b02, 0x03},
-		{0x5b03, 0xcf},
-		{0x5b05, 0x6c},
-		{0x5e00, 0x00}
+static const struct ov8856_reg mipi_data_rate_528mbps[] = {
+	{0x0103, 0x01},
+	{0x0100, 0x00},
+	{0x0302, 0x37},
+	{0x0303, 0x01},
+	{0x030b, 0x02},
+	{0x030d, 0x4b},
+	{0x031e, 0x0c}
 };
 
-static const struct ov8856_reg lane_4_mode_3264x2448[] = {
-	/* 3264x2448 resolution */
-		{0x0103, 0x01},
-		{0x0302, 0x3c},
-		{0x0303, 0x01},
-		{0x031e, 0x0c},
-		{0x3000, 0x20},
-		{0x3003, 0x08},
-		{0x300e, 0x20},
-		{0x3010, 0x00},
-		{0x3015, 0x84},
-		{0x3018, 0x72},
-		{0x3021, 0x23},
-		{0x3033, 0x24},
-		{0x3500, 0x00},
-		{0x3501, 0x9a},
-		{0x3502, 0x20},
-		{0x3503, 0x08},
-		{0x3505, 0x83},
-		{0x3508, 0x01},
-		{0x3509, 0x80},
-		{0x350c, 0x00},
-		{0x350d, 0x80},
-		{0x350e, 0x04},
-		{0x350f, 0x00},
-		{0x3510, 0x00},
-		{0x3511, 0x02},
-		{0x3512, 0x00},
-		{0x3600, 0x72},
-		{0x3601, 0x40},
-		{0x3602, 0x30},
-		{0x3610, 0xc5},
-		{0x3611, 0x58},
-		{0x3612, 0x5c},
-		{0x3613, 0xca},
-		{0x3614, 0x60},
-		{0x3628, 0xff},
-		{0x3629, 0xff},
-		{0x362a, 0xff},
-		{0x3633, 0x10},
-		{0x3634, 0x10},
-		{0x3635, 0x10},
-		{0x3636, 0x10},
-		{0x3663, 0x08},
-		{0x3669, 0x34},
-		{0x366d, 0x00},
-		{0x366e, 0x10},
-		{0x3706, 0x86},
-		{0x370b, 0x7e},
-		{0x3714, 0x23},
-		{0x3730, 0x12},
-		{0x3733, 0x10},
-		{0x3764, 0x00},
-		{0x3765, 0x00},
-		{0x3769, 0x62},
-		{0x376a, 0x2a},
-		{0x376b, 0x30},
-		{0x3780, 0x00},
-		{0x3781, 0x24},
-		{0x3782, 0x00},
-		{0x3783, 0x23},
-		{0x3798, 0x2f},
-		{0x37a1, 0x60},
-		{0x37a8, 0x6a},
-		{0x37ab, 0x3f},
-		{0x37c2, 0x04},
-		{0x37c3, 0xf1},
-		{0x37c9, 0x80},
-		{0x37cb, 0x16},
-		{0x37cc, 0x16},
-		{0x37cd, 0x16},
-		{0x37ce, 0x16},
-		{0x3800, 0x00},
-		{0x3801, 0x00},
-		{0x3802, 0x00},
-		{0x3803, 0x0c},
-		{0x3804, 0x0c},
-		{0x3805, 0xdf},
-		{0x3806, 0x09},
-		{0x3807, 0xa3},
-		{0x3808, 0x0c},
-		{0x3809, 0xc0},
-		{0x380a, 0x09},
-		{0x380b, 0x90},
-		{0x380c, 0x07},
-		{0x380d, 0x8c},
-		{0x380e, 0x09},
-		{0x380f, 0xb2},
-		{0x3810, 0x00},
-		{0x3811, 0x04},
-		{0x3812, 0x00},
-		{0x3813, 0x01},
-		{0x3814, 0x01},
-		{0x3815, 0x01},
-		{0x3816, 0x00},
-		{0x3817, 0x00},
-		{0x3818, 0x00},
-		{0x3819, 0x10},
-		{0x3820, 0x80},
-		{0x3821, 0x46},
-		{0x382a, 0x01},
-		{0x382b, 0x01},
-		{0x3830, 0x06},
-		{0x3836, 0x02},
-		{0x3862, 0x04},
-		{0x3863, 0x08},
-		{0x3cc0, 0x33},
-		{0x3d85, 0x17},
-		{0x3d8c, 0x73},
-		{0x3d8d, 0xde},
-		{0x4001, 0xe0},
-		{0x4003, 0x40},
-		{0x4008, 0x00},
-		{0x4009, 0x0b},
-		{0x400a, 0x00},
-		{0x400b, 0x84},
-		{0x400f, 0x80},
-		{0x4010, 0xf0},
-		{0x4011, 0xff},
-		{0x4012, 0x02},
-		{0x4013, 0x01},
-		{0x4014, 0x01},
-		{0x4015, 0x01},
-		{0x4042, 0x00},
-		{0x4043, 0x80},
-		{0x4044, 0x00},
-		{0x4045, 0x80},
-		{0x4046, 0x00},
-		{0x4047, 0x80},
-		{0x4048, 0x00},
-		{0x4049, 0x80},
-		{0x4041, 0x03},
-		{0x404c, 0x20},
-		{0x404d, 0x00},
-		{0x404e, 0x20},
-		{0x4203, 0x80},
-		{0x4307, 0x30},
-		{0x4317, 0x00},
-		{0x4502, 0x50},
-		{0x4503, 0x08},
-		{0x4601, 0x80},
-		{0x4800, 0x44},
-		{0x4816, 0x53},
-		{0x481b, 0x50},
-		{0x481f, 0x27},
-		{0x4823, 0x3c},
-		{0x482b, 0x00},
-		{0x4831, 0x66},
-		{0x4837, 0x16},
-		{0x483c, 0x0f},
-		{0x484b, 0x05},
-		{0x5000, 0x77},
-		{0x5001, 0x0a},
-		{0x5003, 0xc8},
-		{0x5004, 0x04},
-		{0x5006, 0x00},
-		{0x5007, 0x00},
-		{0x502e, 0x03},
-		{0x5030, 0x41},
-		{0x5780, 0x14},
-		{0x5781, 0x0f},
-		{0x5782, 0x44},
-		{0x5783, 0x02},
-		{0x5784, 0x01},
-		{0x5785, 0x01},
-		{0x5786, 0x00},
-		{0x5787, 0x04},
-		{0x5788, 0x02},
-		{0x5789, 0x0f},
-		{0x578a, 0xfd},
-		{0x578b, 0xf5},
-		{0x578c, 0xf5},
-		{0x578d, 0x03},
-		{0x578e, 0x08},
-		{0x578f, 0x0c},
-		{0x5790, 0x08},
-		{0x5791, 0x04},
-		{0x5792, 0x00},
-		{0x5793, 0x52},
-		{0x5794, 0xa3},
-		{0x5795, 0x02},
-		{0x5796, 0x20},
-		{0x5797, 0x20},
-		{0x5798, 0xd5},
-		{0x5799, 0xd5},
-		{0x579a, 0x00},
-		{0x579b, 0x50},
-		{0x579c, 0x00},
-		{0x579d, 0x2c},
-		{0x579e, 0x0c},
-		{0x579f, 0x40},
-		{0x57a0, 0x09},
-		{0x57a1, 0x40},
-		{0x59f8, 0x3d},
-		{0x5a08, 0x02},
-		{0x5b00, 0x02},
-		{0x5b01, 0x10},
-		{0x5b02, 0x03},
-		{0x5b03, 0xcf},
-		{0x5b05, 0x6c},
-		{0x5e00, 0x00},
-		{0x5e10, 0xfc}
+static const struct ov8856_reg mode_3280x2464_regs[] = {
+	{0x0303, 0x01},
+	{0x031e, 0x0c},
+	{0x3000, 0x00},
+	{0x300e, 0x00},
+	{0x3010, 0x00},
+	{0x3015, 0x84},
+	{0x3018, 0x72},
+	{0x3021, 0x23},
+	{0x3033, 0x24},
+	{0x3500, 0x00},
+	{0x3501, 0x9c},
+	{0x3502, 0x80},
+	{0x3503, 0x08},
+	{0x3505, 0x83},
+	{0x3508, 0x01},
+	{0x3509, 0x80},
+	{0x350c, 0x00},
+	{0x350d, 0x80},
+	{0x350e, 0x04},
+	{0x350f, 0x00},
+	{0x3510, 0x00},
+	{0x3511, 0x02},
+	{0x3512, 0x00},
+	{0x3600, 0x72},
+	{0x3601, 0x40},
+	{0x3602, 0x30},
+	{0x3610, 0xc5},
+	{0x3611, 0x58},
+	{0x3612, 0x5c},
+	{0x3613, 0xca},
+	{0x3614, 0x20},
+	{0x3628, 0xff},
+	{0x3629, 0xff},
+	{0x362a, 0xff},
+	{0x3633, 0x10},
+	{0x3634, 0x10},
+	{0x3635, 0x10},
+	{0x3636, 0x10},
+	{0x3663, 0x08},
+	{0x3669, 0x34},
+	{0x366e, 0x10},
+	{0x3706, 0x86},
+	{0x370b, 0x7e},
+	{0x3714, 0x23},
+	{0x3730, 0x12},
+	{0x3733, 0x10},
+	{0x3764, 0x00},
+	{0x3765, 0x00},
+	{0x3769, 0x62},
+	{0x376a, 0x2a},
+	{0x376b, 0x30},
+	{0x3780, 0x00},
+	{0x3781, 0x24},
+	{0x3782, 0x00},
+	{0x3783, 0x23},
+	{0x3798, 0x2f},
+	{0x37a1, 0x60},
+	{0x37a8, 0x6a},
+	{0x37ab, 0x3f},
+	{0x37c2, 0x04},
+	{0x37c3, 0xf1},
+	{0x37c9, 0x80},
+	{0x37cb, 0x16},
+	{0x37cc, 0x16},
+	{0x37cd, 0x16},
+	{0x37ce, 0x16},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0x00},
+	{0x3804, 0x0c},
+	{0x3805, 0xdf},
+	{0x3806, 0x09},
+	{0x3807, 0xaf},
+	{0x3808, 0x0c},
+	{0x3809, 0xe0},
+	{0x380a, 0x09},
+	{0x380b, 0xb0},
+	{0x380c, 0x07},
+	{0x380d, 0x90},
+	{0x380e, 0x09},
+	{0x380f, 0xd8},
+	{0x3810, 0x00},
+	{0x3811, 0x00},
+	{0x3812, 0x00},
+	{0x3813, 0x00},
+	{0x3814, 0x01},
+	{0x3815, 0x01},
+	{0x3816, 0x00},
+	{0x3817, 0x00},
+	{0x3818, 0x00},
+	{0x3819, 0x00},
+	{0x3820, 0x80},
+	{0x3821, 0x46},
+	{0x382a, 0x01},
+	{0x382b, 0x01},
+	{0x3830, 0x06},
+	{0x3836, 0x02},
+	{0x3837, 0x10},
+	{0x3862, 0x04},
+	{0x3863, 0x08},
+	{0x3cc0, 0x33},
+	{0x3d85, 0x17},
+	{0x3d8c, 0x73},
+	{0x3d8d, 0xde},
+	{0x4001, 0xe0},
+	{0x4003, 0x40},
+	{0x4008, 0x00},
+	{0x4009, 0x0b},
+	{0x400a, 0x00},
+	{0x400b, 0x84},
+	{0x400f, 0x80},
+	{0x4010, 0xf0},
+	{0x4011, 0xff},
+	{0x4012, 0x02},
+	{0x4013, 0x01},
+	{0x4014, 0x01},
+	{0x4015, 0x01},
+	{0x4042, 0x00},
+	{0x4043, 0x80},
+	{0x4044, 0x00},
+	{0x4045, 0x80},
+	{0x4046, 0x00},
+	{0x4047, 0x80},
+	{0x4048, 0x00},
+	{0x4049, 0x80},
+	{0x4041, 0x03},
+	{0x404c, 0x20},
+	{0x404d, 0x00},
+	{0x404e, 0x20},
+	{0x4203, 0x80},
+	{0x4307, 0x30},
+	{0x4317, 0x00},
+	{0x4503, 0x08},
+	{0x4601, 0x80},
+	{0x4800, 0x44},
+	{0x4816, 0x53},
+	{0x481b, 0x58},
+	{0x481f, 0x27},
+	{0x4837, 0x16},
+	{0x483c, 0x0f},
+	{0x484b, 0x05},
+	{0x5000, 0x57},
+	{0x5001, 0x0a},
+	{0x5004, 0x00},
+	{0x502e, 0x03},
+	{0x5030, 0x41},
+	{0x5795, 0x02},
+	{0x5796, 0x20},
+	{0x5797, 0x20},
+	{0x5798, 0x2a},
+	{0x5799, 0x2a},
+	{0x579a, 0x00},
+	{0x579b, 0x50},
+	{0x579c, 0x00},
+	{0x579d, 0x38},
+	{0x579e, 0x0c},
+	{0x579f, 0x40},
+	{0x57a0, 0x09},
+	{0x57a1, 0x40},
+	{0x5780, 0x14},
+	{0x5781, 0x0f},
+	{0x5782, 0x44},
+	{0x5783, 0x02},
+	{0x5784, 0x01},
+	{0x5785, 0x01},
+	{0x5786, 0x00},
+	{0x5787, 0x04},
+	{0x5788, 0x02},
+	{0x5789, 0x0f},
+	{0x578a, 0xfd},
+	{0x578b, 0xf5},
+	{0x578c, 0xf5},
+	{0x578d, 0x03},
+	{0x578e, 0x08},
+	{0x578f, 0x0c},
+	{0x5790, 0x08},
+	{0x5791, 0x04},
+	{0x5792, 0x00},
+	{0x5793, 0x52},
+	{0x5794, 0xa3},
+	{0x59f8, 0x3d},
+	{0x5a08, 0x02},
+	{0x5b00, 0x02},
+	{0x5b01, 0x10},
+	{0x5b02, 0x03},
+	{0x5b03, 0xcf},
+	{0x5b05, 0x6c},
+	{0x5e00, 0x00},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0x06},
+	{0x3804, 0x0c},
+	{0x3805, 0xdf},
+	{0x3806, 0x09},
+	{0x3807, 0xa7},
+	{0x3808, 0x0c},
+	{0x3809, 0xd0},
+	{0x380a, 0x09},
+	{0x380b, 0xa0},
+	{0x380c, 0x07},
+	{0x380d, 0x8c},
+	{0x380e, 0x09},
+	{0x380f, 0xca},
+	{0x3810, 0x00},
+	{0x3811, 0x08},
+	{0x3812, 0x00},
+	{0x3813, 0x01}
 };
 
-static const struct ov8856_reg lane_4_mode_1632x1224[] = {
-	/* 1632x1224 resolution */
-		{0x0103, 0x01},
-		{0x0302, 0x3c},
-		{0x0303, 0x01},
-		{0x031e, 0x0c},
-		{0x3000, 0x20},
-		{0x3003, 0x08},
-		{0x300e, 0x20},
-		{0x3010, 0x00},
-		{0x3015, 0x84},
-		{0x3018, 0x72},
-		{0x3021, 0x23},
-		{0x3033, 0x24},
-		{0x3500, 0x00},
-		{0x3501, 0x4c},
-		{0x3502, 0xe0},
-		{0x3503, 0x08},
-		{0x3505, 0x83},
-		{0x3508, 0x01},
-		{0x3509, 0x80},
-		{0x350c, 0x00},
-		{0x350d, 0x80},
-		{0x350e, 0x04},
-		{0x350f, 0x00},
-		{0x3510, 0x00},
-		{0x3511, 0x02},
-		{0x3512, 0x00},
-		{0x3600, 0x72},
-		{0x3601, 0x40},
-		{0x3602, 0x30},
-		{0x3610, 0xc5},
-		{0x3611, 0x58},
-		{0x3612, 0x5c},
-		{0x3613, 0xca},
-		{0x3614, 0x60},
-		{0x3628, 0xff},
-		{0x3629, 0xff},
-		{0x362a, 0xff},
-		{0x3633, 0x10},
-		{0x3634, 0x10},
-		{0x3635, 0x10},
-		{0x3636, 0x10},
-		{0x3663, 0x08},
-		{0x3669, 0x34},
-		{0x366d, 0x00},
-		{0x366e, 0x08},
-		{0x3706, 0x86},
-		{0x370b, 0x7e},
-		{0x3714, 0x27},
-		{0x3730, 0x12},
-		{0x3733, 0x10},
-		{0x3764, 0x00},
-		{0x3765, 0x00},
-		{0x3769, 0x62},
-		{0x376a, 0x2a},
-		{0x376b, 0x30},
-		{0x3780, 0x00},
-		{0x3781, 0x24},
-		{0x3782, 0x00},
-		{0x3783, 0x23},
-		{0x3798, 0x2f},
-		{0x37a1, 0x60},
-		{0x37a8, 0x6a},
-		{0x37ab, 0x3f},
-		{0x37c2, 0x14},
-		{0x37c3, 0xf1},
-		{0x37c9, 0x80},
-		{0x37cb, 0x16},
-		{0x37cc, 0x16},
-		{0x37cd, 0x16},
-		{0x37ce, 0x16},
-		{0x3800, 0x00},
-		{0x3801, 0x00},
-		{0x3802, 0x00},
-		{0x3803, 0x0c},
-		{0x3804, 0x0c},
-		{0x3805, 0xdf},
-		{0x3806, 0x09},
-		{0x3807, 0xa3},
-		{0x3808, 0x06},
-		{0x3809, 0x60},
-		{0x380a, 0x04},
-		{0x380b, 0xc8},
-		{0x380c, 0x07},
-		{0x380d, 0x8c},
-		{0x380e, 0x09},
-		{0x380f, 0xb2},
-		{0x3810, 0x00},
-		{0x3811, 0x02},
-		{0x3812, 0x00},
-		{0x3813, 0x01},
-		{0x3814, 0x03},
-		{0x3815, 0x01},
-		{0x3816, 0x00},
-		{0x3817, 0x00},
-		{0x3818, 0x00},
-		{0x3819, 0x10},
-		{0x3820, 0x80},
-		{0x3821, 0x47},
-		{0x382a, 0x03},
-		{0x382b, 0x01},
-		{0x3830, 0x06},
-		{0x3836, 0x02},
-		{0x3862, 0x04},
-		{0x3863, 0x08},
-		{0x3cc0, 0x33},
-		{0x3d85, 0x17},
-		{0x3d8c, 0x73},
-		{0x3d8d, 0xde},
-		{0x4001, 0xe0},
-		{0x4003, 0x40},
-		{0x4008, 0x00},
-		{0x4009, 0x05},
-		{0x400a, 0x00},
-		{0x400b, 0x84},
-		{0x400f, 0x80},
-		{0x4010, 0xf0},
-		{0x4011, 0xff},
-		{0x4012, 0x02},
-		{0x4013, 0x01},
-		{0x4014, 0x01},
-		{0x4015, 0x01},
-		{0x4042, 0x00},
-		{0x4043, 0x80},
-		{0x4044, 0x00},
-		{0x4045, 0x80},
-		{0x4046, 0x00},
-		{0x4047, 0x80},
-		{0x4048, 0x00},
-		{0x4049, 0x80},
-		{0x4041, 0x03},
-		{0x404c, 0x20},
-		{0x404d, 0x00},
-		{0x404e, 0x20},
-		{0x4203, 0x80},
-		{0x4307, 0x30},
-		{0x4317, 0x00},
-		{0x4502, 0x50},
-		{0x4503, 0x08},
-		{0x4601, 0x80},
-		{0x4800, 0x44},
-		{0x4816, 0x53},
-		{0x481b, 0x50},
-		{0x481f, 0x27},
-		{0x4823, 0x3c},
-		{0x482b, 0x00},
-		{0x4831, 0x66},
-		{0x4837, 0x16},
-		{0x483c, 0x0f},
-		{0x484b, 0x05},
-		{0x5000, 0x77},
-		{0x5001, 0x0a},
-		{0x5003, 0xc8},
-		{0x5004, 0x04},
-		{0x5006, 0x00},
-		{0x5007, 0x00},
-		{0x502e, 0x03},
-		{0x5030, 0x41},
-		{0x5795, 0x00},
-		{0x5796, 0x10},
-		{0x5797, 0x10},
-		{0x5798, 0x73},
-		{0x5799, 0x73},
-		{0x579a, 0x00},
-		{0x579b, 0x28},
-		{0x579c, 0x00},
-		{0x579d, 0x16},
-		{0x579e, 0x06},
-		{0x579f, 0x20},
-		{0x57a0, 0x04},
-		{0x57a1, 0xa0},
-		{0x5780, 0x14},
-		{0x5781, 0x0f},
-		{0x5782, 0x44},
-		{0x5783, 0x02},
-		{0x5784, 0x01},
-		{0x5785, 0x01},
-		{0x5786, 0x00},
-		{0x5787, 0x04},
-		{0x5788, 0x02},
-		{0x5789, 0x0f},
-		{0x578a, 0xfd},
-		{0x578b, 0xf5},
-		{0x578c, 0xf5},
-		{0x578d, 0x03},
-		{0x578e, 0x08},
-		{0x578f, 0x0c},
-		{0x5790, 0x08},
-		{0x5791, 0x04},
-		{0x5792, 0x00},
-		{0x5793, 0x52},
-		{0x5794, 0xa3},
-		{0x59f8, 0x3d},
-		{0x5a08, 0x02},
-		{0x5b00, 0x02},
-		{0x5b01, 0x10},
-		{0x5b02, 0x03},
-		{0x5b03, 0xcf},
-		{0x5b05, 0x6c},
-		{0x5e00, 0x00},
-		{0x5e10, 0xfc}
+static const struct ov8856_reg mode_1640x1232_regs[] = {
+	{0x3000, 0x00},
+	{0x300e, 0x00},
+	{0x3010, 0x00},
+	{0x3015, 0x84},
+	{0x3018, 0x72},
+	{0x3021, 0x23},
+	{0x3033, 0x24},
+	{0x3500, 0x00},
+	{0x3501, 0x4c},
+	{0x3502, 0xe0},
+	{0x3503, 0x08},
+	{0x3505, 0x83},
+	{0x3508, 0x01},
+	{0x3509, 0x80},
+	{0x350c, 0x00},
+	{0x350d, 0x80},
+	{0x350e, 0x04},
+	{0x350f, 0x00},
+	{0x3510, 0x00},
+	{0x3511, 0x02},
+	{0x3512, 0x00},
+	{0x3600, 0x72},
+	{0x3601, 0x40},
+	{0x3602, 0x30},
+	{0x3610, 0xc5},
+	{0x3611, 0x58},
+	{0x3612, 0x5c},
+	{0x3613, 0xca},
+	{0x3614, 0x20},
+	{0x3628, 0xff},
+	{0x3629, 0xff},
+	{0x362a, 0xff},
+	{0x3633, 0x10},
+	{0x3634, 0x10},
+	{0x3635, 0x10},
+	{0x3636, 0x10},
+	{0x3663, 0x08},
+	{0x3669, 0x34},
+	{0x366e, 0x08},
+	{0x3706, 0x86},
+	{0x370b, 0x7e},
+	{0x3714, 0x27},
+	{0x3730, 0x12},
+	{0x3733, 0x10},
+	{0x3764, 0x00},
+	{0x3765, 0x00},
+	{0x3769, 0x62},
+	{0x376a, 0x2a},
+	{0x376b, 0x30},
+	{0x3780, 0x00},
+	{0x3781, 0x24},
+	{0x3782, 0x00},
+	{0x3783, 0x23},
+	{0x3798, 0x2f},
+	{0x37a1, 0x60},
+	{0x37a8, 0x6a},
+	{0x37ab, 0x3f},
+	{0x37c2, 0x14},
+	{0x37c3, 0xf1},
+	{0x37c9, 0x80},
+	{0x37cb, 0x16},
+	{0x37cc, 0x16},
+	{0x37cd, 0x16},
+	{0x37ce, 0x16},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0x0c},
+	{0x3804, 0x0c},
+	{0x3805, 0xdf},
+	{0x3806, 0x09},
+	{0x3807, 0xa3},
+	{0x3808, 0x06},
+	{0x3809, 0x60},
+	{0x380a, 0x04},
+	{0x380b, 0xc8},
+	{0x380c, 0x07},
+	{0x380d, 0x8c},
+	{0x380e, 0x04},
+	{0x380f, 0xde},
+	{0x3810, 0x00},
+	{0x3811, 0x08},
+	{0x3812, 0x00},
+	{0x3813, 0x02},
+	{0x3814, 0x03},
+	{0x3815, 0x01},
+	{0x3816, 0x00},
+	{0x3817, 0x00},
+	{0x3818, 0x00},
+	{0x3819, 0x00},
+	{0x3820, 0x90},
+	{0x3821, 0x67},
+	{0x382a, 0x03},
+	{0x382b, 0x01},
+	{0x3830, 0x06},
+	{0x3836, 0x02},
+	{0x3837, 0x10},
+	{0x3862, 0x04},
+	{0x3863, 0x08},
+	{0x3cc0, 0x33},
+	{0x3d85, 0x17},
+	{0x3d8c, 0x73},
+	{0x3d8d, 0xde},
+	{0x4001, 0xe0},
+	{0x4003, 0x40},
+	{0x4008, 0x00},
+	{0x4009, 0x05},
+	{0x400a, 0x00},
+	{0x400b, 0x84},
+	{0x400f, 0x80},
+	{0x4010, 0xf0},
+	{0x4011, 0xff},
+	{0x4012, 0x02},
+	{0x4013, 0x01},
+	{0x4014, 0x01},
+	{0x4015, 0x01},
+	{0x4042, 0x00},
+	{0x4043, 0x80},
+	{0x4044, 0x00},
+	{0x4045, 0x80},
+	{0x4046, 0x00},
+	{0x4047, 0x80},
+	{0x4048, 0x00},
+	{0x4049, 0x80},
+	{0x4041, 0x03},
+	{0x404c, 0x20},
+	{0x404d, 0x00},
+	{0x404e, 0x20},
+	{0x4203, 0x80},
+	{0x4307, 0x30},
+	{0x4317, 0x00},
+	{0x4503, 0x08},
+	{0x4601, 0x80},
+	{0x4800, 0x44},
+	{0x4816, 0x53},
+	{0x481b, 0x58},
+	{0x481f, 0x27},
+	{0x4837, 0x16},
+	{0x483c, 0x0f},
+	{0x484b, 0x05},
+	{0x5000, 0x57},
+	{0x5001, 0x0a},
+	{0x5004, 0x04},
+	{0x502e, 0x03},
+	{0x5030, 0x41},
+	{0x5795, 0x00},
+	{0x5796, 0x10},
+	{0x5797, 0x10},
+	{0x5798, 0x73},
+	{0x5799, 0x73},
+	{0x579a, 0x00},
+	{0x579b, 0x28},
+	{0x579c, 0x00},
+	{0x579d, 0x16},
+	{0x579e, 0x06},
+	{0x579f, 0x20},
+	{0x57a0, 0x04},
+	{0x57a1, 0xa0},
+	{0x5780, 0x14},
+	{0x5781, 0x0f},
+	{0x5782, 0x44},
+	{0x5783, 0x02},
+	{0x5784, 0x01},
+	{0x5785, 0x01},
+	{0x5786, 0x00},
+	{0x5787, 0x04},
+	{0x5788, 0x02},
+	{0x5789, 0x0f},
+	{0x578a, 0xfd},
+	{0x578b, 0xf5},
+	{0x578c, 0xf5},
+	{0x578d, 0x03},
+	{0x578e, 0x08},
+	{0x578f, 0x0c},
+	{0x5790, 0x08},
+	{0x5791, 0x04},
+	{0x5792, 0x00},
+	{0x5793, 0x52},
+	{0x5794, 0xa3},
+	{0x59f8, 0x3d},
+	{0x5a08, 0x02},
+	{0x5b00, 0x02},
+	{0x5b01, 0x10},
+	{0x5b02, 0x03},
+	{0x5b03, 0xcf},
+	{0x5b05, 0x6c},
+	{0x5e00, 0x00},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0x00},
+	{0x3804, 0x0c},
+	{0x3805, 0xdf},
+	{0x3806, 0x09},
+	{0x3807, 0xaf},
+	{0x3808, 0x06},
+	{0x3809, 0x68},
+	{0x380a, 0x04},
+	{0x380b, 0xd0},
+	{0x380e, 0x04},
+	{0x380f, 0xee},
+	{0x3810, 0x00},
+	{0x3811, 0x04},
+	{0x3812, 0x00},
+	{0x3813, 0x05},
+	{0x3500, 0x00},
+	{0x3501, 0x4e},
+	{0x3502, 0x80},
+	{0x3820, 0x90},
+	{0x3821, 0x67},
+	{0x502e, 0x03},
+	{0x5001, 0x0a},
+	{0x5004, 0x04},
+	{0x376b, 0x30},
+	{0x030d, 0x4b},
+	{0x030b, 0x02},
+	{0x4837, 0x1e},
+	{0x380c, 0x0c},
+	{0x380d, 0x60},
+	{0x380e, 0x05},
+	{0x380f, 0xea}
 };
 
 static const char * const ov8856_test_pattern_menu[] = {
@@ -1380,197 +584,87 @@ static const char * const ov8856_test_pattern_menu[] = {
 	"Bottom-Top Darker Color Bar"
 };
 
-struct ov8856 {
-	struct v4l2_subdev sd;
-	struct media_pad pad;
-	struct v4l2_ctrl_handler ctrl_handler;
-
-	struct clk		*xvclk;
-	struct gpio_desc	*reset_gpio;
-	struct regulator_bulk_data supplies[ARRAY_SIZE(ov8856_supply_names)];
-
-	/* V4L2 Controls */
-	struct v4l2_ctrl *link_freq;
-	struct v4l2_ctrl *pixel_rate;
-	struct v4l2_ctrl *vblank;
-	struct v4l2_ctrl *hblank;
-	struct v4l2_ctrl *exposure;
-
-	/* Current mode */
-	const struct ov8856_mode *cur_mode;
-
-	/* To serialize asynchronus callbacks */
-	struct mutex mutex;
-
-	/* Streaming on/off */
-	bool streaming;
-
-	/* lanes index */
-	u8 nlanes;
-
-	const struct ov8856_lane_cfg *priv_lane;
-	u8 modes_size;
-};
-
-struct ov8856_lane_cfg {
-	const s64 link_freq_menu_items[2];
-	const struct ov8856_link_freq_config link_freq_configs[2];
-	const struct ov8856_mode supported_modes[4];
+static const s64 link_freq_menu_items[] = {
+	OV8856_LINK_FREQ_360MHZ,
+	OV8856_LINK_FREQ_264MHZ
 };
 
-static const struct ov8856_lane_cfg lane_cfg_2 = {
-	{
-		720000000,
-		360000000,
-	},
-	{{
+static const struct ov8856_link_freq_config link_freq_configs[] = {
+	[OV8856_LINK_FREQ_720MBPS] = {
 		.reg_list = {
-			.num_of_regs =
-			ARRAY_SIZE(mipi_data_rate_lane_2.regs_0),
-			.regs = mipi_data_rate_lane_2.regs_0,
+			.num_of_regs = ARRAY_SIZE(mipi_data_rate_720mbps),
+			.regs = mipi_data_rate_720mbps,
 		}
 	},
-	{
+	[OV8856_LINK_FREQ_528MBPS] = {
 		.reg_list = {
-			.num_of_regs =
-			ARRAY_SIZE(mipi_data_rate_lane_2.regs_1),
-			.regs = mipi_data_rate_lane_2.regs_1,
+			.num_of_regs = ARRAY_SIZE(mipi_data_rate_528mbps),
+			.regs = mipi_data_rate_528mbps,
 		}
-	}},
-	{{
+	}
+};
+
+static const struct ov8856_mode supported_modes[] = {
+	{
 		.width = 3280,
 		.height = 2464,
 		.hts = 1928,
 		.vts_def = 2488,
 		.vts_min = 2488,
 		.reg_list = {
-			.num_of_regs =
-			ARRAY_SIZE(lane_2_mode_3280x2464),
-			.regs = lane_2_mode_3280x2464,
+			.num_of_regs = ARRAY_SIZE(mode_3280x2464_regs),
+			.regs = mode_3280x2464_regs,
 		},
-		.link_freq_index = 0,
-		.data_lanes = 2,
+		.link_freq_index = OV8856_LINK_FREQ_720MBPS,
 	},
 	{
 		.width = 1640,
 		.height = 1232,
-		.hts = 3168,
-		.vts_def = 1514,
-		.vts_min = 1514,
+		.hts = 3820,
+		.vts_def = 1256,
+		.vts_min = 1256,
 		.reg_list = {
-			.num_of_regs =
-			ARRAY_SIZE(lane_2_mode_1640x1232),
-			.regs = lane_2_mode_1640x1232,
+			.num_of_regs = ARRAY_SIZE(mode_1640x1232_regs),
+			.regs = mode_1640x1232_regs,
 		},
-		.link_freq_index = 1,
-		.data_lanes = 2,
-	}}
+		.link_freq_index = OV8856_LINK_FREQ_528MBPS,
+	}
 };
 
-static const struct ov8856_lane_cfg lane_cfg_4 = {
-		{
-			360000000,
-			180000000,
-		},
-		{{
-			.reg_list = {
-				.num_of_regs =
-				 ARRAY_SIZE(mipi_data_rate_lane_4.regs_0),
-				.regs = mipi_data_rate_lane_4.regs_0,
-			}
-		},
-		{
-			.reg_list = {
-				.num_of_regs =
-				 ARRAY_SIZE(mipi_data_rate_lane_4.regs_1),
-				.regs = mipi_data_rate_lane_4.regs_1,
-			}
-		}},
-		{{
-			.width = 3280,
-			.height = 2464,
-			.hts = 1928,
-			.vts_def = 2488,
-			.vts_min = 2488,
-			.reg_list = {
-				.num_of_regs =
-				 ARRAY_SIZE(lane_4_mode_3280x2464),
-				.regs = lane_4_mode_3280x2464,
-			},
-			.link_freq_index = 0,
-			.data_lanes = 4,
-		},
-		{
-			.width = 1640,
-			.height = 1232,
-			.hts = 3820,
-			.vts_def = 1256,
-			.vts_min = 1256,
-			.reg_list = {
-				.num_of_regs =
-				 ARRAY_SIZE(lane_4_mode_1640x1232),
-				.regs = lane_4_mode_1640x1232,
-			},
-			.link_freq_index = 1,
-			.data_lanes = 4,
-		},
-		{
-			.width = 3264,
-			.height = 2448,
-			.hts = 1932,
-			.vts_def = 2482,
-			.vts_min = 2482,
-			.reg_list = {
-				.num_of_regs =
-				 ARRAY_SIZE(lane_4_mode_3264x2448),
-				.regs = lane_4_mode_3264x2448,
-			},
-			.link_freq_index = 0,
-			.data_lanes = 4,
-		},
-		{
-			.width = 1632,
-			.height = 1224,
-			.hts = 1932,
-			.vts_def = 2482,
-			.vts_min = 2482,
-			.reg_list = {
-				.num_of_regs =
-				 ARRAY_SIZE(lane_4_mode_1632x1224),
-				.regs = lane_4_mode_1632x1224,
-			},
-			.link_freq_index = 1,
-			.data_lanes = 4,
-		}}
-};
+struct ov8856 {
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_ctrl_handler ctrl_handler;
 
-static unsigned int ov8856_modes_num(const struct ov8856 *ov8856)
-{
-	unsigned int i, count = 0;
+	/* V4L2 Controls */
+	struct v4l2_ctrl *link_freq;
+	struct v4l2_ctrl *pixel_rate;
+	struct v4l2_ctrl *vblank;
+	struct v4l2_ctrl *hblank;
+	struct v4l2_ctrl *exposure;
 
-	for (i = 0; i < ARRAY_SIZE(ov8856->priv_lane->supported_modes); i++) {
-		if (ov8856->priv_lane->supported_modes[i].width == 0)
-			break;
-		count++;
-	}
+	/* Current mode */
+	const struct ov8856_mode *cur_mode;
 
-	return count;
-}
+	/* To serialize asynchronus callbacks */
+	struct mutex mutex;
+
+	/* Streaming on/off */
+	bool streaming;
+};
 
-static u64 to_rate(const s64 *link_freq_menu_items,
-		   u32 f_index, u8 nlanes)
+static u64 to_pixel_rate(u32 f_index)
 {
-	u64 pixel_rate = link_freq_menu_items[f_index] * 2 * nlanes;
+	u64 pixel_rate = link_freq_menu_items[f_index] * 2 * OV8856_DATA_LANES;
 
 	do_div(pixel_rate, OV8856_RGB_DEPTH);
 
 	return pixel_rate;
 }
 
-static u64 to_pixels_per_line(const s64 *link_freq_menu_items, u32 hts,
-			      u32 f_index, u8 nlanes)
+static u64 to_pixels_per_line(u32 hts, u32 f_index)
 {
-	u64 ppl = hts * to_rate(link_freq_menu_items, f_index, nlanes);
+	u64 ppl = hts * to_pixel_rate(f_index);
 
 	do_div(ppl, OV8856_SCLK);
 
@@ -1635,8 +729,8 @@ static int ov8856_write_reg_list(struct ov8856 *ov8856,
 				       r_list->regs[i].val);
 		if (ret) {
 			dev_err_ratelimited(&client->dev,
-				    "failed to write reg 0x%4.4x. error = %d",
-				    r_list->regs[i].address, ret);
+					    "failed to W reg 0x%4.4x err %d",
+					    r_list->regs[i].address, ret);
 			return ret;
 		}
 	}
@@ -1672,93 +766,6 @@ static int ov8856_test_pattern(struct ov8856 *ov8856, u32 pattern)
 				OV8856_REG_VALUE_08BIT, pattern);
 }
 
-static int ov8856_set_ctrl_hflip(struct ov8856 *ov8856, u32 ctrl_val)
-{
-	int ret;
-	u32 val;
-
-	ret = ov8856_read_reg(ov8856, OV8856_REG_MIRROR_OPT_1,
-			      OV8856_REG_VALUE_08BIT, &val);
-	if (ret)
-		return ret;
-
-	ret = ov8856_write_reg(ov8856, OV8856_REG_MIRROR_OPT_1,
-			       OV8856_REG_VALUE_08BIT,
-			       ctrl_val ? val & ~OV8856_REG_MIRROR_OP_2 :
-			       val | OV8856_REG_MIRROR_OP_2);
-
-	if (ret)
-		return ret;
-
-	ret = ov8856_read_reg(ov8856, OV8856_REG_FORMAT2,
-			      OV8856_REG_VALUE_08BIT, &val);
-	if (ret)
-		return ret;
-
-	return ov8856_write_reg(ov8856, OV8856_REG_FORMAT2,
-				OV8856_REG_VALUE_08BIT,
-				ctrl_val ? val & ~OV8856_REG_FORMAT2_OP_1 &
-				~OV8856_REG_FORMAT2_OP_2 &
-				~OV8856_REG_FORMAT2_OP_3 :
-				val | OV8856_REG_FORMAT2_OP_1 |
-				OV8856_REG_FORMAT2_OP_2 |
-				OV8856_REG_FORMAT2_OP_3);
-}
-
-static int ov8856_set_ctrl_vflip(struct ov8856 *ov8856, u8 ctrl_val)
-{
-	int ret;
-	u32 val;
-
-	ret = ov8856_read_reg(ov8856, OV8856_REG_FLIP_OPT_1,
-			      OV8856_REG_VALUE_08BIT, &val);
-	if (ret)
-		return ret;
-
-	ret = ov8856_write_reg(ov8856, OV8856_REG_FLIP_OPT_1,
-			       OV8856_REG_VALUE_08BIT,
-			       ctrl_val ? val | OV8856_REG_FLIP_OP_1 |
-			       OV8856_REG_FLIP_OP_2 :
-			       val & ~OV8856_REG_FLIP_OP_1 &
-			       ~OV8856_REG_FLIP_OP_2);
-
-	ret = ov8856_read_reg(ov8856, OV8856_REG_FLIP_OPT_2,
-			      OV8856_REG_VALUE_08BIT, &val);
-	if (ret)
-		return ret;
-
-	ret = ov8856_write_reg(ov8856, OV8856_REG_FLIP_OPT_2,
-			       OV8856_REG_VALUE_08BIT,
-			       ctrl_val ? val | OV8856_REG_FLIP_OP_2 :
-			       val & ~OV8856_REG_FLIP_OP_2);
-
-	ret = ov8856_read_reg(ov8856, OV8856_REG_FLIP_OPT_3,
-			      OV8856_REG_VALUE_08BIT, &val);
-	if (ret)
-		return ret;
-
-	ret = ov8856_write_reg(ov8856, OV8856_REG_FLIP_OPT_3,
-			       OV8856_REG_VALUE_08BIT,
-			       ctrl_val ? val & ~OV8856_REG_FLIP_OP_0 &
-			       ~OV8856_REG_FLIP_OP_1 :
-			       val | OV8856_REG_FLIP_OP_0 |
-			       OV8856_REG_FLIP_OP_1);
-
-	ret = ov8856_read_reg(ov8856, OV8856_REG_FORMAT1,
-			      OV8856_REG_VALUE_08BIT, &val);
-	if (ret)
-		return ret;
-
-	return ov8856_write_reg(ov8856, OV8856_REG_FORMAT1,
-			       OV8856_REG_VALUE_08BIT,
-			       ctrl_val ? val | OV8856_REG_FORMAT1_OP_1 |
-			       OV8856_REG_FORMAT1_OP_3 |
-			       OV8856_REG_FORMAT1_OP_2 :
-			       val & ~OV8856_REG_FORMAT1_OP_1 &
-			       ~OV8856_REG_FORMAT1_OP_3 &
-			       ~OV8856_REG_FORMAT1_OP_2);
-}
-
 static int ov8856_set_ctrl(struct v4l2_ctrl *ctrl)
 {
 	struct ov8856 *ov8856 = container_of(ctrl->handler,
@@ -1808,14 +815,6 @@ static int ov8856_set_ctrl(struct v4l2_ctrl *ctrl)
 		ret = ov8856_test_pattern(ov8856, ctrl->val);
 		break;
 
-	case V4L2_CID_HFLIP:
-		ret = ov8856_set_ctrl_hflip(ov8856, ctrl->val);
-		break;
-
-	case V4L2_CID_VFLIP:
-		ret = ov8856_set_ctrl_vflip(ov8856, ctrl->val);
-		break;
-
 	default:
 		ret = -EINVAL;
 		break;
@@ -1834,6 +833,7 @@ static int ov8856_init_controls(struct ov8856 *ov8856)
 {
 	struct v4l2_ctrl_handler *ctrl_hdlr;
 	s64 exposure_max, h_blank;
+	const struct ov8856_mode *cur_mode = ov8856->cur_mode;
 	int ret;
 
 	ctrl_hdlr = &ov8856->ctrl_handler;
@@ -1842,34 +842,29 @@ static int ov8856_init_controls(struct ov8856 *ov8856)
 		return ret;
 
 	ctrl_hdlr->lock = &ov8856->mutex;
-	ov8856->link_freq = v4l2_ctrl_new_int_menu(ctrl_hdlr, &ov8856_ctrl_ops,
-					   V4L2_CID_LINK_FREQ,
-					   ARRAY_SIZE
-					   (ov8856->priv_lane->link_freq_menu_items)
-					   - 1,
-					   0, ov8856->priv_lane->link_freq_menu_items);
+	ov8856->link_freq =
+	    v4l2_ctrl_new_int_menu(ctrl_hdlr, &ov8856_ctrl_ops,
+				   V4L2_CID_LINK_FREQ,
+				   ARRAY_SIZE(link_freq_menu_items) - 1,
+				   0, link_freq_menu_items);
 	if (ov8856->link_freq)
 		ov8856->link_freq->flags |= V4L2_CTRL_FLAG_READ_ONLY;
 
-	ov8856->pixel_rate = v4l2_ctrl_new_std(ctrl_hdlr, &ov8856_ctrl_ops,
-				       V4L2_CID_PIXEL_RATE, 0,
-				       to_rate(ov8856->priv_lane->link_freq_menu_items,
-					       0,
-					       ov8856->cur_mode->data_lanes), 1,
-				       to_rate(ov8856->priv_lane->link_freq_menu_items,
-					       0,
-					       ov8856->cur_mode->data_lanes));
-	ov8856->vblank = v4l2_ctrl_new_std(ctrl_hdlr, &ov8856_ctrl_ops,
-			  V4L2_CID_VBLANK,
-			  ov8856->cur_mode->vts_min - ov8856->cur_mode->height,
-			  OV8856_VTS_MAX - ov8856->cur_mode->height, 1,
-			  ov8856->cur_mode->vts_def -
-			  ov8856->cur_mode->height);
-	h_blank = to_pixels_per_line(ov8856->priv_lane->link_freq_menu_items,
-				     ov8856->cur_mode->hts,
-				     ov8856->cur_mode->link_freq_index,
-				     ov8856->cur_mode->data_lanes) -
-				     ov8856->cur_mode->width;
+	ov8856->pixel_rate =
+	    v4l2_ctrl_new_std(ctrl_hdlr, &ov8856_ctrl_ops,
+			      V4L2_CID_PIXEL_RATE, 0,
+			      to_pixel_rate(OV8856_LINK_FREQ_720MBPS),
+			      1, to_pixel_rate(OV8856_LINK_FREQ_720MBPS));
+	ov8856->vblank =
+	    v4l2_ctrl_new_std(ctrl_hdlr, &ov8856_ctrl_ops,
+			      V4L2_CID_VBLANK,
+			      cur_mode->vts_min - cur_mode->height,
+			      OV8856_VTS_MAX - cur_mode->height, 1,
+			      cur_mode->vts_def - cur_mode->height);
+	h_blank = to_pixels_per_line(cur_mode->hts,
+				     cur_mode->link_freq_index) -
+					cur_mode->width;
+
 	ov8856->hblank = v4l2_ctrl_new_std(ctrl_hdlr, &ov8856_ctrl_ops,
 					   V4L2_CID_HBLANK, h_blank, h_blank, 1,
 					   h_blank);
@@ -1882,7 +877,7 @@ static int ov8856_init_controls(struct ov8856 *ov8856)
 	v4l2_ctrl_new_std(ctrl_hdlr, &ov8856_ctrl_ops, V4L2_CID_DIGITAL_GAIN,
 			  OV8856_DGTL_GAIN_MIN, OV8856_DGTL_GAIN_MAX,
 			  OV8856_DGTL_GAIN_STEP, OV8856_DGTL_GAIN_DEFAULT);
-	exposure_max = ov8856->cur_mode->vts_def - OV8856_EXPOSURE_MAX_MARGIN;
+	exposure_max = cur_mode->vts_def - OV8856_EXPOSURE_MAX_MARGIN;
 	ov8856->exposure = v4l2_ctrl_new_std(ctrl_hdlr, &ov8856_ctrl_ops,
 					     V4L2_CID_EXPOSURE,
 					     OV8856_EXPOSURE_MIN, exposure_max,
@@ -1892,10 +887,6 @@ static int ov8856_init_controls(struct ov8856 *ov8856)
 				     V4L2_CID_TEST_PATTERN,
 				     ARRAY_SIZE(ov8856_test_pattern_menu) - 1,
 				     0, 0, ov8856_test_pattern_menu);
-	v4l2_ctrl_new_std(ctrl_hdlr, &ov8856_ctrl_ops,
-			  V4L2_CID_HFLIP, 0, 1, 1, 0);
-	v4l2_ctrl_new_std(ctrl_hdlr, &ov8856_ctrl_ops,
-			  V4L2_CID_VFLIP, 0, 1, 1, 0);
 	if (ctrl_hdlr->error)
 		return ctrl_hdlr->error;
 
@@ -1920,8 +911,7 @@ static int ov8856_start_streaming(struct ov8856 *ov8856)
 	int link_freq_index, ret;
 
 	link_freq_index = ov8856->cur_mode->link_freq_index;
-	reg_list = &ov8856->priv_lane->link_freq_configs[link_freq_index].reg_list;
-
+	reg_list = &link_freq_configs[link_freq_index].reg_list;
 	ret = ov8856_write_reg_list(ov8856, reg_list);
 	if (ret) {
 		dev_err(&client->dev, "failed to set plls");
@@ -1969,8 +959,9 @@ static int ov8856_set_stream(struct v4l2_subdev *sd, int enable)
 
 	mutex_lock(&ov8856->mutex);
 	if (enable) {
-		ret = pm_runtime_resume_and_get(&client->dev);
+		ret = pm_runtime_get_sync(&client->dev);
 		if (ret < 0) {
+			pm_runtime_put_noidle(&client->dev);
 			mutex_unlock(&ov8856->mutex);
 			return ret;
 		}
@@ -1992,67 +983,16 @@ static int ov8856_set_stream(struct v4l2_subdev *sd, int enable)
 	return ret;
 }
 
-static int __ov8856_power_on(struct ov8856 *ov8856)
-{
-	struct i2c_client *client = v4l2_get_subdevdata(&ov8856->sd);
-	int ret;
-
-	if (is_acpi_node(dev_fwnode(&client->dev)))
-		return 0;
-
-	ret = clk_prepare_enable(ov8856->xvclk);
-	if (ret < 0) {
-		dev_err(&client->dev, "failed to enable xvclk\n");
-		return ret;
-	}
-
-	if (ov8856->reset_gpio) {
-		gpiod_set_value_cansleep(ov8856->reset_gpio, 1);
-		usleep_range(1000, 2000);
-	}
-
-	ret = regulator_bulk_enable(ARRAY_SIZE(ov8856_supply_names),
-				    ov8856->supplies);
-	if (ret < 0) {
-		dev_err(&client->dev, "failed to enable regulators\n");
-		goto disable_clk;
-	}
-
-	gpiod_set_value_cansleep(ov8856->reset_gpio, 0);
-	usleep_range(1500, 1800);
-
-	return 0;
-
-disable_clk:
-	gpiod_set_value_cansleep(ov8856->reset_gpio, 1);
-	clk_disable_unprepare(ov8856->xvclk);
-
-	return ret;
-}
-
-static void __ov8856_power_off(struct ov8856 *ov8856)
-{
-	struct i2c_client *client = v4l2_get_subdevdata(&ov8856->sd);
-
-	if (is_acpi_node(dev_fwnode(&client->dev)))
-		return;
-
-	gpiod_set_value_cansleep(ov8856->reset_gpio, 1);
-	regulator_bulk_disable(ARRAY_SIZE(ov8856_supply_names),
-			       ov8856->supplies);
-	clk_disable_unprepare(ov8856->xvclk);
-}
-
 static int __maybe_unused ov8856_suspend(struct device *dev)
 {
-	struct v4l2_subdev *sd = dev_get_drvdata(dev);
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
 	struct ov8856 *ov8856 = to_ov8856(sd);
 
 	mutex_lock(&ov8856->mutex);
 	if (ov8856->streaming)
 		ov8856_stop_streaming(ov8856);
 
-	__ov8856_power_off(ov8856);
 	mutex_unlock(&ov8856->mutex);
 
 	return 0;
@@ -2060,13 +1000,12 @@ static int __maybe_unused ov8856_suspend(struct device *dev)
 
 static int __maybe_unused ov8856_resume(struct device *dev)
 {
-	struct v4l2_subdev *sd = dev_get_drvdata(dev);
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
 	struct ov8856 *ov8856 = to_ov8856(sd);
 	int ret;
 
 	mutex_lock(&ov8856->mutex);
-
-	__ov8856_power_on(ov8856);
 	if (ov8856->streaming) {
 		ret = ov8856_start_streaming(ov8856);
 		if (ret) {
@@ -2090,9 +1029,9 @@ static int ov8856_set_format(struct v4l2_subdev *sd,
 	const struct ov8856_mode *mode;
 	s32 vblank_def, h_blank;
 
-	mode = v4l2_find_nearest_size(ov8856->priv_lane->supported_modes,
-				      ov8856->modes_size,
-				      width, height, fmt->format.width,
+	mode = v4l2_find_nearest_size(supported_modes,
+				      ARRAY_SIZE(supported_modes), width,
+				      height, fmt->format.width,
 				      fmt->format.height);
 
 	mutex_lock(&ov8856->mutex);
@@ -2103,9 +1042,7 @@ static int ov8856_set_format(struct v4l2_subdev *sd,
 		ov8856->cur_mode = mode;
 		__v4l2_ctrl_s_ctrl(ov8856->link_freq, mode->link_freq_index);
 		__v4l2_ctrl_s_ctrl_int64(ov8856->pixel_rate,
-					 to_rate(ov8856->priv_lane->link_freq_menu_items,
-						 mode->link_freq_index,
-						 ov8856->cur_mode->data_lanes));
+					 to_pixel_rate(mode->link_freq_index));
 
 		/* Update limits and set FPS to default */
 		vblank_def = mode->vts_def - mode->height;
@@ -2114,11 +1051,8 @@ static int ov8856_set_format(struct v4l2_subdev *sd,
 					 OV8856_VTS_MAX - mode->height, 1,
 					 vblank_def);
 		__v4l2_ctrl_s_ctrl(ov8856->vblank, vblank_def);
-		h_blank = to_pixels_per_line(ov8856->priv_lane->link_freq_menu_items,
-					     mode->hts,
-					     mode->link_freq_index,
-					     ov8856->cur_mode->data_lanes)
-					     - mode->width;
+		h_blank = to_pixels_per_line(mode->hts, mode->link_freq_index) -
+			  mode->width;
 		__v4l2_ctrl_modify_range(ov8856->hblank, h_blank, h_blank, 1,
 					 h_blank);
 	}
@@ -2137,8 +1071,7 @@ static int ov8856_get_format(struct v4l2_subdev *sd,
 	mutex_lock(&ov8856->mutex);
 	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY)
 		fmt->format = *v4l2_subdev_get_try_format(&ov8856->sd,
-							  sd_state,
-							  fmt->pad);
+							  sd_state, fmt->pad);
 	else
 		ov8856_update_pad_format(ov8856->cur_mode, &fmt->format);
 
@@ -2164,17 +1097,15 @@ static int ov8856_enum_frame_size(struct v4l2_subdev *sd,
 				  struct v4l2_subdev_state *sd_state,
 				  struct v4l2_subdev_frame_size_enum *fse)
 {
-	struct ov8856 *ov8856 = to_ov8856(sd);
-
-	if (fse->index >= ov8856->modes_size)
+	if (fse->index >= ARRAY_SIZE(supported_modes))
 		return -EINVAL;
 
 	if (fse->code != MEDIA_BUS_FMT_SGRBG10_1X10)
 		return -EINVAL;
 
-	fse->min_width = ov8856->priv_lane->supported_modes[fse->index].width;
+	fse->min_width = supported_modes[fse->index].width;
 	fse->max_width = fse->min_width;
-	fse->min_height = ov8856->priv_lane->supported_modes[fse->index].height;
+	fse->min_height = supported_modes[fse->index].height;
 	fse->max_height = fse->min_height;
 
 	return 0;
@@ -2185,7 +1116,7 @@ static int ov8856_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
 	struct ov8856 *ov8856 = to_ov8856(sd);
 
 	mutex_lock(&ov8856->mutex);
-	ov8856_update_pad_format(&ov8856->priv_lane->supported_modes[0],
+	ov8856_update_pad_format(&supported_modes[0],
 				 v4l2_subdev_get_try_format(sd, fh->state, 0));
 	mutex_unlock(&ov8856->mutex);
 
@@ -2233,151 +1164,9 @@ static int ov8856_identify_module(struct ov8856 *ov8856)
 		return -ENXIO;
 	}
 
-	ret = ov8856_write_reg(ov8856, OV8856_REG_MODE_SELECT,
-			       OV8856_REG_VALUE_08BIT, OV8856_MODE_STREAMING);
-	if (ret)
-		return ret;
-
-	ret = ov8856_write_reg(ov8856, OV8856_OTP_MODE_CTRL,
-			       OV8856_REG_VALUE_08BIT, OV8856_OTP_MODE_AUTO);
-	if (ret) {
-		dev_err(&client->dev, "failed to set otp mode");
-		return ret;
-	}
-
-	ret = ov8856_write_reg(ov8856, OV8856_OTP_LOAD_CTRL,
-			       OV8856_REG_VALUE_08BIT,
-			       OV8856_OTP_LOAD_CTRL_ENABLE);
-	if (ret) {
-		dev_err(&client->dev, "failed to enable load control");
-		return ret;
-	}
-
-	ret = ov8856_read_reg(ov8856, OV8856_MODULE_REVISION,
-			      OV8856_REG_VALUE_08BIT, &val);
-	if (ret) {
-		dev_err(&client->dev, "failed to read module revision");
-		return ret;
-	}
-
-	dev_info(&client->dev, "OV8856 revision %x (%s) at address 0x%02x\n",
-		 val,
-		 val == OV8856_2A_MODULE ? "2A" :
-		 val == OV8856_1B_MODULE ? "1B" : "unknown revision",
-		 client->addr);
-
-	ret = ov8856_write_reg(ov8856, OV8856_REG_MODE_SELECT,
-			       OV8856_REG_VALUE_08BIT, OV8856_MODE_STANDBY);
-	if (ret) {
-		dev_err(&client->dev, "failed to exit streaming mode");
-		return ret;
-	}
-
 	return 0;
 }
 
-static int ov8856_get_hwcfg(struct ov8856 *ov8856, struct device *dev)
-{
-	struct fwnode_handle *ep;
-	struct fwnode_handle *fwnode = dev_fwnode(dev);
-	struct v4l2_fwnode_endpoint bus_cfg = {
-		.bus_type = V4L2_MBUS_CSI2_DPHY
-	};
-	u32 xvclk_rate;
-	int ret;
-	unsigned int i, j;
-
-	if (!fwnode)
-		return -ENXIO;
-
-	ret = fwnode_property_read_u32(fwnode, "clock-frequency", &xvclk_rate);
-	if (ret)
-		return ret;
-
-	if (!is_acpi_node(fwnode)) {
-		ov8856->xvclk = devm_clk_get(dev, "xvclk");
-		if (IS_ERR(ov8856->xvclk)) {
-			dev_err(dev, "could not get xvclk clock (%pe)\n",
-				ov8856->xvclk);
-			return PTR_ERR(ov8856->xvclk);
-		}
-
-		clk_set_rate(ov8856->xvclk, xvclk_rate);
-		xvclk_rate = clk_get_rate(ov8856->xvclk);
-
-		ov8856->reset_gpio = devm_gpiod_get_optional(dev, "reset",
-							     GPIOD_OUT_LOW);
-		if (IS_ERR(ov8856->reset_gpio))
-			return PTR_ERR(ov8856->reset_gpio);
-
-		for (i = 0; i < ARRAY_SIZE(ov8856_supply_names); i++)
-			ov8856->supplies[i].supply = ov8856_supply_names[i];
-
-		ret = devm_regulator_bulk_get(dev,
-					      ARRAY_SIZE(ov8856_supply_names),
-					      ov8856->supplies);
-		if (ret)
-			return ret;
-	}
-
-	if (xvclk_rate != OV8856_XVCLK_19_2)
-		dev_warn(dev, "external clock rate %u is unsupported",
-			 xvclk_rate);
-
-	ep = fwnode_graph_get_next_endpoint(fwnode, NULL);
-	if (!ep)
-		return -ENXIO;
-
-	ret = v4l2_fwnode_endpoint_alloc_parse(ep, &bus_cfg);
-	fwnode_handle_put(ep);
-	if (ret)
-		return ret;
-
-	/* Get number of data lanes */
-	if (bus_cfg.bus.mipi_csi2.num_data_lanes != 2 &&
-	    bus_cfg.bus.mipi_csi2.num_data_lanes != 4) {
-		dev_err(dev, "number of CSI2 data lanes %d is not supported",
-			bus_cfg.bus.mipi_csi2.num_data_lanes);
-		ret = -EINVAL;
-		goto check_hwcfg_error;
-	}
-
-	dev_dbg(dev, "Using %u data lanes\n", ov8856->cur_mode->data_lanes);
-
-	if (bus_cfg.bus.mipi_csi2.num_data_lanes == 2)
-		ov8856->priv_lane = &lane_cfg_2;
-	else
-		ov8856->priv_lane = &lane_cfg_4;
-
-	ov8856->modes_size = ov8856_modes_num(ov8856);
-
-	if (!bus_cfg.nr_of_link_frequencies) {
-		dev_err(dev, "no link frequencies defined");
-		ret = -EINVAL;
-		goto check_hwcfg_error;
-	}
-
-	for (i = 0; i < ARRAY_SIZE(ov8856->priv_lane->link_freq_menu_items); i++) {
-		for (j = 0; j < bus_cfg.nr_of_link_frequencies; j++) {
-			if (ov8856->priv_lane->link_freq_menu_items[i] ==
-			    bus_cfg.link_frequencies[j])
-				break;
-		}
-
-		if (j == bus_cfg.nr_of_link_frequencies) {
-			dev_err(dev, "no link frequency %lld supported",
-				ov8856->priv_lane->link_freq_menu_items[i]);
-			ret = -EINVAL;
-			goto check_hwcfg_error;
-		}
-	}
-
-check_hwcfg_error:
-	v4l2_fwnode_endpoint_free(&bus_cfg);
-
-	return ret;
-}
-
 static int ov8856_remove(struct i2c_client *client)
 {
 	struct v4l2_subdev *sd = i2c_get_clientdata(client);
@@ -2389,8 +1178,6 @@ static int ov8856_remove(struct i2c_client *client)
 	pm_runtime_disable(&client->dev);
 	mutex_destroy(&ov8856->mutex);
 
-	__ov8856_power_off(ov8856);
-
 	return 0;
 }
 
@@ -2403,29 +1190,15 @@ static int ov8856_probe(struct i2c_client *client)
 	if (!ov8856)
 		return -ENOMEM;
 
-	ret = ov8856_get_hwcfg(ov8856, &client->dev);
-	if (ret) {
-		dev_err(&client->dev, "failed to get HW configuration: %d",
-			ret);
-		return ret;
-	}
-
 	v4l2_i2c_subdev_init(&ov8856->sd, client, &ov8856_subdev_ops);
-
-	ret = __ov8856_power_on(ov8856);
-	if (ret) {
-		dev_err(&client->dev, "failed to power on\n");
-		return ret;
-	}
-
 	ret = ov8856_identify_module(ov8856);
 	if (ret) {
 		dev_err(&client->dev, "failed to find sensor: %d", ret);
-		goto probe_power_off;
+		return ret;
 	}
 
 	mutex_init(&ov8856->mutex);
-	ov8856->cur_mode = &ov8856->priv_lane->supported_modes[0];
+	ov8856->cur_mode = &supported_modes[0];
 	ret = ov8856_init_controls(ov8856);
 	if (ret) {
 		dev_err(&client->dev, "failed to init controls: %d", ret);
@@ -2467,9 +1240,6 @@ static int ov8856_probe(struct i2c_client *client)
 	v4l2_ctrl_handler_free(ov8856->sd.ctrl_handler);
 	mutex_destroy(&ov8856->mutex);
 
-probe_power_off:
-	__ov8856_power_off(ov8856);
-
 	return ret;
 }
 
@@ -2477,6 +1247,12 @@ static const struct dev_pm_ops ov8856_pm_ops = {
 	SET_SYSTEM_SLEEP_PM_OPS(ov8856_suspend, ov8856_resume)
 };
 
+static const struct i2c_device_id ov8856_id_table[] = {
+	{ "ov8856", 0 },
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(i2c, ov8856_id_table);
+
 #ifdef CONFIG_ACPI
 static const struct acpi_device_id ov8856_acpi_ids[] = {
 	{"OVTI8856"},
@@ -2486,25 +1262,20 @@ static const struct acpi_device_id ov8856_acpi_ids[] = {
 MODULE_DEVICE_TABLE(acpi, ov8856_acpi_ids);
 #endif
 
-static const struct of_device_id ov8856_of_match[] = {
-	{ .compatible = "ovti,ov8856" },
-	{ /* sentinel */ }
-};
-MODULE_DEVICE_TABLE(of, ov8856_of_match);
-
 static struct i2c_driver ov8856_i2c_driver = {
 	.driver = {
 		.name = "ov8856",
 		.pm = &ov8856_pm_ops,
 		.acpi_match_table = ACPI_PTR(ov8856_acpi_ids),
-		.of_match_table = ov8856_of_match,
 	},
 	.probe_new = ov8856_probe,
 	.remove = ov8856_remove,
+	.id_table = ov8856_id_table,
 };
 
 module_i2c_driver(ov8856_i2c_driver);
 
 MODULE_AUTHOR("Ben Kao <ben.kao@intel.com>");
+MODULE_AUTHOR("Qiu, Tianshu <tian.shu.qiu@intel.com>");
 MODULE_DESCRIPTION("OmniVision OV8856 sensor driver");
 MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/i2c/power_ctrl_logic.c b/drivers/media/i2c/power_ctrl_logic.c
new file mode 100644
index 000000000000..aaf475aa6e20
--- /dev/null
+++ b/drivers/media/i2c/power_ctrl_logic.c
@@ -0,0 +1,149 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (c) 2020-2021 Intel Corporation.
+
+#include <linux/acpi.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/mutex.h>
+#include <linux/gpio/consumer.h>
+#include <linux/version.h>
+
+#define PCL_DRV_NAME "power_ctrl_logic"
+
+struct power_ctrl_logic {
+	/* gpio resource*/
+	struct gpio_desc *reset_gpio;
+	struct gpio_desc *powerdn_gpio;
+	struct gpio_desc *clocken_gpio;
+	struct gpio_desc *indled_gpio;
+	/* status */
+	struct mutex status_lock;
+	bool power_on;
+	bool gpio_ready;
+};
+
+struct power_ctrl_gpio {
+	const char *name;
+	struct gpio_desc **pin;
+};
+
+/* mcu gpio resources*/
+static const struct acpi_gpio_params camreset_gpio  = { 0, 0, false };
+static const struct acpi_gpio_params campwdn_gpio   = { 1, 0, false };
+static const struct acpi_gpio_params midmclken_gpio = { 2, 0, false };
+static const struct acpi_gpio_params led_gpio       = { 3, 0, false };
+static const struct acpi_gpio_mapping dsc1_acpi_gpios[] = {
+	{ "camreset-gpios", &camreset_gpio, 1 },
+	{ "campwdn-gpios", &campwdn_gpio, 1 },
+	{ "midmclken-gpios", &midmclken_gpio, 1 },
+	{ "indled-gpios", &led_gpio, 1 },
+	{ }
+};
+
+static struct power_ctrl_logic pcl = {
+	.reset_gpio = NULL,
+	.powerdn_gpio = NULL,
+	.clocken_gpio = NULL,
+	.indled_gpio = NULL,
+	.power_on = false,
+	.gpio_ready = false,
+};
+
+static struct power_ctrl_gpio pcl_gpios[] = {
+	{ "camreset", &pcl.reset_gpio },
+	{ "campwdn", &pcl.powerdn_gpio },
+	{ "midmclken", &pcl.clocken_gpio},
+	{ "indled", &pcl.indled_gpio},
+};
+
+static int power_ctrl_logic_add(struct acpi_device *adev)
+{
+	int i, ret;
+
+	dev_dbg(&adev->dev, "@%s, enter\n", __func__);
+	set_primary_fwnode(&adev->dev, &adev->fwnode);
+
+	ret = acpi_dev_add_driver_gpios(adev, dsc1_acpi_gpios);
+	if (ret) {
+		dev_err(&adev->dev, "@%s: --111---fail to add gpio. ret %d\n", __func__, ret);
+		return -EBUSY;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(pcl_gpios); i++) {
+		*pcl_gpios[i].pin = gpiod_get(&adev->dev, pcl_gpios[i].name, GPIOD_OUT_LOW);
+		if (IS_ERR(*pcl_gpios[i].pin)) {
+			dev_dbg(&adev->dev, "failed to get gpio %s\n", pcl_gpios[i].name);
+			return -EPROBE_DEFER;
+		}
+	}
+
+	mutex_lock(&pcl.status_lock);
+	pcl.gpio_ready = true;
+	mutex_unlock(&pcl.status_lock);
+	acpi_dev_clear_dependencies(adev);
+
+	dev_dbg(&adev->dev, "@%s, exit\n", __func__);
+	return ret;
+}
+
+static int power_ctrl_logic_remove(struct acpi_device *adev)
+{
+	dev_dbg(&adev->dev, "@%s, enter\n", __func__);
+	mutex_lock(&pcl.status_lock);
+	pcl.gpio_ready = false;
+	gpiod_set_value_cansleep(pcl.reset_gpio, 0);
+	gpiod_put(pcl.reset_gpio);
+	gpiod_set_value_cansleep(pcl.powerdn_gpio, 0);
+	gpiod_put(pcl.powerdn_gpio);
+	gpiod_set_value_cansleep(pcl.clocken_gpio, 0);
+	gpiod_put(pcl.clocken_gpio);
+	gpiod_set_value_cansleep(pcl.indled_gpio, 0);
+	gpiod_put(pcl.indled_gpio);
+	mutex_unlock(&pcl.status_lock);
+	dev_dbg(&adev->dev, "@%s, exit\n", __func__);
+	return 0;
+}
+
+static struct acpi_device_id acpi_ids[] = {
+	{ "INT3472", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(acpi, acpi_ids);
+
+static struct acpi_driver _driver = {
+	.name = PCL_DRV_NAME,
+	.class = PCL_DRV_NAME,
+	.ids = acpi_ids,
+	.ops = {
+		.add = power_ctrl_logic_add,
+		.remove = power_ctrl_logic_remove,
+	},
+};
+module_acpi_driver(_driver);
+
+int power_ctrl_logic_set_power(int on)
+{
+	mutex_lock(&pcl.status_lock);
+	if (!pcl.gpio_ready) {
+		pr_debug("@%s,failed to set power, gpio_ready=%d, on=%d\n",
+			 __func__, pcl.gpio_ready, on);
+		mutex_unlock(&pcl.status_lock);
+		return -EPROBE_DEFER;
+	}
+	if (pcl.power_on != on) {
+		gpiod_set_value_cansleep(pcl.reset_gpio, on);
+		gpiod_set_value_cansleep(pcl.powerdn_gpio, on);
+		gpiod_set_value_cansleep(pcl.clocken_gpio, on);
+		gpiod_set_value_cansleep(pcl.indled_gpio, on);
+		pcl.power_on = on;
+	}
+	mutex_unlock(&pcl.status_lock);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(power_ctrl_logic_set_power);
+
+MODULE_AUTHOR("Bingbu Cao <bingbu.cao@intel.com>");
+MODULE_AUTHOR("Qiu, Tianshu <tian.shu.qiu@intel.com>");
+MODULE_AUTHOR("Xu, Chongyang <chongyang.xu@intel.com>");
+MODULE_DESCRIPTION("Power Control Logic Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/i2c/power_ctrl_logic.h b/drivers/media/i2c/power_ctrl_logic.h
new file mode 100644
index 000000000000..a7967858fbe9
--- /dev/null
+++ b/drivers/media/i2c/power_ctrl_logic.h
@@ -0,0 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (c) 2020-2021 Intel Corporation. */
+
+#ifndef _POWER_CTRL_LOGIC_H_
+#define _POWER_CTRL_LOGIC_H_
+
+/* exported function for extern module */
+int power_ctrl_logic_set_power(int on);
+#endif
diff --git a/drivers/media/pci/intel/Kconfig b/drivers/media/pci/intel/Kconfig
index 47c40fd2e8eb..20673f7ce2e5 100644
--- a/drivers/media/pci/intel/Kconfig
+++ b/drivers/media/pci/intel/Kconfig
@@ -32,7 +32,7 @@ config VIDEO_INTEL_IPU_SOC
 endchoice
 
 config VIDEO_INTEL_IPU_WERROR
-	bool "Force GCC to throw an error instead of a warning when compiling"
+	tristate "Force GCC to throw an error instead of a warning when compiling"
 	depends on VIDEO_INTEL_IPU6
 	depends on EXPERT
 	depends on !COMPILE_TEST
@@ -46,14 +46,14 @@ config VIDEO_INTEL_IPU_WERROR
 	  If in doubt, say "N".
 
 config VIDEO_INTEL_IPU_USE_PLATFORMDATA
-	bool "Enable platform data"
+	tristate "Enable platform data"
 	depends on VIDEO_INTEL_IPU6
 	default y
 	help
 	  Enalbe platform data in IPU.
 
 config VIDEO_INTEL_IPU_PDATA_DYNAMIC_LOADING
-	bool "Enable platform data dynamic loading"
+	tristate "Enable platform data dynamic loading"
 	depends on VIDEO_INTEL_IPU6
 	depends on VIDEO_INTEL_IPU_USE_PLATFORMDATA
 	default n
diff --git a/drivers/media/pci/intel/ipu-buttress.c b/drivers/media/pci/intel/ipu-buttress.c
index f4c708240dba..d0a3bdf10a08 100644
--- a/drivers/media/pci/intel/ipu-buttress.c
+++ b/drivers/media/pci/intel/ipu-buttress.c
@@ -1,5 +1,5 @@
 // SPDX-License-Identifier: GPL-2.0
-// Copyright (C) 2013 - 2020 Intel Corporation
+// Copyright (C) 2013 - 2022 Intel Corporation
 
 #include <linux/clk.h>
 #include <linux/clkdev.h>
@@ -23,11 +23,6 @@
 #include "ipu-buttress.h"
 #include "ipu-platform-buttress-regs.h"
 #include "ipu-cpd.h"
-#ifdef IPU_TRACE_EVENT
-#define CREATE_TRACE_POINTS
-#define IPU_PERF_REG_TRACE
-#include "ipu-trace-event.h"
-#endif
 
 #define BOOTLOADER_STATUS_OFFSET       0x15c
 
@@ -381,12 +376,6 @@ irqreturn_t ipu_buttress_isr(int irq, void *isp_ptr)
 		return IRQ_HANDLED;
 	}
 
-#ifdef IPU_TRACE_EVENT
-	trace_ipu_perf_reg(BUTTRESS_REG_IS_FREQ_CTL,
-			   readl(isp->base + BUTTRESS_REG_IS_FREQ_CTL));
-	trace_ipu_perf_reg(BUTTRESS_REG_PS_FREQ_CTL,
-			   readl(isp->base + BUTTRESS_REG_PS_FREQ_CTL));
-#endif
 	irq_status = readl(isp->base + reg_irq_sts);
 	if (!irq_status) {
 		pm_runtime_put(&isp->pdev->dev);
@@ -451,6 +440,15 @@ irqreturn_t ipu_buttress_isr(int irq, void *isp_ptr)
 			WARN_ON(1);
 		}
 
+		if (irq_status & (BUTTRESS_ISR_IS_FATAL_MEM_ERR |
+				  BUTTRESS_ISR_PS_FATAL_MEM_ERR)) {
+			dev_err(&isp->pdev->dev,
+				"BUTTRESS_ISR_FATAL_MEM_ERR\n");
+		}
+
+		if (irq_status & BUTTRESS_ISR_UFI_ERROR)
+			dev_err(&isp->pdev->dev, "BUTTRESS_ISR_UFI_ERROR\n");
+
 		irq_status = readl(isp->base + reg_irq_sts);
 	} while (irq_status && !isp->flr_done);
 
@@ -523,12 +521,6 @@ int ipu_buttress_power(struct device *dev,
 
 	ctrl->started = !ret && on;
 
-#ifdef IPU_TRACE_EVENT
-	trace_ipu_perf_reg(BUTTRESS_REG_IS_FREQ_CTL,
-			   readl(isp->base + BUTTRESS_REG_IS_FREQ_CTL));
-	trace_ipu_perf_reg(BUTTRESS_REG_PS_FREQ_CTL,
-			   readl(isp->base + BUTTRESS_REG_PS_FREQ_CTL));
-#endif
 	mutex_unlock(&isp->buttress.power_mutex);
 
 	return ret;
@@ -742,8 +734,8 @@ int ipu_buttress_map_fw_image(struct ipu_bus_device *sys,
 {
 	struct page **pages;
 	const void *addr;
-	unsigned long n_pages, i;
-	int rval;
+	unsigned long n_pages;
+	int rval, i;
 
 	n_pages = PAGE_ALIGN(fw->size) >> PAGE_SHIFT;
 
@@ -770,14 +762,14 @@ int ipu_buttress_map_fw_image(struct ipu_bus_device *sys,
 		goto out;
 	}
 
-	n_pages = dma_map_sg(&sys->dev, sgt->sgl, sgt->nents, DMA_TO_DEVICE);
-	if (n_pages != sgt->nents) {
+	rval = dma_map_sgtable(&sys->dev, sgt, DMA_TO_DEVICE, 0);
+	if (rval < 0) {
 		rval = -ENOMEM;
 		sg_free_table(sgt);
 		goto out;
 	}
 
-	dma_sync_sg_for_device(&sys->dev, sgt->sgl, sgt->nents, DMA_TO_DEVICE);
+	dma_sync_sgtable_for_device(&sys->dev, sgt, DMA_TO_DEVICE);
 
 out:
 	kfree(pages);
@@ -1041,6 +1033,32 @@ int ipu_buttress_tsc_read(struct ipu_device *isp, u64 *val)
 }
 EXPORT_SYMBOL_GPL(ipu_buttress_tsc_read);
 
+int ipu_buttress_isys_freq_set(void *data, u64 val)
+{
+	struct ipu_device *isp = data;
+	int rval;
+
+	if (val < BUTTRESS_MIN_FORCE_IS_FREQ ||
+	    val > BUTTRESS_MAX_FORCE_IS_FREQ)
+		return -EINVAL;
+
+	rval = pm_runtime_get_sync(&isp->isys->dev);
+	if (rval < 0) {
+		pm_runtime_put(&isp->isys->dev);
+		dev_err(&isp->pdev->dev, "Runtime PM failed (%d)\n", rval);
+		return rval;
+	}
+
+	do_div(val, BUTTRESS_IS_FREQ_STEP);
+	if (val)
+		ipu_buttress_set_isys_ratio(isp, val);
+
+	pm_runtime_put(&isp->isys->dev);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ipu_buttress_isys_freq_set);
+
 #ifdef CONFIG_DEBUG_FS
 
 static int ipu_buttress_reg_open(struct inode *inode, struct file *file)
@@ -1166,31 +1184,6 @@ static int ipu_buttress_isys_freq_get(void *data, u64 *val)
 	return 0;
 }
 
-static int ipu_buttress_isys_freq_set(void *data, u64 val)
-{
-	struct ipu_device *isp = data;
-	int rval;
-
-	if (val < BUTTRESS_MIN_FORCE_IS_FREQ ||
-	    val > BUTTRESS_MAX_FORCE_IS_FREQ)
-		return -EINVAL;
-
-	rval = pm_runtime_get_sync(&isp->isys->dev);
-	if (rval < 0) {
-		pm_runtime_put(&isp->isys->dev);
-		dev_err(&isp->pdev->dev, "Runtime PM failed (%d)\n", rval);
-		return rval;
-	}
-
-	do_div(val, BUTTRESS_IS_FREQ_STEP);
-	if (val)
-		ipu_buttress_set_isys_ratio(isp, val);
-
-	pm_runtime_put(&isp->isys->dev);
-
-	return 0;
-}
-
 DEFINE_SIMPLE_ATTRIBUTE(ipu_buttress_psys_force_freq_fops,
 			ipu_buttress_psys_force_freq_get,
 			ipu_buttress_psys_force_freq_set, "%llu\n");
@@ -1358,6 +1351,12 @@ int ipu_buttress_init(struct ipu_device *isp)
 	dev_info(&isp->pdev->dev, "IPU in %s mode\n",
 		 isp->secure_mode ? "secure" : "non-secure");
 
+	dev_info(&isp->pdev->dev, "IPU secure touch = 0x%x\n",
+		 readl(isp->base + BUTTRESS_REG_SECURITY_TOUCH));
+
+	dev_info(&isp->pdev->dev, "IPU camera mask = 0x%x\n",
+		 readl(isp->base + BUTTRESS_REG_CAMERA_MASK));
+
 	b->wdt_cached_value = readl(isp->base + BUTTRESS_REG_WDT);
 	writel(BUTTRESS_IRQS, isp->base + BUTTRESS_REG_ISR_CLEAR);
 	writel(BUTTRESS_IRQS, isp->base + BUTTRESS_REG_ISR_ENABLE);
diff --git a/drivers/media/pci/intel/ipu-buttress.h b/drivers/media/pci/intel/ipu-buttress.h
index 5865a35eae7e..cfe008f749f4 100644
--- a/drivers/media/pci/intel/ipu-buttress.h
+++ b/drivers/media/pci/intel/ipu-buttress.h
@@ -1,5 +1,5 @@
 /* SPDX-License-Identifier: GPL-2.0 */
-/* Copyright (C) 2013 - 2020 Intel Corporation */
+/* Copyright (C) 2013 - 2022 Intel Corporation */
 
 #ifndef IPU_BUTTRESS_H
 #define IPU_BUTTRESS_H
@@ -125,6 +125,7 @@ void ipu_buttress_csi_port_config(struct ipu_device *isp,
 				  u32 legacy, u32 combo);
 int ipu_buttress_restore(struct ipu_device *isp);
 
+int ipu_buttress_isys_freq_set(void *data, u64 val);
 int ipu_buttress_psys_freq_get(void *data, u64 *val);
 int ipu_get_i2c_bus_id(int adapter_id, char *adapter_bdf, int bdf_len);
 #endif /* IPU_BUTTRESS_H */
diff --git a/drivers/media/pci/intel/ipu-cpd.c b/drivers/media/pci/intel/ipu-cpd.c
index 3833f3f0bd8d..26099c46e463 100644
--- a/drivers/media/pci/intel/ipu-cpd.c
+++ b/drivers/media/pci/intel/ipu-cpd.c
@@ -180,7 +180,8 @@ static int ipu_cpd_parse_module_data(struct ipu_device *isp,
 
 		*p++ = dma_addr_module_data + dir_ent->offset;
 
-		if (ipu_ver == IPU_VER_6 || ipu_ver == IPU_VER_6EP)
+		if (ipu_ver == IPU_VER_6 || ipu_ver == IPU_VER_6EP ||
+		    ipu_ver == IPU_VER_6EP_MTL)
 			id = ipu6_cpd_metadata_get_cmpnt_id(isp, metadata,
 							    metadata_size, i);
 		else
@@ -193,7 +194,8 @@ static int ipu_cpd_parse_module_data(struct ipu_device *isp,
 			return -EINVAL;
 		}
 
-		if (ipu_ver == IPU_VER_6 || ipu_ver == IPU_VER_6EP)
+		if (ipu_ver == IPU_VER_6 || ipu_ver == IPU_VER_6EP ||
+		    ipu_ver == IPU_VER_6EP_MTL)
 			ver = ipu6_cpd_metadata_cmpnt_version(isp, metadata,
 							      metadata_size, i);
 		else
@@ -377,7 +379,8 @@ static int ipu_cpd_validate_metadata(struct ipu_device *isp,
 	}
 
 	/* Validate metadata size multiple of metadata components */
-	if (ipu_ver == IPU_VER_6 || ipu_ver == IPU_VER_6EP)
+	if (ipu_ver == IPU_VER_6 || ipu_ver == IPU_VER_6EP ||
+	    ipu_ver == IPU_VER_6EP_MTL)
 		size = sizeof(struct ipu6_cpd_metadata_cmpnt);
 	else
 		size = sizeof(struct ipu_cpd_metadata_cmpnt);
diff --git a/drivers/media/pci/intel/ipu-dma.c b/drivers/media/pci/intel/ipu-dma.c
index a661257a30de..d37762cb7841 100644
--- a/drivers/media/pci/intel/ipu-dma.c
+++ b/drivers/media/pci/intel/ipu-dma.c
@@ -22,16 +22,18 @@
 struct vm_info {
 	struct list_head list;
 	struct page **pages;
+	dma_addr_t ipu_iova;
 	void *vaddr;
 	unsigned long size;
 };
 
-static struct vm_info *get_vm_info(struct ipu_mmu *mmu, void *vaddr)
+static struct vm_info *get_vm_info(struct ipu_mmu *mmu, dma_addr_t iova)
 {
 	struct vm_info *info, *save;
 
 	list_for_each_entry_safe(info, save, &mmu->vma_list, list) {
-		if (info->vaddr == vaddr)
+		if (iova >= info->ipu_iova &&
+		    iova < (info->ipu_iova + info->size))
 			return info;
 	}
 
@@ -107,7 +109,6 @@ static int __dma_free_buffer(struct device *dev, struct page **pages,
 
 	for (i = 0; i < count; i++) {
 		if (pages[i]) {
-			__dma_clear_buffer(pages[i], PAGE_SIZE, attrs);
 			__free_pages(pages[i], 0);
 		}
 	}
@@ -123,11 +124,21 @@ static void ipu_dma_sync_single_for_cpu(struct device *dev,
 					size_t size,
 					enum dma_data_direction dir)
 {
+	void *vaddr;
+	u32 offset;
+	struct vm_info *info;
 	struct ipu_mmu *mmu = to_ipu_bus_device(dev)->mmu;
-	unsigned long pa = ipu_mmu_iova_to_phys(mmu->dmap->mmu_info,
-						dma_handle);
 
-	clflush_cache_range(phys_to_virt(pa), size);
+	info = get_vm_info(mmu, dma_handle);
+	if (WARN_ON(!info))
+		return;
+
+	offset = dma_handle - info->ipu_iova;
+	if (WARN_ON(size > (info->size - offset)))
+		return;
+
+	vaddr = info->vaddr + offset;
+	clflush_cache_range(vaddr, size);
 }
 
 static void ipu_dma_sync_sg_for_cpu(struct device *dev,
@@ -146,12 +157,14 @@ static void *ipu_dma_alloc(struct device *dev, size_t size,
 			   unsigned long attrs)
 {
 	struct ipu_mmu *mmu = to_ipu_bus_device(dev)->mmu;
+	struct pci_dev *pdev = to_ipu_bus_device(dev)->isp->pdev;
 	struct page **pages;
 	struct iova *iova;
 	struct vm_info *info;
 	int i;
 	int rval;
 	unsigned long count;
+	dma_addr_t pci_dma_addr, ipu_iova;
 
 	info = kzalloc(sizeof(*info), GFP_KERNEL);
 	if (!info)
@@ -169,12 +182,30 @@ static void *ipu_dma_alloc(struct device *dev, size_t size,
 	if (!pages)
 		goto out_free_iova;
 
+	dev_dbg(dev, "dma_alloc: iova low pfn %lu, high pfn %lu\n", iova->pfn_lo,
+		iova->pfn_hi);
 	for (i = 0; iova->pfn_lo + i <= iova->pfn_hi; i++) {
+		pci_dma_addr = dma_map_page_attrs(&pdev->dev, pages[i], 0,
+						  PAGE_SIZE, DMA_BIDIRECTIONAL,
+						  attrs);
+		dev_dbg(dev, "dma_alloc: mapped pci_dma_addr %pad\n",
+			&pci_dma_addr);
+		if (dma_mapping_error(&pdev->dev, pci_dma_addr)) {
+			dev_err(dev, "pci_dma_mapping for page[%d] failed", i);
+			goto out_unmap;
+		}
+
 		rval = ipu_mmu_map(mmu->dmap->mmu_info,
 				   (iova->pfn_lo + i) << PAGE_SHIFT,
-				   page_to_phys(pages[i]), PAGE_SIZE);
-		if (rval)
+				   pci_dma_addr, PAGE_SIZE);
+		if (rval) {
+			dev_err(dev, "ipu_mmu_map for pci_dma[%d] %pad failed",
+				i, &pci_dma_addr);
+			dma_unmap_page_attrs(&pdev->dev, pci_dma_addr,
+					     PAGE_SIZE, DMA_BIDIRECTIONAL,
+					     attrs);
 			goto out_unmap;
+		}
 	}
 
 	info->vaddr = vmap(pages, count, VM_USERMAP, PAGE_KERNEL);
@@ -184,6 +215,7 @@ static void *ipu_dma_alloc(struct device *dev, size_t size,
 	*dma_handle = iova->pfn_lo << PAGE_SHIFT;
 
 	info->pages = pages;
+	info->ipu_iova = *dma_handle;
 	info->size = size;
 	list_add(&info->list, &mmu->vma_list);
 
@@ -191,9 +223,15 @@ static void *ipu_dma_alloc(struct device *dev, size_t size,
 
 out_unmap:
 	for (i--; i >= 0; i--) {
-		ipu_mmu_unmap(mmu->dmap->mmu_info,
-			      (iova->pfn_lo + i) << PAGE_SHIFT, PAGE_SIZE);
+		ipu_iova = (iova->pfn_lo + i) << PAGE_SHIFT;
+		pci_dma_addr = ipu_mmu_iova_to_phys(mmu->dmap->mmu_info,
+						    ipu_iova);
+		dma_unmap_page_attrs(&pdev->dev, pci_dma_addr, PAGE_SIZE,
+				     DMA_BIDIRECTIONAL, attrs);
+
+		ipu_mmu_unmap(mmu->dmap->mmu_info, ipu_iova, PAGE_SIZE);
 	}
+
 	__dma_free_buffer(dev, pages, size, attrs);
 
 out_free_iova:
@@ -209,15 +247,18 @@ static void ipu_dma_free(struct device *dev, size_t size, void *vaddr,
 			 unsigned long attrs)
 {
 	struct ipu_mmu *mmu = to_ipu_bus_device(dev)->mmu;
+	struct pci_dev *pdev = to_ipu_bus_device(dev)->isp->pdev;
 	struct page **pages;
 	struct vm_info *info;
 	struct iova *iova = find_iova(&mmu->dmap->iovad,
 				      dma_handle >> PAGE_SHIFT);
+	dma_addr_t pci_dma_addr, ipu_iova;
+	int i;
 
 	if (WARN_ON(!iova))
 		return;
 
-	info = get_vm_info(mmu, vaddr);
+	info = get_vm_info(mmu, dma_handle);
 	if (WARN_ON(!info))
 		return;
 
@@ -235,8 +276,16 @@ static void ipu_dma_free(struct device *dev, size_t size, void *vaddr,
 
 	vunmap(vaddr);
 
+	for (i = 0; i < size >> PAGE_SHIFT; i++) {
+		ipu_iova = (iova->pfn_lo + i) << PAGE_SHIFT;
+		pci_dma_addr = ipu_mmu_iova_to_phys(mmu->dmap->mmu_info,
+						    ipu_iova);
+		dma_unmap_page_attrs(&pdev->dev, pci_dma_addr, PAGE_SIZE,
+				     DMA_BIDIRECTIONAL, attrs);
+	}
+
 	ipu_mmu_unmap(mmu->dmap->mmu_info, iova->pfn_lo << PAGE_SHIFT,
-		      (iova->pfn_hi - iova->pfn_lo + 1) << PAGE_SHIFT);
+		      iova_size(iova) << PAGE_SHIFT);
 
 	__dma_free_buffer(dev, pages, size, attrs);
 
@@ -256,7 +305,7 @@ static int ipu_dma_mmap(struct device *dev, struct vm_area_struct *vma,
 	size_t count = PAGE_ALIGN(size) >> PAGE_SHIFT;
 	size_t i;
 
-	info = get_vm_info(mmu, addr);
+	info = get_vm_info(mmu, iova);
 	if (!info)
 		return -EFAULT;
 
@@ -281,7 +330,11 @@ static void ipu_dma_unmap_sg(struct device *dev,
 			     int nents, enum dma_data_direction dir,
 			     unsigned long attrs)
 {
+	int i, npages, count;
+	struct scatterlist *sg;
+	dma_addr_t pci_dma_addr;
 	struct ipu_mmu *mmu = to_ipu_bus_device(dev)->mmu;
+	struct pci_dev *pdev = to_ipu_bus_device(dev)->isp->pdev;
 	struct iova *iova = find_iova(&mmu->dmap->iovad,
 				      sg_dma_address(sglist) >> PAGE_SHIFT);
 
@@ -294,11 +347,43 @@ static void ipu_dma_unmap_sg(struct device *dev,
 	if ((attrs & DMA_ATTR_SKIP_CPU_SYNC) == 0)
 		ipu_dma_sync_sg_for_cpu(dev, sglist, nents, DMA_BIDIRECTIONAL);
 
+	/* get the nents as orig_nents given by caller */
+	count = 0;
+	npages = iova_size(iova);
+	for_each_sg(sglist, sg, nents, i) {
+		if (sg_dma_len(sg) == 0 ||
+		    sg_dma_address(sg) == DMA_MAPPING_ERROR)
+			break;
+
+		npages -= PAGE_ALIGN(sg_dma_len(sg)) >> PAGE_SHIFT;
+		count++;
+		if (npages <= 0)
+			break;
+	}
+
+	/* before ipu mmu unmap, return the pci dma address back to sg
+	 * assume the nents is less than orig_nents as the least granule
+	 * is 1 SZ_4K page
+	 */
+	dev_dbg(dev, "trying to unmap concatenated %u ents\n", count);
+	for_each_sg(sglist, sg, count, i) {
+		dev_dbg(dev, "ipu_unmap sg[%d] %pad\n", i, &sg_dma_address(sg));
+		pci_dma_addr = ipu_mmu_iova_to_phys(mmu->dmap->mmu_info,
+						    sg_dma_address(sg));
+		dev_dbg(dev, "return pci_dma_addr %pad back to sg[%d]\n",
+			&pci_dma_addr, i);
+		sg_dma_address(sg) = pci_dma_addr;
+	}
+
+	dev_dbg(dev, "ipu_mmu_unmap low pfn %lu high pfn %lu\n",
+		iova->pfn_lo, iova->pfn_hi);
 	ipu_mmu_unmap(mmu->dmap->mmu_info, iova->pfn_lo << PAGE_SHIFT,
-		      (iova->pfn_hi - iova->pfn_lo + 1) << PAGE_SHIFT);
+		      iova_size(iova) << PAGE_SHIFT);
 
 	mmu->tlb_invalidate(mmu);
 
+	dma_unmap_sg_attrs(&pdev->dev, sglist, nents, dir, attrs);
+
 	__free_iova(&mmu->dmap->iovad, iova);
 }
 
@@ -307,18 +392,26 @@ static int ipu_dma_map_sg(struct device *dev, struct scatterlist *sglist,
 			  unsigned long attrs)
 {
 	struct ipu_mmu *mmu = to_ipu_bus_device(dev)->mmu;
+	struct pci_dev *pdev = to_ipu_bus_device(dev)->isp->pdev;
 	struct scatterlist *sg;
 	struct iova *iova;
-	size_t size = 0;
+	size_t npages = 0;
 	u32 iova_addr;
-	int i;
+	int i, count;
 
-	for_each_sg(sglist, sg, nents, i)
-		size += PAGE_ALIGN(sg->length) >> PAGE_SHIFT;
+	dev_dbg(dev, "pci_dma_map_sg trying to map %d ents\n", nents);
+	count  = dma_map_sg_attrs(&pdev->dev, sglist, nents, dir, attrs);
+	if (count <= 0) {
+		dev_err(dev, "pci_dma_map_sg %d ents failed\n", nents);
+		return 0;
+	}
 
-	dev_dbg(dev, "dmamap: mapping sg %d entries, %zu pages\n", nents, size);
+	dev_dbg(dev, "pci_dma_map_sg %d ents mapped\n", count);
 
-	iova = alloc_iova(&mmu->dmap->iovad, size,
+	for_each_sg(sglist, sg, count, i)
+		npages += PAGE_ALIGN(sg_dma_len(sg)) >> PAGE_SHIFT;
+
+	iova = alloc_iova(&mmu->dmap->iovad, npages,
 			  dma_get_mask(dev) >> PAGE_SHIFT, 0);
 	if (!iova)
 		return 0;
@@ -327,24 +420,25 @@ static int ipu_dma_map_sg(struct device *dev, struct scatterlist *sglist,
 		iova->pfn_hi);
 
 	iova_addr = iova->pfn_lo;
-
-	for_each_sg(sglist, sg, nents, i) {
+	for_each_sg(sglist, sg, count, i) {
 		int rval;
 
-		dev_dbg(dev, "mapping entry %d: iova 0x%8.8x,phy 0x%16.16llx\n",
-			i, iova_addr << PAGE_SHIFT,
-			(unsigned long long)page_to_phys(sg_page(sg)));
+		dev_dbg(dev, "mapping entry %d: iova 0x%lx phy %pad size %d\n",
+			i, (unsigned long)iova_addr << PAGE_SHIFT,
+			&sg_dma_address(sg), sg_dma_len(sg));
+
+		dev_dbg(dev, "mapping entry %d: sg->length = %d\n", i,
+			sg->length);
+
 		rval = ipu_mmu_map(mmu->dmap->mmu_info, iova_addr << PAGE_SHIFT,
-				   page_to_phys(sg_page(sg)),
-				   PAGE_ALIGN(sg->length));
+				   sg_dma_address(sg),
+				   PAGE_ALIGN(sg_dma_len(sg)));
 		if (rval)
 			goto out_fail;
+
 		sg_dma_address(sg) = iova_addr << PAGE_SHIFT;
-#ifdef CONFIG_NEED_SG_DMA_LENGTH
-		sg_dma_len(sg) = sg->length;
-#endif /* CONFIG_NEED_SG_DMA_LENGTH */
 
-		iova_addr += PAGE_ALIGN(sg->length) >> PAGE_SHIFT;
+		iova_addr += PAGE_ALIGN(sg_dma_len(sg)) >> PAGE_SHIFT;
 	}
 
 	if ((attrs & DMA_ATTR_SKIP_CPU_SYNC) == 0)
@@ -352,7 +446,7 @@ static int ipu_dma_map_sg(struct device *dev, struct scatterlist *sglist,
 
 	mmu->tlb_invalidate(mmu);
 
-	return nents;
+	return count;
 
 out_fail:
 	ipu_dma_unmap_sg(dev, sglist, i, dir, attrs);
@@ -372,7 +466,7 @@ static int ipu_dma_get_sgtable(struct device *dev, struct sg_table *sgt,
 	int n_pages;
 	int ret = 0;
 
-	info = get_vm_info(mmu, cpu_addr);
+	info = get_vm_info(mmu, handle);
 	if (!info)
 		return -EFAULT;
 
@@ -387,7 +481,7 @@ static int ipu_dma_get_sgtable(struct device *dev, struct sg_table *sgt,
 	ret = sg_alloc_table_from_pages(sgt, info->pages, n_pages, 0, size,
 					GFP_KERNEL);
 	if (ret)
-		dev_dbg(dev, "IPU get sgt table fail\n");
+		dev_warn(dev, "IPU get sgt table fail\n");
 
 	return ret;
 }
diff --git a/drivers/media/pci/intel/ipu-fw-com.c b/drivers/media/pci/intel/ipu-fw-com.c
index 59d69ea6110c..492766dda199 100644
--- a/drivers/media/pci/intel/ipu-fw-com.c
+++ b/drivers/media/pci/intel/ipu-fw-com.c
@@ -1,5 +1,5 @@
 // SPDX-License-Identifier: GPL-2.0
-// Copyright (C) 2013 - 2020 Intel Corporation
+// Copyright (C) 2013 - 2022 Intel Corporation
 
 #include <asm/cacheflush.h>
 
@@ -10,6 +10,7 @@
 #include <linux/dma-mapping.h>
 
 #include "ipu.h"
+#include "ipu-trace.h"
 #include "ipu-fw-com.h"
 #include "ipu-bus.h"
 
@@ -335,11 +336,15 @@ EXPORT_SYMBOL_GPL(ipu_fw_com_prepare);
 
 int ipu_fw_com_open(struct ipu_fw_com_context *ctx)
 {
+	dma_addr_t trace_buff = TUNIT_MAGIC_PATTERN;
+
 	/*
-	 * Disable tunit configuration by FW.
-	 * This feature is used to configure tunit in secure mode.
+	 * Write trace buff start addr to tunit cfg reg.
+	 * This feature is used to enable tunit trace in secure mode.
 	 */
-	writel(TUNIT_MAGIC_PATTERN, ctx->dmem_addr + TUNIT_CFG_DWR_REG * 4);
+	ipu_trace_buffer_dma_handle(&ctx->adev->dev, &trace_buff);
+	writel(trace_buff, ctx->dmem_addr + TUNIT_CFG_DWR_REG * 4);
+
 	/* Check if SP is in valid state */
 	if (!ctx->cell_ready(ctx->adev))
 		return -EIO;
diff --git a/drivers/media/pci/intel/ipu-fw-isys.h b/drivers/media/pci/intel/ipu-fw-isys.h
index 8e703eeb668d..0dc320474b77 100644
--- a/drivers/media/pci/intel/ipu-fw-isys.h
+++ b/drivers/media/pci/intel/ipu-fw-isys.h
@@ -430,12 +430,6 @@ enum ipu_fw_isys_pin_type {
 	IPU_FW_ISYS_PIN_TYPE_METADATA_0 = 4,
 	/* Reserved for future use */
 	IPU_FW_ISYS_PIN_TYPE_METADATA_1 = 5,
-#if defined(IPU_ISYS_YUV422_I420)
-	/* Captured through the SoC path
-	 * (2D mode where odd and even lines are handled separately)
-	 */
-	IPU_FW_ISYS_PIN_TYPE_RAW_DUAL_SOC = 10,
-#endif
 	/* Keep always last and max value */
 	N_IPU_FW_ISYS_PIN_TYPE
 };
diff --git a/drivers/media/pci/intel/ipu-fw-psys.c b/drivers/media/pci/intel/ipu-fw-psys.c
index 219b72ef1190..68da73fa5c7a 100644
--- a/drivers/media/pci/intel/ipu-fw-psys.c
+++ b/drivers/media/pci/intel/ipu-fw-psys.c
@@ -15,38 +15,6 @@ int ipu_fw_psys_pg_start(struct ipu_psys_kcmd *kcmd)
 	return 0;
 }
 
-#ifdef IPU_TRACE_EVENT
-int ipu_fw_psys_pg_load_cycles(struct ipu_psys_kcmd *kcmd)
-{
-	return 0;
-}
-
-int ipu_fw_psys_pg_init_cycles(struct ipu_psys_kcmd *kcmd)
-{
-	return 0;
-}
-
-int ipu_fw_psys_pg_processing_cycles(struct ipu_psys_kcmd *kcmd)
-{
-	return 0;
-}
-
-int ipu_fw_psys_pg_server_init_cycles(struct ipu_psys_kcmd *kcmd)
-{
-	return 0;
-}
-
-int ipu_fw_psys_pg_next_frame_init_cycles(struct ipu_psys_kcmd *kcmd)
-{
-	return 0;
-}
-
-int ipu_fw_psys_pg_complete_cycles(struct ipu_psys_kcmd *kcmd)
-{
-	return 0;
-}
-#endif
-
 int ipu_fw_psys_pg_disown(struct ipu_psys_kcmd *kcmd)
 {
 	struct ipu_fw_psys_cmd *psys_cmd;
diff --git a/drivers/media/pci/intel/ipu-isys-csi2-be-soc.c b/drivers/media/pci/intel/ipu-isys-csi2-be-soc.c
index 45d01d8e3fc9..203f16eb5ed1 100644
--- a/drivers/media/pci/intel/ipu-isys-csi2-be-soc.c
+++ b/drivers/media/pci/intel/ipu-isys-csi2-be-soc.c
@@ -1,5 +1,5 @@
 // SPDX-License-Identifier: GPL-2.0
-// Copyright (C) 2014 - 2021 Intel Corporation
+// Copyright (C) 2014 - 2022 Intel Corporation
 
 #include <linux/device.h>
 #include <linux/module.h>
@@ -23,10 +23,6 @@ static const u32 csi2_be_soc_supported_codes_pad[] = {
 	MEDIA_BUS_FMT_Y10_1X10,
 	MEDIA_BUS_FMT_RGB565_1X16,
 	MEDIA_BUS_FMT_RGB888_1X24,
-#ifdef IPU_ISYS_YUV422_I420
-	/* YUV420 plannar */
-	MEDIA_BUS_FMT_UYVY8_2X8,
-#endif
 	MEDIA_BUS_FMT_UYVY8_1X16,
 	MEDIA_BUS_FMT_YUYV8_1X16,
 	MEDIA_BUS_FMT_SBGGR12_1X12,
@@ -64,6 +60,17 @@ static const u32 csi2_be_soc_supported_raw_bayer_codes_pad[] = {
 	0,
 };
 
+static int get_supported_code_index(u32 code)
+{
+	int i;
+
+	for (i = 0; csi2_be_soc_supported_raw_bayer_codes_pad[i]; i++) {
+		if (csi2_be_soc_supported_raw_bayer_codes_pad[i] == code)
+			return i;
+	}
+	return -EINVAL;
+}
+
 static const u32 *csi2_be_soc_supported_codes[NR_OF_CSI2_BE_SOC_PADS];
 
 static struct v4l2_subdev_internal_ops csi2_be_soc_sd_internal_ops = {
@@ -74,7 +81,6 @@ static struct v4l2_subdev_internal_ops csi2_be_soc_sd_internal_ops = {
 static const struct v4l2_subdev_core_ops csi2_be_soc_sd_core_ops = {
 };
 
-#if defined(IPU_ISYS_COMPRESSION)
 static const struct v4l2_ctrl_config compression_ctrl_cfg = {
 	.ops = NULL,
 	.id = V4L2_CID_IPU_ISYS_COMPRESSION,
@@ -85,7 +91,6 @@ static const struct v4l2_ctrl_config compression_ctrl_cfg = {
 	.step = 1,
 	.def = 0,
 };
-#endif
 
 static int set_stream(struct v4l2_subdev *sd, int enable)
 {
@@ -122,35 +127,20 @@ ipu_isys_csi2_be_soc_set_sel(struct v4l2_subdev *sd,
 	    asd->valid_tgts[sel->pad].crop) {
 		enum isys_subdev_prop_tgt tgt =
 		    IPU_ISYS_SUBDEV_PROP_TGT_SOURCE_CROP;
-		struct v4l2_rect *r;
-		unsigned int sink_pad = 0;
-		int i;
-
-		for (i = 0; i < asd->nstreams; i++) {
-			if (!(asd->route[i].flags &
-			      V4L2_SUBDEV_ROUTE_FL_ACTIVE))
-				continue;
-			if (asd->route[i].source == sel->pad) {
-				sink_pad = asd->route[i].sink;
-				break;
-			}
-		}
+		struct v4l2_mbus_framefmt *ffmt =
+			__ipu_isys_get_ffmt(sd, state, sel->pad, sel->which);
 
-		if (i == asd->nstreams) {
-			dev_dbg(&asd->isys->adev->dev, "No sink pad routed.\n");
-			return -EINVAL;
+		if (get_supported_code_index(ffmt->code) < 0) {
+			/* Non-bayer formats can't be odd lines cropped */
+			sel->r.left &= ~1;
+			sel->r.top &= ~1;
 		}
-		r = __ipu_isys_get_selection(sd, state, sel->target,
-					     sink_pad, sel->which);
 
-		/* Cropping is not supported by SoC BE.
-		 * Only horizontal padding is allowed.
-		 */
-		sel->r.top = r->top;
-		sel->r.left = r->left;
-		sel->r.width = clamp(sel->r.width, r->width,
+		sel->r.width = clamp(sel->r.width, IPU_ISYS_MIN_WIDTH,
 				     IPU_ISYS_MAX_WIDTH);
-		sel->r.height = r->height;
+
+		sel->r.height = clamp(sel->r.height, IPU_ISYS_MIN_HEIGHT,
+				      IPU_ISYS_MAX_HEIGHT);
 
 		*__ipu_isys_get_selection(sd, state, sel->target, sel->pad,
 					  sel->which) = sel->r;
@@ -168,8 +158,6 @@ static const struct v4l2_subdev_pad_ops csi2_be_soc_sd_pad_ops = {
 	.get_selection = ipu_isys_subdev_get_sel,
 	.set_selection = ipu_isys_csi2_be_soc_set_sel,
 	.enum_mbus_code = ipu_isys_subdev_enum_mbus_code,
-	.set_routing = ipu_isys_subdev_set_routing,
-	.get_routing = ipu_isys_subdev_get_routing,
 };
 
 static struct v4l2_subdev_ops csi2_be_soc_sd_ops = {
@@ -180,7 +168,6 @@ static struct v4l2_subdev_ops csi2_be_soc_sd_ops = {
 
 static struct media_entity_operations csi2_be_soc_entity_ops = {
 	.link_validate = v4l2_subdev_link_validate,
-	.has_route = ipu_isys_subdev_has_route,
 };
 
 static void csi2_be_soc_set_ffmt(struct v4l2_subdev *sd,
@@ -189,13 +176,8 @@ static void csi2_be_soc_set_ffmt(struct v4l2_subdev *sd,
 {
 	struct v4l2_mbus_framefmt *ffmt =
 		__ipu_isys_get_ffmt(sd, state, fmt->pad,
-				    fmt->stream,
 				    fmt->which);
 
-#ifdef IPU_ISYS_YUV422_I420
-	struct ipu_isys_csi2_be_soc *csi2_be_soc = to_ipu_isys_csi2_be_soc(sd);
-#endif
-
 	if (sd->entity.pads[fmt->pad].flags & MEDIA_PAD_FL_SINK) {
 		if (fmt->format.field != V4L2_FIELD_ALTERNATE)
 			fmt->format.field = V4L2_FIELD_NONE;
@@ -210,40 +192,30 @@ static void csi2_be_soc_set_ffmt(struct v4l2_subdev *sd,
 		struct v4l2_rect *r = __ipu_isys_get_selection(sd, state,
 			V4L2_SEL_TGT_CROP, fmt->pad, fmt->which);
 		struct ipu_isys_subdev *asd = to_ipu_isys_subdev(sd);
-		unsigned int sink_pad = 0;
-		int i;
-
-		for (i = 0; i < asd->nsinks; i++)
-			if (media_entity_has_route(&sd->entity, fmt->pad, i))
-				break;
-		if (i != asd->nsinks)
-			sink_pad = i;
-		sink_ffmt = __ipu_isys_get_ffmt(sd, state, sink_pad,
-						fmt->stream,
-						fmt->which);
-		ffmt->code = sink_ffmt->code;
+		u32 code;
+		int idx;
+
+		sink_ffmt = __ipu_isys_get_ffmt(sd, state, 0, fmt->which);
+		code = sink_ffmt->code;
+		idx = get_supported_code_index(code);
+
+		if (asd->valid_tgts[fmt->pad].crop && idx >= 0) {
+			int crop_info = 0;
+
+			/* Only croping odd line at top side. */
+			if (r->top & 1)
+				crop_info |= CSI2_BE_CROP_VER;
+
+			code = csi2_be_soc_supported_raw_bayer_codes_pad
+				[((idx & CSI2_BE_CROP_MASK) ^ crop_info)
+				+ (idx & ~CSI2_BE_CROP_MASK)];
+
+		}
+		ffmt->code = code;
 		ffmt->width = r->width;
 		ffmt->height = r->height;
 		ffmt->field = sink_ffmt->field;
 
-#ifdef IPU_ISYS_YUV422_I420
-		/*
-		 * For new IPU special case, format changing in BE-SOC,
-		 * from YUV422 to I420, which is used to adapt multiple
-		 * YUV sensors and provide I420 to BB for partial processing.
-		 * Use original source pad format from user space.
-		 * And change pin type to RAW_DUAL_SOC for this special case
-		 */
-		if (fmt->format.code == MEDIA_BUS_FMT_UYVY8_2X8 &&
-		    (sink_ffmt->code == MEDIA_BUS_FMT_YUYV8_1X16 ||
-		     sink_ffmt->code == MEDIA_BUS_FMT_UYVY8_1X16)) {
-			ffmt->code = fmt->format.code;
-
-			for (i = 0; i < NR_OF_CSI2_BE_SOC_SOURCE_PADS; i++)
-				csi2_be_soc->av[i].aq.css_pin_type =
-					IPU_FW_ISYS_PIN_TYPE_RAW_DUAL_SOC;
-		}
-#endif
 	}
 }
 
@@ -254,19 +226,17 @@ void ipu_isys_csi2_be_soc_cleanup(struct ipu_isys_csi2_be_soc *csi2_be_soc)
 	v4l2_device_unregister_subdev(&csi2_be_soc->asd.sd);
 	ipu_isys_subdev_cleanup(&csi2_be_soc->asd);
 	for (i = 0; i < NR_OF_CSI2_BE_SOC_STREAMS; i++) {
-#if defined(IPU_ISYS_COMPRESSION)
 		v4l2_ctrl_handler_free(&csi2_be_soc->av[i].ctrl_handler);
-#endif
 		ipu_isys_video_cleanup(&csi2_be_soc->av[i]);
 	}
 }
 
 int ipu_isys_csi2_be_soc_init(struct ipu_isys_csi2_be_soc *csi2_be_soc,
-			      struct ipu_isys *isys)
+			      struct ipu_isys *isys, int index)
 {
 	struct v4l2_subdev_format fmt = {
 		.which = V4L2_SUBDEV_FORMAT_ACTIVE,
-		.pad = CSI2_BE_SOC_PAD_SINK(0),
+		.pad = CSI2_BE_SOC_PAD_SINK,
 		.format = {
 			   .width = 4096,
 			   .height = 3072,
@@ -280,15 +250,12 @@ int ipu_isys_csi2_be_soc_init(struct ipu_isys_csi2_be_soc *csi2_be_soc,
 	rval = ipu_isys_subdev_init(&csi2_be_soc->asd,
 				    &csi2_be_soc_sd_ops, 0,
 				    NR_OF_CSI2_BE_SOC_PADS,
-				    NR_OF_CSI2_BE_SOC_STREAMS,
 				    NR_OF_CSI2_BE_SOC_SOURCE_PADS,
 				    NR_OF_CSI2_BE_SOC_SINK_PADS, 0);
 	if (rval)
 		goto fail;
 
-	for (i = CSI2_BE_SOC_PAD_SINK(0); i < NR_OF_CSI2_BE_SOC_SINK_PADS; i++)
-		csi2_be_soc->asd.pad[i].flags = MEDIA_PAD_FL_SINK;
-
+	csi2_be_soc->asd.pad[CSI2_BE_SOC_PAD_SINK].flags = MEDIA_PAD_FL_SINK;
 	for (i = CSI2_BE_SOC_PAD_SOURCE(0);
 	     i < NR_OF_CSI2_BE_SOC_SOURCE_PADS + CSI2_BE_SOC_PAD_SOURCE(0);
 	     i++) {
@@ -304,17 +271,12 @@ int ipu_isys_csi2_be_soc_init(struct ipu_isys_csi2_be_soc *csi2_be_soc,
 	csi2_be_soc->asd.isl_mode = IPU_ISL_OFF;
 	csi2_be_soc->asd.set_ffmt = csi2_be_soc_set_ffmt;
 
-	for (i = CSI2_BE_SOC_PAD_SINK(0); i < NR_OF_CSI2_BE_SOC_SINK_PADS;
-	     i++) {
-		fmt.pad = CSI2_BE_SOC_PAD_SINK(i);
-		ipu_isys_subdev_set_ffmt(&csi2_be_soc->asd.sd, NULL, &fmt);
-	}
-
+	fmt.pad = CSI2_BE_SOC_PAD_SINK;
 	ipu_isys_subdev_set_ffmt(&csi2_be_soc->asd.sd, NULL, &fmt);
 	csi2_be_soc->asd.sd.internal_ops = &csi2_be_soc_sd_internal_ops;
 
 	snprintf(csi2_be_soc->asd.sd.name, sizeof(csi2_be_soc->asd.sd.name),
-		 IPU_ISYS_ENTITY_PREFIX " CSI2 BE SOC");
+		 IPU_ISYS_ENTITY_PREFIX " CSI2 BE SOC %d", index);
 	v4l2_set_subdevdata(&csi2_be_soc->asd.sd, &csi2_be_soc->asd);
 
 	rval = v4l2_device_register_subdev(&isys->v4l2_dev,
@@ -324,34 +286,15 @@ int ipu_isys_csi2_be_soc_init(struct ipu_isys_csi2_be_soc *csi2_be_soc,
 		goto fail;
 	}
 
-	mutex_lock(&csi2_be_soc->asd.mutex);
-	/* create default route information */
-	for (i = 0; i < NR_OF_CSI2_BE_SOC_STREAMS; i++) {
-		csi2_be_soc->asd.route[i].sink = CSI2_BE_SOC_PAD_SINK(i);
-		csi2_be_soc->asd.route[i].source = CSI2_BE_SOC_PAD_SOURCE(i);
-		csi2_be_soc->asd.route[i].flags = 0;
-	}
-
-	for (i = 0; i < NR_OF_CSI2_BE_SOC_SOURCE_PADS; i++) {
-		csi2_be_soc->asd.stream[CSI2_BE_SOC_PAD_SINK(i)].stream_id[0]
-		    = 0;
-		csi2_be_soc->asd.stream[CSI2_BE_SOC_PAD_SOURCE(i)].stream_id[0]
-		    = 0;
-	}
-	for (i = 0; i < NR_OF_CSI2_BE_SOC_STREAMS; i++) {
-		csi2_be_soc->asd.route[i].flags = V4L2_SUBDEV_ROUTE_FL_ACTIVE;
-		bitmap_set(csi2_be_soc->asd.stream[CSI2_BE_SOC_PAD_SINK(i)].
-			   streams_stat, 0, 1);
-		bitmap_set(csi2_be_soc->asd.stream[CSI2_BE_SOC_PAD_SOURCE(i)].
-			   streams_stat, 0, 1);
-	}
-	csi2_be_soc->asd.route[0].flags |= V4L2_SUBDEV_ROUTE_FL_IMMUTABLE;
-	mutex_unlock(&csi2_be_soc->asd.mutex);
-
 	for (i = 0; i < NR_OF_CSI2_BE_SOC_SOURCE_PADS; i++) {
-		snprintf(csi2_be_soc->av[i].vdev.name,
-			 sizeof(csi2_be_soc->av[i].vdev.name),
-			 IPU_ISYS_ENTITY_PREFIX " BE SOC capture %d", i);
+		if (!index)
+			snprintf(csi2_be_soc->av[i].vdev.name,
+				 sizeof(csi2_be_soc->av[i].vdev.name),
+				 IPU_ISYS_ENTITY_PREFIX " BE SOC capture %d", i);
+		else
+			snprintf(csi2_be_soc->av[i].vdev.name,
+				 sizeof(csi2_be_soc->av[i].vdev.name),
+				 IPU_ISYS_ENTITY_PREFIX " BE SOC %d capture %d", index, i);
 		/*
 		 * Pin type could be overwritten for YUV422 to I420 case, at
 		 * set_format phase
@@ -373,7 +316,6 @@ int ipu_isys_csi2_be_soc_init(struct ipu_isys_csi2_be_soc *csi2_be_soc,
 		csi2_be_soc->av[i].aq.vbq.buf_struct_size =
 		    sizeof(struct ipu_isys_video_buffer);
 
-#if defined(IPU_ISYS_COMPRESSION)
 		/* create v4l2 ctrl for be-soc video node */
 		rval =
 		  v4l2_ctrl_handler_init(&csi2_be_soc->av[i].ctrl_handler, 0);
@@ -394,7 +336,6 @@ int ipu_isys_csi2_be_soc_init(struct ipu_isys_csi2_be_soc *csi2_be_soc,
 		csi2_be_soc->av[i].compression = 0;
 		csi2_be_soc->av[i].vdev.ctrl_handler =
 			&csi2_be_soc->av[i].ctrl_handler;
-#endif
 
 		rval = ipu_isys_video_init(&csi2_be_soc->av[i],
 					   &csi2_be_soc->asd.sd.entity,
diff --git a/drivers/media/pci/intel/ipu-isys-csi2-be.c b/drivers/media/pci/intel/ipu-isys-csi2-be.c
index 07a2a55bec89..61a22e416d07 100644
--- a/drivers/media/pci/intel/ipu-isys-csi2-be.c
+++ b/drivers/media/pci/intel/ipu-isys-csi2-be.c
@@ -48,7 +48,6 @@ static struct v4l2_subdev_internal_ops csi2_be_sd_internal_ops = {
 static const struct v4l2_subdev_core_ops csi2_be_sd_core_ops = {
 };
 
-#if defined(IPU_ISYS_COMPRESSION)
 static const struct v4l2_ctrl_config compression_ctrl_cfg = {
 	.ops = NULL,
 	.id = V4L2_CID_IPU_ISYS_COMPRESSION,
@@ -59,7 +58,6 @@ static const struct v4l2_ctrl_config compression_ctrl_cfg = {
 	.step = 1,
 	.def = 0,
 };
-#endif
 
 static int set_stream(struct v4l2_subdev *sd, int enable)
 {
@@ -105,7 +103,7 @@ static int ipu_isys_csi2_be_set_sel(struct v4l2_subdev *sd,
 	    pad->flags & MEDIA_PAD_FL_SOURCE &&
 	    asd->valid_tgts[CSI2_BE_PAD_SOURCE].crop) {
 		struct v4l2_mbus_framefmt *ffmt =
-			__ipu_isys_get_ffmt(sd, state, sel->pad, 0, sel->which);
+			__ipu_isys_get_ffmt(sd, state, sel->pad, sel->which);
 		struct v4l2_rect *r = __ipu_isys_get_selection
 		    (sd, state, sel->target, CSI2_BE_PAD_SINK, sel->which);
 
@@ -165,8 +163,7 @@ static void csi2_be_set_ffmt(struct v4l2_subdev *sd,
 {
 	struct ipu_isys_csi2 *csi2 = to_ipu_isys_csi2(sd);
 	struct v4l2_mbus_framefmt *ffmt =
-		__ipu_isys_get_ffmt(sd, state, fmt->pad, fmt->stream,
-				    fmt->which);
+		__ipu_isys_get_ffmt(sd, state, fmt->pad, fmt->which);
 
 	switch (fmt->pad) {
 	case CSI2_BE_PAD_SINK:
@@ -181,7 +178,7 @@ static void csi2_be_set_ffmt(struct v4l2_subdev *sd,
 	case CSI2_BE_PAD_SOURCE: {
 		struct v4l2_mbus_framefmt *sink_ffmt =
 			__ipu_isys_get_ffmt(sd, state, CSI2_BE_PAD_SINK,
-					    fmt->stream, fmt->which);
+					    fmt->which);
 		struct v4l2_rect *r =
 			__ipu_isys_get_selection(sd, state, V4L2_SEL_TGT_CROP,
 						 CSI2_BE_PAD_SOURCE,
@@ -215,9 +212,7 @@ static void csi2_be_set_ffmt(struct v4l2_subdev *sd,
 
 void ipu_isys_csi2_be_cleanup(struct ipu_isys_csi2_be *csi2_be)
 {
-#if defined(IPU_ISYS_COMPRESSION)
 	v4l2_ctrl_handler_free(&csi2_be->av.ctrl_handler);
-#endif
 	v4l2_device_unregister_subdev(&csi2_be->asd.sd);
 	ipu_isys_subdev_cleanup(&csi2_be->asd);
 	ipu_isys_video_cleanup(&csi2_be->av);
@@ -250,7 +245,6 @@ int ipu_isys_csi2_be_init(struct ipu_isys_csi2_be *csi2_be,
 
 	rval = ipu_isys_subdev_init(&csi2_be->asd, &csi2_be_sd_ops, 0,
 				    NR_OF_CSI2_BE_PADS,
-				    NR_OF_CSI2_BE_STREAMS,
 				    NR_OF_CSI2_BE_SOURCE_PADS,
 				    NR_OF_CSI2_BE_SINK_PADS, 0);
 	if (rval)
@@ -296,7 +290,6 @@ int ipu_isys_csi2_be_init(struct ipu_isys_csi2_be *csi2_be,
 	csi2_be->av.aq.vbq.buf_struct_size =
 	    sizeof(struct ipu_isys_video_buffer);
 
-#if defined(IPU_ISYS_COMPRESSION)
 	/* create v4l2 ctrl for csi-be video node */
 	rval = v4l2_ctrl_handler_init(&csi2_be->av.ctrl_handler, 0);
 	if (rval) {
@@ -315,7 +308,6 @@ int ipu_isys_csi2_be_init(struct ipu_isys_csi2_be *csi2_be,
 	}
 	csi2_be->av.compression = 0;
 	csi2_be->av.vdev.ctrl_handler = &csi2_be->av.ctrl_handler;
-#endif
 
 	rval = ipu_isys_video_init(&csi2_be->av, &csi2_be->asd.sd.entity,
 				   CSI2_BE_PAD_SOURCE, MEDIA_PAD_FL_SINK, 0);
diff --git a/drivers/media/pci/intel/ipu-isys-csi2-be.h b/drivers/media/pci/intel/ipu-isys-csi2-be.h
index bf2217519681..4c74db05431d 100644
--- a/drivers/media/pci/intel/ipu-isys-csi2-be.h
+++ b/drivers/media/pci/intel/ipu-isys-csi2-be.h
@@ -1,5 +1,5 @@
 /* SPDX-License-Identifier: GPL-2.0 */
-/* Copyright (C) 2014 - 2020 Intel Corporation */
+/* Copyright (C) 2014 - 2022 Intel Corporation */
 
 #ifndef IPU_ISYS_CSI2_BE_H
 #define IPU_ISYS_CSI2_BE_H
@@ -22,17 +22,14 @@ struct ipu_isys;
 #define NR_OF_CSI2_BE_SOURCE_PADS	1
 #define NR_OF_CSI2_BE_SINK_PADS		1
 
-#define NR_OF_CSI2_BE_STREAMS	1
+#define INVALIA_VC_ID -1
 #define NR_OF_CSI2_BE_SOC_SOURCE_PADS	NR_OF_CSI2_BE_SOC_STREAMS
-#define NR_OF_CSI2_BE_SOC_SINK_PADS	NR_OF_CSI2_BE_SOC_STREAMS
-#define CSI2_BE_SOC_PAD_SINK(n)		\
-	({ typeof(n) __n = (n);	\
-	   (__n) >= NR_OF_CSI2_BE_SOC_SINK_PADS ?	\
-	   (NR_OF_CSI2_BE_SOC_SINK_PADS) : (__n); })
+#define NR_OF_CSI2_BE_SOC_SINK_PADS	1
+#define CSI2_BE_SOC_PAD_SINK 0
 #define CSI2_BE_SOC_PAD_SOURCE(n)	\
 	({ typeof(n) __n = (n);  \
 	   (__n) >= NR_OF_CSI2_BE_SOC_SOURCE_PADS ? \
-		(NR_OF_CSI2_BE_SOC_PADS - 1) : \
+		(NR_OF_CSI2_BE_SOC_SOURCE_PADS - 1) : \
 		((__n) + NR_OF_CSI2_BE_SOC_SINK_PADS); })
 #define NR_OF_CSI2_BE_SOC_PADS \
 	(NR_OF_CSI2_BE_SOC_SOURCE_PADS + NR_OF_CSI2_BE_SOC_SINK_PADS)
@@ -68,7 +65,7 @@ int ipu_isys_csi2_be_init(struct ipu_isys_csi2_be *csi2_be,
 			  struct ipu_isys *isys);
 void ipu_isys_csi2_be_cleanup(struct ipu_isys_csi2_be *csi2_be);
 int ipu_isys_csi2_be_soc_init(struct ipu_isys_csi2_be_soc *csi2_be_soc,
-			      struct ipu_isys *isys);
+			      struct ipu_isys *isys, int index);
 void ipu_isys_csi2_be_soc_cleanup(struct ipu_isys_csi2_be_soc *csi2_be);
 
 #endif /* IPU_ISYS_CSI2_BE_H */
diff --git a/drivers/media/pci/intel/ipu-isys-csi2.c b/drivers/media/pci/intel/ipu-isys-csi2.c
index 4fd03475743b..b4a9be0dcb90 100644
--- a/drivers/media/pci/intel/ipu-isys-csi2.c
+++ b/drivers/media/pci/intel/ipu-isys-csi2.c
@@ -1,5 +1,5 @@
 // SPDX-License-Identifier: GPL-2.0
-// Copyright (C) 2013 - 2021 Intel Corporation
+// Copyright (C) 2013 - 2022 Intel Corporation
 
 #include <linux/device.h>
 #include <linux/module.h>
@@ -17,12 +17,6 @@
 #include "ipu-isys-subdev.h"
 #include "ipu-isys-video.h"
 #include "ipu-platform-regs.h"
-#ifdef IPU_TRACE_EVENT
-#define CREATE_TRACE_POINTS
-#define IPU_SOF_SEQID_TRACE
-#define IPU_EOF_SEQID_TRACE
-#include "ipu-trace-event.h"
-#endif
 
 static const u32 csi2_supported_codes_pad_sink[] = {
 	MEDIA_BUS_FMT_Y10_1X10,
@@ -72,11 +66,6 @@ static const u32 csi2_supported_codes_pad_source[] = {
 	0,
 };
 
-static const u32 csi2_supported_codes_pad_meta[] = {
-	MEDIA_BUS_FMT_FIXED,
-	0,
-};
-
 static const u32 *csi2_supported_codes[NR_OF_CSI2_PADS];
 
 static struct v4l2_subdev_internal_ops csi2_sd_internal_ops = {
@@ -84,117 +73,37 @@ static struct v4l2_subdev_internal_ops csi2_sd_internal_ops = {
 	.close = ipu_isys_subdev_close,
 };
 
-int ipu_isys_csi2_get_link_freq(struct ipu_isys_csi2 *csi2, __s64 *link_freq)
+int ipu_isys_csi2_get_link_freq(struct ipu_isys_csi2 *csi2, s64 *link_freq)
 {
 	struct ipu_isys_pipeline *pipe = container_of(csi2->asd.sd.entity.pipe,
 						      struct ipu_isys_pipeline,
 						      pipe);
 	struct v4l2_subdev *ext_sd =
-	    media_entity_to_v4l2_subdev(pipe->external->entity);
-	struct v4l2_ext_control c = {.id = V4L2_CID_LINK_FREQ, };
-	struct v4l2_ext_controls cs = {.count = 1,
-		.controls = &c,
-	};
-	struct v4l2_querymenu qm = {.id = c.id, };
-	int rval;
+		media_entity_to_v4l2_subdev(pipe->external->entity);
+	struct device *dev = &csi2->isys->adev->dev;
+	unsigned int bpp, lanes;
+	s64 ret;
 
 	if (!ext_sd) {
 		WARN_ON(1);
 		return -ENODEV;
 	}
-	rval = v4l2_g_ext_ctrls(ext_sd->ctrl_handler,
-				ext_sd->devnode,
-				ext_sd->v4l2_dev->mdev,
-				&cs);
-	if (rval) {
-		dev_info(&csi2->isys->adev->dev, "can't get link frequency\n");
-		return rval;
-	}
 
-	qm.index = c.value;
+	bpp = ipu_isys_mbus_code_to_bpp(csi2->asd.ffmt->code);
+	lanes = csi2->nlanes;
 
-	rval = v4l2_querymenu(ext_sd->ctrl_handler, &qm);
-	if (rval) {
-		dev_info(&csi2->isys->adev->dev, "can't get menu item\n");
-		return rval;
+	ret = v4l2_get_link_freq(ext_sd->ctrl_handler, bpp, lanes * 2);
+	if (ret < 0) {
+		dev_err(dev, "can't get link frequency (%lld)\n", ret);
+		return ret;
 	}
 
-	dev_dbg(&csi2->isys->adev->dev, "%s: link frequency %lld\n", __func__,
-		qm.value);
+	dev_dbg(dev, "link freq of %s is %lld\n", ext_sd->name, ret);
+	*link_freq = ret;
 
-	if (!qm.value)
-		return -EINVAL;
-	*link_freq = qm.value;
 	return 0;
 }
 
-static int ipu_get_frame_desc_entry_by_dt(struct v4l2_subdev *sd,
-					  struct v4l2_mbus_frame_desc_entry
-					  *entry, u8 data_type)
-{
-	struct v4l2_mbus_frame_desc desc = {
-		.num_entries = V4L2_FRAME_DESC_ENTRY_MAX,
-	};
-	int rval, i;
-
-	rval = v4l2_subdev_call(sd, pad, get_frame_desc, 0, &desc);
-	if (rval)
-		return rval;
-
-	for (i = 0; i < desc.num_entries; i++) {
-		if (desc.entry[i].bus.csi2.data_type != data_type)
-			continue;
-		*entry = desc.entry[i];
-		return 0;
-	}
-
-	return -EINVAL;
-}
-
-static void csi2_meta_prepare_firmware_stream_cfg_default(
-			struct ipu_isys_video *av,
-			struct ipu_fw_isys_stream_cfg_data_abi *cfg)
-{
-	struct ipu_isys_pipeline *ip =
-	    to_ipu_isys_pipeline(av->vdev.entity.pipe);
-	struct ipu_isys_queue *aq = &av->aq;
-	struct ipu_fw_isys_output_pin_info_abi *pin_info;
-	struct v4l2_mbus_frame_desc_entry entry;
-	int pin = cfg->nof_output_pins++;
-	int inpin = cfg->nof_input_pins++;
-	int rval;
-
-	aq->fw_output = pin;
-	ip->output_pins[pin].pin_ready = ipu_isys_queue_buf_ready;
-	ip->output_pins[pin].aq = aq;
-
-	pin_info = &cfg->output_pins[pin];
-	pin_info->input_pin_id = inpin;
-	pin_info->output_res.width = av->mpix.width;
-	pin_info->output_res.height = av->mpix.height;
-	pin_info->stride = av->mpix.plane_fmt[0].bytesperline;
-	pin_info->pt = aq->css_pin_type;
-	pin_info->ft = av->pfmt->css_pixelformat;
-	pin_info->send_irq = 1;
-
-	memset(pin_info->ts_offsets, 0, sizeof(pin_info->ts_offsets));
-	pin_info->s2m_pixel_soc_pixel_remapping =
-	    S2M_PIXEL_SOC_PIXEL_REMAPPING_FLAG_NO_REMAPPING;
-	pin_info->csi_be_soc_pixel_remapping =
-	    CSI_BE_SOC_PIXEL_REMAPPING_FLAG_NO_REMAPPING;
-	rval =
-	    ipu_get_frame_desc_entry_by_dt(media_entity_to_v4l2_subdev
-					   (ip->external->entity), &entry,
-					   IPU_ISYS_MIPI_CSI2_TYPE_EMBEDDED8);
-	if (!rval) {
-		cfg->input_pins[inpin].dt = IPU_ISYS_MIPI_CSI2_TYPE_EMBEDDED8;
-		cfg->input_pins[inpin].input_res.width =
-		    entry.two_dim.width * entry.bpp / BITS_PER_BYTE;
-		cfg->input_pins[inpin].input_res.height =
-		    entry.two_dim.height;
-	}
-}
-
 static int subscribe_event(struct v4l2_subdev *sd, struct v4l2_fh *fh,
 			   struct v4l2_event_subscription *sub)
 {
@@ -218,11 +127,6 @@ static const struct v4l2_subdev_core_ops csi2_sd_core_ops = {
 	.unsubscribe_event = v4l2_event_subdev_unsubscribe,
 };
 
-static struct ipu_isys_pixelformat csi2_meta_pfmts[] = {
-	{V4L2_FMT_IPU_ISYS_META, 8, 8, 0, MEDIA_BUS_FMT_FIXED, 0},
-	{},
-};
-
 /*
  * The input system CSI2+ receiver has several
  * parameters affecting the receiver timings. These depend
@@ -304,9 +208,6 @@ static int set_stream(struct v4l2_subdev *sd, int enable)
 						    pipe);
 	struct ipu_isys_csi2_config *cfg;
 	struct v4l2_subdev *ext_sd;
-#ifdef V4L2_CID_MIPI_LANES
-	struct v4l2_control c = {.id = V4L2_CID_MIPI_LANES, };
-#endif
 	struct ipu_isys_csi2_timing timing = {0};
 	unsigned int nlanes;
 	int rval;
@@ -336,15 +237,7 @@ static int set_stream(struct v4l2_subdev *sd, int enable)
 		return 0;
 	}
 
-#ifdef V4L2_CID_MIPI_LANES
-	rval = v4l2_g_ctrl(ext_sd->ctrl_handler, &c);
-	if (!rval && c.value > 0 && cfg->nlanes > c.value)
-		nlanes = c.value;
-	else
-		nlanes = cfg->nlanes;
-#else
 	nlanes = cfg->nlanes;
-#endif
 
 	dev_dbg(&csi2->isys->adev->dev, "lane nr %d.\n", nlanes);
 
@@ -380,13 +273,6 @@ static int csi2_link_validate(struct media_link *link)
 {
 	struct ipu_isys_csi2 *csi2;
 	struct ipu_isys_pipeline *ip;
-	struct v4l2_subdev_route r[IPU_ISYS_MAX_STREAMS];
-	struct v4l2_subdev_routing routing = {
-		.routes = r,
-		.num_routes = IPU_ISYS_MAX_STREAMS,
-	};
-	unsigned int active = 0;
-	int i;
 	int rval;
 
 	if (!link->sink->entity ||
@@ -406,88 +292,28 @@ static int csi2_link_validate(struct media_link *link)
 		return rval;
 
 	if (!v4l2_ctrl_g_ctrl(csi2->store_csi2_header)) {
-		for (i = 0; i < NR_OF_CSI2_SOURCE_PADS; i++) {
-			struct media_pad *remote_pad =
-			    media_entity_remote_pad(&csi2->asd.
-						    pad[CSI2_PAD_SOURCE(i)]);
-
-			if (remote_pad &&
-			    is_media_entity_v4l2_subdev(remote_pad->entity)) {
-				dev_err(&csi2->isys->adev->dev,
-					"CSI2 BE requires CSI2 headers.\n");
-				return -EINVAL;
-			}
-		}
-	}
-
-	rval =
-	    v4l2_subdev_call(media_entity_to_v4l2_subdev(link->source->entity),
-			     pad, get_routing, &routing);
-
-	if (rval) {
-		csi2->remote_streams = 1;
-		return 0;
-	}
+		struct media_pad *remote_pad =
+		    media_entity_remote_pad(&csi2->asd.pad[CSI2_PAD_SOURCE]);
 
-	for (i = 0; i < routing.num_routes; i++) {
-		if (routing.routes[i].flags & V4L2_SUBDEV_ROUTE_FL_ACTIVE)
-			active++;
+		if (remote_pad &&
+		    is_media_entity_v4l2_subdev(remote_pad->entity)) {
+			dev_err(&csi2->isys->adev->dev,
+				"CSI2 BE requires CSI2 headers.\n");
+			return -EINVAL;
+		}
 	}
 
-	if (active !=
-	    bitmap_weight(csi2->asd.stream[link->sink->index].streams_stat, 32))
-		return -EINVAL;
-
-	csi2->remote_streams = active;
-
 	return 0;
 }
 
-static bool csi2_has_route(struct media_entity *entity, unsigned int pad0,
-			   unsigned int pad1, int *stream)
-{
-	if (pad0 == CSI2_PAD_META || pad1 == CSI2_PAD_META)
-		return true;
-	return ipu_isys_subdev_has_route(entity, pad0, pad1, stream);
-}
-
 static const struct v4l2_subdev_video_ops csi2_sd_video_ops = {
 	.s_stream = set_stream,
 };
 
-static int get_metadata_fmt(struct v4l2_subdev *sd,
-			    struct v4l2_subdev_state *state,
-			    struct v4l2_subdev_format *fmt)
-{
-	struct media_pad *pad =
-	    media_entity_remote_pad(&sd->entity.pads[CSI2_PAD_SINK]);
-	struct v4l2_mbus_frame_desc_entry entry;
-	int rval;
-
-	if (!pad)
-		return -EINVAL;
-
-	rval =
-	    ipu_get_frame_desc_entry_by_dt(media_entity_to_v4l2_subdev
-					   (pad->entity), &entry,
-					   IPU_ISYS_MIPI_CSI2_TYPE_EMBEDDED8);
-
-	if (!rval) {
-		fmt->format.width =
-		    entry.two_dim.width * entry.bpp / BITS_PER_BYTE;
-		fmt->format.height = entry.two_dim.height;
-		fmt->format.code = entry.pixelcode;
-		fmt->format.field = V4L2_FIELD_NONE;
-	}
-	return rval;
-}
-
 static int ipu_isys_csi2_get_fmt(struct v4l2_subdev *sd,
 				 struct v4l2_subdev_state *state,
 				 struct v4l2_subdev_format *fmt)
 {
-	if (fmt->pad == CSI2_PAD_META)
-		return get_metadata_fmt(sd, state, fmt);
 	return ipu_isys_subdev_get_ffmt(sd, state, fmt);
 }
 
@@ -495,8 +321,6 @@ static int ipu_isys_csi2_set_fmt(struct v4l2_subdev *sd,
 				 struct v4l2_subdev_state *state,
 				 struct v4l2_subdev_format *fmt)
 {
-	if (fmt->pad == CSI2_PAD_META)
-		return get_metadata_fmt(sd, state, fmt);
 	return ipu_isys_subdev_set_ffmt(sd, state, fmt);
 }
 
@@ -520,8 +344,6 @@ static const struct v4l2_subdev_pad_ops csi2_sd_pad_ops = {
 	.get_fmt = ipu_isys_csi2_get_fmt,
 	.set_fmt = ipu_isys_csi2_set_fmt,
 	.enum_mbus_code = ipu_isys_subdev_enum_mbus_code,
-	.set_routing = ipu_isys_subdev_set_routing,
-	.get_routing = ipu_isys_subdev_get_routing,
 };
 
 static struct v4l2_subdev_ops csi2_sd_ops = {
@@ -532,7 +354,6 @@ static struct v4l2_subdev_ops csi2_sd_ops = {
 
 static struct media_entity_operations csi2_entity_ops = {
 	.link_validate = csi2_link_validate,
-	.has_route = csi2_has_route,
 };
 
 static void csi2_set_ffmt(struct v4l2_subdev *sd,
@@ -542,7 +363,6 @@ static void csi2_set_ffmt(struct v4l2_subdev *sd,
 	enum isys_subdev_prop_tgt tgt = IPU_ISYS_SUBDEV_PROP_TGT_SINK_FMT;
 	struct v4l2_mbus_framefmt *ffmt =
 		__ipu_isys_get_ffmt(sd, state, fmt->pad,
-				    fmt->stream,
 				    fmt->which);
 
 	if (fmt->format.field != V4L2_FIELD_ALTERNATE)
@@ -550,45 +370,11 @@ static void csi2_set_ffmt(struct v4l2_subdev *sd,
 
 	if (fmt->pad == CSI2_PAD_SINK) {
 		*ffmt = fmt->format;
-		if (fmt->stream)
-			return;
 		ipu_isys_subdev_fmt_propagate(sd, state, &fmt->format, NULL,
 					      tgt, fmt->pad, fmt->which);
 		return;
 	}
 
-	if (fmt->pad == CSI2_PAD_META) {
-		struct v4l2_mbus_framefmt *ffmt =
-			__ipu_isys_get_ffmt(sd, state, fmt->pad,
-					    fmt->stream,
-					    fmt->which);
-		struct media_pad *pad = media_entity_remote_pad(
-			&sd->entity.pads[CSI2_PAD_SINK]);
-		struct v4l2_mbus_frame_desc_entry entry;
-		int rval;
-
-		if (!pad) {
-			ffmt->width = 0;
-			ffmt->height = 0;
-			ffmt->code = 0;
-			return;
-		}
-
-		rval = ipu_get_frame_desc_entry_by_dt(
-				media_entity_to_v4l2_subdev(pad->entity),
-				&entry,
-				IPU_ISYS_MIPI_CSI2_TYPE_EMBEDDED8);
-
-		if (!rval) {
-			ffmt->width = entry.two_dim.width * entry.bpp
-			    / BITS_PER_BYTE;
-			ffmt->height = entry.two_dim.height;
-			ffmt->code = entry.pixelcode;
-			ffmt->field = V4L2_FIELD_NONE;
-		}
-
-		return;
-	}
 	if (sd->entity.pads[fmt->pad].flags & MEDIA_PAD_FL_SOURCE) {
 		ffmt->width = fmt->format.width;
 		ffmt->height = fmt->format.height;
@@ -622,16 +408,12 @@ csi2_try_fmt(struct ipu_isys_video *av,
 
 void ipu_isys_csi2_cleanup(struct ipu_isys_csi2 *csi2)
 {
-	int i;
-
 	if (!csi2->isys)
 		return;
 
 	v4l2_device_unregister_subdev(&csi2->asd.sd);
 	ipu_isys_subdev_cleanup(&csi2->asd);
-	for (i = 0; i < NR_OF_CSI2_SOURCE_PADS; i++)
-		ipu_isys_video_cleanup(&csi2->av[i]);
-	ipu_isys_video_cleanup(&csi2->av_meta);
+	ipu_isys_video_cleanup(&csi2->av);
 	csi2->isys = NULL;
 }
 
@@ -665,10 +447,6 @@ int ipu_isys_csi2_init(struct ipu_isys_csi2 *csi2,
 			   .height = 3072,
 			  },
 	};
-	struct v4l2_subdev_format fmt_meta = {
-		.which = V4L2_SUBDEV_FORMAT_ACTIVE,
-		.pad = CSI2_PAD_META,
-	};
 	int i, rval, src;
 
 	dev_dbg(&isys->adev->dev, "csi-%d base = 0x%lx\n", index,
@@ -681,32 +459,25 @@ int ipu_isys_csi2_init(struct ipu_isys_csi2 *csi2,
 	csi2->asd.ctrl_init = csi_ctrl_init;
 	csi2->asd.isys = isys;
 	init_completion(&csi2->eof_completion);
-	csi2->remote_streams = 1;
 	csi2->stream_count = 0;
-
 	rval = ipu_isys_subdev_init(&csi2->asd, &csi2_sd_ops, 0,
 				    NR_OF_CSI2_PADS,
-				    NR_OF_CSI2_STREAMS,
 				    NR_OF_CSI2_SOURCE_PADS,
 				    NR_OF_CSI2_SINK_PADS,
-				    V4L2_SUBDEV_FL_HAS_SUBSTREAMS);
+				    0);
 	if (rval)
 		goto fail;
 
 	csi2->asd.pad[CSI2_PAD_SINK].flags = MEDIA_PAD_FL_SINK
-	    | MEDIA_PAD_FL_MUST_CONNECT | MEDIA_PAD_FL_MULTIPLEX;
-	for (i = CSI2_PAD_SOURCE(0);
-	     i < (NR_OF_CSI2_SOURCE_PADS + CSI2_PAD_SOURCE(0)); i++)
-		csi2->asd.pad[i].flags = MEDIA_PAD_FL_SOURCE;
+		| MEDIA_PAD_FL_MUST_CONNECT;
+	csi2->asd.pad[CSI2_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
 
-	csi2->asd.pad[CSI2_PAD_META].flags = MEDIA_PAD_FL_SOURCE;
 	src = index;
 	csi2->asd.source = IPU_FW_ISYS_STREAM_SRC_CSI2_PORT0 + src;
 	csi2_supported_codes[CSI2_PAD_SINK] = csi2_supported_codes_pad_sink;
 
 	for (i = 0; i < NR_OF_CSI2_SOURCE_PADS; i++)
 		csi2_supported_codes[i + 1] = csi2_supported_codes_pad_source;
-	csi2_supported_codes[CSI2_PAD_META] = csi2_supported_codes_pad_meta;
 	csi2->asd.supported_codes = csi2_supported_codes;
 	csi2->asd.set_ffmt = csi2_set_ffmt;
 
@@ -724,84 +495,38 @@ int ipu_isys_csi2_init(struct ipu_isys_csi2 *csi2,
 
 	mutex_lock(&csi2->asd.mutex);
 	__ipu_isys_subdev_set_ffmt(&csi2->asd.sd, NULL, &fmt);
-	__ipu_isys_subdev_set_ffmt(&csi2->asd.sd, NULL, &fmt_meta);
-	/* create default route information */
-	for (i = 0; i < NR_OF_CSI2_STREAMS; i++) {
-		csi2->asd.route[i].sink = CSI2_PAD_SINK;
-		csi2->asd.route[i].source = CSI2_PAD_SOURCE(i);
-		csi2->asd.route[i].flags = 0;
-	}
-
-	for (i = 0; i < NR_OF_CSI2_SOURCE_PADS; i++) {
-		csi2->asd.stream[CSI2_PAD_SINK].stream_id[i] = i;
-		csi2->asd.stream[CSI2_PAD_SOURCE(i)].stream_id[CSI2_PAD_SINK]
-		    = i;
-	}
-	csi2->asd.route[0].flags = V4L2_SUBDEV_ROUTE_FL_ACTIVE |
-	    V4L2_SUBDEV_ROUTE_FL_IMMUTABLE;
-	bitmap_set(csi2->asd.stream[CSI2_PAD_SINK].streams_stat, 0, 1);
-	bitmap_set(csi2->asd.stream[CSI2_PAD_SOURCE(0)].streams_stat, 0, 1);
-
 	mutex_unlock(&csi2->asd.mutex);
 
-	for (i = 0; i < NR_OF_CSI2_SOURCE_PADS; i++) {
-		snprintf(csi2->av[i].vdev.name, sizeof(csi2->av[i].vdev.name),
-			 IPU_ISYS_ENTITY_PREFIX " CSI-2 %u capture %d",
-			 index, i);
-		csi2->av[i].isys = isys;
-		csi2->av[i].aq.css_pin_type = IPU_FW_ISYS_PIN_TYPE_MIPI;
-		csi2->av[i].pfmts = ipu_isys_pfmts_packed;
-		csi2->av[i].try_fmt_vid_mplane = csi2_try_fmt;
-		csi2->av[i].prepare_fw_stream =
-		    ipu_isys_prepare_fw_cfg_default;
-		csi2->av[i].packed = true;
-		csi2->av[i].line_header_length =
-		    IPU_ISYS_CSI2_LONG_PACKET_HEADER_SIZE;
-		csi2->av[i].line_footer_length =
-		    IPU_ISYS_CSI2_LONG_PACKET_FOOTER_SIZE;
-		csi2->av[i].aq.buf_prepare = ipu_isys_buf_prepare;
-		csi2->av[i].aq.fill_frame_buff_set_pin =
-		    ipu_isys_buffer_to_fw_frame_buff_pin;
-		csi2->av[i].aq.link_fmt_validate = ipu_isys_link_fmt_validate;
-		csi2->av[i].aq.vbq.buf_struct_size =
-		    sizeof(struct ipu_isys_video_buffer);
-
-		rval = ipu_isys_video_init(&csi2->av[i],
-					   &csi2->asd.sd.entity,
-					   CSI2_PAD_SOURCE(i),
-					   MEDIA_PAD_FL_SINK, 0);
-		if (rval) {
-			dev_info(&isys->adev->dev, "can't init video node\n");
-			goto fail;
-		}
-	}
-
-	snprintf(csi2->av_meta.vdev.name, sizeof(csi2->av_meta.vdev.name),
-		 IPU_ISYS_ENTITY_PREFIX " CSI-2 %u meta", index);
-	csi2->av_meta.isys = isys;
-	csi2->av_meta.aq.css_pin_type = IPU_FW_ISYS_PIN_TYPE_MIPI;
-	csi2->av_meta.pfmts = csi2_meta_pfmts;
-	csi2->av_meta.try_fmt_vid_mplane = csi2_try_fmt;
-	csi2->av_meta.prepare_fw_stream =
-	    csi2_meta_prepare_firmware_stream_cfg_default;
-	csi2->av_meta.packed = true;
-	csi2->av_meta.line_header_length =
-	    IPU_ISYS_CSI2_LONG_PACKET_HEADER_SIZE;
-	csi2->av_meta.line_footer_length =
-	    IPU_ISYS_CSI2_LONG_PACKET_FOOTER_SIZE;
-	csi2->av_meta.aq.buf_prepare = ipu_isys_buf_prepare;
-	csi2->av_meta.aq.fill_frame_buff_set_pin =
-	    ipu_isys_buffer_to_fw_frame_buff_pin;
-	csi2->av_meta.aq.link_fmt_validate = ipu_isys_link_fmt_validate;
-	csi2->av_meta.aq.vbq.buf_struct_size =
-	    sizeof(struct ipu_isys_video_buffer);
-
-	rval = ipu_isys_video_init(&csi2->av_meta, &csi2->asd.sd.entity,
-				   CSI2_PAD_META, MEDIA_PAD_FL_SINK, 0);
+	snprintf(csi2->av.vdev.name, sizeof(csi2->av.vdev.name),
+		 IPU_ISYS_ENTITY_PREFIX " CSI-2 %u capture", index);
+	csi2->av.isys = isys;
+	csi2->av.aq.css_pin_type = IPU_FW_ISYS_PIN_TYPE_MIPI;
+	csi2->av.pfmts = ipu_isys_pfmts_packed;
+	csi2->av.try_fmt_vid_mplane = csi2_try_fmt;
+	csi2->av.prepare_fw_stream =
+		ipu_isys_prepare_fw_cfg_default;
+	csi2->av.packed = true;
+	csi2->av.line_header_length =
+		IPU_ISYS_CSI2_LONG_PACKET_HEADER_SIZE;
+	csi2->av.line_footer_length =
+		IPU_ISYS_CSI2_LONG_PACKET_FOOTER_SIZE;
+	csi2->av.aq.buf_prepare = ipu_isys_buf_prepare;
+	csi2->av.aq.fill_frame_buff_set_pin =
+	ipu_isys_buffer_to_fw_frame_buff_pin;
+	csi2->av.aq.link_fmt_validate =
+		ipu_isys_link_fmt_validate;
+	csi2->av.aq.vbq.buf_struct_size =
+		sizeof(struct ipu_isys_video_buffer);
+
+	rval = ipu_isys_video_init(&csi2->av,
+				   &csi2->asd.sd.entity,
+				   CSI2_PAD_SOURCE,
+				   MEDIA_PAD_FL_SINK, 0);
 	if (rval) {
-		dev_info(&isys->adev->dev, "can't init metadata node\n");
+		dev_info(&isys->adev->dev, "can't init video node\n");
 		goto fail;
 	}
+
 	return 0;
 
 fail:
@@ -810,7 +535,7 @@ int ipu_isys_csi2_init(struct ipu_isys_csi2 *csi2,
 	return rval;
 }
 
-void ipu_isys_csi2_sof_event(struct ipu_isys_csi2 *csi2, unsigned int vc)
+void ipu_isys_csi2_sof_event(struct ipu_isys_csi2 *csi2)
 {
 	struct ipu_isys_pipeline *ip = NULL;
 	struct v4l2_event ev = {
@@ -821,11 +546,10 @@ void ipu_isys_csi2_sof_event(struct ipu_isys_csi2 *csi2, unsigned int vc)
 	unsigned int i;
 
 	spin_lock_irqsave(&csi2->isys->lock, flags);
-	csi2->in_frame[vc] = true;
+	csi2->in_frame = true;
 
 	for (i = 0; i < IPU_ISYS_MAX_STREAMS; i++) {
 		if (csi2->isys->pipes[i] &&
-		    csi2->isys->pipes[i]->vc == vc &&
 		    csi2->isys->pipes[i]->csi2 == csi2) {
 			ip = csi2->isys->pipes[i];
 			break;
@@ -839,19 +563,15 @@ void ipu_isys_csi2_sof_event(struct ipu_isys_csi2 *csi2, unsigned int vc)
 	}
 
 	ev.u.frame_sync.frame_sequence = atomic_inc_return(&ip->sequence) - 1;
-	ev.id = ip->stream_id;
 	spin_unlock_irqrestore(&csi2->isys->lock, flags);
 
-#ifdef IPU_TRACE_EVENT
-	trace_ipu_sof_seqid(ev.u.frame_sync.frame_sequence, csi2->index, vc);
-#endif
 	v4l2_event_queue(vdev, &ev);
 	dev_dbg(&csi2->isys->adev->dev,
-		"sof_event::csi2-%i CPU-timestamp:%lld, sequence:%i, vc:%d, stream_id:%d\n",
-		csi2->index, ktime_get_ns(), ev.u.frame_sync.frame_sequence, vc, ip->stream_id);
+		"sof_event::csi2-%i sequence: %i\n",
+		csi2->index, ev.u.frame_sync.frame_sequence);
 }
 
-void ipu_isys_csi2_eof_event(struct ipu_isys_csi2 *csi2, unsigned int vc)
+void ipu_isys_csi2_eof_event(struct ipu_isys_csi2 *csi2)
 {
 	struct ipu_isys_pipeline *ip = NULL;
 	unsigned long flags;
@@ -859,13 +579,12 @@ void ipu_isys_csi2_eof_event(struct ipu_isys_csi2 *csi2, unsigned int vc)
 	u32 frame_sequence;
 
 	spin_lock_irqsave(&csi2->isys->lock, flags);
-	csi2->in_frame[vc] = false;
-	if (csi2->wait_for_sync[vc])
+	csi2->in_frame = false;
+	if (csi2->wait_for_sync)
 		complete(&csi2->eof_completion);
 
 	for (i = 0; i < IPU_ISYS_MAX_STREAMS; i++) {
 		if (csi2->isys->pipes[i] &&
-		    csi2->isys->pipes[i]->vc == vc &&
 		    csi2->isys->pipes[i]->csi2 == csi2) {
 			ip = csi2->isys->pipes[i];
 			break;
@@ -875,13 +594,10 @@ void ipu_isys_csi2_eof_event(struct ipu_isys_csi2 *csi2, unsigned int vc)
 	if (ip) {
 		frame_sequence = atomic_read(&ip->sequence);
 		spin_unlock_irqrestore(&csi2->isys->lock, flags);
-#ifdef IPU_TRACE_EVENT
-		trace_ipu_eof_seqid(frame_sequence, csi2->index, vc);
-#endif
 
 		dev_dbg(&csi2->isys->adev->dev,
-			"eof_event: csi2-%i sequence: %i, vc: %d, stream: %d\n",
-			csi2->index, frame_sequence, vc, ip->stream_id);
+			"eof_event::csi2-%i sequence: %i\n",
+			csi2->index, frame_sequence);
 		return;
 	}
 
@@ -892,27 +608,24 @@ void ipu_isys_csi2_eof_event(struct ipu_isys_csi2 *csi2, unsigned int vc)
 void ipu_isys_csi2_wait_last_eof(struct ipu_isys_csi2 *csi2)
 {
 	unsigned long flags, tout;
-	unsigned int i;
 
-	for (i = 0; i < NR_OF_CSI2_VC; i++) {
-		spin_lock_irqsave(&csi2->isys->lock, flags);
-
-		if (!csi2->in_frame[i]) {
-			spin_unlock_irqrestore(&csi2->isys->lock, flags);
-			continue;
-		}
+	spin_lock_irqsave(&csi2->isys->lock, flags);
 
-		reinit_completion(&csi2->eof_completion);
-		csi2->wait_for_sync[i] = true;
+	if (!csi2->in_frame) {
 		spin_unlock_irqrestore(&csi2->isys->lock, flags);
-		tout = wait_for_completion_timeout(&csi2->eof_completion,
-						   IPU_EOF_TIMEOUT_JIFFIES);
-		if (!tout)
-			dev_err(&csi2->isys->adev->dev,
-				"csi2-%d: timeout at sync to eof of vc %d\n",
-				csi2->index, i);
-		csi2->wait_for_sync[i] = false;
+		return;
 	}
+
+	reinit_completion(&csi2->eof_completion);
+	csi2->wait_for_sync = true;
+	spin_unlock_irqrestore(&csi2->isys->lock, flags);
+	tout = wait_for_completion_timeout(&csi2->eof_completion,
+					   IPU_EOF_TIMEOUT_JIFFIES);
+	if (!tout)
+		dev_err(&csi2->isys->adev->dev,
+			"csi2-%d: timeout at sync to eof\n",
+			csi2->index);
+	csi2->wait_for_sync = false;
 }
 
 struct ipu_isys_buffer *
diff --git a/drivers/media/pci/intel/ipu-isys-csi2.h b/drivers/media/pci/intel/ipu-isys-csi2.h
index 985e5d39d788..e7f99ab2fe41 100644
--- a/drivers/media/pci/intel/ipu-isys-csi2.h
+++ b/drivers/media/pci/intel/ipu-isys-csi2.h
@@ -1,5 +1,5 @@
 /* SPDX-License-Identifier: GPL-2.0 */
-/* Copyright (C) 2013 - 2020 Intel Corporation */
+/* Copyright (C) 2013 - 2022 Intel Corporation */
 
 #ifndef IPU_ISYS_CSI2_H
 #define IPU_ISYS_CSI2_H
@@ -18,17 +18,9 @@ struct ipu_isys;
 
 #define NR_OF_CSI2_SINK_PADS		1
 #define CSI2_PAD_SINK			0
-#define NR_OF_CSI2_STREAMS		NR_OF_CSI2_VC
-#define NR_OF_CSI2_SOURCE_PADS		NR_OF_CSI2_STREAMS
-#define CSI2_PAD_SOURCE(n)		\
-	({ typeof(n) __n = (n);		\
-	(__n >= NR_OF_CSI2_SOURCE_PADS ? \
-		(NR_OF_CSI2_PADS - 2) : \
-		(__n + NR_OF_CSI2_SINK_PADS)); })
-#define NR_OF_CSI2_META_PADS		1
-#define NR_OF_CSI2_PADS			\
-	(NR_OF_CSI2_SINK_PADS + NR_OF_CSI2_SOURCE_PADS + NR_OF_CSI2_META_PADS)
-#define CSI2_PAD_META			(NR_OF_CSI2_PADS - 1)
+#define NR_OF_CSI2_SOURCE_PADS		1
+#define CSI2_PAD_SOURCE			1
+#define NR_OF_CSI2_PADS	(NR_OF_CSI2_SINK_PADS + NR_OF_CSI2_SOURCE_PADS)
 
 #define IPU_ISYS_SHORT_PACKET_BUFFER_NUM	VIDEO_MAX_FRAME
 #define IPU_ISYS_SHORT_PACKET_WIDTH	32
@@ -89,8 +81,7 @@ struct ipu_isys_csi2 {
 	struct ipu_isys_csi2_pdata *pdata;
 	struct ipu_isys *isys;
 	struct ipu_isys_subdev asd;
-	struct ipu_isys_video av[NR_OF_CSI2_SOURCE_PADS];
-	struct ipu_isys_video av_meta;
+	struct ipu_isys_video av;
 	struct completion eof_completion;
 
 	void __iomem *base;
@@ -98,11 +89,9 @@ struct ipu_isys_csi2 {
 	unsigned int nlanes;
 	unsigned int index;
 	atomic_t sof_sequence;
-	bool in_frame[NR_OF_CSI2_VC];
-	bool wait_for_sync[NR_OF_CSI2_VC];
-
-	unsigned int remote_streams;
 	unsigned int stream_count;
+	bool in_frame;
+	bool wait_for_sync;
 
 	struct v4l2_ctrl *store_csi2_header;
 };
@@ -160,8 +149,8 @@ void ipu_isys_csi2_cleanup(struct ipu_isys_csi2 *csi2);
 struct ipu_isys_buffer *
 ipu_isys_csi2_get_short_packet_buffer(struct ipu_isys_pipeline *ip,
 				      struct ipu_isys_buffer_list *bl);
-void ipu_isys_csi2_sof_event(struct ipu_isys_csi2 *csi2, unsigned int vc);
-void ipu_isys_csi2_eof_event(struct ipu_isys_csi2 *csi2, unsigned int vc);
+void ipu_isys_csi2_sof_event(struct ipu_isys_csi2 *csi2);
+void ipu_isys_csi2_eof_event(struct ipu_isys_csi2 *csi2);
 void ipu_isys_csi2_wait_last_eof(struct ipu_isys_csi2 *csi2);
 
 /* interface for platform specific */
diff --git a/drivers/media/pci/intel/ipu-isys-queue.c b/drivers/media/pci/intel/ipu-isys-queue.c
index 0099f4c15e3d..04c98ab82852 100644
--- a/drivers/media/pci/intel/ipu-isys-queue.c
+++ b/drivers/media/pci/intel/ipu-isys-queue.c
@@ -18,11 +18,6 @@
 #include "ipu-isys.h"
 #include "ipu-isys-csi2.h"
 #include "ipu-isys-video.h"
-#ifdef IPU_TRACE_EVENT
-#define CREATE_TRACE_POINTS
-#define IPU_ISYSBUF_READY_TRACE
-#include "ipu-trace-event.h"
-#endif
 
 static bool wall_clock_ts_on;
 module_param(wall_clock_ts_on, bool, 0660);
@@ -343,12 +338,10 @@ ipu_isys_buffer_to_fw_frame_buff_pin(struct vb2_buffer *vb,
 				     struct ipu_fw_isys_frame_buff_set_abi *set)
 {
 	struct ipu_isys_queue *aq = vb2_queue_to_ipu_isys_queue(vb->vb2_queue);
-#if defined(IPU_ISYS_COMPRESSION)
 	struct ipu_isys_video *av = container_of(aq, struct ipu_isys_video, aq);
 
 	if (av->compression)
 		set->output_pins[aq->fw_output].compress = 1;
-#endif
 
 	set->output_pins[aq->fw_output].addr =
 	    vb2_dma_contig_plane_dma_addr(vb, 0);
@@ -633,7 +626,6 @@ int ipu_isys_link_fmt_validate(struct ipu_isys_queue *aq)
 
 	fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
 	fmt.pad = pad->index;
-	fmt.stream = 0;
 	rval = v4l2_subdev_call(sd, pad, get_fmt, NULL, &fmt);
 	if (rval)
 		return rval;
@@ -885,6 +877,7 @@ static int reset_start_streaming(struct ipu_isys_video *av)
 	}
 	spin_unlock_irqrestore(&aq->lock, flags);
 
+	av->skipframe = 1;
 	rval = __start_streaming(&aq->vbq, 0);
 
 	return rval;
@@ -911,22 +904,16 @@ static int ipu_isys_reset(struct ipu_isys_video *self_av)
 	isys->in_reset = true;
 	mutex_unlock(&isys->reset_mutex);
 
-	for (i = 0; i < NR_OF_CSI2_SOURCE_PADS; i++) {
-		av = &isys->csi2->av[i];
-
-		if (av == self_av)
-			continue;
+	av = &isys->csi2->av;
 
+	if (av != self_av) {
 		ip = &av->ip;
 		mutex_lock(&av->mutex);
-		if (!ip->streaming) {
-			mutex_unlock(&av->mutex);
-			continue;
+		if (ip->streaming) {
+			av->reset = true;
+			has_streaming = true;
+			reset_stop_streaming(av);
 		}
-
-		av->reset = true;
-		has_streaming = true;
-		reset_stop_streaming(av);
 		mutex_unlock(&av->mutex);
 	}
 
@@ -943,9 +930,10 @@ static int ipu_isys_reset(struct ipu_isys_video *self_av)
 		mutex_unlock(&av->mutex);
 	}
 
-	csi2_be_soc = &isys->csi2_be_soc;
-	for (j = 0; j < NR_OF_CSI2_BE_SOC_SOURCE_PADS; j++) {
-		av = &csi2_be_soc->av[j];
+	for (i = 0; i < NR_OF_CSI2_BE_SOC_DEV; i++) {
+		csi2_be_soc = &isys->csi2_be_soc[i];
+		for (j = 0; j < NR_OF_CSI2_BE_SOC_SOURCE_PADS; j++) {
+			av = &csi2_be_soc->av[j];
 		if (av == self_av)
 			continue;
 
@@ -959,6 +947,7 @@ static int ipu_isys_reset(struct ipu_isys_video *self_av)
 		has_streaming = true;
 		reset_stop_streaming(av);
 		mutex_unlock(&av->mutex);
+		}
 	}
 
 	if (!has_streaming)
@@ -1002,12 +991,8 @@ static int ipu_isys_reset(struct ipu_isys_video *self_av)
 
 	dev_dbg(&isys->adev->dev, "restart streams\n");
 
-	for (i = 0; i < NR_OF_CSI2_SOURCE_PADS; i++) {
-		av = &isys->csi2->av[i];
-
-		if (!av->reset)
-			continue;
-
+	av = &isys->csi2->av;
+	if (av->reset) {
 		av->reset = false;
 		mutex_lock(&av->mutex);
 		reset_start_streaming(av);
@@ -1022,9 +1007,10 @@ static int ipu_isys_reset(struct ipu_isys_video *self_av)
 		mutex_unlock(&av->mutex);
 	}
 
-	csi2_be_soc = &isys->csi2_be_soc;
-	for (j = 0; j < NR_OF_CSI2_BE_SOC_SOURCE_PADS; j++) {
-		av = &csi2_be_soc->av[j];
+	for (i = 0; i < NR_OF_CSI2_BE_SOC_DEV; i++) {
+		csi2_be_soc = &isys->csi2_be_soc[i];
+		for (j = 0; j < NR_OF_CSI2_BE_SOC_SOURCE_PADS; j++) {
+			av = &csi2_be_soc->av[j];
 		if (!av->reset)
 			continue;
 
@@ -1032,6 +1018,7 @@ static int ipu_isys_reset(struct ipu_isys_video *self_av)
 		mutex_lock(&av->mutex);
 		reset_start_streaming(av);
 		mutex_unlock(&av->mutex);
+		}
 	}
 
 end_of_reset:
@@ -1176,8 +1163,8 @@ ipu_isys_buf_calc_sequence_time(struct ipu_isys_buffer *ib,
 
 	dev_dbg(dev, "buf: %s: buffer done, CPU-timestamp:%lld, sequence:%d\n",
 		av->vdev.name, ktime_get_ns(), sequence);
-	dev_dbg(dev, "vc:%d, index:%d, vbuf timestamp:%lld, endl\n",
-		ip->vc, vb->index, vbuf->vb2_buf.timestamp);
+	dev_dbg(dev, "index:%d, vbuf timestamp:%lld, endl\n",
+		vb->index, vbuf->vb2_buf.timestamp);
 }
 
 void ipu_isys_queue_buf_done(struct ipu_isys_buffer *ib)
@@ -1191,6 +1178,9 @@ void ipu_isys_queue_buf_done(struct ipu_isys_buffer *ib)
 		 * to the userspace when it is de-queued
 		 */
 		atomic_set(&ib->str2mmio_flag, 0);
+	} else if (atomic_read(&ib->skipframe_flag)) {
+		vb2_buffer_done(vb, VB2_BUF_STATE_ERROR);
+		atomic_set(&ib->skipframe_flag, 0);
 	} else {
 		vb2_buffer_done(vb, VB2_BUF_STATE_DONE);
 	}
@@ -1246,15 +1236,6 @@ void ipu_isys_queue_buf_ready(struct ipu_isys_pipeline *ip,
 		buf = to_vb2_v4l2_buffer(vb);
 		buf->field = V4L2_FIELD_NONE;
 
-		/*
-		 * Use "reserved" field to pass csi2 index and vc.
-		 * May need to change to other approach.
-		 */
-		buf->reserved &= 0xFFFFFF00;
-		if (ip->csi2)
-			buf->reserved |= ip->csi2->index << 4;
-		buf->reserved |= ip->vc;
-
 		list_del(&ib->head);
 		spin_unlock_irqrestore(&aq->lock, flags);
 
@@ -1271,13 +1252,6 @@ void ipu_isys_queue_buf_ready(struct ipu_isys_pipeline *ip,
 			spin_unlock_irqrestore(&ip->short_packet_queue_lock,
 					       flags);
 		} else {
-#ifdef IPU_TRACE_EVENT
-			struct ipu_isys_video *av = ipu_isys_queue_to_video(aq);
-
-			trace_ipu_isysbuf_ready(buf->sequence, av->mpix.width,
-						av->mpix.height,
-						av->pfmt->bpp_packed);
-#endif
 			ipu_isys_queue_buf_done(ib);
 		}
 
diff --git a/drivers/media/pci/intel/ipu-isys-queue.h b/drivers/media/pci/intel/ipu-isys-queue.h
index 99be2989a088..ed14b6b23a34 100644
--- a/drivers/media/pci/intel/ipu-isys-queue.h
+++ b/drivers/media/pci/intel/ipu-isys-queue.h
@@ -49,6 +49,7 @@ struct ipu_isys_buffer {
 	struct list_head req_head;
 	struct media_device_request *req;
 	atomic_t str2mmio_flag;
+	atomic_t skipframe_flag;
 };
 
 struct ipu_isys_video_buffer {
diff --git a/drivers/media/pci/intel/ipu-isys-subdev.c b/drivers/media/pci/intel/ipu-isys-subdev.c
index 7290a7f5ed8d..68c4a8492a16 100644
--- a/drivers/media/pci/intel/ipu-isys-subdev.c
+++ b/drivers/media/pci/intel/ipu-isys-subdev.c
@@ -136,13 +136,12 @@ u32 ipu_isys_subdev_code_to_uncompressed(u32 sink_code)
 struct v4l2_mbus_framefmt *__ipu_isys_get_ffmt(struct v4l2_subdev *sd,
 					       struct v4l2_subdev_state *state,
 					       unsigned int pad,
-					       unsigned int stream,
 					       unsigned int which)
 {
 	struct ipu_isys_subdev *asd = to_ipu_isys_subdev(sd);
 
 	if (which == V4L2_SUBDEV_FORMAT_ACTIVE)
-		return &asd->ffmt[pad][stream];
+		return &asd->ffmt[pad];
 	else
 		return v4l2_subdev_get_try_format(sd, state, pad);
 }
@@ -228,7 +227,7 @@ int ipu_isys_subdev_fmt_propagate(struct v4l2_subdev *sd,
 	}
 
 	for (i = 0; i < sd->entity.num_pads; i++) {
-		ffmts[i] = __ipu_isys_get_ffmt(sd, state, i, 0, which);
+		ffmts[i] = __ipu_isys_get_ffmt(sd, state, i, which);
 		crops[i] = __ipu_isys_get_selection(sd, state, V4L2_SEL_TGT_CROP,
 						    i, which);
 		compose[i] = __ipu_isys_get_selection(sd, state,
@@ -263,57 +262,22 @@ int ipu_isys_subdev_fmt_propagate(struct v4l2_subdev *sd,
 			goto out_subdev_fmt_propagate;
 		}
 
-		/* 1:n and 1:1 case: only propagate to the first source pad */
-		if (asd->nsinks == 1 && asd->nsources >= 1) {
-			compose[asd->nsinks]->left =
-			    compose[asd->nsinks]->top = 0;
-			compose[asd->nsinks]->width = r->width;
-			compose[asd->nsinks]->height = r->height;
-			rval = ipu_isys_subdev_fmt_propagate(sd, state, ffmt,
-						      compose[asd->nsinks],
-						      tgt + 1, asd->nsinks,
-						      which);
+		for (i = 1; i < sd->entity.num_pads; i++) {
+			if (!(sd->entity.pads[i].flags &
+					MEDIA_PAD_FL_SOURCE))
+				continue;
+
+			compose[i]->left = 0;
+			compose[i]->top = 0;
+			compose[i]->width = r->width;
+			compose[i]->height = r->height;
+			rval = ipu_isys_subdev_fmt_propagate(sd, state,
+							     ffmt,
+							     compose[i],
+							     tgt + 1, i,
+							     which);
 			if (rval)
 				goto out_subdev_fmt_propagate;
-			/* n:n case: propagate according to route info */
-		} else if (asd->nsinks == asd->nsources && asd->nsources > 1) {
-			for (i = asd->nsinks; i < sd->entity.num_pads; i++)
-				if (media_entity_has_route(&sd->entity, pad, i))
-					break;
-
-			if (i != sd->entity.num_pads) {
-				compose[i]->left = 0;
-				compose[i]->top = 0;
-				compose[i]->width = r->width;
-				compose[i]->height = r->height;
-				rval = ipu_isys_subdev_fmt_propagate(sd, state,
-								     ffmt,
-								     compose[i],
-								     tgt + 1, i,
-								     which);
-				if (rval)
-					goto out_subdev_fmt_propagate;
-			}
-			/* n:m case: propagate to all source pad */
-		} else if (asd->nsinks != asd->nsources && asd->nsources > 1 &&
-			   asd->nsources > 1) {
-			for (i = 1; i < sd->entity.num_pads; i++) {
-				if (!(sd->entity.pads[i].flags &
-				      MEDIA_PAD_FL_SOURCE))
-					continue;
-
-				compose[i]->left = 0;
-				compose[i]->top = 0;
-				compose[i]->width = r->width;
-				compose[i]->height = r->height;
-				rval = ipu_isys_subdev_fmt_propagate(sd, state,
-								     ffmt,
-								     compose[i],
-								     tgt + 1, i,
-								     which);
-				if (rval)
-					goto out_subdev_fmt_propagate;
-			}
 		}
 		goto out_subdev_fmt_propagate;
 	case IPU_ISYS_SUBDEV_PROP_TGT_SOURCE_COMPOSE:
@@ -365,14 +329,12 @@ int ipu_isys_subdev_set_ffmt_default(struct v4l2_subdev *sd,
 				     struct v4l2_subdev_format *fmt)
 {
 	struct v4l2_mbus_framefmt *ffmt =
-		__ipu_isys_get_ffmt(sd, state, fmt->pad, fmt->stream,
-					   fmt->which);
+		__ipu_isys_get_ffmt(sd, state, fmt->pad, fmt->which);
 
 	/* No propagation for non-zero pads. */
 	if (fmt->pad) {
 		struct v4l2_mbus_framefmt *sink_ffmt =
-			__ipu_isys_get_ffmt(sd, state, 0, fmt->stream,
-						   fmt->which);
+			__ipu_isys_get_ffmt(sd, state, 0, fmt->which);
 
 		ffmt->width = sink_ffmt->width;
 		ffmt->height = sink_ffmt->height;
@@ -398,8 +360,7 @@ int __ipu_isys_subdev_set_ffmt(struct v4l2_subdev *sd,
 {
 	struct ipu_isys_subdev *asd = to_ipu_isys_subdev(sd);
 	struct v4l2_mbus_framefmt *ffmt =
-		__ipu_isys_get_ffmt(sd, state, fmt->pad, fmt->stream,
-					   fmt->which);
+		__ipu_isys_get_ffmt(sd, state, fmt->pad, fmt->which);
 	u32 code = asd->supported_codes[fmt->pad][0];
 	unsigned int i;
 
@@ -433,9 +394,6 @@ int ipu_isys_subdev_set_ffmt(struct v4l2_subdev *sd,
 	struct ipu_isys_subdev *asd = to_ipu_isys_subdev(sd);
 	int rval;
 
-	if (fmt->stream >= asd->nstreams)
-		return -EINVAL;
-
 	mutex_lock(&asd->mutex);
 	rval = __ipu_isys_subdev_set_ffmt(sd, state, fmt);
 	mutex_unlock(&asd->mutex);
@@ -449,180 +407,14 @@ int ipu_isys_subdev_get_ffmt(struct v4l2_subdev *sd,
 {
 	struct ipu_isys_subdev *asd = to_ipu_isys_subdev(sd);
 
-	if (fmt->stream >= asd->nstreams)
-		return -EINVAL;
-
 	mutex_lock(&asd->mutex);
 	fmt->format = *__ipu_isys_get_ffmt(sd, state, fmt->pad,
-					   fmt->stream,
 					   fmt->which);
 	mutex_unlock(&asd->mutex);
 
 	return 0;
 }
 
-int ipu_isys_subdev_get_frame_desc(struct v4l2_subdev *sd,
-				   struct v4l2_mbus_frame_desc *desc)
-{
-	int i, rval = 0;
-
-	for (i = 0; i < sd->entity.num_pads; i++) {
-		if (!(sd->entity.pads[i].flags & MEDIA_PAD_FL_SOURCE))
-			continue;
-
-		rval = v4l2_subdev_call(sd, pad, get_frame_desc, i, desc);
-		if (!rval)
-			return rval;
-	}
-
-	if (i == sd->entity.num_pads)
-		rval = -EINVAL;
-
-	return rval;
-}
-
-bool ipu_isys_subdev_has_route(struct media_entity *entity,
-			       unsigned int pad0, unsigned int pad1, int *stream)
-{
-	struct ipu_isys_subdev *asd;
-	int i;
-
-	if (!entity) {
-		WARN_ON(1);
-		return false;
-	}
-	asd = to_ipu_isys_subdev(media_entity_to_v4l2_subdev(entity));
-
-	/* Two sinks are never connected together. */
-	if (pad0 < asd->nsinks && pad1 < asd->nsinks)
-		return false;
-
-	for (i = 0; i < asd->nstreams; i++) {
-		if ((asd->route[i].flags & V4L2_SUBDEV_ROUTE_FL_ACTIVE) &&
-		    ((asd->route[i].sink == pad0 &&
-		      asd->route[i].source == pad1) ||
-		     (asd->route[i].sink == pad1 &&
-			  asd->route[i].source == pad0))) {
-			if (stream)
-				*stream = i;
-			return true;
-		}
-	}
-
-	return false;
-}
-
-int ipu_isys_subdev_set_routing(struct v4l2_subdev *sd,
-				struct v4l2_subdev_routing *route)
-{
-	struct ipu_isys_subdev *asd = to_ipu_isys_subdev(sd);
-	int i, j, ret = 0;
-
-	WARN_ON(!mutex_is_locked(&sd->entity.
-				 graph_obj.mdev
-				 ->graph_mutex));
-
-	for (i = 0; i < min(route->num_routes, asd->nstreams); ++i) {
-		struct v4l2_subdev_route *t = &route->routes[i];
-
-		if (t->sink_stream > asd->nstreams - 1 ||
-		    t->source_stream > asd->nstreams - 1)
-			continue;
-
-		for (j = 0; j < asd->nstreams; j++) {
-			if (t->sink_pad == asd->route[j].sink &&
-			    t->source_pad == asd->route[j].source)
-				break;
-		}
-
-		if (j == asd->nstreams)
-			continue;
-
-		if (asd->route[j].flags & V4L2_SUBDEV_ROUTE_FL_IMMUTABLE)
-			continue;
-
-		if ((t->flags & V4L2_SUBDEV_ROUTE_FL_SOURCE) && asd->nsinks)
-			continue;
-
-		if (!(t->flags & V4L2_SUBDEV_ROUTE_FL_SOURCE)) {
-			int source_pad = 0;
-
-			if (sd->entity.pads[t->sink_pad].flags &
-			    MEDIA_PAD_FL_MULTIPLEX)
-				source_pad = t->source_pad - asd->nsinks;
-
-			asd->stream[t->sink_pad].stream_id[source_pad] =
-			    t->sink_stream;
-		}
-
-		if (sd->entity.pads[t->source_pad].flags &
-		    MEDIA_PAD_FL_MULTIPLEX)
-			asd->stream[t->source_pad].stream_id[t->sink_pad] =
-			    t->source_stream;
-		else
-			asd->stream[t->source_pad].stream_id[0] =
-			    t->source_stream;
-
-		if (t->flags & V4L2_SUBDEV_ROUTE_FL_ACTIVE) {
-			bitmap_set(asd->stream[t->source_pad].streams_stat,
-				   t->source_stream, 1);
-			if (!(t->flags & V4L2_SUBDEV_ROUTE_FL_SOURCE))
-				bitmap_set(asd->stream[t->sink_pad]
-					   .streams_stat, t->sink_stream, 1);
-			asd->route[j].flags |= V4L2_SUBDEV_ROUTE_FL_ACTIVE;
-		} else if (!(t->flags & V4L2_SUBDEV_ROUTE_FL_ACTIVE)) {
-			bitmap_clear(asd->stream[t->source_pad].streams_stat,
-				     t->source_stream, 1);
-			if (!(t->flags & V4L2_SUBDEV_ROUTE_FL_SOURCE))
-				bitmap_clear(asd->stream[t->sink_pad]
-					     .streams_stat, t->sink_stream, 1);
-			asd->route[j].flags &= (~V4L2_SUBDEV_ROUTE_FL_ACTIVE);
-		}
-	}
-
-	return ret;
-}
-
-int ipu_isys_subdev_get_routing(struct v4l2_subdev *sd,
-				struct v4l2_subdev_routing *route)
-{
-	struct ipu_isys_subdev *asd = to_ipu_isys_subdev(sd);
-	int i, j;
-
-	for (i = 0, j = 0; i < min(asd->nstreams, route->num_routes); ++i) {
-		route->routes[j].sink_pad = asd->route[i].sink;
-		if (sd->entity.pads[asd->route[i].sink].flags &
-		    MEDIA_PAD_FL_MULTIPLEX) {
-			int source_pad = asd->route[i].source - asd->nsinks;
-
-			route->routes[j].sink_stream =
-			    asd->stream[asd->route[i].sink].
-			    stream_id[source_pad];
-		} else {
-			route->routes[j].sink_stream =
-			    asd->stream[asd->route[i].sink].stream_id[0];
-		}
-
-		route->routes[j].source_pad = asd->route[i].source;
-		if (sd->entity.pads[asd->route[i].source].flags &
-		    MEDIA_PAD_FL_MULTIPLEX) {
-			route->routes[j].source_stream =
-			    asd->stream[asd->route[i].source].stream_id[asd->
-									route
-									[i].
-									sink];
-		} else {
-			route->routes[j].source_stream =
-			    asd->stream[asd->route[i].source].stream_id[0];
-		}
-		route->routes[j++].flags = asd->route[i].flags;
-	}
-
-	route->num_routes = j;
-
-	return 0;
-}
-
 int ipu_isys_subdev_set_sel(struct v4l2_subdev *sd,
 			    struct v4l2_subdev_state *state,
 			    struct v4l2_subdev_selection *sel)
@@ -639,8 +431,8 @@ int ipu_isys_subdev_set_sel(struct v4l2_subdev *sd,
 	case V4L2_SEL_TGT_CROP:
 		if (pad->flags & MEDIA_PAD_FL_SINK) {
 			struct v4l2_mbus_framefmt *ffmt =
-				__ipu_isys_get_ffmt(sd, state, sel->pad, 0,
-							   sel->which);
+				__ipu_isys_get_ffmt(sd, state, sel->pad,
+						    sel->which);
 
 			__r.width = ffmt->width;
 			__r.height = ffmt->height;
@@ -698,24 +490,6 @@ int ipu_isys_subdev_enum_mbus_code(struct v4l2_subdev *sd,
 	struct ipu_isys_subdev *asd = to_ipu_isys_subdev(sd);
 	const u32 *supported_codes = asd->supported_codes[code->pad];
 	u32 index;
-	bool next_stream = false;
-
-	if (sd->entity.pads[code->pad].flags & MEDIA_PAD_FL_MULTIPLEX) {
-		if (code->stream & V4L2_SUBDEV_FLAG_NEXT_STREAM) {
-			next_stream = true;
-			code->stream &= ~V4L2_SUBDEV_FLAG_NEXT_STREAM;
-		}
-
-		if (code->stream > asd->nstreams - 1)
-			return -EINVAL;
-
-		if (next_stream && code->stream < asd->nstreams) {
-			code->stream++;
-			return 0;
-		}
-
-		return -EINVAL;
-	}
 
 	for (index = 0; supported_codes[index]; index++) {
 		if (index == code->index) {
@@ -727,57 +501,6 @@ int ipu_isys_subdev_enum_mbus_code(struct v4l2_subdev *sd,
 	return -EINVAL;
 }
 
-#ifdef IPU_ISYS_YUV422_I420
-/*
- * IPU private link validation
- * In advanced IPU and special case, there will be format change between
- * sink/source pads in ISYS.
- * Format code checking is not necessary for these features.
- */
-static int
-ipu_isys_subdev_link_validate_private(struct v4l2_subdev *sd,
-				      struct media_link *link,
-				      struct v4l2_subdev_format *source_fmt,
-				      struct v4l2_subdev_format *sink_fmt)
-{
-	struct ipu_isys_subdev *asd = to_ipu_isys_subdev(sd);
-
-	/* The width and height must match. */
-	if (source_fmt->format.width != sink_fmt->format.width ||
-	    source_fmt->format.height != sink_fmt->format.height)
-		return -EPIPE;
-
-	/*
-	 * The field order must match, or the sink field order must be NONE
-	 * to support interlaced hardware connected to bridges that support
-	 * progressive formats only.
-	 */
-	if (source_fmt->format.field != sink_fmt->format.field &&
-	    sink_fmt->format.field != V4L2_FIELD_NONE)
-		return -EPIPE;
-
-	if (source_fmt->stream != sink_fmt->stream)
-		return -EINVAL;
-	/*
-	 * For new IPU special case, YUV format changing in BE-SOC,
-	 * from YUV422 to I420, which is used to adapt multiple
-	 * YUV sensors and provide I420 to BB for partial processing.
-	 * If this entity doing format convert, ignore format check
-	 */
-	if (source_fmt->format.code != sink_fmt->format.code) {
-		if (source_fmt->format.code == MEDIA_BUS_FMT_UYVY8_2X8 &&
-		    (sink_fmt->format.code == MEDIA_BUS_FMT_YUYV8_1X16 ||
-		     sink_fmt->format.code == MEDIA_BUS_FMT_UYVY8_1X16))
-			dev_warn(&asd->isys->adev->dev,
-				 "YUV format change, ignore code check\n");
-		else
-			return -EINVAL;
-	}
-
-	return 0;
-}
-#endif
-
 /*
  * Besides validating the link, figure out the external pad and the
  * ISYS FW ABI source.
@@ -818,13 +541,8 @@ int ipu_isys_subdev_link_validate(struct v4l2_subdev *sd,
 	if (asd->isl_mode != IPU_ISL_OFF)
 		ip->isl_mode = asd->isl_mode;
 
-#if defined(IPU_ISYS_YUV422_I420)
-	return ipu_isys_subdev_link_validate_private(sd, link, source_fmt,
-						    sink_fmt);
-#else
 	return v4l2_subdev_link_validate_default(sd, link, source_fmt,
 						 sink_fmt);
-#endif
 }
 
 int ipu_isys_subdev_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
@@ -842,7 +560,7 @@ int ipu_isys_subdev_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
 		struct v4l2_rect *try_compose =
 			v4l2_subdev_get_try_compose(sd, fh->state, i);
 
-		*try_fmt = asd->ffmt[i][0];
+		*try_fmt = asd->ffmt[i];
 		*try_crop = asd->crop[i];
 		*try_compose = asd->compose[i];
 	}
@@ -861,12 +579,10 @@ int ipu_isys_subdev_init(struct ipu_isys_subdev *asd,
 			 struct v4l2_subdev_ops *ops,
 			 unsigned int nr_ctrls,
 			 unsigned int num_pads,
-			 unsigned int num_streams,
 			 unsigned int num_source,
 			 unsigned int num_sink,
 			 unsigned int sd_flags)
 {
-	int i;
 	int rval = -EINVAL;
 
 	mutex_init(&asd->mutex);
@@ -877,17 +593,14 @@ int ipu_isys_subdev_init(struct ipu_isys_subdev *asd,
 	asd->sd.owner = THIS_MODULE;
 	asd->sd.entity.function = MEDIA_ENT_F_VID_IF_BRIDGE;
 
-	asd->nstreams = num_streams;
 	asd->nsources = num_source;
 	asd->nsinks = num_sink;
 
 	asd->pad = devm_kcalloc(&asd->isys->adev->dev, num_pads,
 				sizeof(*asd->pad), GFP_KERNEL);
 
-	asd->ffmt = (struct v4l2_mbus_framefmt **)
-			devm_kcalloc(&asd->isys->adev->dev, num_pads,
-				     sizeof(struct v4l2_mbus_framefmt *),
-				     GFP_KERNEL);
+	asd->ffmt = devm_kcalloc(&asd->isys->adev->dev, num_pads,
+				 sizeof(*asd->ffmt), GFP_KERNEL);
 
 	asd->crop = devm_kcalloc(&asd->isys->adev->dev, num_pads,
 				 sizeof(*asd->crop), GFP_KERNEL);
@@ -897,30 +610,10 @@ int ipu_isys_subdev_init(struct ipu_isys_subdev *asd,
 
 	asd->valid_tgts = devm_kcalloc(&asd->isys->adev->dev, num_pads,
 				       sizeof(*asd->valid_tgts), GFP_KERNEL);
-	asd->route = devm_kcalloc(&asd->isys->adev->dev, num_streams,
-				  sizeof(*asd->route), GFP_KERNEL);
-
-	asd->stream = devm_kcalloc(&asd->isys->adev->dev, num_pads,
-				   sizeof(*asd->stream), GFP_KERNEL);
-
 	if (!asd->pad || !asd->ffmt || !asd->crop || !asd->compose ||
-	    !asd->valid_tgts || !asd->route || !asd->stream)
+	    !asd->valid_tgts)
 		return -ENOMEM;
 
-	for (i = 0; i < num_pads; i++) {
-		asd->ffmt[i] = (struct v4l2_mbus_framefmt *)
-		    devm_kcalloc(&asd->isys->adev->dev, num_streams,
-				 sizeof(struct v4l2_mbus_framefmt), GFP_KERNEL);
-		if (!asd->ffmt[i])
-			return -ENOMEM;
-
-		asd->stream[i].stream_id =
-		    devm_kcalloc(&asd->isys->adev->dev, num_source,
-				 sizeof(*asd->stream[i].stream_id), GFP_KERNEL);
-		if (!asd->stream[i].stream_id)
-			return -ENOMEM;
-	}
-
 	rval = media_entity_pads_init(&asd->sd.entity, num_pads, asd->pad);
 	if (rval)
 		goto out_mutex_destroy;
diff --git a/drivers/media/pci/intel/ipu-isys-subdev.h b/drivers/media/pci/intel/ipu-isys-subdev.h
index ceb08395d398..d16d95670f99 100644
--- a/drivers/media/pci/intel/ipu-isys-subdev.h
+++ b/drivers/media/pci/intel/ipu-isys-subdev.h
@@ -67,19 +67,9 @@ struct ipu_isys_subdev {
 	struct ipu_isys *isys;
 	u32 const *const *supported_codes;
 	struct media_pad *pad;
-	struct v4l2_mbus_framefmt **ffmt;
+	struct v4l2_mbus_framefmt *ffmt;
 	struct v4l2_rect *crop;
 	struct v4l2_rect *compose;
-	struct {
-		unsigned int *stream_id;
-		 DECLARE_BITMAP(streams_stat, 32);
-	} *stream;	/* stream enable/disable status, indexed by pad */
-	struct {
-		unsigned int sink;
-		unsigned int source;
-		int flags;
-	} *route;	/* pad level info, indexed by stream */
-	unsigned int nstreams;
 	unsigned int nsinks;
 	unsigned int nsources;
 	struct v4l2_ctrl_handler ctrl_handler;
@@ -102,7 +92,6 @@ struct ipu_isys_subdev {
 struct v4l2_mbus_framefmt *__ipu_isys_get_ffmt(struct v4l2_subdev *sd,
 					       struct v4l2_subdev_state *state,
 					       unsigned int pad,
-					       unsigned int stream,
 					       unsigned int which);
 
 unsigned int ipu_isys_mbus_code_to_bpp(u32 code);
@@ -156,17 +145,8 @@ int ipu_isys_subdev_init(struct ipu_isys_subdev *asd,
 			 struct v4l2_subdev_ops *ops,
 			 unsigned int nr_ctrls,
 			 unsigned int num_pads,
-			 unsigned int num_streams,
 			 unsigned int num_source,
 			 unsigned int num_sink,
 			 unsigned int sd_flags);
 void ipu_isys_subdev_cleanup(struct ipu_isys_subdev *asd);
-int ipu_isys_subdev_get_frame_desc(struct v4l2_subdev *sd,
-				   struct v4l2_mbus_frame_desc *desc);
-int ipu_isys_subdev_set_routing(struct v4l2_subdev *sd,
-				struct v4l2_subdev_routing *route);
-int ipu_isys_subdev_get_routing(struct v4l2_subdev *sd,
-				struct v4l2_subdev_routing *route);
-bool ipu_isys_subdev_has_route(struct media_entity *entity,
-			       unsigned int pad0, unsigned int pad1, int *stream);
 #endif /* IPU_ISYS_SUBDEV_H */
diff --git a/drivers/media/pci/intel/ipu-isys-tpg.c b/drivers/media/pci/intel/ipu-isys-tpg.c
index a0431892fa0f..c866c0c8b2a0 100644
--- a/drivers/media/pci/intel/ipu-isys-tpg.c
+++ b/drivers/media/pci/intel/ipu-isys-tpg.c
@@ -140,8 +140,7 @@ static void tpg_set_ffmt(struct v4l2_subdev *sd,
 			 struct v4l2_subdev_format *fmt)
 {
 	fmt->format.field = V4L2_FIELD_NONE;
-	*__ipu_isys_get_ffmt(sd, state, fmt->pad, fmt->stream,
-			     fmt->which) = fmt->format;
+	*__ipu_isys_get_ffmt(sd, state, fmt->pad, fmt->which) = fmt->format;
 }
 
 static int ipu_isys_tpg_set_ffmt(struct v4l2_subdev *sd,
@@ -149,7 +148,7 @@ static int ipu_isys_tpg_set_ffmt(struct v4l2_subdev *sd,
 				 struct v4l2_subdev_format *fmt)
 {
 	struct ipu_isys_tpg *tpg = to_ipu_isys_tpg(sd);
-	__u32 code = tpg->asd.ffmt[TPG_PAD_SOURCE][0].code;
+	__u32 code = tpg->asd.ffmt[TPG_PAD_SOURCE].code;
 	unsigned int bpp = ipu_isys_mbus_code_to_bpp(code);
 	s64 tpg_rate = ipu_isys_tpg_rate(tpg, bpp);
 	int rval;
@@ -255,7 +254,6 @@ int ipu_isys_tpg_init(struct ipu_isys_tpg *tpg,
 
 	rval = ipu_isys_subdev_init(&tpg->asd, &tpg_sd_ops, 5,
 				    NR_OF_TPG_PADS,
-				    NR_OF_TPG_STREAMS,
 				    NR_OF_TPG_SOURCE_PADS,
 				    NR_OF_TPG_SINK_PADS,
 				    V4L2_SUBDEV_FL_HAS_EVENTS);
diff --git a/drivers/media/pci/intel/ipu-isys-video.c b/drivers/media/pci/intel/ipu-isys-video.c
index 86f7fa39ce0e..5d41b86e3b27 100644
--- a/drivers/media/pci/intel/ipu-isys-video.c
+++ b/drivers/media/pci/intel/ipu-isys-video.c
@@ -1,5 +1,5 @@
 // SPDX-License-Identifier: GPL-2.0
-// Copyright (C) 2013 - 2021 Intel Corporation
+// Copyright (C) 2013 - 2022 Intel Corporation
 
 #include <linux/delay.h>
 #include <linux/firmware.h>
@@ -9,6 +9,7 @@
 #include <linux/module.h>
 #include <linux/version.h>
 #include <linux/compat.h>
+#include <uapi/linux/ipu-isys.h>
 
 #include <uapi/linux/sched/types.h>
 
@@ -21,6 +22,7 @@
 #include "ipu-bus.h"
 #include "ipu-cpd.h"
 #include "ipu-isys.h"
+#include "ipu-buttress.h"
 #include "ipu-isys-video.h"
 #include "ipu-platform.h"
 #include "ipu-platform-regs.h"
@@ -29,11 +31,6 @@
 #include "ipu-fw-isys.h"
 #include "ipu-fw-com.h"
 
-#if defined(IPU_IWAKE_ENABLE)
-/* use max resolution pixel rate by default */
-#define DEFAULT_PIXEL_RATE	(360000000ULL * 2 * 4 / 10)
-#endif
-
 const struct ipu_isys_pixelformat ipu_isys_pfmts_be_soc[] = {
 	{V4L2_PIX_FMT_Y10, 16, 10, 0, MEDIA_BUS_FMT_Y10_1X10,
 	 IPU_FW_ISYS_FRAME_FORMAT_RAW16},
@@ -43,10 +40,6 @@ const struct ipu_isys_pixelformat ipu_isys_pfmts_be_soc[] = {
 	 IPU_FW_ISYS_FRAME_FORMAT_YUYV},
 	{V4L2_PIX_FMT_NV16, 16, 16, 8, MEDIA_BUS_FMT_UYVY8_1X16,
 	 IPU_FW_ISYS_FRAME_FORMAT_NV16},
-#ifdef IPU_ISYS_YUV422_I420
-	{V4L2_PIX_FMT_YUV420, 12, 0, 8, MEDIA_BUS_FMT_UYVY8_2X8,
-	 IPU_FW_ISYS_FRAME_FORMAT_YUV420},
-#endif
 	{V4L2_PIX_FMT_XRGB32, 32, 32, 0, MEDIA_BUS_FMT_RGB565_1X16,
 	 IPU_FW_ISYS_FRAME_FORMAT_RGBA888},
 	{V4L2_PIX_FMT_XBGR32, 32, 32, 0, MEDIA_BUS_FMT_RGB888_1X24,
@@ -138,11 +131,6 @@ static int video_open(struct file *file)
 	struct ipu_isys *isys = av->isys;
 	struct ipu_bus_device *adev = to_ipu_bus_device(&isys->adev->dev);
 	struct ipu_device *isp = adev->isp;
-#ifdef IPU_IRQ_POLL
-	const struct sched_param param = {
-			.sched_priority = MAX_USER_RT_PRIO / 2,
-	};
-#endif
 	int rval;
 	const struct ipu_isys_internal_pdata *ipdata;
 
@@ -199,19 +187,6 @@ static int video_open(struct file *file)
 		ipu_fw_isys_cleanup(isys);
 	}
 
-#ifdef IPU_IRQ_POLL
-	isys->isr_thread = kthread_run(ipu_isys_isr_run,
-				       av->isys,
-				       IPU_ISYS_ENTITY_PREFIX);
-
-	if (IS_ERR(isys->isr_thread)) {
-		rval = PTR_ERR(isys->isr_thread);
-		goto out_ipu_pipeline_pm_use;
-	}
-
-	sched_setscheduler(isys->isr_thread, SCHED_FIFO, &param);
-#endif
-
 	rval = ipu_fw_isys_init(av->isys, ipdata->num_parallel_streams);
 	if (rval < 0)
 		goto out_lib_init;
@@ -221,11 +196,6 @@ static int video_open(struct file *file)
 	return 0;
 
 out_lib_init:
-#ifdef IPU_IRQ_POLL
-	kthread_stop(isys->isr_thread);
-
-out_ipu_pipeline_pm_use:
-#endif /* IPU_IRQ_POLL */
 	isys->video_opened--;
 	mutex_unlock(&isys->mutex);
 	v4l2_pipeline_pm_put(&av->vdev.entity);
@@ -261,9 +231,6 @@ static int video_release(struct file *file)
 	mutex_lock(&av->isys->mutex);
 
 	if (!--av->isys->video_opened) {
-#ifdef IPU_IRQ_POLL
-		kthread_stop(av->isys->isr_thread);
-#endif
 	dev_dbg(&av->isys->adev->dev, "release: %s: close fw\n",
 		av->vdev.name);
 		ipu_fw_isys_close(av->isys);
@@ -467,7 +434,6 @@ ipu_isys_video_try_fmt_vid_mplane(struct ipu_isys_video *av,
 		    max(mpix->plane_fmt[0].bytesperline,
 			av->isys->pdata->ipdata->isys_dma_overshoot)), 1U);
 
-#if defined(IPU_ISYS_COMPRESSION)
 	if (av->compression_ctrl)
 		av->compression = v4l2_ctrl_g_ctrl(av->compression_ctrl);
 
@@ -504,7 +470,6 @@ ipu_isys_video_try_fmt_vid_mplane(struct ipu_isys_video *av,
 			mpix->plane_fmt[0].bytesperline, mpix->height,
 			av->ts_offsets[0], tile_status_size);
 	}
-#endif
 
 	memset(mpix->plane_fmt[0].reserved, 0,
 	       sizeof(mpix->plane_fmt[0].reserved));
@@ -596,9 +561,6 @@ static int vidioc_s_input(struct file *file, void *fh, unsigned int input)
 static bool is_external(struct ipu_isys_video *av, struct media_entity *entity)
 {
 	struct v4l2_subdev *sd;
-#ifdef CONFIG_VIDEO_INTEL_IPU_TPG
-	unsigned int i;
-#endif
 
 	/* All video nodes are ours. */
 	if (!is_media_entity_v4l2_subdev(entity))
@@ -609,13 +571,6 @@ static bool is_external(struct ipu_isys_video *av, struct media_entity *entity)
 		    strlen(IPU_ISYS_ENTITY_PREFIX)) != 0)
 		return true;
 
-#ifdef CONFIG_VIDEO_INTEL_IPU_TPG
-	for (i = 0; i < av->isys->pdata->ipdata->tpg.ntpgs &&
-	     av->isys->tpg[i].isys; i++)
-		if (entity == &av->isys->tpg[i].asd.sd.entity)
-			return true;
-#endif
-
 	return false;
 }
 
@@ -626,12 +581,6 @@ static int link_validate(struct media_link *link)
 	/* All sub-devices connected to a video node are ours. */
 	struct ipu_isys_pipeline *ip =
 		to_ipu_isys_pipeline(av->vdev.entity.pipe);
-	struct v4l2_subdev_route r[IPU_ISYS_MAX_STREAMS];
-	struct v4l2_subdev_routing routing = {
-		.routes = r,
-		.num_routes = IPU_ISYS_MAX_STREAMS,
-	};
-	int i, rval, active = 0;
 	struct v4l2_subdev *sd;
 
 	if (!link->source->entity)
@@ -642,32 +591,6 @@ static int link_validate(struct media_link *link)
 		ip->source = to_ipu_isys_subdev(sd)->source;
 	}
 
-	rval = v4l2_subdev_call(sd, pad, get_routing, &routing);
-	if (rval)
-		goto err_subdev;
-
-	for (i = 0; i < routing.num_routes; i++) {
-		if (!(routing.routes[i].flags & V4L2_SUBDEV_ROUTE_FL_ACTIVE))
-			continue;
-
-		if (routing.routes[i].source_pad == link->source->index)
-			ip->stream_id = routing.routes[i].sink_stream;
-
-		active++;
-	}
-
-	if (ip->external) {
-		struct v4l2_mbus_frame_desc desc = {
-			.num_entries = V4L2_FRAME_DESC_ENTRY_MAX,
-		};
-
-		sd = media_entity_to_v4l2_subdev(ip->external->entity);
-		rval = ipu_isys_subdev_get_frame_desc(sd, &desc);
-		if (!rval && ip->stream_id < desc.num_entries)
-			ip->vc = desc.entry[ip->stream_id].bus.csi2.channel;
-	}
-
-err_subdev:
 	ip->nr_queues++;
 
 	return 0;
@@ -680,6 +603,7 @@ static void get_stream_opened(struct ipu_isys_video *av)
 	spin_lock_irqsave(&av->isys->lock, flags);
 	av->isys->stream_opened++;
 	spin_unlock_irqrestore(&av->isys->lock, flags);
+
 }
 
 static void put_stream_opened(struct ipu_isys_video *av)
@@ -689,6 +613,7 @@ static void put_stream_opened(struct ipu_isys_video *av)
 	spin_lock_irqsave(&av->isys->lock, flags);
 	av->isys->stream_opened--;
 	spin_unlock_irqrestore(&av->isys->lock, flags);
+
 }
 
 static int get_stream_handle(struct ipu_isys_video *av)
@@ -749,7 +674,6 @@ static int get_external_facing_format(struct ipu_isys_pipeline *ip,
 
 	format->which = V4L2_SUBDEV_FORMAT_ACTIVE;
 	format->pad = 0;
-	format->stream = ip->stream_id;
 	sd = media_entity_to_v4l2_subdev(external_facing->entity);
 
 	return v4l2_subdev_call(sd, pad, get_fmt, NULL, format);
@@ -880,13 +804,54 @@ ipu_isys_prepare_fw_cfg_default(struct ipu_isys_video *av,
 	struct ipu_isys *isys = av->isys;
 	unsigned int type_index, type;
 	int pin = cfg->nof_output_pins++;
+	int i;
+	int input_pin = cfg->nof_input_pins++;
+	struct ipu_fw_isys_input_pin_info_abi *input_pin_info =
+		&cfg->input_pins[input_pin];
+	struct ipu_isys_sub_stream_vc *sv = NULL;
+	struct media_pad *source_pad = media_entity_remote_pad(&av->pad);
+	unsigned int sub_stream_id;
+
+	if (!source_pad) {
+		dev_err(&av->isys->adev->dev, "no remote pad found\n");
+		return;
+	}
+	sub_stream_id = source_pad->index - NR_OF_CSI2_BE_SOC_SINK_PADS;
+
+	for (i = 0; i < NR_OF_CSI2_BE_SOC_SOURCE_PADS; i++) {
+		if (sub_stream_id == ip->asv[i].substream) {
+			sv = &ip->asv[i];
+			break;
+		}
+	}
+	if (!sv) {
+		dev_err(&av->isys->adev->dev,
+			"Don't find input pin info for vc:%d\n", ip->vc);
+		return;
+	}
+
+	input_pin_info->input_res.width = sv->width;
+	input_pin_info->input_res.height = sv->height;
+	input_pin_info->dt =
+		(sv->dt != 0 ? sv->dt : IPU_ISYS_MIPI_CSI2_TYPE_RAW12);
+	input_pin_info->mapped_dt = N_IPU_FW_ISYS_MIPI_DATA_TYPE;
+	input_pin_info->mipi_decompression =
+		IPU_FW_ISYS_MIPI_COMPRESSION_TYPE_NO_COMPRESSION;
+	input_pin_info->capture_mode =
+		IPU_FW_ISYS_CAPTURE_MODE_REGULAR;
+	if (ip->csi2 && !v4l2_ctrl_g_ctrl(ip->csi2->store_csi2_header))
+		input_pin_info->mipi_store_mode =
+			IPU_FW_ISYS_MIPI_STORE_MODE_DISCARD_LONG_HEADER;
+	else if (input_pin_info->dt == IPU_ISYS_MIPI_CSI2_TYPE_EMBEDDED8)
+		input_pin_info->mipi_store_mode =
+			IPU_FW_ISYS_MIPI_STORE_MODE_DISCARD_LONG_HEADER;
 
 	aq->fw_output = pin;
 	ip->output_pins[pin].pin_ready = ipu_isys_queue_buf_ready;
 	ip->output_pins[pin].aq = aq;
 
 	pin_info = &cfg->output_pins[pin];
-	pin_info->input_pin_id = 0;
+	pin_info->input_pin_id = input_pin;
 	pin_info->output_res.width = av->mpix.width;
 	pin_info->output_res.height = av->mpix.height;
 
@@ -898,7 +863,9 @@ ipu_isys_prepare_fw_cfg_default(struct ipu_isys_video *av,
 						      BITS_PER_BYTE),
 					 av->isys->line_align);
 
-	pin_info->pt = aq->css_pin_type;
+	pin_info->pt =
+		(input_pin_info->dt == IPU_ISYS_MIPI_CSI2_TYPE_EMBEDDED8 ?
+		 IPU_FW_ISYS_PIN_TYPE_MIPI : aq->css_pin_type);
 	pin_info->ft = av->pfmt->css_pixelformat;
 	pin_info->send_irq = 1;
 	memset(pin_info->ts_offsets, 0, sizeof(pin_info->ts_offsets));
@@ -910,9 +877,6 @@ ipu_isys_prepare_fw_cfg_default(struct ipu_isys_video *av,
 
 	switch (pin_info->pt) {
 	/* non-snoopable sensor data to PSYS */
-#ifdef IPU_ISYS_YUV422_I420
-	case IPU_FW_ISYS_PIN_TYPE_RAW_DUAL_SOC:
-#endif
 	case IPU_FW_ISYS_PIN_TYPE_RAW_NS:
 		type_index = IPU_FW_ISYS_VC1_SENSOR_DATA;
 		pin_info->sensor_type = isys->sensor_types[type_index]++;
@@ -931,7 +895,6 @@ ipu_isys_prepare_fw_cfg_default(struct ipu_isys_video *av,
 		pin_info->snoopable = true;
 		pin_info->error_handling_enable = false;
 		break;
-#if defined(IPU_ISYS_COMPRESSION)
 	case IPU_FW_ISYS_PIN_TYPE_RAW_SOC:
 		if (av->compression) {
 			type_index = IPU_FW_ISYS_VC1_SENSOR_DATA;
@@ -955,9 +918,6 @@ ipu_isys_prepare_fw_cfg_default(struct ipu_isys_video *av,
 					isys->sensor_info.vc0_data_start;
 		}
 		break;
-#else
-	case IPU_FW_ISYS_PIN_TYPE_RAW_SOC:
-#endif
 	case IPU_FW_ISYS_PIN_TYPE_MIPI:
 		type_index = IPU_FW_ISYS_VC0_SENSOR_DATA;
 		pin_info->sensor_type = isys->sensor_types[type_index]++;
@@ -978,13 +938,11 @@ ipu_isys_prepare_fw_cfg_default(struct ipu_isys_video *av,
 		pin_info->snoopable = true;
 		pin_info->error_handling_enable = false;
 	}
-#if defined(IPU_ISYS_COMPRESSION)
 	if (av->compression) {
 		pin_info->payload_buf_size = av->mpix.plane_fmt[0].sizeimage;
 		pin_info->reserve_compression = av->compression;
 		pin_info->ts_offsets[0] = av->ts_offsets[0];
 	}
-#endif
 }
 
 static unsigned int ipu_isys_get_compression_scheme(u32 code)
@@ -1065,28 +1023,10 @@ static int start_stream_firmware(struct ipu_isys_video *av,
 
 	stream_cfg = to_stream_cfg_msg_buf(msg);
 	stream_cfg->compfmt = get_comp_format(source_fmt.format.code);
-	stream_cfg->input_pins[0].input_res.width = source_fmt.format.width;
-	stream_cfg->input_pins[0].input_res.height = source_fmt.format.height;
-	stream_cfg->input_pins[0].dt =
-	    ipu_isys_mbus_code_to_mipi(source_fmt.format.code);
-	stream_cfg->input_pins[0].mapped_dt = N_IPU_FW_ISYS_MIPI_DATA_TYPE;
-	stream_cfg->input_pins[0].mipi_decompression =
-	    IPU_FW_ISYS_MIPI_COMPRESSION_TYPE_NO_COMPRESSION;
-	stream_cfg->input_pins[0].capture_mode =
-		IPU_FW_ISYS_CAPTURE_MODE_REGULAR;
-	if (ip->csi2 && !v4l2_ctrl_g_ctrl(ip->csi2->store_csi2_header))
-		stream_cfg->input_pins[0].mipi_store_mode =
-		    IPU_FW_ISYS_MIPI_STORE_MODE_DISCARD_LONG_HEADER;
-#ifdef CONFIG_VIDEO_INTEL_IPU_TPG
-	else if (ip->tpg && !v4l2_ctrl_g_ctrl(ip->tpg->store_csi2_header))
-		stream_cfg->input_pins[0].mipi_store_mode =
-		    IPU_FW_ISYS_MIPI_STORE_MODE_DISCARD_LONG_HEADER;
-#endif
 
 	stream_cfg->src = ip->source;
 	stream_cfg->vc = 0;
 	stream_cfg->isl_use = ip->isl_mode;
-	stream_cfg->nof_input_pins = 1;
 	stream_cfg->sensor_type = IPU_FW_ISYS_SENSOR_MODE_NORMAL;
 
 	/*
@@ -1357,6 +1297,269 @@ ipu_isys_video_add_capture_done(struct ipu_isys_pipeline *ip,
 	WARN_ON(1);
 }
 
+#define MEDIA_ENTITY_MAX_PADS		512
+
+static int ipu_isys_query_sensor_info(struct media_pad *source_pad,
+				      struct ipu_isys_pipeline *ip)
+{
+	int i;
+	int ret = -ENOLINK;
+	bool flag = false;
+	unsigned int pad_id = source_pad->index;
+	struct media_pad *remote_pad = source_pad;
+	struct media_pad *extern_pad = NULL;
+	struct v4l2_subdev *sd = NULL;
+	struct v4l2_querymenu qm = {.id = V4L2_CID_IPU_QUERY_SUB_STREAM, };
+
+	while ((remote_pad =
+		media_entity_remote_pad(&remote_pad->entity->pads[0])
+		)) {
+		/* Non-subdev nodes can be safely ignored here. */
+		if (!is_media_entity_v4l2_subdev(remote_pad->entity))
+			continue;
+
+		/* Don't start truly external devices quite yet. */
+		if (strncmp(remote_pad->entity->name,
+		    IPU_ISYS_CSI2_ENTITY_PREFIX,
+		    strlen(IPU_ISYS_CSI2_ENTITY_PREFIX)) != 0)
+			continue;
+
+		dev_dbg(remote_pad->entity->graph_obj.mdev->dev,
+			"It finds CSI2 %s\n", remote_pad->entity->name);
+		extern_pad =
+			media_entity_remote_pad(&remote_pad->entity->pads[0]);
+		if (!extern_pad) {
+			dev_dbg(remote_pad->entity->graph_obj.mdev->dev,
+				"extern_pad is null\n");
+			return -ENOLINK;
+		}
+		sd = media_entity_to_v4l2_subdev(extern_pad->entity);
+		break;
+	}
+
+	if (!sd) {
+		dev_dbg(source_pad->entity->graph_obj.mdev->dev,
+			"It doesn't find extern entity\n");
+		return -ENOLINK;
+	}
+
+	/* Get the sub stream info and set the current pipe's vc id */
+	for (i = CSI2_BE_SOC_PAD_SOURCE(0);
+	     i < NR_OF_CSI2_BE_SOC_SOURCE_PADS; i++) {
+		/*
+		 * index is sub stream id. sub stream id is
+		 * equalto BE SOC source pad id - sink pad count
+		 */
+		qm.index = i - NR_OF_CSI2_BE_SOC_SINK_PADS;
+		ret = v4l2_querymenu(sd->ctrl_handler, &qm);
+		if (ret)
+			continue;
+
+		/* get sub stream info by sub stream id */
+		ip->asv[qm.index].substream = qm.index;
+		ip->asv[qm.index].code = SUB_STREAM_CODE(qm.value);
+		ip->asv[qm.index].height = SUB_STREAM_H(qm.value);
+		ip->asv[qm.index].width = SUB_STREAM_W(qm.value);
+		ip->asv[qm.index].dt = SUB_STREAM_DT(qm.value);
+		ip->asv[qm.index].vc = SUB_STREAM_VC_ID(qm.value);
+		if (ip->asv[qm.index].substream ==
+			(pad_id - NR_OF_CSI2_BE_SOC_SINK_PADS)) {
+			ip->vc = ip->asv[qm.index].vc;
+			flag = true;
+			pr_info("The current entityvc:id:%d\n", ip->vc);
+		}
+	}
+
+	if (flag)
+		return 0;
+
+	return ret;
+}
+
+static int media_pipeline_walk_by_vc(struct ipu_isys_video *av,
+				     struct media_pipeline *pipe)
+{
+	int ret = -ENOLINK;
+	int i;
+	int entity_vc = INVALIA_VC_ID;
+	u32 n;
+	struct media_entity *entity = &av->vdev.entity;
+	struct media_device *mdev = entity->graph_obj.mdev;
+	struct media_graph *graph = &pipe->graph;
+	struct media_entity *entity_err = entity;
+	struct media_link *link;
+	struct ipu_isys_pipeline *ip = to_ipu_isys_pipeline(pipe);
+	struct media_pad *source_pad = media_entity_remote_pad(&av->pad);
+	unsigned int pad_id;
+
+	if (!source_pad) {
+		dev_err(entity->graph_obj.mdev->dev, "no remote pad found\n");
+		return ret;
+	}
+	pad_id = source_pad->index;
+
+	ret = ipu_isys_query_sensor_info(source_pad, ip);
+	if (ret) {
+		dev_err(entity->graph_obj.mdev->dev,
+			"query sensor info failed\n");
+		return ret;
+	}
+
+	if (!pipe->streaming_count++) {
+		ret = media_graph_walk_init(&pipe->graph, mdev);
+		if (ret)
+			goto error_graph_walk_start;
+	}
+
+	media_graph_walk_start(&pipe->graph, entity);
+	while ((entity = media_graph_walk_next(graph))) {
+		DECLARE_BITMAP(active, MEDIA_ENTITY_MAX_PADS);
+		DECLARE_BITMAP(has_no_links, MEDIA_ENTITY_MAX_PADS);
+
+		dev_dbg(entity->graph_obj.mdev->dev, "entity name:%s\n",
+			entity->name);
+
+		entity->stream_count++;
+
+		if (entity->pipe && entity->pipe == pipe) {
+			pr_err("Pipe active for %s. Can't start for %s\n",
+			       entity->name, entity_err->name);
+			ret = -EBUSY;
+			goto error;
+		}
+		/*
+		 * If entity's pipe is not null and it is video device, it has
+		 * be enabled.
+		 */
+		if (entity->pipe && is_media_entity_v4l2_video_device(entity))
+			continue;
+
+		/*
+		 * If it is video device and its vc id is not equal to curren
+		 * video device's vc id, it should continue.
+		 */
+		if (is_media_entity_v4l2_video_device(entity)) {
+			source_pad =
+				media_entity_remote_pad(entity->pads);
+			if (!source_pad) {
+				dev_warn(entity->graph_obj.mdev->dev,
+					 "no remote pad found\n");
+				continue;
+			}
+			pad_id = source_pad->index;
+			for (i = CSI2_BE_SOC_PAD_SOURCE(0);
+			     i < NR_OF_CSI2_BE_SOC_SOURCE_PADS; i++) {
+				if (ip->asv[i - 1].substream ==
+				(pad_id - NR_OF_CSI2_BE_SOC_SINK_PADS)) {
+					entity_vc = ip->asv[i - 1].vc;
+					break;
+				}
+			}
+
+			if (entity_vc != ip->vc)
+				continue;
+		}
+
+		entity->pipe = pipe;
+
+		if (!entity->ops || !entity->ops->link_validate)
+			continue;
+
+		bitmap_zero(active, entity->num_pads);
+		bitmap_fill(has_no_links, entity->num_pads);
+
+		list_for_each_entry(link, &entity->links, list) {
+			struct media_pad *pad = link->sink->entity == entity
+						? link->sink : link->source;
+
+			/* Mark that a pad is connected by a link. */
+			bitmap_clear(has_no_links, pad->index, 1);
+
+			/*
+			 * Pads that either do not need to connect or
+			 * are connected through an enabled link are
+			 * fine.
+			 */
+			if (!(pad->flags & MEDIA_PAD_FL_MUST_CONNECT) ||
+			    link->flags & MEDIA_LNK_FL_ENABLED)
+				bitmap_set(active, pad->index, 1);
+
+			/*
+			 * Link validation will only take place for
+			 * sink ends of the link that are enabled.
+			 */
+			if (link->sink != pad ||
+			    !(link->flags & MEDIA_LNK_FL_ENABLED))
+				continue;
+
+			ret = entity->ops->link_validate(link);
+			if (ret < 0 && ret != -ENOIOCTLCMD) {
+				dev_dbg(entity->graph_obj.mdev->dev,
+					"link failed for %s:%u->%s:%u,ret:%d\n",
+					link->source->entity->name,
+					link->source->index,
+					entity->name, link->sink->index, ret);
+				goto error;
+			}
+		}
+
+		/* Either no links or validated links are fine. */
+		bitmap_or(active, active, has_no_links, entity->num_pads);
+
+		if (!bitmap_full(active, entity->num_pads)) {
+			ret = -ENOLINK;
+			n = (u32)find_first_zero_bit(active, entity->num_pads);
+			dev_dbg(entity->graph_obj.mdev->dev,
+				"%s:%u must be connected by an enabled link\n",
+				entity->name, n);
+			goto error;
+		}
+	}
+
+	return 0;
+
+error:
+	/*
+	 * Link validation on graph failed. We revert what we did and
+	 * return the error.
+	 */
+	media_graph_walk_start(graph, entity_err);
+	while ((entity_err = media_graph_walk_next(graph))) {
+		/* Sanity check for negative stream_count */
+		if (!WARN_ON_ONCE(entity_err->stream_count <= 0)) {
+			entity_err->stream_count--;
+			if (entity_err->stream_count == 0)
+				entity_err->pipe = NULL;
+		}
+
+		/*
+		 * We haven't increased stream_count further than this
+		 * so we quit here.
+		 */
+		if (entity_err == entity)
+			break;
+	}
+
+error_graph_walk_start:
+	if (!--pipe->streaming_count)
+		media_graph_walk_cleanup(graph);
+
+	return ret;
+}
+
+static int media_pipeline_start_by_vc(struct ipu_isys_video *av,
+				      struct media_pipeline *pipe)
+{
+	struct media_device *mdev = av->vdev.entity.graph_obj.mdev;
+	int ret;
+
+	mutex_lock(&mdev->graph_mutex);
+	ret = media_pipeline_walk_by_vc(av, pipe);
+	mutex_unlock(&mdev->graph_mutex);
+
+	return ret;
+}
+
 int ipu_isys_video_prepare_streaming(struct ipu_isys_video *av,
 				     unsigned int state)
 {
@@ -1396,9 +1599,6 @@ int ipu_isys_video_prepare_streaming(struct ipu_isys_video *av,
 	ip->csi2_be = NULL;
 	ip->csi2_be_soc = NULL;
 	ip->csi2 = NULL;
-#ifdef CONFIG_VIDEO_INTEL_IPU_TPG
-	ip->tpg = NULL;
-#endif
 	ip->seq_index = 0;
 	memset(ip->seq, 0, sizeof(ip->seq));
 
@@ -1409,7 +1609,7 @@ int ipu_isys_video_prepare_streaming(struct ipu_isys_video *av,
 	if (rval)
 		return rval;
 
-	rval = media_pipeline_start(&av->vdev.entity, &ip->pipe);
+	rval = media_pipeline_start_by_vc(av, &ip->pipe);
 	if (rval < 0) {
 		dev_dbg(dev, "pipeline start failed\n");
 		goto out_enum_cleanup;
@@ -1427,11 +1627,7 @@ int ipu_isys_video_prepare_streaming(struct ipu_isys_video *av,
 
 	/* Gather all entities in the graph. */
 	mutex_lock(&mdev->graph_mutex);
-	/*
-	 * media_graph_walk_start checks pad instead of entity if virtual
-	 * channel is enabled.
-	 */
-	media_graph_walk_start(&graph, &av->vdev.entity.pads[0]);
+	media_graph_walk_start(&graph, &av->vdev.entity);
 	while ((entity = media_graph_walk_next(&graph)))
 		media_entity_enum_set(&ip->entity_enum, entity);
 
@@ -1462,111 +1658,6 @@ int ipu_isys_video_prepare_streaming(struct ipu_isys_video *av,
 	return rval;
 }
 
-#if defined(IPU_IWAKE_ENABLE)
-static void configure_stream_watermark(struct ipu_isys_video *av)
-{
-	u32 vblank, hblank;
-	u64 pixel_rate;
-	int ret = 0;
-	struct v4l2_subdev *esd;
-	struct v4l2_ctrl *ctrl;
-	struct ipu_isys_pipeline *ip;
-	struct isys_iwake_watermark *iwake_watermark;
-	struct v4l2_control vb = { .id = V4L2_CID_VBLANK, .value = 0 };
-	struct v4l2_control hb = { .id = V4L2_CID_HBLANK, .value = 0 };
-
-	ip = to_ipu_isys_pipeline(av->vdev.entity.pipe);
-	if (!ip->external->entity) {
-		WARN_ON(1);
-		return;
-	}
-	esd = media_entity_to_v4l2_subdev(ip->external->entity);
-
-	av->watermark->width = av->mpix.width;
-	av->watermark->height = av->mpix.height;
-
-	ret = v4l2_g_ctrl(esd->ctrl_handler, &vb);
-	if (!ret && vb.value >= 0)
-		vblank = vb.value;
-	else
-		vblank = 0;
-
-	ret = v4l2_g_ctrl(esd->ctrl_handler, &hb);
-	if (!ret && hb.value >= 0)
-		hblank = hb.value;
-	else
-		hblank = 0;
-
-	ctrl = v4l2_ctrl_find(esd->ctrl_handler, V4L2_CID_PIXEL_RATE);
-
-	if (!ctrl)
-		pixel_rate = DEFAULT_PIXEL_RATE;
-	else
-		pixel_rate = v4l2_ctrl_g_ctrl_int64(ctrl);
-
-	av->watermark->vblank = vblank;
-	av->watermark->hblank = hblank;
-	av->watermark->pixel_rate = pixel_rate;
-	if (!pixel_rate) {
-		iwake_watermark = av->isys->iwake_watermark;
-		mutex_lock(&iwake_watermark->mutex);
-		iwake_watermark->force_iwake_disable = true;
-		mutex_unlock(&iwake_watermark->mutex);
-		WARN(1, "%s Invalid pixel_rate, disable iwake.\n", __func__);
-		return;
-	}
-}
-
-static void calculate_stream_datarate(struct video_stream_watermark *watermark)
-{
-	u64 pixels_per_line, bytes_per_line, line_time_ns;
-	u64 pages_per_line, pb_bytes_per_line, stream_data_rate;
-	u16 sram_granulrity_shift =
-		(ipu_ver == IPU_VER_6 || ipu_ver == IPU_VER_6EP) ?
-		IPU6_SRAM_GRANULRITY_SHIFT : IPU6SE_SRAM_GRANULRITY_SHIFT;
-	u16 sram_granulrity_size =
-		(ipu_ver == IPU_VER_6 || ipu_ver == IPU_VER_6EP) ?
-		IPU6_SRAM_GRANULRITY_SIZE : IPU6SE_SRAM_GRANULRITY_SIZE;
-
-	pixels_per_line = watermark->width + watermark->hblank;
-	line_time_ns =
-		pixels_per_line * 1000 / (watermark->pixel_rate / 1000000);
-	/* 2 bytes per Bayer pixel */
-	bytes_per_line = watermark->width << 1;
-	/* bytes to IS pixel buffer pages */
-	pages_per_line = bytes_per_line >> sram_granulrity_shift;
-
-	/* pages for each line */
-	pages_per_line = DIV_ROUND_UP(bytes_per_line,
-				      sram_granulrity_size);
-	pb_bytes_per_line = pages_per_line << sram_granulrity_shift;
-
-	/* data rate MB/s */
-	stream_data_rate = (pb_bytes_per_line * 1000) / line_time_ns;
-	watermark->stream_data_rate = stream_data_rate;
-}
-
-static void update_stream_watermark(struct ipu_isys_video *av, bool state)
-{
-	struct isys_iwake_watermark *iwake_watermark;
-
-	iwake_watermark = av->isys->iwake_watermark;
-	if (state) {
-		calculate_stream_datarate(av->watermark);
-		mutex_lock(&iwake_watermark->mutex);
-		list_add(&av->watermark->stream_node,
-			 &iwake_watermark->video_list);
-		mutex_unlock(&iwake_watermark->mutex);
-	} else {
-		av->watermark->stream_data_rate = 0;
-		mutex_lock(&iwake_watermark->mutex);
-		list_del(&av->watermark->stream_node);
-		mutex_unlock(&iwake_watermark->mutex);
-	}
-	update_watermark_setting(av->isys);
-}
-#endif
-
 int ipu_isys_video_set_streaming(struct ipu_isys_video *av,
 				 unsigned int state,
 				 struct ipu_isys_buffer_list *bl)
@@ -1580,6 +1671,10 @@ int ipu_isys_video_set_streaming(struct ipu_isys_video *av,
 	    to_ipu_isys_pipeline(av->vdev.entity.pipe);
 	struct v4l2_subdev *sd, *esd;
 	int rval = 0;
+	struct v4l2_ext_control c = {.id = V4L2_CID_IPU_SET_SUB_STREAM, };
+	struct v4l2_ext_controls cs = {.count = 1,
+		.controls = &c,
+	};
 
 	dev_dbg(dev, "set stream: %d\n", state);
 
@@ -1604,19 +1699,17 @@ int ipu_isys_video_set_streaming(struct ipu_isys_video *av,
 		/* stop external sub-device now. */
 		dev_info(dev, "stream off %s\n", ip->external->entity->name);
 
-		if (ip->csi2) {
-			if (ip->csi2->stream_count == 1) {
-				v4l2_subdev_call(esd, video, s_stream, state);
-			}
-		} else {
-			v4l2_subdev_call(esd, video, s_stream, state);
-		}
+		c.value64 = SUB_STREAM_SET_VALUE(ip->vc, state);
+		v4l2_s_ext_ctrls(NULL, esd->ctrl_handler,
+				 esd->devnode,
+				 esd->v4l2_dev->mdev,
+				 &cs);
 	}
 
 	mutex_lock(&mdev->graph_mutex);
 
 	media_graph_walk_start(&ip->graph,
-			       &av->vdev.entity.pads[0]);
+			       &av->vdev.entity);
 
 	while ((entity = media_graph_walk_next(&ip->graph))) {
 		sd = media_entity_to_v4l2_subdev(entity);
@@ -1646,14 +1739,6 @@ int ipu_isys_video_set_streaming(struct ipu_isys_video *av,
 
 	mutex_unlock(&mdev->graph_mutex);
 
-#if defined(IPU_IWAKE_ENABLE)
-	if (av->aq.css_pin_type == IPU_FW_ISYS_PIN_TYPE_RAW_SOC) {
-		if (state)
-			configure_stream_watermark(av);
-		update_stream_watermark(av, state);
-	}
-#endif
-
 	/* Oh crap */
 	if (state) {
 		rval = start_stream_firmware(av, bl);
@@ -1666,17 +1751,16 @@ int ipu_isys_video_set_streaming(struct ipu_isys_video *av,
 		/* Start external sub-device now. */
 		dev_info(dev, "stream on %s\n", ip->external->entity->name);
 
-		if (ip->csi2 &&
-		    ip->csi2->remote_streams == ip->csi2->stream_count)
-			rval = v4l2_subdev_call(esd, video, s_stream, state);
-		else if (!ip->csi2)
-			rval = v4l2_subdev_call(esd, video, s_stream, state);
+		c.value64 = SUB_STREAM_SET_VALUE(ip->vc, state);
+		rval = v4l2_s_ext_ctrls(NULL, esd->ctrl_handler,
+					esd->devnode,
+					esd->v4l2_dev->mdev,
+					&cs);
 		if (rval)
 			goto out_media_entity_stop_streaming_firmware;
 	} else {
 		close_streaming_firmware(av);
-		av->ip.stream_id = 0;
-		av->ip.vc = 0;
+		av->ip.vc = INVALIA_VC_ID;
 	}
 
 	if (state)
@@ -1694,7 +1778,7 @@ int ipu_isys_video_set_streaming(struct ipu_isys_video *av,
 	mutex_lock(&mdev->graph_mutex);
 
 	media_graph_walk_start(&ip->graph,
-			       &av->vdev.entity.pads[0]);
+			       &av->vdev.entity);
 
 	while (state && (entity2 = media_graph_walk_next(&ip->graph)) &&
 	       entity2 != entity) {
@@ -1783,6 +1867,7 @@ int ipu_isys_video_init(struct ipu_isys_video *av,
 {
 	const struct v4l2_ioctl_ops *ioctl_ops = NULL;
 	int rval;
+	int i;
 
 	mutex_init(&av->mutex);
 	init_completion(&av->ip.stream_open_completion);
@@ -1792,19 +1877,14 @@ int ipu_isys_video_init(struct ipu_isys_video *av,
 	INIT_LIST_HEAD(&av->ip.queues);
 	spin_lock_init(&av->ip.short_packet_queue_lock);
 	av->ip.isys = av->isys;
-	av->ip.stream_id = 0;
-	av->ip.vc = 0;
-	av->reset = false;
-
-#if defined(IPU_IWAKE_ENABLE)
-	if (!av->watermark) {
-		av->watermark = kzalloc(sizeof(*av->watermark), GFP_KERNEL);
-		if (!av->watermark) {
-			rval = -ENOMEM;
-			goto out_mutex_destroy;
-		}
+	av->ip.vc = INVALIA_VC_ID;
+	for (i = 0; i < NR_OF_CSI2_BE_SOC_SOURCE_PADS; i++) {
+		memset(&av->ip.asv[i], 0,
+		       sizeof(struct ipu_isys_sub_stream_vc));
+		av->ip.asv[i].vc = INVALIA_VC_ID;
 	}
-#endif
+	av->reset = false;
+	av->skipframe = 0;
 
 	av->vdev.device_caps = V4L2_CAP_STREAMING;
 	if (pad_flags & MEDIA_PAD_FL_SINK) {
@@ -1869,9 +1949,6 @@ int ipu_isys_video_init(struct ipu_isys_video *av,
 	ipu_isys_queue_cleanup(&av->aq);
 
 out_mutex_destroy:
-#if defined(IPU_IWAKE_ENABLE)
-	kfree(av->watermark);
-#endif
 	mutex_destroy(&av->mutex);
 
 	return rval;
@@ -1879,9 +1956,6 @@ int ipu_isys_video_init(struct ipu_isys_video *av,
 
 void ipu_isys_video_cleanup(struct ipu_isys_video *av)
 {
-#if defined(IPU_IWAKE_ENABLE)
-	kfree(av->watermark);
-#endif
 	video_unregister_device(&av->vdev);
 	media_entity_cleanup(&av->vdev.entity);
 	mutex_destroy(&av->mutex);
diff --git a/drivers/media/pci/intel/ipu-isys-video.h b/drivers/media/pci/intel/ipu-isys-video.h
index 46b812e3399e..bb05c19dc5f8 100644
--- a/drivers/media/pci/intel/ipu-isys-video.h
+++ b/drivers/media/pci/intel/ipu-isys-video.h
@@ -1,5 +1,5 @@
 /* SPDX-License-Identifier: GPL-2.0 */
-/* Copyright (C) 2013 - 2020 Intel Corporation */
+/* Copyright (C) 2013 - 2022 Intel Corporation */
 
 #ifndef IPU_ISYS_VIDEO_H
 #define IPU_ISYS_VIDEO_H
@@ -12,10 +12,12 @@
 #include <media/v4l2-subdev.h>
 
 #include "ipu-isys-queue.h"
+#include "ipu-platform-isys.h"
 
 #define IPU_ISYS_OUTPUT_PINS 11
 #define IPU_NUM_CAPTURE_DONE 2
 #define IPU_ISYS_MAX_PARALLEL_SOF 2
+#define CSI2_BE_SOC_SOURCE_PADS_NUM NR_OF_CSI2_BE_SOC_STREAMS
 
 struct ipu_isys;
 struct ipu_isys_csi2_be_soc;
@@ -41,6 +43,26 @@ struct output_pin_data {
 	struct ipu_isys_queue *aq;
 };
 
+/*
+ * struct ipu_isys_sub_stream_vc
+ */
+struct ipu_isys_sub_stream_vc {
+	unsigned int substream;	/* sub stream id */
+	int vc;	/* VC number */
+	u32 width;
+	u32 height;
+	unsigned int dt;
+	unsigned int code;
+};
+
+#define SUB_STREAM_CODE(value) ((value) & 0xFFFF)
+#define SUB_STREAM_H(value) (((value) >> 16) & 0xFFFF)
+#define SUB_STREAM_W(value) (((value) >> 32) & 0xFFFF)
+#define SUB_STREAM_DT(value) (((value) >> 48) & 0xFF)
+#define SUB_STREAM_VC_ID(value) ((value) >> 56 & 0xFF)
+#define SUB_STREAM_SET_VALUE(vc_id, stream_state) \
+	((((vc_id) << 8) & 0xFF00) | (stream_state))
+
 struct ipu_isys_pipeline {
 	struct media_pipeline pipe;
 	struct media_pad *external;
@@ -54,14 +76,12 @@ struct ipu_isys_pipeline {
 	struct ipu_isys_csi2_be *csi2_be;
 	struct ipu_isys_csi2_be_soc *csi2_be_soc;
 	struct ipu_isys_csi2 *csi2;
-#ifdef CONFIG_VIDEO_INTEL_IPU_TPG
-	struct ipu_isys_tpg *tpg;
-#endif
 
 	/*
 	 * Number of capture queues, write access serialised using struct
 	 * ipu_isys.stream_mutex
 	 */
+	/* If it supports vc, this is number of links for the same vc. */
 	int nr_queues;
 	int nr_streaming;	/* Number of capture queues streaming */
 	int streaming;	/* Has streaming been really started? */
@@ -90,28 +110,15 @@ struct ipu_isys_pipeline {
 	spinlock_t short_packet_queue_lock;
 	struct list_head pending_interlaced_bufs;
 	unsigned int short_packet_trace_index;
-	unsigned int vc;
-	unsigned int stream_id;
 	struct media_graph graph;
 	struct media_entity_enum entity_enum;
+	unsigned int vc;
+	struct ipu_isys_sub_stream_vc asv[CSI2_BE_SOC_SOURCE_PADS_NUM];
 };
 
 #define to_ipu_isys_pipeline(__pipe)				\
 	container_of((__pipe), struct ipu_isys_pipeline, pipe)
 
-#if defined(IPU_IWAKE_ENABLE)
-struct video_stream_watermark {
-	u32 width;
-	u32 height;
-	u32 vblank;
-	u32 hblank;
-	u32 frame_rate;
-	u64 pixel_rate;
-	u64 stream_data_rate;
-	struct list_head stream_node;
-};
-#endif
-
 struct ipu_isys_video {
 	/* Serialise access to other fields in the struct. */
 	struct mutex mutex;
@@ -125,20 +132,15 @@ struct ipu_isys_video {
 	struct ipu_isys_pipeline ip;
 	unsigned int streaming;
 	unsigned int reset;
+	unsigned int skipframe;
 	bool packed;
-#if defined(IPU_ISYS_COMPRESSION)
 	bool compression;
 	struct v4l2_ctrl_handler ctrl_handler;
 	struct v4l2_ctrl *compression_ctrl;
 	unsigned int ts_offsets[VIDEO_MAX_PLANES];
-#endif
 	unsigned int line_header_length;	/* bits */
 	unsigned int line_footer_length;	/* bits */
 
-#if defined(IPU_IWAKE_ENABLE)
-	struct video_stream_watermark *watermark;
-#endif
-
 	const struct ipu_isys_pixelformat *
 		(*try_fmt_vid_mplane)(struct ipu_isys_video *av,
 				      struct v4l2_pix_format_mplane *mpix);
diff --git a/drivers/media/pci/intel/ipu-isys.c b/drivers/media/pci/intel/ipu-isys.c
index 1c1908fd36ef..6ccd39236587 100644
--- a/drivers/media/pci/intel/ipu-isys.c
+++ b/drivers/media/pci/intel/ipu-isys.c
@@ -16,6 +16,14 @@
 #include <media/ipu-isys.h>
 #include <media/v4l2-mc.h>
 #include <media/v4l2-subdev.h>
+#if !IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA)
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-event.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-async.h>
+#endif
 #include "ipu.h"
 #include "ipu-bus.h"
 #include "ipu-cpd.h"
@@ -23,9 +31,6 @@
 #include "ipu-dma.h"
 #include "ipu-isys.h"
 #include "ipu-isys-csi2.h"
-#ifdef CONFIG_VIDEO_INTEL_IPU_TPG
-#include "ipu-isys-tpg.h"
-#endif
 #include "ipu-isys-video.h"
 #include "ipu-platform-regs.h"
 #include "ipu-buttress.h"
@@ -33,6 +38,7 @@
 #include "ipu-platform-buttress-regs.h"
 
 #define ISYS_PM_QOS_VALUE	300
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA)
 /*
  * The param was passed from module to indicate if port
  * could be optimized.
@@ -40,62 +46,9 @@
 static bool csi2_port_optimized = true;
 module_param(csi2_port_optimized, bool, 0660);
 MODULE_PARM_DESC(csi2_port_optimized, "IPU CSI2 port optimization");
-
-#if defined(IPU_IWAKE_ENABLE)
-#define IPU_BUTTRESS_FABIC_CONTROL	    0x68
-#define GDA_ENABLE_IWAKE_INDEX		    2
-#define GDA_IWAKE_THRESHOLD_INDEX           1
-#define GDA_IRQ_CRITICAL_THRESHOLD_INDEX    0
-
-/* LTR & DID value are 10 bit at most */
-#define LTR_DID_VAL_MAX		1023
-#define LTR_DEFAULT_VALUE	0x70503C19
-#define FILL_TIME_DEFAULT_VALUE 0xFFF0783C
-#define LTR_DID_PKGC_2R		20
-#define LTR_DID_PKGC_8		100
-#define LTR_SCALE_DEFAULT	5
-#define LTR_SCALE_1024NS	2
-#define REG_PKGC_PMON_CFG	0xB00
-
-#define VAL_PKGC_PMON_CFG_RESET 0x38
-#define VAL_PKGC_PMON_CFG_START 0x7
-
-#define IS_PIXEL_BUFFER_PAGES		0x80
-/* BIOS provides the driver the LTR and threshold information in IPU,
- * IS pixel buffer is 256KB, MaxSRAMSize is 200KB on IPU6.
- */
-#define IPU6_MAX_SRAM_SIZE			(200 << 10)
-/* IS pixel buffer is 128KB, MaxSRAMSize is 96KB on IPU6SE.
- */
-#define IPU6SE_MAX_SRAM_SIZE			(96 << 10)
-/* When iwake mode is disabled the critical threshold is statically set to 75%
- * of the IS pixel buffer criticalThreshold = (128 * 3) / 4
- */
-#define CRITICAL_THRESHOLD_IWAKE_DISABLE	(IS_PIXEL_BUFFER_PAGES * 3 / 4)
-
-union fabric_ctrl {
-	struct {
-		u16 ltr_val   : 10;
-		u16 ltr_scale : 3;
-		u16 RSVD1     : 3;
-		u16 did_val   : 10;
-		u16 did_scale : 3;
-		u16 RSVD2     : 1;
-		u16 keep_power_in_D0   : 1;
-		u16 keep_power_override : 1;
-	} bits;
-	u32 value;
-};
-
-enum ltr_did_type {
-	LTR_IWAKE_ON,
-	LTR_IWAKE_OFF,
-	LTR_ISYS_ON,
-	LTR_ISYS_OFF,
-	LTR_TYPE_MAX
-};
 #endif
 
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA)
 struct isys_i2c_test {
 	u8 bus_nr;
 	u16 addr;
@@ -135,6 +88,7 @@ i2c_client *isys_find_i2c_subdev(struct i2c_adapter *adapter,
 		return NULL;
 	return test.client;
 }
+#endif
 static int
 isys_complete_ext_device_registration(struct ipu_isys *isys,
 				      struct v4l2_subdev *sd,
@@ -172,7 +126,7 @@ isys_complete_ext_device_registration(struct ipu_isys *isys,
 	v4l2_device_unregister_subdev(sd);
 	return rval;
 }
-
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA)
 static int isys_register_ext_subdev(struct ipu_isys *isys,
 				    struct ipu_isys_subdev_info *sd_info)
 {
@@ -252,24 +206,17 @@ static void isys_register_ext_subdevs(struct ipu_isys *isys)
 	for (sd_info = spdata->subdevs; *sd_info; sd_info++)
 		isys_register_ext_subdev(isys, *sd_info);
 }
+#endif
 
 static void isys_unregister_subdevices(struct ipu_isys *isys)
 {
-#ifdef CONFIG_VIDEO_INTEL_IPU_TPG
-	const struct ipu_isys_internal_tpg_pdata *tpg =
-	    &isys->pdata->ipdata->tpg;
-#endif
 	const struct ipu_isys_internal_csi2_pdata *csi2 =
 	    &isys->pdata->ipdata->csi2;
 	unsigned int i;
 
 	ipu_isys_csi2_be_cleanup(&isys->csi2_be);
-	ipu_isys_csi2_be_soc_cleanup(&isys->csi2_be_soc);
-
-#ifdef CONFIG_VIDEO_INTEL_IPU_TPG
-	for (i = 0; i < tpg->ntpgs; i++)
-		ipu_isys_tpg_cleanup(&isys->tpg[i]);
-#endif
+	for (i = 0; i < NR_OF_CSI2_BE_SOC_DEV; i++)
+		ipu_isys_csi2_be_soc_cleanup(&isys->csi2_be_soc[i]);
 
 	for (i = 0; i < csi2->nports; i++)
 		ipu_isys_csi2_cleanup(&isys->csi2[i]);
@@ -277,18 +224,18 @@ static void isys_unregister_subdevices(struct ipu_isys *isys)
 
 static int isys_register_subdevices(struct ipu_isys *isys)
 {
-#ifdef CONFIG_VIDEO_INTEL_IPU_TPG
-	const struct ipu_isys_internal_tpg_pdata *tpg =
-	    &isys->pdata->ipdata->tpg;
-#endif
 	const struct ipu_isys_internal_csi2_pdata *csi2 =
 	    &isys->pdata->ipdata->csi2;
+	struct ipu_isys_csi2_be_soc *csi2_be_soc;
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA)
 	struct ipu_isys_subdev_pdata *spdata = isys->pdata->spdata;
 	struct ipu_isys_subdev_info **sd_info;
 	DECLARE_BITMAP(csi2_enable, 32);
-	unsigned int i, j, k;
+#endif
+	unsigned int i, k;
 	int rval;
 
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA)
 	/*
 	 * Here is somewhat a workaround, let each platform decide
 	 * if csi2 port can be optimized, which means only registered
@@ -310,6 +257,7 @@ static int isys_register_subdevices(struct ipu_isys *isys)
 	} else {
 		bitmap_fill(csi2_enable, 32);
 	}
+#endif
 	isys->csi2 = devm_kcalloc(&isys->adev->dev, csi2->nports,
 				  sizeof(*isys->csi2), GFP_KERNEL);
 	if (!isys->csi2) {
@@ -318,8 +266,10 @@ static int isys_register_subdevices(struct ipu_isys *isys)
 	}
 
 	for (i = 0; i < csi2->nports; i++) {
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA)
 		if (!test_bit(i, csi2_enable))
 			continue;
+#endif
 		rval = ipu_isys_csi2_init(&isys->csi2[i], isys,
 					  isys->pdata->base +
 					  csi2->offsets[i], i);
@@ -329,30 +279,14 @@ static int isys_register_subdevices(struct ipu_isys *isys)
 		isys->isr_csi2_bits |= IPU_ISYS_UNISPART_IRQ_CSI2(i);
 	}
 
-#ifdef CONFIG_VIDEO_INTEL_IPU_TPG
-	isys->tpg = devm_kcalloc(&isys->adev->dev, tpg->ntpgs,
-				 sizeof(*isys->tpg), GFP_KERNEL);
-	if (!isys->tpg) {
-		rval = -ENOMEM;
-		goto fail;
-	}
-
-	for (i = 0; i < tpg->ntpgs; i++) {
-		rval = ipu_isys_tpg_init(&isys->tpg[i], isys,
-					 isys->pdata->base +
-					 tpg->offsets[i],
-					 tpg->sels ? (isys->pdata->base +
-						      tpg->sels[i]) : NULL, i);
-		if (rval)
+	for (k = 0; k < NR_OF_CSI2_BE_SOC_DEV; k++) {
+		rval = ipu_isys_csi2_be_soc_init(&isys->csi2_be_soc[k],
+						 isys, k);
+		if (rval) {
+			dev_info(&isys->adev->dev,
+				 "can't register csi2 soc be device %d\n", k);
 			goto fail;
-	}
-#endif
-
-	rval = ipu_isys_csi2_be_soc_init(&isys->csi2_be_soc, isys);
-	if (rval) {
-		dev_info(&isys->adev->dev,
-			 "can't register csi2 soc be device\n");
-		goto fail;
+		}
 	}
 
 	rval = ipu_isys_csi2_be_init(&isys->csi2_be, isys);
@@ -363,66 +297,33 @@ static int isys_register_subdevices(struct ipu_isys *isys)
 	}
 
 	for (i = 0; i < csi2->nports; i++) {
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA)
 		if (!test_bit(i, csi2_enable))
 			continue;
-		for (j = CSI2_PAD_SOURCE(0);
-		     j < (NR_OF_CSI2_SOURCE_PADS + CSI2_PAD_SOURCE(0)); j++) {
-			rval =
-			    media_create_pad_link(&isys->csi2[i].asd.sd.entity,
-						  j,
-						  &isys->csi2_be.asd.sd.entity,
-						  CSI2_BE_PAD_SINK, 0);
-			if (rval) {
-				dev_info(&isys->adev->dev,
-					 "can't create link csi2 <=> csi2_be\n");
-				goto fail;
-			}
-
-			for (k = CSI2_BE_SOC_PAD_SINK(0);
-			     k < NR_OF_CSI2_BE_SOC_SINK_PADS; k++) {
-				rval =
-				    media_create_pad_link(&isys->csi2[i].asd.sd.
-							  entity, j,
-							  &isys->csi2_be_soc.
-							  asd.sd.entity, k,
-							  MEDIA_LNK_FL_DYNAMIC);
-				if (rval) {
-					dev_info(&isys->adev->dev,
-						 "can't create link csi2->be_soc\n");
-					goto fail;
-				}
-			}
-		}
-	}
-
-#ifdef CONFIG_VIDEO_INTEL_IPU_TPG
-	for (i = 0; i < tpg->ntpgs; i++) {
-		rval = media_create_pad_link(&isys->tpg[i].asd.sd.entity,
-					     TPG_PAD_SOURCE,
+#endif
+		rval = media_create_pad_link(&isys->csi2[i].asd.sd.entity,
+					     CSI2_PAD_SOURCE,
 					     &isys->csi2_be.asd.sd.entity,
 					     CSI2_BE_PAD_SINK, 0);
 		if (rval) {
 			dev_info(&isys->adev->dev,
-				 "can't create link between tpg and csi2_be\n");
+				 "can't create link csi2 <=> csi2_be\n");
 			goto fail;
 		}
-
-		for (k = CSI2_BE_SOC_PAD_SINK(0);
-		     k < NR_OF_CSI2_BE_SOC_SINK_PADS; k++) {
+		for (k = 0; k < NR_OF_CSI2_BE_SOC_DEV; k++) {
+			csi2_be_soc = &isys->csi2_be_soc[k];
 			rval =
-			    media_create_pad_link(&isys->tpg[i].asd.sd.entity,
-						  TPG_PAD_SOURCE,
-						  &isys->csi2_be_soc.asd.sd.
-						  entity, k,
-						  MEDIA_LNK_FL_DYNAMIC);
+			    media_create_pad_link(&isys->csi2[i].asd.sd.entity,
+						  CSI2_PAD_SOURCE,
+						  &csi2_be_soc->asd.sd.entity,
+						  CSI2_BE_SOC_PAD_SINK, 0);
 			if (rval) {
 				dev_info(&isys->adev->dev,
-					 "can't create link tpg->be_soc\n");
+					 "can't create link csi2->be_soc\n");
 				goto fail;
 			}
 		}
 	}
-#endif
 
 	return 0;
 
@@ -431,256 +332,100 @@ static int isys_register_subdevices(struct ipu_isys *isys)
 	return rval;
 }
 
-#if defined(IPU_IWAKE_ENABLE)
-/* read ltrdid threshold values from BIOS or system configuration */
-static void get_lut_ltrdid(struct ipu_isys *isys, struct ltr_did *pltr_did)
+#if !IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA)
+/* The .bound() notifier callback when a match is found */
+static int isys_notifier_bound(struct v4l2_async_notifier *notifier,
+			       struct v4l2_subdev *sd,
+			       struct v4l2_async_subdev *asd)
 {
-	struct isys_iwake_watermark *iwake_watermark = isys->iwake_watermark;
-	/* default values*/
-	struct ltr_did ltrdid_default;
+	struct ipu_isys *isys = container_of(notifier,
+					struct ipu_isys, notifier);
+	struct sensor_async_subdev *s_asd = container_of(asd,
+					struct sensor_async_subdev, asd);
 
-	ltrdid_default.lut_ltr.value = LTR_DEFAULT_VALUE;
-	ltrdid_default.lut_fill_time.value = FILL_TIME_DEFAULT_VALUE;
+	dev_info(&isys->adev->dev, "bind %s nlanes is %d port is %d\n",
+		 sd->name, s_asd->csi2.nlanes, s_asd->csi2.port);
+	isys_complete_ext_device_registration(isys, sd, &s_asd->csi2);
 
-	if (iwake_watermark->ltrdid.lut_ltr.value)
-		*pltr_did = iwake_watermark->ltrdid;
-	else
-		*pltr_did = ltrdid_default;
+	return v4l2_device_register_subdev_nodes(&isys->v4l2_dev);
 }
 
-static int set_iwake_register(struct ipu_isys *isys, u32 index, u32 value)
+static void isys_notifier_unbind(struct v4l2_async_notifier *notifier,
+				 struct v4l2_subdev *sd,
+				 struct v4l2_async_subdev *asd)
 {
-	int ret = 0;
-	u32 req_id = index;
-	u32 offset = 0;
+	struct ipu_isys *isys = container_of(notifier,
+					struct ipu_isys, notifier);
 
-	ret = ipu_fw_isys_send_proxy_token(isys, req_id, index, offset, value);
-	if (ret)
-		dev_err(&isys->adev->dev, "write %d failed %d", index, ret);
-
-	return ret;
+	dev_info(&isys->adev->dev, "unbind %s\n", sd->name);
 }
 
-/*
- * When input system is powered up and before enabling any new sensor capture,
- * or after disabling any sensor capture the following values need to be set:
- * LTR_value = LTR(usec) from calculation;
- * LTR_scale = 2;
- * DID_value = DID(usec) from calculation;
- * DID_scale = 2;
- *
- * When input system is powered down, the LTR and DID values
- * must be returned to the default values:
- * LTR_value = 1023;
- * LTR_scale = 5;
- * DID_value = 1023;
- * DID_scale = 2;
- */
-static void set_iwake_ltrdid(struct ipu_isys *isys,
-			     u16 ltr,
-			     u16 did,
-			     enum ltr_did_type use)
+static int isys_notifier_complete(struct v4l2_async_notifier *notifier)
 {
-	/* did_scale will set to 2= 1us */
-	u16 ltr_val, ltr_scale, did_val;
-	union fabric_ctrl fc;
-	struct ipu_device *isp = isys->adev->isp;
+	struct ipu_isys *isys = container_of(notifier,
+					struct ipu_isys, notifier);
 
-	switch (use) {
-	case LTR_IWAKE_ON:
-		ltr_val = min_t(u16, ltr, (u16)LTR_DID_VAL_MAX);
-		did_val = min_t(u16, did, (u16)LTR_DID_VAL_MAX);
-		ltr_scale = (ltr == LTR_DID_VAL_MAX &&
-				did == LTR_DID_VAL_MAX) ?
-				LTR_SCALE_DEFAULT : LTR_SCALE_1024NS;
-		break;
-	case LTR_ISYS_ON:
-	case LTR_IWAKE_OFF:
-		ltr_val = LTR_DID_PKGC_2R;
-		did_val = LTR_DID_PKGC_2R;
-		ltr_scale = LTR_SCALE_1024NS;
-		break;
-	case LTR_ISYS_OFF:
-		ltr_val   = LTR_DID_VAL_MAX;
-		did_val   = LTR_DID_VAL_MAX;
-		ltr_scale = LTR_SCALE_DEFAULT;
-		break;
-	default:
-		return;
-	}
+	dev_info(&isys->adev->dev, "All sensor registration completed.\n");
 
-	fc.value = readl(isp->base + IPU_BUTTRESS_FABIC_CONTROL);
-	fc.bits.ltr_val = ltr_val;
-	fc.bits.ltr_scale = ltr_scale;
-	fc.bits.did_val = did_val;
-	fc.bits.did_scale = 2;
-	dev_dbg(&isys->adev->dev,
-		"%s ltr: %d  did: %d", __func__, ltr_val, did_val);
-	writel(fc.value, isp->base + IPU_BUTTRESS_FABIC_CONTROL);
+	return v4l2_device_register_subdev_nodes(&isys->v4l2_dev);
 }
 
-/* SW driver may clear register GDA_ENABLE_IWAKE before the FW configures the
- * stream for debug purposes. Otherwise SW should not access this register.
- */
-static int enable_iwake(struct ipu_isys *isys, bool enable)
-{
-	int ret = 0;
-	struct isys_iwake_watermark *iwake_watermark = isys->iwake_watermark;
-
-	mutex_lock(&iwake_watermark->mutex);
-	if (iwake_watermark->iwake_enabled == enable) {
-		mutex_unlock(&iwake_watermark->mutex);
-		return ret;
-	}
-	ret = set_iwake_register(isys, GDA_ENABLE_IWAKE_INDEX, enable);
-	if (!ret)
-		iwake_watermark->iwake_enabled = enable;
-	mutex_unlock(&iwake_watermark->mutex);
-	return ret;
-}
+static const struct v4l2_async_notifier_operations isys_async_ops = {
+	.bound = isys_notifier_bound,
+	.unbind = isys_notifier_unbind,
+	.complete = isys_notifier_complete,
+};
 
-void update_watermark_setting(struct ipu_isys *isys)
+static int isys_fwnode_parse(struct device *dev,
+			     struct v4l2_fwnode_endpoint *vep,
+			     struct v4l2_async_subdev *asd)
 {
-	struct isys_iwake_watermark *iwake_watermark = isys->iwake_watermark;
-	struct list_head *stream_node;
-	struct video_stream_watermark *p_watermark;
-	struct ltr_did ltrdid;
-	u16 calc_fill_time_us = 0;
-	u16 ltr = 0;
-	u16 did = 0;
-	u32 iwake_threshold, iwake_critical_threshold;
-	u64 threshold_bytes;
-	u64 isys_pb_datarate_mbs = 0;
-	u16 sram_granulrity_shift =
-		(ipu_ver == IPU_VER_6 || ipu_ver == IPU_VER_6EP) ?
-		IPU6_SRAM_GRANULRITY_SHIFT : IPU6SE_SRAM_GRANULRITY_SHIFT;
-	int max_sram_size =
-		(ipu_ver == IPU_VER_6 || ipu_ver == IPU_VER_6EP) ?
-		IPU6_MAX_SRAM_SIZE : IPU6SE_MAX_SRAM_SIZE;
-
-	mutex_lock(&iwake_watermark->mutex);
-	if (iwake_watermark->force_iwake_disable) {
-		set_iwake_ltrdid(isys, 0, 0, LTR_IWAKE_OFF);
-		set_iwake_register(isys, GDA_IRQ_CRITICAL_THRESHOLD_INDEX,
-				   CRITICAL_THRESHOLD_IWAKE_DISABLE);
-		mutex_unlock(&iwake_watermark->mutex);
-		return;
-	}
-
-	if (list_empty(&iwake_watermark->video_list)) {
-		isys_pb_datarate_mbs = 0;
-	} else {
-		list_for_each(stream_node, &iwake_watermark->video_list)
-		{
-			p_watermark = list_entry(stream_node,
-						 struct video_stream_watermark,
-						 stream_node);
-			isys_pb_datarate_mbs += p_watermark->stream_data_rate;
-		}
-	}
-	mutex_unlock(&iwake_watermark->mutex);
-
-	if (!isys_pb_datarate_mbs) {
-		enable_iwake(isys, false);
-		set_iwake_ltrdid(isys, 0, 0, LTR_IWAKE_OFF);
-		mutex_lock(&iwake_watermark->mutex);
-		set_iwake_register(isys, GDA_IRQ_CRITICAL_THRESHOLD_INDEX,
-				   CRITICAL_THRESHOLD_IWAKE_DISABLE);
-		mutex_unlock(&iwake_watermark->mutex);
-	} else {
-		/* should enable iwake by default according to FW */
-		enable_iwake(isys, true);
-		calc_fill_time_us = (u16)(max_sram_size / isys_pb_datarate_mbs);
-		get_lut_ltrdid(isys, &ltrdid);
-
-		if (calc_fill_time_us <= ltrdid.lut_fill_time.bits.th0)
-			ltr = 0;
-		else if (calc_fill_time_us <= ltrdid.lut_fill_time.bits.th1)
-			ltr = ltrdid.lut_ltr.bits.val0;
-		else if (calc_fill_time_us <= ltrdid.lut_fill_time.bits.th2)
-			ltr = ltrdid.lut_ltr.bits.val1;
-		else if (calc_fill_time_us <= ltrdid.lut_fill_time.bits.th3)
-			ltr = ltrdid.lut_ltr.bits.val2;
-		else
-			ltr = ltrdid.lut_ltr.bits.val3;
-
-		did = calc_fill_time_us - ltr;
-#ifdef IPU_IWAKE_TUNING
-		if (iwake_watermark->ltrdid_setting) {
-			ltr = min_t(u16, LTR_DID_VAL_MAX,
-				    iwake_watermark->ltrdid_setting & 0xFFFF);
-			did = min_t(u16, LTR_DID_VAL_MAX,
-				    iwake_watermark->ltrdid_setting >> 16 &
-				    0xFFFF);
-		}
-#endif
+	struct sensor_async_subdev *s_asd =
+			container_of(asd, struct sensor_async_subdev, asd);
 
-		threshold_bytes = did * isys_pb_datarate_mbs;
-		/* calculate iwake threshold with 2KB granularity pages */
-		iwake_threshold =
-			max_t(u32, 1, threshold_bytes >> sram_granulrity_shift);
+	s_asd->csi2.port = vep->base.port;
+	s_asd->csi2.nlanes = vep->bus.mipi_csi2.num_data_lanes;
 
-		iwake_threshold = min_t(u32, iwake_threshold, max_sram_size);
-
-		/* set the critical threshold to halfway between
-		 * iwake threshold and the full buffer.
-		 */
-		iwake_critical_threshold = iwake_threshold +
-			(IS_PIXEL_BUFFER_PAGES - iwake_threshold) / 2;
-
-		dev_dbg(&isys->adev->dev, "%s threshold: %u  critical: %u",
-			__func__, iwake_threshold, iwake_critical_threshold);
-		set_iwake_ltrdid(isys, ltr, did, LTR_IWAKE_ON);
-		mutex_lock(&iwake_watermark->mutex);
-		set_iwake_register(isys,
-				   GDA_IWAKE_THRESHOLD_INDEX, iwake_threshold);
-
-		set_iwake_register(isys,
-				   GDA_IRQ_CRITICAL_THRESHOLD_INDEX,
-				   iwake_critical_threshold);
-		mutex_unlock(&iwake_watermark->mutex);
-
-		writel(VAL_PKGC_PMON_CFG_RESET,
-		       isys->adev->isp->base + REG_PKGC_PMON_CFG);
-		writel(VAL_PKGC_PMON_CFG_START,
-		       isys->adev->isp->base + REG_PKGC_PMON_CFG);
-	}
+	return 0;
 }
 
-static int isys_iwake_watermark_init(struct ipu_isys *isys)
+static int isys_notifier_init(struct ipu_isys *isys)
 {
-	struct isys_iwake_watermark *iwake_watermark;
+	struct ipu_device *isp = isys->adev->isp;
+	size_t asd_struct_size = sizeof(struct sensor_async_subdev);
+	int ret;
 
-	if (isys->iwake_watermark)
+	v4l2_async_nf_init(&isys->notifier);
+	ret = v4l2_async_nf_parse_fwnode_endpoints(&isp->pdev->dev,
+						   &isys->notifier,
+						   asd_struct_size,
+						   isys_fwnode_parse);
+	if (ret < 0) {
+		dev_err(&isys->adev->dev,
+			"v4l2 parse_fwnode_endpoints() failed: %d\n", ret);
+		return ret;
+	}
+	if (list_empty(&isys->notifier.asd_list)) {
+		/* isys probe could continue with async subdevs missing */
+		dev_warn(&isys->adev->dev, "no subdev found in graph\n");
 		return 0;
+	}
 
-	iwake_watermark = devm_kzalloc(&isys->adev->dev,
-				       sizeof(*iwake_watermark), GFP_KERNEL);
-	if (!iwake_watermark)
-		return -ENOMEM;
-	INIT_LIST_HEAD(&iwake_watermark->video_list);
-	mutex_init(&iwake_watermark->mutex);
-
-	iwake_watermark->ltrdid.lut_ltr.value = 0;
-	isys->iwake_watermark = iwake_watermark;
-	iwake_watermark->isys = isys;
-	iwake_watermark->iwake_enabled = false;
-	iwake_watermark->force_iwake_disable = false;
-	return 0;
+	isys->notifier.ops = &isys_async_ops;
+	ret = v4l2_async_nf_register(&isys->v4l2_dev, &isys->notifier);
+	if (ret) {
+		dev_err(&isys->adev->dev,
+			"failed to register async notifier : %d\n", ret);
+		v4l2_async_nf_cleanup(&isys->notifier);
+	}
+
+	return ret;
 }
 
-static int isys_iwake_watermark_cleanup(struct ipu_isys *isys)
+static void isys_notifier_cleanup(struct ipu_isys *isys)
 {
-	struct isys_iwake_watermark *iwake_watermark = isys->iwake_watermark;
-
-	if (!iwake_watermark)
-		return -EINVAL;
-	mutex_lock(&iwake_watermark->mutex);
-	list_del(&iwake_watermark->video_list);
-	mutex_unlock(&iwake_watermark->mutex);
-	mutex_destroy(&iwake_watermark->mutex);
-	isys->iwake_watermark = NULL;
-	return 0;
+	v4l2_async_nf_unregister(&isys->notifier);
+	v4l2_async_nf_cleanup(&isys->notifier);
 }
 #endif
 
@@ -721,7 +466,13 @@ static int isys_register_devices(struct ipu_isys *isys)
 	if (rval)
 		goto out_v4l2_device_unregister;
 
+#if !IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA)
+	rval = isys_notifier_init(isys);
+	if (rval)
+		goto out_isys_unregister_subdevices;
+#else
 	isys_register_ext_subdevs(isys);
+#endif
 
 	rval = v4l2_device_register_subdev_nodes(&isys->v4l2_dev);
 	if (rval)
@@ -730,8 +481,16 @@ static int isys_register_devices(struct ipu_isys *isys)
 	return 0;
 
 out_isys_notifier_cleanup:
+#if !IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA)
+	isys_notifier_cleanup(isys);
+#endif
 
+#if !IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA)
+out_isys_unregister_subdevices:
+	isys_unregister_subdevices(isys);
+#else
 	isys_unregister_subdevices(isys);
+#endif
 
 out_v4l2_device_unregister:
 	v4l2_device_unregister(&isys->v4l2_dev);
@@ -786,9 +545,6 @@ static int isys_runtime_pm_resume(struct device *dev)
 	}
 	isys_setup_hw(isys);
 
-#if defined(IPU_IWAKE_ENABLE)
-	set_iwake_ltrdid(isys, 0, 0, LTR_ISYS_ON);
-#endif
 	return 0;
 }
 
@@ -810,13 +566,11 @@ static int isys_runtime_pm_suspend(struct device *dev)
 	isys->reset_needed = false;
 	mutex_unlock(&isys->mutex);
 
+	isys->phy_termcal_val = 0;
 	cpu_latency_qos_update_request(&isys->pm_qos, PM_QOS_DEFAULT_VALUE);
 
 	ipu_mmu_hw_cleanup(adev->mmu);
 
-#if defined(IPU_IWAKE_ENABLE)
-	set_iwake_ltrdid(isys, 0, 0, LTR_ISYS_OFF);
-#endif
 	return 0;
 }
 
@@ -874,11 +628,10 @@ static void isys_remove(struct ipu_bus_device *adev)
 		    );
 	}
 
-#if defined(IPU_IWAKE_ENABLE)
-	isys_iwake_watermark_cleanup(isys);
-#endif
-
 	ipu_trace_uninit(&adev->dev);
+#if !IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA)
+	isys_notifier_cleanup(isys);
+#endif
 	isys_unregister_devices(isys);
 
 	cpu_latency_qos_remove_request(&isys->pm_qos);
@@ -925,81 +678,10 @@ static int ipu_isys_icache_prefetch_set(void *data, u64 val)
 	return 0;
 }
 
-#if defined(IPU_IWAKE_ENABLE)
-static int isys_iwake_control_get(void *data, u64 *val)
-{
-	struct ipu_isys *isys = data;
-	struct isys_iwake_watermark *iwake_watermark = isys->iwake_watermark;
-
-	mutex_lock(&iwake_watermark->mutex);
-	*val = isys->iwake_watermark->force_iwake_disable;
-	mutex_unlock(&iwake_watermark->mutex);
-	return 0;
-}
-
-static int isys_iwake_control_set(void *data, u64 val)
-{
-	struct ipu_isys *isys = data;
-	struct isys_iwake_watermark *iwake_watermark;
-
-	if (val != !!val)
-		return -EINVAL;
-	/* If stream is open, refuse to set iwake */
-	if (isys->stream_opened)
-		return -EBUSY;
-
-	iwake_watermark = isys->iwake_watermark;
-	mutex_lock(&iwake_watermark->mutex);
-	isys->iwake_watermark->force_iwake_disable = !!val;
-	mutex_unlock(&iwake_watermark->mutex);
-	return 0;
-}
-
-#ifdef IPU_IWAKE_TUNING
-static int ipu_iwake_ltrdid_get(void *data, u64 *val)
-{
-	struct ipu_isys *isys = data;
-
-	*val = isys->iwake_watermark->ltrdid_setting;
-
-	return 0;
-}
-
-static int ipu_iwake_ltrdid_set(void *data, u64 val)
-{
-	struct ipu_isys *isys = data;
-	struct isys_iwake_watermark *iwake_watermark;
-
-	/* If stream is open, refuse to set iwake ltr did */
-	if (isys->stream_opened)
-		return -EBUSY;
-
-	iwake_watermark = isys->iwake_watermark;
-	mutex_lock(&iwake_watermark->mutex);
-	isys->iwake_watermark->ltrdid_setting = val & 0xFFFFFFFF;
-	mutex_unlock(&iwake_watermark->mutex);
-
-	return 0;
-}
-#endif
-#endif
-
 DEFINE_SIMPLE_ATTRIBUTE(isys_icache_prefetch_fops,
 			ipu_isys_icache_prefetch_get,
 			ipu_isys_icache_prefetch_set, "%llu\n");
 
-#if defined(IPU_IWAKE_ENABLE)
-DEFINE_SIMPLE_ATTRIBUTE(isys_iwake_control_fops,
-			isys_iwake_control_get,
-			isys_iwake_control_set, "%llu\n");
-
-#ifdef IPU_IWAKE_TUNING
-DEFINE_SIMPLE_ATTRIBUTE(isys_iwake_ltrdid_fops,
-			ipu_iwake_ltrdid_get,
-			ipu_iwake_ltrdid_set, "%llu\n");
-#endif
-#endif
-
 static int ipu_isys_init_debugfs(struct ipu_isys *isys)
 {
 	struct dentry *file;
@@ -1017,19 +699,6 @@ static int ipu_isys_init_debugfs(struct ipu_isys *isys)
 	if (IS_ERR(file))
 		goto err;
 
-#if defined(IPU_IWAKE_ENABLE)
-	file = debugfs_create_file("iwake_disable", 0600,
-				   dir, isys, &isys_iwake_control_fops);
-	if (IS_ERR(file))
-		goto err;
-#ifdef IPU_IWAKE_TUNING
-	file = debugfs_create_file("iwake_ltrdid", 0600,
-				   dir, isys, &isys_iwake_ltrdid_fops);
-	if (IS_ERR(file))
-		goto err;
-#endif
-#endif
-
 	isys->debugfsdir = dir;
 
 #ifdef IPU_ISYS_GPC
@@ -1148,10 +817,6 @@ static int isys_probe(struct ipu_bus_device *adev)
 	const struct firmware *fw;
 	int rval = 0;
 
-#ifdef IPU_TRACE_EVENT
-	trace_printk("B|%d|TMWK\n", current->pid);
-#endif
-
 	isys = devm_kzalloc(&adev->dev, sizeof(*isys), GFP_KERNEL);
 	if (!isys)
 		return -ENOMEM;
@@ -1166,7 +831,8 @@ static int isys_probe(struct ipu_bus_device *adev)
 	isys->pdata = adev->pdata;
 
 	/* initial streamID for different sensor types */
-	if (ipu_ver == IPU_VER_6 || ipu_ver == IPU_VER_6EP) {
+	if (ipu_ver == IPU_VER_6 || ipu_ver == IPU_VER_6EP ||
+	    ipu_ver == IPU_VER_6EP_MTL) {
 		isys->sensor_info.vc1_data_start =
 			IPU6_FW_ISYS_VC1_SENSOR_DATA_START;
 		isys->sensor_info.vc1_data_end =
@@ -1217,6 +883,7 @@ static int isys_probe(struct ipu_bus_device *adev)
 	spin_lock_init(&isys->lock);
 	spin_lock_init(&isys->power_lock);
 	isys->power = 0;
+	isys->phy_termcal_val = 0;
 
 	mutex_init(&isys->mutex);
 	mutex_init(&isys->stream_mutex);
@@ -1270,24 +937,11 @@ static int isys_probe(struct ipu_bus_device *adev)
 	rval = isys_register_devices(isys);
 	if (rval)
 		goto out_remove_pkg_dir_shared_buffer;
-#if defined(IPU_IWAKE_ENABLE)
-	rval = isys_iwake_watermark_init(isys);
-	if (rval)
-		goto out_unregister_devices;
-#endif
 
 	ipu_mmu_hw_cleanup(adev->mmu);
 
-#ifdef IPU_TRACE_EVENT
-	trace_printk("E|%d|TMWK\n", rval);
-#endif
 	return 0;
 
-#if defined(IPU_IWAKE_ENABLE)
-out_unregister_devices:
-	isys_iwake_watermark_cleanup(isys);
-	isys_unregister_devices(isys);
-#endif
 out_remove_pkg_dir_shared_buffer:
 	if (!isp->secure_mode)
 		ipu_cpd_free_pkg_dir(adev, isys->pkg_dir,
@@ -1301,10 +955,6 @@ static int isys_probe(struct ipu_bus_device *adev)
 		release_firmware(isys->fw);
 	ipu_trace_uninit(&adev->dev);
 
-#ifdef IPU_TRACE_EVENT
-	trace_printk("E|%d|TMWK\n", rval);
-#endif
-
 	mutex_destroy(&isys->mutex);
 	mutex_destroy(&isys->stream_mutex);
 
@@ -1496,14 +1146,8 @@ int isys_isr_one(struct ipu_bus_device *adev)
 		break;
 	case IPU_FW_ISYS_RESP_TYPE_FRAME_SOF:
 		if (pipe->csi2)
-			ipu_isys_csi2_sof_event(pipe->csi2, pipe->vc);
+			ipu_isys_csi2_sof_event(pipe->csi2);
 
-#ifdef CONFIG_VIDEO_INTEL_IPU_TPG
-#ifdef IPU_TPG_FRAME_SYNC
-		if (pipe->tpg)
-			ipu_isys_tpg_sof_event(pipe->tpg);
-#endif
-#endif
 		pipe->seq[pipe->seq_index].sequence =
 		    atomic_read(&pipe->sequence) - 1;
 		pipe->seq[pipe->seq_index].timestamp = ts;
@@ -1516,14 +1160,7 @@ int isys_isr_one(struct ipu_bus_device *adev)
 		break;
 	case IPU_FW_ISYS_RESP_TYPE_FRAME_EOF:
 		if (pipe->csi2)
-			ipu_isys_csi2_eof_event(pipe->csi2, pipe->vc);
-
-#ifdef CONFIG_VIDEO_INTEL_IPU_TPG
-#ifdef IPU_TPG_FRAME_SYNC
-		if (pipe->tpg)
-			ipu_isys_tpg_eof_event(pipe->tpg);
-#endif
-#endif
+			ipu_isys_csi2_eof_event(pipe->csi2);
 
 		dev_dbg(&adev->dev,
 			"eof: handle %d: (index %u), timestamp 0x%16.16llx\n",
@@ -1543,35 +1180,6 @@ int isys_isr_one(struct ipu_bus_device *adev)
 	return 0;
 }
 
-#ifdef IPU_IRQ_POLL
-static void isys_isr_poll(struct ipu_bus_device *adev)
-{
-	struct ipu_isys *isys = ipu_bus_get_drvdata(adev);
-
-	if (!isys->fwcom) {
-		dev_dbg(&isys->adev->dev,
-			"got interrupt but device not configured yet\n");
-		return;
-	}
-
-	mutex_lock(&isys->mutex);
-	isys_isr(adev);
-	mutex_unlock(&isys->mutex);
-}
-
-int ipu_isys_isr_run(void *ptr)
-{
-	struct ipu_isys *isys = ptr;
-
-	while (!kthread_should_stop()) {
-		usleep_range(500, 1000);
-		if (isys->stream_opened)
-			isys_isr_poll(isys->adev);
-	}
-
-	return 0;
-}
-#endif
 static struct ipu_bus_driver isys_driver = {
 	.probe = isys_probe,
 	.remove = isys_remove,
@@ -1592,6 +1200,7 @@ static const struct pci_device_id ipu_pci_tbl[] = {
 	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, IPU6EP_ADL_P_PCI_ID)},
 	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, IPU6EP_ADL_N_PCI_ID)},
 	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, IPU6EP_RPL_P_PCI_ID)},
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, IPU6EP_MTL_PCI_ID)},
 	{0,}
 };
 MODULE_DEVICE_TABLE(pci, ipu_pci_tbl);
diff --git a/drivers/media/pci/intel/ipu-isys.h b/drivers/media/pci/intel/ipu-isys.h
index 1ad857ebe7e8..5d5393a83add 100644
--- a/drivers/media/pci/intel/ipu-isys.h
+++ b/drivers/media/pci/intel/ipu-isys.h
@@ -16,9 +16,6 @@
 #include "ipu-isys-media.h"
 #include "ipu-isys-csi2.h"
 #include "ipu-isys-csi2-be.h"
-#ifdef CONFIG_VIDEO_INTEL_IPU_TPG
-#include "ipu-isys-tpg.h"
-#endif
 #include "ipu-isys-video.h"
 #include "ipu-pdata.h"
 #include "ipu-fw-isys.h"
@@ -61,53 +58,10 @@
 #define IPU_ISYS_MAX_WIDTH		16384U
 #define IPU_ISYS_MAX_HEIGHT		16384U
 
-#if defined(IPU_IWAKE_ENABLE)
-/* the threshold granularity is 2KB on IPU6 */
-#define IPU6_SRAM_GRANULRITY_SHIFT	11
-#define IPU6_SRAM_GRANULRITY_SIZE	2048
-/* the threshold granularity is 1KB on IPU6SE */
-#define IPU6SE_SRAM_GRANULRITY_SHIFT	10
-#define IPU6SE_SRAM_GRANULRITY_SIZE	1024
-#endif
+#define NR_OF_CSI2_BE_SOC_DEV 8
 
 struct task_struct;
 
-#if defined(IPU_IWAKE_ENABLE)
-struct ltr_did {
-	union {
-		u32 value;
-		struct {
-			u8 val0;
-			u8 val1;
-			u8 val2;
-			u8 val3;
-		} bits;
-	} lut_ltr;
-	union {
-		u32 value;
-		struct {
-			u8 th0;
-			u8 th1;
-			u8 th2;
-			u8 th3;
-		} bits;
-	} lut_fill_time;
-};
-
-struct isys_iwake_watermark {
-	bool iwake_enabled;
-	bool force_iwake_disable;
-	u32 iwake_threshold;
-#ifdef IPU_IWAKE_TUNING
-	u32 ltrdid_setting;
-#endif
-	u64 isys_pixelbuffer_datarate;
-	struct ltr_did ltrdid;
-	struct mutex mutex; /* protect whole struct */
-	struct ipu_isys *isys;
-	struct list_head video_list;
-};
-#endif
 struct ipu_isys_sensor_info {
 	unsigned int vc1_data_start;
 	unsigned int vc1_data_end;
@@ -133,6 +87,7 @@ struct ipu_isys_sensor_info {
  * @fwcom: fw communication layer private pointer
  *         or optional external library private pointer
  * @line_align: line alignment in memory
+ * @phy_termcal_val: the termination calibration value, only used for DWC PHY
  * @reset_needed: Isys requires d0i0->i3 transition
  * @video_opened: total number of opened file handles on video nodes
  * @mutex: serialise access isys video open/release related operations
@@ -140,9 +95,6 @@ struct ipu_isys_sensor_info {
  * @lib_mutex: optional external library mutex
  * @pdata: platform data pointer
  * @csi2: CSI-2 receivers
-#ifdef CONFIG_VIDEO_INTEL_IPU_TPG
- * @tpg: test pattern generators
-#endif
  * @csi2_be: CSI-2 back-ends
  * @fw: ISYS firmware binary (unsecure firmware)
  * @fw_sgt: fw scatterlist
@@ -164,10 +116,7 @@ struct ipu_isys {
 	struct ipu_isys_pipeline *pipes[IPU_ISYS_MAX_STREAMS];
 	void *fwcom;
 	unsigned int line_align;
-#ifdef IPU_IRQ_POLL
-	/* for polling for events if interrupt delivery isn't available */
-	struct task_struct *isr_thread;
-#endif
+	u32 phy_termcal_val;
 	bool reset_needed;
 	bool icache_prefetch;
 	bool csi2_cse_ipc_not_supported;
@@ -186,11 +135,8 @@ struct ipu_isys {
 	struct ipu_isys_pdata *pdata;
 
 	struct ipu_isys_csi2 *csi2;
-#ifdef CONFIG_VIDEO_INTEL_IPU_TPG
-	struct ipu_isys_tpg *tpg;
-#endif
 	struct ipu_isys_csi2_be csi2_be;
-	struct ipu_isys_csi2_be_soc csi2_be_soc;
+	struct ipu_isys_csi2_be_soc csi2_be_soc[NR_OF_CSI2_BE_SOC_DEV];
 	const struct firmware *fw;
 	struct sg_table fw_sgt;
 
@@ -210,8 +156,8 @@ struct ipu_isys {
 	spinlock_t listlock;	/* Protect framebuflist */
 	struct list_head framebuflist;
 	struct list_head framebuflist_fw;
-#if defined(IPU_IWAKE_ENABLE)
-	struct isys_iwake_watermark *iwake_watermark;
+#if !IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA)
+	struct v4l2_async_notifier notifier;
 #endif
 
 	struct mutex reset_mutex;
@@ -219,10 +165,6 @@ struct ipu_isys {
 	bool in_stop_streaming;
 };
 
-#if defined(IPU_IWAKE_ENABLE)
-void update_watermark_setting(struct ipu_isys *isys);
-#endif
-
 struct isys_fw_msgs {
 	union {
 		u64 dummy;
@@ -245,9 +187,6 @@ extern const struct v4l2_ioctl_ops ipu_isys_ioctl_ops;
 
 void isys_setup_hw(struct ipu_isys *isys);
 int isys_isr_one(struct ipu_bus_device *adev);
-#ifdef IPU_IRQ_POLL
-int ipu_isys_isr_run(void *ptr);
-#endif
 irqreturn_t isys_isr(struct ipu_bus_device *adev);
 #ifdef IPU_ISYS_GPC
 int ipu_isys_gpc_init_debugfs(struct ipu_isys *isys);
diff --git a/drivers/media/pci/intel/ipu-pdata.h b/drivers/media/pci/intel/ipu-pdata.h
index bf9fca1edf95..c029c05faeb0 100644
--- a/drivers/media/pci/intel/ipu-pdata.h
+++ b/drivers/media/pci/intel/ipu-pdata.h
@@ -205,14 +205,6 @@ struct ipu_isys_internal_csi2_pdata {
 	unsigned int *offsets;
 };
 
-#ifdef CONFIG_VIDEO_INTEL_IPU_TPG
-struct ipu_isys_internal_tpg_pdata {
-	unsigned int ntpgs;
-	unsigned int *offsets;
-	unsigned int *sels;
-};
-#endif
-
 /*
  * One place to handle all the IPU HW variations
  */
@@ -228,9 +220,6 @@ struct ipu_hw_variants {
 
 struct ipu_isys_internal_pdata {
 	struct ipu_isys_internal_csi2_pdata csi2;
-#ifdef CONFIG_VIDEO_INTEL_IPU_TPG
-	struct ipu_isys_internal_tpg_pdata tpg;
-#endif
 	struct ipu_hw_variants hw_variant;
 	u32 num_parallel_streams;
 	u32 isys_dma_overshoot;
@@ -239,7 +228,9 @@ struct ipu_isys_internal_pdata {
 struct ipu_isys_pdata {
 	void __iomem *base;
 	const struct ipu_isys_internal_pdata *ipdata;
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA)
 	struct ipu_isys_subdev_pdata *spdata;
+#endif
 };
 
 struct ipu_psys_internal_pdata {
diff --git a/drivers/media/pci/intel/ipu-psys.c b/drivers/media/pci/intel/ipu-psys.c
index 1be8ac9d5d67..da2b0707aedb 100644
--- a/drivers/media/pci/intel/ipu-psys.c
+++ b/drivers/media/pci/intel/ipu-psys.c
@@ -13,9 +13,6 @@
 #include <linux/mm.h>
 #include <linux/module.h>
 #include <linux/pm_runtime.h>
-#if defined(CONFIG_VIDEO_INTEL_IPU_ACRN) && defined(CONFIG_VIDEO_INTEL_IPU_VIRTIO_BE)
-#include <linux/syscalls.h>
-#endif
 #include <linux/version.h>
 #include <linux/poll.h>
 #include <uapi/linux/sched/types.h>
@@ -67,9 +64,6 @@ static struct fw_init_task {
 	struct ipu_psys *psys;
 } fw_init_task;
 
-#ifdef IPU_IRQ_POLL
-static int ipu_psys_isr_run(void *data);
-#endif
 static void ipu_psys_remove(struct ipu_bus_device *adev);
 
 static struct bus_type ipu_psys_bus = {
@@ -301,9 +295,8 @@ static struct sg_table *ipu_dma_buf_map(struct dma_buf_attachment *attach,
 		return NULL;
 
 	attrs = DMA_ATTR_SKIP_CPU_SYNC;
-	ret = dma_map_sg_attrs(attach->dev, ipu_attach->sgt->sgl,
-			       ipu_attach->sgt->orig_nents, dir, attrs);
-	if (ret < ipu_attach->sgt->orig_nents) {
+	ret = dma_map_sgtable(attach->dev, ipu_attach->sgt, dir, attrs);
+	if (ret < 0) {
 		ipu_psys_put_userpages(ipu_attach);
 		dev_dbg(attach->dev, "buf map failed\n");
 
@@ -321,11 +314,11 @@ static struct sg_table *ipu_dma_buf_map(struct dma_buf_attachment *attach,
 }
 
 static void ipu_dma_buf_unmap(struct dma_buf_attachment *attach,
-			      struct sg_table *sg, enum dma_data_direction dir)
+			      struct sg_table *sgt, enum dma_data_direction dir)
 {
 	struct ipu_dma_buf_attach *ipu_attach = attach->priv;
 
-	dma_unmap_sg(attach->dev, sg->sgl, sg->orig_nents, dir);
+	dma_unmap_sgtable(attach->dev, sgt, dir, DMA_ATTR_SKIP_CPU_SYNC);
 	ipu_psys_put_userpages(ipu_attach);
 }
 
@@ -424,10 +417,6 @@ static int ipu_psys_open(struct inode *inode, struct file *file)
 
 	fh->psys = psys;
 
-#if defined(CONFIG_VIDEO_INTEL_IPU_ACRN) && defined(CONFIG_VIDEO_INTEL_IPU_VIRTIO_BE)
-	fh->vfops = &psys_vfops;
-#endif
-
 	file->private_data = fh;
 
 	mutex_init(&fh->mutex);
@@ -439,34 +428,12 @@ static int ipu_psys_open(struct inode *inode, struct file *file)
 		goto open_failed;
 
 	mutex_lock(&psys->mutex);
-#ifdef IPU_IRQ_POLL
-	if (list_empty(&psys->fhs)) {
-		static const struct sched_param param = {
-			.sched_priority = MAX_USER_RT_PRIO / 2,
-		};
-		psys->isr_thread = kthread_run(ipu_psys_isr_run, psys,
-					       IPU_PSYS_NAME);
-
-		if (IS_ERR(psys->isr_thread)) {
-			mutex_unlock(&psys->mutex);
-			goto open_failed;
-		}
-
-		sched_setscheduler(psys->isr_thread, SCHED_FIFO, &param);
-	}
-#endif
 	list_add_tail(&fh->list, &psys->fhs);
 	mutex_unlock(&psys->mutex);
 
 	return 0;
 
 open_failed:
-#ifdef IPU_IRQ_POLL
-	if (list_empty(&psys->fhs) && psys->isr_thread) {
-		kthread_stop(psys->isr_thread);
-		psys->isr_thread = NULL;
-	}
-#endif
 	mutex_destroy(&fh->mutex);
 	kfree(fh);
 	return rval;
@@ -503,9 +470,6 @@ static int ipu_psys_release(struct inode *inode, struct file *file)
 	struct ipu_psys_fh *fh = file->private_data;
 	struct ipu_psys_kbuffer *kbuf, *kbuf0;
 	struct dma_buf_attachment *db_attach;
-#if defined(CONFIG_VIDEO_INTEL_IPU_ACRN) && defined(CONFIG_VIDEO_INTEL_IPU_VIRTIO_BE)
-	struct ipu_dma_buf_attach *ipu_attach;
-#endif
 
 	mutex_lock(&fh->mutex);
 	/* clean up buffers */
@@ -516,11 +480,6 @@ static int ipu_psys_release(struct inode *inode, struct file *file)
 
 			/* Unmap and release buffers */
 			if (kbuf->dbuf && db_attach) {
-#if defined(CONFIG_VIDEO_INTEL_IPU_ACRN) && defined(CONFIG_VIDEO_INTEL_IPU_VIRTIO_BE)
-				ipu_attach = db_attach->priv;
-				if (ipu_attach->vma_is_io)
-					ksys_close(kbuf->fd);
-#endif
 
 				ipu_psys_kbuf_unmap(kbuf);
 			} else {
@@ -535,12 +494,6 @@ static int ipu_psys_release(struct inode *inode, struct file *file)
 	mutex_lock(&psys->mutex);
 	list_del(&fh->list);
 
-#ifdef IPU_IRQ_POLL
-	if (list_empty(&psys->fhs) && psys->isr_thread) {
-		kthread_stop(psys->isr_thread);
-		psys->isr_thread = NULL;
-	}
-#endif
 	mutex_unlock(&psys->mutex);
 	ipu_psys_fh_deinit(fh);
 
@@ -589,7 +542,6 @@ static int ipu_psys_getbuf(struct ipu_psys_buffer *buf, struct ipu_psys_fh *fh)
 
 	ret = dma_buf_fd(dbuf, 0);
 	if (ret < 0) {
-		kfree(kbuf);
 		dma_buf_put(dbuf);
 		return ret;
 	}
@@ -1289,7 +1241,7 @@ static int ipu_psys_fw_init(struct ipu_psys *psys)
 	int i;
 
 	size = IPU6SE_FW_PSYS_N_PSYS_CMD_QUEUE_ID;
-	if (ipu_ver == IPU_VER_6 || ipu_ver == IPU_VER_6EP)
+	if (ipu_ver == IPU_VER_6 || ipu_ver == IPU_VER_6EP || ipu_ver == IPU_VER_6EP_MTL)
 		size = IPU6_FW_PSYS_N_PSYS_CMD_QUEUE_ID;
 
 	queue_cfg = devm_kzalloc(&psys->adev->dev, sizeof(*queue_cfg) * size,
@@ -1339,10 +1291,6 @@ static int ipu_psys_probe(struct ipu_bus_device *adev)
 	unsigned int minor;
 	int i, rval = -E2BIG;
 
-#ifdef IPU_TRACE_EVENT
-	trace_printk("B|%d|TMWK\n", current->pid);
-#endif
-
 	rval = ipu_mmu_hw_init(adev->mmu);
 	if (rval)
 		return rval;
@@ -1489,9 +1437,6 @@ static int ipu_psys_probe(struct ipu_bus_device *adev)
 
 	ipu_mmu_hw_cleanup(adev->mmu);
 
-#ifdef IPU_TRACE_EVENT
-	trace_printk("E|%d|TMWK\n", rval);
-#endif
 	return 0;
 
 out_release_fw_com:
@@ -1518,9 +1463,6 @@ static int ipu_psys_probe(struct ipu_bus_device *adev)
 
 	ipu_mmu_hw_cleanup(adev->mmu);
 
-#ifdef IPU_TRACE_EVENT
-	trace_printk("E|%d|TMWK\n", rval);
-#endif
 	return rval;
 }
 
@@ -1535,8 +1477,6 @@ static void ipu_psys_remove(struct ipu_bus_device *adev)
 		debugfs_remove_recursive(psys->debugfsdir);
 #endif
 
-	flush_workqueue(IPU_PSYS_WORK_QUEUE);
-
 	if (psys->sched_cmd_thread) {
 		kthread_stop(psys->sched_cmd_thread);
 		psys->sched_cmd_thread = NULL;
@@ -1605,37 +1545,6 @@ static irqreturn_t psys_isr_threaded(struct ipu_bus_device *adev)
 	return status ? IRQ_HANDLED : IRQ_NONE;
 }
 
-#ifdef IPU_IRQ_POLL
-static int ipu_psys_isr_run(void *data)
-{
-	struct ipu_psys *psys = data;
-	int r;
-
-	while (!kthread_should_stop()) {
-		usleep_range(100, 500);
-
-		r = mutex_trylock(&psys->mutex);
-		if (!r)
-			continue;
-#ifdef CONFIG_PM
-		r = pm_runtime_get_if_in_use(&psys->adev->dev);
-		if (!r || WARN_ON_ONCE(r < 0)) {
-			mutex_unlock(&psys->mutex);
-			continue;
-		}
-#endif
-
-		ipu_psys_handle_events(psys);
-
-		pm_runtime_mark_last_busy(&psys->adev->dev);
-		pm_runtime_put_autosuspend(&psys->adev->dev);
-		mutex_unlock(&psys->mutex);
-	}
-
-	return 0;
-}
-#endif /* IPU_IRQ_POLL */
-
 static struct ipu_bus_driver ipu_psys_driver = {
 	.probe = ipu_psys_probe,
 	.remove = ipu_psys_remove,
@@ -1687,6 +1596,7 @@ static const struct pci_device_id ipu_pci_tbl[] = {
 	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, IPU6EP_ADL_P_PCI_ID)},
 	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, IPU6EP_ADL_N_PCI_ID)},
 	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, IPU6EP_RPL_P_PCI_ID)},
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, IPU6EP_MTL_PCI_ID)},
 	{0,}
 };
 MODULE_DEVICE_TABLE(pci, ipu_pci_tbl);
@@ -1704,3 +1614,4 @@ MODULE_AUTHOR("Zaikuo Wang <zaikuo.wang@intel.com>");
 MODULE_AUTHOR("Yunliang Ding <yunliang.ding@intel.com>");
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("Intel ipu processing system driver");
+MODULE_IMPORT_NS(DMA_BUF);
diff --git a/drivers/media/pci/intel/ipu-psys.h b/drivers/media/pci/intel/ipu-psys.h
index 97424602eff1..8ba314cfe1c2 100644
--- a/drivers/media/pci/intel/ipu-psys.h
+++ b/drivers/media/pci/intel/ipu-psys.h
@@ -10,9 +10,6 @@
 #include "ipu.h"
 #include "ipu-pdata.h"
 #include "ipu-fw-psys.h"
-#if defined(CONFIG_VIDEO_INTEL_IPU_ACRN) && defined(CONFIG_VIDEO_INTEL_IPU_VIRTIO_BE)
-#include "ipu-psys-virt.h"
-#endif
 #include "ipu-platform-psys.h"
 
 #define IPU_PSYS_PG_POOL_SIZE 16
@@ -22,7 +19,6 @@
 #define IPU_PSYS_EVENT_FRAGMENT_COMPLETE IPU_FW_PSYS_EVENT_TYPE_SUCCESS
 #define IPU_PSYS_CLOSE_TIMEOUT_US   50
 #define IPU_PSYS_CLOSE_TIMEOUT (100000 / IPU_PSYS_CLOSE_TIMEOUT_US)
-#define IPU_PSYS_WORK_QUEUE		system_power_efficient_wq
 #define IPU_MAX_RESOURCES 128
 
 /* Opaque structure. Do not access fields. */
@@ -99,9 +95,6 @@ struct ipu_psys {
 	struct ia_css_syscom_context *dev_ctx;
 	struct ia_css_syscom_config *syscom_config;
 	struct ia_css_psys_server_init *server_init;
-#ifdef IPU_IRQ_POLL
-	struct task_struct *isr_thread;
-#endif
 	struct task_struct *sched_cmd_thread;
 	wait_queue_head_t sched_cmd_wq;
 	atomic_t wakeup_count;  /* Psys schedule thread wakeup count */
@@ -126,9 +119,6 @@ struct ipu_psys {
 };
 
 struct ipu_psys_fh {
-#if defined(CONFIG_VIDEO_INTEL_IPU_ACRN) && defined(CONFIG_VIDEO_INTEL_IPU_VIRTIO_BE)
-	const struct psys_fops_virt *vfops;
-#endif
 	struct ipu_psys *psys;
 	struct mutex mutex;	/* Protects bufmap & kcmds fields */
 	struct list_head list;
diff --git a/drivers/media/pci/intel/ipu-trace-event.h b/drivers/media/pci/intel/ipu-trace-event.h
deleted file mode 100644
index 883ed2af08a0..000000000000
--- a/drivers/media/pci/intel/ipu-trace-event.h
+++ /dev/null
@@ -1,136 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/* Copyright (C) 2015 - 2020 Intel Corporation */
-
-#undef TRACE_SYSTEM
-#define TRACE_SYSTEM ipu
-
-#if !defined(IPU_TRACE_EVENT_H) || defined(TRACE_HEADER_MULTI_READ)
-#define IPU_EVENT_H
-
-#include <linux/tracepoint.h>
-
-#ifdef IPU_SOF_SEQID_TRACE
-TRACE_EVENT(ipu_sof_seqid,
-	    TP_PROTO(unsigned int seqid, unsigned int csiport,
-		     unsigned int csivc),
-	    TP_ARGS(seqid, csiport, csivc),
-	    TP_STRUCT__entry(__field(unsigned int, seqid)
-			     __field(unsigned int, csiport)
-			     __field(unsigned int, csivc)
-	    ),
-	    TP_fast_assign(__entry->seqid = seqid;
-			   __entry->csiport = csiport;
-			   __entry->csivc = csivc;),
-	    TP_printk("seqid=%u csiport=%u csivc=%u", __entry->seqid,
-		      __entry->csiport, __entry->csivc)
-	);
-#endif
-
-#ifdef IPU_EOF_SEQID_TRACE
-TRACE_EVENT(ipu_eof_seqid,
-	    TP_PROTO(unsigned int seqid, unsigned int csiport,
-		     unsigned int csivc),
-	    TP_ARGS(seqid, csiport, csivc),
-	    TP_STRUCT__entry(__field(unsigned int, seqid)
-			     __field(unsigned int, csiport)
-			     __field(unsigned int, csivc)
-	    ),
-	    TP_fast_assign(__entry->seqid = seqid;
-			   __entry->csiport = csiport;
-			   __entry->csivc = csivc;),
-	    TP_printk("seqid=%u csiport=%u csivc=%u", __entry->seqid,
-		      __entry->csiport, __entry->csivc)
-	);
-#endif
-
-#ifdef IPU_ISYSBUF_READY_TRACE
-TRACE_EVENT(ipu_isysbuf_ready,
-	    TP_PROTO(unsigned int seqid, unsigned int width,
-		     unsigned int height, unsigned int bpp),
-	    TP_ARGS(seqid, width, height, bpp),
-	    TP_STRUCT__entry(__field(unsigned int, seqid)
-			     __field(unsigned int, width)
-			     __field(unsigned int, height)
-			     __field(unsigned int, bpp)
-	    ),
-	    TP_fast_assign(__entry->seqid = seqid;
-			   __entry->width = width;
-			   __entry->height = height;
-			   __entry->bpp = bpp;),
-	    TP_printk("seqid=%u width=%u height=%u bpp=%u", __entry->seqid,
-		      __entry->width, __entry->height, __entry->bpp)
-	);
-#endif
-
-#ifdef IPU_PERF_REG_TRACE
-TRACE_EVENT(ipu_perf_reg,
-	    TP_PROTO(unsigned int addr, unsigned int val),
-	    TP_ARGS(addr, val), TP_STRUCT__entry(__field(unsigned int, addr)
-						 __field(unsigned int, val)
-	    ),
-	    TP_fast_assign(__entry->addr = addr;
-			   __entry->val = val;),
-	    TP_printk("addr=%u val=%u", __entry->addr, __entry->val)
-	);
-#endif
-
-#ifdef IPU_PG_KCMD_TRACE
-TRACE_EVENT(ipu_pg_kcmd,
-	    TP_PROTO(const char *func, unsigned int id,
-		     unsigned long long issue_id, unsigned int pri,
-		     unsigned int pg_id, unsigned int load_cycles,
-		     unsigned int init_cycles,
-		     unsigned int server_init_cycles,
-		     unsigned int next_frame_init_cycles,
-		     unsigned int complete_cycles,
-		     unsigned int processing_cycles),
-	    TP_ARGS(func, id, issue_id, pri, pg_id, load_cycles, init_cycles,
-		    server_init_cycles, next_frame_init_cycles,
-		    complete_cycles,
-		    processing_cycles),
-	    TP_STRUCT__entry(__field(const char *, func)
-			     __field(unsigned int, id)
-			     __field(unsigned long long, issue_id)
-			     __field(unsigned int, pri)
-			     __field(unsigned int, pg_id)
-			     __field(unsigned int, load_cycles)
-			     __field(unsigned int, init_cycles)
-			     __field(unsigned int, server_init_cycles)
-			     __field(unsigned int, next_frame_init_cycles)
-			     __field(unsigned int, complete_cycles)
-			     __field(unsigned int, processing_cycles)
-	    ),
-	    TP_fast_assign(__entry->func = func;
-			   __entry->id = id;
-			   __entry->issue_id = issue_id;
-			   __entry->pri = pri;
-			   __entry->pg_id = pg_id;
-			   __entry->load_cycles = load_cycles;
-			   __entry->init_cycles = init_cycles;
-			   __entry->server_init_cycles = server_init_cycles;
-			   __entry->next_frame_init_cycles =
-							next_frame_init_cycles;
-			   __entry->complete_cycles = complete_cycles;
-			   __entry->processing_cycles = processing_cycles;),
-	    TP_printk
-	    ("func=%s id=%u issue_id=0x%llx pri=%u pg_id=%d "
-	     "load_cycles=%u init_cycles=%u "
-	     "server_init_cycles=%u next_frame_init_cycles=%u "
-	     "complete_cycles=%u "
-	     "processing_cycles=%u",
-	     __entry->func, __entry->id, __entry->issue_id, __entry->pri,
-	     __entry->pg_id, __entry->load_cycles, __entry->init_cycles,
-	     __entry->server_init_cycles, __entry->next_frame_init_cycles,
-	     __entry->complete_cycles,
-	     __entry->processing_cycles)
-	);
-
-#endif
-#endif
-
-#undef TRACE_INCLUDE_PATH
-#undef TRACE_INCLUDE_FILE
-#define TRACE_INCLUDE_PATH .
-#define TRACE_INCLUDE_FILE  ipu-trace-event
-/* This part must be outside protection */
-#include <trace/define_trace.h>
diff --git a/drivers/media/pci/intel/ipu-trace.c b/drivers/media/pci/intel/ipu-trace.c
index 4e7ee02a423b..1992589186f7 100644
--- a/drivers/media/pci/intel/ipu-trace.c
+++ b/drivers/media/pci/intel/ipu-trace.c
@@ -15,12 +15,19 @@
 #include "ipu-platform-regs.h"
 #include "ipu-trace.h"
 
+/*
+ * enabling ipu trace need a 96 MB buffer.
+ */
+static bool ipu_trace_enable;
+module_param(ipu_trace_enable, bool, 0660);
+MODULE_PARM_DESC(ipu_trace_enable, "IPU trace enable");
+
 struct trace_register_range {
 	u32 start;
 	u32 end;
 };
 
-#define MEMORY_RING_BUFFER_SIZE		(SZ_1M * 32)
+#define MEMORY_RING_BUFFER_SIZE		(SZ_1M * 96)
 #define TRACE_MESSAGE_SIZE		16
 /*
  * It looks that the trace unit sometimes writes outside the given buffer.
@@ -773,6 +780,15 @@ int ipu_trace_init(struct ipu_device *isp, void __iomem *base,
 	sys->base = base;
 	sys->blocks = blocks;
 
+	sys->memory.memory_buffer =
+	    dma_alloc_coherent(dev, MEMORY_RING_BUFFER_SIZE +
+			       MEMORY_RING_BUFFER_GUARD,
+			       &sys->memory.dma_handle,
+			       GFP_KERNEL);
+
+	if (!sys->memory.memory_buffer)
+		dev_err(dev, "failed alloc memory for tracing.\n");
+
 leave:
 	mutex_unlock(&isp->trace->lock);
 
@@ -811,6 +827,9 @@ int ipu_trace_debugfs_add(struct ipu_device *isp, struct dentry *dir)
 	struct dentry *files[4];
 	int i = 0;
 
+	if (!ipu_trace_enable)
+		return 0;
+
 	files[i] = debugfs_create_file("traceconf", 0644,
 				       dir, isp, &ipu_traceconf_fops);
 	if (!files[i])
@@ -847,6 +866,9 @@ int ipu_trace_debugfs_add(struct ipu_device *isp, struct dentry *dir)
 
 int ipu_trace_add(struct ipu_device *isp)
 {
+	if (!ipu_trace_enable)
+		return 0;
+
 	isp->trace = devm_kzalloc(&isp->pdev->dev,
 				  sizeof(struct ipu_trace), GFP_KERNEL);
 	if (!isp->trace)
@@ -854,6 +876,8 @@ int ipu_trace_add(struct ipu_device *isp)
 
 	mutex_init(&isp->trace->lock);
 
+	dev_dbg(&isp->pdev->dev, "ipu trace enabled!");
+
 	return 0;
 }
 
@@ -864,6 +888,23 @@ void ipu_trace_release(struct ipu_device *isp)
 	mutex_destroy(&isp->trace->lock);
 }
 
+int ipu_trace_buffer_dma_handle(struct device *dev, dma_addr_t *dma_handle)
+{
+	struct ipu_bus_device *adev = to_ipu_bus_device(dev);
+	struct ipu_subsystem_trace_config *sys = adev->trace_cfg;
+
+	if (!ipu_trace_enable)
+		return -EACCES;
+
+	if (!sys->memory.memory_buffer)
+		return -EACCES;
+
+	*dma_handle = sys->memory.dma_handle;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ipu_trace_buffer_dma_handle);
+
 MODULE_AUTHOR("Samu Onkalo <samu.onkalo@intel.com>");
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("Intel ipu trace support");
diff --git a/drivers/media/pci/intel/ipu-trace.h b/drivers/media/pci/intel/ipu-trace.h
index f1233a306519..6609a227f2e7 100644
--- a/drivers/media/pci/intel/ipu-trace.h
+++ b/drivers/media/pci/intel/ipu-trace.h
@@ -143,4 +143,5 @@ int ipu_trace_init(struct ipu_device *isp, void __iomem *base,
 void ipu_trace_restore(struct device *dev);
 void ipu_trace_uninit(struct device *dev);
 void ipu_trace_stop(struct device *dev);
+int ipu_trace_buffer_dma_handle(struct device *dev, dma_addr_t *dma_handle);
 #endif
diff --git a/drivers/media/pci/intel/ipu.c b/drivers/media/pci/intel/ipu.c
index 01a8964ed072..65e30bd9d79e 100644
--- a/drivers/media/pci/intel/ipu.c
+++ b/drivers/media/pci/intel/ipu.c
@@ -26,11 +26,15 @@
 #include "ipu-platform-isys-csi2-reg.h"
 #include "ipu-trace.h"
 
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA)
 #if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_PDATA_DYNAMIC_LOADING)
 #include <media/ipu-isys.h>
 #endif
+#endif
 
+#if IS_ENABLED(CONFIG_INTEL_IPU6_ACPI)
 #include <media/ipu-acpi.h>
+#endif
 
 #define IPU_PCI_BAR		0
 enum ipu_version ipu_ver;
@@ -40,12 +44,14 @@ static int isys_freq_overwrite = -1;
 module_param(isys_freq_overwrite, int, 0660);
 MODULE_PARM_DESC(isys_freq_overwrite, "overwrite isys freq default value");
 
+#if IS_ENABLED(CONFIG_INTEL_IPU6_ACPI)
 static int isys_init_acpi_add_device(struct device *dev, void *priv,
 				struct ipu_isys_csi2_config *csi2,
 				bool reprobe)
 {
 	return 0;
 }
+#endif
 
 static struct ipu_bus_device *ipu_isys_init(struct pci_dev *pdev,
 					    struct device *parent,
@@ -53,8 +59,10 @@ static struct ipu_bus_device *ipu_isys_init(struct pci_dev *pdev,
 					    void __iomem *base,
 					    const struct ipu_isys_internal_pdata
 					    *ipdata,
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA)
 					    struct ipu_isys_subdev_pdata
 					    *spdata,
+#endif
 					    unsigned int nr)
 {
 	struct ipu_bus_device *isys;
@@ -62,13 +70,16 @@ static struct ipu_bus_device *ipu_isys_init(struct pci_dev *pdev,
 #if IS_ENABLED(CONFIG_INTEL_IPU6_ACPI)
 	struct ipu_isys_subdev_pdata *acpi_pdata;
 #endif
+
 	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
 	if (!pdata)
 		return ERR_PTR(-ENOMEM);
 
 	pdata->base = base;
 	pdata->ipdata = ipdata;
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA)
 	pdata->spdata = spdata;
+#endif
 
 	/* Use 250MHz for ipu6 se */
 	if (ipu_ver == IPU_VER_6SE)
@@ -76,6 +87,8 @@ static struct ipu_bus_device *ipu_isys_init(struct pci_dev *pdev,
 
 	isys = ipu_bus_add_device(pdev, parent, pdata, ctrl,
 				  IPU_ISYS_NAME, nr);
+	if (IS_ERR(isys))
+		return ERR_PTR(-ENOMEM);
 
 #if IS_ENABLED(CONFIG_INTEL_IPU6_ACPI)
 	if (!spdata) {
@@ -83,14 +96,10 @@ static struct ipu_bus_device *ipu_isys_init(struct pci_dev *pdev,
 		ipu_get_acpi_devices(isys, &isys->dev, &acpi_pdata, NULL, isys_init_acpi_add_device);
 		pdata->spdata = acpi_pdata;
 	} else {
-		dev_info(&pdev->dev, "Subdevice info found");
+		dev_dbg(&pdev->dev, "Subdevice info found");
 		ipu_get_acpi_devices(isys, &isys->dev, &acpi_pdata, &spdata, isys_init_acpi_add_device);
 	}
 #endif
-
-	if (IS_ERR(isys))
-		return ERR_PTR(-ENOMEM);
-
 	isys->mmu = ipu_mmu_init(&pdev->dev, base, ISYS_MMID,
 				 &ipdata->hw_variant);
 	if (IS_ERR(isys->mmu))
@@ -323,7 +332,9 @@ static int ipu_pci_config_setup(struct pci_dev *dev)
 	pci_read_config_word(dev, PCI_COMMAND, &pci_command);
 	pci_command |= PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER;
 	pci_write_config_word(dev, PCI_COMMAND, pci_command);
-	if (ipu_ver == IPU_VER_6EP) {
+
+	/* no msi pci capability for IPU6EP */
+	if (ipu_ver == IPU_VER_6EP || ipu_ver == IPU_VER_6EP_MTL) {
 		/* likely do nothing as msi not enabled by default */
 		pci_disable_msi(dev);
 		return 0;
@@ -388,6 +399,7 @@ int request_cpd_fw(const struct firmware **firmware_p, const char *name,
 }
 EXPORT_SYMBOL(request_cpd_fw);
 
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA)
 #if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_PDATA_DYNAMIC_LOADING)
 static inline int match_spdata(struct ipu_isys_subdev_info *sd,
 			const struct ipu_spdata_rep *rep)
@@ -438,6 +450,7 @@ void fixup_spdata(const void *spdata_rep,
 	}
 }
 #endif
+#endif
 
 static int ipu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 {
@@ -451,10 +464,8 @@ static int ipu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	struct fwnode_handle *fwnode = dev_fwnode(&pdev->dev);
 	u32 is_es;
 	int rval;
+	u32 val;
 
-#ifdef IPU_TRACE_EVENT
-	trace_printk("B|%d|TMWK\n", current->pid);
-#endif
 	if (!fwnode || fwnode_property_read_u32(fwnode, "is_es", &is_es))
 		is_es = 0;
 
@@ -470,9 +481,6 @@ static int ipu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	if (rval) {
 		dev_err(&pdev->dev, "Failed to enable CI ISP device (%d)\n",
 			rval);
-#ifdef IPU_TRACE_EVENT
-		trace_printk("E|%d|TMWK\n", rval);
-#endif
 		return rval;
 	}
 
@@ -487,9 +495,6 @@ static int ipu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	if (rval) {
 		dev_err(&pdev->dev, "Failed to I/O memory remapping (%d)\n",
 			rval);
-#ifdef IPU_TRACE_EVENT
-		trace_printk("E|%d|TMWK\n", rval);
-#endif
 		return rval;
 	}
 	dev_info(&pdev->dev, "physical base address 0x%llx\n", phys);
@@ -497,9 +502,6 @@ static int ipu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	iomap = pcim_iomap_table(pdev);
 	if (!iomap) {
 		dev_err(&pdev->dev, "Failed to iomap table (%d)\n", rval);
-#ifdef IPU_TRACE_EVENT
-		trace_printk("E|%d|TMWK\n", rval);
-#endif
 		return -ENODEV;
 	}
 
@@ -524,6 +526,10 @@ static int ipu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 		ipu_ver = IPU_VER_6EP;
 		isp->cpd_fw_name = is_es ? IPU6EPES_FIRMWARE_NAME : IPU6EP_FIRMWARE_NAME;
 		break;
+	case IPU6EP_MTL_PCI_ID:
+		ipu_ver = IPU_VER_6EP_MTL;
+		isp->cpd_fw_name = IPU6EPMTL_FIRMWARE_NAME;
+		break;
 	default:
 		WARN(1, "Unsupported IPU device");
 		return -ENODEV;
@@ -537,30 +543,17 @@ static int ipu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	dev_dbg(&pdev->dev, "isys_base: 0x%lx\n", (unsigned long)isys_base);
 	dev_dbg(&pdev->dev, "psys_base: 0x%lx\n", (unsigned long)psys_base);
 
-	rval = pci_set_dma_mask(pdev, DMA_BIT_MASK(dma_mask));
-	if (!rval)
-		rval = pci_set_consistent_dma_mask(pdev,
-						   DMA_BIT_MASK(dma_mask));
+	rval = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(dma_mask));
 	if (rval) {
 		dev_err(&pdev->dev, "Failed to set DMA mask (%d)\n", rval);
-#ifdef IPU_TRACE_EVENT
-		trace_printk("E|%d|TMWK\n", rval);
-#endif
 		return rval;
 	}
 
 	dma_set_max_seg_size(&pdev->dev, UINT_MAX);
 
 	rval = ipu_pci_config_setup(pdev);
-#ifdef IPU_TRACE_EVENT
-	if (rval) {
-		trace_printk("E|%d|TMWK\n", rval);
-		return rval;
-	}
-#else
 	if (rval)
 		return rval;
-#endif
 
 	rval = devm_request_threaded_irq(&pdev->dev, pdev->irq,
 					 ipu_buttress_isr,
@@ -568,31 +561,18 @@ static int ipu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 					 IRQF_SHARED, IPU_NAME, isp);
 	if (rval) {
 		dev_err(&pdev->dev, "Requesting irq failed(%d)\n", rval);
-#ifdef IPU_TRACE_EVENT
-		trace_printk("E|%d|TMWK\n", rval);
-#endif
 		return rval;
 	}
 
 	rval = ipu_buttress_init(isp);
-#ifdef IPU_TRACE_EVENT
-	if (rval) {
-		trace_printk("E|%d|TMWK\n", rval);
-		return rval;
-	}
-#else
 	if (rval)
 		return rval;
-#endif
 
 	dev_info(&pdev->dev, "cpd file name: %s\n", isp->cpd_fw_name);
 
 	rval = request_cpd_fw(&isp->cpd_fw, isp->cpd_fw_name, &pdev->dev);
 	if (rval) {
 		dev_err(&isp->pdev->dev, "Requesting signed firmware failed\n");
-#ifdef IPU_TRACE_EVENT
-		trace_printk("E|%d|TMWK\n", rval);
-#endif
 		return rval;
 	}
 
@@ -603,20 +583,19 @@ static int ipu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 		goto out_ipu_bus_del_devices;
 	}
 
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA)
 #if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_PDATA_DYNAMIC_LOADING)
 	rval = request_firmware(&isp->spdata_fw, IPU_SPDATA_NAME, &pdev->dev);
 	if (rval)
 		dev_warn(&isp->pdev->dev, "no spdata replace, using default\n");
 	else
 		fixup_spdata(isp->spdata_fw->data, pdev->dev.platform_data);
+#endif
 #endif
 	rval = ipu_trace_add(isp);
 	if (rval)
 		dev_err(&pdev->dev, "Trace support not available\n");
 
-	pm_runtime_put_noidle(&pdev->dev);
-	pm_runtime_allow(&pdev->dev);
-
 	/*
 	 * NOTE Device hierarchy below is important to ensure proper
 	 * runtime suspend and resume order.
@@ -637,7 +616,9 @@ static int ipu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	isp->isys = ipu_isys_init(pdev, &pdev->dev,
 				  isys_ctrl, isys_base,
 				  &isys_ipdata,
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA)
 				  pdev->dev.platform_data,
+#endif
 				  0);
 	if (IS_ERR(isp->isys)) {
 		rval = PTR_ERR(isp->isys);
@@ -720,38 +701,42 @@ static int ipu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	/* Configure the arbitration mechanisms for VC requests */
 	ipu_configure_vc_mechanism(isp);
 
-	dev_info(&pdev->dev, "IPU driver version %d.%d\n", IPU_MAJOR_VERSION,
+	val = readl(isp->base + BUTTRESS_REG_SKU);
+	dev_info(&pdev->dev, "IPU%u-v%u driver version %d.%d\n",
+		 val & 0xf, (val >> 4) & 0x7,
+		 IPU_MAJOR_VERSION,
 		 IPU_MINOR_VERSION);
 
-#ifdef IPU_TRACE_EVENT
-	trace_printk("E|%d|TMWK\n", rval);
-#endif
+	pm_runtime_put_noidle(&pdev->dev);
+	pm_runtime_allow(&pdev->dev);
+
 	return 0;
 
 out_ipu_bus_del_devices:
 	if (isp->pkg_dir) {
-		ipu_cpd_free_pkg_dir(isp->psys, isp->pkg_dir,
-				     isp->pkg_dir_dma_addr,
-				     isp->pkg_dir_size);
-		ipu_buttress_unmap_fw_image(isp->psys, &isp->fw_sgt);
+		if (isp->psys) {
+			ipu_cpd_free_pkg_dir(isp->psys, isp->pkg_dir,
+					     isp->pkg_dir_dma_addr,
+					     isp->pkg_dir_size);
+			ipu_buttress_unmap_fw_image(isp->psys, &isp->fw_sgt);
+		}
 		isp->pkg_dir = NULL;
 	}
-	if (isp->psys && isp->psys->mmu)
+	if (!IS_ERR_OR_NULL(isp->psys) && !IS_ERR_OR_NULL(isp->psys->mmu))
 		ipu_mmu_cleanup(isp->psys->mmu);
-	if (isp->isys && isp->isys->mmu)
+	if (!IS_ERR_OR_NULL(isp->isys) && !IS_ERR_OR_NULL(isp->isys->mmu))
 		ipu_mmu_cleanup(isp->isys->mmu);
-	if (isp->psys)
+	if (!IS_ERR_OR_NULL(isp->psys))
 		pm_runtime_put(&isp->psys->dev);
 	ipu_bus_del_devices(pdev);
 	ipu_buttress_exit(isp);
 	release_firmware(isp->cpd_fw);
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA)
 #if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_PDATA_DYNAMIC_LOADING)
 	release_firmware(isp->spdata_fw);
 #endif
-
-#ifdef IPU_TRACE_EVENT
-	trace_printk("E|%d|TMWK\n", rval);
 #endif
+
 	return rval;
 }
 
@@ -906,6 +891,7 @@ static const struct pci_device_id ipu_pci_tbl[] = {
 	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, IPU6EP_ADL_P_PCI_ID)},
 	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, IPU6EP_ADL_N_PCI_ID)},
 	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, IPU6EP_RPL_P_PCI_ID)},
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, IPU6EP_MTL_PCI_ID)},
 	{0,}
 };
 MODULE_DEVICE_TABLE(pci, ipu_pci_tbl);
diff --git a/drivers/media/pci/intel/ipu.h b/drivers/media/pci/intel/ipu.h
index 0bc307b7c61f..bbf7831f1d2b 100644
--- a/drivers/media/pci/intel/ipu.h
+++ b/drivers/media/pci/intel/ipu.h
@@ -26,6 +26,7 @@ enum ipu_version {
 	IPU_VER_6,
 	IPU_VER_6SE,
 	IPU_VER_6EP,
+	IPU_VER_6EP_MTL,
 };
 
 /*
@@ -80,8 +81,10 @@ struct ipu_device {
 	unsigned int pkg_dir_size;
 	struct sg_table fw_sgt;
 
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA)
 #if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_PDATA_DYNAMIC_LOADING)
 	const struct firmware *spdata_fw;
+#endif
 #endif
 	void __iomem *base;
 #ifdef CONFIG_DEBUG_FS
diff --git a/drivers/media/pci/intel/ipu6/Makefile b/drivers/media/pci/intel/ipu6/Makefile
index 49f19439f4f3..d6acf6ad687d 100644
--- a/drivers/media/pci/intel/ipu6/Makefile
+++ b/drivers/media/pci/intel/ipu6/Makefile
@@ -6,7 +6,7 @@ srcpath := $(srctree)
 endif
 
 ccflags-y += -DIPU_VC_SUPPORT -DIPU_HAS_S2M -DIPU_TPG_FRAME_SYNC -DIPU_PSYS_GPC \
-		-DIPU_ISYS_GPC -DIPU_TRACE_EVENT
+		-DIPU_ISYS_GPC
 ccflags-y += -DIPU_META_DATA_SUPPORT -DI2C_DYNAMIC
 ccflags-y += -DIPU_ISYS_RESET
 
@@ -26,6 +26,7 @@ intel-ipu6-isys-objs			+= ../ipu-isys.o \
 					   ../ipu-isys-csi2.o \
 					   ipu6-isys.o \
 					   ipu6-isys-phy.o \
+					   ipu6-isys-dwc-phy.o \
 					   ipu6-isys-csi2.o \
 					   ipu6-isys-gpc.o \
 					   ../ipu-isys-csi2-be-soc.o \
@@ -35,10 +36,6 @@ intel-ipu6-isys-objs			+= ../ipu-isys.o \
 					   ../ipu-isys-subdev.o
 intel-ipu6-isys-objs			+= ../ipu-isys-csi2-be.o
 
-ifdef CONFIG_VIDEO_INTEL_IPU_TPG
-intel-ipu6-isys-objs                    += ../ipu-isys-tpg.o
-endif
-
 obj-$(CONFIG_VIDEO_INTEL_IPU6)		+= intel-ipu6-isys.o
 
 intel-ipu6-psys-objs			+= ../ipu-psys.o \
diff --git a/drivers/media/pci/intel/ipu6/ipu-platform-buttress-regs.h b/drivers/media/pci/intel/ipu6/ipu-platform-buttress-regs.h
index 3c8b8eab838e..11597bdad91d 100644
--- a/drivers/media/pci/intel/ipu6/ipu-platform-buttress-regs.h
+++ b/drivers/media/pci/intel/ipu6/ipu-platform-buttress-regs.h
@@ -144,6 +144,9 @@ enum {
 #define BUTTRESS_PWR_STATE_PS_PWR_FSM_WAIT_DVFS_CLKACK		0x16
 
 #define BUTTRESS_REG_SECURITY_CTL	0x300
+#define BUTTRESS_REG_SKU		0x314
+#define BUTTRESS_REG_SECURITY_TOUCH	0x318
+#define BUTTRESS_REG_CAMERA_MASK	0x84
 
 #define BUTTRESS_SECURITY_CTL_FW_SECURE_MODE	BIT(16)
 #define BUTTRESS_SECURITY_CTL_FW_SETUP_SHIFT		0
@@ -218,6 +221,14 @@ enum {
 #define BUTTRESS_ISR_PUNIT_2_IUNIT_IRQ		BIT(10)
 #define BUTTRESS_ISR_SAI_VIOLATION		BIT(11)
 #define BUTTRESS_ISR_HW_ASSERTION		BIT(12)
+#define BUTTRESS_ISR_IS_CORRECTABLE_MEM_ERR	BIT(13)
+#define BUTTRESS_ISR_IS_FATAL_MEM_ERR		BIT(14)
+#define BUTTRESS_ISR_IS_NON_FATAL_MEM_ERR	BIT(15)
+#define BUTTRESS_ISR_PS_CORRECTABLE_MEM_ERR	BIT(16)
+#define BUTTRESS_ISR_PS_FATAL_MEM_ERR		BIT(17)
+#define BUTTRESS_ISR_PS_NON_FATAL_MEM_ERR	BIT(18)
+#define BUTTRESS_ISR_PS_FAST_THROTTLE		BIT(19)
+#define BUTTRESS_ISR_UFI_ERROR			BIT(20)
 
 #define BUTTRESS_REG_IU2CSEDB0	0x100
 
diff --git a/drivers/media/pci/intel/ipu6/ipu-platform-isys-csi2-reg.h b/drivers/media/pci/intel/ipu6/ipu-platform-isys-csi2-reg.h
index ad8f534bbbab..6cfad53e16eb 100644
--- a/drivers/media/pci/intel/ipu6/ipu-platform-isys-csi2-reg.h
+++ b/drivers/media/pci/intel/ipu6/ipu-platform-isys-csi2-reg.h
@@ -54,8 +54,8 @@
 #define CSI_RX_NUM_ERRORS_IN_IRQ		20
 #define CSI_RX_NUM_IRQ				32
 
-#define IPU_CSI_RX_IRQ_FS_VC(chn)	(1 << ((chn) * 2))
-#define IPU_CSI_RX_IRQ_FE_VC(chn)	(2 << ((chn) * 2))
+#define IPU_CSI_RX_IRQ_FS_VC		1
+#define IPU_CSI_RX_IRQ_FE_VC		2
 
 /* PPI2CSI */
 #define CSI_REG_PPI2CSI_ENABLE                  0x200
@@ -226,6 +226,8 @@ enum CSI_FE_SYNC_CNTR_SEL_TYPE {
 
 #define CSI_REG_HUB_DRV_ACCESS_PORT(id)	(CSI_REG_BASE + 0x18018 + (id) * 4)
 #define CSI_REG_HUB_FW_ACCESS_PORT(id)	(CSI_REG_BASE + 0x17000 + (id) * 4)
+#define IPU6V6_CSI_REG_HUB_FW_ACCESS_PORT(id)	\
+	(CSI_REG_BASE + 0x16000 + (id) * 4)
 
 enum CSI_PORT_CLK_GATING_SWITCH {
 	CSI_PORT_CLK_GATING_OFF = 0,
diff --git a/drivers/media/pci/intel/ipu6/ipu-platform-isys.h b/drivers/media/pci/intel/ipu6/ipu-platform-isys.h
index f043bc7ae55c..ce2aae70c3c1 100644
--- a/drivers/media/pci/intel/ipu6/ipu-platform-isys.h
+++ b/drivers/media/pci/intel/ipu6/ipu-platform-isys.h
@@ -1,5 +1,5 @@
 /* SPDX-License-Identifier: GPL-2.0 */
-/* Copyright (C) 2020 Intel Corporation */
+/* Copyright (C) 2022 Intel Corporation */
 
 #ifndef IPU_PLATFORM_ISYS_H
 #define IPU_PLATFORM_ISYS_H
@@ -13,13 +13,12 @@
 
 #define NR_OF_CSI2_BE_SOC_STREAMS	16
 
-#define NR_OF_CSI2_VC			16
+#define IPU_ISYS_CSI2_ENTITY_PREFIX	"Intel IPU6 CSI-2"
 
 #define ISYS_UNISPART_IRQS	(IPU_ISYS_UNISPART_IRQ_SW |	\
 				 IPU_ISYS_UNISPART_IRQ_CSI0 |	\
 				 IPU_ISYS_UNISPART_IRQ_CSI1)
 
-#if defined(IPU_ISYS_COMPRESSION)
 /* IPU6 ISYS compression alignment */
 #define IPU_ISYS_COMPRESSION_LINE_ALIGN		512
 #define IPU_ISYS_COMPRESSION_HEIGHT_ALIGN	1
@@ -27,6 +26,5 @@
 #define IPU_ISYS_COMPRESSION_PAGE_ALIGN		0x1000
 #define IPU_ISYS_COMPRESSION_TILE_STATUS_BITS	4
 #define IPU_ISYS_COMPRESSION_MAX		3
-#endif
 
 #endif
diff --git a/drivers/media/pci/intel/ipu6/ipu-platform-regs.h b/drivers/media/pci/intel/ipu6/ipu-platform-regs.h
index be6c7f298e6d..eb0b9219a995 100644
--- a/drivers/media/pci/intel/ipu6/ipu-platform-regs.h
+++ b/drivers/media/pci/intel/ipu6/ipu-platform-regs.h
@@ -50,6 +50,21 @@
 #define IPU_REG_ISYS_CSI_TOP_CTRL1_IRQ_ENABLE		0x238230
 #define IPU_REG_ISYS_CSI_TOP_CTRL1_IRQ_LEVEL_NOT_PULSE	0x238234
 
+/* MTL IPU6V6 irq ctrl0 & ctrl1 */
+#define IPU6V6_REG_ISYS_CSI_TOP_CTRL0_IRQ_EDGE			0x238700
+#define IPU6V6_REG_ISYS_CSI_TOP_CTRL0_IRQ_MASK			0x238704
+#define IPU6V6_REG_ISYS_CSI_TOP_CTRL0_IRQ_STATUS		0x238708
+#define IPU6V6_REG_ISYS_CSI_TOP_CTRL0_IRQ_CLEAR			0x23870c
+#define IPU6V6_REG_ISYS_CSI_TOP_CTRL0_IRQ_ENABLE		0x238710
+#define IPU6V6_REG_ISYS_CSI_TOP_CTRL0_IRQ_LEVEL_NOT_PULSE	0x238714
+
+#define IPU6V6_REG_ISYS_CSI_TOP_CTRL1_IRQ_EDGE			0x238720
+#define IPU6V6_REG_ISYS_CSI_TOP_CTRL1_IRQ_MASK			0x238724
+#define IPU6V6_REG_ISYS_CSI_TOP_CTRL1_IRQ_STATUS		0x238728
+#define IPU6V6_REG_ISYS_CSI_TOP_CTRL1_IRQ_CLEAR			0x23872c
+#define IPU6V6_REG_ISYS_CSI_TOP_CTRL1_IRQ_ENABLE		0x238730
+#define IPU6V6_REG_ISYS_CSI_TOP_CTRL1_IRQ_LEVEL_NOT_PULSE	0x238734
+
 #define IPU_REG_ISYS_UNISPART_IRQ_EDGE			0x27c000
 #define IPU_REG_ISYS_UNISPART_IRQ_MASK			0x27c004
 #define IPU_REG_ISYS_UNISPART_IRQ_STATUS		0x27c008
diff --git a/drivers/media/pci/intel/ipu6/ipu-platform.h b/drivers/media/pci/intel/ipu6/ipu-platform.h
index 4eb6949efa1d..86b6e12b2bb4 100644
--- a/drivers/media/pci/intel/ipu6/ipu-platform.h
+++ b/drivers/media/pci/intel/ipu6/ipu-platform.h
@@ -10,9 +10,13 @@
 #define IPU6EP_FIRMWARE_NAME		"intel/ipu6ep_fw.bin"
 #define IPU6EPES_FIRMWARE_NAME		"intel/ipu6epes_fw.bin"
 #define IPU6_FIRMWARE_NAME		"intel/ipu6_fw.bin"
+#define IPU6EPMTL_FIRMWARE_NAME		"intel/ipu6epmtl_fw.bin"
 
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA) \
+	&& IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_PDATA_DYNAMIC_LOADING)
 /* array of struct ipu_spdata_rep terminated by NULL */
 #define IPU_SPDATA_NAME		"ipu6v1_spdata.bin"
+#endif
 
 /*
  * The following definitions are encoded to the media_device's model field so
diff --git a/drivers/media/pci/intel/ipu6/ipu-resources.c b/drivers/media/pci/intel/ipu6/ipu-resources.c
index 76d03a30ff38..365b1ba7ebb4 100644
--- a/drivers/media/pci/intel/ipu6/ipu-resources.c
+++ b/drivers/media/pci/intel/ipu6/ipu-resources.c
@@ -21,7 +21,7 @@ void ipu6_psys_hw_res_variant_init(void)
 	} else if (ipu_ver == IPU_VER_6) {
 		hw_var.queue_num = IPU6_FW_PSYS_N_PSYS_CMD_QUEUE_ID;
 		hw_var.cell_num = IPU6_FW_PSYS_N_CELL_ID;
-	} else if (ipu_ver == IPU_VER_6EP) {
+	} else if (ipu_ver == IPU_VER_6EP || ipu_ver == IPU_VER_6EP_MTL) {
 		hw_var.queue_num = IPU6_FW_PSYS_N_PSYS_CMD_QUEUE_ID;
 		hw_var.cell_num = IPU6EP_FW_PSYS_N_CELL_ID;
 	} else {
@@ -40,7 +40,7 @@ static const struct ipu_fw_resource_definitions *get_res(void)
 	if (ipu_ver == IPU_VER_6SE)
 		return ipu6se_res_defs;
 
-	if (ipu_ver == IPU_VER_6EP)
+	if (ipu_ver == IPU_VER_6EP || ipu_ver == IPU_VER_6EP_MTL)
 		return ipu6ep_res_defs;
 
 	return ipu6_res_defs;
@@ -242,7 +242,7 @@ static int __alloc_one_resrc(const struct device *dev,
 	const u16 resource_offset_req = pm->dev_chn_offset[resource_id];
 	unsigned long retl;
 
-	if (resource_req <= 0)
+	if (!resource_req)
 		return -ENXIO;
 
 	if (alloc->resources >= IPU_MAX_RESOURCES) {
@@ -283,7 +283,7 @@ static int ipu_psys_allocate_one_dfm(const struct device *dev,
 	struct ipu_resource_alloc *alloc_resource;
 	unsigned long p = 0;
 
-	if (dfm_bitmap_req == 0)
+	if (!dfm_bitmap_req)
 		return -ENXIO;
 
 	if (alloc->resources >= IPU_MAX_RESOURCES) {
@@ -344,7 +344,7 @@ static int __alloc_mem_resrc(const struct device *dev,
 
 	unsigned long retl;
 
-	if (memory_resource_req <= 0)
+	if (!memory_resource_req)
 		return -ENXIO;
 
 	if (alloc->resources >= IPU_MAX_RESOURCES) {
@@ -487,7 +487,10 @@ int ipu_psys_try_allocate_resources(struct device *dev,
 				ret = __alloc_one_resrc(dev, process,
 							&pool->dev_channels[id],
 							&pm, id, alloc);
-				if (ret && ret != -ENXIO)
+				if (ret == -ENXIO)
+					continue;
+
+				if (ret)
 					goto free_out;
 			}
 		}
@@ -497,7 +500,10 @@ int ipu_psys_try_allocate_resources(struct device *dev,
 				ret = ipu_psys_allocate_one_dfm
 					(dev, process,
 					 &pool->dfms[id], &pm, id, alloc);
-				if (ret && ret != -ENXIO)
+				if (ret == -ENXIO)
+					continue;
+
+				if (ret)
 					goto free_out;
 			}
 		}
@@ -521,12 +527,15 @@ int ipu_psys_try_allocate_resources(struct device *dev,
 							&pool->ext_memory[bank],
 							&pm, mem_type_id, bank,
 							alloc);
-				if (ret && ret != -ENXIO)
+				if (ret == -ENXIO)
+					continue;
+
+				if (ret)
 					goto free_out;
 			}
 		}
 	}
-	alloc->cells |= cells;
+
 	pool->cells |= cells;
 
 	kfree(alloc);
diff --git a/drivers/media/pci/intel/ipu6/ipu6-fw-resources.c b/drivers/media/pci/intel/ipu6/ipu6-fw-resources.c
index 338e90d8f29b..3b4ecb6eb422 100644
--- a/drivers/media/pci/intel/ipu6/ipu6-fw-resources.c
+++ b/drivers/media/pci/intel/ipu6/ipu6-fw-resources.c
@@ -555,7 +555,8 @@ void ipu6_fw_psys_pg_dump(struct ipu_psys *psys,
 		mem_type = IPU6SE_FW_PSYS_N_DATA_MEM_TYPE_ID;
 		max_mem_id = IPU6SE_FW_PSYS_N_MEM_ID;
 		dev_chn = IPU6SE_FW_PSYS_N_DEV_CHN_ID;
-	} else if (ipu_ver == IPU_VER_6 || ipu_ver == IPU_VER_6EP) {
+	} else if (ipu_ver == IPU_VER_6 || ipu_ver == IPU_VER_6EP ||
+		   ipu_ver == IPU_VER_6EP_MTL) {
 		mem_type = IPU6_FW_PSYS_N_DATA_MEM_TYPE_ID;
 		max_mem_id = IPU6_FW_PSYS_N_MEM_ID;
 		dev_chn = IPU6_FW_PSYS_N_DEV_CHN_ID;
@@ -600,7 +601,7 @@ void ipu6_fw_psys_pg_dump(struct ipu_psys *psys,
 			  struct ipu_psys_kcmd *kcmd, const char *note)
 {
 	if (ipu_ver == IPU_VER_6SE || ipu_ver == IPU_VER_6 ||
-	    ipu_ver == IPU_VER_6EP)
+	    ipu_ver == IPU_VER_6EP || ipu_ver == IPU_VER_6EP_MTL)
 		return;
 
 	WARN(1, "%s ipu_ver:[%u] is unsupported!\n", __func__, ipu_ver);
diff --git a/drivers/media/pci/intel/ipu6/ipu6-isys-csi2.c b/drivers/media/pci/intel/ipu6/ipu6-isys-csi2.c
index 88b4aa41069a..68da67def4b5 100644
--- a/drivers/media/pci/intel/ipu6/ipu6-isys-csi2.c
+++ b/drivers/media/pci/intel/ipu6/ipu6-isys-csi2.c
@@ -1,5 +1,5 @@
 // SPDX-License-Identifier: GPL-2.0
-// Copyright (C) 2020 Intel Corporation
+// Copyright (C) 2020 - 2022 Intel Corporation
 
 #include <linux/delay.h>
 #include <linux/spinlock.h>
@@ -12,6 +12,7 @@
 #include "ipu-platform-isys-csi2-reg.h"
 #include "ipu6-isys-csi2.h"
 #include "ipu6-isys-phy.h"
+#include "ipu6-isys-dwc-phy.h"
 #include "ipu-isys-csi2.h"
 
 struct ipu6_csi2_error {
@@ -71,7 +72,8 @@ static int ipu6_csi2_phy_power_set(struct ipu_isys *isys,
 	dev_dbg(&isys->adev->dev, "for phy %d port %d, lanes: %d\n",
 		phy_id, port, cfg->nlanes);
 
-	nr = (ipu_ver == IPU_VER_6 || ipu_ver == IPU_VER_6EP) ?
+	nr = (ipu_ver == IPU_VER_6 || ipu_ver == IPU_VER_6EP ||
+	      ipu_ver == IPU_VER_6EP_MTL) ?
 		IPU6_ISYS_CSI_PORT_NUM : IPU6SE_ISYS_CSI_PORT_NUM;
 
 	if (!isys_base || port >= nr) {
@@ -93,8 +95,14 @@ static int ipu6_csi2_phy_power_set(struct ipu_isys *isys,
 			return ret;
 
 		ipu6_isys_phy_reset(isys, phy_id, 0);
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA)
 		ipu6_isys_phy_common_init(isys, cfg);
 		ret = ipu6_isys_phy_config(isys, cfg);
+#else
+		ipu6_isys_phy_common_init(isys);
+
+		ret = ipu6_isys_phy_config(isys);
+#endif
 		if (ret)
 			return ret;
 
@@ -116,13 +124,125 @@ static int ipu6_csi2_phy_power_set(struct ipu_isys *isys,
 	return ret;
 }
 
+static int ipu6_csi2_dwc_phy_power_set(struct ipu_isys *isys,
+				       struct ipu_isys_csi2_config *cfg, bool on)
+{
+	int ret = 0;
+	u32 port;
+	u32 phy_id, primary, secondary;
+	u32 nlanes;
+	u32 mbps;
+	void __iomem *isys_base = isys->pdata->base;
+	u32 nr;
+	s64 link_freq;
+
+	port = cfg->port;
+
+	nr = (ipu_ver == IPU_VER_6 || ipu_ver == IPU_VER_6EP ||
+	      ipu_ver == IPU_VER_6EP_MTL) ?
+		IPU6_ISYS_CSI_PORT_NUM : IPU6SE_ISYS_CSI_PORT_NUM;
+
+	if (!isys_base || port >= nr) {
+		dev_warn(&isys->adev->dev, "invalid port ID %d\n", port);
+		return -EINVAL;
+	}
+
+	nlanes = cfg->nlanes;
+	/* only port a/c/e support 4 lanes */
+	if (nlanes == 4 && port % 2) {
+		dev_err(&isys->adev->dev, "invalid csi-port %u with %u lanes\n",
+			port, nlanes);
+		return -EINVAL;
+	}
+
+	ret = ipu_isys_csi2_get_link_freq(&isys->csi2[port], &link_freq);
+	if (ret) {
+		dev_err(&isys->adev->dev,
+			"get link freq failed(%d).\n", ret);
+		return ret;
+	}
+
+	do_div(link_freq, 1000000);
+	mbps = link_freq * 2;
+
+	phy_id = port;
+	primary = port & ~1;
+	secondary = primary + 1;
+	if (on) {
+		/* do rext flow for PHY-E */
+		ret = ipu6_isys_dwc_phy_termcal_rext(isys, mbps);
+		if (ret)
+			return ret;
+
+		if (nlanes == 4) {
+			dev_dbg(&isys->adev->dev,
+				"config phy %u and %u in aggregation mode",
+				primary, secondary);
+
+			ipu6_isys_dwc_phy_reset(isys, primary);
+			ipu6_isys_dwc_phy_reset(isys, secondary);
+			ipu6_isys_dwc_phy_aggr_setup(isys, primary,
+						     secondary, mbps);
+
+			ret = ipu6_isys_dwc_phy_config(isys, primary, mbps);
+			if (ret)
+				return ret;
+			ret = ipu6_isys_dwc_phy_config(isys, secondary, mbps);
+			if (ret)
+				return ret;
+
+			ret = ipu6_isys_dwc_phy_powerup_ack(isys, primary);
+			if (ret)
+				return ret;
+			ret = ipu6_isys_dwc_phy_powerup_ack(isys, secondary);
+			if (ret)
+				return ret;
+
+			return 0;
+		}
+
+		dev_dbg(&isys->adev->dev,
+			"config phy %u with %u lanes in non-aggr mode",
+			phy_id, nlanes);
+
+		ipu6_isys_dwc_phy_reset(isys, phy_id);
+		ret = ipu6_isys_dwc_phy_config(isys, phy_id, mbps);
+		if (ret)
+			return ret;
+
+		ret = ipu6_isys_dwc_phy_powerup_ack(isys, phy_id);
+		if (ret)
+			return ret;
+
+		return 0;
+	}
+
+	if (nlanes == 4) {
+		dev_dbg(&isys->adev->dev,
+			"Powerdown phy %u and phy %u for port %u",
+			primary, secondary, port);
+		ipu6_isys_dwc_phy_reset(isys, secondary);
+		ipu6_isys_dwc_phy_reset(isys, primary);
+
+		return 0;
+	}
+
+	dev_dbg(&isys->adev->dev,
+		"Powerdown phy %u with %u lanes", phy_id, nlanes);
+
+	ipu6_isys_dwc_phy_reset(isys, phy_id);
+
+	return 0;
+}
+
 static void ipu6_isys_register_errors(struct ipu_isys_csi2 *csi2)
 {
 	u32 mask = 0;
 	u32 irq = readl(csi2->base + CSI_PORT_REG_BASE_IRQ_CSI +
 			CSI_PORT_REG_BASE_IRQ_STATUS_OFFSET);
 
-	mask = (ipu_ver == IPU_VER_6 || ipu_ver == IPU_VER_6EP) ?
+	mask = (ipu_ver == IPU_VER_6 || ipu_ver == IPU_VER_6EP ||
+		ipu_ver == IPU_VER_6EP_MTL) ?
 		IPU6_CSI_RX_ERROR_IRQ_MASK : IPU6SE_CSI_RX_ERROR_IRQ_MASK;
 
 	writel(irq & mask,
@@ -343,18 +463,19 @@ int ipu_isys_csi2_set_stream(struct v4l2_subdev *sd,
 	struct ipu_isys_csi2_config *cfg =
 		v4l2_get_subdev_hostdata(media_entity_to_v4l2_subdev
 					 (ip->external->entity));
-	unsigned int port;
-	int ret;
+	unsigned int port, port_max;
+	int ret = 0;
 	u32 mask = 0;
+	unsigned int i;
 
 	port = cfg->port;
-	dev_dbg(&isys->adev->dev, "for port %u\n", port);
+	dev_dbg(&isys->adev->dev, "for port %u with %u lanes\n", port, nlanes);
 
-	mask = (ipu_ver == IPU_VER_6 || ipu_ver == IPU_VER_6EP) ?
+	mask = (ipu_ver == IPU_VER_6 || ipu_ver == IPU_VER_6EP ||
+		ipu_ver == IPU_VER_6EP_MTL) ?
 		IPU6_CSI_RX_ERROR_IRQ_MASK : IPU6SE_CSI_RX_ERROR_IRQ_MASK;
 
 	if (!enable) {
-
 		writel(0, csi2->base + CSI_REG_CSI_FE_ENABLE);
 		writel(0, csi2->base + CSI_REG_PPI2CSI_ENABLE);
 
@@ -372,28 +493,20 @@ int ipu_isys_csi2_set_stream(struct v4l2_subdev *sd,
 		       csi2->base + CSI_PORT_REG_BASE_IRQ_CSI_SYNC +
 		       CSI_PORT_REG_BASE_IRQ_CLEAR_OFFSET);
 
+		/* power down phy */
+		if (ipu_ver == IPU_VER_6EP_MTL)
+			ret = ipu6_csi2_dwc_phy_power_set(isys, cfg, false);
+
+		if (ipu_ver == IPU_VER_6 || ipu_ver == IPU_VER_6EP)
+			ret = ipu6_csi2_phy_power_set(isys, cfg, false);
+
 		/* Disable clock */
 		writel(0, isys->pdata->base +
 		       CSI_REG_HUB_FW_ACCESS_PORT(port));
 		writel(0, isys->pdata->base +
 		       CSI_REG_HUB_DRV_ACCESS_PORT(port));
 
-		if (ipu_ver == IPU_VER_6SE)
-			return 0;
-
-		/* power down */
-		return ipu6_csi2_phy_power_set(isys, cfg, false);
-	}
-
-	if (ipu_ver == IPU_VER_6 || ipu_ver == IPU_VER_6EP) {
-		/* Enable DPHY power */
-		ret = ipu6_csi2_phy_power_set(isys, cfg, true);
-		if (ret) {
-			dev_err(&isys->adev->dev,
-				"CSI-%d PHY power up failed %d\n",
-				cfg->port, ret);
-			return ret;
-		}
+		return ret;
 	}
 
 	/* reset port reset */
@@ -401,24 +514,20 @@ int ipu_isys_csi2_set_stream(struct v4l2_subdev *sd,
 	usleep_range(100, 200);
 	writel(0x0, csi2->base + CSI_REG_PORT_GPREG_SRST);
 
-	/* Enable port clock */
-	writel(1, isys->pdata->base + CSI_REG_HUB_DRV_ACCESS_PORT(port));
-	writel(1, isys->pdata->base + CSI_REG_HUB_FW_ACCESS_PORT(port));
-
-	if (ipu_ver == IPU_VER_6SE) {
-		ipu_isys_csi2_phy_config_by_port(isys, port, nlanes);
-
-		/* 9'b00010.1000 for 400Mhz isys freqency */
-		writel(0x28,
-		       isys->pdata->base + CSI2_HUB_GPREG_DPHY_TIMER_INCR);
-		/* set port cfg and rx timing */
-		ipu_isys_csi2_set_timing(sd, timing, port, nlanes);
-
-		ret = ipu_isys_csi2_set_port_cfg(sd, port, nlanes);
-		if (ret)
-			return ret;
+	/* We need enable clock for all ports for MTL */
+	port_max = (ipu_ver == IPU_VER_6 || ipu_ver == IPU_VER_6EP ||
+		    ipu_ver == IPU_VER_6EP_MTL) ?
+		IPU6_ISYS_CSI_PORT_NUM : IPU6SE_ISYS_CSI_PORT_NUM;
 
-		ipu_isys_csi2_rx_control(isys);
+	/* Enable port clock */
+	for (i = 0; i < port_max; i++) {
+		writel(1, isys->pdata->base + CSI_REG_HUB_DRV_ACCESS_PORT(i));
+		if (ipu_ver == IPU_VER_6EP_MTL)
+			writel(1, isys->pdata->base +
+			       IPU6V6_CSI_REG_HUB_FW_ACCESS_PORT(i));
+		else
+			writel(1, isys->pdata->base +
+			       CSI_REG_HUB_FW_ACCESS_PORT(i));
 	}
 
 	/* enable all error related irq */
@@ -463,13 +572,46 @@ int ipu_isys_csi2_set_stream(struct v4l2_subdev *sd,
 	writel(1, csi2->base + CSI_REG_PPI2CSI_ENABLE);
 	writel(1, csi2->base + CSI_REG_CSI_FE_ENABLE);
 
+	if (ipu_ver == IPU_VER_6 || ipu_ver == IPU_VER_6EP) {
+		/* Enable DPHY power */
+		ret = ipu6_csi2_phy_power_set(isys, cfg, true);
+		if (ret) {
+			dev_err(&isys->adev->dev,
+				"CSI-%d PHY power up failed %d\n",
+				cfg->port, ret);
+			return ret;
+		}
+	} else if (ipu_ver == IPU_VER_6EP_MTL) {
+		/* Enable DWC DPHY power */
+		ret = ipu6_csi2_dwc_phy_power_set(isys, cfg, true);
+		if (ret) {
+			dev_err(&isys->adev->dev,
+				"CSI-%d DWC-PHY power up failed %d\n",
+				cfg->port, ret);
+			return ret;
+		}
+	} else if (ipu_ver == IPU_VER_6SE) {
+		ipu_isys_csi2_phy_config_by_port(isys, port, nlanes);
+
+		/* 9'b00010.1000 for 400Mhz isys freqency */
+		writel(0x28,
+		       isys->pdata->base + CSI2_HUB_GPREG_DPHY_TIMER_INCR);
+		/* set port cfg and rx timing */
+		ipu_isys_csi2_set_timing(sd, timing, port, nlanes);
+
+		ret = ipu_isys_csi2_set_port_cfg(sd, port, nlanes);
+		if (ret)
+			return ret;
+
+		ipu_isys_csi2_rx_control(isys);
+	}
+
 	return 0;
 }
 
 void ipu_isys_csi2_isr(struct ipu_isys_csi2 *csi2)
 {
 	u32 status;
-	unsigned int i;
 
 	ipu6_isys_register_errors(csi2);
 
@@ -479,13 +621,10 @@ void ipu_isys_csi2_isr(struct ipu_isys_csi2 *csi2)
 	writel(status, csi2->base + CSI_PORT_REG_BASE_IRQ_CSI_SYNC +
 	       CSI_PORT_REG_BASE_IRQ_CLEAR_OFFSET);
 
-	for (i = 0; i < NR_OF_CSI2_VC; i++) {
-		if (status & IPU_CSI_RX_IRQ_FS_VC(i))
-			ipu_isys_csi2_sof_event(csi2, i);
-
-		if (status & IPU_CSI_RX_IRQ_FE_VC(i))
-			ipu_isys_csi2_eof_event(csi2, i);
-	}
+	if (status & IPU_CSI_RX_IRQ_FS_VC)
+		ipu_isys_csi2_sof_event(csi2);
+	if (status & IPU_CSI_RX_IRQ_FE_VC)
+		ipu_isys_csi2_eof_event(csi2);
 }
 
 unsigned int ipu_isys_csi2_get_current_field(struct ipu_isys_pipeline *ip,
diff --git a/drivers/media/pci/intel/ipu6/ipu6-isys-dwc-phy.c b/drivers/media/pci/intel/ipu6/ipu6-isys-dwc-phy.c
new file mode 100644
index 000000000000..fd6ea80bb371
--- /dev/null
+++ b/drivers/media/pci/intel/ipu6/ipu6-isys-dwc-phy.c
@@ -0,0 +1,539 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2013 - 2020 Intel Corporation
+ */
+
+#include <linux/delay.h>
+#include <linux/iopoll.h>
+#include <media/ipu-isys.h>
+#include <media/v4l2-device.h>
+#include "ipu.h"
+#include "ipu-buttress.h"
+#include "ipu-isys.h"
+#include "ipu-isys-csi2.h"
+#include "ipu-platform-regs.h"
+#include "ipu-platform-isys-csi2-reg.h"
+#include "ipu6-isys-csi2.h"
+#include "ipu6-isys-dwc-phy.h"
+
+#define IPU_DWC_DPHY_MAX_NUM			(6)
+#define IPU_DWC_DPHY_BASE(i)			(0x238038 + 0x34 * (i))
+#define IPU_DWC_DPHY_RSTZ			(0x00)
+#define IPU_DWC_DPHY_SHUTDOWNZ			(0x04)
+#define IPU_DWC_DPHY_HSFREQRANGE		(0x08)
+#define IPU_DWC_DPHY_CFGCLKFREQRANGE		(0x0c)
+#define IPU_DWC_DPHY_TEST_IFC_ACCESS_MODE	(0x10)
+#define IPU_DWC_DPHY_TEST_IFC_REQ		(0x14)
+#define IPU_DWC_DPHY_TEST_IFC_REQ_COMPLETION	(0x18)
+#define IPU_DWC_DPHY_TEST_IFC_CTRL0		(0x1c)
+#define IPU_DWC_DPHY_TEST_IFC_CTRL1		(0x20)
+#define IPU_DWC_DPHY_TEST_IFC_CTRL1_RO		(0x24)
+#define IPU_DWC_DPHY_DFT_CTRL0			(0x28)
+#define IPU_DWC_DPHY_DFT_CTRL1			(0x2c)
+#define IPU_DWC_DPHY_DFT_CTRL2			(0x30)
+
+#define PPI_DATAWIDTH_8BIT		0
+#define PPI_DATAWIDTH_16BIT		1
+
+/*
+ * test IFC request definition:
+ * - req: 0 for read, 1 for write
+ * - 12 bits address
+ * - 8bits data (will ignore for read)
+ * --24----16------4-----0
+ * --|-data-|-addr-|-req-|
+ */
+#define IFC_REQ(req, addr, data) ((data) << 16 | (addr) << 4 | (req))
+
+enum req_type {
+	TEST_IFC_REQ_READ = 0,
+	TEST_IFC_REQ_WRITE = 1,
+	TEST_IFC_REQ_RESET = 2,
+};
+
+enum access_mode {
+	TEST_IFC_ACCESS_MODE_FSM = 0,
+	/* backup mode for DFT/workaround etc */
+	TEST_IFC_ACCESS_MODE_IFC_CTL = 1,
+};
+
+enum phy_fsm_state {
+	PHY_FSM_STATE_POWERON = 0,
+	PHY_FSM_STATE_BGPON = 1,
+	PHY_FSM_STATE_CAL_TYPE = 2,
+	PHY_FSM_STATE_BURNIN_CAL = 3,
+	PHY_FSM_STATE_TERMCAL = 4,
+	PHY_FSM_STATE_OFFSETCAL = 5,
+	PHY_FSM_STATE_OFFSET_LANE = 6,
+	PHY_FSM_STATE_IDLE = 7,
+	PHY_FSM_STATE_ULP = 8,
+	PHY_FSM_STATE_DDLTUNNING = 9,
+	PHY_FSM_STATE_SKEW_BACKWARD = 10,
+	PHY_FSM_STATE_INVALID,
+};
+
+static void dwc_dphy_write(struct ipu_isys *isys, u32 phy_id, u32 addr,
+			   u32 data)
+{
+	void __iomem *isys_base = isys->pdata->base;
+	void __iomem *base = isys_base + IPU_DWC_DPHY_BASE(phy_id);
+
+	dev_dbg(&isys->adev->dev, "write: reg 0x%lx = data 0x%x",
+		base + addr - isys_base, data);
+	writel(data, base + addr);
+}
+
+static u32 dwc_dphy_read(struct ipu_isys *isys, u32 phy_id, u32 addr)
+{
+	u32 data;
+	void __iomem *isys_base = isys->pdata->base;
+	void __iomem *base = isys_base + IPU_DWC_DPHY_BASE(phy_id);
+
+	data = readl(base + addr);
+	dev_dbg(&isys->adev->dev, "read: reg 0x%lx = data 0x%x",
+		base + addr - isys_base, data);
+
+	return data;
+}
+
+static void dwc_dphy_write_mask(struct ipu_isys *isys, u32 phy_id, u32 addr,
+				u32 data, u8 shift, u8 width)
+{
+	u32 temp;
+	u32 mask;
+
+	mask = (1 << width) - 1;
+	temp = dwc_dphy_read(isys, phy_id, addr);
+	temp &= ~(mask << shift);
+	temp |= (data & mask) << shift;
+	dwc_dphy_write(isys, phy_id, addr, temp);
+}
+
+static u32 __maybe_unused dwc_dphy_read_mask(struct ipu_isys *isys, u32 phy_id,
+					     u32 addr, u8 shift,  u8 width)
+{
+	return (dwc_dphy_read(isys, phy_id, addr) >> shift) & ((1 << width) - 1);
+}
+
+#define DWC_DPHY_TIMEOUT (5000000)
+static int dwc_dphy_ifc_read(struct ipu_isys *isys, u32 phy_id, u32 addr, u32 *val)
+{
+	int rval;
+	u32 completion;
+	void __iomem *isys_base = isys->pdata->base;
+	void __iomem *base = isys_base + IPU_DWC_DPHY_BASE(phy_id);
+	void __iomem *reg;
+	u32 timeout = DWC_DPHY_TIMEOUT;
+
+	dwc_dphy_write(isys, phy_id, IPU_DWC_DPHY_TEST_IFC_REQ,
+		       IFC_REQ(TEST_IFC_REQ_READ, addr, 0));
+	reg = base + IPU_DWC_DPHY_TEST_IFC_REQ_COMPLETION;
+	rval = readl_poll_timeout(reg, completion, !(completion & BIT(0)),
+				  10, timeout);
+	if (rval) {
+		dev_err(&isys->adev->dev,
+			"%s: ifc request read timeout!", __func__);
+		return rval;
+	}
+
+	*val = completion >> 8 & 0xff;
+	dev_dbg(&isys->adev->dev, "ifc read 0x%x = 0x%x", addr, *val);
+
+	return 0;
+}
+
+static int dwc_dphy_ifc_write(struct ipu_isys *isys, u32 phy_id, u32 addr, u32 data)
+{
+	int rval;
+	u32 completion;
+	void __iomem *reg;
+	void __iomem *isys_base = isys->pdata->base;
+	void __iomem *base = isys_base + IPU_DWC_DPHY_BASE(phy_id);
+	u32 timeout = DWC_DPHY_TIMEOUT;
+
+	dwc_dphy_write(isys, phy_id, IPU_DWC_DPHY_TEST_IFC_REQ,
+		       IFC_REQ(TEST_IFC_REQ_WRITE, addr, data));
+	completion = readl(base + IPU_DWC_DPHY_TEST_IFC_REQ_COMPLETION);
+	reg = base + IPU_DWC_DPHY_TEST_IFC_REQ_COMPLETION;
+	rval = readl_poll_timeout(reg, completion, !(completion & BIT(0)),
+				  10, timeout);
+	if (rval) {
+		dev_err(&isys->adev->dev,
+			"%s: ifc request write timeout", __func__);
+		return rval;
+	}
+
+	return 0;
+}
+
+static void dwc_dphy_ifc_write_mask(struct ipu_isys *isys, u32 phy_id, u32 addr,
+				    u32 data, u8 shift, u8 width)
+{
+	int rval;
+	u32 temp, mask;
+
+	rval = dwc_dphy_ifc_read(isys, phy_id, addr, &temp);
+	if (rval) {
+		dev_err(&isys->adev->dev,
+			"dphy proxy read failed with %d", rval);
+		return;
+	}
+
+	mask = (1 << width) - 1;
+	temp &= ~(mask << shift);
+	temp |= (data & mask) << shift;
+	rval = dwc_dphy_ifc_write(isys, phy_id, addr, temp);
+	if (rval)
+		dev_err(&isys->adev->dev, "dphy proxy write failed(%d)", rval);
+}
+
+static u32 dwc_dphy_ifc_read_mask(struct ipu_isys *isys, u32 phy_id, u32 addr,
+				  u8 shift, u8 width)
+{
+	int rval;
+	u32 val;
+
+	rval = dwc_dphy_ifc_read(isys, phy_id, addr, &val);
+	if (rval) {
+		dev_err(&isys->adev->dev, "dphy proxy read failed with %d", rval);
+		return 0;
+	}
+
+	return ((val >> shift) & ((1 << width) - 1));
+}
+
+static int dwc_dphy_pwr_up(struct ipu_isys *isys, u32 phy_id)
+{
+	u32 fsm_state;
+	int ret;
+	u32 timeout = DWC_DPHY_TIMEOUT;
+
+	dwc_dphy_write(isys, phy_id, IPU_DWC_DPHY_RSTZ, 1);
+	usleep_range(10, 20);
+	dwc_dphy_write(isys, phy_id, IPU_DWC_DPHY_SHUTDOWNZ, 1);
+
+	ret = read_poll_timeout(dwc_dphy_ifc_read_mask, fsm_state,
+				(fsm_state == PHY_FSM_STATE_IDLE ||
+				 fsm_state == PHY_FSM_STATE_ULP), 100, timeout,
+				false, isys, phy_id, 0x1e, 0, 4);
+
+	if (ret) {
+		dev_err(&isys->adev->dev, "DPHY%d power up failed, state 0x%x",
+			phy_id, fsm_state);
+		return ret;
+	}
+
+	return 0;
+}
+
+struct dwc_dphy_freq_range {
+	u8 hsfreq;
+	u32 min;
+	u32 max;
+	u32 default_mbps;
+	u32 osc_freq_target;
+};
+
+#define DPHY_FREQ_RANGE_NUM		(63)
+#define DPHY_FREQ_RANGE_INVALID_INDEX	(0xff)
+const struct dwc_dphy_freq_range freqranges[DPHY_FREQ_RANGE_NUM] = {
+	{0x00,	80,	97,	80,	448},
+	{0x10,	80,	107,	90,	448},
+	{0x20,	84,	118,	100,	448},
+	{0x30,	93,	128,	110,	448},
+	{0x01,	103,	139,	120,	448},
+	{0x11,	112,	149,	130,	448},
+	{0x21,	122,	160,	140,	448},
+	{0x31,	131,	170,	150,	448},
+	{0x02,	141,	181,	160,	448},
+	{0x12,	150,	191,	170,	448},
+	{0x22,	160,	202,	180,	448},
+	{0x32,	169,	212,	190,	448},
+	{0x03,	183,	228,	205,	448},
+	{0x13,	198,	244,	220,	448},
+	{0x23,	212,	259,	235,	448},
+	{0x33,	226,	275,	250,	448},
+	{0x04,	250,	301,	275,	448},
+	{0x14,	274,	328,	300,	448},
+	{0x25,	297,	354,	325,	448},
+	{0x35,	321,	380,	350,	448},
+	{0x05,	369,	433,	400,	448},
+	{0x16,	416,	485,	450,	448},
+	{0x26,	464,	538,	500,	448},
+	{0x37,	511,	590,	550,	448},
+	{0x07,	559,	643,	600,	448},
+	{0x18,	606,	695,	650,	448},
+	{0x28,	654,	748,	700,	448},
+	{0x39,	701,	800,	750,	448},
+	{0x09,	749,	853,	800,	448},
+	{0x19,	796,	905,	850,	448},
+	{0x29,	844,	958,	900,	448},
+	{0x3a,	891,	1010,	950,	448},
+	{0x0a,	939,	1063,	1000,	448},
+	{0x1a,	986,	1115,	1050,	448},
+	{0x2a,	1034,	1168,	1100,	448},
+	{0x3b,	1081,	1220,	1150,	448},
+	{0x0b,	1129,	1273,	1200,	448},
+	{0x1b,	1176,	1325,	1250,	448},
+	{0x2b,	1224,	1378,	1300,	448},
+	{0x3c,	1271,	1430,	1350,	448},
+	{0x0c,	1319,	1483,	1400,	448},
+	{0x1c,	1366,	1535,	1450,	448},
+	{0x2c,	1414,	1588,	1500,	448},
+	{0x3d,	1461,	1640,	1550,	278},
+	{0x0d,	1509,	1693,	1600,	287},
+	{0x1d,	1556,	1745,	1650,	296},
+	{0x2e,	1604,	1798,	1700,	305},
+	{0x3e,	1651,	1850,	1750,	314},
+	{0x0e,	1699,	1903,	1800,	323},
+	{0x1e,	1746,	1955,	1850,	331},
+	{0x2f,	1794,	2008,	1900,	340},
+	{0x3f,	1841,	2060,	1950,	349},
+	{0x0f,	1889,	2113,	2000,	358},
+	{0x40,	1936,	2165,	2050,	367},
+	{0x41,	1984,	2218,	2100,	376},
+	{0x42,	2031,	2270,	2150,	385},
+	{0x43,	2079,	2323,	2200,	394},
+	{0x44,	2126,	2375,	2250,	403},
+	{0x45,	2174,	2428,	2300,	412},
+	{0x46,	2221,	2480,	2350,	421},
+	{0x47,	2269,	2500,	2400,	430},
+	{0x48,	2316,	2500,	2450,	439},
+	{0x49,	2364,	2500,	2500,	448},
+};
+
+static u32 get_hsfreq_by_mbps(u32 mbps)
+{
+	int i;
+
+	for (i = DPHY_FREQ_RANGE_NUM - 1; i >= 0; i--) {
+		if (freqranges[i].default_mbps == mbps ||
+		    (mbps >= freqranges[i].min && mbps <= freqranges[i].max))
+			return i;
+	}
+
+	return DPHY_FREQ_RANGE_INVALID_INDEX;
+}
+
+int ipu6_isys_dwc_phy_config(struct ipu_isys *isys, u32 phy_id, u32 mbps)
+{
+	u32 index;
+	u32 osc_freq_target;
+	u32 cfg_clk_freqrange;
+	struct ipu_bus_device *adev = to_ipu_bus_device(&isys->adev->dev);
+	struct ipu_device *isp = adev->isp;
+
+	dev_dbg(&isys->adev->dev, "config phy %u with %u mbps", phy_id, mbps);
+
+	index = get_hsfreq_by_mbps(mbps);
+	if (index == DPHY_FREQ_RANGE_INVALID_INDEX) {
+		dev_err(&isys->adev->dev, "link freq not found for mbps %u",
+			mbps);
+		return -EINVAL;
+	}
+
+	dwc_dphy_write_mask(isys, phy_id, IPU_DWC_DPHY_HSFREQRANGE,
+			    freqranges[index].hsfreq, 0, 7);
+
+	/* Force termination Calibration */
+	if (isys->phy_termcal_val) {
+		dwc_dphy_ifc_write_mask(isys, phy_id, 0x20a, 0x1, 0, 1);
+		dwc_dphy_ifc_write_mask(isys, phy_id, 0x209, 0x3, 0, 2);
+		dwc_dphy_ifc_write_mask(isys, phy_id, 0x209,
+					isys->phy_termcal_val, 4, 4);
+	}
+
+	/*
+	 * Enable override to configure the DDL target oscillation
+	 * frequency on bit 0 of register 0xe4
+	 */
+	dwc_dphy_ifc_write_mask(isys, phy_id, 0xe4, 0x1, 0, 1);
+	/*
+	 * configure registers 0xe2, 0xe3 with the
+	 * appropriate DDL target oscillation frequency
+	 * 0x1cc(460)
+	 */
+	osc_freq_target = freqranges[index].osc_freq_target;
+	dwc_dphy_ifc_write_mask(isys, phy_id, 0xe2,
+				osc_freq_target & 0xff, 0, 8);
+	dwc_dphy_ifc_write_mask(isys, phy_id, 0xe3,
+				(osc_freq_target >> 8) & 0xf, 0, 4);
+
+	if (mbps < 1500) {
+		/* deskew_polarity_rw, for < 1.5Gbps */
+		dwc_dphy_ifc_write_mask(isys, phy_id, 0x8, 0x1, 5, 1);
+	}
+
+	/*
+	 * Set cfgclkfreqrange[5:0] = round[(Fcfg_clk(MHz)-17)*4]
+	 * (38.4 - 17) * 4 = ~85 (0x55)
+	 */
+	cfg_clk_freqrange = (isp->buttress.ref_clk - 170) * 4 / 10;
+	dev_dbg(&isys->adev->dev, "ref_clk = %u clf_freqrange = %u",
+		isp->buttress.ref_clk, cfg_clk_freqrange);
+	dwc_dphy_write_mask(isys, phy_id, IPU_DWC_DPHY_CFGCLKFREQRANGE,
+			    cfg_clk_freqrange, 0, 8);
+
+	/*
+	 * run without external reference resistor for 2Gbps
+	 * dwc_dphy_ifc_write_mask(isys, phy_id, 0x4, 0x0, 4, 1);
+	 */
+
+	dwc_dphy_write_mask(isys, phy_id, IPU_DWC_DPHY_DFT_CTRL2, 0x1, 4, 1);
+	dwc_dphy_write_mask(isys, phy_id, IPU_DWC_DPHY_DFT_CTRL2, 0x1, 8, 1);
+
+	return 0;
+}
+
+void ipu6_isys_dwc_phy_aggr_setup(struct ipu_isys *isys, u32 master, u32 slave,
+				  u32 mbps)
+{
+	/* Config mastermacro */
+	dwc_dphy_ifc_write_mask(isys, master, 0x133, 0x1, 0, 1);
+	dwc_dphy_ifc_write_mask(isys, slave, 0x133, 0x0, 0, 1);
+
+	/* Config master PHY clk lane to drive long channel clk */
+	dwc_dphy_ifc_write_mask(isys, master, 0x307, 0x1, 2, 1);
+	dwc_dphy_ifc_write_mask(isys, slave, 0x307, 0x0, 2, 1);
+
+	/* Config both PHYs data lanes to get clk from long channel */
+	dwc_dphy_ifc_write_mask(isys, master, 0x508, 0x1, 5, 1);
+	dwc_dphy_ifc_write_mask(isys, slave, 0x508, 0x1, 5, 1);
+	dwc_dphy_ifc_write_mask(isys, master, 0x708, 0x1, 5, 1);
+	dwc_dphy_ifc_write_mask(isys, slave, 0x708, 0x1, 5, 1);
+
+	/* Config slave PHY clk lane to bypass long channel clk to DDR clk */
+	dwc_dphy_ifc_write_mask(isys, master, 0x308, 0x0, 3, 1);
+	dwc_dphy_ifc_write_mask(isys, slave, 0x308, 0x1, 3, 1);
+
+	/* Override slave PHY clk lane enable (DPHYRXCLK_CLL_demux module) */
+	dwc_dphy_ifc_write_mask(isys, slave, 0xe0, 0x3, 0, 2);
+
+	/* Override slave PHY DDR clk lane enable (DPHYHSRX_div124 module) */
+	dwc_dphy_ifc_write_mask(isys, slave, 0xe1, 0x1, 1, 1);
+	dwc_dphy_ifc_write_mask(isys, slave, 0x307, 0x1, 3, 1);
+
+	/* Turn off slave PHY LP-RX clk lane */
+	dwc_dphy_ifc_write_mask(isys, slave, 0x304, 0x1, 7, 1);
+	dwc_dphy_ifc_write_mask(isys, slave, 0x305, 0xa, 0, 5);
+}
+
+int ipu6_isys_dwc_phy_powerup_ack(struct ipu_isys *isys, u32 phy_id)
+{
+	int rval;
+
+	rval = dwc_dphy_pwr_up(isys, phy_id);
+	if (rval != 0) {
+		dev_err(&isys->adev->dev, "dphy%u power up failed(%d)", phy_id,
+			rval);
+		return rval;
+	}
+
+	/* reset forcerxmode */
+	dwc_dphy_write_mask(isys, phy_id, IPU_DWC_DPHY_DFT_CTRL2, 0, 4, 1);
+	dwc_dphy_write_mask(isys, phy_id, IPU_DWC_DPHY_DFT_CTRL2, 0, 8, 1);
+
+	dev_dbg(&isys->adev->dev, "phy %u is ready!", phy_id);
+
+	return 0;
+}
+
+void ipu6_isys_dwc_phy_reset(struct ipu_isys *isys, u32 phy_id)
+{
+	dev_dbg(&isys->adev->dev, "Reset phy %u", phy_id);
+
+	dwc_dphy_write(isys, phy_id, IPU_DWC_DPHY_SHUTDOWNZ, 0);
+	dwc_dphy_write(isys, phy_id, IPU_DWC_DPHY_RSTZ, 0);
+	dwc_dphy_write(isys, phy_id, IPU_DWC_DPHY_TEST_IFC_ACCESS_MODE,
+		       TEST_IFC_ACCESS_MODE_FSM);
+	dwc_dphy_write(isys, phy_id, IPU_DWC_DPHY_TEST_IFC_REQ,
+		       TEST_IFC_REQ_RESET);
+}
+
+#define PHY_E	(4)
+int ipu6_isys_dwc_phy_termcal_rext(struct ipu_isys *isys, u32 mbps)
+{
+	u32 index;
+	u32 osc_freq_target;
+	u32 cfg_clk_freqrange;
+	u32 rescal_done;
+	struct ipu_bus_device *adev = to_ipu_bus_device(&isys->adev->dev);
+	struct ipu_device *isp = adev->isp;
+	int ret;
+	u32 phy_id = PHY_E;
+
+	if (isys->phy_termcal_val) {
+		dev_dbg(&isys->adev->dev, "phy term cal already done, ignore.");
+		return 0;
+	}
+
+	dev_dbg(&isys->adev->dev, "phy %u term calibration with %u mbps",
+		phy_id, mbps);
+
+	ipu6_isys_dwc_phy_reset(isys, phy_id);
+
+	index = get_hsfreq_by_mbps(mbps);
+	if (index == DPHY_FREQ_RANGE_INVALID_INDEX) {
+		dev_err(&isys->adev->dev, "link freq not found for mbps %u",
+			mbps);
+		return -EINVAL;
+	}
+
+	dwc_dphy_write_mask(isys, phy_id, IPU_DWC_DPHY_HSFREQRANGE,
+			    freqranges[index].hsfreq, 0, 7);
+
+	/*
+	 * Enable override to configure the DDL target oscillation
+	 * frequency on bit 0 of register 0xe4
+	 */
+	dwc_dphy_ifc_write_mask(isys, phy_id, 0xe4, 0x1, 0, 1);
+	/*
+	 * configure registers 0xe2, 0xe3 with the
+	 * appropriate DDL target oscillation frequency
+	 * 0x1cc(460)
+	 */
+	osc_freq_target = freqranges[index].osc_freq_target;
+	dwc_dphy_ifc_write_mask(isys, phy_id, 0xe2,
+				osc_freq_target & 0xff, 0, 8);
+	dwc_dphy_ifc_write_mask(isys, phy_id, 0xe3,
+				(osc_freq_target >> 8) & 0xff, 0, 4);
+
+	if (mbps < 1500) {
+		/* deskew_polarity_rw, for < 1.5Gbps */
+		dwc_dphy_ifc_write_mask(isys, phy_id, 0x8, 0x1, 5, 1);
+	}
+
+	/*
+	 * Set cfgclkfreqrange[5:0] = round[(Fcfg_clk(MHz)-17)*4]
+	 * (38.4 - 17) * 4 = 84 (0x54)
+	 */
+	cfg_clk_freqrange = (isp->buttress.ref_clk / 10 - 17) * 4;
+	dwc_dphy_write_mask(isys, phy_id, IPU_DWC_DPHY_CFGCLKFREQRANGE,
+			    cfg_clk_freqrange, 0, 8);
+
+	/*
+	 * run without external reference resistor for 2Gbps
+	 * dwc_dphy_ifc_write_mask(isys, phy_id, 0x4, 0x0, 4, 1);
+	 */
+
+	dwc_dphy_write_mask(isys, phy_id, IPU_DWC_DPHY_DFT_CTRL2, 0x1, 4, 1);
+	dwc_dphy_write_mask(isys, phy_id, IPU_DWC_DPHY_DFT_CTRL2, 0x1, 8, 1);
+
+	ret = ipu6_isys_dwc_phy_powerup_ack(isys, phy_id);
+	if (ret)
+		return ret;
+
+	usleep_range(100, 200);
+	rescal_done = dwc_dphy_ifc_read_mask(isys, phy_id, 0x221, 7, 1);
+	if (rescal_done) {
+		isys->phy_termcal_val = dwc_dphy_ifc_read_mask(isys, phy_id,
+							       0x220, 2, 4);
+		dev_dbg(&isys->adev->dev, "termcal done with value = %u",
+			isys->phy_termcal_val);
+	}
+
+	/* whatever reset the phy E after rext flow */
+	ipu6_isys_dwc_phy_reset(isys, phy_id);
+
+	return 0;
+}
diff --git a/drivers/media/pci/intel/ipu6/ipu6-isys-dwc-phy.h b/drivers/media/pci/intel/ipu6/ipu6-isys-dwc-phy.h
new file mode 100644
index 000000000000..565d2c3643ac
--- /dev/null
+++ b/drivers/media/pci/intel/ipu6/ipu6-isys-dwc-phy.h
@@ -0,0 +1,15 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2013 - 2022 Intel Corporation
+ */
+
+#ifndef IPU6_ISYS_DWC_PHY_H
+#define IPU6_ISYS_DWC_PHY_H
+
+int ipu6_isys_dwc_phy_powerup_ack(struct ipu_isys *isys, u32 phy_id);
+int ipu6_isys_dwc_phy_config(struct ipu_isys *isys, u32 phy_id, u32 mbps);
+int ipu6_isys_dwc_phy_termcal_rext(struct ipu_isys *isys, u32 mbps);
+void ipu6_isys_dwc_phy_reset(struct ipu_isys *isys, u32 phy_id);
+void ipu6_isys_dwc_phy_aggr_setup(struct ipu_isys *isys, u32 master, u32 slave,
+				  u32 mbps);
+#endif
diff --git a/drivers/media/pci/intel/ipu6/ipu6-isys-phy.c b/drivers/media/pci/intel/ipu6/ipu6-isys-phy.c
index 3216bb393e96..6ba2c72201fe 100644
--- a/drivers/media/pci/intel/ipu6/ipu6-isys-phy.c
+++ b/drivers/media/pci/intel/ipu6/ipu6-isys-phy.c
@@ -497,6 +497,7 @@ int ipu6_isys_phy_ready(struct ipu_isys *isys, unsigned int phy_id)
 	return -ETIMEDOUT;
 }
 
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA)
 int ipu6_isys_phy_common_init(struct ipu_isys *isys, struct ipu_isys_csi2_config *cfg)
 {
 	unsigned int phy_id;
@@ -516,6 +517,32 @@ int ipu6_isys_phy_common_init(struct ipu_isys *isys, struct ipu_isys_csi2_config
 
 	return 0;
 }
+#else
+int ipu6_isys_phy_common_init(struct ipu_isys *isys)
+{
+	unsigned int phy_id;
+	void __iomem *phy_base;
+	struct ipu_bus_device *adev = to_ipu_bus_device(&isys->adev->dev);
+	struct ipu_device *isp = adev->isp;
+	void __iomem *isp_base = isp->base;
+	struct v4l2_async_subdev *asd;
+	struct sensor_async_subdev *s_asd;
+	unsigned int i;
+
+	list_for_each_entry(asd, &isys->notifier.asd_list, asd_list) {
+		s_asd = container_of(asd, struct sensor_async_subdev, asd);
+		phy_id = s_asd->csi2.port / 4;
+		phy_base = isp_base + IPU6_ISYS_PHY_BASE(phy_id);
+
+		for (i = 0 ; i < ARRAY_SIZE(common_init_regs); i++) {
+			writel(common_init_regs[i].val,
+				phy_base + common_init_regs[i].reg);
+		}
+	}
+
+	return 0;
+}
+#endif
 
 static int ipu6_isys_driver_port_to_phy_port(struct ipu_isys_csi2_config *cfg)
 {
@@ -548,6 +575,7 @@ static int ipu6_isys_driver_port_to_phy_port(struct ipu_isys_csi2_config *cfg)
 	return ret;
 }
 
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA)
 int ipu6_isys_phy_config(struct ipu_isys *isys, struct ipu_isys_csi2_config *cfg)
 {
 	unsigned int phy_port, phy_id;
@@ -595,3 +623,45 @@ int ipu6_isys_phy_config(struct ipu_isys *isys, struct ipu_isys_csi2_config *cfg
 
 	return 0;
 }
+#else
+int ipu6_isys_phy_config(struct ipu_isys *isys)
+{
+	int phy_port;
+	unsigned int phy_id;
+	void __iomem *phy_base;
+	struct ipu_bus_device *adev = to_ipu_bus_device(&isys->adev->dev);
+	struct ipu_device *isp = adev->isp;
+	void __iomem *isp_base = isp->base;
+	const struct phy_reg **phy_config_regs;
+	struct v4l2_async_subdev *asd;
+	struct sensor_async_subdev *s_asd;
+	struct ipu_isys_csi2_config cfg;
+	int i;
+
+	list_for_each_entry(asd, &isys->notifier.asd_list, asd_list) {
+		s_asd = container_of(asd, struct sensor_async_subdev, asd);
+		cfg.port = s_asd->csi2.port;
+		cfg.nlanes = s_asd->csi2.nlanes;
+		phy_port = ipu6_isys_driver_port_to_phy_port(&cfg);
+		if (phy_port < 0) {
+			dev_err(&isys->adev->dev, "invalid port %d for lane %d",
+				cfg.port, cfg.nlanes);
+			return -ENXIO;
+		}
+
+		phy_id = cfg.port / 4;
+		phy_base = isp_base + IPU6_ISYS_PHY_BASE(phy_id);
+		dev_dbg(&isys->adev->dev, "port%d PHY%u lanes %u\n",
+			cfg.port, phy_id, cfg.nlanes);
+
+		phy_config_regs = config_regs[cfg.nlanes/2];
+		cfg.port = phy_port;
+		for (i = 0; phy_config_regs[cfg.port][i].reg; i++) {
+			writel(phy_config_regs[cfg.port][i].val,
+				phy_base + phy_config_regs[cfg.port][i].reg);
+		}
+	}
+
+	return 0;
+}
+#endif
diff --git a/drivers/media/pci/intel/ipu6/ipu6-isys-phy.h b/drivers/media/pci/intel/ipu6/ipu6-isys-phy.h
index 3e4411b5350e..49fd8aa4b4d9 100644
--- a/drivers/media/pci/intel/ipu6/ipu6-isys-phy.h
+++ b/drivers/media/pci/intel/ipu6/ipu6-isys-phy.h
@@ -154,6 +154,11 @@ int ipu6_isys_phy_powerdown_ack(struct ipu_isys *isys, unsigned int phy_id);
 int ipu6_isys_phy_reset(struct ipu_isys *isys, unsigned int phy_id,
 			bool assert);
 int ipu6_isys_phy_ready(struct ipu_isys *isys, unsigned int phy_id);
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA)
 int ipu6_isys_phy_common_init(struct ipu_isys *isys, struct ipu_isys_csi2_config *cfg);
 int ipu6_isys_phy_config(struct ipu_isys *isys, struct ipu_isys_csi2_config *cfg);
+#else
+int ipu6_isys_phy_common_init(struct ipu_isys *isys);
+int ipu6_isys_phy_config(struct ipu_isys *isys);
+#endif
 #endif
diff --git a/drivers/media/pci/intel/ipu6/ipu6-isys.c b/drivers/media/pci/intel/ipu6/ipu6-isys.c
index 8a0dce09553d..bbbc594d6cf8 100644
--- a/drivers/media/pci/intel/ipu6/ipu6-isys.c
+++ b/drivers/media/pci/intel/ipu6/ipu6-isys.c
@@ -8,15 +8,7 @@
 #include "ipu-platform-regs.h"
 #include "ipu-trace.h"
 #include "ipu-isys.h"
-#ifdef CONFIG_VIDEO_INTEL_IPU_TPG
-#include "ipu-isys-tpg.h"
-#endif
 #include "ipu-platform-isys-csi2-reg.h"
-#ifdef IPU_TRACE_EVENT
-#define IPU_SOF_SEQID_TRACE
-#define IPU_EOF_SEQID_TRACE
-#include "../ipu-trace-event.h"
-#endif
 
 const struct ipu_isys_pixelformat ipu_isys_pfmts[] = {
 	{V4L2_PIX_FMT_SBGGR12, 16, 12, 0, MEDIA_BUS_FMT_SBGGR12_1X12,
@@ -43,8 +35,6 @@ const struct ipu_isys_pixelformat ipu_isys_pfmts[] = {
 	 IPU_FW_ISYS_FRAME_FORMAT_RAW8},
 	{V4L2_PIX_FMT_SRGGB8, 8, 8, 0, MEDIA_BUS_FMT_SRGGB8_1X8,
 	 IPU_FW_ISYS_FRAME_FORMAT_RAW8},
-	{V4L2_FMT_IPU_ISYS_META, 8, 8, 0, MEDIA_BUS_FMT_FIXED,
-	 IPU_FW_ISYS_MIPI_DATA_TYPE_EMBEDDED},
 	{}
 };
 
@@ -95,18 +85,27 @@ void isys_setup_hw(struct ipu_isys *isys)
 	u32 irqs = 0;
 	unsigned int i, nr;
 
-	nr = (ipu_ver == IPU_VER_6 || ipu_ver == IPU_VER_6EP) ?
+	nr = (ipu_ver == IPU_VER_6 || ipu_ver == IPU_VER_6EP ||
+	      ipu_ver == IPU_VER_6EP_MTL) ?
 		IPU6_ISYS_CSI_PORT_NUM : IPU6SE_ISYS_CSI_PORT_NUM;
 
 	/* Enable irqs for all MIPI ports */
 	for (i = 0; i < nr; i++)
 		irqs |= IPU_ISYS_UNISPART_IRQ_CSI2(i);
 
-	writel(irqs, base + IPU_REG_ISYS_CSI_TOP_CTRL0_IRQ_EDGE);
-	writel(irqs, base + IPU_REG_ISYS_CSI_TOP_CTRL0_IRQ_LEVEL_NOT_PULSE);
-	writel(0xffffffff, base + IPU_REG_ISYS_CSI_TOP_CTRL0_IRQ_CLEAR);
-	writel(irqs, base + IPU_REG_ISYS_CSI_TOP_CTRL0_IRQ_MASK);
-	writel(irqs, base + IPU_REG_ISYS_CSI_TOP_CTRL0_IRQ_ENABLE);
+	if (ipu_ver == IPU_VER_6EP_MTL) {
+		writel(irqs, base + IPU6V6_REG_ISYS_CSI_TOP_CTRL0_IRQ_EDGE);
+		writel(irqs, base + IPU6V6_REG_ISYS_CSI_TOP_CTRL0_IRQ_LEVEL_NOT_PULSE);
+		writel(0xffffffff, base + IPU6V6_REG_ISYS_CSI_TOP_CTRL0_IRQ_CLEAR);
+		writel(irqs, base + IPU6V6_REG_ISYS_CSI_TOP_CTRL0_IRQ_MASK);
+		writel(irqs, base + IPU6V6_REG_ISYS_CSI_TOP_CTRL0_IRQ_ENABLE);
+	} else {
+		writel(irqs, base + IPU_REG_ISYS_CSI_TOP_CTRL0_IRQ_EDGE);
+		writel(irqs, base + IPU_REG_ISYS_CSI_TOP_CTRL0_IRQ_LEVEL_NOT_PULSE);
+		writel(0xffffffff, base + IPU_REG_ISYS_CSI_TOP_CTRL0_IRQ_CLEAR);
+		writel(irqs, base + IPU_REG_ISYS_CSI_TOP_CTRL0_IRQ_MASK);
+		writel(irqs, base + IPU_REG_ISYS_CSI_TOP_CTRL0_IRQ_ENABLE);
+	}
 
 	irqs = ISYS_UNISPART_IRQS;
 	writel(irqs, base + IPU_REG_ISYS_UNISPART_IRQ_EDGE);
@@ -128,6 +127,7 @@ irqreturn_t isys_isr(struct ipu_bus_device *adev)
 	struct ipu_isys *isys = ipu_bus_get_drvdata(adev);
 	void __iomem *base = isys->pdata->base;
 	u32 status_sw, status_csi;
+	u32 ctrl0_status, ctrl0_clear;
 
 	spin_lock(&isys->power_lock);
 	if (!isys->power) {
@@ -135,16 +135,23 @@ irqreturn_t isys_isr(struct ipu_bus_device *adev)
 		return IRQ_NONE;
 	}
 
-	status_csi = readl(isys->pdata->base +
-			   IPU_REG_ISYS_CSI_TOP_CTRL0_IRQ_STATUS);
+	if (ipu_ver == IPU_VER_6EP_MTL) {
+		ctrl0_status = IPU6V6_REG_ISYS_CSI_TOP_CTRL0_IRQ_STATUS;
+		ctrl0_clear = IPU6V6_REG_ISYS_CSI_TOP_CTRL0_IRQ_CLEAR;
+	} else {
+		ctrl0_status = IPU_REG_ISYS_CSI_TOP_CTRL0_IRQ_STATUS;
+		ctrl0_clear = IPU_REG_ISYS_CSI_TOP_CTRL0_IRQ_CLEAR;
+	}
+
+	status_csi = readl(isys->pdata->base + ctrl0_status);
 	status_sw = readl(isys->pdata->base + IPU_REG_ISYS_UNISPART_IRQ_STATUS);
 
 	writel(ISYS_UNISPART_IRQS & ~IPU_ISYS_UNISPART_IRQ_SW,
 	       base + IPU_REG_ISYS_UNISPART_IRQ_MASK);
 
 	do {
-		writel(status_csi, isys->pdata->base +
-			   IPU_REG_ISYS_CSI_TOP_CTRL0_IRQ_CLEAR);
+		writel(status_csi, isys->pdata->base + ctrl0_clear);
+
 		writel(status_sw, isys->pdata->base +
 			   IPU_REG_ISYS_UNISPART_IRQ_CLEAR);
 
@@ -167,10 +174,9 @@ irqreturn_t isys_isr(struct ipu_bus_device *adev)
 		else
 			status_sw = 0;
 
-		status_csi = readl(isys->pdata->base +
-				       IPU_REG_ISYS_CSI_TOP_CTRL0_IRQ_STATUS);
+		status_csi = readl(isys->pdata->base + ctrl0_status);
 		status_sw |= readl(isys->pdata->base +
-				       IPU_REG_ISYS_UNISPART_IRQ_STATUS);
+				   IPU_REG_ISYS_UNISPART_IRQ_STATUS);
 	} while (((status_csi & isys->isr_csi2_bits) ||
 		  (status_sw & IPU_ISYS_UNISPART_IRQ_SW)) &&
 		 !isys->adev->isp->flr_done);
@@ -182,155 +188,3 @@ irqreturn_t isys_isr(struct ipu_bus_device *adev)
 	return IRQ_HANDLED;
 }
 
-#ifdef CONFIG_VIDEO_INTEL_IPU_TPG
-void ipu_isys_tpg_sof_event(struct ipu_isys_tpg *tpg)
-{
-	struct ipu_isys_pipeline *ip = NULL;
-	struct v4l2_event ev = {
-		.type = V4L2_EVENT_FRAME_SYNC,
-	};
-	struct video_device *vdev = tpg->asd.sd.devnode;
-	unsigned long flags;
-	unsigned int i, nr;
-
-	nr = (ipu_ver == IPU_VER_6 || ipu_ver == IPU_VER_6EP) ?
-		IPU6_ISYS_CSI_PORT_NUM : IPU6SE_ISYS_CSI_PORT_NUM;
-
-	spin_lock_irqsave(&tpg->isys->lock, flags);
-	for (i = 0; i < nr; i++) {
-		if (tpg->isys->pipes[i] && tpg->isys->pipes[i]->tpg == tpg) {
-			ip = tpg->isys->pipes[i];
-			break;
-		}
-	}
-
-	/* Pipe already vanished */
-	if (!ip) {
-		spin_unlock_irqrestore(&tpg->isys->lock, flags);
-		return;
-	}
-
-	ev.u.frame_sync.frame_sequence =
-		atomic_inc_return(&ip->sequence) - 1;
-	ev.id = ip->stream_id;
-	spin_unlock_irqrestore(&tpg->isys->lock, flags);
-
-	v4l2_event_queue(vdev, &ev);
-
-#ifdef IPU_TRACE_EVENT
-	trace_ipu_sof_seqid(ev.u.frame_sync.frame_sequence, tpg->index, 0);
-#endif
-	dev_dbg(&tpg->isys->adev->dev,
-		"sof_event::tpg-%i sequence: %i, stream_id: %d\n",
-		tpg->index, ev.u.frame_sync.frame_sequence, ip->stream_id);
-}
-
-void ipu_isys_tpg_eof_event(struct ipu_isys_tpg *tpg)
-{
-	struct ipu_isys_pipeline *ip = NULL;
-	unsigned long flags;
-	unsigned int i, nr;
-	u32 frame_sequence;
-
-	nr = (ipu_ver == IPU_VER_6 || ipu_ver == IPU_VER_6EP) ?
-		IPU6_ISYS_CSI_PORT_NUM : IPU6SE_ISYS_CSI_PORT_NUM;
-
-	spin_lock_irqsave(&tpg->isys->lock, flags);
-	for (i = 0; i < nr; i++) {
-		if (tpg->isys->pipes[i] && tpg->isys->pipes[i]->tpg == tpg) {
-			ip = tpg->isys->pipes[i];
-			break;
-		}
-	}
-
-	/* Pipe already vanished */
-	if (!ip) {
-		spin_unlock_irqrestore(&tpg->isys->lock, flags);
-		return;
-	}
-
-	frame_sequence = atomic_read(&ip->sequence);
-
-	spin_unlock_irqrestore(&tpg->isys->lock, flags);
-
-#ifdef IPU_TRACE_EVENT
-	trace_ipu_eof_seqid(frame_sequence, tpg->index, 0);
-#endif
-	dev_dbg(&tpg->isys->adev->dev,
-		"eof_event::tpg-%i sequence: %i\n",
-		tpg->index, frame_sequence);
-}
-
-int tpg_set_stream(struct v4l2_subdev *sd, int enable)
-{
-	struct ipu_isys_tpg *tpg = to_ipu_isys_tpg(sd);
-	__u32 code = tpg->asd.ffmt[TPG_PAD_SOURCE][0].code;
-	unsigned int bpp = ipu_isys_mbus_code_to_bpp(code);
-	struct ipu_isys_pipeline *ip =
-			to_ipu_isys_pipeline(sd->entity.pipe);
-
-	/*
-	 * MIPI_GEN block is CSI2 FB. Need to enable/disable TPG selection
-	 * register to control the TPG streaming.
-	 */
-	if (tpg->sel)
-		writel(enable ? 1 : 0, tpg->sel);
-
-	if (!enable) {
-		ip->tpg = NULL;
-		writel(0, tpg->base +
-		       CSI_REG_CSI_FE_ENABLE -
-		       CSI_REG_PIXGEN_COM_BASE_OFFSET);
-		writel(CSI_SENSOR_INPUT, tpg->base +
-		       CSI_REG_CSI_FE_MUX_CTRL -
-		       CSI_REG_PIXGEN_COM_BASE_OFFSET);
-		writel(CSI_CNTR_SENSOR_LINE_ID |
-		       CSI_CNTR_SENSOR_FRAME_ID,
-		       tpg->base + CSI_REG_CSI_FE_SYNC_CNTR_SEL -
-		       CSI_REG_PIXGEN_COM_BASE_OFFSET);
-		writel(0, tpg->base + MIPI_GEN_REG_COM_ENABLE);
-		return 0;
-	}
-
-	ip->has_sof = true;
-	ip->tpg = tpg;
-	/* Select MIPI GEN as input */
-	writel(0, tpg->base + CSI_REG_CSI_FE_MODE -
-	       CSI_REG_PIXGEN_COM_BASE_OFFSET);
-	writel(1, tpg->base + CSI_REG_CSI_FE_ENABLE -
-	       CSI_REG_PIXGEN_COM_BASE_OFFSET);
-	writel(CSI_MIPIGEN_INPUT, tpg->base +
-	       CSI_REG_CSI_FE_MUX_CTRL - CSI_REG_PIXGEN_COM_BASE_OFFSET);
-	writel(0, tpg->base + CSI_REG_CSI_FE_SYNC_CNTR_SEL -
-	       CSI_REG_PIXGEN_COM_BASE_OFFSET);
-
-	writel(MIPI_GEN_COM_DTYPE_RAW(bpp),
-	       tpg->base + MIPI_GEN_REG_COM_DTYPE);
-	writel(ipu_isys_mbus_code_to_mipi(code),
-	       tpg->base + MIPI_GEN_REG_COM_VTYPE);
-	writel(0, tpg->base + MIPI_GEN_REG_COM_VCHAN);
-
-	writel(0, tpg->base + MIPI_GEN_REG_SYNG_NOF_FRAMES);
-
-	writel(DIV_ROUND_UP(tpg->asd.ffmt[TPG_PAD_SOURCE][0].width *
-			    bpp, BITS_PER_BYTE),
-	       tpg->base + MIPI_GEN_REG_COM_WCOUNT);
-	writel(DIV_ROUND_UP(tpg->asd.ffmt[TPG_PAD_SOURCE][0].width,
-			    MIPI_GEN_PPC),
-	       tpg->base + MIPI_GEN_REG_SYNG_NOF_PIXELS);
-	writel(tpg->asd.ffmt[TPG_PAD_SOURCE][0].height,
-	       tpg->base + MIPI_GEN_REG_SYNG_NOF_LINES);
-
-	writel(0, tpg->base + MIPI_GEN_REG_TPG_MODE);
-	writel(-1, tpg->base + MIPI_GEN_REG_TPG_HCNT_MASK);
-	writel(-1, tpg->base + MIPI_GEN_REG_TPG_VCNT_MASK);
-	writel(-1, tpg->base + MIPI_GEN_REG_TPG_XYCNT_MASK);
-	writel(0, tpg->base + MIPI_GEN_REG_TPG_HCNT_DELTA);
-	writel(0, tpg->base + MIPI_GEN_REG_TPG_VCNT_DELTA);
-
-	v4l2_ctrl_handler_setup(&tpg->asd.ctrl_handler);
-
-	writel(2, tpg->base + MIPI_GEN_REG_COM_ENABLE);
-	return 0;
-}
-#endif
diff --git a/drivers/media/pci/intel/ipu6/ipu6-psys.c b/drivers/media/pci/intel/ipu6/ipu6-psys.c
index 9d9a38031e74..1c46de9eb71f 100644
--- a/drivers/media/pci/intel/ipu6/ipu6-psys.c
+++ b/drivers/media/pci/intel/ipu6/ipu6-psys.c
@@ -19,11 +19,6 @@
 #include "ipu6-ppg.h"
 #include "ipu-platform-regs.h"
 #include "ipu-trace.h"
-#ifdef IPU_TRACE_EVENT
-#define CREATE_TRACE_POINTS
-#define IPU_PG_KCMD_TRACE
-#include "ipu-trace-event.h"
-#endif
 
 static bool early_pg_transfer;
 module_param(early_pg_transfer, bool, 0664);
@@ -34,12 +29,6 @@ bool enable_power_gating = true;
 module_param(enable_power_gating, bool, 0664);
 MODULE_PARM_DESC(enable_power_gating, "enable power gating");
 
-#ifdef IPU_CACHE_DEBUG
-bool enable_cache_flush = true;
-module_param(enable_cache_flush, bool, 0664);
-MODULE_PARM_DESC(enable_cache_flush, "enable cache flush");
-#endif
-
 struct ipu_trace_block psys_trace_blocks[] = {
 	{
 		.offset = IPU_TRACE_REG_PS_TRACE_UNIT_BASE,
@@ -328,10 +317,6 @@ static struct ipu_psys_kcmd *ipu_psys_copy_cmd(struct ipu_psys_command *cmd,
 	if (ret)
 		goto error;
 
-#ifdef IPU_CACHE_DEBUG
-	dev_dbg(&psys->adev->dev, "enable_cache_flush = %d\n",
-		enable_cache_flush);
-#endif
 	for (i = 0; i < kcmd->nbuffers; i++) {
 		struct ipu_fw_psys_terminal *terminal;
 
@@ -387,10 +372,6 @@ static struct ipu_psys_kcmd *ipu_psys_copy_cmd(struct ipu_psys_command *cmd,
 			continue;
 
 		prevfd = kcmd->buffers[i].base.fd;
-#ifdef IPU_CACHE_DEBUG
-		if (!enable_cache_flush)
-			continue;
-#endif
 		dma_sync_sg_for_device(&psys->adev->dev,
 				       kcmd->kbufs[i]->sgt->sgl,
 				       kcmd->kbufs[i]->sgt->orig_nents,
@@ -469,17 +450,6 @@ void ipu_psys_kcmd_complete(struct ipu_psys_ppg *kppg,
 	struct ipu_psys_fh *fh = kcmd->fh;
 	struct ipu_psys *psys = fh->psys;
 
-#ifdef IPU_TRACE_EVENT
-	trace_ipu_pg_kcmd(__func__, kcmd->user_token, kcmd->issue_id,
-			  kcmd->priority,
-			  ipu_fw_psys_pg_get_id(kcmd),
-			  ipu_fw_psys_pg_load_cycles(kcmd),
-			  ipu_fw_psys_pg_init_cycles(kcmd),
-			  ipu_fw_psys_pg_server_init_cycles(kcmd),
-			  ipu_fw_psys_pg_next_frame_init_cycles(kcmd),
-			  ipu_fw_psys_pg_complete_cycles(kcmd),
-			  ipu_fw_psys_pg_processing_cycles(kcmd));
-#endif
 	kcmd->ev.type = IPU_PSYS_EVENT_TYPE_CMD_COMPLETE;
 	kcmd->ev.user_token = kcmd->user_token;
 	kcmd->ev.issue_id = kcmd->issue_id;
@@ -677,18 +647,6 @@ static int ipu_psys_kcmd_send_to_ppg(struct ipu_psys_kcmd *kcmd)
 		mutex_lock(&kppg->mutex);
 		list_add_tail(&kcmd->list, &kppg->kcmds_new_list);
 		mutex_unlock(&kppg->mutex);
-#ifdef IPU_TRACE_EVENT
-		trace_ipu_pg_kcmd(__func__, kcmd->user_token,
-				  kcmd->issue_id,
-				  kcmd->priority,
-				  ipu_fw_psys_pg_get_id(kcmd),
-				  ipu_fw_psys_pg_load_cycles(kcmd),
-				  ipu_fw_psys_pg_init_cycles(kcmd),
-				  ipu_fw_psys_pg_server_init_cycles(kcmd),
-				  ipu_fw_psys_pg_next_frame_init_cycles(kcmd),
-				  ipu_fw_psys_pg_complete_cycles(kcmd),
-				  ipu_fw_psys_pg_processing_cycles(kcmd));
-#endif
 	}
 
 	if (resche) {
@@ -1072,5 +1030,3 @@ long ipu_ioctl_dqevent(struct ipu_psys_event *event,
 
 	return 0;
 }
-
-MODULE_IMPORT_NS(DMA_BUF);
diff --git a/drivers/media/pci/intel/ipu6/ipu6.c b/drivers/media/pci/intel/ipu6/ipu6.c
index d20f78ab4fa2..c4ce74b25865 100644
--- a/drivers/media/pci/intel/ipu6/ipu6.c
+++ b/drivers/media/pci/intel/ipu6/ipu6.c
@@ -58,26 +58,6 @@ static unsigned int ipu6se_csi_offsets[] = {
 	IPU_CSI_PORT_D_ADDR_OFFSET,
 };
 
-#ifdef CONFIG_VIDEO_INTEL_IPU_TPG
-static unsigned int ipu6se_tpg_offsets[] = {
-	IPU_CSI_PORT_A_PIXGEN_ADDR_OFFSET,
-	IPU_CSI_PORT_B_PIXGEN_ADDR_OFFSET,
-	IPU_CSI_PORT_C_PIXGEN_ADDR_OFFSET,
-	IPU_CSI_PORT_D_PIXGEN_ADDR_OFFSET,
-};
-
-static unsigned int ipu6_tpg_offsets[] = {
-	IPU_CSI_PORT_A_PIXGEN_ADDR_OFFSET,
-	IPU_CSI_PORT_B_PIXGEN_ADDR_OFFSET,
-	IPU_CSI_PORT_C_PIXGEN_ADDR_OFFSET,
-	IPU_CSI_PORT_D_PIXGEN_ADDR_OFFSET,
-	IPU_CSI_PORT_E_PIXGEN_ADDR_OFFSET,
-	IPU_CSI_PORT_F_PIXGEN_ADDR_OFFSET,
-	IPU_CSI_PORT_G_PIXGEN_ADDR_OFFSET,
-	IPU_CSI_PORT_H_PIXGEN_ADDR_OFFSET
-};
-#endif
-
 static unsigned int ipu6_csi_offsets[] = {
 	IPU_CSI_PORT_A_ADDR_OFFSET,
 	IPU_CSI_PORT_B_ADDR_OFFSET,
@@ -338,25 +318,16 @@ int ipu_buttress_psys_freq_get(void *data, u64 *val)
 
 void ipu_internal_pdata_init(void)
 {
-	if (ipu_ver == IPU_VER_6 || ipu_ver == IPU_VER_6EP) {
+	if (ipu_ver == IPU_VER_6 || ipu_ver == IPU_VER_6EP ||
+	    ipu_ver == IPU_VER_6EP_MTL) {
 		isys_ipdata.csi2.nports = ARRAY_SIZE(ipu6_csi_offsets);
 		isys_ipdata.csi2.offsets = ipu6_csi_offsets;
-#ifdef CONFIG_VIDEO_INTEL_IPU_TPG
-		isys_ipdata.tpg.ntpgs = ARRAY_SIZE(ipu6_tpg_offsets);
-		isys_ipdata.tpg.offsets = ipu6_tpg_offsets;
-		isys_ipdata.tpg.sels = NULL;
-#endif
 		isys_ipdata.num_parallel_streams = IPU6_ISYS_NUM_STREAMS;
 		psys_ipdata.hw_variant.spc_offset = IPU6_PSYS_SPC_OFFSET;
 
 	} else if (ipu_ver == IPU_VER_6SE) {
 		isys_ipdata.csi2.nports = ARRAY_SIZE(ipu6se_csi_offsets);
 		isys_ipdata.csi2.offsets = ipu6se_csi_offsets;
-#ifdef CONFIG_VIDEO_INTEL_IPU_TPG
-		isys_ipdata.tpg.ntpgs = ARRAY_SIZE(ipu6se_tpg_offsets);
-		isys_ipdata.tpg.offsets = ipu6se_tpg_offsets;
-		isys_ipdata.tpg.sels = NULL;
-#endif
 		isys_ipdata.num_parallel_streams = IPU6SE_ISYS_NUM_STREAMS;
 		psys_ipdata.hw_variant.spc_offset = IPU6SE_PSYS_SPC_OFFSET;
 	}
diff --git a/drivers/media/platform/intel/Kconfig b/drivers/media/platform/intel/Kconfig
index 86ed40d88357..77c2bc044894 100644
--- a/drivers/media/platform/intel/Kconfig
+++ b/drivers/media/platform/intel/Kconfig
@@ -1,17 +1,24 @@
 config INTEL_IPU6_TGLRVP_PDATA
-	bool "Enable built in platform data for TGL RVP"
+	tristate "Enable built in platform data for TGL RVP"
 	depends on VIDEO_INTEL_IPU6
 	help
 	Pre-ACPI system platform data is compiled inside kernel
 
 config INTEL_IPU6_ADLRVP_PDATA
-	bool "Enable built in platform data for ADL RVP"
-	depends on VIDEO_INTEL_IPU6
+	tristate "Enable built in platform data for ADL RVP"
+	depends on MEDIA_CAMERA_SUPPORT
 	help
-	Pre-ACPI system platform data is compiled inside kernel
+	 Pre-ACPI system platform data is compiled inside kernel
+
+	 This platform data is useful for software development before
+	 the SOC system not ready.
+
 config INTEL_IPU6_ACPI
-	bool "Enable IPU ACPI driver"
+	tristate "Enable IPU ACPI driver"
 	depends on VIDEO_INTEL_IPU6
+	depends on I2C
+	depends on ACPI
+	depends on INTEL_SKL_INT3472
 	help
 	Driver to read ACPI data from BIOS
 
diff --git a/drivers/media/platform/intel/Makefile b/drivers/media/platform/intel/Makefile
index c4574ca69679..2417a4b67a15 100644
--- a/drivers/media/platform/intel/Makefile
+++ b/drivers/media/platform/intel/Makefile
@@ -9,5 +9,8 @@ ccflags-y += -I$(srcpath)/$(src)/../../../../include/
 ccflags-y += -I$(srcpath)/$(src)/../../pci/intel/
 
 obj-$(CONFIG_INTEL_IPU6_TGLRVP_PDATA) += ipu6-tglrvp-pdata.o
+obj-$(CONFIG_INTEL_IPU6_JSLRVP_PDATA) += ipu6-jslrvp-pdata.o
 obj-$(CONFIG_INTEL_IPU6_ADLRVP_PDATA) += ipu6-adlrvp-pdata.o
-obj-$(CONFIG_INTEL_IPU6_ACPI)         += ipu6-acpi.o
+obj-$(CONFIG_INTEL_IPU6_ACPI)         += ipu6-acpi.o \
+					ipu6-acpi-pdata.o \
+					ipu6-acpi-common.o
diff --git a/drivers/media/platform/intel/ipu6-acpi-common.c b/drivers/media/platform/intel/ipu6-acpi-common.c
new file mode 100644
index 000000000000..05e61f9b3cfa
--- /dev/null
+++ b/drivers/media/platform/intel/ipu6-acpi-common.c
@@ -0,0 +1,355 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2016--2022 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ */
+#include <linux/platform_device.h>
+#include <media/ipu-acpi-pdata.h>
+#include <media/ipu-acpi.h>
+
+static int get_integer_dsdt_data(struct device *dev, const u8 *dsdt,
+				 int func, u64 *out)
+{
+	struct acpi_handle *dev_handle = ACPI_HANDLE(dev);
+	union acpi_object *obj;
+
+	obj = acpi_evaluate_dsm(dev_handle, (void *)dsdt, 0, func, NULL);
+	if (!obj) {
+		dev_err(dev, "No dsdt\n");
+		return -ENODEV;
+	}
+	dev_dbg(dev, "ACPI type %d", obj->type);
+
+	if (obj->type != ACPI_TYPE_INTEGER) {
+		ACPI_FREE(obj);
+		return -ENODEV;
+	}
+	*out = obj->integer.value;
+	ACPI_FREE(obj);
+	return 0;
+}
+
+static int read_acpi_block(struct device *dev, char *id, void *data, u32 size)
+{
+	union acpi_object *obj;
+	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+	struct acpi_handle *dev_handle = ACPI_HANDLE(dev);
+	int status;
+	u32 buffer_length;
+
+	status = acpi_evaluate_object(dev_handle, id, NULL, &buffer);
+	if (!ACPI_SUCCESS(status))
+		return -ENODEV;
+
+	obj = (union acpi_object *)buffer.pointer;
+	if (!obj || obj->type != ACPI_TYPE_BUFFER) {
+		dev_err(dev, "Could't read acpi buffer\n");
+		status = -ENODEV;
+		goto err;
+	}
+
+	if (obj->buffer.length > size) {
+		dev_err(dev, "Given buffer is too small\n");
+		status = -ENODEV;
+		goto err;
+	}
+
+	memcpy(data, obj->buffer.pointer, min(size, obj->buffer.length));
+	buffer_length = obj->buffer.length;
+	kfree(buffer.pointer);
+
+	return buffer_length;
+err:
+	kfree(buffer.pointer);
+	return status;
+}
+
+int ipu_acpi_get_gpio_data(struct device *dev, struct ipu_gpio_info *gpio, int size,
+				u64 *gpio_num)
+{
+	const u8 dsdt_cam_gpio[] = {
+		0x40, 0x46, 0x23, 0x79, 0x10, 0x9e, 0xea, 0x4f,
+		0xa5, 0xc1, 0xB5, 0xaa, 0x8b, 0x19, 0x75, 0x6f };
+
+	int i = 0, j = 0, retries = 0, loop = 0;
+	u64 num_gpio;
+
+	int rval = get_integer_dsdt_data(dev, dsdt_cam_gpio, 1, &num_gpio);
+
+	if (rval < 0) {
+		dev_err(dev, "Failed to get number of GPIO pins\n");
+		return rval;
+	}
+
+	dev_dbg(dev, "Num of gpio found = %lld", num_gpio);
+
+	if (num_gpio == 0) {
+		*gpio_num = num_gpio;
+		return rval;
+	}
+
+	if (num_gpio > size) {
+		dev_err(dev, "Incorrect number of GPIO pins\n");
+		return rval;
+	}
+
+	/* repeat until all gpio pin is saved */
+	while (i < num_gpio && loop <= LOOP_SIZE) {
+		u64 data;
+		struct gpio_desc *desc = NULL;
+
+		rval = get_integer_dsdt_data(dev, dsdt_cam_gpio, i + 2, &data);
+
+		if (rval < 0) {
+			dev_err(dev, "No gpio data\n");
+			return -ENODEV;
+		}
+
+		gpio[i].func = (data & 0xff);
+		gpio[i].valid = FALSE;
+
+		desc = gpiod_get_index(dev, NULL, i + retries, GPIOD_ASIS);
+
+		if (!IS_ERR(desc)) {
+			unsigned short pin = desc_to_gpio(desc);
+			bool save = TRUE;
+
+			/* always save first GPIO pin */
+			if (i == 0)
+				save = TRUE;
+
+			/* check subsequent GPIO pin for replicate */
+			else {
+				for (j = 0; j <= i; j++) {
+					/* retry if same as previous pin */
+					if (gpio[j].pin == pin) {
+						retries++;
+						save = FALSE;
+						gpiod_put(desc);
+						break;
+					}
+				}
+			}
+
+			/* save into array */
+			if (save == TRUE) {
+				gpio[i].pin = pin;
+				gpio[i].valid = TRUE;
+				gpiod_put(desc);
+				i++;
+				retries = 0;
+			}
+		}
+		loop++;
+	}
+	*gpio_num = num_gpio;
+
+	return rval;
+}
+
+int ipu_acpi_get_i2c_info(struct device *dev, struct ipu_i2c_info *i2c, int size, u64 *num)
+{
+	const u8 dsdt_cam_i2c[] = {
+		0x49, 0x75, 0x25, 0x26, 0x71, 0x92, 0xA4, 0x4C,
+		0xBB, 0x43, 0xC4, 0x89, 0x9D, 0x5A, 0x48, 0x81};
+
+	u64 num_i2c;
+	int i;
+	int rval = get_integer_dsdt_data(dev, dsdt_cam_i2c, 1, &num_i2c);
+
+	if (rval < 0) {
+		dev_err(dev, "Failed to get number of I2C\n");
+		return -ENODEV;
+	}
+
+	for (i = 0; i < num_i2c && i < size; i++) {
+		u64 data;
+
+		rval = get_integer_dsdt_data(dev, dsdt_cam_i2c, i + 2,
+					     &data);
+
+		if (rval < 0) {
+			dev_err(dev, "Failed to get I2C data\n");
+			return -ENODEV;
+		}
+
+		i2c[i].bus = ((data >> 24) & 0xff);
+		i2c[i].addr = (data >> 8) & 0xff;
+
+		dev_dbg(dev, "ACPI camera option: i2c bus %d addr %x",
+			i2c[i].bus, i2c[i].addr);
+	}
+
+	*num = num_i2c;
+
+	return 0;
+}
+
+static int match_depend(struct device *dev, const void *data)
+{
+	return (dev && dev->fwnode == data) ? 1 : 0;
+}
+
+int ipu_acpi_get_control_logic_data(struct device *dev,
+					struct control_logic_data **ctl_data)
+{
+	/* CLDB data */
+	struct control_logic_data_packed ctl_logic_data;
+	int ret = read_acpi_block(dev, "CLDB", &ctl_logic_data,
+				sizeof(ctl_logic_data));
+
+	if (ret < 0) {
+		dev_err(dev, "no such CLDB block");
+		return ret;
+	}
+
+	(*ctl_data)->type = ctl_logic_data.controllogictype;
+	(*ctl_data)->id = ctl_logic_data.controllogicid;
+	(*ctl_data)->sku = ctl_logic_data.sensorcardsku;
+
+	dev_dbg(dev, "CLDB data version %d clid %d cltype %d sku %d",
+		ctl_logic_data.version,
+		ctl_logic_data.controllogicid,
+		ctl_logic_data.controllogictype,
+		ctl_logic_data.sensorcardsku);
+
+	/* GPIO data */
+	ret = ipu_acpi_get_gpio_data(dev, (*ctl_data)->gpio, ARRAY_SIZE((*ctl_data)->gpio),
+				&((*ctl_data)->gpio_num));
+
+	if (ret < 0) {
+		dev_err(dev, "Failed to get GPIO data");
+		return ret;
+	}
+	return 0;
+}
+
+int ipu_acpi_get_dep_data(struct device *dev,
+			     struct control_logic_data *ctl_data)
+{
+	struct acpi_handle *dev_handle = ACPI_HANDLE(dev);
+	struct acpi_handle_list dep_devices;
+	acpi_status status;
+	int i;
+	int rval;
+
+	ctl_data->completed = false;
+
+	if (!acpi_has_method(dev_handle, "_DEP")) {
+		dev_err(dev, "ACPI does not have _DEP method");
+		return 0;
+	}
+
+	status = acpi_evaluate_reference(dev_handle, "_DEP", NULL,
+					 &dep_devices);
+
+	if (ACPI_FAILURE(status)) {
+		dev_err(dev, "Failed to evaluate _DEP.\n");
+		return -ENODEV;
+	}
+
+	for (i = 0; i < dep_devices.count; i++) {
+		struct acpi_device *device;
+		struct acpi_device_info *info;
+		struct device *p_dev;
+		int match;
+
+		status = acpi_get_object_info(dep_devices.handles[i], &info);
+		if (ACPI_FAILURE(status)) {
+			dev_err(dev, "Error reading _DEP device info\n");
+			continue;
+		}
+
+		match = info->valid & ACPI_VALID_HID &&
+			!strcmp(info->hardware_id.string, "INT3472");
+
+		kfree(info);
+
+		if (!match)
+			continue;
+
+		/* Process device IN3472 created by acpi */
+		if (acpi_bus_get_device(dep_devices.handles[i], &device)) {
+			dev_err(dev, "INT3472 does not have dep device");
+			return -ENODEV;
+		}
+
+		dev_dbg(dev, "Depend ACPI device found: %s\n",
+			dev_name(&device->dev));
+
+		p_dev = bus_find_device(&platform_bus_type, NULL,
+					&device->fwnode, match_depend);
+
+		if (p_dev) {
+			dev_err(dev, "Dependent platform device found %s\n",
+				dev_name(p_dev));
+
+			/* obtain Control Logic Data from BIOS */
+			rval = ipu_acpi_get_control_logic_data(p_dev, &ctl_data);
+
+			if (rval) {
+				dev_err(dev, "Error getting Control Logic Data");
+				return rval;
+			}
+
+			ctl_data->completed = true;
+		} else
+			dev_err(dev, "Dependent platform device not found\n");
+	}
+
+	if (!ctl_data->completed) {
+		ctl_data->type = CL_EMPTY;
+		dev_err(dev, "No control logic data available");
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_acpi_get_dep_data);
+
+int ipu_acpi_get_cam_data(struct device *dev,
+			     struct sensor_bios_data *sensor)
+{
+	/* SSDB */
+	struct sensor_bios_data_packed sensor_data;
+
+	int ret = read_acpi_block(dev, "SSDB", &sensor_data,
+				  sizeof(sensor_data));
+
+	if (ret < 0) {
+		dev_err(dev, "Fail to read from SSDB");
+		return ret;
+	}
+
+	/* Xshutdown is not part of the ssdb data */
+	sensor->link = sensor_data.link;
+	sensor->lanes = sensor_data.lanes;
+	sensor->pprval = sensor_data.pprval;
+	sensor->pprunit = sensor_data.pprunit;
+
+	dev_dbg(dev, "sensor ACPI data: name %s link %d, lanes %d pprval %d pprunit %x",
+		dev_name(dev), sensor->link, sensor->lanes, sensor->pprval, sensor->pprunit);
+
+	/* I2C */
+	ret = ipu_acpi_get_i2c_info(dev, sensor->i2c, ARRAY_SIZE(sensor->i2c), &sensor->i2c_num);
+
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_acpi_get_cam_data);
+
+MODULE_AUTHOR("Samu Onkalo <samu.onkalo@intel.com>");
+MODULE_AUTHOR("Khai Wen Ng <khai.wen.ng@intel.com>");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("IPU6 ACPI support");
+
diff --git a/drivers/media/platform/intel/ipu6-acpi-pdata.c b/drivers/media/platform/intel/ipu6-acpi-pdata.c
new file mode 100644
index 000000000000..bc144222a2e5
--- /dev/null
+++ b/drivers/media/platform/intel/ipu6-acpi-pdata.c
@@ -0,0 +1,843 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2016--2022 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <media/ipu-acpi.h>
+#include <media/ipu-acpi-pdata.h>
+
+#define MIN_SENSOR_I2C 1
+#define MIN_SERDES_I2C 2
+#define SUFFIX_BASE 96
+#define MSG_LEN 128
+
+static struct ipu_isys_clk_mapping clk_mapping[] = {
+	{ CLKDEV_INIT(NULL, NULL, NULL), NULL }
+};
+
+struct ipu_isys_subdev_pdata acpi_subdev_pdata = {
+	.subdevs = (struct ipu_isys_subdev_info *[]) {
+		NULL,
+	},
+	.clk_map = clk_mapping,
+};
+
+struct serdes_local serdes_info;
+
+struct serdes_subdev_info serdes_sdinfo[SERDES_MAX_PORT];
+
+struct ipu_isys_subdev_pdata *get_acpi_subdev_pdata(void)
+{
+	struct ipu_isys_subdev_pdata *ptr;
+	ptr = &acpi_subdev_pdata;
+	return ptr;
+}
+EXPORT_SYMBOL(get_acpi_subdev_pdata);
+
+void print_serdes_sdinfo(struct serdes_subdev_info *sdinfo)
+{
+	int j;
+	struct serdes_module_pdata *sd_mpdata = sdinfo->board_info.platform_data;
+
+	if (!sd_mpdata) {
+		pr_err("Empty serdes module pdata");
+		return;
+	}
+
+	pr_debug("\t\trx_port \t\t= %d", sdinfo->rx_port);
+	pr_debug("\t\tphy_i2c_addr \t\t= 0x%x", sdinfo->phy_i2c_addr);
+	pr_debug("\t\tser_alias \t\t= 0x%x", sdinfo->ser_alias);
+	pr_debug("\t\tsuffix \t\t\t= %c", sdinfo->suffix);
+	pr_debug("\t\tboard_info.type \t= %s", sdinfo->board_info.type);
+	pr_debug("\t\tboard_info.addr \t= 0x%x", sdinfo->board_info.addr);
+
+	pr_debug("serdes board_info.platform_data");
+	pr_debug("\t\tlanes \t\t\t= %d", sd_mpdata->lanes);
+	pr_debug("\t\tmodule_name \t\t= %s", sd_mpdata->module_name);
+	pr_debug("\t\tfsin \t\t\t= %d", sd_mpdata->fsin);
+
+	if (serdes_info.gpio_powerup_seq > 0)
+		for (j = 0; j < serdes_info.gpio_powerup_seq; j++)
+			pr_debug("\t\t gpio_powerup_seq[%d] \t= %d", j,
+				(int)sd_mpdata->gpio_powerup_seq[j]);
+}
+
+void print_serdes_subdev(struct ipu_isys_subdev_info *sd)
+{
+	struct serdes_platform_data *sd_pdata = sd->i2c.board_info.platform_data;
+	int i;
+	struct serdes_subdev_info *sd_sdinfo;
+	struct serdes_module_pdata *sd_mpdata;
+
+	if (!sd_pdata) {
+		pr_err("Empty serdes subdev pdata");
+		return;
+	}
+
+	pr_debug("IPU6 ACPI %s", __func__);
+	pr_debug("sd_csi2");
+	pr_debug("\t\tnlanes \t\t\t= %d", sd->csi2->nlanes);
+	pr_debug("\t\tport \t\t\t= %d", sd->csi2->port);
+
+	pr_debug("sd->i2c");
+	pr_debug("\t\ti2c_adapter_bdf \t= %s", sd->i2c.i2c_adapter_bdf);
+	pr_debug("\t\tboard_info.type \t= %s", sd->i2c.board_info.type);
+	pr_debug("\t\tboard_info.addr \t= 0x%x", sd->i2c.board_info.addr);
+
+	pr_debug("sd->i2c.board_info.platform_data");
+	pr_debug("\t\treset_gpio \t\t= %d", sd_pdata->reset_gpio);
+	pr_debug("\t\tFPD_gpio \t\t= %d", sd_pdata->FPD_gpio);
+	pr_debug("\t\tsuffix \t\t\t= %c", sd_pdata->suffix);
+
+	for (i = 0; i < serdes_info.rx_port; i++) {
+		sd_sdinfo = &sd_pdata->subdev_info[i];
+		sd_mpdata = sd_sdinfo->board_info.platform_data;
+
+		if (!sd_mpdata)
+			continue;
+
+		pr_debug("serdes subdev_info[%d]", i);
+		print_serdes_sdinfo(sd_sdinfo);
+	}
+
+}
+
+void print_subdev(struct ipu_isys_subdev_info *sd)
+{
+	struct sensor_platform_data *spdata = sd->i2c.board_info.platform_data;
+	int i;
+
+	if (!spdata) {
+		pr_err("Empty sensor subdev");
+		return;
+	}
+
+	pr_debug("IPU6 ACPI %s", __func__);
+	pr_debug("sd->csi2");
+	pr_debug("\t\tnlanes \t\t\t= %d", sd->csi2->nlanes);
+	pr_debug("\t\tport \t\t\t= %d", sd->csi2->port);
+
+	pr_debug("sd->i2c");
+	pr_debug("\t\ti2c_adapter_bdf \t= %s", sd->i2c.i2c_adapter_bdf);
+	pr_debug("\t\tboard_info.type \t= %s", sd->i2c.board_info.type);
+	pr_debug("\t\tboard_info.addr \t= 0x%x", sd->i2c.board_info.addr);
+
+	pr_debug("sd->i2c.platform_data");
+	pr_debug("\t\tport \t\t\t= %d", spdata->port);
+	pr_debug("\t\tlanes \t\t\t= %d", spdata->lanes);
+	pr_debug("\t\ti2c_slave_address \t= 0x%x", spdata->i2c_slave_address);
+	pr_debug("\t\tirq_pin \t\t= %d", spdata->irq_pin);
+	pr_debug("\t\tirq_pin_name \t\t= %s", spdata->irq_pin_name);
+	pr_debug("\t\tsuffix \t\t\t= %c", spdata->suffix);
+	pr_debug("\t\treset_pin \t\t= %d", spdata->reset_pin);
+	pr_debug("\t\tdetect_pin \t\t= %d", spdata->detect_pin);
+
+	for (i = 0; i < IPU_SPLATA_GPIO_NUM; i++)
+		pr_debug("\t\tgpios[%d] \t\t= %d", i, spdata->gpios[i]);
+}
+
+void add_local_subdevs(struct ipu_isys_subdev_info *new_subdev_info)
+{
+	struct ipu_isys_subdev_pdata *ptr_acpi_subdev_pdata = &acpi_subdev_pdata;
+	int i = 0;
+
+	while (i <= MAX_ACPI_SENSOR_NUM) {
+		if (!ptr_acpi_subdev_pdata->subdevs[i]) {
+			ptr_acpi_subdev_pdata->subdevs[i] = new_subdev_info;
+			ptr_acpi_subdev_pdata->subdevs[i+1] = NULL;
+			break;
+		}
+		i++;
+	}
+}
+
+void update_short(struct device *dev,
+		char msg[MSG_LEN],
+		unsigned short *old_short,
+		unsigned int new_short)
+{
+	if (*old_short != new_short) {
+		dev_info(dev, "%s 0x%x -> 0x%x", msg, *old_short, new_short);
+		*old_short = new_short;
+	}
+}
+
+void update_hex(struct device *dev,
+		char msg[MSG_LEN],
+		unsigned int *old_hex,
+		unsigned int new_hex)
+{
+	if (*old_hex != new_hex) {
+		dev_info(dev, "%s 0x%x -> 0x%x", msg, *old_hex, new_hex);
+		*old_hex = new_hex;
+	}
+}
+
+void update_int(struct device *dev,
+		char msg[MSG_LEN],
+		unsigned int *old_int,
+		unsigned int new_int)
+{
+	if (*old_int != new_int) {
+		dev_info(dev, "%s %d -> %d", msg, *old_int, new_int);
+		*old_int = new_int;
+	}
+}
+
+void update_inta(struct device *dev,
+		char msg[MSG_LEN],
+		int old_int[MSG_LEN],
+		int new_int[MSG_LEN],
+		size_t size)
+{
+	int i;
+
+	for (i = 0; i < size; i++) {
+		if (old_int[i] != new_int[i]) {
+			dev_info(dev, "%s %d -> %d", msg, old_int[i], new_int[i]);
+			old_int[i] = new_int[i];
+		}
+	}
+}
+
+void update_str(struct device *dev,
+		char msg[MSG_LEN],
+		char old_str[MSG_LEN],
+		char new_str[MSG_LEN])
+{
+	if (strcmp(old_str, new_str) != 0) {
+		dev_info(dev, "%s %s -> %s", msg, old_str, new_str);
+		strlcpy(old_str, new_str, strlen(new_str)+1);
+	}
+}
+
+void update_subdev(struct device *dev,
+			struct ipu_isys_subdev_info *new_sd,
+			struct ipu_isys_subdev_info **old_sd)
+{
+	struct sensor_platform_data *old_pdata =
+					(*old_sd)->i2c.board_info.platform_data;
+
+	struct sensor_platform_data *new_pdata =
+					new_sd->i2c.board_info.platform_data;
+
+	/* csi2 */
+	update_int(dev, "CSI2 port", &(*old_sd)->csi2->port, new_sd->csi2->port);
+	update_int(dev, "CSI2 nlanes", &(*old_sd)->csi2->nlanes, new_sd->csi2->nlanes);
+
+	/* i2c */
+	update_short(dev, "I2C board_info addr", &(*old_sd)->i2c.board_info.addr,
+		new_sd->i2c.board_info.addr);
+	update_str(dev, "I2C i2c_adapter_bdf", (*old_sd)->i2c.i2c_adapter_bdf,
+		new_sd->i2c.i2c_adapter_bdf);
+
+	/* platform data */
+	update_int(dev, "pdata port", &(old_pdata)->port, new_pdata->port);
+	update_int(dev, "pdata lanes", &(old_pdata)->lanes, new_pdata->lanes);
+	update_hex(dev, "pdata I2C slave addr", &(old_pdata)->i2c_slave_address,
+		new_pdata->i2c_slave_address);
+	update_int(dev, "pdata irq_pin", &(old_pdata)->irq_pin, new_pdata->irq_pin);
+	update_str(dev, "pdata irq_pin_name", old_pdata->irq_pin_name, new_pdata->irq_pin_name);
+	update_int(dev, "pdata reset_pin", &(old_pdata)->reset_pin, new_pdata->reset_pin);
+	update_int(dev, "pdata detect_pin", &(old_pdata)->detect_pin, new_pdata->detect_pin);
+	update_inta(dev, "pdata gpios", old_pdata->gpios, new_pdata->gpios, IPU_SPLATA_GPIO_NUM);
+}
+
+void update_serdes_subdev(struct device *dev,
+			struct ipu_isys_subdev_info *new_sd,
+			struct ipu_isys_subdev_info **old_sd)
+{
+	struct serdes_platform_data *old_pdata =
+					(*old_sd)->i2c.board_info.platform_data;
+
+	struct serdes_platform_data *new_pdata =
+					new_sd->i2c.board_info.platform_data;
+
+	int i;
+	struct serdes_subdev_info *old_sdinfo, *new_sdinfo;
+	struct serdes_module_pdata *old_mpdata, *new_mpdata;
+
+	/* csi2 */
+	update_int(dev, "CSI2 port", &(*old_sd)->csi2->port, new_sd->csi2->port);
+	update_int(dev, "CSI2 nlanes", &(*old_sd)->csi2->nlanes, new_sd->csi2->nlanes);
+
+	/* i2c */
+	update_short(dev, "I2C board_info addr", &(*old_sd)->i2c.board_info.addr,
+		new_sd->i2c.board_info.addr);
+	update_str(dev, "I2C i2c_adapter_bdf", (*old_sd)->i2c.i2c_adapter_bdf,
+		new_sd->i2c.i2c_adapter_bdf);
+
+	update_int(dev, "I2C Pdata reset_gpio", &old_pdata->reset_gpio,
+		new_pdata->reset_gpio);
+	update_int(dev, "I2C Pdata FPD_gpio", &old_pdata->FPD_gpio, new_pdata->FPD_gpio);
+
+	/* platform data */
+	for (i = 0; i < SERDES_MAX_PORT; i++) {
+		old_sdinfo = &old_pdata->subdev_info[i];
+		old_mpdata = old_sdinfo->board_info.platform_data;
+
+		new_sdinfo = &new_pdata->subdev_info[i];
+		new_mpdata = new_sdinfo->board_info.platform_data;
+
+		if (!strcmp(old_sdinfo->board_info.type, new_sdinfo->board_info.type) &&
+			old_sdinfo->suffix == new_sdinfo->suffix) {
+			update_short(dev, "SdInfo port", &old_sdinfo->rx_port,
+				new_sdinfo->rx_port);
+			update_short(dev, "SdInfo phy_i2c_addr", &old_sdinfo->phy_i2c_addr,
+				new_sdinfo->phy_i2c_addr);
+			update_short(dev, "SdInfo ser_alias", &old_sdinfo->ser_alias,
+				new_sdinfo->ser_alias);
+			update_short(dev, "SdInfo board_info.addr", &old_sdinfo->board_info.addr,
+				new_sdinfo->board_info.addr);
+
+			if (!strcmp(old_mpdata->module_name, new_mpdata->module_name)) {
+				update_int(dev, "mPdata lanes", &old_mpdata->lanes,
+					new_mpdata->lanes);
+				update_int(dev, "mPdata fsin", &old_mpdata->fsin,
+					new_mpdata->fsin);
+				update_inta(dev, "mPdata gpio_powerup_seq",
+						(int *)old_mpdata->gpio_powerup_seq,
+						(int *)new_mpdata->gpio_powerup_seq,
+						SERDES_MAX_GPIO_POWERUP_SEQ);
+			}
+		}
+	}
+}
+
+int compare_subdev(struct device *dev,
+			struct ipu_isys_subdev_info *new_subdev,
+			struct ipu_isys_subdev_info *old_subdev,
+			enum connection_type connect)
+{
+	/* check for ACPI HID in existing pdata */
+	if (old_subdev->acpi_hid) {
+		/* compare with HID for User Custom */
+		if (!strcmp(old_subdev->acpi_hid, dev_name(dev))) {
+			dev_info(dev, "Found matching sensor : %s", dev_name(dev));
+			return 0;
+		}
+	}
+	/* compare sensor type */
+	if (!strcmp(old_subdev->i2c.board_info.type,
+			new_subdev->i2c.board_info.type)) {
+
+		if (connect == TYPE_DIRECT) {
+			struct sensor_platform_data *old_pdata, *new_pdata;
+
+			old_pdata = (struct sensor_platform_data *)
+					old_subdev->i2c.board_info.platform_data;
+
+			new_pdata = (struct sensor_platform_data *)
+					new_subdev->i2c.board_info.platform_data;
+
+			if (old_pdata->suffix == new_pdata->suffix) {
+				dev_info(dev, "Found matching sensor : %s %c",
+					old_subdev->i2c.board_info.type,
+					old_pdata->suffix);
+				return 0;
+			}
+		} else if (connect == TYPE_SERDES) {
+			struct serdes_platform_data *old_pdata, *new_pdata;
+
+			old_pdata = (struct serdes_platform_data *)
+					old_subdev->i2c.board_info.platform_data;
+
+			new_pdata = (struct serdes_platform_data *)
+					new_subdev->i2c.board_info.platform_data;
+
+			if (old_pdata->suffix == new_pdata->suffix) {
+				dev_info(dev, "Found matching sensor : %s %c",
+					old_subdev->i2c.board_info.type,
+					old_pdata->suffix);
+				return 0;
+			}
+		}
+	}
+	return -1;
+}
+
+void update_pdata(struct device *dev,
+			struct ipu_isys_subdev_info *new_subdev,
+			enum connection_type connect)
+{
+	struct ipu_isys_subdev_info *acpi_subdev;
+	struct ipu_isys_subdev_pdata *ptr_built_in_pdata;
+	bool found = false;
+
+	acpi_subdev = new_subdev;
+
+	/* update local ipu_isys_subdev_pdata */
+	add_local_subdevs(acpi_subdev);
+
+	ptr_built_in_pdata = get_built_in_pdata();
+
+	/* if there is existing pdata, update the existing one */
+	if (ptr_built_in_pdata) {
+		struct ipu_isys_subdev_info **subdevs, *sd_info;
+
+		for (subdevs = ptr_built_in_pdata->subdevs; *subdevs; subdevs++) {
+			sd_info = *subdevs;
+
+			if (!compare_subdev(dev, acpi_subdev, sd_info, connect)) {
+				if (connect == TYPE_DIRECT) {
+					dev_dbg(dev, "Old sensor subdev\n");
+					print_subdev(sd_info);
+					dev_dbg(dev, "New sensor subdev\n");
+					print_subdev(acpi_subdev);
+				} else if (connect == TYPE_SERDES) {
+					dev_dbg(dev, "Old serdes subdev\n");
+					print_serdes_subdev(sd_info);
+					dev_dbg(dev, "New serdes subdev\n");
+					print_serdes_subdev(acpi_subdev);
+				}
+
+				if (connect == TYPE_DIRECT)
+					update_subdev(dev, acpi_subdev, &sd_info);
+				else if (connect == TYPE_SERDES)
+					update_serdes_subdev(dev, acpi_subdev, &sd_info);
+
+				found = true;
+				break;
+			}
+		}
+
+		if (!found) {
+			if (connect == TYPE_DIRECT) {
+				struct sensor_platform_data *acpi_pdata;
+
+				acpi_pdata = (struct sensor_platform_data *)
+					acpi_subdev->i2c.board_info.platform_data;
+
+				dev_err(dev, "Pdata does not contain %s %c\n",
+					acpi_subdev->i2c.board_info.type,
+					acpi_pdata->suffix);
+			} else if (connect == TYPE_DIRECT) {
+				struct serdes_platform_data *acpi_pdata;
+
+				acpi_pdata = (struct serdes_platform_data *)
+					acpi_subdev->i2c.board_info.platform_data;
+
+				dev_err(dev, "Pdata does not contain %s %c\n",
+					acpi_subdev->i2c.board_info.type,
+					acpi_pdata->suffix);
+			}
+		}
+	}
+
+	if (!serdes_info.sensor_num)
+		serdes_info.sensor_num = serdes_info.rx_port;
+	else
+		serdes_info.sensor_num += serdes_info.rx_port;
+}
+
+void set_ti960_gpio(struct control_logic_data *ctl_data, struct serdes_platform_data **pdata)
+{
+	int i;
+
+	(*pdata)->reset_gpio = 0;
+	(*pdata)->FPD_gpio = -1;
+
+	if (ctl_data->completed && ctl_data->gpio_num > 0) {
+		for (i = 0; i < ctl_data->gpio_num; i++) {
+			/* check for RESET selection in BIOS */
+			if (ctl_data->gpio[i].valid && ctl_data->gpio[i].func == GPIO_RESET)
+				(*pdata)->reset_gpio = ctl_data->gpio[i].pin;
+
+			/* check for POWER_EN selection in BIOS */
+			if (ctl_data->gpio[i].valid && ctl_data->gpio[i].func == GPIO_POWER_EN)
+				(*pdata)->FPD_gpio = ctl_data->gpio[i].pin;
+		}
+	}
+}
+
+void set_lt_gpio(struct control_logic_data *ctl_data, struct sensor_platform_data **pdata,
+			bool is_dummy)
+{
+	int i;
+
+	(*pdata)->irq_pin = -1;
+	(*pdata)->reset_pin = -1;
+	(*pdata)->detect_pin = -1;
+
+	if (ctl_data->completed && ctl_data->gpio_num > 0 && !is_dummy) {
+		for (i = 0; i < ctl_data->gpio_num; i++) {
+			/* check for RESET selection in BIOS */
+			if (ctl_data->gpio[i].valid && ctl_data->gpio[i].func == GPIO_RESET)
+				(*pdata)->reset_pin = ctl_data->gpio[i].pin;
+
+			/* check for READY_STAT selection in BIOS */
+			if (ctl_data->gpio[i].valid && ctl_data->gpio[i].func == GPIO_READY_STAT) {
+				(*pdata)->irq_pin = ctl_data->gpio[i].pin;
+				(*pdata)->irq_pin_flags = IRQF_TRIGGER_RISING |
+							IRQF_TRIGGER_FALLING |
+							IRQF_ONESHOT;
+				strlcpy((*pdata)->irq_pin_name, "READY_STAT", sizeof("READY_STAT"));
+			}
+
+			/* check for HDMI_DETECT selection in BIOS */
+			if (ctl_data->gpio[i].valid && ctl_data->gpio[i].func == GPIO_HDMI_DETECT)
+				(*pdata)->detect_pin = ctl_data->gpio[i].pin;
+		}
+	}
+}
+
+void set_ar0234_gpio(struct sensor_platform_data **pdata)
+{
+	(*pdata)->gpios[0] = -1;
+	(*pdata)->gpios[1] = 0;
+	(*pdata)->gpios[2] = 0;
+	(*pdata)->gpios[3] = 0;
+}
+
+int set_csi2(struct ipu_isys_subdev_info **sensor_sd,
+		unsigned int lanes,
+		unsigned int port)
+{
+	struct ipu_isys_csi2_config *csi2_config;
+
+	csi2_config = kzalloc(sizeof(*csi2_config), GFP_KERNEL);
+	if (!csi2_config)
+		return -ENOMEM;
+
+	csi2_config->nlanes = lanes;
+	csi2_config->port = port;
+	(*sensor_sd)->csi2 = csi2_config;
+
+	return 0;
+}
+
+void set_i2c(struct ipu_isys_subdev_info **sensor_sd,
+		struct device *dev,
+		const char sensor_name[I2C_NAME_SIZE],
+		unsigned int addr)
+{
+	(*sensor_sd)->i2c.board_info.addr = addr;
+	strlcpy((*sensor_sd)->i2c.board_info.type, sensor_name, I2C_NAME_SIZE);
+	strlcpy((*sensor_sd)->i2c.i2c_adapter_bdf, dev_name(dev->parent->parent->parent),
+		sizeof((*sensor_sd)->i2c.i2c_adapter_bdf));
+}
+
+void set_serdes_sd_pdata(struct serdes_module_pdata **module_pdata, char sensor_name[I2C_NAME_SIZE],
+			unsigned int lanes)
+{
+	/* general */
+	(*module_pdata)->lanes = lanes;
+	strlcpy((*module_pdata)->module_name, sensor_name, I2C_NAME_SIZE);
+
+	/* TI960 and IMX390 specific */
+	if (!strcmp(sensor_name, IMX390_NAME)) {
+		(*module_pdata)->gpio_powerup_seq[0] = 0;
+		(*module_pdata)->gpio_powerup_seq[1] = 0x9;
+		(*module_pdata)->gpio_powerup_seq[2] = -1;
+		(*module_pdata)->gpio_powerup_seq[3] = -1;
+		(*module_pdata)->module_flags = TI960_FL_POWERUP | TI960_FL_INIT_SER_CLK;
+		(*module_pdata)->fsin = 3;
+	}
+}
+
+#define PORT_NR 8
+
+int set_serdes_subdev(struct ipu_isys_subdev_info **serdes_sd,
+		struct device *dev,
+		struct serdes_platform_data **pdata,
+		char sensor_name[I2C_NAME_SIZE],
+		unsigned int lanes,
+		unsigned int addr,
+		unsigned int subdev_port)
+{
+	int i;
+	struct serdes_module_pdata *module_pdata[PORT_NR];
+
+	for (i = 0; i < subdev_port; i++) {
+		module_pdata[i] = kzalloc(sizeof(*module_pdata[i]), GFP_KERNEL);
+		if (!module_pdata[i])
+			return -ENOMEM;
+
+		set_serdes_sd_pdata(&module_pdata[i], sensor_name, lanes);
+
+		/* board info */
+		strlcpy(serdes_sdinfo[i].board_info.type, sensor_name, I2C_NAME_SIZE);
+		serdes_sdinfo[i].board_info.addr = DUMMY_SERDES_BASE_ADDR + subdev_port + i;
+		serdes_sdinfo[i].board_info.platform_data = module_pdata[i];
+
+		/* serdes_subdev_info */
+		serdes_sdinfo[i].rx_port = i;
+		serdes_sdinfo[i].phy_i2c_addr = (addr << 1);
+		serdes_sdinfo[i].ser_alias = DUMMY_SERDES_BASE_ADDR + i;
+		serdes_sdinfo[i].suffix = i + 1 + SUFFIX_BASE + serdes_info.sensor_num;
+	}
+
+	(*pdata)->subdev_info = serdes_sdinfo;
+	(*pdata)->subdev_num = ARRAY_SIZE(serdes_sdinfo);
+
+	return 0;
+}
+
+int set_pdata(struct ipu_isys_subdev_info **sensor_sd,
+		struct device *dev,
+		char sensor_name[I2C_NAME_SIZE],
+		struct control_logic_data *ctl_data,
+		unsigned int port,
+		unsigned int lanes,
+		unsigned int addr,
+		unsigned int rx_port,
+		bool is_dummy,
+		enum connection_type connect)
+{
+	if (connect == TYPE_DIRECT) {
+		struct sensor_platform_data *pdata;
+
+		pdata = kzalloc(sizeof(*pdata), GFP_KERNEL);
+		if (!pdata)
+			return -ENOMEM;
+		/* use ascii */
+		/* port for D457 start from 0 */
+		if (!strcmp(sensor_name, D457_NAME) && port >= 0)
+			pdata->suffix = port + SUFFIX_BASE + 1;
+		else if (port > 0)
+			pdata->suffix = port + SUFFIX_BASE;
+		else
+			dev_err(dev, "INVALID MIPI PORT");
+
+		pdata->port = port;
+		pdata->lanes = lanes;
+		pdata->i2c_slave_address = addr;
+
+		/* gpio */
+		if (!strcmp(sensor_name, LT6911UXC_NAME))
+			set_lt_gpio(ctl_data, &pdata, is_dummy);
+		else if (!strcmp(sensor_name, AR0234_NAME))
+			set_ar0234_gpio(&pdata);
+
+		(*sensor_sd)->i2c.board_info.platform_data = pdata;
+	} else if (connect == TYPE_SERDES) {
+		struct serdes_platform_data *pdata;
+
+		pdata = kzalloc(sizeof(*pdata), GFP_KERNEL);
+		if (!pdata)
+			return -ENOMEM;
+
+		/* use ascii */
+		if (port > 0)
+			pdata->suffix = port + SUFFIX_BASE;
+		else
+			dev_err(dev, "INVALID MIPI PORT");
+
+		if (!strcmp(sensor_name, IMX390_NAME))
+			set_ti960_gpio(ctl_data, &pdata);
+
+		set_serdes_subdev(sensor_sd, dev, &pdata, sensor_name, lanes, addr, rx_port);
+
+		(*sensor_sd)->i2c.board_info.platform_data = pdata;
+	}
+
+	return 0;
+}
+
+void set_serdes_info(struct device *dev, const char *serdes_name, struct sensor_bios_data *cam_data)
+{
+	/* pprunit as num of sensor connected to deserializer*/
+	serdes_info.rx_port = cam_data->pprunit;
+
+	/* init sensor_num */
+	if (!serdes_info.sensor_num)
+		serdes_info.sensor_num = 0;
+
+	/* save sensor addr */
+	if (!serdes_info.sensor_addr)
+		serdes_info.sensor_addr = cam_data->i2c[1].addr;
+
+	/* TI960 specific */
+	if (!strcmp(serdes_name, TI960_NAME))
+		serdes_info.gpio_powerup_seq = TI960_MAX_GPIO_POWERUP_SEQ;
+	else
+		serdes_info.gpio_powerup_seq = 0;
+}
+
+int populate_dummy(struct device *dev,
+			char sensor_name[I2C_NAME_SIZE],
+			struct sensor_bios_data *cam_data,
+			struct control_logic_data *ctl_data,
+			enum connection_type connect)
+{
+	struct ipu_isys_subdev_info *dummy;
+	unsigned short addr_dummy = 0x11;
+	int ret;
+
+	dummy = kzalloc(sizeof(*dummy), GFP_KERNEL);
+	if (!dummy)
+		return -ENOMEM;
+
+	ret = set_csi2(&dummy, cam_data->lanes, cam_data->pprval);
+	if (ret) {
+		kfree(dummy);
+		return ret;
+	}
+
+	set_i2c(&dummy, dev, sensor_name, addr_dummy);
+
+	ret = set_pdata(&dummy, dev, sensor_name, ctl_data, cam_data->pprval,
+		cam_data->lanes, addr_dummy, 0, true, connect);
+	if (ret) {
+		kfree(dummy);
+		return ret;
+	}
+
+	update_pdata(dev, dummy, connect);
+
+	return 0;
+}
+
+int populate_sensor_pdata(struct device *dev,
+			struct ipu_isys_subdev_info **sensor_sd,
+			char sensor_name[I2C_NAME_SIZE],
+			struct sensor_bios_data *cam_data,
+			struct control_logic_data *ctl_data,
+			enum connection_type connect,
+			const char *serdes_name)
+{
+	int ret;
+
+	if (connect == TYPE_DIRECT) {
+		/* sensor csi2 info */
+		ret = set_csi2(sensor_sd, cam_data->lanes, cam_data->link);
+		if (ret)
+			return ret;
+
+		/* sensor i2c info */
+		if (cam_data->i2c_num == MIN_SENSOR_I2C) {
+			set_i2c(sensor_sd, dev, sensor_name, cam_data->i2c[0].addr);
+		} else {
+			dev_err(dev, "IPU6 ACPI: Incorrect number of I2C device for sensor (%lld)",
+				cam_data->i2c_num);
+			return -1;
+		}
+
+	} else if (connect == TYPE_SERDES) {
+		/* serdes csi2 info. pprval as deserializer lane */
+		ret = set_csi2(sensor_sd, cam_data->pprval, cam_data->link);
+		if (ret)
+			return ret;
+
+		/* Use DISCRETE Control Logic or No Control Logic for serdes */
+		if (ctl_data->type != CL_DISCRETE && ctl_data->type != CL_EMPTY) {
+			dev_err(dev, "IPU6 ACPI: Incorrect Control Logic Type for serdes (%d)",
+				ctl_data->type);
+			return -1;
+		}
+
+		/* serdes i2c info */
+		if (cam_data->i2c_num == MIN_SERDES_I2C) {
+			dev_info(dev, "IPU6 ACPI: correct i2c device for serdes");
+			set_i2c(sensor_sd, dev, serdes_name, cam_data->i2c[0].addr);
+		} else {
+			dev_err(dev, "IPU6 ACPI: Incorrect number of I2C device for serdes (%lld)",
+				cam_data->i2c_num);
+			return -1;
+		}
+
+		/* local serdes info */
+		set_serdes_info(dev, serdes_name, cam_data);
+	}
+
+	/* Use last I2C device */
+	ret = set_pdata(sensor_sd, dev, sensor_name, ctl_data, cam_data->link,
+		cam_data->lanes, cam_data->i2c[cam_data->i2c_num - 1].addr,
+		cam_data->pprunit, false, connect);
+
+	if (ret)
+		return ret;
+
+	update_pdata(dev, *sensor_sd, connect);
+
+	/* Lontium specific */
+	if (!strcmp(sensor_name, LT6911UXC_NAME)) {
+		if (cam_data->pprval != cam_data->link) {
+			ret = populate_dummy(dev, sensor_name, cam_data, ctl_data, connect);
+			if (ret)
+				return ret;
+		}
+	}
+
+	return 0;
+}
+
+int get_sensor_pdata(struct i2c_client *client,
+			struct ipu_camera_module_data *data,
+			struct ipu_i2c_helper *helper,
+			void *priv, size_t size,
+			enum connection_type connect, const char *serdes_name)
+{
+	struct sensor_bios_data *cam_data;
+	struct control_logic_data *ctl_data;
+	struct ipu_isys_subdev_info *sensor_sd;
+	int rval;
+
+	cam_data = kzalloc(sizeof(*cam_data), GFP_KERNEL);
+	if (!cam_data)
+		return -ENOMEM;
+
+	cam_data->dev = &client->dev;
+
+	ctl_data = kzalloc(sizeof(*ctl_data), GFP_KERNEL);
+	if (!ctl_data) {
+		kfree(cam_data);
+		return -ENOMEM;
+	}
+
+	sensor_sd = kzalloc(sizeof(*sensor_sd), GFP_KERNEL);
+	if (!sensor_sd) {
+		kfree(cam_data);
+		kfree(ctl_data);
+		return -ENOMEM;
+	}
+
+	/* camera info */
+	rval = ipu_acpi_get_cam_data(&client->dev, cam_data);
+	if (rval) {
+		kfree(sensor_sd);
+		kfree(cam_data);
+		kfree(ctl_data);
+		return rval;
+	}
+
+	/* control logic info */
+	rval = ipu_acpi_get_dep_data(&client->dev, ctl_data);
+	if (rval) {
+		kfree(sensor_sd);
+		kfree(cam_data);
+		kfree(ctl_data);
+		return rval;
+	}
+
+	/* populate pdata */
+	rval = populate_sensor_pdata(&client->dev, &sensor_sd,
+				client->name, cam_data, ctl_data, connect, serdes_name);
+	if (rval) {
+		kfree(sensor_sd);
+		kfree(cam_data);
+		kfree(ctl_data);
+		return rval;
+	}
+
+	client->dev.platform_data = sensor_sd;
+
+	kfree(cam_data);
+	kfree(ctl_data);
+	return rval;
+}
+EXPORT_SYMBOL(get_sensor_pdata);
+
+MODULE_AUTHOR("Khai Wen, Ng <khai.wen.ng@intel.com>");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("IPU6 ACPI support");
diff --git a/drivers/media/platform/intel/ipu6-acpi.c b/drivers/media/platform/intel/ipu6-acpi.c
index ac92174c8ddb..f334faf868cb 100644
--- a/drivers/media/platform/intel/ipu6-acpi.c
+++ b/drivers/media/platform/intel/ipu6-acpi.c
@@ -30,132 +30,20 @@
 #include <linux/regulator/machine.h>
 #include <linux/list.h>
 #include <linux/platform_device.h>
-
-#include <linux/clk.h>
 #include <linux/clkdev.h>
-#include <linux/gpio.h>
 #include <linux/kernel.h>
 #include <linux/pci.h>
 #include <media/ipu-isys.h>
 #include "ipu.h"
-
+#include <media/ipu-acpi-pdata.h>
 #include <media/ipu-acpi.h>
 #include <media/ar0234.h>
 #include <media/lt6911uxc.h>
+#include <media/imx390.h>
+#include <media/ti960.h>
+#include <media/d4xx.h>
 
-#define HID_BUFFER_SIZE 32
-#define VCM_BUFFER_SIZE 32
-
-#define LOOP_SIZE 10
-#define SUFFIX_BASE 96
 static LIST_HEAD(devices);
-static LIST_HEAD(new_devs);
-
-struct ipu_i2c_helper {
-	int (*fn)(struct device *dev, void *priv,
-		  struct ipu_isys_csi2_config *csi2,
-		  bool reprobe);
-	void *driver_data;
-};
-
-struct ipu_i2c_new_dev {
-	struct list_head list;
-	struct i2c_board_info info;
-	unsigned short int bus;
-};
-
-struct ipu_camera_module_data {
-	struct list_head list;
-	struct ipu_isys_subdev_info sd;
-	struct ipu_isys_csi2_config csi2;
-	unsigned int ext_clk;
-	void *pdata; /* Ptr to generated platform data*/
-	void *priv; /* Private for specific subdevice */
-};
-
-struct ipu_acpi_devices {
-	const char *hid_name;
-	const char *real_driver;
-	int (*get_platform_data)(struct i2c_client *client,
-				 struct ipu_camera_module_data *data,
-				 struct ipu_i2c_helper *helper,
-				 void *priv, size_t size);
-	void *priv_data;
-	size_t priv_size;
-//	const struct intel_ipu_regulator *regulators;
-};
-
-/* acpi_subdev_pdata as pdata */
-
-static struct ipu_isys_clk_mapping clk_mapping[] = {
-	{ CLKDEV_INIT(NULL, NULL, NULL), NULL }
-};
-
-struct ipu_isys_subdev_pdata acpi_subdev_pdata = {
-	.subdevs = (struct ipu_isys_subdev_info *[]) {
-		NULL,
-	},
-	.clk_map = clk_mapping,
-};
-
-struct ipu_isys_subdev_pdata *ptr_built_in_pdata;
-
-static int get_integer_dsdt_data(struct device *dev, const u8 *dsdt,
-				 int func, u64 *out)
-{
-	struct acpi_handle *dev_handle = ACPI_HANDLE(dev);
-	union acpi_object *obj;
-
-	obj = acpi_evaluate_dsm(dev_handle, (void *)dsdt, 0, func, NULL);
-	if (!obj) {
-		dev_err(dev, "No dsdt\n");
-		return -ENODEV;
-	}
-	dev_dbg(dev, "ACPI type %d", obj->type);
-
-	if (obj->type != ACPI_TYPE_INTEGER) {
-		ACPI_FREE(obj);
-		return -ENODEV;
-	}
-	*out = obj->integer.value;
-	ACPI_FREE(obj);
-	return 0;
-}
-
-static int read_acpi_block(struct device *dev, char *id, void *data, u32 size)
-{
-	union acpi_object *obj;
-	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
-	struct acpi_handle *dev_handle = ACPI_HANDLE(dev);
-	int status;
-	u32 buffer_length;
-
-	status = acpi_evaluate_object(dev_handle, id, NULL, &buffer);
-	if (!ACPI_SUCCESS(status))
-		return -ENODEV;
-
-	obj = (union acpi_object *)buffer.pointer;
-	if (!obj || obj->type != ACPI_TYPE_BUFFER) {
-		dev_err(dev, "Could't read acpi buffer\n");
-		status = -ENODEV;
-		goto err;
-	}
-
-	if (obj->buffer.length > size) {
-		dev_err(dev, "Given buffer is too small\n");
-		status = -ENODEV;
-		goto err;
-	}
-
-	memcpy(data, obj->buffer.pointer, min(size, obj->buffer.length));
-	buffer_length = obj->buffer.length;
-	kfree(buffer.pointer);
-
-	return buffer_length;
-err:
-	kfree(buffer.pointer);
-	return status;
-}
 
 static struct ipu_camera_module_data *add_device_to_list(
 	struct list_head *devices)
@@ -170,694 +58,16 @@ static struct ipu_camera_module_data *add_device_to_list(
 	return cam_device;
 }
 
-static int ipu_acpi_get_gpio_data(struct device *dev, struct ipu_gpio_info *gpio, int size,
-				u64 *gpio_num)
-{
-	const u8 dsdt_cam_gpio[] = {
-		0x40, 0x46, 0x23, 0x79, 0x10, 0x9e, 0xea, 0x4f,
-		0xa5, 0xc1, 0xB5, 0xaa, 0x8b, 0x19, 0x75, 0x6f };
-
-	int i = 0, j = 0, retries = 0, loop = 0;
-	u64 num_gpio;
-
-	int rval = get_integer_dsdt_data(dev, dsdt_cam_gpio, 1, &num_gpio);
-
-	if (rval < 0) {
-		dev_err(dev, "Failed to get number of GPIO pins\n");
-		return rval;
-	}
-
-	dev_dbg(dev, "Num of gpio found = %lld", num_gpio);
-
-	if (num_gpio == 0) {
-		*gpio_num = num_gpio;
-		return rval;
-	}
-
-	if (num_gpio > size) {
-		dev_err(dev, "Incorrect number of GPIO pins\n");
-		return rval;
-	}
-
-	/* repeat until all gpio pin is saved */
-	while (i < num_gpio && loop <= LOOP_SIZE) {
-		u64 data;
-		struct gpio_desc *desc = NULL;
-
-		rval = get_integer_dsdt_data(dev, dsdt_cam_gpio, i + 2, &data);
-
-		if (rval < 0) {
-			dev_err(dev, "No gpio data\n");
-			return -ENODEV;
-		}
-
-		gpio[i].func = (data & 0xff);
-		gpio[i].valid = FALSE;
-
-		desc = gpiod_get_index(dev, NULL, i + retries, GPIOD_ASIS);
-
-		if (!IS_ERR(desc)) {
-			unsigned short pin = desc_to_gpio(desc);
-			bool save = TRUE;
-
-			/* always save first GPIO pin */
-			if (i == 0)
-				save = TRUE;
-
-			/* check subsequent GPIO pin for replicate */
-			else {
-				for (j = 0; j <= i; j++) {
-					/* retry if same as previous pin */
-					if (gpio[j].pin == pin) {
-						retries++;
-						save = FALSE;
-						gpiod_put(desc);
-						break;
-					}
-				}
-			}
-
-			/* save into array */
-			if (save == TRUE) {
-				gpio[i].pin = pin;
-				gpio[i].valid = TRUE;
-				gpiod_put(desc);
-				i++;
-				retries = 0;
-			}
-		}
-		loop++;
-	}
-	*gpio_num = num_gpio;
-
-	return rval;
-}
-
-static int ipu_acpi_get_i2c_info(struct device *dev, struct ipu_i2c_info *i2c, int size)
-{
-	const u8 dsdt_cam_i2c[] = {
-		0x49, 0x75, 0x25, 0x26, 0x71, 0x92, 0xA4, 0x4C,
-		0xBB, 0x43, 0xC4, 0x89, 0x9D, 0x5A, 0x48, 0x81};
-
-	u64 num_i2c;
-	int i;
-	int rval = get_integer_dsdt_data(dev, dsdt_cam_i2c, 1, &num_i2c);
-
-	if (rval < 0) {
-		dev_err(dev, "Failed to get number of I2C\n");
-		return -ENODEV;
-	}
-
-	for (i = 0; i < num_i2c && i < size; i++) {
-		u64 data;
-
-		rval = get_integer_dsdt_data(dev, dsdt_cam_i2c, i + 2,
-					     &data);
-
-		if (rval < 0) {
-			dev_err(dev, "Failed to get I2C data\n");
-			return -ENODEV;
-		}
-
-		i2c[i].bus = ((data >> 24) & 0xff);
-		i2c[i].addr = (data >> 8) & 0xff;
-
-		dev_dbg(dev, "ACPI camera option: i2c bus %d addr %x",
-			i2c[i].bus, i2c[i].addr);
-	}
-	return 0;
-}
-
-static int match_depend(struct device *dev, const void *data)
-{
-	return (dev && dev->fwnode == data) ? 1 : 0;
-}
-
-#define MAX_CONSUMERS 1
-static int ipu_acpi_get_control_logic_data(struct device *dev,
-					struct control_logic_data **ctl_data)
-{
-	/* CLDB data */
-	struct control_logic_data_packed ctl_logic_data;
-	int ret = read_acpi_block(dev, "CLDB", &ctl_logic_data,
-				sizeof(ctl_logic_data));
-
-	if (ret < 0) {
-		dev_err(dev, "no such CLDB block");
-		return ret;
-	}
-
-	(*ctl_data)->type = ctl_logic_data.controllogictype;
-	(*ctl_data)->id = ctl_logic_data.controllogicid;
-	(*ctl_data)->sku = ctl_logic_data.sensorcardsku;
-
-	dev_dbg(dev, "CLDB data version %d clid %d cltype %d sku %d",
-		ctl_logic_data.version,
-		ctl_logic_data.controllogictype,
-		ctl_logic_data.controllogicid,
-		ctl_logic_data.sensorcardsku);
-
-	/* GPIO data */
-	ret = ipu_acpi_get_gpio_data(dev, (*ctl_data)->gpio, ARRAY_SIZE((*ctl_data)->gpio),
-				&((*ctl_data)->gpio_num));
-
-	if (ret < 0) {
-		dev_err(dev, "Failed to get GPIO data");
-		return ret;
-	}
-	return 0;
-}
-
-static int ipu_acpi_get_dep_data(struct device *dev,
-			     struct control_logic_data *ctl_data)
-{
-	struct acpi_handle *dev_handle = ACPI_HANDLE(dev);
-	struct acpi_handle_list dep_devices;
-	acpi_status status;
-	int i;
-	int rval;
-
-	ctl_data->completed = false;
-
-	if (!acpi_has_method(dev_handle, "_DEP")) {
-		dev_err(dev, "ACPI does not have _DEP method");
-		return 0;
-	}
-
-	status = acpi_evaluate_reference(dev_handle, "_DEP", NULL,
-					 &dep_devices);
-
-	if (ACPI_FAILURE(status)) {
-		dev_err(dev, "Failed to evaluate _DEP.\n");
-		return -ENODEV;
-	}
-
-	for (i = 0; i < dep_devices.count; i++) {
-		struct acpi_device *device;
-		struct acpi_device_info *info;
-		struct device *p_dev;
-		int match;
-
-		status = acpi_get_object_info(dep_devices.handles[i], &info);
-		if (ACPI_FAILURE(status)) {
-			dev_err(dev, "Error reading _DEP device info\n");
-			continue;
-		}
-
-		match = info->valid & ACPI_VALID_HID &&
-			!strcmp(info->hardware_id.string, "INT3472");
-
-		kfree(info);
-
-		if (!match)
-			continue;
-
-		/* Process device IN3472 created by acpi */
-		if (acpi_bus_get_device(dep_devices.handles[i], &device)) {
-			dev_err(dev, "INT3472 does not have dep device");
-			return -ENODEV;
-		}
-
-		dev_dbg(dev, "Depend ACPI device found: %s\n",
-			dev_name(&device->dev));
-
-		p_dev = bus_find_device(&platform_bus_type, NULL,
-					&device->fwnode, match_depend);
-
-		if (p_dev) {
-			dev_err(dev, "Dependent platform device found %s\n",
-				dev_name(p_dev));
-
-			/* obtain Control Logic Data from BIOS */
-			rval = ipu_acpi_get_control_logic_data(p_dev, &ctl_data);
-
-			if (rval) {
-				dev_err(dev, "Error getting Control Logic Data");
-				return rval;
-			} else
-				ctl_data->completed = true;
-		} else
-			dev_err(dev, "Dependent platform device not found\n");
-	}
-
-	if (!ctl_data->completed)
-		dev_err(dev, "No control logic data available");
-
-	return 0;
-}
-
-int ipu_acpi_get_cam_data(struct device *dev,
-			     struct sensor_bios_data *sensor)
-{
-	/* SSDB */
-	struct sensor_bios_data_packed sensor_data;
-
-	int ret = read_acpi_block(dev, "SSDB", &sensor_data,
-				  sizeof(sensor_data));
-
-	if (ret < 0) {
-		dev_err(dev, "Fail to read from SSDB");
-		return ret;
-	}
-
-	/* Xshutdown is not part of the ssdb data */
-	sensor->link = sensor_data.link;
-	sensor->lanes = sensor_data.lanes;
-	sensor->pprval = sensor_data.pprval;
-
-	dev_dbg(dev, "sensor ACPI data: name %s link %d, lanes %d ",
-		dev_name(dev), sensor->link, sensor->lanes);
-
-	/* I2C */
-	ret = ipu_acpi_get_i2c_info(dev, sensor->i2c, ARRAY_SIZE(sensor->i2c));
-
-	if (ret < 0)
-		return ret;
-
-	return 0;
-}
-EXPORT_SYMBOL(ipu_acpi_get_cam_data);
-
-static void add_local_subdevs(struct ipu_isys_subdev_info *new_subdev_info)
-{
-	struct ipu_isys_subdev_pdata *ptr_acpi_subdev_pdata = &acpi_subdev_pdata;
-	int i = 0;
-
-	while (i <= MAX_ACPI_SENSOR_NUM) {
-		if (!ptr_acpi_subdev_pdata->subdevs[i]) {
-			ptr_acpi_subdev_pdata->subdevs[i] = new_subdev_info;
-			ptr_acpi_subdev_pdata->subdevs[i+1] = NULL;
-			break;
-		}
-		i++;
-	}
-}
-
-static bool update_subdev(struct device *dev,
-			struct ipu_isys_subdev_info *new_subdev_info,
-			struct ipu_isys_subdev_info **sd_info)
-{
-	struct lt6911uxc_platform_data *ori_pdata =
-					(*sd_info)->i2c.board_info.platform_data;
-
-	struct lt6911uxc_platform_data *new_pdata =
-					new_subdev_info->i2c.board_info.platform_data;
-
-	/* csi2 */
-	if ((*sd_info)->csi2->port != new_subdev_info->csi2->port)
-		dev_info(dev, "CSI2 Port %d -> %d",
-			(*sd_info)->csi2->port, new_subdev_info->csi2->port);
-
-	if ((*sd_info)->csi2->nlanes != new_subdev_info->csi2->nlanes)
-		dev_info(dev, "CSI2 nlanes %d -> %d",
-			(*sd_info)->csi2->nlanes, new_subdev_info->csi2->nlanes);
-
-	/* i2c */
-	if ((*sd_info)->i2c.board_info.addr != new_subdev_info->i2c.board_info.addr)
-		dev_info(dev, "I2C board_info addr %x -> %x",
-			(*sd_info)->i2c.board_info.addr, new_subdev_info->i2c.board_info.addr);
-
-	if (strcmp((*sd_info)->i2c.i2c_adapter_bdf, new_subdev_info->i2c.i2c_adapter_bdf) != 0)
-		dev_info(dev, "I2C bdf %s -> %s",
-			(*sd_info)->i2c.i2c_adapter_bdf, new_subdev_info->i2c.i2c_adapter_bdf);
-
-	/* platform data */
-	if (ori_pdata->port != new_pdata->port)
-		dev_info(dev, "Pdata port %d -> %d",
-			ori_pdata->port, new_pdata->port);
-
-	if (ori_pdata->lanes != new_pdata->lanes)
-		dev_info(dev, "Pdata lanes %d -> %d",
-			ori_pdata->lanes, new_pdata->lanes);
-
-	if (ori_pdata->i2c_slave_address != new_pdata->i2c_slave_address)
-		dev_info(dev, "Pdata I2C_slave_addr %x -> %x",
-			ori_pdata->i2c_slave_address, new_pdata->i2c_slave_address);
-
-	if (ori_pdata->irq_pin != new_pdata->irq_pin)
-		dev_info(dev, "Pdata irq_pin %d -> %d",
-			ori_pdata->irq_pin, new_pdata->irq_pin);
-
-	if (strcmp(ori_pdata->irq_pin_name, new_pdata->irq_pin_name) != 0)
-		dev_info(dev, "Pdata irq_pin_name %s -> %s",
-			ori_pdata->irq_pin_name, new_pdata->irq_pin_name);
-
-	if (ori_pdata->reset_pin != new_pdata->reset_pin)
-		dev_info(dev, "Pdata reset_pin %d -> %d",
-			ori_pdata->reset_pin, new_pdata->reset_pin);
-
-	if (ori_pdata->detect_pin != new_pdata->detect_pin)
-		dev_info(dev, "Pdata detect_pin %d -> %d",
-			ori_pdata->detect_pin, new_pdata->detect_pin);
-
-	(*sd_info)->csi2->port = new_subdev_info->csi2->port;
-	(*sd_info)->csi2->nlanes = new_subdev_info->csi2->nlanes;
-	(*sd_info)->i2c.board_info.addr = new_subdev_info->i2c.board_info.addr;
-
-	strlcpy((*sd_info)->i2c.i2c_adapter_bdf, new_subdev_info->i2c.i2c_adapter_bdf,
-		sizeof((*sd_info)->i2c.i2c_adapter_bdf));
-
-	ori_pdata->port = new_pdata->port;
-	ori_pdata->lanes = new_pdata->lanes;
-	ori_pdata->i2c_slave_address = new_pdata->i2c_slave_address;
-
-	ori_pdata->irq_pin = new_pdata->irq_pin;
-
-	strlcpy(ori_pdata->irq_pin_name, new_pdata->irq_pin_name, sizeof(new_pdata->irq_pin_name));
-	ori_pdata->reset_pin = new_pdata->reset_pin;
-	ori_pdata->detect_pin = new_pdata->detect_pin;
-
-	return true;
-}
-
-int compare_subdev(struct device *dev,
-			struct ipu_isys_subdev_info *new_subdev,
-			struct ipu_isys_subdev_info *existing_subdev)
-{
-	/* check for ACPI HID in existing pdata */
-	if (existing_subdev->acpi_hid) {
-		/* compare with HID for User Custom */
-		if (!strcmp(existing_subdev->acpi_hid, dev_name(dev))) {
-			dev_info(dev, "Found matching sensor : %s", dev_name(dev));
-			return 0;
-		}
-	}
-
-	/* compare sensor type */
-	if (!strcmp(existing_subdev->i2c.board_info.type,
-			new_subdev->i2c.board_info.type)) {
-		struct lt6911uxc_platform_data *existing_pdata, *new_pdata;
-
-		existing_pdata = (struct lt6911uxc_platform_data *)
-					existing_subdev->i2c.board_info.platform_data;
-
-		new_pdata = (struct lt6911uxc_platform_data *)
-					new_subdev->i2c.board_info.platform_data;
-
-		if (existing_pdata->suffix == new_pdata->suffix) {
-			dev_info(dev, "Found matching sensor : %s %c",
-				existing_subdev->i2c.board_info.type,
-				existing_pdata->suffix);
-			return 0;
-		}
-	}
-	return -1;
-}
-
-void update_pdata(struct device *dev,
-			struct ipu_isys_subdev_info *new_subdev)
-{
-	struct ipu_isys_subdev_info *acpi_subdev;
-
-	acpi_subdev = new_subdev;
-
-	/* update local ipu_isys_subdev_pdata */
-	add_local_subdevs(acpi_subdev);
-
-	/* if there is existing pdata, update the existing one */
-	if (ptr_built_in_pdata) {
-		struct ipu_isys_subdev_info **subdevs, *sd_info;
-
-		for (subdevs = ptr_built_in_pdata->subdevs; *subdevs; subdevs++) {
-			sd_info = *subdevs;
-
-			if (!compare_subdev(dev, acpi_subdev, sd_info))
-				update_subdev(dev, acpi_subdev, &sd_info);
-		}
-	}
-}
-
-int ar0234_populate(struct device dev,
-			struct ipu_isys_subdev_info **ar0234_sd,
-			struct ipu_i2c_info i2c,
-			char sensor_name[I2C_NAME_SIZE],
-			struct sensor_bios_data cam_data,
-			struct control_logic_data ctl_data)
-{
-	struct ar0234_platform_data *pdata;
-	struct ipu_isys_csi2_config *csi2_config;
-
-	pdata = kzalloc(sizeof(*pdata), GFP_KERNEL);
-	if (!pdata)
-		return -ENOMEM;
-
-	csi2_config = kzalloc(sizeof(*csi2_config), GFP_KERNEL);
-	if (!csi2_config) {
-		kfree(pdata);
-		return -ENOMEM;
-	}
-
-	/* csi2 */
-	csi2_config->nlanes = cam_data.lanes;
-	csi2_config->port = cam_data.link;
-	(*ar0234_sd)->csi2 = csi2_config;
-
-	/* i2c */
-	(*ar0234_sd)->i2c.board_info.addr = i2c.addr;
-	strlcpy((*ar0234_sd)->i2c.board_info.type, sensor_name, I2C_NAME_SIZE);
-	strlcpy((*ar0234_sd)->i2c.i2c_adapter_bdf, dev_name(dev.parent->parent->parent),
-		sizeof((*ar0234_sd)->i2c.i2c_adapter_bdf));
-
-	/* platform_data */
-	pdata->port = cam_data.link;
-	pdata->lanes = cam_data.lanes;
-	pdata->i2c_slave_address = cam_data.i2c[0].addr;
-
-	/* gpio */
-	pdata->irq_pin = -1;
-	pdata->gpios[0] = -1;
-	pdata->gpios[1] = 0;
-	pdata->gpios[2] = 0;
-	pdata->gpios[3] = 0;
-
-	switch (cam_data.link) {
-	case 1:
-		pdata->suffix = 'a';
-		break;
-	case 2:
-		pdata->suffix = 'b';
-		break;
-	case 4:
-		pdata->suffix = 'c';
-		break;
-	case 5:
-		pdata->suffix = 'd';
-		break;
-	default:
-		dev_err(&dev, "INVALID MIPI PORT");
-		break;
-	}
-
-	(*ar0234_sd)->i2c.board_info.platform_data = pdata;
-
-	return 0;
-}
-
-int lt6911uxc_populate(struct device *dev,
-			struct ipu_isys_subdev_info **lt6911uxc_sd,
-			char sensor_name[I2C_NAME_SIZE],
-			struct sensor_bios_data *cam_data,
-			struct control_logic_data *ctl_data)
-{
-	struct lt6911uxc_platform_data *pdata;
-	struct ipu_isys_csi2_config *csi2_config;
-	int i;
-	bool irq_set = false;
-
-	pdata = kzalloc(sizeof(*pdata), GFP_KERNEL);
-	if (!pdata)
-		return -ENOMEM;
-
-	csi2_config = kzalloc(sizeof(*csi2_config), GFP_KERNEL);
-	if (!csi2_config) {
-		kfree(pdata);
-		return -ENOMEM;
-	}
-
-	/* csi2 */
-	csi2_config->nlanes = cam_data->lanes;
-	csi2_config->port = cam_data->link;
-	(*lt6911uxc_sd)->csi2 = csi2_config;
-
-	/* i2c */
-	(*lt6911uxc_sd)->i2c.board_info.addr = cam_data->i2c[0].addr;
-	strlcpy((*lt6911uxc_sd)->i2c.board_info.type, sensor_name, I2C_NAME_SIZE);
-	strlcpy((*lt6911uxc_sd)->i2c.i2c_adapter_bdf, dev_name(dev->parent->parent->parent),
-		sizeof((*lt6911uxc_sd)->i2c.i2c_adapter_bdf));
-
-	/* platform data */
-	pdata->port = cam_data->link;
-	pdata->lanes = cam_data->lanes;
-	pdata->i2c_slave_address = cam_data->i2c[0].addr;
-
-	/* use ascii */
-	if (cam_data->link > 0)
-		pdata->suffix = cam_data->link + SUFFIX_BASE;
-	else
-		dev_err(dev, "INVALID MIPI PORT");
-
-	/* gpio */
-	if (ctl_data->completed && ctl_data->gpio_num > 0) {
-		for (i = 0; i < ctl_data->gpio_num; i++) {
-			/* check for RESET selection in BIOS */
-			if (ctl_data->gpio[i].valid && ctl_data->gpio[i].func == GPIO_RESET)
-				pdata->reset_pin = ctl_data->gpio[i].pin;
-			/* check for READY_STAT selection in BIOS */
-			if (ctl_data->gpio[i].valid && ctl_data->gpio[i].func == GPIO_READY_STAT) {
-				pdata->irq_pin = ctl_data->gpio[i].pin;
-				pdata->irq_pin_flags = IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING |
-							IRQF_ONESHOT;
-				strlcpy(pdata->irq_pin_name, "READY_STAT", sizeof("READY_STAT"));
-				irq_set = true;
-			}
-			/* check for HDMI_DETECT selection in BIOS */
-			if (ctl_data->gpio[i].valid && ctl_data->gpio[i].func == GPIO_HDMI_DETECT)
-				pdata->detect_pin = ctl_data->gpio[i].pin;
-		}
-	}
-
-	if (!irq_set)
-		pdata->irq_pin = -1;
-
-	pdata->gpios[0] = -1;
-	pdata->gpios[1] = 0;
-	pdata->gpios[2] = 0;
-	pdata->gpios[3] = 0;
-
-	(*lt6911uxc_sd)->i2c.board_info.platform_data = pdata;
-
-	// insert pdata into local here.
-	update_pdata(dev, *lt6911uxc_sd);
-
-	/* pprval is used as an indicator to enumerate dummy port for HDMI use case */
-	if (cam_data->pprval != cam_data->link) {
-		struct ipu_isys_subdev_info *lt6911uxc_sd_dummy;
-		struct lt6911uxc_platform_data *pdata_dummy;
-		struct ipu_isys_csi2_config *csi2_config_dummy;
-		unsigned short addr_dummy = 0x11;
-
-		lt6911uxc_sd_dummy = kzalloc(sizeof(*lt6911uxc_sd_dummy), GFP_KERNEL);
-		if (!lt6911uxc_sd_dummy) {
-			kfree(pdata);
-			kfree(csi2_config);
-			return -ENOMEM;
-		}
-
-		pdata_dummy = kzalloc(sizeof(*pdata_dummy), GFP_KERNEL);
-		if (!pdata_dummy) {
-			kfree(pdata);
-			kfree(csi2_config);
-			kfree(lt6911uxc_sd_dummy);
-			return -ENOMEM;
-		}
-
-		csi2_config_dummy = kzalloc(sizeof(*csi2_config_dummy), GFP_KERNEL);
-		if (!csi2_config_dummy) {
-			kfree(pdata);
-			kfree(csi2_config);
-			kfree(lt6911uxc_sd_dummy);
-			kfree(pdata_dummy);
-			return -ENOMEM;
-		}
-
-		pdata_dummy->port = cam_data->pprval;
-		pdata_dummy->lanes = cam_data->lanes;
-		pdata_dummy->i2c_slave_address = addr_dummy;
-		pdata_dummy->suffix = cam_data->pprval + SUFFIX_BASE;
-		pdata_dummy->irq_pin = -1;
-
-		csi2_config_dummy->nlanes = cam_data->lanes;
-		csi2_config_dummy->port = cam_data->pprval;
-
-		lt6911uxc_sd_dummy->csi2 = csi2_config_dummy;
-		lt6911uxc_sd_dummy->i2c.board_info.addr = addr_dummy;
-		strlcpy(lt6911uxc_sd_dummy->i2c.board_info.type, sensor_name, I2C_NAME_SIZE);
-		strlcpy(lt6911uxc_sd_dummy->i2c.i2c_adapter_bdf, dev_name(dev->parent->parent->parent),
-			sizeof(lt6911uxc_sd_dummy->i2c.i2c_adapter_bdf));
-
-		lt6911uxc_sd_dummy->i2c.board_info.platform_data = pdata_dummy;
-
-		/* update pdata */
-		update_pdata(dev, lt6911uxc_sd_dummy);
-
-	}
-
-	return 0;
-}
-
-static int get_lt6911uxc_pdata(struct i2c_client *client,
-			       struct ipu_camera_module_data *data,
-			       struct ipu_i2c_helper *helper,
-			       void *priv, size_t size)
-{
-	struct sensor_bios_data *cam_data;
-	struct control_logic_data *ctl_data;
-	struct ipu_isys_subdev_info *lt6911uxc_sd;
-	int rval;
-
-	cam_data = kzalloc(sizeof(*cam_data), GFP_KERNEL);
-	if (!cam_data)
-		return -ENOMEM;
-
-	cam_data->dev = &client->dev;
-
-	ctl_data = kzalloc(sizeof(*ctl_data), GFP_KERNEL);
-	if (!ctl_data) {
-		kfree(cam_data);
-		return -ENOMEM;
-	}
-
-	lt6911uxc_sd = kzalloc(sizeof(*lt6911uxc_sd), GFP_KERNEL);
-	if (!lt6911uxc_sd) {
-		kfree(cam_data);
-		kfree(ctl_data);
-		return -ENOMEM;
-	}
-
-	/* get sensor info from ssdb table generated from BIOS, save in sensor */
-	rval = ipu_acpi_get_cam_data(&client->dev, cam_data);
-	if (rval) {
-		kfree(lt6911uxc_sd);
-		kfree(cam_data);
-		kfree(ctl_data);
-		return rval;
-	}
-
-	rval = ipu_acpi_get_dep_data(&client->dev, ctl_data);
-	if (rval) {
-		kfree(lt6911uxc_sd);
-		kfree(cam_data);
-		kfree(ctl_data);
-		return rval;
-	}
-
-	rval = lt6911uxc_populate(&client->dev, &lt6911uxc_sd,
-				client->name, cam_data, ctl_data);
-	if (rval) {
-		kfree(lt6911uxc_sd);
-		kfree(cam_data);
-		kfree(ctl_data);
-		return rval;
-	}
-
-	client->dev.platform_data = lt6911uxc_sd;
-
-	kfree(cam_data);
-	kfree(ctl_data);
-	return rval;
-}
-
 static const struct ipu_acpi_devices supported_devices[] = {
 /*
- *	{ "AR0234A", AR0234_NAME, get_ar0234_pdata, NULL, 0 },
- *	{ "AR0234B", AR0234_NAME, get_ar0234_pdata, NULL, 0 },
- *	{ "AR0234C", AR0234_NAME, get_ar0234_pdata, NULL, 0 },
- *	{ "AR0234D", AR0234_NAME, get_ar0234_pdata, NULL, 0 },
- *	{ "LT6911A", LT6911UXC_NAME, get_lt6911uxc_pdata, NULL, 0 },
- *	{ "LT6911B", LT6911UXC_NAME, get_lt6911uxc_pdata, NULL, 0 },
- *	{ "LT6911C", LT6911UXC_NAME, get_lt6911uxc_pdata, NULL, 0 },
+ *	{ "ACPI ID", sensor_name, get_sensor_pdata, NULL, 0, TYPE, serdes_name },	// Custom HID
  */
-	{ "INTC10B1", LT6911UXC_NAME, get_lt6911uxc_pdata, NULL, 0 },	// HID for Lontium
+	{ "INTC10C0", AR0234_NAME, get_sensor_pdata, NULL, 0, TYPE_DIRECT, NULL },	// AR0234 HID
+	{ "INTC10B1", LT6911UXC_NAME, get_sensor_pdata, NULL, 0, TYPE_DIRECT, NULL },	// Lontium HID
+	{ "INTC10C1", IMX390_NAME, get_sensor_pdata, NULL, 0, TYPE_SERDES, TI960_NAME },// IMX390 HID
+	{ "INTC10CD", D457_NAME, get_sensor_pdata, NULL, 0, TYPE_DIRECT, NULL },	// D457 HID
+	/* for later usage */
+//	{ "INTC10CD", D457_NAME, get_sensor_pdata, NULL, 0, TYPE_SERDES, MAX9296_NAME },// D457 HID
 };
 
 static int get_table_index(struct device *device, const __u8 *acpi_name)
@@ -876,15 +86,12 @@ static int get_table_index(struct device *device, const __u8 *acpi_name)
 /* Must match with HID in BIOS option. Add new sensor if required */
 static const struct acpi_device_id ipu_acpi_match[] = {
 /*
- *	{ "AR0234A", 0 },
- *	{ "AR0234B", 0 },
- *	{ "AR0234C", 0 },
- *	{ "AR0234D", 0 },
- *	{ "LT6911A", 0 },
- *	{ "LT6911B", 0 },
- *	{ "LT6911C", 0 },
+ *	{ "AR0234A", 0 },	// Custom HID
  */
-	{ "INTC10B1", 0 },	// HID for Lontium
+	{ "INTC10C0", 0 },	// AR0234 HID
+	{ "INTC10B1", 0 },	// Lontium HID
+	{ "INTC10C1", 0 },	// IMX390 HID
+	{ "INTC10CD", 0 },	// D457 HID
 	{},
 };
 static int ipu_acpi_get_pdata(struct i2c_client *client,
@@ -912,7 +119,9 @@ static int ipu_acpi_get_pdata(struct i2c_client *client,
 	supported_devices[index].get_platform_data(
 		client, camdata, helper,
 		supported_devices[index].priv_data,
-		supported_devices[index].priv_size);
+		supported_devices[index].priv_size,
+		supported_devices[index].connect,
+		supported_devices[index].serdes_name);
 
 	return 0;
 }
@@ -993,7 +202,7 @@ int ipu_get_acpi_devices(void *driver_data,
 
 	if (!built_in_pdata) {
 		dev_dbg(dev, "Return ACPI generated pdata");
-		*spdata = &acpi_subdev_pdata;
+		*spdata = get_acpi_subdev_pdata();
 	} else
 		dev_dbg(dev, "Return updated built-in pdata");
 
@@ -1016,5 +225,5 @@ module_exit(ipu_acpi_exit);
 
 MODULE_AUTHOR("Samu Onkalo <samu.onkalo@intel.com>");
 MODULE_LICENSE("GPL");
-MODULE_DESCRIPTION("IPU4 ACPI support");
+MODULE_DESCRIPTION("IPU6 ACPI support");
 
diff --git a/drivers/media/platform/intel/ipu6-adlrvp-pdata.c b/drivers/media/platform/intel/ipu6-adlrvp-pdata.c
index 334ee2a622dd..61c1fe4a17f7 100644
--- a/drivers/media/platform/intel/ipu6-adlrvp-pdata.c
+++ b/drivers/media/platform/intel/ipu6-adlrvp-pdata.c
@@ -11,9 +11,12 @@
 #include <media/ar0234.h>
 #include <media/imx390.h>
 #include <media/lt6911uxc.h>
+#include <media/d4xx.h>
 
 #include "ipu.h"
 
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA) \
+	&& IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_PDATA_DYNAMIC_LOADING)
 static void ar0234_fixup_spdata(const void *spdata_rep, void *spdata)
 {
 	const struct ipu_spdata_rep *rep = spdata_rep;
@@ -48,6 +51,8 @@ static void lt6911uxc_fixup_spdata(const void *spdata_rep, void *spdata)
 	}
 }
 
+#endif
+
 #define AR0234_LANES       2
 #define AR0234_I2C_ADDRESS 0x10
 
@@ -77,7 +82,10 @@ static struct ipu_isys_subdev_info ar0234_sd_1 = {
 	},
 	.i2c_adapter_bdf = "0000:00:15.1",
 	},
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA) \
+	&& IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_PDATA_DYNAMIC_LOADING)
 	.fixup_spdata = ar0234_fixup_spdata,
+#endif
 };
 
 static struct ipu_isys_csi2_config ar0234_csi2_cfg_2 = {
@@ -106,7 +114,10 @@ static struct ipu_isys_subdev_info ar0234_sd_2 = {
 	},
 	.i2c_adapter_bdf = "0000:00:19.1",
 	},
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA) \
+	&& IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_PDATA_DYNAMIC_LOADING)
 	.fixup_spdata = ar0234_fixup_spdata,
+#endif
 };
 
 #if IS_ENABLED(CONFIG_VIDEO_IMX390)
@@ -377,13 +388,13 @@ static struct lt6911uxc_platform_data lt6911uxc_pdata_1 = {
 	.port = 1,
 	.lanes = LT6911UXC_LANES,
 	.i2c_slave_address = LT6911UXC_I2C_ADDRESS,
-	.irq_pin = 749,
+	.irq_pin = -1,
 	.irq_pin_name = "READY_STAT",
 	.irq_pin_flags = IRQF_TRIGGER_RISING
 		| IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
 	.suffix = 'a',
-	.reset_pin = 957,
-	.detect_pin = 687,
+	.reset_pin = -1,
+	.detect_pin = -1,
 	.gpios = {-1, 0, 0, 0},
 };
 
@@ -396,7 +407,10 @@ static struct ipu_isys_subdev_info  lt6911uxc_sd_1 = {
 	},
 	.i2c_adapter_bdf = "0000:00:15.1",
 	},
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA) \
+	&& IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_PDATA_DYNAMIC_LOADING)
 	.fixup_spdata = lt6911uxc_fixup_spdata,
+#endif
 };
 
 static struct ipu_isys_csi2_config lt6911uxc_csi2_cfg_2 = {
@@ -408,13 +422,13 @@ static struct lt6911uxc_platform_data lt6911uxc_pdata_2 = {
 	.port = 2,
 	.lanes = LT6911UXC_LANES,
 	.i2c_slave_address = LT6911UXC_I2C_ADDRESS,
-	.irq_pin = 956,
+	.irq_pin = -1,
 	.irq_pin_name = "READY_STAT",
 	.irq_pin_flags = IRQF_TRIGGER_RISING
 		| IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
 	.suffix = 'b',
-	.reset_pin = 999,
-	.detect_pin = 1000,
+	.reset_pin = -1,
+	.detect_pin = -1,
 	.gpios = {-1, 0, 0, 0},
 };
 
@@ -427,8 +441,103 @@ static struct ipu_isys_subdev_info lt6911uxc_sd_2 = {
 	},
 	.i2c_adapter_bdf = "0000:00:19.1",
 	},
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA) \
+	&& IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_PDATA_DYNAMIC_LOADING)
 	.fixup_spdata = lt6911uxc_fixup_spdata,
+#endif
+};
+
+#if IS_ENABLED(CONFIG_VIDEO_D4XX)
+#define D4XX_LANES       2
+#define D4XX_I2C_ADDRESS_0 0x10
+#define D4XX_I2C_ADDRESS_1 0x12
+#define D4XX_I2C_ADDRESS_2 0x14
+#define D4XX_PORT0      0
+#define D4XX_PORT1      1
+#define D4XX_PORT2      2
+#define D4XX_PORT3      3
+
+static struct ipu_isys_csi2_config d4xx_csi2_cfg_0 = {
+	.nlanes = D4XX_LANES,
+	.port = D4XX_PORT0,
+};
+
+static struct d4xx_pdata d4xx_pdata_0 = {
+	.suffix = 'a',
+};
+
+static struct ipu_isys_subdev_info d4xx_sd_0 = {
+	.csi2 = &d4xx_csi2_cfg_0,
+	.i2c = {
+		.board_info = {
+			I2C_BOARD_INFO("d4xx", D4XX_I2C_ADDRESS_1),
+			.platform_data = &d4xx_pdata_0,
+		},
+		.i2c_adapter_bdf = "0000:00:15.1",
+	},
+};
+
+static struct ipu_isys_csi2_config d4xx_csi2_cfg_1 = {
+	.nlanes = D4XX_LANES,
+	.port = D4XX_PORT1,
+};
+
+static struct d4xx_pdata d4xx_pdata_1 = {
+	.suffix = 'b',
+};
+
+static struct ipu_isys_subdev_info d4xx_sd_1 = {
+	.csi2 = &d4xx_csi2_cfg_1,
+	.i2c = {
+	.board_info = {
+		I2C_BOARD_INFO("d4xx", D4XX_I2C_ADDRESS_2),
+		.platform_data = &d4xx_pdata_1,
+	},
+	.i2c_adapter_bdf = "0000:00:15.1",
+	},
+};
+
+static struct ipu_isys_csi2_config d4xx_csi2_cfg_2 = {
+	.nlanes = D4XX_LANES,
+	.port = D4XX_PORT2,
+};
+
+static struct d4xx_pdata d4xx_pdata_2 = {
+	.suffix = 'c',
 };
+
+static struct ipu_isys_subdev_info d4xx_sd_2 = {
+	.csi2 = &d4xx_csi2_cfg_2,
+	.i2c = {
+		.board_info = {
+			I2C_BOARD_INFO("d4xx", D4XX_I2C_ADDRESS_1),
+			.platform_data = &d4xx_pdata_2,
+		},
+		.i2c_adapter_bdf = "0000:00:19.1",
+	},
+};
+
+static struct ipu_isys_csi2_config d4xx_csi2_cfg_3 = {
+	.nlanes = D4XX_LANES,
+	.port = D4XX_PORT3,
+};
+
+static struct d4xx_pdata d4xx_pdata_3 = {
+	.suffix = 'd',
+};
+
+static struct ipu_isys_subdev_info d4xx_sd_3 = {
+	.csi2 = &d4xx_csi2_cfg_3,
+	.i2c = {
+	.board_info = {
+		I2C_BOARD_INFO("d4xx", D4XX_I2C_ADDRESS_2),
+	.platform_data = &d4xx_pdata_3,
+	},
+	.i2c_adapter_bdf = "0000:00:19.1",
+	},
+};
+#endif
+
 static struct ipu_isys_clk_mapping clk_mapping[] = {
 	{ CLKDEV_INIT(NULL, NULL, NULL), NULL }
 };
@@ -443,6 +552,12 @@ static struct ipu_isys_subdev_pdata pdata = {
 #endif
 		&lt6911uxc_sd_1,
 		&lt6911uxc_sd_2,
+#if IS_ENABLED(CONFIG_VIDEO_D4XX)
+		&d4xx_sd_0,
+		&d4xx_sd_1,
+		&d4xx_sd_2,
+		&d4xx_sd_3,
+#endif
 		NULL,
 	},
 	.clk_map = clk_mapping,
@@ -456,3 +571,6 @@ static void ipu6_quirk(struct pci_dev *pci_dev)
 
 DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, IPU6EP_ADL_P_PCI_ID, ipu6_quirk);
 DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, IPU6EP_ADL_N_PCI_ID, ipu6_quirk);
+DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, IPU6EP_RPL_P_PCI_ID, ipu6_quirk);
+
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/platform/intel/ipu6-tglrvp-pdata.c b/drivers/media/platform/intel/ipu6-tglrvp-pdata.c
index 0ab3ccf17487..9b8154d8220a 100644
--- a/drivers/media/platform/intel/ipu6-tglrvp-pdata.c
+++ b/drivers/media/platform/intel/ipu6-tglrvp-pdata.c
@@ -15,6 +15,57 @@
 
 #include "ipu.h"
 
+#if defined(CONFIG_VIDEO_OV8856)
+#define OV8856_LANES       4
+#define OV8856_I2C_ADDRESS 0x10
+#define DW9714_I2C_ADDRESS 0xc
+
+static struct ipu_isys_csi2_config ov8856_csi2_cfg_1 = {
+	.nlanes = OV8856_LANES,
+	.port = 1,
+};
+
+static struct ipu_isys_csi2_config ov8856_csi2_cfg_2 = {
+	.nlanes = OV8856_LANES,
+	.port = 2,
+};
+
+static struct ipu_isys_subdev_info ov8856_sd_1 = {
+	.csi2 = &ov8856_csi2_cfg_1,
+	.i2c = {
+	.board_info = {
+		I2C_BOARD_INFO("ov8856", OV8856_I2C_ADDRESS),
+	},
+	.i2c_adapter_id = 13,
+	.i2c_adapter_bdf = "0000:00:15.3",
+	}
+};
+
+static struct ipu_isys_subdev_info dw9714_sd_1 = {
+	.i2c = {
+		.board_info = {
+			I2C_BOARD_INFO("dw9714", DW9714_I2C_ADDRESS),
+		},
+		.i2c_adapter_id = 13,
+		.i2c_adapter_bdf = "0000:00:15.3",
+	}
+};
+
+static struct ipu_isys_subdev_info ov8856_sd_2 = {
+	.csi2 = &ov8856_csi2_cfg_2,
+	.i2c = {
+	.board_info = {
+		I2C_BOARD_INFO("ov8856", OV8856_I2C_ADDRESS),
+	},
+	.i2c_adapter_id = 15,
+	.i2c_adapter_bdf = "0000:00:19.1",
+	}
+};
+
+#endif
+
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA) \
+	&& IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_PDATA_DYNAMIC_LOADING)
 static void ar0234_fixup_spdata(const void *spdata_rep, void *spdata)
 {
 	const struct ipu_spdata_rep *rep = spdata_rep;
@@ -31,6 +82,7 @@ static void ar0234_fixup_spdata(const void *spdata_rep, void *spdata)
 		platform->suffix = rep->suffix;
 	}
 }
+#endif
 
 #define AR0234_LANES       2
 #define AR0234_I2C_ADDRESS 0x10
@@ -62,7 +114,10 @@ static struct ipu_isys_subdev_info ar0234_sd_1 = {
 	},
 	.i2c_adapter_bdf = "0000:00:15.3",
 	},
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA) \
+	&& IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_PDATA_DYNAMIC_LOADING)
 	.fixup_spdata = ar0234_fixup_spdata,
+#endif
 };
 
 static struct ipu_isys_csi2_config ar0234_csi2_cfg_2 = {
@@ -91,7 +146,10 @@ static struct ipu_isys_subdev_info ar0234_sd_2 = {
 	},
 	.i2c_adapter_bdf = "0000:00:19.1",
 	},
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA) \
+	&& IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_PDATA_DYNAMIC_LOADING)
 	.fixup_spdata = ar0234_fixup_spdata,
+#endif
 };
 
 #if !IS_ENABLED(CONFIG_VIDEO_LT6911UXC)
@@ -121,7 +179,10 @@ static struct ipu_isys_subdev_info ar0234_sd_3 = {
 	},
 	.i2c_adapter_bdf = "0000:00:15.2",
 	},
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA) \
+	&& IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_PDATA_DYNAMIC_LOADING)
 	.fixup_spdata = ar0234_fixup_spdata,
+#endif
 };
 #endif
 
@@ -151,7 +212,9 @@ static struct ipu_isys_subdev_info ar0234_sd_4 = {
 	},
 	.i2c_adapter_bdf = "0000:00:15.2",
 	},
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA)
 	.fixup_spdata = ar0234_fixup_spdata,
+#endif
 };
 
 #if IS_ENABLED(CONFIG_VIDEO_IMX390)
@@ -472,13 +535,13 @@ static struct lt6911uxc_platform_data lt6911uxc_pdata_1 = {
 	.port = 1,
 	.lanes = LT6911UXC_LANES,
 	.i2c_slave_address = LT6911UXC_I2C_ADDRESS,
-	.irq_pin = 410,
+	.irq_pin = -1,
 	.irq_pin_name = "C2",
 	.irq_pin_flags = IRQF_TRIGGER_RISING
 		| IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
 	.suffix = 'a',
-	.reset_pin = 423,
-	.detect_pin = 175,
+	.reset_pin = -1,
+	.detect_pin = -1,
 };
 
 static struct ipu_isys_subdev_info  lt6911uxc_sd_1 = {
@@ -501,13 +564,13 @@ static struct lt6911uxc_platform_data lt6911uxc_pdata_2 = {
 	.port = 2,
 	.lanes = LT6911UXC_LANES,
 	.i2c_slave_address = LT6911UXC_I2C_ADDRESS,
-	.irq_pin = 170,
+	.irq_pin = -1,
 	.irq_pin_name = "B18",
 	.irq_pin_flags = IRQF_TRIGGER_RISING
 		| IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
 	.suffix = 'b',
-	.reset_pin = 292,
-	.detect_pin = 510,
+	.reset_pin = -1,
+	.detect_pin = -1,
 };
 
 static struct ipu_isys_subdev_info lt6911uxc_sd_2 = {
@@ -527,6 +590,11 @@ static struct ipu_isys_clk_mapping clk_mapping[] = {
 
 static struct ipu_isys_subdev_pdata pdata = {
 	.subdevs = (struct ipu_isys_subdev_info *[]) {
+#if defined(CONFIG_VIDEO_OV8856)
+		&ov8856_sd_1,
+		&dw9714_sd_1,
+		&ov8856_sd_2,
+#endif
 		&ar0234_sd_1,
 		&ar0234_sd_2,
 #if !IS_ENABLED(CONFIG_VIDEO_LT6911UXC)
@@ -556,3 +624,5 @@ static void ipu6_quirk(struct pci_dev *pci_dev)
 	pci_dev->dev.platform_data = &pdata;
 }
 DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, IPU6_PCI_ID, ipu6_quirk);
+
+MODULE_LICENSE("GPL");
diff --git a/include/media/ar0234.h b/include/media/ar0234.h
index 3c1b59fb9765..c8a8c95d4380 100644
--- a/include/media/ar0234.h
+++ b/include/media/ar0234.h
@@ -15,6 +15,8 @@ struct ar0234_platform_data {
 	int irq_pin;
 	unsigned int irq_pin_flags;
 	char irq_pin_name[16];
+	int reset_pin;
+	int detect_pin;
 	char suffix;
 	int gpios[4];
 };
diff --git a/include/media/d4xx.h b/include/media/d4xx.h
new file mode 100644
index 000000000000..7e285588586f
--- /dev/null
+++ b/include/media/d4xx.h
@@ -0,0 +1,23 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2022 Intel Corporation */
+
+#ifndef D457_H
+#define D457_H
+
+#define D457_NAME "d4xx"
+#define MAX9296_NAME "MAX9296"
+
+struct d4xx_pdata {
+	unsigned int port;
+	unsigned int lanes;
+	uint32_t i2c_slave_address;
+	int irq_pin;
+	unsigned int irq_pin_flags;
+	char irq_pin_name[16];
+	int reset_pin;
+	int detect_pin;
+	char suffix;
+	int gpios[4];
+};
+
+#endif
diff --git a/include/media/imx390.h b/include/media/imx390.h
index ebac4036e041..bc0fa1c0393d 100644
--- a/include/media/imx390.h
+++ b/include/media/imx390.h
@@ -6,6 +6,8 @@
 
 #include <linux/types.h>
 
+#define IMX390_NAME "imx390"
+
 struct imx390_platform_data {
 	unsigned int port;
 	unsigned int lanes;
diff --git a/include/media/ipu-acpi-pdata.h b/include/media/ipu-acpi-pdata.h
new file mode 100644
index 000000000000..3aa9beaadb24
--- /dev/null
+++ b/include/media/ipu-acpi-pdata.h
@@ -0,0 +1,76 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2022 Intel Corporation */
+#include <linux/interrupt.h>
+#include <media/ipu-acpi.h>
+#include <media/ar0234.h>
+#include <media/lt6911uxc.h>
+#include <media/ti960.h>
+#include <media/imx390.h>
+#include <media/d4xx.h>
+
+#define DUMMY_SERDES_BASE_ADDR 0x40
+#define CL_EMPTY 0
+#define CL_DISCRETE 1
+#define SERDES_MAX_PORT 4
+#define SERDES_MAX_GPIO_POWERUP_SEQ 4
+#define LOOP_SIZE 10
+
+int get_sensor_pdata(struct i2c_client *client,
+			struct ipu_camera_module_data *data,
+			struct ipu_i2c_helper *helper,
+			void *priv, size_t size,
+			enum connection_type connect,
+			const char *serdes_name);
+
+struct ipu_isys_subdev_pdata *get_acpi_subdev_pdata(void);
+
+struct sensor_platform_data {
+	unsigned int port;
+	unsigned int lanes;
+	uint32_t i2c_slave_address;
+	int irq_pin;
+	unsigned int irq_pin_flags;
+	char irq_pin_name[IPU_SPLATA_IRQ_PIN_NAME_LEN];
+	int reset_pin;
+	int detect_pin;
+	char suffix;
+	int gpios[IPU_SPLATA_GPIO_NUM];
+};
+
+struct serdes_platform_data {
+	unsigned int subdev_num;
+	struct serdes_subdev_info *subdev_info;
+	unsigned int reset_gpio;
+	unsigned int FPD_gpio;
+	char suffix;
+};
+
+struct serdes_subdev_info {
+	struct i2c_board_info board_info;
+	int i2c_adapter_id;
+	unsigned short rx_port;
+	unsigned short phy_i2c_addr;
+	unsigned short ser_alias;
+	char suffix; /* suffix for subdevs */
+};
+
+struct serdes_module_pdata {
+	unsigned short i2c_addr;
+	unsigned short i2c_adapter;
+	unsigned int lanes;
+	int xshutdown;
+	int fsin;
+	int reset;
+	char gpio_powerup_seq[SERDES_MAX_GPIO_POWERUP_SEQ];
+	unsigned int module_flags;
+	char module_name[I2C_NAME_SIZE];
+	char suffix;
+};
+
+struct serdes_local {
+	unsigned int rx_port;
+	unsigned short sensor_addr;
+	unsigned int gpio_powerup_seq;
+	unsigned int module_flags;
+	unsigned int sensor_num;
+};
diff --git a/include/media/ipu-acpi.h b/include/media/ipu-acpi.h
index adae58a73870..622b13215fdd 100644
--- a/include/media/ipu-acpi.h
+++ b/include/media/ipu-acpi.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright (c) 2016--2017 Intel Corporation.
+ * Copyright (c) 2016--2022 Intel Corporation.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License version
@@ -23,6 +23,23 @@
 #define MAX_ACPI_I2C_NUM	12
 #define MAX_ACPI_GPIO_NUM	12
 
+#define GPIO_RESET		0x0
+#define GPIO_POWER_EN		0xb
+#define GPIO_READY_STAT		0x13
+#define GPIO_HDMI_DETECT	0x14
+
+struct ipu_isys_subdev_pdata *ptr_built_in_pdata;
+
+struct ipu_isys_subdev_pdata *get_built_in_pdata(void)
+{
+	return ptr_built_in_pdata;
+};
+
+enum connection_type {
+	TYPE_DIRECT,
+	TYPE_SERDES
+};
+
 /* Data representation as it is in ACPI SSDB buffer */
 struct sensor_bios_data_packed {
 	u8 version;
@@ -79,7 +96,9 @@ struct sensor_bios_data {
 	u16 xshutdown;
 	u8 controllogicid;
 	u8 pprval;
+	u8 pprunit;
 	struct ipu_i2c_info i2c[MAX_ACPI_I2C_NUM];
+	u64 i2c_num;
 };
 
 struct control_logic_data_packed {
@@ -133,7 +152,16 @@ int ipu_get_acpi_devices(void *driver_data,
 				 struct ipu_isys_csi2_config *csi2,
 				 bool reprobe));
 
-struct ipu_isys_subdev_pdata get_acpi_adata(void);
+struct ipu_isys_subdev_pdata *get_built_in_pdata(void);
+
+int ipu_acpi_get_cam_data(struct device *dev,
+				struct sensor_bios_data *sensor);
+
+int ipu_acpi_get_dep_data(struct device *dev,
+				struct control_logic_data *ctl_data);
+
+int ipu_acpi_get_control_logic_data(struct device *dev,
+				struct control_logic_data **ctl_data);
 
 struct intel_ipu6_regulator {
 	char *src_dev_name;
@@ -141,8 +169,42 @@ struct intel_ipu6_regulator {
 	char *dest_rail;
 };
 
-#define GPIO_RESET             0x0
-#define GPIO_READY_STAT        0x13
-#define GPIO_HDMI_DETECT       0x14
+struct ipu_i2c_helper {
+	int (*fn)(struct device *dev, void *priv,
+		struct ipu_isys_csi2_config *csi2,
+		bool reprobe);
+	void *driver_data;
+};
+
+struct ipu_i2c_new_dev {
+	struct list_head list;
+	struct i2c_board_info info;
+	unsigned short int bus;
+};
+
+struct ipu_camera_module_data {
+	struct list_head list;
+	struct ipu_isys_subdev_info sd;
+	struct ipu_isys_csi2_config csi2;
+	unsigned int ext_clk;
+	void *pdata; /* Ptr to generated platform data*/
+	void *priv; /* Private for specific subdevice */
+};
+
+struct ipu_acpi_devices {
+	const char *hid_name;
+	const char *real_driver;
+	int (*get_platform_data)(struct i2c_client *client,
+				 struct ipu_camera_module_data *data,
+				 struct ipu_i2c_helper *helper,
+				 void *priv,
+				 size_t size,
+				 enum connection_type type,
+				 const char *serdes_name);
+	void *priv_data;
+	size_t priv_size;
+	enum connection_type connect;
+	const char *serdes_name;
+};
 
 #endif
diff --git a/include/media/ipu-isys.h b/include/media/ipu-isys.h
index a9201ab0c104..f87bb25e0f93 100644
--- a/include/media/ipu-isys.h
+++ b/include/media/ipu-isys.h
@@ -21,6 +21,8 @@ struct ipu_isys_subdev_i2c_info {
 	char i2c_adapter_bdf[32];
 };
 
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA) \
+	&& IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_PDATA_DYNAMIC_LOADING)
 /**
  * struct ipu_spdata_rep - override subdev platform data
  *
@@ -57,12 +59,18 @@ struct ipu_spdata_rep {
 	char irq_pin_name[IPU_SPLATA_IRQ_PIN_NAME_LEN];
 	char suffix;
 };
+#endif
 
 struct ipu_isys_subdev_info {
 	struct ipu_isys_csi2_config *csi2;
 	struct ipu_isys_subdev_i2c_info i2c;
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA) \
+	&& IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_PDATA_DYNAMIC_LOADING)
 	void (*fixup_spdata)(const void *spdata_rep, void *spdata);
+#endif
+#if IS_ENABLED(CONFIG_INTEL_IPU6_ACPI)
 	char *acpi_hid;
+#endif
 };
 
 struct ipu_isys_clk_mapping {
diff --git a/include/uapi/linux/ipu-isys.h b/include/uapi/linux/ipu-isys.h
index 4709d66393c0..f5bb12c16991 100644
--- a/include/uapi/linux/ipu-isys.h
+++ b/include/uapi/linux/ipu-isys.h
@@ -7,11 +7,10 @@
 #define V4L2_CID_IPU_BASE	(V4L2_CID_USER_BASE + 0x1080)
 
 #define V4L2_CID_IPU_STORE_CSI2_HEADER	(V4L2_CID_IPU_BASE + 2)
-#if defined(IPU_ISYS_COMPRESSION)
 #define V4L2_CID_IPU_ISYS_COMPRESSION	(V4L2_CID_IPU_BASE + 3)
-#endif
 
-#define V4L2_FMT_IPU_ISYS_META	v4l2_fourcc('i', 'p', '4', 'm')
+#define V4L2_CID_IPU_QUERY_SUB_STREAM	(V4L2_CID_IPU_BASE + 4)
+#define V4L2_CID_IPU_SET_SUB_STREAM	(V4L2_CID_IPU_BASE + 5)
 
 #define VIDIOC_IPU_GET_DRIVER_VERSION \
 	_IOWR('v', BASE_VIDIOC_PRIVATE + 3, uint32_t)
-- 
2.25.1

