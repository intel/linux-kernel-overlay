From ad577ccb212706e5241847e5fc9eda928d15e9d8 Mon Sep 17 00:00:00 2001
From: Lay Kuan Loon <kuan.loon.lay@intel.com>
Date: Wed, 20 Oct 2021 10:19:54 +0800
Subject: [PATCH 17/54] net: networkproxy: introduce network proxy framework

Network proxy maintains network presence while Host is in low-power
mode. Host is woke-up when there is print job or other packet of
interest not handled by Network Proxy agent.

This technology is described in ECMA-393 proxZzzy. It requires two
devices to be registered to the Network Proxy framework: IPC Device
and Network Device.

Signed-off-by: Ong Boon Leong <boon.leong.ong@intel.com>
Signed-off-by: Lay Kuan Loon <kuan.loon.lay@intel.com>
Signed-off-by: Song Yoong Siang <yoong.siang.song@intel.com>
Signed-off-by: Noor Azura Ahmad Tarmizi <noor.azura.ahmad.tarmizi@intel.com>
---
 MAINTAINERS                              |   8 ++
 drivers/net/Kconfig                      |   1 +
 drivers/net/Makefile                     |   1 +
 drivers/net/networkproxy/Kconfig         |  10 ++
 drivers/net/networkproxy/Makefile        |   3 +
 drivers/net/networkproxy/network_proxy.c | 162 +++++++++++++++++++++++
 include/linux/network_proxy.h            |  56 ++++++++
 include/linux/network_proxy_common.h     | 126 ++++++++++++++++++
 8 files changed, 367 insertions(+)
 create mode 100644 drivers/net/networkproxy/Kconfig
 create mode 100644 drivers/net/networkproxy/Makefile
 create mode 100644 drivers/net/networkproxy/network_proxy.c
 create mode 100644 include/linux/network_proxy.h
 create mode 100644 include/linux/network_proxy_common.h

diff --git a/MAINTAINERS b/MAINTAINERS
index 3187614006ce..5405a7c91ca0 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -13329,6 +13329,14 @@ NETWORKING [WIRELESS]
 L:	linux-wireless@vger.kernel.org
 Q:	http://patchwork.kernel.org/project/linux-wireless/list/
 
+NETWORK PROXY
+M:	Ong Boon Leong <boon.leong.ong@intel.com>
+M:	Song Yoong Siang <yoong.siang.song@intel.com>
+L:	netdev@vger.kernel.org
+S:	Maintained
+F:	drivers/net/networkproxy
+F:	include/linux/network_proxy*
+
 NETXEN (1/10) GbE SUPPORT
 M:	Manish Chopra <manishc@marvell.com>
 M:	Rahul Verma <rahulv@marvell.com>
diff --git a/drivers/net/Kconfig b/drivers/net/Kconfig
index 44a7d36446c5..10653f1269ae 100644
--- a/drivers/net/Kconfig
+++ b/drivers/net/Kconfig
@@ -577,6 +577,7 @@ config USB4_NET
 	  called thunderbolt-net.
 
 source "drivers/net/hyperv/Kconfig"
+source "drivers/net/networkproxy/Kconfig"
 
 config NETDEVSIM
 	tristate "Simulated networking device"
diff --git a/drivers/net/Makefile b/drivers/net/Makefile
index 739838623cf6..44c90a198ab2 100644
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -87,3 +87,4 @@ thunderbolt-net-y += thunderbolt.o
 obj-$(CONFIG_USB4_NET) += thunderbolt-net.o
 obj-$(CONFIG_NETDEVSIM) += netdevsim/
 obj-$(CONFIG_NET_FAILOVER) += net_failover.o
+obj-$(CONFIG_NETWORK_PROXY) += networkproxy/
diff --git a/drivers/net/networkproxy/Kconfig b/drivers/net/networkproxy/Kconfig
new file mode 100644
index 000000000000..8b09f2c66c56
--- /dev/null
+++ b/drivers/net/networkproxy/Kconfig
@@ -0,0 +1,10 @@
+config NETWORK_PROXY
+	tristate "Network Proxy"
+	depends on CONFIGFS_FS && INTEL_ISH_HID
+	help
+	  Network proxy maintains network presence while Host is in
+	  low-power mode. Host is woke-up when there is print job or
+	  other packet of interest not handled by Network Proxy agent.
+	  This technology is described in ECMA-393 proxZzzy.
+	  It requires 2 devices to be registered to the Network Proxy
+	  framework: IPC Device and Network Device.
diff --git a/drivers/net/networkproxy/Makefile b/drivers/net/networkproxy/Makefile
new file mode 100644
index 000000000000..07bfc36af4a8
--- /dev/null
+++ b/drivers/net/networkproxy/Makefile
@@ -0,0 +1,3 @@
+obj-$(CONFIG_NETWORK_PROXY) = network_proxy.o
+
+CFLAGS_np_ishtp_client.o += -I$(srctree)/drivers/hid/intel-ish-hid
diff --git a/drivers/net/networkproxy/network_proxy.c b/drivers/net/networkproxy/network_proxy.c
new file mode 100644
index 000000000000..4bdeaad1b559
--- /dev/null
+++ b/drivers/net/networkproxy/network_proxy.c
@@ -0,0 +1,162 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Copyright (c) 2022, Intel Corporation. */
+
+#include <linux/module.h>
+#include <linux/network_proxy.h>
+#include <linux/slab.h>
+
+static struct np_context *np_ctx;
+
+int netprox_send_ipc_msg(int cmd, const char *msg, int size)
+{
+	struct np_ipc_msg ipc_msg = { {0} };
+	struct np_ipcdev *ipcd = np_ctx->np_ipcdev;
+	struct np_netdev *nd = np_ctx->np_netdev;
+
+	ipc_msg.ipc_hdr.command = cmd;
+
+	if (size >= NP_IPC_PYLD_MAX) {
+		pr_err("netprox send msg over size: %d\n", size);
+		return -ENOMEM;
+	}
+
+	if (ipcd && nd) {
+		if (msg && size) {
+			memcpy(ipc_msg.ipc_pyld, msg, size);
+			ipc_msg.ipc_hdr.size = size;
+		}
+
+		ipcd->ipc_send(np_ctx->np_ipcdev->ipc_cl, (void *)&ipc_msg,
+			       ipc_msg.ipc_hdr.size + sizeof(struct np_ipc_hdr),
+			       false);
+	} else {
+		pr_err("Netprox send IPC message failure: incomplete device registration.\n");
+		return -ENODEV;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(netprox_send_ipc_msg);
+
+int netprox_agent_is_ready(void)
+{
+	if (!np_ctx->np_ipcdev || !np_ctx->np_netdev)
+		return 0;
+
+	return (np_ctx->agent_state == NP_AGENT_READY);
+}
+EXPORT_SYMBOL(netprox_agent_is_ready);
+
+int netprox_host_proxy_enter(void)
+{
+	if (np_ctx->agent_state != NP_AGENT_READY) {
+		pr_err("Network Proxy Agent is not ready.\n");
+		return -EPERM;
+	} else if (np_ctx->host_state == NP_HOST_PROXY_ENTER) {
+		pr_err("Network Proxy Host is in proxy mode.\n");
+		return -EPERM;
+	}
+
+	np_ctx->host_state = NP_HOST_PROXY_ENTER;
+
+	return 0;
+}
+EXPORT_SYMBOL(netprox_host_proxy_enter);
+
+int netprox_host_proxy_exit(void)
+{
+	if (np_ctx->host_state != NP_HOST_PROXY_ENTER) {
+		pr_err("Host is not in proxy mode.\n");
+		return -EPERM;
+	}
+
+	return netprox_send_ipc_msg(NP_H2A_CMD_PROXY_EXIT, NULL, 0);
+}
+EXPORT_SYMBOL(netprox_host_proxy_exit);
+
+int netprox_ipc_recv(int cmd, unsigned char *payload, int size)
+{
+	struct net_device *netdev = np_ctx->np_netdev->netdev;
+
+	/* Process IPC message from Network Proxy Agent */
+	switch (cmd) {
+	case NP_A2H_CMD_AGENT_READY:
+		np_ctx->agent_state = NP_AGENT_READY;
+		np_ctx->np_netdev->proxy_wakeup_enable(netdev, 1);
+		break;
+	case NP_A2H_CMD_HOST_IS_AWAKE:
+		/* Ethernet driver's resume function will eventually
+		 * call into netprox_host_proxy_exit() function. Thus,
+		 * do nothing here.
+		 */
+		break;
+	case NP_A2H_CMD_HOST_IS_EXITED:
+		np_ctx->host_state = NP_HOST_PROXY_EXIT;
+		break;
+	default:
+		pr_err("%s unknown command %d\n", __func__, cmd);
+		break;
+	};
+	return 0;
+}
+EXPORT_SYMBOL(netprox_ipc_recv);
+
+int netprox_register_ipcdev(struct np_ipcdev *np_ipcdev)
+{
+	np_ctx->np_ipcdev = np_ipcdev;
+
+	return 0;
+}
+EXPORT_SYMBOL(netprox_register_ipcdev);
+
+int netprox_deregister_ipcdev(struct np_ipcdev *np_ipcdev)
+{
+	np_ctx->np_ipcdev = NULL;
+
+	return 0;
+}
+EXPORT_SYMBOL(netprox_deregister_ipcdev);
+
+int netprox_register_netdev(struct np_netdev *np_netdev,
+			    void *config, int size)
+{
+	np_ctx->np_netdev = np_netdev;
+
+	return netprox_send_ipc_msg(NP_H2A_CMD_NETDEV_READY, config, size);
+}
+EXPORT_SYMBOL(netprox_register_netdev);
+
+int netprox_deregister_netdev(struct np_netdev *np_netdev)
+{
+	np_ctx->np_netdev = NULL;
+
+	return 0;
+}
+EXPORT_SYMBOL(netprox_deregister_netdev);
+
+static int __init network_proxy_init(void)
+{
+	np_ctx = kzalloc(sizeof(*np_ctx), GFP_KERNEL);
+	if (!np_ctx)
+		return -ENOMEM;
+
+	np_ctx->host_state = NP_HOST_PROXY_EXIT;
+	np_ctx->agent_state = NP_AGENT_UNKNOWN;
+
+	return 0;
+}
+
+static void __exit network_proxy_deinit(void)
+{
+	kfree(np_ctx);
+}
+
+module_init(network_proxy_init);
+module_exit(network_proxy_deinit);
+
+MODULE_DESCRIPTION("Network Proxy");
+MODULE_AUTHOR("Song Yoong Siang <yoong.siang.song@intel.com>");
+MODULE_AUTHOR("Ong Boon Leong <boon.leong.ong@intel.com>");
+
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("networkproxy:*");
diff --git a/include/linux/network_proxy.h b/include/linux/network_proxy.h
new file mode 100644
index 000000000000..4536d76b9b1e
--- /dev/null
+++ b/include/linux/network_proxy.h
@@ -0,0 +1,56 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (c) 2022, Intel Corporation. */
+
+#ifndef __NETWORK_PROXY_H__
+#define __NETWORK_PROXY_H__
+
+#include <linux/errno.h>
+#include <linux/network_proxy_common.h>
+#include <linux/printk.h>
+#include <linux/types.h>
+
+/* Network Proxy Host States */
+enum np_host_state {
+	NP_HOST_PROXY_EXIT = 0,
+	NP_HOST_PROXY_ENTER,
+};
+
+/* Network Proxy Agent States */
+enum np_agent_state {
+	NP_AGENT_UNKNOWN = 0,
+	NP_AGENT_READY,
+};
+
+/* IPC Device for Network Proxy Agent */
+struct np_ipcdev {
+	void *ipc_cl;
+	int (*ipc_send)(void *ipc_cl, void *msg, int size, bool async);
+};
+
+/* Network Device for Network Proxy Agent */
+struct np_netdev {
+	struct net_device *netdev;
+	int (*proxy_enter)(struct net_device *netdev);
+	void (*proxy_wakeup_enable)(struct net_device *netdev, bool enable);
+};
+
+/* Network Proxy Context */
+struct np_context {
+	enum np_host_state host_state;
+	enum np_agent_state agent_state;
+	struct np_ipcdev *np_ipcdev;
+	struct np_netdev *np_netdev;
+};
+
+int netprox_agent_is_ready(void);
+int netprox_host_proxy_enter(void);
+int netprox_host_proxy_exit(void);
+int netprox_send_ipc_msg(int cmd, const char *msg, int size);
+int netprox_ipc_recv(int cmd, unsigned char *payload, int size);
+int netprox_register_ipcdev(struct np_ipcdev *np_ipcdev);
+int netprox_deregister_ipcdev(struct np_ipcdev *np_ipcdev);
+int netprox_register_netdev(struct np_netdev *np_netdev, void *config,
+			    int size);
+int netprox_deregister_netdev(struct np_netdev *np_netdev);
+
+#endif /* __NETWORK_PROXY_H__ */
diff --git a/include/linux/network_proxy_common.h b/include/linux/network_proxy_common.h
new file mode 100644
index 000000000000..ab4345a31e18
--- /dev/null
+++ b/include/linux/network_proxy_common.h
@@ -0,0 +1,126 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (c) 2022, Intel Corporation. */
+
+#ifndef __NETWORK_PROXY_COMMON_H__
+#define __NETWORK_PROXY_COMMON_H__
+
+#define NP_CMD_MASK			0x7F
+#define NP_IS_RESPONSE			0x80
+
+/* IPC Message and Payload Size Limit */
+#define NP_IPC_MSG_MAX		256
+#define NP_IPC_PYLD_MAX		(NP_IPC_MSG_MAX - sizeof(struct np_ipc_hdr))
+
+/* Network Proxy Agent to Host Packet Size Limit */
+#define NP_A2H_PKT_MAX			512
+
+#define NP_MAC_ADDR_BYTES		6
+#define NP_IPV4_ADDR_BYTES		4
+#define NP_IPV6_ADDR_ARRAY		10
+#define NP_IPV6_ADDR_BYTES		16
+#define NP_TCP_PORT_ARRAY		16
+
+/* Network Proxy IPC Message Header */
+struct np_ipc_hdr {
+	unsigned char command; /* Bit 7 : is_response */
+	unsigned char status;
+	unsigned short size;
+};
+
+/* Network Proxy IPC Message */
+struct np_ipc_msg {
+	struct np_ipc_hdr ipc_hdr;
+	char ipc_pyld[NP_IPC_PYLD_MAX];
+};
+
+/* MIB for Network Proxy Agent */
+struct np_mib {
+	unsigned char mac_addr[NP_MAC_ADDR_BYTES];
+	unsigned char ipv4_addr[NP_IPV4_ADDR_BYTES];
+	unsigned char ipv6_addr[NP_IPV6_ADDR_ARRAY][NP_IPV6_ADDR_BYTES];
+	unsigned short tcp_port[NP_TCP_PORT_ARRAY];
+	unsigned int ipv6_addr_sz;
+	unsigned int tcp_port_sz;
+};
+
+/* Commands from Network Proxy Host to Agent */
+enum np_h2a_cmd {
+	/* Network Device for Network Proxy is ready */
+	NP_H2A_CMD_NETDEV_READY = 1,
+	/* Enter Network Proxy Mode */
+	NP_H2A_CMD_PROXY_ENTER,
+	/* Exit Network Proxy Mode */
+	NP_H2A_CMD_PROXY_EXIT,
+	NP_H2A_CMD_MAX,
+};
+
+/* Commands from Network Proxy Agent to Host */
+enum np_a2h_cmd {
+	/* Network Proxy Agent is ready */
+	NP_A2H_CMD_AGENT_READY = 1,
+	/* Is Host Awake? */
+	NP_A2H_CMD_HOST_IS_AWAKE,
+	/* Network Proxy Mode Exited */
+	NP_A2H_CMD_HOST_IS_EXITED,
+	NP_A2H_CMD_MAX,
+};
+
+/* Network Proxy Agent to Host Packet Passing Memory Design.
+ *
+ * A2H Memory Pool Header Format:-
+ * ===============================
+ *         2-byte              2-byte
+ * +-------------------+--------------------+
+ * |   total_packets   |     total_size     |
+ * +-------------------+--------------------+
+ * Whereby:-
+ *    a) total_packets: Total number of A2P packets
+ *    b) total_size:    Total memory size to be passed from Agent Host
+ *                      including the 4-byte A2H Memory Pool Header and
+ *                      Total_packet * (A2H Per-packet Header Format +
+ *                      NP_A2H_PKT_MAX).
+ *
+ * When Agent passes packets to Host, the packets may be different in length.
+ * Each of a packet is kept following the below A2P Per-packet format.
+ *
+ * A2H Per-packet Format:-
+ * =======================
+ *         2-byte              2-byte
+ *  +-------------------+--------------------+
+ *  |                pkt_desc                |
+ *  +-------------------+--------------------+
+ *  |                pkt_len                 |
+ *  +-------------------+--------------------+
+ *  |                pkt_info1               |
+ *  +-------------------+--------------------+
+ *  |                pkt_info2               |
+ *  +-------------------+--------------------+
+ *  |             Packet Content             |
+ *  +-------------------+--------------------+
+ *  |             Packet Content             |
+ *  +-------------------+--------------------+
+ *  |             Packet Content             |
+ *  +-------------------+--------------------+
+ *  Whereby:-
+ *    a) pkt_desc: Packet descriptor for this packet.
+ *    b) pkt_len:  The length (in Byte) of a packet, the maximum size of
+ *                 packet content is limited by NP_A2H_PKT_MAX.
+ *    c) pkt_info: Extra information about this packet.
+ *    d) Packet content: The actual network packet to be passed from
+ *                       Network Proxy Agent to Host.
+ *                       Note: the actual length of a packet may vary but
+ *                       it is always smaller than NP_A2H_PKT_MAX
+ */
+struct np_a2h_pool_header {
+	unsigned short total_packets;
+	unsigned short total_size;
+};
+
+struct np_a2h_packet_header {
+	unsigned int pkt_desc;
+	unsigned int pkt_len;
+	unsigned int pkt_info1;
+	unsigned int pkt_info2;
+};
+
+#endif /* __NETWORK_PROXY_COMMON_H__ */
-- 
2.25.1

