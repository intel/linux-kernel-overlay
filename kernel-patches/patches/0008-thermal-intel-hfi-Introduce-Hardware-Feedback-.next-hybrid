From 6709b4acb795670751a8b3288ceb75e70110f9ae Mon Sep 17 00:00:00 2001
From: Ricardo Neri <ricardo.neri-calderon@linux.intel.com>
Date: Thu, 16 Dec 2021 17:40:00 -0800
Subject: [PATCH 08/41] thermal: intel: hfi: Introduce Hardware Feedback
 Interface classes

On Intel hybrid parts, CPUs have asymmetric performance properties.
However, such asymmetry depends not only on the type of CPU but also
on the type of instructions a task executes. This means that different
types of tasks will have different instructions-per-cycle (IPC) ratios.

The Enhanced Hardware Feedback (EHFI) interface provides classification
of tasks based on the instructions they execute. In other words, hardware
can identify specific types of tasks with higher or lower IPC ratios.

Tasks are classified into several classes. Hardware defines the number
of supported classes.

Class 0 denotes tasks for which hardware did not find a suitable class.
The IPC ratio of class 0 is the average of all classes. Thus, use to decide
when to inject CPU idleness.

Signed-off-by: Ricardo Neri <ricardo.neri-calderon@linux.intel.com>
---
 drivers/thermal/intel/intel_hfi.c | 37 +++++++++++++++++++++++--------
 1 file changed, 28 insertions(+), 9 deletions(-)

diff --git a/drivers/thermal/intel/intel_hfi.c b/drivers/thermal/intel/intel_hfi.c
index 1466734c168a..f3591a4c7cca 100644
--- a/drivers/thermal/intel/intel_hfi.c
+++ b/drivers/thermal/intel/intel_hfi.c
@@ -64,7 +64,7 @@ union cpuid6_edx {
  * @ee_cap:		Energy efficiency capability
  *
  * Capabilities of a logical processor in the HFI table. These capabilities are
- * unitless.
+ * unitless and specific to each HFI class.
  */
 struct hfi_cpu_data {
 	u8	perf_cap;
@@ -76,7 +76,8 @@ struct hfi_cpu_data {
  * @perf_updated:	Hardware updated performance capabilities
  * @ee_updated:		Hardware updated energy efficiency capabilities
  *
- * Properties of the data in an HFI table.
+ * Properties of the data in an HFI table. There exists one header per each
+ * HFI class.
  */
 struct hfi_hdr {
 	u8	perf_updated;
@@ -116,16 +117,21 @@ struct hfi_instance {
 
 /**
  * struct hfi_features - Supported HFI features
+ * @nr_classes:		Number of classes supported
  * @nr_table_pages:	Size of the HFI table in 4KB pages
  * @cpu_stride:		Stride size to locate capability data of a logical
  *			processor within the table (i.e., row stride)
+ * @class_stride:	Stride size to locate a class within the capability
+ *			data of a logical processor or the HFI table header
  * @hdr_size:		Size of table header
  *
  * Parameters and supported features that are common to all HFI instances
  */
 struct hfi_features {
+	int		nr_classes;
 	unsigned int	nr_table_pages;
 	unsigned int	cpu_stride;
+	unsigned int	class_stride;
 	unsigned int	hdr_size;
 };
 
@@ -153,13 +159,14 @@ static DEFINE_MUTEX(hfi_lock);
 #define HFI_MAX_THERM_NOTIFY_COUNT	16
 
 static void get_one_hfi_cap(struct hfi_instance *hfi_instance, s16 index,
-			    struct hfi_cpu_data *hfi_caps)
+			    struct hfi_cpu_data *hfi_caps, int classid)
 {
 	struct hfi_cpu_data *caps;
 
 	/* Find the capabilities of @cpu */
 	raw_spin_lock_irq(&hfi_instance->table_lock);
-	caps = hfi_instance->data + index * hfi_features.cpu_stride;
+	caps = hfi_instance->data + index * hfi_features.cpu_stride +
+	       classid * hfi_features.class_stride;
 	memcpy(hfi_caps, caps, sizeof(*hfi_caps));
 	raw_spin_unlock_irq(&hfi_instance->table_lock);
 }
@@ -182,7 +189,7 @@ static void update_capabilities(struct hfi_instance *hfi_instance)
 		 */
 		index = per_cpu(hfi_cpu_info, cpu).index;
 
-		get_one_hfi_cap(hfi_instance, index, &caps);
+		get_one_hfi_cap(hfi_instance, index, &caps, 0);
 
 		cpu_caps[i].cpu = cpu;
 
@@ -293,8 +300,8 @@ static void init_hfi_cpu_index(struct hfi_cpu_info *info)
 }
 
 /*
- * The format of the HFI table depends on the number of capabilities that the
- * hardware supports. Keep a data structure to navigate the table.
+ * The format of the HFI table depends on the number of capabilities and classes
+ * that the hardware supports. Keep a data structure to navigate the table.
  */
 static void init_hfi_instance(struct hfi_instance *hfi_instance)
 {
@@ -478,18 +485,30 @@ static __init int hfi_parse_features(void)
 	/* The number of 4KB pages required by the table */
 	hfi_features.nr_table_pages = edx.split.table_pages + 1;
 
+	/*
+	 * Capability fields of an HFI class are grouped together. Classes are
+	 * continuous.  Hence, use the number of supported features to locate
+	 * a specific class.
+	 */
+	hfi_features.class_stride = nr_capabilities;
+
+	/* For now, use only one class of the HFI table */
+	hfi_features.nr_classes = 1;
+
 	/*
 	 * The header contains change indications for each supported feature.
 	 * The size of the table header is rounded up to be a multiple of 8
 	 * bytes.
 	 */
-	hfi_features.hdr_size = DIV_ROUND_UP(nr_capabilities, 8) * 8;
+	hfi_features.hdr_size = DIV_ROUND_UP(nr_capabilities *
+					     hfi_features.nr_classes, 8) * 8;
 
 	/*
 	 * Data of each logical processor is also rounded up to be a multiple
 	 * of 8 bytes.
 	 */
-	hfi_features.cpu_stride = DIV_ROUND_UP(nr_capabilities, 8) * 8;
+	hfi_features.cpu_stride = DIV_ROUND_UP(nr_capabilities *
+					       hfi_features.nr_classes, 8) * 8;
 
 	return 0;
 }
-- 
2.32.0

