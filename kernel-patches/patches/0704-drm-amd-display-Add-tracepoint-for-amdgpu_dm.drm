From 3ba65d920adc80aecbb5441a16fc014ff0a49669 Mon Sep 17 00:00:00 2001
From: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
Date: Fri, 4 Sep 2020 14:37:53 -0400
Subject: [PATCH 0704/1714] drm/amd/display: Add tracepoint for amdgpu_dm

Debug amdgpu_dm could be a complicated task, therefore, this commit adds
tracepoints in some convenient functions such as plane and connector
check inside amdgpu_dm.

Signed-off-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
Acked-by: Aurabindo Pillai <aurabindo.pillai@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
---
 .../gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c |  17 ++
 .../amd/display/amdgpu_dm/amdgpu_dm_trace.h   | 287 ++++++++++++++++++
 2 files changed, 304 insertions(+)

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
index acd78a63fcac..f3e64d18683d 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
@@ -5498,6 +5498,8 @@ amdgpu_dm_connector_atomic_check(struct drm_connector *conn,
 	struct drm_crtc_state *new_crtc_state;
 	int ret;
 
+	trace_amdgpu_dm_connector_atomic_check(new_con_state);
+
 	if (!crtc)
 		return 0;
 
@@ -5605,6 +5607,8 @@ static int dm_crtc_helper_atomic_check(struct drm_crtc *crtc,
 	struct dm_crtc_state *dm_crtc_state = to_dm_crtc_state(crtc_state);
 	int ret = -EINVAL;
 
+	trace_amdgpu_dm_crtc_atomic_check(crtc_state);
+
 	dm_update_crtc_active_planes(crtc, crtc_state);
 
 	if (unlikely(!dm_crtc_state->stream &&
@@ -5980,6 +5984,8 @@ static int dm_plane_atomic_check(struct drm_plane *plane,
 	struct drm_crtc_state *new_crtc_state;
 	int ret;
 
+	trace_amdgpu_dm_plane_atomic_check(state);
+
 	dm_plane_state = to_dm_plane_state(state);
 
 	if (!dm_plane_state->dc_state)
@@ -6020,6 +6026,8 @@ static void dm_plane_atomic_async_update(struct drm_plane *plane,
 	struct drm_plane_state *old_state =
 		drm_atomic_get_old_plane_state(new_state->state, plane);
 
+	trace_amdgpu_dm_atomic_update_cursor(new_state);
+
 	swap(plane->state->fb, new_state->fb);
 
 	plane->state->src_x = new_state->src_x;
@@ -7583,6 +7591,8 @@ static void amdgpu_dm_atomic_commit_tail(struct drm_atomic_state *state)
 	int crtc_disable_count = 0;
 	bool mode_set_reset_required = false;
 
+	trace_amdgpu_dm_atomic_commit_tail_begin(state);
+
 	drm_atomic_helper_update_legacy_modeset_state(dev, state);
 
 	dm_state = dm_atomic_get_new_state(state);
@@ -8671,6 +8681,8 @@ static int amdgpu_dm_atomic_check(struct drm_device *dev,
 	int ret, i;
 	bool lock_and_validation_needed = false;
 
+	trace_amdgpu_dm_atomic_check_begin(state);
+
 	ret = drm_atomic_helper_check_modeset(dev, state);
 	if (ret)
 		goto fail;
@@ -8967,6 +8979,9 @@ static int amdgpu_dm_atomic_check(struct drm_device *dev,
 
 	/* Must be success */
 	WARN_ON(ret);
+
+	trace_amdgpu_dm_atomic_check_finish(state, ret);
+
 	return ret;
 
 fail:
@@ -8977,6 +8992,8 @@ static int amdgpu_dm_atomic_check(struct drm_device *dev,
 	else
 		DRM_DEBUG_DRIVER("Atomic check failed with err: %d \n", ret);
 
+	trace_amdgpu_dm_atomic_check_finish(state, ret);
+
 	return ret;
 }
 
diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_trace.h b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_trace.h
index 11941c69c420..6f07c43ef794 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_trace.h
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_trace.h
@@ -30,6 +30,12 @@
 #define _AMDGPU_DM_TRACE_H_
 
 #include <linux/tracepoint.h>
+#include <drm/drm_connector.h>
+#include <drm/drm_crtc.h>
+#include <drm/drm_plane.h>
+#include <drm/drm_fourcc.h>
+#include <drm/drm_encoder.h>
+#include <drm/drm_atomic.h>
 
 DECLARE_EVENT_CLASS(amdgpu_dc_reg_template,
 		    TP_PROTO(unsigned long *count, uint32_t reg, uint32_t value),
@@ -89,6 +95,287 @@ TRACE_EVENT(amdgpu_dc_performance,
 			(unsigned long)__entry->write_delta,
 			(unsigned long)__entry->writes)
 );
+
+TRACE_EVENT(amdgpu_dm_connector_atomic_check,
+	    TP_PROTO(const struct drm_connector_state *state),
+	    TP_ARGS(state),
+
+	    TP_STRUCT__entry(
+			     __field(uint32_t, conn_id)
+			     __field(const struct drm_connector_state *, conn_state)
+			     __field(const struct drm_atomic_state *, state)
+			     __field(const struct drm_crtc_commit *, commit)
+			     __field(uint32_t, crtc_id)
+			     __field(uint32_t, best_encoder_id)
+			     __field(enum drm_link_status, link_status)
+			     __field(bool, self_refresh_aware)
+			     __field(enum hdmi_picture_aspect, picture_aspect_ratio)
+			     __field(unsigned int, content_type)
+			     __field(unsigned int, hdcp_content_type)
+			     __field(unsigned int, content_protection)
+			     __field(unsigned int, scaling_mode)
+			     __field(u32, colorspace)
+			     __field(u8, max_requested_bpc)
+			     __field(u8, max_bpc)
+	    ),
+
+	    TP_fast_assign(
+			   __entry->conn_id = state->connector->base.id;
+			   __entry->conn_state = state;
+			   __entry->state = state->state;
+			   __entry->commit = state->commit;
+			   __entry->crtc_id = state->crtc ? state->crtc->base.id : 0;
+			   __entry->best_encoder_id = state->best_encoder ?
+						      state->best_encoder->base.id : 0;
+			   __entry->link_status = state->link_status;
+			   __entry->self_refresh_aware = state->self_refresh_aware;
+			   __entry->picture_aspect_ratio = state->picture_aspect_ratio;
+			   __entry->content_type = state->content_type;
+			   __entry->hdcp_content_type = state->hdcp_content_type;
+			   __entry->content_protection = state->content_protection;
+			   __entry->scaling_mode = state->scaling_mode;
+			   __entry->colorspace = state->colorspace;
+			   __entry->max_requested_bpc = state->max_requested_bpc;
+			   __entry->max_bpc = state->max_bpc;
+	    ),
+
+	    TP_printk("conn_id=%u conn_state=%p state=%p commit=%p crtc_id=%u "
+		      "best_encoder_id=%u link_status=%d self_refresh_aware=%d "
+		      "picture_aspect_ratio=%d content_type=%u "
+		      "hdcp_content_type=%u content_protection=%u scaling_mode=%u "
+		      "colorspace=%u max_requested_bpc=%u max_bpc=%u",
+		      __entry->conn_id, __entry->conn_state, __entry->state,
+		      __entry->commit, __entry->crtc_id, __entry->best_encoder_id,
+		      __entry->link_status, __entry->self_refresh_aware,
+		      __entry->picture_aspect_ratio, __entry->content_type,
+		      __entry->hdcp_content_type, __entry->content_protection,
+		      __entry->scaling_mode, __entry->colorspace,
+		      __entry->max_requested_bpc, __entry->max_bpc)
+);
+
+TRACE_EVENT(amdgpu_dm_crtc_atomic_check,
+	    TP_PROTO(const struct drm_crtc_state *state),
+	    TP_ARGS(state),
+
+	    TP_STRUCT__entry(
+			     __field(const struct drm_atomic_state *, state)
+			     __field(const struct drm_crtc_state *, crtc_state)
+			     __field(const struct drm_crtc_commit *, commit)
+			     __field(uint32_t, crtc_id)
+			     __field(bool, enable)
+			     __field(bool, active)
+			     __field(bool, planes_changed)
+			     __field(bool, mode_changed)
+			     __field(bool, active_changed)
+			     __field(bool, connectors_changed)
+			     __field(bool, zpos_changed)
+			     __field(bool, color_mgmt_changed)
+			     __field(bool, no_vblank)
+			     __field(bool, async_flip)
+			     __field(bool, vrr_enabled)
+			     __field(bool, self_refresh_active)
+			     __field(u32, plane_mask)
+			     __field(u32, connector_mask)
+			     __field(u32, encoder_mask)
+	    ),
+
+	    TP_fast_assign(
+			   __entry->state = state->state;
+			   __entry->crtc_state = state;
+			   __entry->crtc_id = state->crtc->base.id;
+			   __entry->commit = state->commit;
+			   __entry->enable = state->enable;
+			   __entry->active = state->active;
+			   __entry->planes_changed = state->planes_changed;
+			   __entry->mode_changed = state->mode_changed;
+			   __entry->active_changed = state->active_changed;
+			   __entry->connectors_changed = state->connectors_changed;
+			   __entry->zpos_changed = state->zpos_changed;
+			   __entry->color_mgmt_changed = state->color_mgmt_changed;
+			   __entry->no_vblank = state->no_vblank;
+			   __entry->async_flip = state->async_flip;
+			   __entry->vrr_enabled = state->vrr_enabled;
+			   __entry->self_refresh_active = state->self_refresh_active;
+			   __entry->plane_mask = state->plane_mask;
+			   __entry->connector_mask = state->connector_mask;
+			   __entry->encoder_mask = state->encoder_mask;
+	    ),
+
+	    TP_printk("crtc_id=%u crtc_state=%p state=%p commit=%p changed("
+		      "planes=%d mode=%d active=%d conn=%d zpos=%d color_mgmt=%d) "
+		      "state(enable=%d active=%d async_flip=%d vrr_enabled=%d "
+		      "self_refresh_active=%d no_vblank=%d) mask(plane=%x conn=%x "
+		      "enc=%x)",
+		      __entry->crtc_id, __entry->crtc_state, __entry->state,
+		      __entry->commit, __entry->planes_changed,
+		      __entry->mode_changed, __entry->active_changed,
+		      __entry->connectors_changed, __entry->zpos_changed,
+		      __entry->color_mgmt_changed, __entry->enable, __entry->active,
+		      __entry->async_flip, __entry->vrr_enabled,
+		      __entry->self_refresh_active, __entry->no_vblank,
+		      __entry->plane_mask, __entry->connector_mask,
+		      __entry->encoder_mask)
+);
+
+DECLARE_EVENT_CLASS(amdgpu_dm_plane_state_template,
+	    TP_PROTO(const struct drm_plane_state *state),
+	    TP_ARGS(state),
+	    TP_STRUCT__entry(
+			     __field(uint32_t, plane_id)
+			     __field(enum drm_plane_type, plane_type)
+			     __field(const struct drm_plane_state *, plane_state)
+			     __field(const struct drm_atomic_state *, state)
+			     __field(uint32_t, crtc_id)
+			     __field(uint32_t, fb_id)
+			     __field(uint32_t, fb_format)
+			     __field(uint8_t, fb_planes)
+			     __field(uint64_t, fb_modifier)
+			     __field(const struct dma_fence *, fence)
+			     __field(int32_t, crtc_x)
+			     __field(int32_t, crtc_y)
+			     __field(uint32_t, crtc_w)
+			     __field(uint32_t, crtc_h)
+			     __field(uint32_t, src_x)
+			     __field(uint32_t, src_y)
+			     __field(uint32_t, src_w)
+			     __field(uint32_t, src_h)
+			     __field(u32, alpha)
+			     __field(uint32_t, pixel_blend_mode)
+			     __field(unsigned int, rotation)
+			     __field(unsigned int, zpos)
+			     __field(unsigned int, normalized_zpos)
+			     __field(enum drm_color_encoding, color_encoding)
+			     __field(enum drm_color_range, color_range)
+			     __field(bool, visible)
+	    ),
+
+	    TP_fast_assign(
+			   __entry->plane_id = state->plane->base.id;
+			   __entry->plane_type = state->plane->type;
+			   __entry->plane_state = state;
+			   __entry->state = state->state;
+			   __entry->crtc_id = state->crtc ? state->crtc->base.id : 0;
+			   __entry->fb_id = state->fb ? state->fb->base.id : 0;
+			   __entry->fb_format = state->fb ? state->fb->format->format : 0;
+			   __entry->fb_planes = state->fb ? state->fb->format->num_planes : 0;
+			   __entry->fb_modifier = state->fb ? state->fb->modifier : 0;
+			   __entry->fence = state->fence;
+			   __entry->crtc_x = state->crtc_x;
+			   __entry->crtc_y = state->crtc_y;
+			   __entry->crtc_w = state->crtc_w;
+			   __entry->crtc_h = state->crtc_h;
+			   __entry->src_x = state->src_x >> 16;
+			   __entry->src_y = state->src_y >> 16;
+			   __entry->src_w = state->src_w >> 16;
+			   __entry->src_h = state->src_h >> 16;
+			   __entry->alpha = state->alpha;
+			   __entry->pixel_blend_mode = state->pixel_blend_mode;
+			   __entry->rotation = state->rotation;
+			   __entry->zpos = state->zpos;
+			   __entry->normalized_zpos = state->normalized_zpos;
+			   __entry->color_encoding = state->color_encoding;
+			   __entry->color_range = state->color_range;
+			   __entry->visible = state->visible;
+	    ),
+
+	    TP_printk("plane_id=%u plane_type=%d plane_state=%p state=%p "
+		      "crtc_id=%u fb(id=%u fmt=%c%c%c%c planes=%u mod=%llu) "
+		      "fence=%p crtc_x=%d crtc_y=%d crtc_w=%u crtc_h=%u "
+		      "src_x=%u src_y=%u src_w=%u src_h=%u alpha=%u "
+		      "pixel_blend_mode=%u rotation=%u zpos=%u "
+		      "normalized_zpos=%u color_encoding=%d color_range=%d "
+		      "visible=%d",
+		      __entry->plane_id, __entry->plane_type, __entry->plane_state,
+		      __entry->state, __entry->crtc_id, __entry->fb_id,
+		      (__entry->fb_format & 0xff) ? (__entry->fb_format & 0xff) : 'N',
+		      ((__entry->fb_format >> 8) & 0xff) ? ((__entry->fb_format >> 8) & 0xff) : 'O',
+		      ((__entry->fb_format >> 16) & 0xff) ? ((__entry->fb_format >> 16) & 0xff) : 'N',
+		      ((__entry->fb_format >> 24) & 0x7f) ? ((__entry->fb_format >> 24) & 0x7f) : 'E',
+		      __entry->fb_planes,
+		      __entry->fb_modifier, __entry->fence, __entry->crtc_x,
+		      __entry->crtc_y, __entry->crtc_w, __entry->crtc_h,
+		      __entry->src_x, __entry->src_y, __entry->src_w, __entry->src_h,
+		      __entry->alpha, __entry->pixel_blend_mode, __entry->rotation,
+		      __entry->zpos, __entry->normalized_zpos,
+		      __entry->color_encoding, __entry->color_range,
+		      __entry->visible)
+);
+
+DEFINE_EVENT(amdgpu_dm_plane_state_template, amdgpu_dm_plane_atomic_check,
+	     TP_PROTO(const struct drm_plane_state *state),
+	     TP_ARGS(state));
+
+DEFINE_EVENT(amdgpu_dm_plane_state_template, amdgpu_dm_atomic_update_cursor,
+	     TP_PROTO(const struct drm_plane_state *state),
+	     TP_ARGS(state));
+
+TRACE_EVENT(amdgpu_dm_atomic_state_template,
+	    TP_PROTO(const struct drm_atomic_state *state),
+	    TP_ARGS(state),
+
+	    TP_STRUCT__entry(
+			     __field(const struct drm_atomic_state *, state)
+			     __field(bool, allow_modeset)
+			     __field(bool, legacy_cursor_update)
+			     __field(bool, async_update)
+			     __field(bool, duplicated)
+			     __field(int, num_connector)
+			     __field(int, num_private_objs)
+	    ),
+
+	    TP_fast_assign(
+			   __entry->state = state;
+			   __entry->allow_modeset = state->allow_modeset;
+			   __entry->legacy_cursor_update = state->legacy_cursor_update;
+			   __entry->async_update = state->async_update;
+			   __entry->duplicated = state->duplicated;
+			   __entry->num_connector = state->num_connector;
+			   __entry->num_private_objs = state->num_private_objs;
+	    ),
+
+	    TP_printk("state=%p allow_modeset=%d legacy_cursor_update=%d "
+		      "async_update=%d duplicated=%d num_connector=%d "
+		      "num_private_objs=%d",
+		      __entry->state, __entry->allow_modeset, __entry->legacy_cursor_update,
+		      __entry->async_update, __entry->duplicated, __entry->num_connector,
+		      __entry->num_private_objs)
+);
+
+DEFINE_EVENT(amdgpu_dm_atomic_state_template, amdgpu_dm_atomic_commit_tail_begin,
+	     TP_PROTO(const struct drm_atomic_state *state),
+	     TP_ARGS(state));
+
+DEFINE_EVENT(amdgpu_dm_atomic_state_template, amdgpu_dm_atomic_commit_tail_finish,
+	     TP_PROTO(const struct drm_atomic_state *state),
+	     TP_ARGS(state));
+
+DEFINE_EVENT(amdgpu_dm_atomic_state_template, amdgpu_dm_atomic_check_begin,
+	     TP_PROTO(const struct drm_atomic_state *state),
+	     TP_ARGS(state));
+
+TRACE_EVENT(amdgpu_dm_atomic_check_finish,
+	    TP_PROTO(const struct drm_atomic_state *state, int res),
+	    TP_ARGS(state, res),
+
+	    TP_STRUCT__entry(
+			     __field(const struct drm_atomic_state *, state)
+			     __field(int, res)
+			     __field(bool, async_update)
+			     __field(bool, allow_modeset)
+	    ),
+
+	    TP_fast_assign(
+			   __entry->state = state;
+			   __entry->res = res;
+			   __entry->async_update = state->async_update;
+			   __entry->allow_modeset = state->allow_modeset;
+	    ),
+
+	    TP_printk("state=%p res=%d async_update=%d allow_modeset=%d",
+		      __entry->state, __entry->res,
+		      __entry->async_update, __entry->allow_modeset)
+);
+
 #endif /* _AMDGPU_DM_TRACE_H_ */
 
 #undef TRACE_INCLUDE_PATH
-- 
2.25.1

