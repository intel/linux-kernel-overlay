From a743bd90e3ad9624697c1cb9af42f679f353b8be Mon Sep 17 00:00:00 2001
From: Youquan Song <youquan.song@intel.com>
Date: Thu, 10 Sep 2020 00:14:39 -0400
Subject: [PATCH] EDAC, i10nm: Retrieve and print retry_rd_err_log registers

Retrieve and print retry_rd_err_log registers as like the previous commit:
commit e80634a75aba ("EDAC, skx: Retrieve and print retry_rd_err_log registers")

Co-developed-by: Qiuxu Zhuo <qiuxu.zhuo@intel.com>
Signed-off-by: Qiuxu Zhuo <qiuxu.zhuo@intel.com>
Signed-off-by: Youquan Song <youquan.song@intel.com>
---
 drivers/edac/i10nm_base.c | 44 +++++++++++++++++++++++++++++++++++++++
 drivers/edac/skx_base.c   |  3 ++-
 drivers/edac/skx_common.c |  4 +++-
 drivers/edac/skx_common.h |  2 +-
 4 files changed, 50 insertions(+), 3 deletions(-)

diff --git a/drivers/edac/i10nm_base.c b/drivers/edac/i10nm_base.c
index 53fd1d5f80bb..9924540b4226 100644
--- a/drivers/edac/i10nm_base.c
+++ b/drivers/edac/i10nm_base.c
@@ -32,6 +32,8 @@
 	readl((m)->mbase + 0x20ef8 + (i) * (m)->chan_mmio_sz)
 #define I10NM_GET_AMAP(m, i)		\
 	readl((m)->mbase + 0x20814 + (i) * (m)->chan_mmio_sz)
+#define I10NM_GET_REG(m, i, offset)	\
+	readl((m)->mbase + (i) * (m)->chan_mmio_sz + (offset))
 
 #define I10NM_GET_SCK_MMIO_BASE(reg)	(GET_BITFIELD(reg, 0, 28) << 23)
 #define I10NM_GET_IMC_MMIO_OFFSET(reg)	(GET_BITFIELD(reg, 0, 10) << 12)
@@ -40,6 +42,46 @@
 
 static struct list_head *i10nm_edac_list;
 
+static void i10nm_show_retry_rd_err_log(struct decoded_addr *res,
+					char *msg, int len,
+					bool scrub_err)
+{
+	u32 offsets1[] = {0x22c60, 0x22c54, 0x22c5c, 0x22c58, 0x22c28, 0x20ed8, 0x20edc};
+	u32 offsets2[] = {0x22e54, 0x22e60, 0x22e64, 0x22e58, 0x22e5c, 0x20ee0, 0x20ee4};
+	struct skx_imc *imc = &res->dev->imc[res->imc];
+	u32 log0, log1, log2, log3, log4;
+	u32 corr0, corr1, corr2, corr3;
+	u32 *offsets;
+	u64 log5;
+	int n;
+
+	offsets = scrub_err ? offsets1 : offsets2;
+
+	log0 = I10NM_GET_REG(imc, res->channel, offsets[0]);
+	log1 = I10NM_GET_REG(imc, res->channel, offsets[1]);
+	log2 = I10NM_GET_REG(imc, res->channel, offsets[2]);
+	log3 = I10NM_GET_REG(imc, res->channel, offsets[3]);
+	log4 = I10NM_GET_REG(imc, res->channel, offsets[4]);
+	log5 = I10NM_GET_REG(imc, res->channel, offsets[5]);
+	log5 |= (u64)I10NM_GET_REG(imc, res->channel, offsets[6]) << 32;
+
+	n = snprintf(msg, len, " retry_rd_err_log[%.8x %.8x %.8x %.8x %.8x %.16llx]",
+		     log0, log1, log2, log3, log4, log5);
+
+	corr0 = I10NM_GET_REG(imc, res->channel, 0x22c18);
+	corr1 = I10NM_GET_REG(imc, res->channel, 0x22c1c);
+	corr2 = I10NM_GET_REG(imc, res->channel, 0x22c20);
+	corr3 = I10NM_GET_REG(imc, res->channel, 0x22c24);
+
+	if (len - n > 0)
+		snprintf(msg + n, len - n,
+			 " correrrcnt[%.4x %.4x %.4x %.4x %.4x %.4x %.4x %.4x]",
+			 corr0 & 0xffff, corr0 >> 16,
+			 corr1 & 0xffff, corr1 >> 16,
+			 corr2 & 0xffff, corr2 >> 16,
+			 corr3 & 0xffff, corr3 >> 16);
+}
+
 static struct pci_dev *pci_get_dev_wrapper(int dom, unsigned int bus,
 					   unsigned int dev, unsigned int fun)
 {
@@ -331,6 +373,8 @@ static int __init i10nm_init(void)
 		}
 	}
 
+	skx_set_decode(NULL, i10nm_show_retry_rd_err_log);
+
 	rc = skx_adxl_get();
 	if (rc)
 		goto fail;
diff --git a/drivers/edac/skx_base.c b/drivers/edac/skx_base.c
index 4dbd46575bfb..1abc020d49ab 100644
--- a/drivers/edac/skx_base.c
+++ b/drivers/edac/skx_base.c
@@ -230,7 +230,8 @@ static int skx_get_dimm_config(struct mem_ctl_info *mci, struct res_config *cfg)
 #define SKX_ILV_TARGET(tgt)	((tgt) & 7)
 
 static void skx_show_retry_rd_err_log(struct decoded_addr *res,
-				      char *msg, int len)
+				      char *msg, int len,
+				      bool scrub_err)
 {
 	u32 log0, log1, log2, log3, log4;
 	u32 corr0, corr1, corr2, corr3;
diff --git a/drivers/edac/skx_common.c b/drivers/edac/skx_common.c
index 81c3e2ec6f56..05ffd39d6de9 100644
--- a/drivers/edac/skx_common.c
+++ b/drivers/edac/skx_common.c
@@ -494,6 +494,7 @@ static void skx_mce_output_error(struct mem_ctl_info *mci,
 	bool ripv = GET_BITFIELD(m->mcgstatus, 0, 0);
 	bool overflow = GET_BITFIELD(m->status, 62, 62);
 	bool uncorrected_error = GET_BITFIELD(m->status, 61, 61);
+	bool scrub_err = false;
 	bool recoverable;
 	int len;
 	u32 core_err_cnt = GET_BITFIELD(m->status, 38, 52);
@@ -545,6 +546,7 @@ static void skx_mce_output_error(struct mem_ctl_info *mci,
 			break;
 		case 4:
 			optype = "memory scrubbing error";
+			scrub_err = true;
 			break;
 		default:
 			optype = "reserved";
@@ -567,7 +569,7 @@ static void skx_mce_output_error(struct mem_ctl_info *mci,
 	}
 
 	if (skx_show_retry_rd_err_log)
-		skx_show_retry_rd_err_log(res, skx_msg + len, MSG_SIZE - len);
+		skx_show_retry_rd_err_log(res, skx_msg + len, MSG_SIZE - len, scrub_err);
 
 	edac_dbg(0, "%s\n", skx_msg);
 
diff --git a/drivers/edac/skx_common.h b/drivers/edac/skx_common.h
index bf56bebff138..c0edb1979646 100644
--- a/drivers/edac/skx_common.h
+++ b/drivers/edac/skx_common.h
@@ -128,7 +128,7 @@ struct res_config {
 typedef int (*get_dimm_config_f)(struct mem_ctl_info *mci,
 				 struct res_config *cfg);
 typedef bool (*skx_decode_f)(struct decoded_addr *res);
-typedef void (*skx_show_retry_log_f)(struct decoded_addr *res, char *msg, int len);
+typedef void (*skx_show_retry_log_f)(struct decoded_addr *res, char *msg, int len, bool scrub_err);
 
 int __init skx_adxl_get(void);
 void __exit skx_adxl_put(void);
-- 
2.17.1

