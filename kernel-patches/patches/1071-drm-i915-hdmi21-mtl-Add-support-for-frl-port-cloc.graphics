From 46413afd553a3d937836d9f895f698f44c00fd16 Mon Sep 17 00:00:00 2001
From: Vandita Kulkarni <vandita.kulkarni@intel.com>
Date: Sat, 2 Apr 2022 12:22:18 +0530
Subject: [PATCH 1071/1096] drm/i915/hdmi21/mtl: Add support for frl port clock
 valid

Check if the given mode is can be supported with the div18 symbol clock
for FRL transmission mode. Compute the required symbol clock to fit the
given pixel clock and validate against max port clock.

v2: Fixed pixel_rate calculation, and minor restructure. (Uma)
Squahsed the patch to compute clock for frl mode. (Ankit)

v3: Rebased

v3: Fixed the check for min and max clock with FRL mode. (Ankit)

v4: Rounded div18 clock to 10KHz to match with C20 clocks. (Ankit)

v5: Prune FRL modes for platforms < MTL. (Ankit)

Signed-off-by: Vandita Kulkarni <vandita.kulkarni@intel.com>
Signed-off-by: Ankit Nautiyal <ankit.k.nautiyal@intel.com>
Reviewed-by: Uma Shankar <uma.shankar@intel.com>
---
 drivers/gpu/drm/i915/display/intel_hdmi.c | 136 ++++++++++++++++++++--
 1 file changed, 126 insertions(+), 10 deletions(-)

diff --git a/drivers/gpu/drm/i915/display/intel_hdmi.c b/drivers/gpu/drm/i915/display/intel_hdmi.c
index 87fac230fa95..5a20c4496c55 100644
--- a/drivers/gpu/drm/i915/display/intel_hdmi.c
+++ b/drivers/gpu/drm/i915/display/intel_hdmi.c
@@ -1918,13 +1918,93 @@ hdmi_port_tmds_clock_valid(struct intel_hdmi *hdmi,
 	return MODE_OK;
 }
 
+/*
+ * Returns the Fixed rate per lane required to support given pixel rate.
+ * Returns 0 for pixel rate demanding > 12 Gbps
+ */
+static int intel_hdmi_frl_required_bitrate(int pixel_rate_kbps)
+{
+	/*
+	 * 3 lane configurations:
+	 * 3 Gbps * 3 = 9 Gbps; 6 Gbps * 3 = 18 Gbps.
+	 *
+	 * 4 lane configurations:
+	 * 6 Gbps * 4 = 24 Gbps; 8 Gbps * 4 = 32 Gbp;
+	 * 10 Gbps * 4 = 40 Gbps; 12 Gbps * 4 = 48 Gbps.
+	 */
+#define frl_gbps_to_kbps(rate) ((rate) * 1000000)
+	if (pixel_rate_kbps <= frl_gbps_to_kbps(9))
+		return frl_gbps_to_kbps(3);
+
+	if (pixel_rate_kbps > frl_gbps_to_kbps(9) &&
+	    pixel_rate_kbps <= frl_gbps_to_kbps(18))
+		return frl_gbps_to_kbps(6);
+
+	if (pixel_rate_kbps > frl_gbps_to_kbps(18) &&
+	    pixel_rate_kbps <= frl_gbps_to_kbps(24))
+		return frl_gbps_to_kbps(6);
+
+	if (pixel_rate_kbps > frl_gbps_to_kbps(24) &&
+	    pixel_rate_kbps <= frl_gbps_to_kbps(32))
+		return frl_gbps_to_kbps(8);
+
+	if (pixel_rate_kbps > frl_gbps_to_kbps(32) &&
+	    pixel_rate_kbps <= frl_gbps_to_kbps(40))
+		return frl_gbps_to_kbps(10);
+
+	if (pixel_rate_kbps > frl_gbps_to_kbps(40) &&
+	    pixel_rate_kbps <= frl_gbps_to_kbps(48))
+		return frl_gbps_to_kbps(12);
+
+	/*
+	 * pixel rate more than 48 Gbps rate, means more than
+	 * 12 Gbps x 4 lanes. Such a rate not possible with FRL.
+	 */
+	return 0;
+}
+
+static int
+hdmi21_port_clock_limit(struct intel_hdmi *hdmi)
+{
+	int max_lane_rate_gbps, max_symbol_clock_khz;
+
+	max_lane_rate_gbps = intel_hdmi_frl_required_bitrate(hdmi->max_frl_rate);
+
+	max_symbol_clock_khz = (max_lane_rate_gbps * 1000000) / 18;
+
+	/*
+	 * FIXME: Currently the resolution of C20 clocks is in 10KHz.
+	 * Check if we need to have finer granularity.
+	 */
+	return roundup(max_symbol_clock_khz, 10);
+}
+
+static enum drm_mode_status
+hdmi_port_frl_clock_valid(struct intel_hdmi *hdmi, int clock)
+{
+	struct intel_encoder *encoder = &hdmi_to_dig_port(hdmi)->base;
+	struct drm_i915_private *i915 = to_i915(encoder->base.dev);
+
+	if (!clock || clock > hdmi21_port_clock_limit(hdmi))
+		return MODE_CLOCK_HIGH;
+
+	if (DISPLAY_VER(i915) >= 14)
+		return intel_c20_phy_check_hdmi_link_rate(clock);
+
+	return MODE_OK;
+}
+
 static enum drm_mode_status
 hdmi_port_clock_valid(struct intel_hdmi *hdmi,
 		      int clock, bool respect_downstream_limits,
-		      bool has_hdmi_sink)
+		      bool has_hdmi_sink, bool frl_mode)
 {
-	return hdmi_port_tmds_clock_valid(hdmi, clock, respect_downstream_limits,
-				     has_hdmi_sink);
+	if (frl_mode)
+		return hdmi_port_frl_clock_valid(hdmi, clock);
+
+	return hdmi_port_tmds_clock_valid(hdmi, clock,
+					  respect_downstream_limits,
+					  has_hdmi_sink);
 }
 
 int intel_hdmi_tmds_clock(int clock, int bpc, bool ycbcr420_output)
@@ -1987,6 +2067,39 @@ static bool intel_hdmi_sink_bpc_possible(struct drm_connector *connector,
 	}
 }
 
+static
+int intel_hdmi_frl_clock(int clock, int bpc, bool ycbcr420_output)
+{
+	int pixel_rate_kbps, frl_bit_rate_required;
+	int frl_symbol_clock;
+
+	if (ycbcr420_output)
+		clock /= 2;
+
+	pixel_rate_kbps = clock * bpc * 3;
+
+	/* find the closest frl bit rate */
+	frl_bit_rate_required = intel_hdmi_frl_required_bitrate(pixel_rate_kbps);
+
+	/* frl_symbol_clock */
+	frl_symbol_clock = frl_bit_rate_required / 18;
+
+	/*
+	 * FIXME: Currently the resolution of C20 clocks is in 10KHz.
+	 * Check if we need to have finer granularity.
+	 */
+	return roundup(frl_symbol_clock, 10);
+}
+
+static
+int intel_hdmi_clock(int clock, int bpc, bool ycbcr420_output, bool frl_mode)
+{
+	if (frl_mode)
+		return intel_hdmi_frl_clock(clock, bpc, ycbcr420_output);
+
+	return intel_hdmi_tmds_clock(clock, bpc, ycbcr420_output);
+}
+
 static enum drm_mode_status
 intel_hdmi_mode_clock_valid(struct drm_connector *connector, int clock,
 			    bool has_hdmi_sink, bool ycbcr420_output)
@@ -1995,6 +2108,9 @@ intel_hdmi_mode_clock_valid(struct drm_connector *connector, int clock,
 	struct intel_hdmi *hdmi = intel_attached_hdmi(to_intel_connector(connector));
 	enum drm_mode_status status = MODE_OK;
 	int bpc;
+	bool frl_mode;
+
+	frl_mode = hdmi->has_sink_hdmi_21 && hdmi->max_frl_rate;
 
 	/*
 	 * Try all color depths since valid port clock range
@@ -2002,7 +2118,7 @@ intel_hdmi_mode_clock_valid(struct drm_connector *connector, int clock,
 	 * least one color depth is accepted.
 	 */
 	for (bpc = 12; bpc >= 8; bpc -= 2) {
-		int tmds_clock = intel_hdmi_tmds_clock(clock, bpc, ycbcr420_output);
+		int hdmi_clock = intel_hdmi_clock(clock, bpc, ycbcr420_output, frl_mode);
 
 		if (!intel_hdmi_source_bpc_possible(i915, bpc))
 			continue;
@@ -2010,7 +2126,7 @@ intel_hdmi_mode_clock_valid(struct drm_connector *connector, int clock,
 		if (!intel_hdmi_sink_bpc_possible(connector, bpc, has_hdmi_sink, ycbcr420_output))
 			continue;
 
-		status = hdmi_port_clock_valid(hdmi, tmds_clock, true, has_hdmi_sink);
+		status = hdmi_port_clock_valid(hdmi, hdmi_clock, true, has_hdmi_sink, frl_mode);
 		if (status == MODE_OK)
 			return MODE_OK;
 	}
@@ -2047,11 +2163,11 @@ intel_hdmi_mode_valid(struct drm_connector *connector,
 
 	/*
 	 * HDMI2.1 requires higher resolution modes like 8k60, 4K120 to be
-	 * enumerated only if FRL is supported. Current platforms do not support
+	 * enumerated only if FRL is supported. Platforms < MTL do not support
 	 * FRL so prune the higher resolution modes that require doctclock more
 	 * than 600MHz.
 	 */
-	if (clock > 600000)
+	if (DISPLAY_VER(dev_priv) < 14 && clock > 600000)
 		return MODE_CLOCK_HIGH;
 
 	ycbcr_420_only = drm_mode_is_420_only(&connector->display_info, mode);
@@ -2137,9 +2253,9 @@ static int intel_hdmi_compute_bpc(struct intel_encoder *encoder,
 		int tmds_clock = intel_hdmi_tmds_clock(clock, bpc, ycbcr420_output);
 
 		if (hdmi_bpc_possible(crtc_state, bpc) &&
-		    hdmi_port_clock_valid(intel_hdmi, tmds_clock,
-					  respect_downstream_limits,
-					  crtc_state->has_hdmi_sink) == MODE_OK)
+		    hdmi_port_tmds_clock_valid(intel_hdmi, tmds_clock,
+					       respect_downstream_limits,
+					       crtc_state->has_hdmi_sink) == MODE_OK)
 			return bpc;
 	}
 
-- 
2.25.1

