From deed969eb610848180266578c3158881bb5b3a49 Mon Sep 17 00:00:00 2001
From: Alexander Usyskin <alexander.usyskin@intel.com>
Date: Thu, 6 Oct 2022 13:23:27 +0300
Subject: [PATCH 12/21] INTEL_DII: mei: add force wake workaround in init

Upon force wake assert the firmware goes into reset.
Force wake firmware at the beginning of the init flow and
wait till firmware is usable again.
No need to wait for the driver to process link reset
as link reset will be started right after force wake.

Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
Reviewed-by: Tomas Winkler <tomas.winkler@intel.com>
---
 drivers/misc/mei/client.c     |  6 ++++
 drivers/misc/mei/gsc-me.c     | 65 +++++++++++++++++++++++++++++++++++
 drivers/misc/mei/hw-me-regs.h |  1 +
 drivers/misc/mei/mei_dev.h    |  2 ++
 4 files changed, 74 insertions(+)

diff --git a/drivers/misc/mei/client.c b/drivers/misc/mei/client.c
index 9d090fa07516..dcab98776f95 100644
--- a/drivers/misc/mei/client.c
+++ b/drivers/misc/mei/client.c
@@ -731,6 +731,12 @@ void mei_host_client_init(struct mei_device *dev)
 
 	schedule_work(&dev->bus_rescan_work);
 
+	if (dev->forcewake_needed && dev->gt_forcewake_init_on) {
+		dev->ops->forcewake_put(dev);
+		dev->gt_forcewake_init_on = false;
+		pm_runtime_put_noidle(dev->dev);
+	}
+
 	pm_runtime_mark_last_busy(dev->dev);
 	dev_dbg(dev->dev, "rpm: autosuspend\n");
 	pm_request_autosuspend(dev->dev);
diff --git a/drivers/misc/mei/gsc-me.c b/drivers/misc/mei/gsc-me.c
index 1941cd75952c..ecfd15ace4ce 100644
--- a/drivers/misc/mei/gsc-me.c
+++ b/drivers/misc/mei/gsc-me.c
@@ -333,6 +333,62 @@ static const struct mei_hw_ops mei_gsc_hw_ops_null = {
 	.read = mei_gsc_read_slots_null
 };
 
+#define MEI_GSC_RESET_BEGIN_TIMEOUT 300
+#define MEI_GSC_RESET_END_TIMEOUT 700
+#define MEI_GSC_RESET_STEP 20
+
+static int mei_gsc_forcewake_get_and_wait(struct mei_device *dev)
+{
+	struct mei_fw_status fw_status;
+	int timeout;
+	int ret;
+
+	if (!dev->forcewake_needed || dev->gt_forcewake_init_on)
+		return 0;
+
+	/* grab the GT forcewake bit to prevent RC6-exit which would cause fw reset */
+	dev->ops->forcewake_get(dev);
+	dev->gt_forcewake_init_on = true;
+	/* wait for FW going to reset */
+	for (timeout = MEI_GSC_RESET_BEGIN_TIMEOUT; timeout >= 0; timeout -= MEI_GSC_RESET_STEP) {
+		ret = mei_fw_status(dev, &fw_status);
+		if (ret) {
+			dev_err(dev->dev, "failed to read fw sts: %d\n", ret);
+			dev->gt_forcewake_init_on = false;
+			dev->ops->forcewake_put(dev);
+			return ret;
+		}
+		dev_dbg(dev->dev, "forcewake: fw sts: %d\n", fw_status.status[0]);
+		if (!(fw_status.status[0] & PCI_CFG_HFS_1_INITSTATE))
+			break;
+		msleep(20);
+	}
+	dev_dbg(dev->dev, "forcewake: after wake fw sts: %d\n", fw_status.status[0]);
+
+	/* wait to FW going out of reset */
+	if (fw_status.status[0] & PCI_CFG_HFS_1_INITSTATE)
+		return 0;
+	for (timeout = MEI_GSC_RESET_END_TIMEOUT; timeout >= 0; timeout -= MEI_GSC_RESET_STEP) {
+		ret = mei_fw_status(dev, &fw_status);
+		if (ret) {
+			dev_err(dev->dev, "failed to read fw sts: %d\n", ret);
+			dev->gt_forcewake_init_on = false;
+			dev->ops->forcewake_put(dev);
+			return ret;
+		}
+		dev_dbg(dev->dev, "forcewake: fw sts: %d\n", fw_status.status[0]);
+		if (fw_status.status[0] & PCI_CFG_HFS_1_INITSTATE)
+			break;
+		msleep(20);
+	}
+
+	if (!(fw_status.status[0] & PCI_CFG_HFS_1_INITSTATE)) {
+		dev_err(dev->dev, "forcewake: FW not back from reset: %d\n", fw_status.status[0]);
+		return -ENODEV;
+	}
+	return 0;
+}
+
 static int mei_gsc_probe(struct auxiliary_device *aux_dev,
 			 const struct auxiliary_device_id *aux_dev_id)
 {
@@ -378,6 +434,10 @@ static int mei_gsc_probe(struct auxiliary_device *aux_dev,
 		dev->pxp_mode = MEI_DEV_PXP_INIT;
 	}
 
+	ret = mei_gsc_forcewake_get_and_wait(dev);
+	if (ret)
+		goto err;
+
 	/* use polling */
 	if (mei_me_hw_use_polling(hw)) {
 		mei_disable_interrupts(dev);
@@ -446,6 +506,11 @@ static void mei_gsc_remove(struct auxiliary_device *aux_dev)
 
 	mei_stop(dev);
 
+	if (dev->forcewake_needed && dev->gt_forcewake_init_on) {
+		dev->ops->forcewake_put(dev);
+		dev->gt_forcewake_init_on = false;
+	}
+
 	hw = to_me_hw(dev);
 	if (mei_me_hw_use_polling(hw))
 		kthread_stop(hw->polling_thread);
diff --git a/drivers/misc/mei/hw-me-regs.h b/drivers/misc/mei/hw-me-regs.h
index aac36750d2c5..d381d0bb27b8 100644
--- a/drivers/misc/mei/hw-me-regs.h
+++ b/drivers/misc/mei/hw-me-regs.h
@@ -124,6 +124,7 @@
 #  define PCI_CFG_HFS_1_D0I3_MSK     0x80000000
 #  define PCI_CFG_HFS_1_OPMODE_MSK 0xf0000 /* OP MODE Mask: SPS <= 4.0 */
 #  define PCI_CFG_HFS_1_OPMODE_SPS 0xf0000 /* SPS SKU : SPS <= 4.0 */
+#  define PCI_CFG_HFS_1_INITSTATE    0x00000200
 #define PCI_CFG_HFS_2         0x48
 #  define PCI_CFG_HFS_2_PM_CMOFF_TO_CMX_ERROR 0x1000000 /* CMoff->CMx wake after an error */
 #  define PCI_CFG_HFS_2_PM_CM_RESET_ERROR     0x5000000 /* CME reset due to exception */
diff --git a/drivers/misc/mei/mei_dev.h b/drivers/misc/mei/mei_dev.h
index c03328e4b0fa..30f6e4044dd4 100644
--- a/drivers/misc/mei/mei_dev.h
+++ b/drivers/misc/mei/mei_dev.h
@@ -559,6 +559,7 @@ struct mei_dev_timeouts {
  *
  * @forcewake_needed     : forcewake should be asserted before operations
  * @forcewake_count      : forcewake status counter
+ * @gt_forcewake_init_on : the GT forcewake is on in init flow
  *
  * @ops:        : hw specific operations
  * @hw          : hw specific data
@@ -664,6 +665,7 @@ struct mei_device {
 
 	bool forcewake_needed;
 	int forcewake_count;
+	bool gt_forcewake_init_on;
 
 	const struct mei_hw_ops *ops;
 	char hw[] __aligned(sizeof(void *));
-- 
2.25.1

