From c13e79b95d6444ae3ac1cdb93729672800c7d4f7 Mon Sep 17 00:00:00 2001
From: Vandita Kulkarni <vandita.kulkarni@intel.com>
Date: Sat, 2 Apr 2022 12:22:06 +0530
Subject: [PATCH 1038/1096] drm/hdmi21: Add non dsc frl capacity computation
 helpers

Add helper functions for computing non dsc frl
link characteristics

Signed-off-by: Vandita Kulkarni <vandita.kulkarni@intel.com>
Signed-off-by: Ankit Nautiyal <ankit.k.nautiyal@intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20220214020357.10063-3-vandita.kulkarni@intel.com
---
 drivers/gpu/drm/Makefile             |   1 +
 drivers/gpu/drm/drm_frl_dfm_helper.c | 407 +++++++++++++++++++++++++++
 include/drm/drm_frl_dfm_helper.h     |   2 +
 3 files changed, 410 insertions(+)
 create mode 100644 drivers/gpu/drm/drm_frl_dfm_helper.c

diff --git a/drivers/gpu/drm/Makefile b/drivers/gpu/drm/Makefile
index ab4460fcd63f..21a7fc32df04 100644
--- a/drivers/gpu/drm/Makefile
+++ b/drivers/gpu/drm/Makefile
@@ -107,6 +107,7 @@ drm_kms_helper-y := \
 	drm_encoder_slave.o \
 	drm_flip_work.o \
 	drm_format_helper.o \
+	drm_frl_dfm_helper.o \
 	drm_gem_atomic_helper.o \
 	drm_gem_framebuffer_helper.o \
 	drm_kms_helper_common.o \
diff --git a/drivers/gpu/drm/drm_frl_dfm_helper.c b/drivers/gpu/drm/drm_frl_dfm_helper.c
new file mode 100644
index 000000000000..c02671306ef3
--- /dev/null
+++ b/drivers/gpu/drm/drm_frl_dfm_helper.c
@@ -0,0 +1,407 @@
+// SPDX-License-Identifier: MIT
+/*
+ * Copyright © 2022 Intel Corp
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <drm/drm_frl_dfm_helper.h>
+#include <drm/drm_connector.h>
+
+/* Total frl characters per super block */
+static unsigned int drm_get_frl_char_per_super_blk(unsigned int lanes)
+{
+	return (4 * FRL_CHAR_PER_CHAR_BLK) + lanes;
+}
+
+/* Total minimum overhead multiplied by EFFICIENCY_MULIPLIER */
+static unsigned int drm_get_total_minimum_overhead(unsigned int lanes)
+{
+	unsigned int overhead_sb;
+	unsigned int overhead_rs;
+	unsigned int overhead_map;
+
+	/*
+	 * Determine the overhead due to the inclusion of
+	 * the SR and SSB FRL characters used for
+	 * super block framing
+	 */
+	overhead_sb =
+		(lanes * EFFICIENCY_MULTIPLIER) / drm_get_frl_char_per_super_blk(lanes);
+
+	/*
+	 * Determine the overhead due to the inclusion of RS FEC pairity
+	 * symbols. Each character block uses 8 FRL characters for RS Pairity
+	 * and there are 4 character blocks per super block
+	 */
+	overhead_rs =
+		(8 * 4 * EFFICIENCY_MULTIPLIER) /  drm_get_frl_char_per_super_blk(lanes);
+
+	/*
+	 * Determine the overhead due to FRL Map characters.
+	 * In a bandwidth constrained application, the FRL packets will be long,
+	 * there will typically be two FRL Map Characters per Super Block most of the time.
+	 * When a tracnsition occurs between Hactive and Hblank (uncomperssed video) or
+	 * HCactive and HCblank (compressed video transport), there may be a
+	 * third FRL Map Charecter. Therefore this spec assumes 2.5 FRL Map Characters
+	 * per Super Block.
+	 */
+	overhead_map =
+		(25  * EFFICIENCY_MULTIPLIER) / (10 * drm_get_frl_char_per_super_blk(lanes));
+
+	return overhead_sb + overhead_rs + overhead_map;
+}
+
+/* Audio Support Verification Computations */
+
+/*
+ * During the Hblank period, Audio packets (32 frl characters each),
+ * ACR packets (32 frl characters each), Island guard band (4 total frl characters)
+ * and Video guard band (3 frl characters) do not benefit from RC compression
+ * Therefore start by determining the number of Control Characters that maybe
+ * RC compressible
+ */
+static unsigned int
+drm_get_num_char_rc_compressible(unsigned int color_format, unsigned int bpc,
+				 unsigned int audio_packets_line, unsigned int hblank)
+{
+	unsigned int cfrl_free;
+	unsigned int kcdx100, k420;
+
+	if (color_format == DRM_COLOR_FORMAT_YCBCR420)
+		k420 = 2;
+	else
+		k420 = 1;
+
+	if (color_format == DRM_COLOR_FORMAT_YCBCR422)
+		kcdx100 = 100;
+	else
+		kcdx100 = (100 * bpc) / 8;
+
+	cfrl_free = max(((hblank * kcdx100) / (100 * k420) - 32 * audio_packets_line - 7),
+			U32_MIN);
+
+	return cfrl_free;
+}
+
+/*
+ * Determine the actual number of characters made available by
+ * RC compression
+ */
+static unsigned int
+drm_get_num_char_compression_savings(unsigned int cfrl_free)
+{
+	/*
+	 * In order to be conservative, situations are considered where
+	 * maximum RC compression may not be possible.
+	 * Add one character each for RC break caused by:
+	 * • Island Preamble not aligned to the RC Compression
+	 * • Video Preamble not aligned to the RC Compression
+	 * • HSYNC lead edge not aligned to the RC Compression
+	 * • HSYNC trail edge not aligned to the RC Compression
+	 */
+	const unsigned int cfrl_margin = 4;
+	unsigned int cfrl_savings = max(((7 * cfrl_free) / 8) - cfrl_margin, U32_MIN);
+
+	return cfrl_savings;
+}
+
+static unsigned int
+drm_get_frl_bits_per_pixel(unsigned int color_format, unsigned int bpc)
+{
+	unsigned int kcdx100, k420;
+
+	if (color_format == DRM_COLOR_FORMAT_YCBCR420)
+		k420 = 2;
+	else
+		k420 = 1;
+
+	if (color_format == DRM_COLOR_FORMAT_YCBCR422)
+		kcdx100 = 100;
+	else
+		kcdx100 = (100 * bpc) / 8;
+
+	return (24 * kcdx100) / (100 * k420);
+}
+
+/* Determine the total available tribytes during the blanking period */
+static unsigned int
+drm_get_blanking_tribytes_avail(unsigned int color_format,
+				unsigned int hblank, unsigned int bpc)
+{
+	unsigned int kcdx100, k420;
+
+	if (color_format == DRM_COLOR_FORMAT_YCBCR420)
+		k420 = 2;
+	else
+		k420 = 1;
+
+	if (color_format == DRM_COLOR_FORMAT_YCBCR422)
+		kcdx100 = 100;
+	else
+		kcdx100 = (100 * bpc) / 8;
+
+	return DIV_ROUND_UP((hblank * kcdx100), (100 * k420));
+}
+
+/*
+ * Determine the minimum time necessary to transmit the active tribytes
+ * considering frl bandwidth limitation.
+ * Given the available bandwidth (i.e after overhead is considered),
+ * tactive_min represents the amount of time needed to transmit all the
+ * active data
+ */
+static unsigned int
+drm_get_tactive_min(unsigned int num_lanes, unsigned int tribyte_active,
+		    unsigned int overhead_max_k, unsigned int frl_char_min_rate_k)
+{
+	unsigned int active_bytes, rate_kbps, efficiency_k, effective_rate_kbps;
+
+	active_bytes = (3 * tribyte_active) / 2;
+	rate_kbps = num_lanes * frl_char_min_rate_k;
+	efficiency_k = EFFICIENCY_MULTIPLIER - overhead_max_k;
+	effective_rate_kbps = mult_frac(rate_kbps, efficiency_k, EFFICIENCY_MULTIPLIER);
+
+	return mult_frac(FRL_TIMING_NS_MULTIPLIER, active_bytes, effective_rate_kbps) / 1000;
+}
+
+/*
+ * Determine the minimum time necessary to transmit the video blanking
+ * tribytes considering frl bandwidth limitations
+ */
+static unsigned int
+drm_get_tblank_min(unsigned int num_lanes, unsigned int tribyte_blank,
+		   unsigned int overhead_max_k, unsigned int frl_char_min_rate_k)
+{
+	unsigned int blank_bytes, rate_kbps, efficiency_k, effective_rate_kbps;
+
+	blank_bytes = (3 * tribyte_blank) / 2;
+	rate_kbps = num_lanes * frl_char_min_rate_k;
+	efficiency_k = EFFICIENCY_MULTIPLIER - overhead_max_k;
+	effective_rate_kbps = mult_frac(rate_kbps, efficiency_k, EFFICIENCY_MULTIPLIER);
+
+	return mult_frac(FRL_TIMING_NS_MULTIPLIER, blank_bytes, effective_rate_kbps) / 1000;
+
+}
+
+/* Collect link characteristics */
+static void
+drm_frl_dfm_compute_link_characteristics(struct drm_hdmi_frl_dfm *frl_dfm)
+{
+	unsigned int frl_bit_rate_min_kbps, line_width, rate_m;
+
+	/* Determine the maximum legal pixel rate */
+	frl_dfm->params.pixel_clock_max_khz =
+		(frl_dfm->config.pixel_clock_nominal_khz * (1000 + TOLERANCE_PIXEL_CLOCK)) / 1000;
+
+	/* Determine the minimum Video Line period */
+	line_width = frl_dfm->config.hactive + frl_dfm->config.hblank;
+
+	frl_dfm->params.line_time_ns = mult_frac(FRL_TIMING_NS_MULTIPLIER,
+						  line_width,
+						  frl_dfm->params.pixel_clock_max_khz) / 1000;
+
+	/* Determine the worst-case slow FRL Bit Rate in kbps*/
+	frl_bit_rate_min_kbps =
+		(frl_dfm->config.bit_rate_kbps / 1000000) * (1000000 - TOLERANCE_FRL_BIT_RATE);
+
+	/* Determine the worst-case slow FRL Character Rate */
+	frl_dfm->params.char_rate_min_kbps = frl_bit_rate_min_kbps / 18;
+
+	/* Character rate in mega chars/sec */
+	rate_m = DIV_ROUND_UP(frl_dfm->params.char_rate_min_kbps * frl_dfm->config.lanes, 1000);
+
+	/* Determine the Minimum Total FRL characters per line period */
+	frl_dfm->params.cfrl_line = DIV_ROUND_UP(frl_dfm->params.line_time_ns * rate_m,
+						 FRL_TIMING_NS_MULTIPLIER / 1000000);
+}
+
+/* Determine FRL link overhead */
+static void drm_frl_dfm_compute_max_frl_link_overhead(struct drm_hdmi_frl_dfm *frl_dfm)
+{
+	unsigned int overhead_min =
+		drm_get_total_minimum_overhead(frl_dfm->config.lanes);
+
+	/*
+	 * Additional margin to the overhead is provided to account for the possibility
+	 * of more Map Characters, zero padding at the end of HCactive, and other minor
+	 * items
+	 */
+	frl_dfm->params.overhead_max = overhead_min + OVERHEAD_M;
+}
+
+/* Audio support Verification computations */
+static void
+drm_frl_dfm_compute_audio_hblank_min(struct drm_hdmi_frl_dfm *frl_dfm)
+{
+	unsigned int num_audio_pkt, audio_pkt_rate;
+
+	/*
+	 * TBD: get the actual audio pkt type as described in
+	 * table 6.44 of HDMI2.1 spec to find the num_audio_pkt,
+	 * for now assume audio sample packet and audio packet
+	 * layout as 1, resulting in number of audio packets
+	 * required to carry each audio sample or audio frame
+	 * as 1
+	 */
+	num_audio_pkt = 1;
+
+	/*
+	 * Determine Audio Related Packet Rate considering the audio clock
+	 * increased to maximim rate permitted by Tolerance Audio clock
+	 */
+	audio_pkt_rate =
+		((frl_dfm->config.audio_hz *  num_audio_pkt + (2 * ACR_RATE_MAX)) *
+		 (1000000 + TOLERANCE_AUDIO_CLOCK)) / 1000000;
+
+	/*
+	 * Average required packets per line is
+	 * number of audio packets needed during Hblank
+	 */
+	frl_dfm->params.num_audio_pkts_line =
+		DIV_ROUND_UP(audio_pkt_rate * frl_dfm->params.line_time_ns,
+			     FRL_TIMING_NS_MULTIPLIER);
+
+	/*
+	 * Minimum required Hblank assuming no Control Period RC Compression
+	 * This includes Video Guard band, Two Island Guard bands, two 12 character
+	 * Control Periods and 32 * AudioPackets_Line.
+	 * In addition, 32 character periods are allocated for the transmission of an
+	 * ACR packet
+	 */
+	frl_dfm->params.hblank_audio_min = 32 + 32 * frl_dfm->params.num_audio_pkts_line;
+}
+
+/*
+ * Determine the number of tribytes required for active video , blanking period
+ * with the pixel configuration
+ */
+static void
+drm_frl_dfm_compute_tbactive_tbblank(struct drm_hdmi_frl_dfm *frl_dfm)
+{
+	unsigned int bpp, bytes_per_line;
+
+	bpp = drm_get_frl_bits_per_pixel(frl_dfm->config.color_format, frl_dfm->config.bpc);
+	bytes_per_line = (bpp * frl_dfm->config.hactive) / 8;
+
+	frl_dfm->params.tb_active = DIV_ROUND_UP(bytes_per_line, 3);
+
+	frl_dfm->params.tb_blank =
+		drm_get_blanking_tribytes_avail(frl_dfm->config.color_format,
+						frl_dfm->config.hblank,
+						frl_dfm->config.bpc);
+}
+
+/* Verify the configuration meets the capacity requirements for the FRL configuration*/
+static bool
+drm_frl_dfm_verify_frl_capacity_requirement(struct drm_hdmi_frl_dfm *frl_dfm)
+{
+	unsigned int tactive_ref_ns, tblank_ref_ns, tactive_min_ns, tblank_min_ns;
+	unsigned int tborrowed_ns;
+	unsigned int line_time_ns = frl_dfm->params.line_time_ns;
+	unsigned int hactive = frl_dfm->config.hactive;
+	unsigned int hblank = frl_dfm->config.hblank;
+
+	/* Determine the average tribyte rate in kilo tribytes per sec */
+	frl_dfm->params.ftb_avg_k =
+		(frl_dfm->params.pixel_clock_max_khz * (frl_dfm->params.tb_active + frl_dfm->params.tb_blank)) /
+		(frl_dfm->config.hactive + frl_dfm->config.hblank);
+
+	/*
+	 * Determine the time required to transmit the active portion of the
+	 * minimum possible active line period in the base timing
+	 */
+	tactive_ref_ns = (line_time_ns * hactive) / (hblank + hactive);
+
+	/*
+	 * Determine the time required to transmit the Video blanking portion
+	 * of the minimum possible active line period in the base timing
+	 */
+	tblank_ref_ns = (line_time_ns * hblank) / (hblank + hactive);
+
+	tactive_min_ns = drm_get_tactive_min(frl_dfm->config.lanes,
+					     frl_dfm->params.tb_active,
+					     frl_dfm->params.overhead_max,
+					     frl_dfm->params.char_rate_min_kbps);
+	tblank_min_ns = drm_get_tblank_min(frl_dfm->config.lanes,
+					   frl_dfm->params.tb_blank,
+					   frl_dfm->params.overhead_max,
+					   frl_dfm->params.char_rate_min_kbps);
+
+	if (tactive_ref_ns >= tactive_min_ns &&
+	    tblank_ref_ns >= tblank_min_ns) {
+		tborrowed_ns = 0;
+		frl_dfm->params.tb_borrowed = 0;
+
+		return true;
+	}
+
+	if (tactive_ref_ns < tactive_min_ns &&
+	    tblank_ref_ns >= tblank_min_ns) {
+		tborrowed_ns = tactive_min_ns - tactive_ref_ns;
+		/* Determine the disparity in tribytes */
+		frl_dfm->params.tb_borrowed =
+			DIV_ROUND_UP((tborrowed_ns * frl_dfm->params.ftb_avg_k * 1000),
+				     FRL_TIMING_NS_MULTIPLIER);
+
+		if (frl_dfm->params.tb_borrowed <= TB_BORROWED_MAX)
+			return true;
+	}
+
+	return false;
+}
+
+/* Verify utilization does not exceed capacity */
+static bool
+drm_frl_dfm_verify_utilization_possible(struct drm_hdmi_frl_dfm *frl_dfm)
+{
+	unsigned int cfrl_free, cfrl_savings, frl_char_payload_actual;
+	unsigned int utilization, margin;
+
+	cfrl_free = drm_get_num_char_rc_compressible(frl_dfm->config.color_format,
+						     frl_dfm->config.bpc,
+						     frl_dfm->params.num_audio_pkts_line,
+						     frl_dfm->config.hblank);
+	cfrl_savings = drm_get_num_char_compression_savings(cfrl_free);
+
+	/*
+	 * Determine the actual number of payload FRL characters required to
+	 * carry each video line
+	 */
+	frl_char_payload_actual =
+		DIV_ROUND_UP(3 * frl_dfm->params.tb_active, 2) +
+		frl_dfm->params.tb_blank - cfrl_savings;
+
+	/*
+	 * Determine the payload utilization of the total number of
+	 * FRL characters
+	 */
+	utilization = (frl_char_payload_actual * EFFICIENCY_MULTIPLIER) / frl_dfm->params.cfrl_line;
+
+	margin = 1000 - (utilization + frl_dfm->params.overhead_max);
+
+	if (margin > 0)
+		return true;
+
+	return false;
+}
+
+/* Check if DFM requirement is met */
+bool
+drm_frl_dfm_nondsc_requirement_met(struct drm_hdmi_frl_dfm *frl_dfm)
+{
+	bool frl_capacity_req_met;
+
+	drm_frl_dfm_compute_max_frl_link_overhead(frl_dfm);
+	drm_frl_dfm_compute_link_characteristics(frl_dfm);
+	drm_frl_dfm_compute_audio_hblank_min(frl_dfm);
+	drm_frl_dfm_compute_tbactive_tbblank(frl_dfm);
+
+	frl_capacity_req_met = drm_frl_dfm_verify_frl_capacity_requirement(frl_dfm);
+
+	if (frl_capacity_req_met)
+		return drm_frl_dfm_verify_utilization_possible(frl_dfm);
+
+	return false;
+}
+EXPORT_SYMBOL(drm_frl_dfm_nondsc_requirement_met);
diff --git a/include/drm/drm_frl_dfm_helper.h b/include/drm/drm_frl_dfm_helper.h
index a29a70a64a30..766728410a0b 100644
--- a/include/drm/drm_frl_dfm_helper.h
+++ b/include/drm/drm_frl_dfm_helper.h
@@ -121,4 +121,6 @@ struct drm_hdmi_frl_dfm {
 	struct drm_frl_dfm_params params;
 };
 
+bool drm_frl_dfm_nondsc_requirement_met(struct drm_hdmi_frl_dfm *frl_dfm);
+
 #endif
-- 
2.25.1

