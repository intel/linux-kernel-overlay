From 8156a449326ff729569467fe9d1a41dd04c47e7c Mon Sep 17 00:00:00 2001
From: Ranjan Dutta <ranjan.dutta@intel.com>
Date: Tue, 21 Sep 2021 12:30:21 +0800
Subject: [PATCH 08/30] Revert "drm/amdgpu/acp: Make PM domain really work"

This reverts commit 1f60072320b5f8071946e4b765cbf78a34d22a67.
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_acp.c | 54 +++++++++++++------------
 1 file changed, 28 insertions(+), 26 deletions(-)

diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_acp.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_acp.c
index eb68b0f1da82..d3e51d361179 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_acp.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_acp.c
@@ -160,28 +160,17 @@ static int acp_poweron(struct generic_pm_domain *genpd)
 	return 0;
 }
 
-static int acp_genpd_add_device(struct device *dev, void *data)
+static struct device *get_mfd_cell_dev(const char *device_name, int r)
 {
-	struct generic_pm_domain *gpd = data;
-	int ret;
+	char auto_dev_name[25];
+	struct device *dev;
 
-	ret = pm_genpd_add_device(gpd, dev);
-	if (ret)
-		dev_err(dev, "Failed to add dev to genpd %d\n", ret);
+	snprintf(auto_dev_name, sizeof(auto_dev_name),
+		 "%s.%d.auto", device_name, r);
+	dev = bus_find_device_by_name(&platform_bus_type, NULL, auto_dev_name);
+	dev_info(dev, "device %s added to pm domain\n", auto_dev_name);
 
-	return ret;
-}
-
-static int acp_genpd_remove_device(struct device *dev, void *data)
-{
-	int ret;
-
-	ret = pm_genpd_remove_device(dev);
-	if (ret)
-		dev_err(dev, "Failed to remove dev from genpd %d\n", ret);
-
-	/* Continue to remove */
-	return 0;
+	return dev;
 }
 
 /**
@@ -192,10 +181,11 @@ static int acp_genpd_remove_device(struct device *dev, void *data)
  */
 static int acp_hw_init(void *handle)
 {
-	int r;
+	int r, i;
 	uint64_t acp_base;
 	u32 val = 0;
 	u32 count = 0;
+	struct device *dev;
 	struct i2s_platform_data *i2s_pdata = NULL;
 
 	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
@@ -351,10 +341,15 @@ static int acp_hw_init(void *handle)
 	if (r)
 		goto failure;
 
-	r = device_for_each_child(adev->acp.parent, &adev->acp.acp_genpd->gpd,
-				  acp_genpd_add_device);
-	if (r)
-		goto failure;
+	for (i = 0; i < ACP_DEVS ; i++) {
+		dev = get_mfd_cell_dev(adev->acp.acp_cell[i].name, i);
+		r = pm_genpd_add_device(&adev->acp.acp_genpd->gpd, dev);
+		if (r) {
+			dev_err(dev, "Failed to add dev to genpd\n");
+			goto failure;
+		}
+	}
+
 
 	/* Assert Soft reset of ACP */
 	val = cgs_read_register(adev->acp.cgs_device, mmACP_SOFT_RESET);
@@ -415,8 +410,10 @@ static int acp_hw_init(void *handle)
  */
 static int acp_hw_fini(void *handle)
 {
+	int i, ret;
 	u32 val = 0;
 	u32 count = 0;
+	struct device *dev;
 	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	/* return early if no ACP */
@@ -461,8 +458,13 @@ static int acp_hw_fini(void *handle)
 		udelay(100);
 	}
 
-	device_for_each_child(adev->acp.parent, NULL,
-			      acp_genpd_remove_device);
+	for (i = 0; i < ACP_DEVS ; i++) {
+		dev = get_mfd_cell_dev(adev->acp.acp_cell[i].name, i);
+		ret = pm_genpd_remove_device(dev);
+		/* If removal fails, dont giveup and try rest */
+		if (ret)
+			dev_err(dev, "remove dev from genpd failed\n");
+	}
 
 	mfd_remove_devices(adev->acp.parent);
 	kfree(adev->acp.acp_res);
-- 
2.27.0

