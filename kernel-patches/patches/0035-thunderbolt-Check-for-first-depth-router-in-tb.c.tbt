From 89f1d593865c6bf169595409f5928048b77bc1c1 Mon Sep 17 00:00:00 2001
From: Mika Westerberg <mika.westerberg@linux.intel.com>
Date: Fri, 18 Nov 2022 15:26:12 +0200
Subject: [PATCH 35/51] thunderbolt: Check for first depth router in tb.c

Currently tb_switch_clx_enable() enables CL states only for the first
depth router. This is something we may want to change in the future and
in addition it is not visible from the calling path at all. For this
reason do the check in the tb.c so it is immediately visible that we
only do this for the first depth router. Fix the kernel-docs
accordingly.

Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
---
 drivers/thunderbolt/clx.c | 22 ++++++----------------
 drivers/thunderbolt/tb.c  | 10 ++++++++++
 2 files changed, 16 insertions(+), 16 deletions(-)

diff --git a/drivers/thunderbolt/clx.c b/drivers/thunderbolt/clx.c
index 4601607f1901..b8cfbd643311 100644
--- a/drivers/thunderbolt/clx.c
+++ b/drivers/thunderbolt/clx.c
@@ -257,14 +257,12 @@ static const char *clx_name(unsigned int clx)
  * @sw: Router to enable CLx for
  * @clx: The CLx state to enable
  *
- * Enable CLx state only for first hop router. That is the most common
- * use-case, that is intended for better thermal management, and so helps
- * to improve performance. CLx is enabled only if both sides of the link
- * support CLx, and if both sides of the link are not configured as two
- * single lane links and only if the link is not inter-domain link. The
- * complete set of conditions is described in CM Guide 1.0 section 8.1.
+ * CLx is enabled only if both sides of the link support CLx, and if both sides
+ * of the link are not configured as two single lane links and only if the link
+ * is not inter-domain link. The complete set of conditions is described in CM
+ * Guide 1.0 section 8.1.
  *
- * Return: Returns 0 on success or an error code on failure.
+ * Returns %0 on success or an error code on failure.
  */
 int tb_switch_clx_enable(struct tb_switch *sw, unsigned int clx)
 {
@@ -284,10 +282,6 @@ int tb_switch_clx_enable(struct tb_switch *sw, unsigned int clx)
 	    !tb_switch_clx_is_supported(sw))
 		return 0;
 
-	/* Enable CLx only for first hop router (depth = 1) */
-	if (tb_route(tb_switch_parent(sw)))
-		return 0;
-
 	/* CL2 is not yet supported */
 	if (clx & TB_CL2)
 		return -EOPNOTSUPP;
@@ -340,7 +334,7 @@ int tb_switch_clx_enable(struct tb_switch *sw, unsigned int clx)
  * Disables all CL states of the given router. Can be called on any
  * router and if the states were not enabled already does nothing.
  *
- * Return: Returns 0 on success or an error code on failure.
+ * Returns %0 on success or an error code on failure.
  */
 int tb_switch_clx_disable(struct tb_switch *sw)
 {
@@ -351,10 +345,6 @@ int tb_switch_clx_disable(struct tb_switch *sw)
 	if (!tb_switch_clx_is_supported(sw))
 		return 0;
 
-	/* Disable CLx only for first hop router (depth = 1) */
-	if (tb_route(tb_switch_parent(sw)))
-		return 0;
-
 	if (!clx)
 		return 0;
 
diff --git a/drivers/thunderbolt/tb.c b/drivers/thunderbolt/tb.c
index ff424495394a..375bcb574e66 100644
--- a/drivers/thunderbolt/tb.c
+++ b/drivers/thunderbolt/tb.c
@@ -244,6 +244,16 @@ static int tb_enable_clx(struct tb_switch *sw)
 {
 	int ret;
 
+	/*
+	 * Currently only enable CLx for the first link. This is enough
+	 * to allow the CPU to save energy at least on Intel hardware
+	 * and makes it slightly simpler to implement. We may change
+	 * this in the future to cover the whole topology if it turns
+	 * out to be beneficial.
+	 */
+	if (sw->config.depth != 1)
+		return 0;
+
 	/*
 	 * CL0s and CL1 are enabled and supported together.
 	 * Silently ignore CLx enabling in case CLx is not supported.
-- 
2.25.1

