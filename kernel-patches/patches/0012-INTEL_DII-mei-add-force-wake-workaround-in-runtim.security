From 13b215fd3e19eb51e92239553ea24140237288bc Mon Sep 17 00:00:00 2001
From: Alexander Usyskin <alexander.usyskin@intel.com>
Date: Thu, 6 Oct 2022 13:34:30 +0300
Subject: [PATCH 12/19] INTEL_DII: mei: add force wake workaround in runtime pm

Upon force wake assert the firmware goes into reset.
Take force wake in runtime pm to use autosuspend
timeout to eliminate back-to-back force wakes.

V2: jump to runtime pm force-wake if firmware
    is already awake

Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
Reviewed-by: Tomas Winkler <tomas.winkler@intel.com>
Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
---
 drivers/misc/mei/gsc-me.c | 20 +++++++++++++++++---
 drivers/misc/mei/hw-me.c  |  1 +
 2 files changed, 18 insertions(+), 3 deletions(-)

diff --git a/drivers/misc/mei/gsc-me.c b/drivers/misc/mei/gsc-me.c
index ecfd15ace4ce..bce5dacbce85 100644
--- a/drivers/misc/mei/gsc-me.c
+++ b/drivers/misc/mei/gsc-me.c
@@ -337,7 +337,7 @@ static const struct mei_hw_ops mei_gsc_hw_ops_null = {
 #define MEI_GSC_RESET_END_TIMEOUT 700
 #define MEI_GSC_RESET_STEP 20
 
-static int mei_gsc_forcewake_get_and_wait(struct mei_device *dev)
+static int mei_gsc_forcewake_get_and_wait(struct mei_device *dev, bool need_runtime_pm)
 {
 	struct mei_fw_status fw_status;
 	int timeout;
@@ -367,7 +367,7 @@ static int mei_gsc_forcewake_get_and_wait(struct mei_device *dev)
 
 	/* wait to FW going out of reset */
 	if (fw_status.status[0] & PCI_CFG_HFS_1_INITSTATE)
-		return 0;
+		goto runtime_pm;
 	for (timeout = MEI_GSC_RESET_END_TIMEOUT; timeout >= 0; timeout -= MEI_GSC_RESET_STEP) {
 		ret = mei_fw_status(dev, &fw_status);
 		if (ret) {
@@ -386,6 +386,16 @@ static int mei_gsc_forcewake_get_and_wait(struct mei_device *dev)
 		dev_err(dev->dev, "forcewake: FW not back from reset: %d\n", fw_status.status[0]);
 		return -ENODEV;
 	}
+
+runtime_pm:
+	if (need_runtime_pm) {
+		/*
+		 * Our runtime_pm configured to start as resumed.
+		 * Take additional forcewake and runtime pm to avoid RC6 while initializing
+		 */
+		dev->ops->forcewake_get(dev);
+		pm_runtime_get_noresume(dev->dev);
+	}
 	return 0;
 }
 
@@ -434,7 +444,7 @@ static int mei_gsc_probe(struct auxiliary_device *aux_dev,
 		dev->pxp_mode = MEI_DEV_PXP_INIT;
 	}
 
-	ret = mei_gsc_forcewake_get_and_wait(dev);
+	ret = mei_gsc_forcewake_get_and_wait(dev, true);
 	if (ret)
 		goto err;
 
@@ -585,6 +595,8 @@ static int  __maybe_unused mei_gsc_pm_runtime_suspend(struct device *device)
 
 		if (mei_me_hw_use_polling(hw))
 			hw->is_active = false;
+
+		mei_forcewake_put(dev);
 		ret = 0;
 	} else {
 		ret = -EAGAIN;
@@ -611,6 +623,8 @@ static int __maybe_unused mei_gsc_pm_runtime_resume(struct device *device)
 		wake_up(&hw->wait_active);
 	}
 
+	mei_forcewake_get(dev);
+
 	mutex_unlock(&dev->device_lock);
 
 	irq_ret = mei_me_irq_thread_handler(1, dev);
diff --git a/drivers/misc/mei/hw-me.c b/drivers/misc/mei/hw-me.c
index 8ae3814a788f..cf04f8899530 100644
--- a/drivers/misc/mei/hw-me.c
+++ b/drivers/misc/mei/hw-me.c
@@ -1423,6 +1423,7 @@ static int mei_me_hw_reset(struct mei_device *dev, bool intr_enable)
 			if (ret)
 				return ret;
 		}
+		mei_forcewake_put(dev);
 	}
 	return 0;
 }
-- 
2.25.1

