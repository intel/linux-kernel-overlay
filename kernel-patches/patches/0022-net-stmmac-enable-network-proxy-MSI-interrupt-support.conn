From 42fce83d172cd21e8d96a7974ce19fd3617bc5b2 Mon Sep 17 00:00:00 2001
From: Song Yoong Siang <yoong.siang.song@intel.com>
Date: Tue, 11 Jan 2022 16:37:11 +0800
Subject: [PATCH 22/54] net: stmmac: enable network proxy MSI interrupt support

Enabling network proxy MSI interrupt support for network
proxy.

Signed-off-by: Song Yoong Siang <yoong.siang.song@intel.com>
Signed-off-by: Noor Azura Ahmad Tarmizi <noor.azura.ahmad.tarmizi@intel.com>
---
 drivers/net/ethernet/stmicro/stmmac/common.h  |  3 +++
 .../net/ethernet/stmicro/stmmac/dwmac-intel.c |  9 +++++++
 drivers/net/ethernet/stmicro/stmmac/stmmac.h  | 10 ++++++-
 .../net/ethernet/stmicro/stmmac/stmmac_main.c | 27 +++++++++++++++++++
 include/linux/stmmac.h                        |  3 +++
 5 files changed, 51 insertions(+), 1 deletion(-)

diff --git a/drivers/net/ethernet/stmicro/stmmac/common.h b/drivers/net/ethernet/stmicro/stmmac/common.h
index 4f8948da325c..fd8af73ac704 100644
--- a/drivers/net/ethernet/stmicro/stmmac/common.h
+++ b/drivers/net/ethernet/stmicro/stmmac/common.h
@@ -335,6 +335,9 @@ enum dma_irq_dir {
 
 enum request_irq_err {
 	REQ_IRQ_ERR_ALL,
+#ifdef CONFIG_STMMAC_NETWORK_PROXY
+	REQ_IRQ_ERR_NETWORK_PROXY,
+#endif
 	REQ_IRQ_ERR_TX,
 	REQ_IRQ_ERR_RX,
 	REQ_IRQ_ERR_SFTY_UE,
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac-intel.c b/drivers/net/ethernet/stmicro/stmmac/dwmac-intel.c
index f95c142e1596..bd26a9bdf28a 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac-intel.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac-intel.c
@@ -1009,6 +1009,12 @@ static int stmmac_config_multi_msi(struct pci_dev *pdev,
 		res->sfty_ce_irq = pci_irq_vector(pdev, plat->msi_sfty_ce_vec);
 	if (plat->msi_sfty_ue_vec < STMMAC_MSI_VEC_MAX)
 		res->sfty_ue_irq = pci_irq_vector(pdev, plat->msi_sfty_ue_vec);
+#ifdef CONFIG_STMMAC_NETWORK_PROXY
+	if (plat->msi_network_proxy_vec < STMMAC_MSI_VEC_MAX &&
+	    plat->has_netproxy)
+		res->netprox_irq = pci_irq_vector(pdev,
+						  plat->msi_network_proxy_vec);
+#endif /* CONFIG_STMMAC_NETWORK_PROXY */
 
 	plat->multi_msi_en = 1;
 	dev_info(&pdev->dev, "%s: multi MSI enablement successful\n", __func__);
@@ -1091,6 +1097,9 @@ static int intel_eth_pci_probe(struct pci_dev *pdev,
 	plat->msi_sfty_ue_vec = STMMAC_MSI_VEC_MAX;
 	plat->msi_rx_base_vec = STMMAC_MSI_VEC_MAX;
 	plat->msi_tx_base_vec = STMMAC_MSI_VEC_MAX;
+#ifdef CONFIG_STMMAC_NETWORK_PROXY
+	plat->msi_network_proxy_vec = STMMAC_MSI_VEC_MAX;
+#endif /* CONFIG_STMMAC_NETWORK_PROXY */
 
 	ret = info->setup(pdev, plat);
 	if (ret)
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac.h b/drivers/net/ethernet/stmicro/stmmac/stmmac.h
index 90b7010abd11..0fee33c449dd 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac.h
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac.h
@@ -34,6 +34,9 @@ struct stmmac_resources {
 	int sfty_ue_irq;
 	int rx_irq[MTL_MAX_RX_QUEUES];
 	int tx_irq[MTL_MAX_TX_QUEUES];
+#ifdef CONFIG_STMMAC_NETWORK_PROXY
+	int netprox_irq;
+#endif
 };
 
 enum stmmac_txbuf_type {
@@ -278,6 +281,9 @@ struct stmmac_priv {
 	int sfty_ue_irq;
 	int rx_irq[MTL_MAX_RX_QUEUES];
 	int tx_irq[MTL_MAX_TX_QUEUES];
+#ifdef CONFIG_STMMAC_NETWORK_PROXY
+	int netprox_irq;
+#endif
 	/*irq name */
 	char int_name_mac[IFNAMSIZ + 9];
 	char int_name_wol[IFNAMSIZ + 9];
@@ -286,7 +292,9 @@ struct stmmac_priv {
 	char int_name_sfty_ue[IFNAMSIZ + 10];
 	char int_name_rx_irq[MTL_MAX_TX_QUEUES][IFNAMSIZ + 14];
 	char int_name_tx_irq[MTL_MAX_TX_QUEUES][IFNAMSIZ + 18];
-
+#ifdef CONFIG_STMMAC_NETWORK_PROXY
+	char int_name_netprox_irq[IFNAMSIZ + 9];
+#endif
 	/* WA for skipping disabling EST during TAPRIO deletion */
 	bool est_hw_del_wa;
 
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
index 283e3d11ee49..8fcd41653ce8 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
@@ -3465,6 +3465,12 @@ static void stmmac_free_irq(struct net_device *dev,
 
 	switch (irq_err) {
 	case REQ_IRQ_ERR_ALL:
+#ifdef CONFIG_STMMAC_NETWORK_PROXY
+		if (priv->netprox_irq > 0 && priv->netprox_irq != dev->irq)
+			free_irq(priv->netprox_irq, dev);
+		fallthrough;
+	case REQ_IRQ_ERR_NETWORK_PROXY:
+#endif
 		irq_idx = priv->plat->tx_queues_to_use;
 		fallthrough;
 	case REQ_IRQ_ERR_TX:
@@ -3650,6 +3656,24 @@ static int stmmac_request_irq_multi_msi(struct net_device *dev)
 		irq_set_affinity_hint(priv->tx_irq[i], &cpu_mask);
 	}
 
+#ifdef CONFIG_STMMAC_NETWORK_PROXY
+		/* Network Proxy IRQ line */
+		if (priv->netprox_irq > 0 && priv->netprox_irq != dev->irq) {
+			int_name = priv->int_name_netprox_irq;
+			sprintf(int_name, "%s:%s", dev->name, "netprox");
+			ret = request_threaded_irq(priv->netprox_irq,
+						   netproxy_isr,
+						   netproxy_isr_thread, 0,
+						   int_name, dev);
+			if (unlikely(ret < 0)) {
+				netdev_err(priv->dev,
+					   "%s: alloc netprox MSI %d (error: %d)\n",
+					   __func__, priv->netprox_irq, ret);
+				irq_err = REQ_IRQ_ERR_NETWORK_PROXY;
+				goto irq_error;
+			}
+		}
+#endif
 	return 0;
 
 irq_error:
@@ -7109,6 +7133,9 @@ int stmmac_dvr_probe(struct device *device,
 		priv->rx_irq[i] = res->rx_irq[i];
 	for (i = 0; i < MTL_MAX_TX_QUEUES; i++)
 		priv->tx_irq[i] = res->tx_irq[i];
+#ifdef CONFIG_STMMAC_NETWORK_PROXY
+	priv->netprox_irq = res->netprox_irq;
+#endif
 
 	if (!is_zero_ether_addr(res->mac))
 		memcpy(priv->dev->dev_addr, res->mac, ETH_ALEN);
diff --git a/include/linux/stmmac.h b/include/linux/stmmac.h
index 0e443729ee55..18d4d736514f 100644
--- a/include/linux/stmmac.h
+++ b/include/linux/stmmac.h
@@ -274,6 +274,9 @@ struct plat_stmmacenet_data {
 	int msi_sfty_ue_vec;
 	int msi_rx_base_vec;
 	int msi_tx_base_vec;
+#ifdef CONFIG_STMMAC_NETWORK_PROXY
+	int msi_network_proxy_vec;
+#endif
 	bool use_phy_wol;
 	bool sph_disable;
 	bool skip_xpcs_reset;
-- 
2.25.1

