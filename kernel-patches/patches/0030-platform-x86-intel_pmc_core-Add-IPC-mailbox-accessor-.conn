From f129150d65200d6eb4147c3477d005268e653bd6 Mon Sep 17 00:00:00 2001
From: "David E. Box" <david.e.box@linux.intel.com>
Date: Wed, 9 Feb 2022 18:14:00 +0800
Subject: [PATCH 30/54] platform/x86: intel_pmc_core: Add IPC mailbox accessor
 function

Exports pmc_core_ipc() for host access to the PMC IPC mailbox

Signed-off-by: David E. Box <david.e.box@linux.intel.com>
Signed-off-by: Chao Qin <chao.qin@intel.com>
---
 MAINTAINERS                                   |  1 +
 drivers/platform/x86/intel/pmc/core.c         | 68 ++++++++++++++++++-
 .../core.h => include/linux/intel_pmc_core.h  | 27 ++++++++
 3 files changed, 95 insertions(+), 1 deletion(-)
 rename drivers/platform/x86/intel/pmc/core.h => include/linux/intel_pmc_core.h (94%)

diff --git a/MAINTAINERS b/MAINTAINERS
index abf770a29006..0939bf322ec1 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -9699,6 +9699,7 @@ L:	platform-driver-x86@vger.kernel.org
 S:	Maintained
 F:	Documentation/ABI/testing/sysfs-platform-intel-pmc
 F:	drivers/platform/x86/intel/pmc/
+F:	include/linux/intel_pmc_core*
 
 INTEL PMIC GPIO DRIVERS
 M:	Andy Shevchenko <andy@kernel.org>
diff --git a/drivers/platform/x86/intel/pmc/core.c b/drivers/platform/x86/intel/pmc/core.c
index abb54b0b12ae..44d67a7eedb8 100644
--- a/drivers/platform/x86/intel/pmc/core.c
+++ b/drivers/platform/x86/intel/pmc/core.c
@@ -17,6 +17,7 @@
 #include <linux/delay.h>
 #include <linux/dmi.h>
 #include <linux/io.h>
+#include <linux/intel_pmc_core.h>
 #include <linux/module.h>
 #include <linux/pci.h>
 #include <linux/platform_device.h>
@@ -31,7 +32,9 @@
 #include <asm/msr.h>
 #include <asm/tsc.h>
 
-#include "core.h"
+#define PMC_IPCS_PARAM_COUNT           7
+
+static const struct x86_cpu_id *pmc_cpu_id;
 
 #define ACPI_S0IX_DSM_UUID		"57a6512e-3979-4e9d-9708-ff13b2508972"
 #define ACPI_GET_LOW_MODE_REGISTERS	1
@@ -598,6 +601,67 @@ static const struct pmc_reg_map tgl_reg_map = {
 	.etr3_offset = ETR3_OFFSET,
 };
 
+int intel_pmc_core_ipc(struct pmc_ipc_cmd *ipc_cmd, u32 *rbuf)
+{
+	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+	union acpi_object params[PMC_IPCS_PARAM_COUNT] = {
+		{.type = ACPI_TYPE_INTEGER,},
+		{.type = ACPI_TYPE_INTEGER,},
+		{.type = ACPI_TYPE_INTEGER,},
+		{.type = ACPI_TYPE_INTEGER,},
+		{.type = ACPI_TYPE_INTEGER,},
+		{.type = ACPI_TYPE_INTEGER,},
+		{.type = ACPI_TYPE_INTEGER,},
+	};
+	struct acpi_object_list arg_list = { PMC_IPCS_PARAM_COUNT, params };
+	union acpi_object *obj;
+	int status;
+
+	/* check the platform is Elkhart Lake */
+	if (!pmc_cpu_id)
+		return -EINVAL;
+
+	if (!ipc_cmd || !rbuf)
+		return -EINVAL;
+
+	/*
+	 * 0: IPC Command
+	 * 1: IPC Sub Command
+	 * 2: Size
+	 * 3-6: Write Buffer for offset
+	 */
+	params[0].integer.value = ipc_cmd->cmd;
+	params[1].integer.value = ipc_cmd->sub_cmd;
+	params[2].integer.value = ipc_cmd->size;
+	params[3].integer.value = ipc_cmd->wbuf[0];
+	params[4].integer.value = ipc_cmd->wbuf[1];
+	params[5].integer.value = ipc_cmd->wbuf[2];
+	params[6].integer.value = ipc_cmd->wbuf[3];
+
+	status = acpi_evaluate_object(NULL, "\\IPCS", &arg_list, &buffer);
+	if (ACPI_FAILURE(status))
+		return -ENODEV;
+
+	obj = buffer.pointer;
+	/* Check if the number of elements in package is 5 */
+	if (obj && obj->type == ACPI_TYPE_PACKAGE && obj->package.count == 5) {
+		const union acpi_object *objs = obj->package.elements;
+
+		if ((u8)objs[0].integer.value != 0)
+			return -EINVAL;
+
+		rbuf[0] = objs[1].integer.value;
+		rbuf[1] = objs[2].integer.value;
+		rbuf[2] = objs[3].integer.value;
+		rbuf[3] = objs[4].integer.value;
+	} else {
+		return -EINVAL;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(intel_pmc_core_ipc);
+
 static void pmc_core_get_tgl_lpm_reqs(struct platform_device *pdev)
 {
 	struct pmc_dev *pmcdev = platform_get_drvdata(pdev);
@@ -1997,6 +2061,8 @@ static int pmc_core_probe(struct platform_device *pdev)
 	if (pmcdev->map == &spt_reg_map && !pci_dev_present(pmc_pci_ids))
 		pmcdev->map = &cnp_reg_map;
 
+	pmc_cpu_id = cpu_id;
+
 	if (lpit_read_residency_count_address(&slp_s0_addr)) {
 		pmcdev->base_addr = PMC_BASE_ADDR_DEFAULT;
 
diff --git a/drivers/platform/x86/intel/pmc/core.h b/include/linux/intel_pmc_core.h
similarity index 94%
rename from drivers/platform/x86/intel/pmc/core.h
rename to include/linux/intel_pmc_core.h
index a46d3b53bf61..9ac94ea14f35 100644
--- a/drivers/platform/x86/intel/pmc/core.h
+++ b/include/linux/intel_pmc_core.h
@@ -248,6 +248,17 @@ const char *pmc_lpm_modes[] = {
 	NULL
 };
 
+#define IPC_PMC_REGISTER_ACCESS			0xAB
+#define IPC_PMC_SUB_CMD_READ			0x00
+#define IPC_PMC_SUB_CMD_WRITE			0x01
+
+struct pmc_ipc_cmd {
+	u32 cmd;
+	u32 sub_cmd;
+	u32 size;
+	u32 wbuf[4];
+};
+
 struct pmc_bit_map {
 	const char *name;
 	u32 bit_mask;
@@ -360,4 +371,20 @@ static const struct file_operations __name ## _fops = {			\
 	.release	= single_release,				\
 }
 
+#if IS_ENABLED(CONFIG_INTEL_PMC_CORE)
+/*
+ * intel_pmc_core_ipc() - PMC IPC Mailbox accessor
+ * @ipc_cmd:  struct pmc_ipc_cmd prepared with input to send
+ * @rbuf:     Allocated u32[4] array for returned IPC data
+ *
+ * Return: 0 on success. Non-zero on mailbox error
+ */
+int intel_pmc_core_ipc(struct pmc_ipc_cmd *ipc_cmd, u32 *rbuf);
+#else
+static inline int intel_pmc_core_get_ipcs(struct pmc_ipc_cmd *ipc_cmd, u32 *rbuf)
+{
+	return -ENODEV;
+}
+#endif
+
 #endif /* PMC_CORE_H */
-- 
2.25.1

