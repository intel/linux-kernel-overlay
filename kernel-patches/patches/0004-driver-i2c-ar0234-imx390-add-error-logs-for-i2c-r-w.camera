From f4a837acbd7891ab4d2846568f1c31227748911a Mon Sep 17 00:00:00 2001
From: Chen Meng J <meng.j.chen@intel.com>
Date: Tue, 8 Aug 2023 13:24:38 +0800
Subject: [PATCH 04/20] driver: i2c: ar0234: imx390: add error logs for i2c r&w

Signed-off-by: Ng Khai Wen <khai.wen.ng@intel.com>
Signed-off-by: zouxiaoh <xiaohong.zou@intel.com>
Signed-off-by: Chen Meng J <meng.j.chen@intel.com>
---
 drivers/media/i2c/ar0234.c | 22 +++++++++++++++++-----
 drivers/media/i2c/imx390.c | 22 +++++++++++++++++-----
 2 files changed, 34 insertions(+), 10 deletions(-)

diff --git a/drivers/media/i2c/ar0234.c b/drivers/media/i2c/ar0234.c
index bb6100987a23..ae45c5d00e0a 100644
--- a/drivers/media/i2c/ar0234.c
+++ b/drivers/media/i2c/ar0234.c
@@ -1,5 +1,5 @@
 // SPDX-License-Identifier: GPL-2.0
-// Copyright (c) 2023 Intel Corporation.
+// Copyright (c) 2019-2023 Intel Corporation.
 
 #include <asm/unaligned.h>
 #include <linux/acpi.h>
@@ -1379,8 +1379,11 @@ static int ar0234_read_reg(struct ar0234 *ar0234, u16 reg, u16 len, u32 *val)
 	u8 data_buf[4] = {0};
 	int ret;
 
-	if (len > 4)
+	if (len > 4) {
+		dev_err(&client->dev, "%s: invalid length %d. i2c read register failed\n",
+			__func__, len);
 		return -EINVAL;
+	}
 
 	put_unaligned_be16(reg, addr_buf);
 	msgs[0].addr = client->addr;
@@ -1393,8 +1396,11 @@ static int ar0234_read_reg(struct ar0234 *ar0234, u16 reg, u16 len, u32 *val)
 	msgs[1].buf = &data_buf[4 - len];
 
 	ret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));
-	if (ret != ARRAY_SIZE(msgs))
+	if (ret != ARRAY_SIZE(msgs)) {
+		dev_err(&client->dev, "%s: i2c read register 0x%x from 0x%x failed\n",
+			__func__, reg, client->addr);
 		return -EIO;
+	}
 
 	*val = get_unaligned_be32(data_buf);
 
@@ -1411,12 +1417,18 @@ static int ar0234_write_reg(struct ar0234 *ar0234, u16 reg, u16 len, u32 val)
 		return 0;
 	}
 
-	if (len > 4)
+	if (len > 4) {
+		dev_err(&client->dev, "%s: invalid length %d. i2c write register failed\n",
+			__func__, len);
 		return -EINVAL;
+	}
 
 	put_unaligned_be16(reg, buf);
 	put_unaligned_be32(val << 8 * (4 - len), buf + 2);
-	if (i2c_master_send(client, buf, len + 2) != len + 2)
+	if (i2c_master_send(client, buf, len + 2) != len + 2) {
+		dev_err(&client->dev, "%s: i2c write register 0x%x from 0x%x failed\n",
+			__func__, reg, client->addr);
+	}
 		return -EIO;
 
 	return 0;
diff --git a/drivers/media/i2c/imx390.c b/drivers/media/i2c/imx390.c
index c656b3cbefee..26ff69780b8f 100644
--- a/drivers/media/i2c/imx390.c
+++ b/drivers/media/i2c/imx390.c
@@ -1,5 +1,5 @@
 // SPDX-License-Identifier: GPL-2.0
-// Copyright (c) 2022 Intel Corporation.
+// Copyright (c) 2021-2023 Intel Corporation.
 
 #include <asm/unaligned.h>
 #include <linux/acpi.h>
@@ -1077,8 +1077,11 @@ static int imx390_read_reg(struct imx390 *imx390, u16 reg, u16 len, u32 *val)
 	u8 data_buf[4] = {0};
 	int ret;
 
-	if (len > 4)
+	if (len > 4) {
+		dev_err(&client->dev, "%s: invalid length %d. i2c read register failed\n",
+			__func__, len);
 		return -EINVAL;
+	}
 
 	put_unaligned_be16(reg, addr_buf);
 	msgs[0].addr = client->addr;
@@ -1091,8 +1094,11 @@ static int imx390_read_reg(struct imx390 *imx390, u16 reg, u16 len, u32 *val)
 	msgs[1].buf = &data_buf[4 - len];
 
 	ret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));
-	if (ret != ARRAY_SIZE(msgs))
+	if (ret != ARRAY_SIZE(msgs)) {
+		dev_err(&client->dev, "%s: i2c read register 0x%x from 0x%x failed\n",
+			__func__, reg, client->addr);
 		return -EIO;
+	}
 
 	*val = get_unaligned_be32(data_buf);
 
@@ -1104,14 +1110,20 @@ static int imx390_write_reg(struct imx390 *imx390, u16 reg, u16 len, u32 val)
 	struct i2c_client *client = v4l2_get_subdevdata(&imx390->sd);
 	u8 buf[6];
 
-	if (len > 4)
+	if (len > 4) {
+		dev_err(&client->dev, "%s: invalid length %d. i2c write register failed\n",
+			__func__, len);
 		return -EINVAL;
+	}
 
 	dev_dbg(&client->dev, "%s, reg %x len %x, val %x\n", __func__, reg, len, val);
 	put_unaligned_be16(reg, buf);
 	put_unaligned_be32(val << 8 * (4 - len), buf + 2);
-	if (i2c_master_send(client, buf, len + 2) != len + 2)
+	if (i2c_master_send(client, buf, len + 2) != len + 2) {
+		dev_err(&client->dev, "%s: i2c write register 0x%x from 0x%x failed\n",
+			__func__, reg, client->addr);
 		return -EIO;
+	}
 
 	return 0;
 }
-- 
2.25.1

