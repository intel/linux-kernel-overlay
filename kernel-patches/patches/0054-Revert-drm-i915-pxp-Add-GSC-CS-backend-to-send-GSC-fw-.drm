From f814005d639ea570dd328126db5618ee19950058 Mon Sep 17 00:00:00 2001
From: Junxiao Chang <junxiao.chang@intel.com>
Date: Thu, 6 Jul 2023 15:03:02 +0800
Subject: [PATCH 0054/2351] Revert "drm/i915/pxp: Add GSC-CS backend to send
 GSC fw messages"

This reverts commit 078a945b3a1bf926b1431caf4f1254828e2f597f.
---
 .../drm/i915/pxp/intel_pxp_cmd_interface_43.h |   4 -
 drivers/gpu/drm/i915/pxp/intel_pxp_gsccs.c    | 174 +-----------------
 drivers/gpu/drm/i915/pxp/intel_pxp_types.h    |   6 -
 3 files changed, 1 insertion(+), 183 deletions(-)

diff --git a/drivers/gpu/drm/i915/pxp/intel_pxp_cmd_interface_43.h b/drivers/gpu/drm/i915/pxp/intel_pxp_cmd_interface_43.h
index b2523d6918c77..ad67e3f49c207 100644
--- a/drivers/gpu/drm/i915/pxp/intel_pxp_cmd_interface_43.h
+++ b/drivers/gpu/drm/i915/pxp/intel_pxp_cmd_interface_43.h
@@ -12,10 +12,6 @@
 /* PXP-Cmd-Op definitions */
 #define PXP43_CMDID_START_HUC_AUTH 0x0000003A
 
-/* PXP-Packet sizes for MTL's GSCCS-HECI instruction */
-#define PXP43_MAX_HECI_IN_SIZE (SZ_32K)
-#define PXP43_MAX_HECI_OUT_SIZE (SZ_32K)
-
 /* PXP-Input-Packet: HUC-Authentication */
 struct pxp43_start_huc_auth_in {
 	struct pxp_cmd_header header;
diff --git a/drivers/gpu/drm/i915/pxp/intel_pxp_gsccs.c b/drivers/gpu/drm/i915/pxp/intel_pxp_gsccs.c
index 35b6bfa55dfcc..b304864902c89 100644
--- a/drivers/gpu/drm/i915/pxp/intel_pxp_gsccs.c
+++ b/drivers/gpu/drm/i915/pxp/intel_pxp_gsccs.c
@@ -6,154 +6,12 @@
 #include "gem/i915_gem_internal.h"
 
 #include "gt/intel_context.h"
-#include "gt/uc/intel_gsc_uc_heci_cmd_submit.h"
 
 #include "i915_drv.h"
 #include "intel_pxp_cmd_interface_43.h"
 #include "intel_pxp_gsccs.h"
 #include "intel_pxp_types.h"
 
-__maybe_unused
-static int gsccs_send_message(struct intel_pxp *pxp,
-			      void *msg_in, size_t msg_in_size,
-			      void *msg_out, size_t msg_out_size_max,
-			      size_t *msg_out_len)
-{
-	struct intel_gt *gt = pxp->ctrl_gt;
-	struct drm_i915_private *i915 = gt->i915;
-	struct gsccs_session_resources *exec =  &pxp->gsccs_res;
-	struct intel_gsc_mtl_header *header = exec->pkt_vaddr;
-	struct intel_gsc_heci_non_priv_pkt pkt;
-	size_t max_msg_size;
-	u32 reply_size;
-	int ret;
-
-	if (!exec->ce)
-		return -ENODEV;
-
-	max_msg_size = PXP43_MAX_HECI_IN_SIZE - sizeof(*header);
-
-	if (msg_in_size > max_msg_size || msg_out_size_max > max_msg_size)
-		return -ENOSPC;
-
-	mutex_lock(&pxp->tee_mutex);
-
-	if (!exec->pkt_vma || !exec->bb_vma)
-		return -ENOENT;
-
-	memset(header, 0, sizeof(*header));
-	intel_gsc_uc_heci_cmd_emit_mtl_header(header, GSC_HECI_MEADDRESS_PXP,
-					      msg_in_size + sizeof(*header),
-					      exec->host_session_handle);
-
-	memcpy(exec->pkt_vaddr + sizeof(*header), msg_in, msg_in_size);
-
-	pkt.addr_in = i915_vma_offset(exec->pkt_vma);
-	pkt.size_in = header->message_size;
-	pkt.addr_out = pkt.addr_in + PXP43_MAX_HECI_IN_SIZE;
-	pkt.size_out = msg_out_size_max + sizeof(*header);
-	pkt.heci_pkt_vma = exec->pkt_vma;
-	pkt.bb_vma = exec->bb_vma;
-
-	ret = intel_gsc_uc_heci_cmd_submit_nonpriv(&gt->uc.gsc,
-						   exec->ce, &pkt, exec->bb_vaddr, 500);
-	if (ret) {
-		drm_err(&i915->drm, "failed to send gsc PXP msg (%d)\n", ret);
-		goto unlock;
-	}
-
-	/* we keep separate location for reply, so get the response header loc first */
-	header = exec->pkt_vaddr + PXP43_MAX_HECI_IN_SIZE;
-
-	/* Response validity marker, status and busyness */
-	if (header->validity_marker != GSC_HECI_VALIDITY_MARKER) {
-		drm_err(&i915->drm, "gsc PXP reply with invalid validity marker\n");
-		ret = -EINVAL;
-		goto unlock;
-	}
-	if (header->status != 0) {
-		drm_dbg(&i915->drm, "gsc PXP reply status has error = 0x%08x\n",
-			header->status);
-		ret = -EINVAL;
-		goto unlock;
-	}
-	if (header->flags & GSC_HECI_FLAG_MSG_PENDING) {
-		drm_dbg(&i915->drm, "gsc PXP reply is busy\n");
-		ret = -EAGAIN;
-		goto unlock;
-	}
-
-	reply_size = header->message_size - sizeof(*header);
-	if (reply_size > msg_out_size_max) {
-		drm_warn(&i915->drm, "caller with insufficient PXP reply size %u (%ld)\n",
-			 reply_size, msg_out_size_max);
-		reply_size = msg_out_size_max;
-	} else if (reply_size != msg_out_size_max) {
-		drm_dbg(&i915->drm, "caller unexpected PXP reply size %u (%ld)\n",
-			reply_size, msg_out_size_max);
-	}
-
-	memcpy(msg_out, exec->pkt_vaddr + PXP43_MAX_HECI_IN_SIZE + sizeof(*header),
-	       reply_size);
-	if (msg_out_len)
-		*msg_out_len = reply_size;
-
-unlock:
-	mutex_unlock(&pxp->tee_mutex);
-	return ret;
-}
-
-static int
-gsccs_create_buffer(struct intel_gt *gt,
-		    const char *bufname, size_t size,
-		    struct i915_vma **vma, void **map)
-{
-	struct drm_i915_private *i915 = gt->i915;
-	struct drm_i915_gem_object *obj;
-	int err = 0;
-
-	obj = i915_gem_object_create_internal(i915, size);
-	if (IS_ERR(obj)) {
-		drm_err(&i915->drm, "Failed to allocate gsccs backend %s.\n", bufname);
-		err = PTR_ERR(obj);
-		goto out_none;
-	}
-
-	*vma = i915_vma_instance(obj, gt->vm, NULL);
-	if (IS_ERR(*vma)) {
-		drm_err(&i915->drm, "Failed to vma-instance gsccs backend %s.\n", bufname);
-		err = PTR_ERR(*vma);
-		goto out_put;
-	}
-
-	/* return a virtual pointer */
-	*map = i915_gem_object_pin_map_unlocked(obj, i915_coherent_map_type(i915, obj, true));
-	if (IS_ERR(*map)) {
-		drm_err(&i915->drm, "Failed to map gsccs backend %s.\n", bufname);
-		err = PTR_ERR(*map);
-		goto out_put;
-	}
-
-	/* all PXP sessions commands are treated as non-priveleged */
-	err = i915_vma_pin(*vma, 0, 0, PIN_USER);
-	if (err) {
-		drm_err(&i915->drm, "Failed to vma-pin gsccs backend %s.\n", bufname);
-		goto out_unmap;
-	}
-
-	return 0;
-
-out_unmap:
-	i915_gem_object_unpin_map(obj);
-out_put:
-	i915_gem_object_put(obj);
-out_none:
-	*vma = NULL;
-	*map = NULL;
-
-	return err;
-}
-
 static void
 gsccs_destroy_execution_resource(struct intel_pxp *pxp)
 {
@@ -161,10 +19,6 @@ gsccs_destroy_execution_resource(struct intel_pxp *pxp)
 
 	if (strm_res->ce)
 		intel_context_put(strm_res->ce);
-	if (strm_res->bb_vma)
-		i915_vma_unpin_and_release(&strm_res->bb_vma, I915_VMA_RELEASE_MAP);
-	if (strm_res->pkt_vma)
-		i915_vma_unpin_and_release(&strm_res->pkt_vma, I915_VMA_RELEASE_MAP);
 
 	memset(strm_res, 0, sizeof(*strm_res));
 }
@@ -176,7 +30,6 @@ gsccs_allocate_execution_resource(struct intel_pxp *pxp)
 	struct gsccs_session_resources *strm_res = &pxp->gsccs_res;
 	struct intel_engine_cs *engine = gt->engine[GSC0];
 	struct intel_context *ce;
-	int err = 0;
 
 	/*
 	 * First, ensure the GSC engine is present.
@@ -187,28 +40,11 @@ gsccs_allocate_execution_resource(struct intel_pxp *pxp)
 
 	mutex_init(&pxp->tee_mutex);
 
-	/*
-	 * Now, allocate, pin and map two objects, one for the heci message packet
-	 * and another for the batch buffer we submit into GSC engine (that includes the packet).
-	 * NOTE: GSC-CS backend is currently only supported on MTL, so we allocate shmem.
-	 */
-	err = gsccs_create_buffer(pxp->ctrl_gt, "Heci Packet",
-				  PXP43_MAX_HECI_IN_SIZE + PXP43_MAX_HECI_OUT_SIZE,
-				  &strm_res->pkt_vma, &strm_res->pkt_vaddr);
-	if (err)
-		return err;
-
-	err = gsccs_create_buffer(pxp->ctrl_gt, "Batch Buffer", PAGE_SIZE,
-				  &strm_res->bb_vma, &strm_res->bb_vaddr);
-	if (err)
-		goto free_pkt;
-
 	/* Finally, create an intel_context to be used during the submission */
 	ce = intel_context_create(engine);
 	if (IS_ERR(ce)) {
 		drm_err(&gt->i915->drm, "Failed creating gsccs backend ctx\n");
-		err = PTR_ERR(ce);
-		goto free_batch;
+		return PTR_ERR(ce);
 	}
 	i915_vm_put(ce->vm);
 	ce->vm = i915_vm_get(pxp->ctrl_gt->vm);
@@ -216,14 +52,6 @@ gsccs_allocate_execution_resource(struct intel_pxp *pxp)
 	strm_res->ce = ce;
 
 	return 0;
-
-free_pkt:
-	i915_vma_unpin_and_release(&strm_res->pkt_vma, I915_VMA_RELEASE_MAP);
-free_batch:
-	i915_vma_unpin_and_release(&strm_res->bb_vma, I915_VMA_RELEASE_MAP);
-	memset(strm_res, 0, sizeof(*strm_res));
-
-	return err;
 }
 
 void intel_pxp_gsccs_fini(struct intel_pxp *pxp)
diff --git a/drivers/gpu/drm/i915/pxp/intel_pxp_types.h b/drivers/gpu/drm/i915/pxp/intel_pxp_types.h
index 73392fbab7ee9..fdd98911968dc 100644
--- a/drivers/gpu/drm/i915/pxp/intel_pxp_types.h
+++ b/drivers/gpu/drm/i915/pxp/intel_pxp_types.h
@@ -38,12 +38,6 @@ struct intel_pxp {
 	struct gsccs_session_resources {
 		u64 host_session_handle; /* used by firmware to link commands to sessions */
 		struct intel_context *ce; /* context for gsc command submission */
-
-		struct i915_vma *pkt_vma; /* GSC FW cmd packet vma */
-		void *pkt_vaddr;  /* GSC FW cmd packet virt pointer */
-
-		struct i915_vma *bb_vma; /* HECI_PKT batch buffer vma */
-		void *bb_vaddr; /* HECI_PKT batch buffer virt pointer */
 	} gsccs_res;
 
 	/**
-- 
2.25.1

