From f948cfd989e5d7963de9dca6ca15bbf9f31c041e Mon Sep 17 00:00:00 2001
From: Mathias Nyman <mathias.nyman@linux.intel.com>
Date: Tue, 29 Nov 2022 15:39:25 +0200
Subject: [PATCH 19/21] usb: acpi: add Intel specific port LPM capability
 checker

Intel Type-C USB4 ports have retimers designed for USB4, which cause too
long latency for native USB 3 LPM (link power management) U1 U2
link states.

Normally USB 3 LPM incapable ports are identified in ACPI by their _DSM
method, but some platforms with Intel hosts lack the port _DSM method.

In these cases find LPM incapable ports by checking ACPI _UPC
(USB Port Capabilities) entry if port is a USB4 Type-C port with retimer.

Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
---
 drivers/usb/core/usb-acpi.c | 54 +++++++++++++++++++++++++++++++++++++
 include/linux/usb.h         |  3 +++
 2 files changed, 57 insertions(+)

diff --git a/drivers/usb/core/usb-acpi.c b/drivers/usb/core/usb-acpi.c
index 82bf9d3659fa..4ce073d2d93b 100644
--- a/drivers/usb/core/usb-acpi.c
+++ b/drivers/usb/core/usb-acpi.c
@@ -102,6 +102,60 @@ int usb_acpi_port_lpm_incapable(struct usb_device *hdev, int index)
 }
 EXPORT_SYMBOL_GPL(usb_acpi_port_lpm_incapable);
 
+/**
+ * usb_acpi_intel_port_lpm_incapable - check if LPM should be disabled for a port.
+ * @hdev: USB device belonging to the hub
+ * @index: zero based port index
+ *
+ * Intel Type-C USB4 ports have retimers designed for USB4, which cause too
+ * long latency for native USB 3 LPM U1 U2 usage.
+ * Normally USB 3 LPM incapable ports are identified in ACPI by their _DSM
+ * return value, but some of the platforms lack the _DSM method.
+ * Check _UPC values to find USB4 Type-c ports with retimers in case _DSM is
+ * missing
+ *
+ * Return 1 if USB3 port is LPM incapable, negative on error, otherwise 0
+ */
+
+int usb_acpi_intel_port_lpm_incapable(struct usb_device *hdev, int index)
+{
+	struct acpi_upc_info *upc;
+	acpi_handle port_handle;
+	int port1 = index + 1;
+	acpi_status status;
+	int ret;
+
+	ret = usb_acpi_port_lpm_incapable(hdev, index);
+
+	if (ret >= 0)
+		return ret;
+	/*
+	 * No _DSM found above, check _UPC instead. USB4 capable type-c ports
+	 * on Intel hosts don't support native USB 3 lpm.
+	 */
+
+	ret = 0;
+	port_handle = usb_get_hub_port_acpi_handle(hdev, port1);
+	if (!port_handle) {
+		dev_dbg(&hdev->dev, "port-%d has no acpi handle\n", port1);
+		return -ENODEV;
+	}
+
+	status = acpi_get_usb_port_capabilities(port_handle, &upc);
+	if (ACPI_FAILURE(status))
+		return -ENODEV;
+
+	if ((upc->type == ACPI_UPC_TYPE_USBC_SS_SWITCH ||
+	     upc->type == ACPI_UPC_TYPE_USBC_SS_NO_SWITCH) &&
+	    ACPI_UPC_USBC_USB4(upc->usbc_capabilities))
+		ret = 1;
+
+	ACPI_FREE(upc);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(usb_acpi_intel_port_lpm_incapable);
+
 /**
  * usb_acpi_set_power_state - control usb port's power via acpi power
  * resource
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 9642ee02d713..85bc10fa1dcf 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -774,6 +774,7 @@ extern int usb_acpi_set_power_state(struct usb_device *hdev, int index,
 	bool enable);
 extern bool usb_acpi_power_manageable(struct usb_device *hdev, int index);
 extern int usb_acpi_port_lpm_incapable(struct usb_device *hdev, int index);
+extern int usb_acpi_intel_port_lpm_incapable(struct usb_device *hdev, int index);
 #else
 static inline int usb_acpi_set_power_state(struct usb_device *hdev, int index,
 	bool enable) { return 0; }
@@ -781,6 +782,8 @@ static inline bool usb_acpi_power_manageable(struct usb_device *hdev, int index)
 	{ return true; }
 static inline int usb_acpi_port_lpm_incapable(struct usb_device *hdev, int index)
 	{ return 0; }
+static inline int usb_acpi_intel_port_lpm_incapable(struct usb_device *hdev,
+	int index) { return 0; }
 #endif
 
 /* USB autosuspend and autoresume */
-- 
2.25.1

