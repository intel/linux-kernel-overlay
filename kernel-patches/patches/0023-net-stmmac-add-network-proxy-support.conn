From 9bd72068aa5030ced0f4b76657a2e59911e5dc73 Mon Sep 17 00:00:00 2001
From: Song Yoong Siang <yoong.siang.song@intel.com>
Date: Mon, 10 Jan 2022 18:20:26 +0800
Subject: [PATCH 23/54] net: stmmac: add network proxy support

This enables stmmac driver to support network proxy mode entry and exit
for ECMA-393 proxZzy technology.

Signed-off-by: Ong Boon Leong <boon.leong.ong@intel.com>
Signed-off-by: Lay Kuan Loon <kuan.loon.lay@intel.com>
Signed-off-by: Song Yoong Siang <yoong.siang.song@intel.com>
Signed-off-by: Voon Weifeng <weifeng.voon@intel.com>
Signed-off-by: Ling Pei Lee <pei.lee.ling@intel.com>
Signed-off-by: Noor Azura Ahmad Tarmizi <noor.azura.ahmad.tarmizi@intel.com>
Signed-off-by: Wong Vee Khee <vee.khee.wong@linux.intel.com>
---
 MAINTAINERS                                   |   1 +
 drivers/net/ethernet/stmicro/stmmac/Kconfig   |  19 ++
 drivers/net/ethernet/stmicro/stmmac/Makefile  |   3 +
 drivers/net/ethernet/stmicro/stmmac/common.h  |   3 +
 .../net/ethernet/stmicro/stmmac/dwmac-intel.c |  16 +
 .../ethernet/stmicro/stmmac/dwmac1000_core.c  |  66 ++--
 .../ethernet/stmicro/stmmac/dwmac100_core.c   |  25 +-
 .../net/ethernet/stmicro/stmmac/dwmac4_core.c |  76 +++--
 .../ethernet/stmicro/stmmac/dwxgmac2_core.c   |  66 ++--
 drivers/net/ethernet/stmicro/stmmac/hwif.c    |   6 +
 drivers/net/ethernet/stmicro/stmmac/hwif.h    |  21 +-
 drivers/net/ethernet/stmicro/stmmac/stmmac.h  |  13 +-
 .../net/ethernet/stmicro/stmmac/stmmac_main.c | 296 +++++++++++++++++-
 .../ethernet/stmicro/stmmac/stmmac_netproxy.c | 249 +++++++++++++++
 .../ethernet/stmicro/stmmac/stmmac_netproxy.h |  24 ++
 include/linux/stmmac.h                        |   3 +
 16 files changed, 790 insertions(+), 97 deletions(-)
 create mode 100644 drivers/net/ethernet/stmicro/stmmac/stmmac_netproxy.c
 create mode 100644 drivers/net/ethernet/stmicro/stmmac/stmmac_netproxy.h

diff --git a/MAINTAINERS b/MAINTAINERS
index 3b4e98f9f9de..abf770a29006 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -13334,6 +13334,7 @@ M:	Ong Boon Leong <boon.leong.ong@intel.com>
 M:	Song Yoong Siang <yoong.siang.song@intel.com>
 L:	netdev@vger.kernel.org
 S:	Maintained
+F:	drivers/net/ethernet/stmicro/stmmac/stmmac_netproxy.*
 F:	drivers/net/networkproxy/*
 F:	include/linux/network_proxy*
 
diff --git a/drivers/net/ethernet/stmicro/stmmac/Kconfig b/drivers/net/ethernet/stmicro/stmmac/Kconfig
index 929cfc22cd0c..6bf92356dacd 100644
--- a/drivers/net/ethernet/stmicro/stmmac/Kconfig
+++ b/drivers/net/ethernet/stmicro/stmmac/Kconfig
@@ -271,4 +271,23 @@ config STMMAC_PCI
 	  If you have a controller with this interface, say Y or M here.
 
 	  If unsure, say N.
+
+config STMMAC_NETWORK_PROXY
+	bool "STMMAC Network Proxy support"
+	depends on STMMAC_ETH && DWMAC_INTEL && NETWORK_PROXY
+	help
+	  This selects the Network Proxy support for the stmmac driver.
+
+	  This enables stmmac driver to has the capable of supporting
+	  network proxy mode entry and exit for the ECMA-393 proxZzy
+	  technology.
+
+config STMMAC_NETWORK_PROXY_PORT
+	int "STMMAC Network Proxy support in Port"
+	depends on STMMAC_NETWORK_PROXY
+	range 0 1
+	default 0
+	help
+	  Default enable port 0 for Network Proxy.
+
 endif
diff --git a/drivers/net/ethernet/stmicro/stmmac/Makefile b/drivers/net/ethernet/stmicro/stmmac/Makefile
index d4e12e9ace4f..d77144571bcc 100644
--- a/drivers/net/ethernet/stmicro/stmmac/Makefile
+++ b/drivers/net/ethernet/stmicro/stmmac/Makefile
@@ -10,6 +10,9 @@ stmmac-objs:= stmmac_main.o stmmac_ethtool.o stmmac_mdio.o ring_mode.o	\
 	      $(stmmac-y)
 
 stmmac-$(CONFIG_STMMAC_SELFTESTS) += stmmac_selftests.o
+ifeq ($(CONFIG_STMMAC_NETWORK_PROXY),y)
+stmmac-objs += stmmac_netproxy.o
+endif
 
 # Ordering matters. Generic driver must be last.
 obj-$(CONFIG_STMMAC_PLATFORM)	+= stmmac-platform.o
diff --git a/drivers/net/ethernet/stmicro/stmmac/common.h b/drivers/net/ethernet/stmicro/stmmac/common.h
index fd8af73ac704..73e59551197f 100644
--- a/drivers/net/ethernet/stmicro/stmmac/common.h
+++ b/drivers/net/ethernet/stmicro/stmmac/common.h
@@ -519,6 +519,9 @@ struct mac_device_info {
 	const struct stmmac_mode_ops *mode;
 	const struct stmmac_hwtimestamp *ptp;
 	const struct stmmac_tc_ops *tc;
+#ifdef CONFIG_STMMAC_NETWORK_PROXY
+	const struct stmmac_pm_ops *pm;
+#endif
 	const struct stmmac_mmc_ops *mmc;
 	struct dw_xpcs *xpcs;
 	struct mii_regs mii;	/* MII register Addresses */
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac-intel.c b/drivers/net/ethernet/stmicro/stmmac/dwmac-intel.c
index bd26a9bdf28a..668abc356664 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac-intel.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac-intel.c
@@ -669,6 +669,14 @@ static int ehl_pse0_common_data(struct pci_dev *pdev,
 
 	intel_mgbe_pse_crossts_adj(intel_priv, EHL_PSE_ART_MHZ);
 
+	/* store A2H packets in L2 SRAM, access through BAR0 + 128KB */
+#ifdef CONFIG_STMMAC_NETWORK_PROXY
+#if (CONFIG_STMMAC_NETWORK_PROXY_PORT == 0)
+	plat->has_netproxy = 1;
+	plat->msi_network_proxy_vec = 24;
+#endif /* CONFIG_STMMAC_NETWORK_PROXY_PORT */
+#endif /* CONFIG_STMMAC_NETWORK_PROXY */
+
 	return ehl_common_data(pdev, plat);
 }
 
@@ -708,6 +716,14 @@ static int ehl_pse1_common_data(struct pci_dev *pdev,
 
 	intel_mgbe_pse_crossts_adj(intel_priv, EHL_PSE_ART_MHZ);
 
+	/* store A2H packets in L2 SRAM, access through BAR0 + 128KB */
+#ifdef CONFIG_STMMAC_NETWORK_PROXY
+#if (CONFIG_STMMAC_NETWORK_PROXY_PORT == 1)
+	plat->has_netproxy = 1;
+	plat->msi_network_proxy_vec = 24;
+#endif /* CONFIG_STMMAC_NETWORK_PROXY_PORT */
+#endif /* CONFIG_STMMAC_NETWORK_PROXY */
+
 	return ehl_common_data(pdev, plat);
 }
 
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac1000_core.c b/drivers/net/ethernet/stmicro/stmmac/dwmac1000_core.c
index fc8759f146c7..212ca686c642 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac1000_core.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac1000_core.c
@@ -28,41 +28,43 @@ static void dwmac1000_core_init(struct mac_device_info *hw,
 	void __iomem *ioaddr = hw->pcsr;
 	u32 value = readl(ioaddr + GMAC_CONTROL);
 	int mtu = dev->mtu;
+#ifdef CONFIG_STMMAC_NETWORK_PROXY
+	if (!priv->networkproxy_exit) {
+#endif
+		/* Configure GMAC core */
+		value |= GMAC_CORE_INIT;
 
-	/* Configure GMAC core */
-	value |= GMAC_CORE_INIT;
-
-	/* Clear ACS bit because Ethernet switch tagging formats such as
-	 * Broadcom tags can look like invalid LLC/SNAP packets and cause the
-	 * hardware to truncate packets on reception.
-	 */
-	if (netdev_uses_dsa(dev) || !priv->plat->enh_desc)
-		value &= ~GMAC_CONTROL_ACS;
-
-	if (mtu > 1500)
-		value |= GMAC_CONTROL_2K;
-	if (mtu > 2000)
-		value |= GMAC_CONTROL_JE;
-
-	if (hw->ps) {
-		value |= GMAC_CONTROL_TE;
-
-		value &= ~hw->link.speed_mask;
-		switch (hw->ps) {
-		case SPEED_1000:
-			value |= hw->link.speed1000;
-			break;
-		case SPEED_100:
-			value |= hw->link.speed100;
-			break;
-		case SPEED_10:
-			value |= hw->link.speed10;
-			break;
+		/* Clear ACS bit because Ethernet switch tagging formats such as
+		 * Broadcom tags can look like invalid LLC/SNAP packets and cause the
+		 * hardware to truncate packets on reception.
+		 */
+		if (netdev_uses_dsa(dev) || !priv->plat->enh_desc)
+			value &= ~GMAC_CONTROL_ACS;
+
+		if (mtu > 1500)
+			value |= GMAC_CONTROL_2K;
+		if (mtu > 2000)
+			value |= GMAC_CONTROL_JE;
+
+		if (hw->ps) {
+			value |= GMAC_CONTROL_TE;
+			value &= ~hw->link.speed_mask;
+			switch (hw->ps) {
+			case SPEED_1000:
+				value |= hw->link.speed1000;
+				break;
+			case SPEED_100:
+				value |= hw->link.speed100;
+				break;
+			case SPEED_10:
+				value |= hw->link.speed10;
+				break;
+			}
 		}
+		writel(value, ioaddr + GMAC_CONTROL);
+#ifdef CONFIG_STMMAC_NETWORK_PROXY
 	}
-
-	writel(value, ioaddr + GMAC_CONTROL);
-
+#endif
 	/* Mask GMAC interrupts */
 	value = GMAC_INT_DEFAULT_MASK;
 
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac100_core.c b/drivers/net/ethernet/stmicro/stmmac/dwmac100_core.c
index ebcad8dd99db..435403848371 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac100_core.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac100_core.c
@@ -25,18 +25,23 @@ static void dwmac100_core_init(struct mac_device_info *hw,
 {
 	void __iomem *ioaddr = hw->pcsr;
 	u32 value = readl(ioaddr + MAC_CONTROL);
+#ifdef CONFIG_STMMAC_NETWORK_PROXY
+	struct stmmac_priv *priv = netdev_priv(dev);
 
-	value |= MAC_CORE_INIT;
-
-	/* Clear ASTP bit because Ethernet switch tagging formats such as
-	 * Broadcom tags can look like invalid LLC/SNAP packets and cause the
-	 * hardware to truncate packets on reception.
-	 */
-	if (netdev_uses_dsa(dev))
-		value &= ~MAC_CONTROL_ASTP;
-
-	writel(value, ioaddr + MAC_CONTROL);
+	if (!priv->networkproxy_exit) {
+#endif
+		value |= MAC_CORE_INIT;
+		/* Clear ASTP bit because Ethernet switch tagging formats such
+		 * as Broadcom tags can look like invalid LLC/SNAP packets and
+		 * cause the hardware to truncate packets on reception.
+		 */
+		if (netdev_uses_dsa(dev))
+			value &= ~MAC_CONTROL_ASTP;
 
+		writel(value, ioaddr + MAC_CONTROL);
+#ifdef CONFIG_STMMAC_NETWORK_PROXY
+	}
+#endif
 #ifdef STMMAC_VLAN_TAG_USED
 	writel(ETH_P_8021Q, ioaddr + MAC_VLAN1);
 #endif
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac4_core.c b/drivers/net/ethernet/stmicro/stmmac/dwmac4_core.c
index 38cf48e0fca9..046a2c14553d 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac4_core.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac4_core.c
@@ -24,30 +24,41 @@
 static void dwmac4_core_init(struct mac_device_info *hw,
 			     struct net_device *dev)
 {
-	struct stmmac_priv *priv = netdev_priv(dev);
 	void __iomem *ioaddr = hw->pcsr;
 	u32 value = readl(ioaddr + GMAC_CONFIG);
-
-	value |= GMAC_CORE_INIT;
-
-	if (hw->ps) {
-		value |= GMAC_CONFIG_TE;
-
-		value &= hw->link.speed_mask;
-		switch (hw->ps) {
-		case SPEED_1000:
-			value |= hw->link.speed1000;
-			break;
-		case SPEED_100:
-			value |= hw->link.speed100;
-			break;
-		case SPEED_10:
-			value |= hw->link.speed10;
-			break;
+	int mtu = dev->mtu;
+	struct stmmac_priv *priv = netdev_priv(dev);
+#ifdef CONFIG_STMMAC_NETWORK_PROXY
+	if (!priv->networkproxy_exit) {
+#endif
+		value |= GMAC_CORE_INIT;
+
+		if (mtu > 1500)
+			value |= GMAC_CONFIG_2K;
+		if (mtu > 2000)
+			value |= GMAC_CONFIG_JE;
+
+		if (hw->ps) {
+			value |= GMAC_CONFIG_TE;
+
+			value &= hw->link.speed_mask;
+			switch (hw->ps) {
+			case SPEED_1000:
+				value |= hw->link.speed1000;
+				break;
+			case SPEED_100:
+				value |= hw->link.speed100;
+				break;
+			case SPEED_10:
+				value |= hw->link.speed10;
+				break;
+			}
 		}
-	}
 
-	writel(value, ioaddr + GMAC_CONFIG);
+		writel(value, ioaddr + GMAC_CONFIG);
+#ifdef CONFIG_STMMAC_NETWORK_PROXY
+	}
+#endif
 
 	/* Enable GMAC interrupts */
 	value = GMAC_INT_DEFAULT_ENABLE;
@@ -1244,6 +1255,28 @@ static void dwmac4_set_hw_vlan_mode(void __iomem *ioaddr,
 	writel(val, ioaddr + GMAC_VLAN_TAG);
 }
 
+static int dwmac4_mtl_tx_completed(void __iomem *ioaddr, u32 tx_queues)
+{
+	u32 queue, value;
+
+	for (queue = 0; queue < tx_queues; queue++) {
+		value = readl(ioaddr + MTL_CHAN_TX_DEBUG(queue));
+
+		/* if Tx Queue not empty */
+		if (value & MTL_DEBUG_TXFSTS)
+			return 1;
+
+		/* check frame transmissions is complete */
+		if (value & MTL_DEBUG_TRCSTS_MASK) {
+			u32 trcsts = (value & MTL_DEBUG_TRCSTS_MASK)
+				     >> MTL_DEBUG_TRCSTS_SHIFT;
+			if (trcsts != MTL_DEBUG_TRCSTS_IDLE)
+				return 1;
+		}
+	}
+	return 0;
+}
+
 const struct stmmac_ops dwmac4_ops = {
 	.core_init = dwmac4_core_init,
 	.set_mac = stmmac_set_mac,
@@ -1290,6 +1323,7 @@ const struct stmmac_ops dwmac4_ops = {
 	.restore_hw_vlan_rx_fltr = dwmac4_restore_hw_vlan_rx_fltr,
 	.rx_hw_vlan = dwmac4_rx_hw_vlan,
 	.set_hw_vlan_mode = dwmac4_set_hw_vlan_mode,
+	.mtl_tx_completed = dwmac4_mtl_tx_completed,
 };
 
 const struct stmmac_ops dwmac410_ops = {
@@ -1344,6 +1378,7 @@ const struct stmmac_ops dwmac410_ops = {
 	.restore_hw_vlan_rx_fltr = dwmac4_restore_hw_vlan_rx_fltr,
 	.rx_hw_vlan = dwmac4_rx_hw_vlan,
 	.set_hw_vlan_mode = dwmac4_set_hw_vlan_mode,
+	.mtl_tx_completed = dwmac4_mtl_tx_completed,
 };
 
 const struct stmmac_ops dwmac510_ops = {
@@ -1402,6 +1437,7 @@ const struct stmmac_ops dwmac510_ops = {
 	.restore_hw_vlan_rx_fltr = dwmac4_restore_hw_vlan_rx_fltr,
 	.rx_hw_vlan = dwmac4_rx_hw_vlan,
 	.set_hw_vlan_mode = dwmac4_set_hw_vlan_mode,
+	.mtl_tx_completed = dwmac4_mtl_tx_completed,
 };
 
 static u32 dwmac4_get_num_vlan(void __iomem *ioaddr)
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwxgmac2_core.c b/drivers/net/ethernet/stmicro/stmmac/dwxgmac2_core.c
index f098a8afee1f..0433ac3c8dcf 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwxgmac2_core.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwxgmac2_core.c
@@ -16,34 +16,52 @@ static void dwxgmac2_core_init(struct mac_device_info *hw,
 			       struct net_device *dev)
 {
 	void __iomem *ioaddr = hw->pcsr;
+	int mtu = dev->mtu;
 	u32 tx, rx;
+#ifdef CONFIG_STMMAC_NETWORK_PROXY
+	struct stmmac_priv *priv = netdev_priv(dev);
+
+	if (!priv->networkproxy_exit) {
+#endif
+		tx = readl(ioaddr + XGMAC_TX_CONFIG);
+		rx = readl(ioaddr + XGMAC_RX_CONFIG);
+
+		tx |= XGMAC_CORE_INIT_TX;
+		rx |= XGMAC_CORE_INIT_RX;
+
+		if (mtu >= 9000) {
+			rx |= XGMAC_CONFIG_GPSLCE;
+			rx |= XGMAC_JUMBO_LEN << XGMAC_CONFIG_GPSL_SHIFT;
+			rx |= XGMAC_CONFIG_WD;
+		} else if (mtu > 2000) {
+			rx |= XGMAC_CONFIG_JE;
+		} else if (mtu > 1500) {
+			rx |= XGMAC_CONFIG_S2KP;
+		}
 
-	tx = readl(ioaddr + XGMAC_TX_CONFIG);
-	rx = readl(ioaddr + XGMAC_RX_CONFIG);
-
-	tx |= XGMAC_CORE_INIT_TX;
-	rx |= XGMAC_CORE_INIT_RX;
-
-	if (hw->ps) {
-		tx |= XGMAC_CONFIG_TE;
-		tx &= ~hw->link.speed_mask;
-
-		switch (hw->ps) {
-		case SPEED_10000:
-			tx |= hw->link.xgmii.speed10000;
-			break;
-		case SPEED_2500:
-			tx |= hw->link.speed2500;
-			break;
-		case SPEED_1000:
-		default:
-			tx |= hw->link.speed1000;
-			break;
+		if (hw->ps) {
+			tx |= XGMAC_CONFIG_TE;
+			tx &= ~hw->link.speed_mask;
+
+			switch (hw->ps) {
+			case SPEED_10000:
+				tx |= hw->link.xgmii.speed10000;
+				break;
+			case SPEED_2500:
+				tx |= hw->link.speed2500;
+				break;
+			case SPEED_1000:
+			default:
+				tx |= hw->link.speed1000;
+				break;
+			}
 		}
-	}
 
-	writel(tx, ioaddr + XGMAC_TX_CONFIG);
-	writel(rx, ioaddr + XGMAC_RX_CONFIG);
+		writel(tx, ioaddr + XGMAC_TX_CONFIG);
+		writel(rx, ioaddr + XGMAC_RX_CONFIG);
+#ifdef CONFIG_STMMAC_NETWORK_PROXY
+	}
+#endif
 	writel(XGMAC_INT_DEFAULT_EN, ioaddr + XGMAC_INT_EN);
 }
 
diff --git a/drivers/net/ethernet/stmicro/stmmac/hwif.c b/drivers/net/ethernet/stmicro/stmmac/hwif.c
index bb7114f970f8..cca606a22293 100644
--- a/drivers/net/ethernet/stmicro/stmmac/hwif.c
+++ b/drivers/net/ethernet/stmicro/stmmac/hwif.c
@@ -320,6 +320,12 @@ int stmmac_hwif_init(struct stmmac_priv *priv)
 		mac->tc = mac->tc ? : entry->tc;
 		mac->mmc = mac->mmc ? : entry->mmc;
 
+#ifdef CONFIG_STMMAC_NETWORK_PROXY
+		if (priv->plat->has_netproxy)
+			mac->pm = &dwmac_netprox_pm_ops;
+		else
+			mac->pm = &dwmac_pm_ops;
+#endif
 		priv->hw = mac;
 		priv->ptpaddr = priv->ioaddr + entry->regs.ptp_off;
 		priv->mmcaddr = priv->ioaddr + entry->regs.mmc_off;
diff --git a/drivers/net/ethernet/stmicro/stmmac/hwif.h b/drivers/net/ethernet/stmicro/stmmac/hwif.h
index 3d05b8430988..55b54b94310e 100644
--- a/drivers/net/ethernet/stmicro/stmmac/hwif.h
+++ b/drivers/net/ethernet/stmicro/stmmac/hwif.h
@@ -408,6 +408,8 @@ struct stmmac_ops {
 				bool en, bool udp, bool sa, bool inv,
 				u32 match);
 	void (*set_arp_offload)(struct mac_device_info *hw, bool en, u32 addr);
+	/* Check frame transmission is completed */
+	int (*mtl_tx_completed)(void __iomem *ioaddr, u32 tx_queues);
 	int (*est_configure)(void __iomem *ioaddr, struct stmmac_est *cfg,
 			     unsigned int ptp_rate);
 	void (*est_irq_status)(void __iomem *ioaddr, struct net_device *dev,
@@ -523,6 +525,8 @@ struct stmmac_ops {
 	stmmac_do_callback(__priv, mac, config_l4_filter, __args)
 #define stmmac_set_arp_offload(__priv, __args...) \
 	stmmac_do_void_callback(__priv, mac, set_arp_offload, __args)
+#define stmmac_mtl_tx_completed(__priv, __args...) \
+	stmmac_do_callback(__priv, mac, mtl_tx_completed, __args)
 #define stmmac_est_configure(__priv, __args...) \
 	stmmac_do_callback(__priv, mac, est_configure, __args)
 #define stmmac_est_irq_status(__priv, __args...) \
@@ -652,6 +656,18 @@ struct stmmac_regs_off {
 	u32 mmc_off;
 };
 
+#ifdef CONFIG_STMMAC_NETWORK_PROXY
+struct stmmac_pm_ops {
+	int (*suspend)(struct stmmac_priv *priv, struct net_device *ndev);
+	int (*resume)(struct stmmac_priv *priv, struct net_device *ndev);
+};
+
+#define stmmac_pm_suspend(__priv, __args...) \
+	stmmac_do_callback(__priv, pm, suspend, __args)
+#define stmmac_pm_resume(__priv, __args...) \
+	stmmac_do_callback(__priv, pm, resume, __args)
+#endif /* CONFIG_STMMAC_NETWORK_PROXY */
+
 extern const struct stmmac_ops dwmac100_ops;
 extern const struct stmmac_dma_ops dwmac100_dma_ops;
 extern const struct stmmac_ops dwmac1000_ops;
@@ -668,7 +684,10 @@ extern const struct stmmac_dma_ops dwxgmac210_dma_ops;
 extern const struct stmmac_desc_ops dwxgmac210_desc_ops;
 extern const struct stmmac_mmc_ops dwmac_mmc_ops;
 extern const struct stmmac_mmc_ops dwxgmac_mmc_ops;
-
+#ifdef CONFIG_STMMAC_NETWORK_PROXY
+extern const struct stmmac_pm_ops dwmac_pm_ops;
+extern const struct stmmac_pm_ops dwmac_netprox_pm_ops;
+#endif
 #define GMAC_VERSION		0x00000020	/* GMAC CORE Version */
 #define GMAC4_VERSION		0x00000110	/* GMAC4+ CORE Version */
 
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac.h b/drivers/net/ethernet/stmicro/stmmac/stmmac.h
index 0fee33c449dd..e2e5248dbea8 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac.h
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac.h
@@ -311,7 +311,11 @@ struct stmmac_priv {
 	struct workqueue_struct *fpe_wq;
 	struct work_struct fpe_task;
 	char wq_name[IFNAMSIZ + 4];
-
+#ifdef CONFIG_STMMAC_NETWORK_PROXY
+	/* Network Proxy A2H Worker */
+	struct workqueue_struct *netprox_wq;
+	bool networkproxy_exit;
+#endif
 	/* TC Handling */
 	unsigned int tc_entries_max;
 	unsigned int tc_off_max;
@@ -370,6 +374,13 @@ int stmmac_reinit_queues(struct net_device *dev, u32 rx_cnt, u32 tx_cnt);
 int stmmac_reinit_ringparam(struct net_device *dev, u32 rx_size, u32 tx_size);
 int stmmac_bus_clks_config(struct stmmac_priv *priv, bool enabled);
 void stmmac_fpe_handshake(struct stmmac_priv *priv, bool enable);
+#ifdef CONFIG_STMMAC_NETWORK_PROXY
+int stmmac_config_dma_channel(struct stmmac_priv *priv);
+int stmmac_suspend_common(struct stmmac_priv *priv, struct net_device *ndev);
+int stmmac_resume_common(struct stmmac_priv *priv, struct net_device *ndev);
+int stmmac_suspend_main(struct stmmac_priv *priv, struct net_device *ndev);
+int stmmac_resume_main(struct stmmac_priv *priv, struct net_device *ndev);
+#endif
 
 static inline bool stmmac_xdp_is_enabled(struct stmmac_priv *priv)
 {
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
index 8fcd41653ce8..0a5d3e1e7da6 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
@@ -49,6 +49,9 @@
 #include "dwmac1000.h"
 #include "dwxgmac2.h"
 #include "hwif.h"
+#ifdef CONFIG_STMMAC_NETWORK_PROXY
+#include "stmmac_netproxy.h"
+#endif
 
 /* As long as the interface is active, we keep the timestamping counter enabled
  * with fine resolution and binary rollover. This avoid non-monotonic behavior
@@ -2926,8 +2929,10 @@ static int stmmac_init_dma_engine(struct stmmac_priv *priv)
 	u32 rx_channels_count = priv->plat->rx_queues_to_use;
 	u32 tx_channels_count = priv->plat->tx_queues_to_use;
 	u32 dma_csr_ch = max(rx_channels_count, tx_channels_count);
+#ifndef CONFIG_STMMAC_NETWORK_PROXY
 	struct stmmac_rx_queue *rx_q;
 	struct stmmac_tx_queue *tx_q;
+#endif
 	u32 chan = 0;
 	int atds = 0;
 	int ret = 0;
@@ -2940,12 +2945,17 @@ static int stmmac_init_dma_engine(struct stmmac_priv *priv)
 	if (priv->extend_desc && (priv->mode == STMMAC_RING_MODE))
 		atds = 1;
 
-	ret = stmmac_reset(priv, priv->ioaddr);
-	if (ret) {
-		dev_err(priv->device, "Failed to reset the dma\n");
-		return ret;
+#ifdef CONFIG_STMMAC_NETWORK_PROXY
+	if (!priv->networkproxy_exit) {
+#endif
+		ret = stmmac_reset(priv, priv->ioaddr);
+		if (ret) {
+			dev_err(priv->device, "Failed to reset the dma\n");
+			return ret;
+		}
+#ifdef CONFIG_STMMAC_NETWORK_PROXY
 	}
-
+#endif
 	/* DMA Configuration */
 	stmmac_dma_init(priv, priv->ioaddr, priv->plat->dma_cfg, atds);
 
@@ -2957,7 +2967,9 @@ static int stmmac_init_dma_engine(struct stmmac_priv *priv)
 		stmmac_init_chan(priv, priv->ioaddr, priv->plat->dma_cfg, chan);
 		stmmac_disable_dma_irq(priv, priv->ioaddr, chan, 1, 1);
 	}
-
+#ifdef CONFIG_STMMAC_NETWORK_PROXY
+	stmmac_config_dma_channel(priv);
+#else
 	/* DMA RX Channel Configuration */
 	for (chan = 0; chan < rx_channels_count; chan++) {
 		rx_q = &priv->rx_queue[chan];
@@ -2983,7 +2995,7 @@ static int stmmac_init_dma_engine(struct stmmac_priv *priv)
 		stmmac_set_tx_tail_ptr(priv, priv->ioaddr,
 				       tx_q->tx_tail_addr, chan);
 	}
-
+#endif /* ndef CONFIG_STMMAC_NETWORK_PROXY */
 	return ret;
 }
 
@@ -3845,7 +3857,10 @@ static int stmmac_open(struct net_device *dev)
 	stmmac_enable_all_queues(priv);
 	netif_tx_start_all_queues(priv->dev);
 	stmmac_enable_all_dma_irq(priv);
-
+#ifdef CONFIG_STMMAC_NETWORK_PROXY
+	if (priv->plat->has_netproxy)
+		stmmac_netproxy_register(dev);
+#endif
 	pm_runtime_put(priv->device);
 	return 0;
 
@@ -3932,6 +3947,11 @@ static int stmmac_release(struct net_device *dev)
 	/* Release and free the Rx/Tx resources */
 	free_dma_desc_resources(priv);
 
+#ifdef CONFIG_STMMAC_NETWORK_PROXY
+	if (priv->plat->has_netproxy)
+		stmmac_netproxy_deregister(dev);
+#endif
+
 	stmmac_release_ptp(priv);
 
 	if (!suspended)
@@ -7187,6 +7207,13 @@ int stmmac_dvr_probe(struct device *device,
 	if (ret)
 		goto error_hw_init;
 
+#ifdef CONFIG_STMMAC_NETWORK_PROXY
+	if (priv->plat->has_netproxy) {
+		dev_info(priv->device, "Network Proxy supported\n");
+		device_set_wakeup_capable(priv->device, 1);
+	}
+#endif
+
 	/* Only DWMAC core version 5.20 onwards supports HW descriptor prefetch.
 	 */
 	if (priv->synopsys_id < DWMAC_CORE_5_20)
@@ -7372,6 +7399,12 @@ int stmmac_dvr_probe(struct device *device,
 	if (priv->plat->dump_debug_regs)
 		priv->plat->dump_debug_regs(priv->plat->bsp_priv);
 
+	/* Runtime PM is mutually exclusive with network proxy service */
+#ifdef CONFIG_STMMAC_NETWORK_PROXY
+	if (priv->plat->has_netproxy)
+		return ret;
+#endif
+
 	/* Let pm_runtime_put() disable the clocks.
 	 * If CONFIG_PM is not enabled, the clocks will stay powered.
 	 */
@@ -7458,6 +7491,104 @@ int stmmac_dvr_remove(struct device *dev)
 }
 EXPORT_SYMBOL_GPL(stmmac_dvr_remove);
 
+#ifdef CONFIG_STMMAC_NETWORK_PROXY
+/**
+ * stmmac_suspend_common - suspend common callback
+ * @priv: driver private structure
+ * @ndev: net device structure
+ * Description: this is the function to suspend the device and it is called
+ * by the platform driver to stop the network queue, release the resources,
+ * clean and release driver resources.
+ */
+int stmmac_suspend_common(struct stmmac_priv *priv, struct net_device *ndev)
+{
+	u32 chan;
+
+	mutex_lock(&priv->lock);
+
+	netif_device_detach(ndev);
+
+	netif_carrier_off(priv->dev);
+
+	stmmac_disable_all_queues(priv);
+
+	for (chan = 0; chan < priv->plat->tx_queues_to_use; chan++)
+		hrtimer_cancel(&priv->tx_queue[chan].txtimer);
+
+	if (priv->eee_enabled) {
+		priv->tx_path_in_lpi_mode = false;
+		del_timer_sync(&priv->eee_ctrl_timer);
+	}
+
+	/* Stop TX/RX DMA */
+	stmmac_stop_all_dma(priv);
+	stmmac_stop_mac_tx(priv, priv->ioaddr);
+
+	stmmac_free_tx_skbufs(priv);
+
+	mutex_unlock(&priv->lock);
+
+	priv->speed = SPEED_UNKNOWN;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(stmmac_suspend_common);
+
+/**
+ * stmmac_suspend_main - suspend main callback
+ * @priv: driver private structure
+ * @ndev: net device structure
+ * Description: suspend and program the PMT register (for WoL).
+ */
+int stmmac_suspend_main(struct stmmac_priv *priv, struct net_device *ndev)
+{
+	if (!ndev || !netif_running(ndev))
+		return 0;
+
+	stmmac_suspend_common(priv, ndev);
+
+	mutex_lock(&priv->lock);
+
+	stmmac_stop_mac_rx(priv, priv->ioaddr);
+
+	if (priv->plat->serdes_powerdown)
+		priv->plat->serdes_powerdown(ndev, priv->plat->bsp_priv);
+
+	/* Enable Power down mode by programming the PMT regs */
+	if (device_may_wakeup(priv->device) && priv->plat->pmt) {
+		stmmac_pmt(priv, priv->hw, priv->wolopts);
+		priv->irq_wake = 1;
+	} else {
+		stmmac_mac_set(priv, priv->ioaddr, false);
+		pinctrl_pm_select_sleep_state(priv->device);
+	}
+
+	mutex_unlock(&priv->lock);
+
+	rtnl_lock();
+	if (device_may_wakeup(priv->device) && priv->plat->pmt) {
+		phylink_suspend(priv->phylink, true);
+	} else {
+		if (device_may_wakeup(priv->device))
+			phylink_speed_down(priv->phylink, false);
+		phylink_suspend(priv->phylink, false);
+	}
+	rtnl_unlock();
+
+	if (priv->dma_cap.fpesel) {
+		/* Disable FPE */
+		stmmac_fpe_configure(priv, priv->ioaddr,
+				     priv->plat->tx_queues_to_use,
+				     priv->plat->rx_queues_to_use, 0, false);
+
+		stmmac_fpe_handshake(priv, false);
+		stmmac_fpe_stop_wq(priv);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(stmmac_suspend_main);
+#endif /* CONFIG_STMMAC_NETWORK_PROXY */
+
 /**
  * stmmac_suspend - suspend callback
  * @dev: device pointer
@@ -7469,6 +7600,9 @@ int stmmac_suspend(struct device *dev)
 {
 	struct net_device *ndev = dev_get_drvdata(dev);
 	struct stmmac_priv *priv = netdev_priv(ndev);
+#ifdef CONFIG_STMMAC_NETWORK_PROXY
+	stmmac_pm_suspend(priv, priv, ndev);
+#else
 	u32 chan;
 
 	if (!ndev || !netif_running(ndev))
@@ -7528,6 +7662,7 @@ int stmmac_suspend(struct device *dev)
 	}
 
 	priv->speed = SPEED_UNKNOWN;
+#endif /* ndef CONFIG_STMMAC_NETWORK_PROXY */
 	return 0;
 }
 EXPORT_SYMBOL_GPL(stmmac_suspend);
@@ -7560,6 +7695,138 @@ static void stmmac_reset_queues_param(struct stmmac_priv *priv)
 	}
 }
 
+#ifdef CONFIG_STMMAC_NETWORK_PROXY
+/**
+ * stmmac_resume_common - common resume callback
+ * @priv: driver private structure
+ * @ndev: net device structure
+ * Description: when resume this function is invoked to setup the DMA and CORE
+ * in a usable state.
+ */
+int stmmac_resume_common(struct stmmac_priv *priv, struct net_device *ndev)
+{
+	rtnl_lock();
+		mutex_lock(&priv->lock);
+
+	stmmac_reset_queues_param(priv);
+
+	stmmac_clear_descriptors(priv);
+
+	stmmac_hw_setup(ndev, false);
+	stmmac_init_coalesce(priv);
+	stmmac_set_rx_mode(ndev);
+
+	stmmac_restore_hw_vlan_rx_fltr(priv, ndev, priv->hw);
+
+	stmmac_enable_all_queues(priv);
+	stmmac_enable_all_dma_irq(priv);
+
+	mutex_unlock(&priv->lock);
+	rtnl_unlock();
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(stmmac_resume_common);
+
+/**
+ * stmmac_resume_main - main resume callback
+ * @priv: driver private structure
+ * @ndev: net device structure
+ * Description: program the PMT register (for WoL) and resume
+ */
+int stmmac_resume_main(struct stmmac_priv *priv, struct net_device *ndev)
+{
+	int ret;
+
+	if (!netif_running(ndev))
+		return 0;
+
+	/* Power Down bit, into the PM register, is cleared
+	 * automatically as soon as a magic packet or a Wake-up frame
+	 * is received. Anyway, it's better to manually clear
+	 * this bit because it can generate problems while resuming
+	 * from another devices (e.g. serial console).
+	 */
+	if (device_may_wakeup(priv->device) && priv->plat->pmt) {
+		mutex_lock(&priv->lock);
+		stmmac_pmt(priv, priv->hw, 0);
+		mutex_unlock(&priv->lock);
+		priv->irq_wake = 0;
+	} else {
+		pinctrl_pm_select_default_state(priv->device);
+		/* reset the phy so that it's ready */
+		if (priv->mii)
+			stmmac_mdio_reset(priv->mii);
+	}
+
+	if (priv->plat->serdes_powerup) {
+		ret = priv->plat->serdes_powerup(ndev, priv->plat->bsp_priv);
+		if (ret < 0)
+			return ret;
+	}
+
+	rtnl_lock();
+	if (device_may_wakeup(priv->device) && priv->plat->pmt) {
+		phylink_resume(priv->phylink);
+	} else {
+		phylink_resume(priv->phylink);
+		if (device_may_wakeup(priv->device))
+			phylink_speed_up(priv->phylink);
+	}
+	rtnl_unlock();
+
+	stmmac_resume_common(priv, ndev);
+
+	netif_device_attach(ndev);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(stmmac_resume_main);
+
+int stmmac_config_dma_channel(struct stmmac_priv *priv)
+{
+	u32 rx_channels_count = priv->plat->rx_queues_to_use;
+	u32 tx_channels_count = priv->plat->tx_queues_to_use;
+	struct stmmac_rx_queue *rx_q;
+	struct stmmac_tx_queue *tx_q;
+	u32 chan = 0;
+	int ret = 0;
+
+	if (!priv->plat->dma_cfg || !priv->plat->dma_cfg->pbl) {
+		dev_err(priv->device, "Invalid DMA configuration\n");
+		return -EINVAL;
+	}
+
+	/* DMA RX Channel Configuration */
+	for (chan = 0; chan < rx_channels_count; chan++) {
+		rx_q = &priv->rx_queue[chan];
+
+		stmmac_init_rx_chan(priv, priv->ioaddr, priv->plat->dma_cfg,
+				    rx_q->dma_rx_phy, chan);
+
+		rx_q->rx_tail_addr = rx_q->dma_rx_phy +
+				     (priv->dma_rx_size *
+				      sizeof(struct dma_desc));
+		stmmac_set_rx_tail_ptr(priv, priv->ioaddr,
+				       rx_q->rx_tail_addr, chan);
+	}
+
+	/* DMA TX Channel Configuration */
+	for (chan = 0; chan < tx_channels_count; chan++) {
+		tx_q = &priv->tx_queue[chan];
+
+		stmmac_init_tx_chan(priv, priv->ioaddr, priv->plat->dma_cfg,
+				    tx_q->dma_tx_phy, chan);
+
+		tx_q->tx_tail_addr = tx_q->dma_tx_phy;
+		stmmac_set_tx_tail_ptr(priv, priv->ioaddr,
+				       tx_q->tx_tail_addr, chan);
+	}
+
+	return ret;
+}
+#endif /* CONFIG_STMMAC_NETWORK_PROXY */
+
 /**
  * stmmac_resume - resume callback
  * @dev: device pointer
@@ -7570,6 +7837,10 @@ int stmmac_resume(struct device *dev)
 {
 	struct net_device *ndev = dev_get_drvdata(dev);
 	struct stmmac_priv *priv = netdev_priv(ndev);
+#ifdef CONFIG_STMMAC_NETWORK_PROXY
+	stmmac_pm_resume(priv, priv, ndev);
+#else
+
 	int ret;
 
 	if (!netif_running(ndev))
@@ -7632,7 +7903,7 @@ int stmmac_resume(struct device *dev)
 	rtnl_unlock();
 
 	netif_device_attach(ndev);
-
+#endif /* ndef CONFIG_STMMAC_NETWORK_PROXY */
 	return 0;
 }
 EXPORT_SYMBOL_GPL(stmmac_resume);
@@ -7704,6 +7975,13 @@ static void __exit stmmac_exit(void)
 #endif
 }
 
+#ifdef CONFIG_STMMAC_NETWORK_PROXY
+const struct stmmac_pm_ops dwmac_pm_ops = {
+	.suspend = stmmac_suspend_main,
+	.resume = stmmac_resume_main,
+};
+#endif
+
 module_init(stmmac_init)
 module_exit(stmmac_exit)
 
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_netproxy.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_netproxy.c
new file mode 100644
index 000000000000..aa2f1bbe9010
--- /dev/null
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_netproxy.c
@@ -0,0 +1,249 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Copyright (c) 2022, Intel Corporation. */
+
+#include <linux/netdevice.h>
+#include <linux/network_proxy.h>
+#include <linux/semaphore.h>
+#include <linux/stmmac.h>
+#include <linux/workqueue.h>
+#include "stmmac.h"
+#include "stmmac_netproxy.h"
+#include "stmmac_platform.h"
+
+/* network device context attached to network proxy framework */
+static struct np_netdev np_netdev = { 0 };
+static struct np_shm np_shm = { NULL };
+
+/*  netproxy_isr - Network Proxy interrupt service routine
+ *  @irq: interrupt number.
+ *  @dev_id: to pass the net device pointer.
+ *  Description: ISR to service Network Proxy interrupt.
+ */
+irqreturn_t netproxy_isr(int irq, void *dev_id)
+{
+	struct net_device *ndev = (struct net_device *)dev_id;
+	struct stmmac_priv *priv = netdev_priv(ndev);
+	u32 value;
+
+	value = readl(priv->ioaddr + GBE_PROXYMODE_EXIT_STS_REG);
+	writel(value, priv->ioaddr + GBE_PROXYMODE_EXIT_STS_REG);
+
+	if (!netif_running(ndev)) {
+		netdev_err(priv->dev,
+			   "Netprox exit failed: netdev is not running\n");
+		return IRQ_HANDLED;
+	}
+
+	return IRQ_WAKE_THREAD;
+}
+
+/*  netproxy_isr_thread - Network Proxy ISR thread
+ *  @irq: interrupt number.
+ *  @dev_id: to pass the net device pointer.
+ *  Description: Thread to service Network Proxy interrupt.
+ */
+irqreturn_t netproxy_isr_thread(int irq, void *dev_id)
+{
+	int a2h_pkt_hdr_len = sizeof(struct np_a2h_packet_header);
+	struct net_device *ndev = (struct net_device *)dev_id;
+	int a2h_hdr_len = sizeof(struct np_a2h_pool_header);
+	struct stmmac_priv *priv = netdev_priv(ndev);
+	struct np_a2h_packet_header a2h_pkt_hdr;
+	struct np_a2h_pool_header a2h_hdr;
+	struct stmmac_channel *ch;
+	void __iomem *a2h_mem_ptr;
+	void __iomem *pkt_content;
+	struct sk_buff *skb;
+	unsigned long flags;
+	int i;
+
+	a2h_mem_ptr = priv->ioaddr + NETWORK_PROXY_SHMEM_OFFSET;
+	ch = &priv->channel[0];
+
+	/* Get A2H memory pool header */
+	memcpy_fromio((void *)&a2h_hdr, a2h_mem_ptr, a2h_hdr_len);
+	a2h_mem_ptr += a2h_hdr_len;
+
+	/* TODO: Create workqueue and mutex for each packet */
+	/* Attach A2H Rx buffer to sk_buff then use napi_gro_receive() */
+	for (i = 0; i < a2h_hdr.total_packets; i++) {
+		/* Get A2H packet header */
+		memcpy_fromio((void *)&a2h_pkt_hdr, a2h_mem_ptr,
+			      a2h_pkt_hdr_len);
+		pkt_content = a2h_mem_ptr + a2h_pkt_hdr_len;
+
+		/* Once the length of A2H packet is found to be equal to zero,
+		 * all the remaining A2H packets will be ignored.
+		 */
+		if (!a2h_pkt_hdr.pkt_len) {
+			netdev_err(priv->dev,
+				   "Netprox failed to submit a2h packets.\n");
+			goto err_skb;
+		}
+
+		local_irq_save(flags);
+		skb = napi_alloc_skb(&ch->rx_napi, a2h_pkt_hdr.pkt_len);
+		local_irq_restore(flags);
+		if (!skb)
+			goto err_skb;
+
+		/* Get A2H packet content */
+		skb_copy_to_linear_data(skb, pkt_content, a2h_pkt_hdr.pkt_len);
+
+		skb_put(skb, a2h_pkt_hdr.pkt_len);
+		skb->protocol = eth_type_trans(skb, priv->dev);
+		skb->ip_summed = CHECKSUM_UNNECESSARY;
+
+		/* Submit skbuf to queue 0 */
+		skb_record_rx_queue(skb, 0);
+		napi_gro_receive(&ch->rx_napi, skb);
+		skb = NULL;
+
+		/* Move the pointer the next A2H packet header */
+		a2h_mem_ptr += NP_A2H_PKT_MAX + a2h_pkt_hdr_len;
+	}
+
+err_skb:
+	priv->networkproxy_exit = 1;
+	stmmac_resume_common(priv, ndev);
+	priv->networkproxy_exit = 0;
+	netif_device_attach(ndev);
+
+	if (napi_schedule_prep(&ch->rx_napi)) {
+		spin_lock_irqsave(&ch->lock, flags);
+		stmmac_disable_dma_irq(priv, priv->ioaddr, 0, 1, 0);
+		spin_unlock_irqrestore(&ch->lock, flags);
+		__napi_schedule(&ch->rx_napi);
+	}
+
+	return IRQ_HANDLED;
+}
+
+/**
+ * stmmac_netprox_suspend - stmmac suspend function for
+ * ECMA-393 Network Proxy technology
+ * @priv: driver private structure
+ * @ndev: net device structure
+ * Description: The common function entry to trigger stmmac driver to
+ * enter Network Proxy mode. This function can be called from below:-
+ * a) Linux PM :- echo mem > /sys/power/state
+ * b) User-space Network Proxy library
+ */
+static int stmmac_netprox_suspend(struct stmmac_priv *priv,
+				  struct net_device *ndev)
+{
+	int result = 1;
+	int retry = 5;
+
+	if (!ndev || !netif_running(ndev))
+		return 0;
+
+	/* do generic suspend if Network Proxy Agent is not ready */
+	if (!netprox_agent_is_ready()) {
+		netdev_err(priv->dev, "Netprox is not ready\n");
+		return stmmac_suspend_main(priv, ndev);
+	}
+
+	/* Check MAC is not WIP in frame transmission from MTL Tx */
+	do {
+		result = stmmac_mtl_tx_completed(priv, priv->ioaddr,
+						 priv->plat->tx_queues_to_use);
+		usleep_range(1000, 2000);
+	} while (retry-- > 0 && result);
+
+	/* Message Network Proxy Agent to enter proxy mode */
+	netprox_host_proxy_enter();
+
+	stmmac_suspend_common(priv, ndev);
+
+	/* Change the destination of MAC controller interrupt and DMA transfer
+	 * from Network Proxy Host to Agent.
+	 */
+	writel(GBE_PROXYMODE_ENTER, priv->ioaddr + GBE_PROXYMODE_REG);
+
+	return 0;
+}
+
+/**
+ * stmmac_netprox_resume - stmmac resume function for
+ * ECMA-393 Network Proxy technology
+ * @priv: driver private structure
+ * @ndev: net device structure
+ * Description: The common function entry to trigger stmmac driver to
+ * exit Network Proxy mode. This function can be called from below:-
+ * a) Network Proxy Host message Agent to exit proxy mode
+ *
+ */
+static int stmmac_netprox_resume(struct stmmac_priv *priv,
+				 struct net_device *ndev)
+{
+	/* do generic resume if Network Proxy Agent is not ready */
+	if (!netprox_agent_is_ready()) {
+		netdev_err(priv->dev, "Netprox is not ready\n");
+		return stmmac_resume_main(priv, ndev);
+	}
+
+	/* Message Network Proxy Agent to exit Proxy mode */
+	netprox_host_proxy_exit();
+
+	return 0;
+}
+
+/**
+ * stmmac_netproxy_wakeup_enable - stmmac network proxy wakeup enable function
+ * @ndev: net device structure
+ * @enable: 1: enable; 0: disable
+ * Description: Enable/disable Network Proxy to wake up system
+ */
+static void stmmac_netproxy_wakeup_enable(struct net_device *ndev, bool enable)
+{
+	struct stmmac_priv *priv = netdev_priv(ndev);
+
+	device_set_wakeup_enable(priv->device, enable);
+}
+
+/**
+ * stmmac_netproxy_register - register to network proxy framework
+ * @ndev: net device structure
+ * Description: register to network proxy framework after stmmac_open() success
+ */
+int stmmac_netproxy_register(struct net_device *ndev)
+{
+	struct stmmac_priv *priv = netdev_priv(ndev);
+
+	/* Allocate workqueue */
+	priv->netprox_wq = create_singlethread_workqueue("netprox_wq");
+	if (!priv->netprox_wq) {
+		dev_err(priv->device, "failed to create netprox workqueue\n");
+		return -1;
+	}
+
+	np_netdev.netdev = ndev;
+	np_netdev.proxy_wakeup_enable = &stmmac_netproxy_wakeup_enable;
+
+	/* TODO: check registration is success */
+	netprox_register_netdev(&np_netdev, NULL, 0);
+
+	np_shm.shm_ptr = (char *)priv->ioaddr + NETWORK_PROXY_SHMEM_OFFSET;
+	np_shm.shm_max_len = NETWORK_PROXY_SHMEM_LEN;
+	netprox_register_shm(&np_shm);
+
+	return 0;
+}
+EXPORT_SYMBOL(stmmac_netproxy_register);
+
+int stmmac_netproxy_deregister(struct net_device *ndev)
+{
+	struct stmmac_priv *priv = netdev_priv(ndev);
+
+	if (priv->netprox_wq)
+		destroy_workqueue(priv->netprox_wq);
+
+	return 0;
+}
+EXPORT_SYMBOL(stmmac_netproxy_deregister);
+
+const struct stmmac_pm_ops dwmac_netprox_pm_ops = {
+	.suspend = stmmac_netprox_suspend,
+	.resume = stmmac_netprox_resume,
+};
\ No newline at end of file
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_netproxy.h b/drivers/net/ethernet/stmicro/stmmac/stmmac_netproxy.h
new file mode 100644
index 000000000000..0cc6e315e092
--- /dev/null
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_netproxy.h
@@ -0,0 +1,24 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (c) 2022, Intel Corporation. */
+
+#ifndef __STMMAC_NETWORK_PROXY_H__
+#define __STMMAC_NETWORK_PROXY_H__
+
+/* Proxy mode register in GBE MISC for enter Proxy Mode */
+#define GBE_PROXYMODE_REG		0x10600
+#define GBE_PROXYMODE_ENTER		BIT(0)
+
+/* Proxy mode exit interrupt register. */
+#define GBE_PROXYMODE_EXIT_STS_REG	0x10604
+#define GBE_PROXYMODE_EXIT_STS_TRUE	BIT(0)
+
+/* Shared memory for A2H Packets */
+#define NETWORK_PROXY_SHMEM_OFFSET	(128 * 1024)
+#define NETWORK_PROXY_SHMEM_LEN		(128 * 1024)
+
+int stmmac_netproxy_register(struct net_device *netdev);
+int stmmac_netproxy_deregister(struct net_device *netdev);
+irqreturn_t netproxy_isr(int irq, void *dev_id);
+irqreturn_t netproxy_isr_thread(int irq, void *dev_id);
+
+#endif /* __STMMAC_NETPROXY_H__ */
\ No newline at end of file
diff --git a/include/linux/stmmac.h b/include/linux/stmmac.h
index 18d4d736514f..4c40eb4b1492 100644
--- a/include/linux/stmmac.h
+++ b/include/linux/stmmac.h
@@ -257,6 +257,9 @@ struct plat_stmmacenet_data {
 	int mac_port_sel_speed;
 	bool en_tx_lpi_clockgating;
 	int has_xgmac;
+#ifdef CONFIG_STMMAC_NETWORK_PROXY
+	int has_netproxy;
+#endif
 	bool vlan_fail_q_en;
 	u8 vlan_fail_q;
 	unsigned int eee_usecs_rate;
-- 
2.25.1

