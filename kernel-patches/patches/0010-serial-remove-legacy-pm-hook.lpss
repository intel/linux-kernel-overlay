From 86345bde9ddaf7ee34dedeaee9c0e372ddacae89 Mon Sep 17 00:00:00 2001
From: "Balaramegowda, ChandanaX Goravi"
 <chandanax.goravi.balaramegowda@intel.com>
Date: Mon, 7 Feb 2022 18:07:51 +0530
Subject: [PATCH 10/12] serial: *: remove legacy ->pm() hook

Since we switch to runtime PM the old PM hook is not needed anymore.

TODO: Use of serial8250_set_sleep() ?
TODO: serial: *: enable runtime PM

Enable runtime PM for all ports unconditionally. Set autosuspend time to
infinity (-1) to avoid port being shutdown when using, for example, as a
serial console since there is no means to resume it back.

Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
---
 arch/arm/mach-omap1/board-ams-delta.c | 27 -------------------
 arch/arm/mach-sa1100/assabet.c        | 18 -------------
 arch/arm/mach-sa1100/badge4.c         | 13 ---------
 arch/arm/mach-sa1100/h3xxx.c          | 13 ---------
 arch/arm/mach-sa1100/hackkit.c        | 19 --------------
 arch/arm/mach-sa1100/simpad.c         | 22 ----------------
 arch/mips/alchemy/common/platform.c   | 21 ---------------
 drivers/tty/serial/8250/8250_core.c   |  1 -
 drivers/tty/serial/8250/8250_exar.c   | 12 ---------
 drivers/tty/serial/8250/8250_mtk.c    | 15 -----------
 drivers/tty/serial/8250/8250_omap.c   | 23 ----------------
 drivers/tty/serial/8250/8250_port.c   | 11 --------
 drivers/tty/serial/atmel_serial.c     | 38 ---------------------------
 drivers/tty/serial/dz.c               | 26 +-----------------
 drivers/tty/serial/mpc52xx_uart.c     |  1 -
 drivers/tty/serial/msm_serial.c       | 20 --------------
 drivers/tty/serial/omap-serial.c      | 21 ---------------
 drivers/tty/serial/pch_uart.c         |  1 -
 drivers/tty/serial/pxa.c              | 13 ---------
 drivers/tty/serial/qcom_geni_serial.c | 21 ---------------
 drivers/tty/serial/sa1100.c           |  1 -
 drivers/tty/serial/samsung_tty.c      | 35 ------------------------
 drivers/tty/serial/sc16is7xx.c        |  7 -----
 drivers/tty/serial/serial_txx9.c      | 19 +-------------
 drivers/tty/serial/sh-sci.c           | 16 -----------
 drivers/tty/serial/sprd_serial.c      | 22 ----------------
 drivers/tty/serial/st-asc.c           | 27 -------------------
 drivers/tty/serial/stm32-usart.c      | 23 ----------------
 drivers/tty/serial/uartlite.c         | 16 -----------
 drivers/tty/serial/xilinx_uartps.c    | 15 -----------
 drivers/tty/serial/zs.c               | 20 --------------
 include/linux/serial_8250.h           |  2 --
 32 files changed, 2 insertions(+), 537 deletions(-)

Index: b/arch/arm/mach-omap1/board-ams-delta.c
===================================================================
--- a/arch/arm/mach-omap1/board-ams-delta.c
+++ b/arch/arm/mach-omap1/board-ams-delta.c
@@ -740,32 +740,6 @@ static void __init ams_delta_init(void)
 	omapfb_set_lcd_config(&ams_delta_lcd_config);
 }
 
-static void modem_pm(struct uart_port *port, unsigned int state, unsigned old)
-{
-	struct modem_private_data *priv = port->private_data;
-	int ret;
-
-	if (!priv)
-		return;
-
-	if (IS_ERR(priv->regulator))
-		return;
-
-	if (state == old)
-		return;
-
-	if (state == 0)
-		ret = regulator_enable(priv->regulator);
-	else if (old == 0)
-		ret = regulator_disable(priv->regulator);
-	else
-		ret = 0;
-
-	if (ret)
-		dev_warn(port->dev,
-			 "ams_delta modem_pm: failed to %sable regulator: %d\n",
-			 state ? "dis" : "en", ret);
-}
 
 static struct plat_serial8250_port ams_delta_modem_ports[] = {
 	{
@@ -777,7 +751,6 @@ static struct plat_serial8250_port ams_d
 		.iotype		= UPIO_MEM,
 		.regshift	= 1,
 		.uartclk	= BASE_BAUD * 16,
-		.pm		= modem_pm,
 		.private_data	= &modem_priv,
 	},
 	{ },
Index: b/arch/arm/mach-sa1100/assabet.c
===================================================================
--- a/arch/arm/mach-sa1100/assabet.c
+++ b/arch/arm/mach-sa1100/assabet.c
@@ -681,21 +681,6 @@ fixup_assabet(struct tag *tags, char **c
 		printk("Neponset expansion board detected\n");
 }
 
-
-static void assabet_uart_pm(struct uart_port *port, u_int state, u_int oldstate)
-{
-	if (port->mapbase == _Ser1UTCR0) {
-		if (state)
-			ASSABET_BCR_clear(ASSABET_BCR_RS232EN);
-		else
-			ASSABET_BCR_set(ASSABET_BCR_RS232EN);
-	}
-}
-
-static struct sa1100_port_fns assabet_port_fns __initdata = {
-	.pm		= assabet_uart_pm,
-};
-
 static struct map_desc assabet_io_desc[] __initdata = {
   	{	/* Board Control Register */
 		.virtual	=  0xf1000000,
@@ -724,9 +709,6 @@ static void __init assabet_map_io(void)
 		MSC_NonBrst | MSC_32BitStMem |
 		MSC_RdAcc(2) | MSC_WrAcc(2) | MSC_Rec(0);
 
-	if (!machine_has_neponset())
-		sa1100_register_uart_fns(&assabet_port_fns);
-
 	/*
 	 * When Neponset is attached, the first UART should be
 	 * UART3.  That's what Angel is doing and many documents
Index: b/arch/arm/mach-sa1100/badge4.c
===================================================================
--- a/arch/arm/mach-sa1100/badge4.c
+++ b/arch/arm/mach-sa1100/badge4.c
@@ -302,24 +302,11 @@ static struct map_desc badge4_io_desc[]
 	}
 };
 
-static void
-badge4_uart_pm(struct uart_port *port, u_int state, u_int oldstate)
-{
-	if (!state) {
-		Ser1SDCR0 |= SDCR0_UART;
-	}
-}
-
-static struct sa1100_port_fns badge4_port_fns __initdata = {
-	.pm		= badge4_uart_pm,
-};
-
 static void __init badge4_map_io(void)
 {
 	sa1100_map_io();
 	iotable_init(badge4_io_desc, ARRAY_SIZE(badge4_io_desc));
 
-	sa1100_register_uart_fns(&badge4_port_fns);
 	sa1100_register_uart(0, 3);
 	sa1100_register_uart(1, 1);
 }
Index: b/arch/arm/mach-sa1100/h3xxx.c
===================================================================
--- a/arch/arm/mach-sa1100/h3xxx.c
+++ b/arch/arm/mach-sa1100/h3xxx.c
@@ -83,18 +83,6 @@ static struct resource h3xxx_flash_resou
 /*
  * H3xxx uart support
  */
-static void h3xxx_uart_pm(struct uart_port *port, u_int state, u_int oldstate)
-{
-	if (port->mapbase == _Ser3UTCR0) {
-		if (!gpio_request(H3XXX_EGPIO_RS232_ON, "RS232 transceiver")) {
-			gpio_direction_output(H3XXX_EGPIO_RS232_ON, !state);
-			gpio_free(H3XXX_EGPIO_RS232_ON);
-		} else {
-			pr_err("%s: can't request H3XXX_EGPIO_RS232_ON\n",
-				__func__);
-		}
-	}
-}
 
 /*
  * Enable/Disable wake up events for this serial port.
@@ -115,7 +103,6 @@ static int h3xxx_uart_set_wake(struct ua
 }
 
 static struct sa1100_port_fns h3xxx_port_fns __initdata = {
-	.pm		= h3xxx_uart_pm,
 	.set_wake	= h3xxx_uart_set_wake,
 };
 
Index: b/arch/arm/mach-sa1100/hackkit.c
===================================================================
--- a/arch/arm/mach-sa1100/hackkit.c
+++ b/arch/arm/mach-sa1100/hackkit.c
@@ -45,8 +45,6 @@
 /* init funcs */
 static void __init hackkit_map_io(void);
 
-static void hackkit_uart_pm(struct uart_port *port, u_int state, u_int oldstate);
-
 /**********************************************************************
  *  global data
  */
@@ -64,10 +62,6 @@ static struct map_desc hackkit_io_desc[]
 	},
 };
 
-static struct sa1100_port_fns hackkit_port_fns __initdata = {
-	.pm		= hackkit_uart_pm,
-};
-
 /**********************************************************************
  *  Static functions
  */
@@ -77,7 +71,6 @@ static void __init hackkit_map_io(void)
 	sa1100_map_io();
 	iotable_init(hackkit_io_desc, ARRAY_SIZE(hackkit_io_desc));
 
-	sa1100_register_uart_fns(&hackkit_port_fns);
 	sa1100_register_uart(0, 1);	/* com port */
 	sa1100_register_uart(1, 2);
 	sa1100_register_uart(2, 3);	/* radio module */
@@ -85,18 +78,6 @@ static void __init hackkit_map_io(void)
 	Ser1SDCR0 |= SDCR0_SUS;
 }
 
-/**
- *	hackkit_uart_pm - powermgmt callback function for system 3 UART
- *	@port: uart port structure
- *	@state: pm state
- *	@oldstate: old pm state
- *
- */
-static void hackkit_uart_pm(struct uart_port *port, u_int state, u_int oldstate)
-{
-	/* TODO: switch on/off uart in powersave mode */
-}
-
 static struct mtd_partition hackkit_partitions[] = {
 	{
 		.name		= "BLOB",
Index: b/arch/arm/mach-sa1100/simpad.c
===================================================================
--- a/arch/arm/mach-sa1100/simpad.c
+++ b/arch/arm/mach-sa1100/simpad.c
@@ -134,27 +134,6 @@ static struct map_desc simpad_io_desc[]
 	},
 };
 
-
-static void simpad_uart_pm(struct uart_port *port, u_int state, u_int oldstate)
-{
-	if (port->mapbase == (u_int)&Ser1UTCR0) {
-		if (state)
-		{
-			simpad_clear_cs3_bit(RS232_ON);
-			simpad_clear_cs3_bit(DECT_POWER_ON);
-		}else
-		{
-			simpad_set_cs3_bit(RS232_ON);
-			simpad_set_cs3_bit(DECT_POWER_ON);
-		}
-	}
-}
-
-static struct sa1100_port_fns simpad_port_fns __initdata = {
-	.pm	   = simpad_uart_pm,
-};
-
-
 static struct mtd_partition simpad_partitions[] = {
 	{
 		.name       = "SIMpad boot firmware",
@@ -207,7 +186,6 @@ static void __init simpad_map_io(void)
 		RS232_ON | ENABLE_5V | RESET_SIMCARD | DECT_POWER_ON);
 	__simpad_write_cs3(); /* Spinlocks not yet initialized */
 
-        sa1100_register_uart_fns(&simpad_port_fns);
 	sa1100_register_uart(0, 3);  /* serial interface */
 	sa1100_register_uart(1, 1);  /* DECT             */
 
Index: b/arch/mips/alchemy/common/platform.c
===================================================================
--- a/arch/mips/alchemy/common/platform.c
+++ b/arch/mips/alchemy/common/platform.c
@@ -28,26 +28,6 @@
 
 #include <prom.h>
 
-static void alchemy_8250_pm(struct uart_port *port, unsigned int state,
-			    unsigned int old_state)
-{
-#ifdef CONFIG_SERIAL_8250
-	switch (state) {
-	case 0:
-		alchemy_uart_enable(CPHYSADDR(port->membase));
-		serial8250_do_pm(port, state, old_state);
-		break;
-	case 3:		/* power off */
-		serial8250_do_pm(port, state, old_state);
-		alchemy_uart_disable(CPHYSADDR(port->membase));
-		break;
-	default:
-		serial8250_do_pm(port, state, old_state);
-		break;
-	}
-#endif
-}
-
 #define PORT(_base, _irq)					\
 	{							\
 		.mapbase	= _base,			\
@@ -57,7 +37,6 @@ static void alchemy_8250_pm(struct uart_
 		.flags		= UPF_SKIP_TEST | UPF_IOREMAP | \
 				  UPF_FIXED_TYPE,		\
 		.type		= PORT_16550A,			\
-		.pm		= alchemy_8250_pm,		\
 	}
 
 static struct plat_serial8250_port au1x00_uart_data[][4] __initdata = {
Index: b/drivers/tty/serial/8250/8250_core.c
===================================================================
--- a/drivers/tty/serial/8250/8250_core.c
+++ b/drivers/tty/serial/8250/8250_core.c
@@ -852,7 +852,6 @@ static int serial8250_probe(struct platf
 		uart.port.set_termios	= p->set_termios;
 		uart.port.set_ldisc	= p->set_ldisc;
 		uart.port.get_mctrl	= p->get_mctrl;
-		uart.port.pm		= p->pm;
 		uart.port.dev		= &dev->dev;
 		uart.port.irqflags	|= irqflag;
 		ret = serial8250_register_8250_port(&uart);
Index: b/drivers/tty/serial/8250/8250_exar.c
===================================================================
--- a/drivers/tty/serial/8250/8250_exar.c
+++ b/drivers/tty/serial/8250/8250_exar.c
@@ -151,17 +151,6 @@ struct exar8250 {
 	int			line[];
 };
 
-static void exar_pm(struct uart_port *port, unsigned int state, unsigned int old)
-{
-	/*
-	 * Exar UARTs have a SLEEP register that enables or disables each UART
-	 * to enter sleep mode separately. On the XR17V35x the register
-	 * is accessible to each UART at the UART_EXAR_SLEEP offset, but
-	 * the UART channel may only write to the corresponding bit.
-	 */
-	serial_port_out(port, UART_EXAR_SLEEP, state ? 0xff : 0);
-}
-
 /*
  * XR17V35x UARTs have an extra fractional divisor register (DLD)
  * Calculate divisor with extra 4-bit fractional portion
@@ -258,7 +247,6 @@ static int default_setup(struct exar8250
 		port->port.type = PORT_XR17D15X;
 	}
 
-	port->port.pm = exar_pm;
 	port->port.shutdown = exar_shutdown;
 
 	return 0;
Index: b/drivers/tty/serial/8250/8250_mtk.c
===================================================================
--- a/drivers/tty/serial/8250/8250_mtk.c
+++ b/drivers/tty/serial/8250/8250_mtk.c
@@ -480,20 +480,6 @@ static int __maybe_unused mtk8250_runtim
 	return 0;
 }
 
-static void
-mtk8250_do_pm(struct uart_port *port, unsigned int state, unsigned int old)
-{
-	if (!state)
-		if (!mtk8250_runtime_resume(port->dev))
-			pm_runtime_get_sync(port->dev);
-
-	serial8250_do_pm(port, state, old);
-
-	if (state)
-		if (!pm_runtime_put_sync_suspend(port->dev))
-			mtk8250_runtime_suspend(port->dev);
-}
-
 #ifdef CONFIG_SERIAL_8250_DMA
 static bool mtk8250_dma_filter(struct dma_chan *chan, void *param)
 {
@@ -584,7 +570,6 @@ static int mtk8250_probe(struct platform
 	spin_lock_init(&uart.port.lock);
 	uart.port.mapbase = regs->start;
 	uart.port.irq = irq;
-	uart.port.pm = mtk8250_do_pm;
 	uart.port.type = PORT_16550;
 	uart.port.flags = UPF_BOOT_AUTOCONF | UPF_FIXED_PORT;
 	uart.port.dev = &pdev->dev;
Index: b/drivers/tty/serial/8250/8250_omap.c
===================================================================
--- a/drivers/tty/serial/8250/8250_omap.c
+++ b/drivers/tty/serial/8250/8250_omap.c
@@ -505,28 +505,6 @@ static void omap_8250_set_termios(struct
 		tty_termios_encode_baud_rate(termios, baud, baud);
 }
 
-/* same as 8250 except that we may have extra flow bits set in EFR */
-static void omap_8250_pm(struct uart_port *port, unsigned int state,
-			 unsigned int oldstate)
-{
-	struct uart_8250_port *up = up_to_u8250p(port);
-	u8 efr;
-
-	pm_runtime_get_sync(port->dev);
-	serial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);
-	efr = serial_in(up, UART_EFR);
-	serial_out(up, UART_EFR, efr | UART_EFR_ECB);
-	serial_out(up, UART_LCR, 0);
-
-	serial8250_set_IER(up, (state != 0) ? UART_IERX_SLEEP : 0);
-	serial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);
-	serial_out(up, UART_EFR, efr);
-	serial_out(up, UART_LCR, 0);
-
-	pm_runtime_mark_last_busy(port->dev);
-	pm_runtime_put_autosuspend(port->dev);
-}
-
 static void omap_serial_fill_features_erratas(struct uart_8250_port *up,
 					      struct omap8250_priv *priv)
 {
@@ -1334,7 +1312,6 @@ static int omap8250_probe(struct platfor
 #endif
 	up.port.set_termios = omap_8250_set_termios;
 	up.port.set_mctrl = omap8250_set_mctrl;
-	up.port.pm = omap_8250_pm;
 	up.port.startup = omap_8250_startup;
 	up.port.shutdown = omap_8250_shutdown;
 	up.port.throttle = omap_8250_throttle;
Index: b/drivers/tty/serial/8250/8250_port.c
===================================================================
--- a/drivers/tty/serial/8250/8250_port.c
+++ b/drivers/tty/serial/8250/8250_port.c
@@ -2977,16 +2977,6 @@ void serial8250_do_pm(struct uart_port *
 }
 EXPORT_SYMBOL(serial8250_do_pm);
 
-static void
-serial8250_pm(struct uart_port *port, unsigned int state,
-	      unsigned int oldstate)
-{
-	if (port->pm)
-		port->pm(port, state, oldstate);
-	else
-		serial8250_do_pm(port, state, oldstate);
-}
-
 static unsigned int serial8250_port_size(struct uart_8250_port *pt)
 {
 	if (pt->port.mapsize)
@@ -3297,7 +3287,6 @@ static const struct uart_ops serial8250_
 	.shutdown	= serial8250_shutdown,
 	.set_termios	= serial8250_set_termios,
 	.set_ldisc	= serial8250_set_ldisc,
-	.pm		= serial8250_pm,
 	.type		= serial8250_type,
 	.release_port	= serial8250_release_port,
 	.request_port	= serial8250_request_port,
Index: b/drivers/tty/serial/atmel_serial.c
===================================================================
--- a/drivers/tty/serial/atmel_serial.c
+++ b/drivers/tty/serial/atmel_serial.c
@@ -2096,43 +2096,6 @@ static void atmel_shutdown(struct uart_p
 }
 
 /*
- * Power / Clock management.
- */
-static void atmel_serial_pm(struct uart_port *port, unsigned int state,
-			    unsigned int oldstate)
-{
-	struct atmel_uart_port *atmel_port = to_atmel_uart_port(port);
-
-	switch (state) {
-	case UART_PM_STATE_ON:
-		/*
-		 * Enable the peripheral clock for this serial port.
-		 * This is called on uart_open() or a resume event.
-		 */
-		clk_prepare_enable(atmel_port->clk);
-
-		/* re-enable interrupts if we disabled some on suspend */
-		atmel_uart_writel(port, ATMEL_US_IER, atmel_port->backup_imr);
-		break;
-	case UART_PM_STATE_OFF:
-		/* Back up the interrupt mask and disable all interrupts */
-		atmel_port->backup_imr = atmel_uart_readl(port, ATMEL_US_IMR);
-		atmel_uart_writel(port, ATMEL_US_IDR, -1);
-
-		/*
-		 * Disable the peripheral clock for this serial port.
-		 * This is called on uart_close() or a suspend event.
-		 */
-		clk_disable_unprepare(atmel_port->clk);
-		if (__clk_is_enabled(atmel_port->gclk))
-			clk_disable_unprepare(atmel_port->gclk);
-		break;
-	default:
-		dev_err(port->dev, "atmel_serial: unknown pm %d\n", state);
-	}
-}
-
-/*
  * Change the port parameters
  */
 static void atmel_set_termios(struct uart_port *port,
@@ -2531,7 +2494,6 @@ static const struct uart_ops atmel_pops
 	.request_port	= atmel_request_port,
 	.config_port	= atmel_config_port,
 	.verify_port	= atmel_verify_port,
-	.pm		= atmel_serial_pm,
 #ifdef CONFIG_CONSOLE_POLL
 	.poll_get_char	= atmel_poll_get_char,
 	.poll_put_char	= atmel_poll_put_char,
Index: b/drivers/tty/serial/dz.c
===================================================================
--- a/drivers/tty/serial/dz.c
+++ b/drivers/tty/serial/dz.c
@@ -635,26 +635,6 @@ static void dz_set_termios(struct uart_p
 	spin_unlock_irqrestore(&dport->port.lock, flags);
 }
 
-/*
- * Hack alert!
- * Required solely so that the initial PROM-based console
- * works undisturbed in parallel with this one.
- */
-static void dz_pm(struct uart_port *uport, unsigned int state,
-		  unsigned int oldstate)
-{
-	struct dz_port *dport = to_dport(uport);
-	unsigned long flags;
-
-	spin_lock_irqsave(&dport->port.lock, flags);
-	if (state < 3)
-		dz_start_tx(&dport->port);
-	else
-		dz_stop_tx(&dport->port);
-	spin_unlock_irqrestore(&dport->port.lock, flags);
-}
-
-
 static const char *dz_type(struct uart_port *uport)
 {
 	return "DZ";
@@ -750,7 +730,6 @@ static const struct uart_ops dz_ops = {
 	.startup	= dz_startup,
 	.shutdown	= dz_shutdown,
 	.set_termios	= dz_set_termios,
-	.pm		= dz_pm,
 	.type		= dz_type,
 	.release_port	= dz_release_port,
 	.request_port	= dz_request_port,
@@ -778,7 +757,7 @@ static void __init dz_init_ports(void)
 		struct uart_port *uport = &dport->port;
 
 		dport->mux	= &dz_mux;
-
+		spin_lock_init(&uport->lock);
 		uport->irq	= dec_interrupt[DEC_IRQ_DZ11];
 		uport->fifosize	= 1;
 		uport->iotype	= UPIO_MEM;
@@ -875,10 +854,7 @@ static int __init dz_console_setup(struc
 	if (ret)
 		return ret;
 
-	spin_lock_init(&dport->port.lock);	/* For dz_pm().  */
-
 	dz_reset(dport);
-	dz_pm(uport, 0, -1);
 
 	if (options)
 		uart_parse_options(options, &baud, &parity, &bits, &flow);
Index: b/drivers/tty/serial/mpc52xx_uart.c
===================================================================
--- a/drivers/tty/serial/mpc52xx_uart.c
+++ b/drivers/tty/serial/mpc52xx_uart.c
@@ -1351,7 +1351,6 @@ static const struct uart_ops mpc52xx_uar
 	.startup	= mpc52xx_uart_startup,
 	.shutdown	= mpc52xx_uart_shutdown,
 	.set_termios	= mpc52xx_uart_set_termios,
-/*	.pm		= mpc52xx_uart_pm,		Not supported yet */
 	.type		= mpc52xx_uart_type,
 	.release_port	= mpc52xx_uart_release_port,
 	.request_port	= mpc52xx_uart_request_port,
Index: b/drivers/tty/serial/msm_serial.c
===================================================================
--- a/drivers/tty/serial/msm_serial.c
+++ b/drivers/tty/serial/msm_serial.c
@@ -1416,25 +1416,6 @@ static int msm_verify_port(struct uart_p
 	return 0;
 }
 
-static void msm_power(struct uart_port *port, unsigned int state,
-		      unsigned int oldstate)
-{
-	struct msm_port *msm_port = to_msm_port(port);
-
-	switch (state) {
-	case 0:
-		clk_prepare_enable(msm_port->clk);
-		clk_prepare_enable(msm_port->pclk);
-		break;
-	case 3:
-		clk_disable_unprepare(msm_port->clk);
-		clk_disable_unprepare(msm_port->pclk);
-		break;
-	default:
-		pr_err("msm_serial: Unknown PM state %d\n", state);
-	}
-}
-
 #ifdef CONFIG_CONSOLE_POLL
 static int msm_poll_get_char_single(struct uart_port *port)
 {
@@ -1553,7 +1534,6 @@ static const struct uart_ops msm_uart_po
 	.request_port = msm_request_port,
 	.config_port = msm_config_port,
 	.verify_port = msm_verify_port,
-	.pm = msm_power,
 #ifdef CONFIG_CONSOLE_POLL
 	.poll_get_char	= msm_poll_get_char,
 	.poll_put_char	= msm_poll_put_char,
Index: b/drivers/tty/serial/omap-serial.c
===================================================================
--- a/drivers/tty/serial/omap-serial.c
+++ b/drivers/tty/serial/omap-serial.c
@@ -1046,26 +1046,6 @@ serial_omap_set_termios(struct uart_port
 	dev_dbg(up->port.dev, "serial_omap_set_termios+%d\n", up->port.line);
 }
 
-static void
-serial_omap_pm(struct uart_port *port, unsigned int state,
-	       unsigned int oldstate)
-{
-	struct uart_omap_port *up = to_uart_omap_port(port);
-	unsigned char efr;
-
-	dev_dbg(up->port.dev, "serial_omap_pm+%d\n", up->port.line);
-
-	serial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);
-	efr = serial_in(up, UART_EFR);
-	serial_out(up, UART_EFR, efr | UART_EFR_ECB);
-	serial_out(up, UART_LCR, 0);
-
-	serial_out(up, UART_IER, (state != 0) ? UART_IERX_SLEEP : 0);
-	serial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);
-	serial_out(up, UART_EFR, efr);
-	serial_out(up, UART_LCR, 0);
-}
-
 static void serial_omap_release_port(struct uart_port *port)
 {
 	dev_dbg(port->dev, "serial_omap_release_port+\n");
@@ -1369,7 +1349,6 @@ static const struct uart_ops serial_omap
 	.startup	= serial_omap_startup,
 	.shutdown	= serial_omap_shutdown,
 	.set_termios	= serial_omap_set_termios,
-	.pm		= serial_omap_pm,
 	.type		= serial_omap_type,
 	.release_port	= serial_omap_release_port,
 	.request_port	= serial_omap_request_port,
Index: b/drivers/tty/serial/pch_uart.c
===================================================================
--- a/drivers/tty/serial/pch_uart.c
+++ b/drivers/tty/serial/pch_uart.c
@@ -1535,7 +1535,6 @@ static const struct uart_ops pch_uart_op
 	.startup = pch_uart_startup,
 	.shutdown = pch_uart_shutdown,
 	.set_termios = pch_uart_set_termios,
-/*	.pm		= pch_uart_pm,		Not supported yet */
 	.type = pch_uart_type,
 	.release_port = pch_uart_release_port,
 	.request_port = pch_uart_request_port,
Index: b/drivers/tty/serial/pxa.c
===================================================================
--- a/drivers/tty/serial/pxa.c
+++ b/drivers/tty/serial/pxa.c
@@ -530,18 +530,6 @@ serial_pxa_set_termios(struct uart_port
 	spin_unlock_irqrestore(&up->port.lock, flags);
 }
 
-static void
-serial_pxa_pm(struct uart_port *port, unsigned int state,
-	      unsigned int oldstate)
-{
-	struct uart_pxa_port *up = (struct uart_pxa_port *)port;
-
-	if (!state)
-		clk_prepare_enable(up->clk);
-	else
-		clk_disable_unprepare(up->clk);
-}
-
 static void serial_pxa_release_port(struct uart_port *port)
 {
 }
@@ -751,7 +739,6 @@ static const struct uart_ops serial_pxa_
 	.startup	= serial_pxa_startup,
 	.shutdown	= serial_pxa_shutdown,
 	.set_termios	= serial_pxa_set_termios,
-	.pm		= serial_pxa_pm,
 	.type		= serial_pxa_type,
 	.release_port	= serial_pxa_release_port,
 	.request_port	= serial_pxa_request_port,
Index: b/drivers/tty/serial/qcom_geni_serial.c
===================================================================
--- a/drivers/tty/serial/qcom_geni_serial.c
+++ b/drivers/tty/serial/qcom_geni_serial.c
@@ -1321,28 +1321,6 @@ static struct uart_driver qcom_geni_uart
 	.nr =  GENI_UART_PORTS,
 };
 
-static void qcom_geni_serial_pm(struct uart_port *uport,
-		unsigned int new_state, unsigned int old_state)
-{
-	struct qcom_geni_serial_port *port = to_dev_port(uport, uport);
-
-	/* If we've never been called, treat it as off */
-	if (old_state == UART_PM_STATE_UNDEFINED)
-		old_state = UART_PM_STATE_OFF;
-
-	if (new_state == UART_PM_STATE_ON && old_state == UART_PM_STATE_OFF) {
-		geni_icc_enable(&port->se);
-		if (port->clk_rate)
-			dev_pm_opp_set_rate(uport->dev, port->clk_rate);
-		geni_se_resources_on(&port->se);
-	} else if (new_state == UART_PM_STATE_OFF &&
-			old_state == UART_PM_STATE_ON) {
-		geni_se_resources_off(&port->se);
-		dev_pm_opp_set_rate(uport->dev, 0);
-		geni_icc_disable(&port->se);
-	}
-}
-
 static const struct uart_ops qcom_geni_console_pops = {
 	.tx_empty = qcom_geni_serial_tx_empty,
 	.stop_tx = qcom_geni_serial_stop_tx,
@@ -1361,7 +1339,6 @@ static const struct uart_ops qcom_geni_c
 	.poll_get_char	= qcom_geni_serial_get_char,
 	.poll_put_char	= qcom_geni_serial_poll_put_char,
 #endif
-	.pm = qcom_geni_serial_pm,
 };
 
 static const struct uart_ops qcom_geni_uart_pops = {
@@ -1377,7 +1354,6 @@ static const struct uart_ops qcom_geni_u
 	.type = qcom_geni_serial_get_type,
 	.set_mctrl = qcom_geni_serial_set_mctrl,
 	.get_mctrl = qcom_geni_serial_get_mctrl,
-	.pm = qcom_geni_serial_pm,
 };
 
 static int qcom_geni_serial_probe(struct platform_device *pdev)
Index: b/drivers/tty/serial/sa1100.c
===================================================================
--- a/drivers/tty/serial/sa1100.c
+++ b/drivers/tty/serial/sa1100.c
@@ -652,7 +652,6 @@ void sa1100_register_uart_fns(struct sa1
 	if (fns->set_mctrl)
 		sa1100_pops.set_mctrl = fns->set_mctrl;
 
-	sa1100_pops.pm       = fns->pm;
 	/*
 	 * FIXME: fns->set_wake is unused - this should be called from
 	 * the suspend() callback if device_may_wakeup(dev)) is set.
Index: b/drivers/tty/serial/samsung_tty.c
===================================================================
--- a/drivers/tty/serial/samsung_tty.c
+++ b/drivers/tty/serial/samsung_tty.c
@@ -1366,38 +1366,6 @@ static int apple_s5l_serial_startup(stru
 	return ret;
 }
 
-/* power power management control */
-
-static void s3c24xx_serial_pm(struct uart_port *port, unsigned int level,
-			      unsigned int old)
-{
-	struct s3c24xx_uart_port *ourport = to_ourport(port);
-	int timeout = 10000;
-
-	ourport->pm_level = level;
-
-	switch (level) {
-	case 3:
-		while (--timeout && !s3c24xx_serial_txempty_nofifo(port))
-			udelay(100);
-
-		if (!IS_ERR(ourport->baudclk))
-			clk_disable_unprepare(ourport->baudclk);
-
-		clk_disable_unprepare(ourport->clk);
-		break;
-
-	case 0:
-		clk_prepare_enable(ourport->clk);
-
-		if (!IS_ERR(ourport->baudclk))
-			clk_prepare_enable(ourport->baudclk);
-		break;
-	default:
-		dev_err(port->dev, "s3c24xx_serial: unknown pm %d\n", level);
-	}
-}
-
 /* baud rate calculation
  *
  * The UARTs on the S3C2410/S3C2440 can take their clocks from a number
@@ -1762,7 +1730,6 @@ static void s3c24xx_serial_put_poll_char
 #endif
 
 static const struct uart_ops s3c24xx_serial_ops = {
-	.pm		= s3c24xx_serial_pm,
 	.tx_empty	= s3c24xx_serial_tx_empty,
 	.get_mctrl	= s3c24xx_serial_get_mctrl,
 	.set_mctrl	= s3c24xx_serial_set_mctrl,
@@ -1783,7 +1750,6 @@ static const struct uart_ops s3c24xx_ser
 };
 
 static const struct uart_ops s3c64xx_serial_ops = {
-	.pm		= s3c24xx_serial_pm,
 	.tx_empty	= s3c24xx_serial_tx_empty,
 	.get_mctrl	= s3c24xx_serial_get_mctrl,
 	.set_mctrl	= s3c24xx_serial_set_mctrl,
@@ -1804,7 +1770,6 @@ static const struct uart_ops s3c64xx_ser
 };
 
 static const struct uart_ops apple_s5l_serial_ops = {
-	.pm		= s3c24xx_serial_pm,
 	.tx_empty	= s3c24xx_serial_tx_empty,
 	.get_mctrl	= s3c24xx_serial_get_mctrl,
 	.set_mctrl	= s3c24xx_serial_set_mctrl,
Index: b/drivers/tty/serial/sc16is7xx.c
===================================================================
--- a/drivers/tty/serial/sc16is7xx.c
+++ b/drivers/tty/serial/sc16is7xx.c
@@ -1267,12 +1267,6 @@ static int sc16is7xx_verify_port(struct
 	return 0;
 }
 
-static void sc16is7xx_pm(struct uart_port *port, unsigned int state,
-			 unsigned int oldstate)
-{
-	sc16is7xx_power(port, (state == UART_PM_STATE_ON) ? 1 : 0);
-}
-
 static void sc16is7xx_null_void(struct uart_port *port)
 {
 	/* Do nothing */
@@ -1297,7 +1291,6 @@ static const struct uart_ops sc16is7xx_o
 	.release_port	= sc16is7xx_null_void,
 	.config_port	= sc16is7xx_config_port,
 	.verify_port	= sc16is7xx_verify_port,
-	.pm		= sc16is7xx_pm,
 };
 
 #ifdef CONFIG_GPIOLIB
Index: b/drivers/tty/serial/serial_txx9.c
===================================================================
--- a/drivers/tty/serial/serial_txx9.c
+++ b/drivers/tty/serial/serial_txx9.c
@@ -702,23 +702,7 @@ serial_txx9_set_termios(struct uart_port
 	spin_unlock_irqrestore(&up->lock, flags);
 }
 
-static void
-serial_txx9_pm(struct uart_port *port, unsigned int state,
-	      unsigned int oldstate)
-{
-	/*
-	 * If oldstate was -1 this is called from
-	 * uart_configure_port().  In this case do not initialize the
-	 * port now, because the port was already initialized (for
-	 * non-console port) or should not be initialized here (for
-	 * console port).  If we initialized the port here we lose
-	 * serial console settings.
-	 */
-	if (state == 0 && oldstate != -1)
-		serial_txx9_initialize(port);
-}
-
-static int serial_txx9_request_resource(struct uart_port *up)
+static int serial_txx9_request_resource(struct uart_txx9_port *up)
 {
 	unsigned int size = TXX9_REGION_SIZE;
 	int ret = 0;
@@ -821,7 +805,6 @@ static const struct uart_ops serial_txx9
 	.startup	= serial_txx9_startup,
 	.shutdown	= serial_txx9_shutdown,
 	.set_termios	= serial_txx9_set_termios,
-	.pm		= serial_txx9_pm,
 	.type		= serial_txx9_type,
 	.release_port	= serial_txx9_release_port,
 	.request_port	= serial_txx9_request_port,
Index: b/drivers/tty/serial/sh-sci.c
===================================================================
--- a/drivers/tty/serial/sh-sci.c
+++ b/drivers/tty/serial/sh-sci.c
@@ -2614,21 +2614,6 @@ done:
 		sci_enable_ms(port);
 }
 
-static void sci_pm(struct uart_port *port, unsigned int state,
-		   unsigned int oldstate)
-{
-	struct sci_port *sci_port = to_sci_port(port);
-
-	switch (state) {
-	case UART_PM_STATE_OFF:
-		sci_port_disable(sci_port);
-		break;
-	default:
-		sci_port_enable(sci_port);
-		break;
-	}
-}
-
 static const char *sci_type(struct uart_port *port)
 {
 	switch (port->type) {
@@ -2743,7 +2728,6 @@ static const struct uart_ops sci_uart_op
 	.shutdown	= sci_shutdown,
 	.flush_buffer	= sci_flush_buffer,
 	.set_termios	= sci_set_termios,
-	.pm		= sci_pm,
 	.type		= sci_type,
 	.release_port	= sci_release_port,
 	.request_port	= sci_request_port,
Index: b/drivers/tty/serial/sprd_serial.c
===================================================================
--- a/drivers/tty/serial/sprd_serial.c
+++ b/drivers/tty/serial/sprd_serial.c
@@ -901,30 +901,9 @@ static int sprd_verify_port(struct uart_
 	return 0;
 }
 
-static void sprd_pm(struct uart_port *port, unsigned int state,
-		unsigned int oldstate)
-{
-	struct sprd_uart_port *sup =
-		container_of(port, struct sprd_uart_port, port);
-
-	switch (state) {
-	case UART_PM_STATE_ON:
-		clk_prepare_enable(sup->clk);
-		break;
-	case UART_PM_STATE_OFF:
-		clk_disable_unprepare(sup->clk);
-		break;
-	}
-}
-
 #ifdef CONFIG_CONSOLE_POLL
 static int sprd_poll_init(struct uart_port *port)
 {
-	if (port->state->pm_state != UART_PM_STATE_ON) {
-		sprd_pm(port, UART_PM_STATE_ON, 0);
-		port->state->pm_state = UART_PM_STATE_ON;
-	}
-
 	return 0;
 }
 
@@ -961,7 +940,6 @@ static const struct uart_ops serial_sprd
 	.request_port = sprd_request_port,
 	.config_port = sprd_config_port,
 	.verify_port = sprd_verify_port,
-	.pm = sprd_pm,
 #ifdef CONFIG_CONSOLE_POLL
 	.poll_init	= sprd_poll_init,
 	.poll_get_char	= sprd_poll_get_char,
Index: b/drivers/tty/serial/st-asc.c
===================================================================
--- a/drivers/tty/serial/st-asc.c
+++ b/drivers/tty/serial/st-asc.c
@@ -473,32 +473,6 @@ static void asc_shutdown(struct uart_por
 	free_irq(port->irq, port);
 }
 
-static void asc_pm(struct uart_port *port, unsigned int state,
-		unsigned int oldstate)
-{
-	struct asc_port *ascport = to_asc_port(port);
-	unsigned long flags;
-	u32 ctl;
-
-	switch (state) {
-	case UART_PM_STATE_ON:
-		clk_prepare_enable(ascport->clk);
-		break;
-	case UART_PM_STATE_OFF:
-		/*
-		 * Disable the ASC baud rate generator, which is as close as
-		 * we can come to turning it off. Note this is not called with
-		 * the port spinlock held.
-		 */
-		spin_lock_irqsave(&port->lock, flags);
-		ctl = asc_in(port, ASC_CTL) & ~ASC_CTL_RUN;
-		asc_out(port, ASC_CTL, ctl);
-		spin_unlock_irqrestore(&port->lock, flags);
-		clk_disable_unprepare(ascport->clk);
-		break;
-	}
-}
-
 static void asc_set_termios(struct uart_port *port, struct ktermios *termios,
 			    const struct ktermios *old)
 {
@@ -707,7 +681,6 @@ static const struct uart_ops asc_uart_op
 	.request_port	= asc_request_port,
 	.config_port	= asc_config_port,
 	.verify_port	= asc_verify_port,
-	.pm		= asc_pm,
 #ifdef CONFIG_CONSOLE_POLL
 	.poll_get_char = asc_get_poll_char,
 	.poll_put_char = asc_put_poll_char,
Index: b/drivers/tty/serial/stm32-usart.c
===================================================================
--- a/drivers/tty/serial/stm32-usart.c
+++ b/drivers/tty/serial/stm32-usart.c
@@ -1322,28 +1322,6 @@ stm32_usart_verify_port(struct uart_port
 	return -EINVAL;
 }
 
-static void stm32_usart_pm(struct uart_port *port, unsigned int state,
-			   unsigned int oldstate)
-{
-	struct stm32_port *stm32port = container_of(port,
-			struct stm32_port, port);
-	const struct stm32_usart_offsets *ofs = &stm32port->info->ofs;
-	const struct stm32_usart_config *cfg = &stm32port->info->cfg;
-	unsigned long flags;
-
-	switch (state) {
-	case UART_PM_STATE_ON:
-		pm_runtime_get_sync(port->dev);
-		break;
-	case UART_PM_STATE_OFF:
-		spin_lock_irqsave(&port->lock, flags);
-		stm32_usart_clr_bits(port, ofs->cr1, BIT(cfg->uart_enable_bit));
-		spin_unlock_irqrestore(&port->lock, flags);
-		pm_runtime_put_sync(port->dev);
-		break;
-	}
-}
-
 #if defined(CONFIG_CONSOLE_POLL)
 
  /* Callbacks for characters polling in debug context (i.e. KGDB). */
@@ -1386,7 +1364,6 @@ static const struct uart_ops stm32_uart_
 	.shutdown	= stm32_usart_shutdown,
 	.flush_buffer	= stm32_usart_flush_buffer,
 	.set_termios	= stm32_usart_set_termios,
-	.pm		= stm32_usart_pm,
 	.type		= stm32_usart_type,
 	.release_port	= stm32_usart_release_port,
 	.request_port	= stm32_usart_request_port,
Index: b/drivers/tty/serial/uartlite.c
===================================================================
--- a/drivers/tty/serial/uartlite.c
+++ b/drivers/tty/serial/uartlite.c
@@ -408,21 +408,6 @@ static int ulite_verify_port(struct uart
 	return -EINVAL;
 }
 
-static void ulite_pm(struct uart_port *port, unsigned int state,
-		     unsigned int oldstate)
-{
-	int ret;
-
-	if (!state) {
-		ret = pm_runtime_get_sync(port->dev);
-		if (ret < 0)
-			dev_err(port->dev, "Failed to enable clocks\n");
-	} else {
-		pm_runtime_mark_last_busy(port->dev);
-		pm_runtime_put_autosuspend(port->dev);
-	}
-}
-
 #ifdef CONFIG_CONSOLE_POLL
 static int ulite_get_poll_char(struct uart_port *port)
 {
@@ -458,7 +443,6 @@ static const struct uart_ops ulite_ops =
 	.request_port	= ulite_request_port,
 	.config_port	= ulite_config_port,
 	.verify_port	= ulite_verify_port,
-	.pm		= ulite_pm,
 #ifdef CONFIG_CONSOLE_POLL
 	.poll_get_char	= ulite_get_poll_char,
 	.poll_put_char	= ulite_put_poll_char,
Index: b/drivers/tty/serial/xilinx_uartps.c
===================================================================
--- a/drivers/tty/serial/xilinx_uartps.c
+++ b/drivers/tty/serial/xilinx_uartps.c
@@ -1086,20 +1086,6 @@ static void cdns_uart_poll_put_char(stru
 }
 #endif
 
-static void cdns_uart_pm(struct uart_port *port, unsigned int state,
-		   unsigned int oldstate)
-{
-	switch (state) {
-	case UART_PM_STATE_OFF:
-		pm_runtime_mark_last_busy(port->dev);
-		pm_runtime_put_autosuspend(port->dev);
-		break;
-	default:
-		pm_runtime_get_sync(port->dev);
-		break;
-	}
-}
-
 static const struct uart_ops cdns_uart_ops = {
 	.set_mctrl	= cdns_uart_set_mctrl,
 	.get_mctrl	= cdns_uart_get_mctrl,
@@ -1111,7 +1097,6 @@ static const struct uart_ops cdns_uart_o
 	.set_termios	= cdns_uart_set_termios,
 	.startup	= cdns_uart_startup,
 	.shutdown	= cdns_uart_shutdown,
-	.pm		= cdns_uart_pm,
 	.type		= cdns_uart_type,
 	.verify_port	= cdns_uart_verify_port,
 	.request_port	= cdns_uart_request_port,
Index: b/drivers/tty/serial/zs.c
===================================================================
--- a/drivers/tty/serial/zs.c
+++ b/drivers/tty/serial/zs.c
@@ -955,24 +955,6 @@ static void zs_set_termios(struct uart_p
 	spin_unlock_irqrestore(&scc->zlock, flags);
 }
 
-/*
- * Hack alert!
- * Required solely so that the initial PROM-based console
- * works undisturbed in parallel with this one.
- */
-static void zs_pm(struct uart_port *uport, unsigned int state,
-		  unsigned int oldstate)
-{
-	struct zs_port *zport = to_zport(uport);
-
-	if (state < 3)
-		zport->regs[5] |= TxENAB;
-	else
-		zport->regs[5] &= ~TxENAB;
-	write_zsreg(zport, R5, zport->regs[5]);
-}
-
-
 static const char *zs_type(struct uart_port *uport)
 {
 	return "Z85C30 SCC";
@@ -1054,7 +1036,6 @@ static const struct uart_ops zs_ops = {
 	.startup	= zs_startup,
 	.shutdown	= zs_shutdown,
 	.set_termios	= zs_set_termios,
-	.pm		= zs_pm,
 	.type		= zs_type,
 	.release_port	= zs_release_port,
 	.request_port	= zs_request_port,
@@ -1209,7 +1190,6 @@ static int __init zs_console_setup(struc
 		return ret;
 
 	zs_reset(zport);
-	zs_pm(uport, 0, -1);
 
 	if (options)
 		uart_parse_options(options, &baud, &parity, &bits, &flow);
Index: b/include/linux/serial_8250.h
===================================================================
--- a/include/linux/serial_8250.h
+++ b/include/linux/serial_8250.h
@@ -38,8 +38,6 @@ struct plat_serial8250_port {
 				     struct ktermios *);
 	unsigned int	(*get_mctrl)(struct uart_port *);
 	int		(*handle_irq)(struct uart_port *);
-	void		(*pm)(struct uart_port *, unsigned int state,
-			      unsigned old);
 	void		(*handle_break)(struct uart_port *);
 };
 
