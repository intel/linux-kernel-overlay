From c9ea7d8402a1f22e7afc8d978b355fb63cb01a47 Mon Sep 17 00:00:00 2001
From: "Balaramegowda, ChandanaX Goravi"
 <chandanax.goravi.balaramegowda@intel.com>
Date: Mon, 7 Feb 2022 18:07:51 +0530
Subject: [PATCH 10/10] serial: *: remove legacy ->pm() hook

Since we switch to runtime PM the old PM hook is not needed anymore.

TODO: Use of serial8250_set_sleep() ?
TODO: serial: *: enable runtime PM

Enable runtime PM for all ports unconditionally. Set autosuspend time to
infinity (-1) to avoid port being shutdown when using, for example, as a
serial console since there is no means to resume it back.

Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
---
 Documentation/driver-api/serial/driver.rst | 15 ---------
 arch/arm/mach-omap1/board-ams-delta.c      | 27 ----------------
 arch/arm/mach-sa1100/assabet.c             | 18 -----------
 arch/arm/mach-sa1100/badge4.c              | 13 --------
 arch/arm/mach-sa1100/h3xxx.c               | 13 --------
 arch/arm/mach-sa1100/hackkit.c             | 19 -----------
 arch/arm/mach-sa1100/simpad.c              | 22 -------------
 arch/mips/alchemy/common/platform.c        | 21 ------------
 drivers/tty/serial/8250/8250_core.c        |  1 -
 drivers/tty/serial/8250/8250_exar.c        | 12 -------
 drivers/tty/serial/8250/8250_mtk.c         | 15 ---------
 drivers/tty/serial/8250/8250_omap.c        | 23 --------------
 drivers/tty/serial/8250/8250_port.c        | 11 -------
 drivers/tty/serial/atmel_serial.c          | 36 ---------------------
 drivers/tty/serial/dz.c                    | 26 +--------------
 drivers/tty/serial/mpc52xx_uart.c          |  1 -
 drivers/tty/serial/msm_serial.c            | 20 ------------
 drivers/tty/serial/omap-serial.c           | 21 ------------
 drivers/tty/serial/pch_uart.c              |  1 -
 drivers/tty/serial/pxa.c                   | 13 --------
 drivers/tty/serial/qcom_geni_serial.c      | 21 ------------
 drivers/tty/serial/sa1100.c                |  1 -
 drivers/tty/serial/samsung_tty.c           | 37 ----------------------
 drivers/tty/serial/sc16is7xx.c             |  7 ----
 drivers/tty/serial/serial_txx9.c           | 17 ----------
 drivers/tty/serial/sh-sci.c                | 16 ----------
 drivers/tty/serial/sprd_serial.c           | 22 -------------
 drivers/tty/serial/st-asc.c                | 27 ----------------
 drivers/tty/serial/stm32-usart.c           | 23 --------------
 drivers/tty/serial/uartlite.c              | 16 ----------
 drivers/tty/serial/vr41xx_siu.c            | 27 ----------------
 drivers/tty/serial/xilinx_uartps.c         | 15 ---------
 drivers/tty/serial/zs.c                    | 20 ------------
 include/linux/serial_8250.h                |  2 --
 34 files changed, 1 insertion(+), 578 deletions(-)

diff --git a/Documentation/driver-api/serial/driver.rst b/Documentation/driver-api/serial/driver.rst
index 31bd4e16fb1f..b6269c4f89aa 100644
--- a/Documentation/driver-api/serial/driver.rst
+++ b/Documentation/driver-api/serial/driver.rst
@@ -315,21 +315,6 @@ hardware.
 
 	Locking: caller holds tty_port->mutex
 
-  pm(port,state,oldstate)
-	Perform any power management related activities on the specified
-	port.  State indicates the new state (defined by
-	enum uart_pm_state), oldstate indicates the previous state.
-
-	This function should not be used to grab any resources.
-
-	This will be called when the port is initially opened and finally
-	closed, except when the port is also the system console.  This
-	will occur even if CONFIG_PM is not set.
-
-	Locking: none.
-
-	Interrupts: caller dependent.
-
   type(port)
 	Return a pointer to a string constant describing the specified
 	port, or return NULL, in which case the string 'unknown' is
diff --git a/arch/arm/mach-omap1/board-ams-delta.c b/arch/arm/mach-omap1/board-ams-delta.c
index 1026a816dcc0..4f97302894b2 100644
--- a/arch/arm/mach-omap1/board-ams-delta.c
+++ b/arch/arm/mach-omap1/board-ams-delta.c
@@ -752,32 +752,6 @@ static void __init ams_delta_init(void)
 	omapfb_set_lcd_config(&ams_delta_lcd_config);
 }
 
-static void modem_pm(struct uart_port *port, unsigned int state, unsigned old)
-{
-	struct modem_private_data *priv = port->private_data;
-	int ret;
-
-	if (!priv)
-		return;
-
-	if (IS_ERR(priv->regulator))
-		return;
-
-	if (state == old)
-		return;
-
-	if (state == 0)
-		ret = regulator_enable(priv->regulator);
-	else if (old == 0)
-		ret = regulator_disable(priv->regulator);
-	else
-		ret = 0;
-
-	if (ret)
-		dev_warn(port->dev,
-			 "ams_delta modem_pm: failed to %sable regulator: %d\n",
-			 state ? "dis" : "en", ret);
-}
 
 static struct plat_serial8250_port ams_delta_modem_ports[] = {
 	{
@@ -789,7 +763,6 @@ static struct plat_serial8250_port ams_delta_modem_ports[] = {
 		.iotype		= UPIO_MEM,
 		.regshift	= 1,
 		.uartclk	= BASE_BAUD * 16,
-		.pm		= modem_pm,
 		.private_data	= &modem_priv,
 	},
 	{ },
diff --git a/arch/arm/mach-sa1100/assabet.c b/arch/arm/mach-sa1100/assabet.c
index 2012fa8c28cf..d9786be02246 100644
--- a/arch/arm/mach-sa1100/assabet.c
+++ b/arch/arm/mach-sa1100/assabet.c
@@ -675,21 +675,6 @@ fixup_assabet(struct tag *tags, char **cmdline)
 		printk("Neponset expansion board detected\n");
 }
 
-
-static void assabet_uart_pm(struct uart_port *port, u_int state, u_int oldstate)
-{
-	if (port->mapbase == _Ser1UTCR0) {
-		if (state)
-			ASSABET_BCR_clear(ASSABET_BCR_RS232EN);
-		else
-			ASSABET_BCR_set(ASSABET_BCR_RS232EN);
-	}
-}
-
-static struct sa1100_port_fns assabet_port_fns __initdata = {
-	.pm		= assabet_uart_pm,
-};
-
 static struct map_desc assabet_io_desc[] __initdata = {
   	{	/* Board Control Register */
 		.virtual	=  0xf1000000,
@@ -718,9 +703,6 @@ static void __init assabet_map_io(void)
 		MSC_NonBrst | MSC_32BitStMem |
 		MSC_RdAcc(2) | MSC_WrAcc(2) | MSC_Rec(0);
 
-	if (!machine_has_neponset())
-		sa1100_register_uart_fns(&assabet_port_fns);
-
 	/*
 	 * When Neponset is attached, the first UART should be
 	 * UART3.  That's what Angel is doing and many documents
diff --git a/arch/arm/mach-sa1100/badge4.c b/arch/arm/mach-sa1100/badge4.c
index de79f3502045..1c42b439da76 100644
--- a/arch/arm/mach-sa1100/badge4.c
+++ b/arch/arm/mach-sa1100/badge4.c
@@ -302,24 +302,11 @@ static struct map_desc badge4_io_desc[] __initdata = {
 	}
 };
 
-static void
-badge4_uart_pm(struct uart_port *port, u_int state, u_int oldstate)
-{
-	if (!state) {
-		Ser1SDCR0 |= SDCR0_UART;
-	}
-}
-
-static struct sa1100_port_fns badge4_port_fns __initdata = {
-	.pm		= badge4_uart_pm,
-};
-
 static void __init badge4_map_io(void)
 {
 	sa1100_map_io();
 	iotable_init(badge4_io_desc, ARRAY_SIZE(badge4_io_desc));
 
-	sa1100_register_uart_fns(&badge4_port_fns);
 	sa1100_register_uart(0, 3);
 	sa1100_register_uart(1, 1);
 }
diff --git a/arch/arm/mach-sa1100/h3xxx.c b/arch/arm/mach-sa1100/h3xxx.c
index d685f03f51f3..1f95add44367 100644
--- a/arch/arm/mach-sa1100/h3xxx.c
+++ b/arch/arm/mach-sa1100/h3xxx.c
@@ -83,18 +83,6 @@ static struct resource h3xxx_flash_resource =
 /*
  * H3xxx uart support
  */
-static void h3xxx_uart_pm(struct uart_port *port, u_int state, u_int oldstate)
-{
-	if (port->mapbase == _Ser3UTCR0) {
-		if (!gpio_request(H3XXX_EGPIO_RS232_ON, "RS232 transceiver")) {
-			gpio_direction_output(H3XXX_EGPIO_RS232_ON, !state);
-			gpio_free(H3XXX_EGPIO_RS232_ON);
-		} else {
-			pr_err("%s: can't request H3XXX_EGPIO_RS232_ON\n",
-				__func__);
-		}
-	}
-}
 
 /*
  * Enable/Disable wake up events for this serial port.
@@ -115,7 +103,6 @@ static int h3xxx_uart_set_wake(struct uart_port *port, u_int enable)
 }
 
 static struct sa1100_port_fns h3xxx_port_fns __initdata = {
-	.pm		= h3xxx_uart_pm,
 	.set_wake	= h3xxx_uart_set_wake,
 };
 
diff --git a/arch/arm/mach-sa1100/hackkit.c b/arch/arm/mach-sa1100/hackkit.c
index 3085f1c2e586..dfbba12968d4 100644
--- a/arch/arm/mach-sa1100/hackkit.c
+++ b/arch/arm/mach-sa1100/hackkit.c
@@ -45,8 +45,6 @@
 /* init funcs */
 static void __init hackkit_map_io(void);
 
-static void hackkit_uart_pm(struct uart_port *port, u_int state, u_int oldstate);
-
 /**********************************************************************
  *  global data
  */
@@ -64,10 +62,6 @@ static struct map_desc hackkit_io_desc[] __initdata = {
 	},
 };
 
-static struct sa1100_port_fns hackkit_port_fns __initdata = {
-	.pm		= hackkit_uart_pm,
-};
-
 /**********************************************************************
  *  Static functions
  */
@@ -77,7 +71,6 @@ static void __init hackkit_map_io(void)
 	sa1100_map_io();
 	iotable_init(hackkit_io_desc, ARRAY_SIZE(hackkit_io_desc));
 
-	sa1100_register_uart_fns(&hackkit_port_fns);
 	sa1100_register_uart(0, 1);	/* com port */
 	sa1100_register_uart(1, 2);
 	sa1100_register_uart(2, 3);	/* radio module */
@@ -85,18 +78,6 @@ static void __init hackkit_map_io(void)
 	Ser1SDCR0 |= SDCR0_SUS;
 }
 
-/**
- *	hackkit_uart_pm - powermgmt callback function for system 3 UART
- *	@port: uart port structure
- *	@state: pm state
- *	@oldstate: old pm state
- *
- */
-static void hackkit_uart_pm(struct uart_port *port, u_int state, u_int oldstate)
-{
-	/* TODO: switch on/off uart in powersave mode */
-}
-
 static struct mtd_partition hackkit_partitions[] = {
 	{
 		.name		= "BLOB",
diff --git a/arch/arm/mach-sa1100/simpad.c b/arch/arm/mach-sa1100/simpad.c
index c7fb9a73e4c5..ea3998f92a83 100644
--- a/arch/arm/mach-sa1100/simpad.c
+++ b/arch/arm/mach-sa1100/simpad.c
@@ -134,27 +134,6 @@ static struct map_desc simpad_io_desc[] __initdata = {
 	},
 };
 
-
-static void simpad_uart_pm(struct uart_port *port, u_int state, u_int oldstate)
-{
-	if (port->mapbase == (u_int)&Ser1UTCR0) {
-		if (state)
-		{
-			simpad_clear_cs3_bit(RS232_ON);
-			simpad_clear_cs3_bit(DECT_POWER_ON);
-		}else
-		{
-			simpad_set_cs3_bit(RS232_ON);
-			simpad_set_cs3_bit(DECT_POWER_ON);
-		}
-	}
-}
-
-static struct sa1100_port_fns simpad_port_fns __initdata = {
-	.pm	   = simpad_uart_pm,
-};
-
-
 static struct mtd_partition simpad_partitions[] = {
 	{
 		.name       = "SIMpad boot firmware",
@@ -207,7 +186,6 @@ static void __init simpad_map_io(void)
 		RS232_ON | ENABLE_5V | RESET_SIMCARD | DECT_POWER_ON);
 	__simpad_write_cs3(); /* Spinlocks not yet initialized */
 
-        sa1100_register_uart_fns(&simpad_port_fns);
 	sa1100_register_uart(0, 3);  /* serial interface */
 	sa1100_register_uart(1, 1);  /* DECT             */
 
diff --git a/arch/mips/alchemy/common/platform.c b/arch/mips/alchemy/common/platform.c
index b8f3397c59c9..f82a6007fc3b 100644
--- a/arch/mips/alchemy/common/platform.c
+++ b/arch/mips/alchemy/common/platform.c
@@ -28,26 +28,6 @@
 
 #include <prom.h>
 
-static void alchemy_8250_pm(struct uart_port *port, unsigned int state,
-			    unsigned int old_state)
-{
-#ifdef CONFIG_SERIAL_8250
-	switch (state) {
-	case 0:
-		alchemy_uart_enable(CPHYSADDR(port->membase));
-		serial8250_do_pm(port, state, old_state);
-		break;
-	case 3:		/* power off */
-		serial8250_do_pm(port, state, old_state);
-		alchemy_uart_disable(CPHYSADDR(port->membase));
-		break;
-	default:
-		serial8250_do_pm(port, state, old_state);
-		break;
-	}
-#endif
-}
-
 #define PORT(_base, _irq)					\
 	{							\
 		.mapbase	= _base,			\
@@ -57,7 +37,6 @@ static void alchemy_8250_pm(struct uart_port *port, unsigned int state,
 		.flags		= UPF_SKIP_TEST | UPF_IOREMAP | \
 				  UPF_FIXED_TYPE,		\
 		.type		= PORT_16550A,			\
-		.pm		= alchemy_8250_pm,		\
 	}
 
 static struct plat_serial8250_port au1x00_uart_data[][4] __initdata = {
diff --git a/drivers/tty/serial/8250/8250_core.c b/drivers/tty/serial/8250/8250_core.c
index 30b7890645ac..64f3f9240d06 100644
--- a/drivers/tty/serial/8250/8250_core.c
+++ b/drivers/tty/serial/8250/8250_core.c
@@ -829,7 +829,6 @@ static int serial8250_probe(struct platform_device *dev)
 		uart.port.set_termios	= p->set_termios;
 		uart.port.set_ldisc	= p->set_ldisc;
 		uart.port.get_mctrl	= p->get_mctrl;
-		uart.port.pm		= p->pm;
 		uart.port.dev		= &dev->dev;
 		uart.port.irqflags	|= irqflag;
 		ret = serial8250_register_8250_port(&uart);
diff --git a/drivers/tty/serial/8250/8250_exar.c b/drivers/tty/serial/8250/8250_exar.c
index d502240bbcf2..a4508ac0cac9 100644
--- a/drivers/tty/serial/8250/8250_exar.c
+++ b/drivers/tty/serial/8250/8250_exar.c
@@ -139,17 +139,6 @@ struct exar8250 {
 	int			line[];
 };
 
-static void exar_pm(struct uart_port *port, unsigned int state, unsigned int old)
-{
-	/*
-	 * Exar UARTs have a SLEEP register that enables or disables each UART
-	 * to enter sleep mode separately. On the XR17V35x the register
-	 * is accessible to each UART at the UART_EXAR_SLEEP offset, but
-	 * the UART channel may only write to the corresponding bit.
-	 */
-	serial_port_out(port, UART_EXAR_SLEEP, state ? 0xff : 0);
-}
-
 /*
  * XR17V35x UARTs have an extra fractional divisor register (DLD)
  * Calculate divisor with extra 4-bit fractional portion
@@ -244,7 +233,6 @@ static int default_setup(struct exar8250 *priv, struct pci_dev *pcidev,
 		port->port.type = PORT_XR17D15X;
 	}
 
-	port->port.pm = exar_pm;
 	port->port.shutdown = exar_shutdown;
 
 	return 0;
diff --git a/drivers/tty/serial/8250/8250_mtk.c b/drivers/tty/serial/8250/8250_mtk.c
index de48a58460f4..6225d2b1e888 100644
--- a/drivers/tty/serial/8250/8250_mtk.c
+++ b/drivers/tty/serial/8250/8250_mtk.c
@@ -452,20 +452,6 @@ static int __maybe_unused mtk8250_runtime_resume(struct device *dev)
 	return 0;
 }
 
-static void
-mtk8250_do_pm(struct uart_port *port, unsigned int state, unsigned int old)
-{
-	if (!state)
-		if (!mtk8250_runtime_resume(port->dev))
-			pm_runtime_get_sync(port->dev);
-
-	serial8250_do_pm(port, state, old);
-
-	if (state)
-		if (!pm_runtime_put_sync_suspend(port->dev))
-			mtk8250_runtime_suspend(port->dev);
-}
-
 #ifdef CONFIG_SERIAL_8250_DMA
 static bool mtk8250_dma_filter(struct dma_chan *chan, void *param)
 {
@@ -556,7 +542,6 @@ static int mtk8250_probe(struct platform_device *pdev)
 	spin_lock_init(&uart.port.lock);
 	uart.port.mapbase = regs->start;
 	uart.port.irq = irq;
-	uart.port.pm = mtk8250_do_pm;
 	uart.port.type = PORT_16550;
 	uart.port.flags = UPF_BOOT_AUTOCONF | UPF_FIXED_PORT;
 	uart.port.dev = &pdev->dev;
diff --git a/drivers/tty/serial/8250/8250_omap.c b/drivers/tty/serial/8250/8250_omap.c
index 73e5f1dbd075..bcda54b294ec 100644
--- a/drivers/tty/serial/8250/8250_omap.c
+++ b/drivers/tty/serial/8250/8250_omap.c
@@ -513,28 +513,6 @@ static void omap_8250_set_termios(struct uart_port *port,
 		tty_termios_encode_baud_rate(termios, baud, baud);
 }
 
-/* same as 8250 except that we may have extra flow bits set in EFR */
-static void omap_8250_pm(struct uart_port *port, unsigned int state,
-			 unsigned int oldstate)
-{
-	struct uart_8250_port *up = up_to_u8250p(port);
-	u8 efr;
-
-	pm_runtime_get_sync(port->dev);
-	serial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);
-	efr = serial_in(up, UART_EFR);
-	serial_out(up, UART_EFR, efr | UART_EFR_ECB);
-	serial_out(up, UART_LCR, 0);
-
-	serial_out(up, UART_IER, (state != 0) ? UART_IERX_SLEEP : 0);
-	serial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);
-	serial_out(up, UART_EFR, efr);
-	serial_out(up, UART_LCR, 0);
-
-	pm_runtime_mark_last_busy(port->dev);
-	pm_runtime_put_autosuspend(port->dev);
-}
-
 static void omap_serial_fill_features_erratas(struct uart_8250_port *up,
 					      struct omap8250_priv *priv)
 {
@@ -1343,7 +1321,6 @@ static int omap8250_probe(struct platform_device *pdev)
 #endif
 	up.port.set_termios = omap_8250_set_termios;
 	up.port.set_mctrl = omap8250_set_mctrl;
-	up.port.pm = omap_8250_pm;
 	up.port.startup = omap_8250_startup;
 	up.port.shutdown = omap_8250_shutdown;
 	up.port.throttle = omap_8250_throttle;
diff --git a/drivers/tty/serial/8250/8250_port.c b/drivers/tty/serial/8250/8250_port.c
index d7aca81db638..e518451f0e49 100644
--- a/drivers/tty/serial/8250/8250_port.c
+++ b/drivers/tty/serial/8250/8250_port.c
@@ -2892,16 +2892,6 @@ void serial8250_do_pm(struct uart_port *port, unsigned int state,
 }
 EXPORT_SYMBOL(serial8250_do_pm);
 
-static void
-serial8250_pm(struct uart_port *port, unsigned int state,
-	      unsigned int oldstate)
-{
-	if (port->pm)
-		port->pm(port, state, oldstate);
-	else
-		serial8250_do_pm(port, state, oldstate);
-}
-
 static unsigned int serial8250_port_size(struct uart_8250_port *pt)
 {
 	if (pt->port.mapsize)
@@ -3216,7 +3206,6 @@ static const struct uart_ops serial8250_pops = {
 	.shutdown	= serial8250_shutdown,
 	.set_termios	= serial8250_set_termios,
 	.set_ldisc	= serial8250_set_ldisc,
-	.pm		= serial8250_pm,
 	.type		= serial8250_type,
 	.release_port	= serial8250_release_port,
 	.request_port	= serial8250_request_port,
diff --git a/drivers/tty/serial/atmel_serial.c b/drivers/tty/serial/atmel_serial.c
index c0a86558ceaa..b094c36ada70 100644
--- a/drivers/tty/serial/atmel_serial.c
+++ b/drivers/tty/serial/atmel_serial.c
@@ -2085,41 +2085,6 @@ static void atmel_shutdown(struct uart_port *port)
 	atmel_flush_buffer(port);
 }
 
-/*
- * Power / Clock management.
- */
-static void atmel_serial_pm(struct uart_port *port, unsigned int state,
-			    unsigned int oldstate)
-{
-	struct atmel_uart_port *atmel_port = to_atmel_uart_port(port);
-
-	switch (state) {
-	case 0:
-		/*
-		 * Enable the peripheral clock for this serial port.
-		 * This is called on uart_open() or a resume event.
-		 */
-		clk_prepare_enable(atmel_port->clk);
-
-		/* re-enable interrupts if we disabled some on suspend */
-		atmel_uart_writel(port, ATMEL_US_IER, atmel_port->backup_imr);
-		break;
-	case 3:
-		/* Back up the interrupt mask and disable all interrupts */
-		atmel_port->backup_imr = atmel_uart_readl(port, ATMEL_US_IMR);
-		atmel_uart_writel(port, ATMEL_US_IDR, -1);
-
-		/*
-		 * Disable the peripheral clock for this serial port.
-		 * This is called on uart_close() or a suspend event.
-		 */
-		clk_disable_unprepare(atmel_port->clk);
-		break;
-	default:
-		dev_err(port->dev, "atmel_serial: unknown pm %d\n", state);
-	}
-}
-
 /*
  * Change the port parameters
  */
@@ -2463,7 +2428,6 @@ static const struct uart_ops atmel_pops = {
 	.request_port	= atmel_request_port,
 	.config_port	= atmel_config_port,
 	.verify_port	= atmel_verify_port,
-	.pm		= atmel_serial_pm,
 #ifdef CONFIG_CONSOLE_POLL
 	.poll_get_char	= atmel_poll_get_char,
 	.poll_put_char	= atmel_poll_put_char,
diff --git a/drivers/tty/serial/dz.c b/drivers/tty/serial/dz.c
index e9edabc5a211..6103eec484ed 100644
--- a/drivers/tty/serial/dz.c
+++ b/drivers/tty/serial/dz.c
@@ -632,26 +632,6 @@ static void dz_set_termios(struct uart_port *uport, struct ktermios *termios,
 	spin_unlock_irqrestore(&dport->port.lock, flags);
 }
 
-/*
- * Hack alert!
- * Required solely so that the initial PROM-based console
- * works undisturbed in parallel with this one.
- */
-static void dz_pm(struct uart_port *uport, unsigned int state,
-		  unsigned int oldstate)
-{
-	struct dz_port *dport = to_dport(uport);
-	unsigned long flags;
-
-	spin_lock_irqsave(&dport->port.lock, flags);
-	if (state < 3)
-		dz_start_tx(&dport->port);
-	else
-		dz_stop_tx(&dport->port);
-	spin_unlock_irqrestore(&dport->port.lock, flags);
-}
-
-
 static const char *dz_type(struct uart_port *uport)
 {
 	return "DZ";
@@ -747,7 +727,6 @@ static const struct uart_ops dz_ops = {
 	.startup	= dz_startup,
 	.shutdown	= dz_shutdown,
 	.set_termios	= dz_set_termios,
-	.pm		= dz_pm,
 	.type		= dz_type,
 	.release_port	= dz_release_port,
 	.request_port	= dz_request_port,
@@ -775,7 +754,7 @@ static void __init dz_init_ports(void)
 		struct uart_port *uport = &dport->port;
 
 		dport->mux	= &dz_mux;
-
+		spin_lock_init(&uport->lock);
 		uport->irq	= dec_interrupt[DEC_IRQ_DZ11];
 		uport->fifosize	= 1;
 		uport->iotype	= UPIO_MEM;
@@ -872,10 +851,7 @@ static int __init dz_console_setup(struct console *co, char *options)
 	if (ret)
 		return ret;
 
-	spin_lock_init(&dport->port.lock);	/* For dz_pm().  */
-
 	dz_reset(dport);
-	dz_pm(uport, 0, -1);
 
 	if (options)
 		uart_parse_options(options, &baud, &parity, &bits, &flow);
diff --git a/drivers/tty/serial/mpc52xx_uart.c b/drivers/tty/serial/mpc52xx_uart.c
index 2704dc988e4a..9948311a1115 100644
--- a/drivers/tty/serial/mpc52xx_uart.c
+++ b/drivers/tty/serial/mpc52xx_uart.c
@@ -1352,7 +1352,6 @@ static const struct uart_ops mpc52xx_uart_ops = {
 	.startup	= mpc52xx_uart_startup,
 	.shutdown	= mpc52xx_uart_shutdown,
 	.set_termios	= mpc52xx_uart_set_termios,
-/*	.pm		= mpc52xx_uart_pm,		Not supported yet */
 	.type		= mpc52xx_uart_type,
 	.release_port	= mpc52xx_uart_release_port,
 	.request_port	= mpc52xx_uart_request_port,
diff --git a/drivers/tty/serial/msm_serial.c b/drivers/tty/serial/msm_serial.c
index 03ff63438e77..5d709075e839 100644
--- a/drivers/tty/serial/msm_serial.c
+++ b/drivers/tty/serial/msm_serial.c
@@ -1402,25 +1402,6 @@ static int msm_verify_port(struct uart_port *port, struct serial_struct *ser)
 	return 0;
 }
 
-static void msm_power(struct uart_port *port, unsigned int state,
-		      unsigned int oldstate)
-{
-	struct msm_port *msm_port = UART_TO_MSM(port);
-
-	switch (state) {
-	case 0:
-		clk_prepare_enable(msm_port->clk);
-		clk_prepare_enable(msm_port->pclk);
-		break;
-	case 3:
-		clk_disable_unprepare(msm_port->clk);
-		clk_disable_unprepare(msm_port->pclk);
-		break;
-	default:
-		pr_err("msm_serial: Unknown PM state %d\n", state);
-	}
-}
-
 #ifdef CONFIG_CONSOLE_POLL
 static int msm_poll_get_char_single(struct uart_port *port)
 {
@@ -1540,7 +1521,6 @@ static const struct uart_ops msm_uart_pops = {
 	.request_port = msm_request_port,
 	.config_port = msm_config_port,
 	.verify_port = msm_verify_port,
-	.pm = msm_power,
 #ifdef CONFIG_CONSOLE_POLL
 	.poll_get_char	= msm_poll_get_char,
 	.poll_put_char	= msm_poll_put_char,
diff --git a/drivers/tty/serial/omap-serial.c b/drivers/tty/serial/omap-serial.c
index 0862941862c8..0f4c4766b371 100644
--- a/drivers/tty/serial/omap-serial.c
+++ b/drivers/tty/serial/omap-serial.c
@@ -1058,26 +1058,6 @@ serial_omap_set_termios(struct uart_port *port, struct ktermios *termios,
 	dev_dbg(up->port.dev, "serial_omap_set_termios+%d\n", up->port.line);
 }
 
-static void
-serial_omap_pm(struct uart_port *port, unsigned int state,
-	       unsigned int oldstate)
-{
-	struct uart_omap_port *up = to_uart_omap_port(port);
-	unsigned char efr;
-
-	dev_dbg(up->port.dev, "serial_omap_pm+%d\n", up->port.line);
-
-	serial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);
-	efr = serial_in(up, UART_EFR);
-	serial_out(up, UART_EFR, efr | UART_EFR_ECB);
-	serial_out(up, UART_LCR, 0);
-
-	serial_out(up, UART_IER, (state != 0) ? UART_IERX_SLEEP : 0);
-	serial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);
-	serial_out(up, UART_EFR, efr);
-	serial_out(up, UART_LCR, 0);
-}
-
 static void serial_omap_release_port(struct uart_port *port)
 {
 	dev_dbg(port->dev, "serial_omap_release_port+\n");
@@ -1395,7 +1375,6 @@ static const struct uart_ops serial_omap_pops = {
 	.startup	= serial_omap_startup,
 	.shutdown	= serial_omap_shutdown,
 	.set_termios	= serial_omap_set_termios,
-	.pm		= serial_omap_pm,
 	.type		= serial_omap_type,
 	.release_port	= serial_omap_release_port,
 	.request_port	= serial_omap_request_port,
diff --git a/drivers/tty/serial/pch_uart.c b/drivers/tty/serial/pch_uart.c
index 1e65933f6cce..6ab44e001eb0 100644
--- a/drivers/tty/serial/pch_uart.c
+++ b/drivers/tty/serial/pch_uart.c
@@ -1573,7 +1573,6 @@ static const struct uart_ops pch_uart_ops = {
 	.startup = pch_uart_startup,
 	.shutdown = pch_uart_shutdown,
 	.set_termios = pch_uart_set_termios,
-/*	.pm		= pch_uart_pm,		Not supported yet */
 	.type = pch_uart_type,
 	.release_port = pch_uart_release_port,
 	.request_port = pch_uart_request_port,
diff --git a/drivers/tty/serial/pxa.c b/drivers/tty/serial/pxa.c
index 41319ef96fa6..5317d4e4e954 100644
--- a/drivers/tty/serial/pxa.c
+++ b/drivers/tty/serial/pxa.c
@@ -543,18 +543,6 @@ serial_pxa_set_termios(struct uart_port *port, struct ktermios *termios,
 	spin_unlock_irqrestore(&up->port.lock, flags);
 }
 
-static void
-serial_pxa_pm(struct uart_port *port, unsigned int state,
-	      unsigned int oldstate)
-{
-	struct uart_pxa_port *up = (struct uart_pxa_port *)port;
-
-	if (!state)
-		clk_prepare_enable(up->clk);
-	else
-		clk_disable_unprepare(up->clk);
-}
-
 static void serial_pxa_release_port(struct uart_port *port)
 {
 }
@@ -766,7 +754,6 @@ static const struct uart_ops serial_pxa_pops = {
 	.startup	= serial_pxa_startup,
 	.shutdown	= serial_pxa_shutdown,
 	.set_termios	= serial_pxa_set_termios,
-	.pm		= serial_pxa_pm,
 	.type		= serial_pxa_type,
 	.release_port	= serial_pxa_release_port,
 	.request_port	= serial_pxa_request_port,
diff --git a/drivers/tty/serial/qcom_geni_serial.c b/drivers/tty/serial/qcom_geni_serial.c
index aedc38893e6c..bf7bbb15cb26 100644
--- a/drivers/tty/serial/qcom_geni_serial.c
+++ b/drivers/tty/serial/qcom_geni_serial.c
@@ -1266,25 +1266,6 @@ static struct uart_driver qcom_geni_uart_driver = {
 	.nr =  GENI_UART_PORTS,
 };
 
-static void qcom_geni_serial_pm(struct uart_port *uport,
-		unsigned int new_state, unsigned int old_state)
-{
-	struct qcom_geni_serial_port *port = to_dev_port(uport, uport);
-
-	/* If we've never been called, treat it as off */
-	if (old_state == UART_PM_STATE_UNDEFINED)
-		old_state = UART_PM_STATE_OFF;
-
-	if (new_state == UART_PM_STATE_ON && old_state == UART_PM_STATE_OFF) {
-		geni_icc_enable(&port->se);
-		geni_se_resources_on(&port->se);
-	} else if (new_state == UART_PM_STATE_OFF &&
-			old_state == UART_PM_STATE_ON) {
-		geni_se_resources_off(&port->se);
-		geni_icc_disable(&port->se);
-	}
-}
-
 static const struct uart_ops qcom_geni_console_pops = {
 	.tx_empty = qcom_geni_serial_tx_empty,
 	.stop_tx = qcom_geni_serial_stop_tx,
@@ -1302,7 +1283,6 @@ static const struct uart_ops qcom_geni_console_pops = {
 	.poll_get_char	= qcom_geni_serial_get_char,
 	.poll_put_char	= qcom_geni_serial_poll_put_char,
 #endif
-	.pm = qcom_geni_serial_pm,
 };
 
 static const struct uart_ops qcom_geni_uart_pops = {
@@ -1318,7 +1298,6 @@ static const struct uart_ops qcom_geni_uart_pops = {
 	.type = qcom_geni_serial_get_type,
 	.set_mctrl = qcom_geni_serial_set_mctrl,
 	.get_mctrl = qcom_geni_serial_get_mctrl,
-	.pm = qcom_geni_serial_pm,
 };
 
 static int qcom_geni_serial_probe(struct platform_device *pdev)
diff --git a/drivers/tty/serial/sa1100.c b/drivers/tty/serial/sa1100.c
index 4ddcc985621a..edce707781a4 100644
--- a/drivers/tty/serial/sa1100.c
+++ b/drivers/tty/serial/sa1100.c
@@ -652,7 +652,6 @@ void sa1100_register_uart_fns(struct sa1100_port_fns *fns)
 	if (fns->set_mctrl)
 		sa1100_pops.set_mctrl = fns->set_mctrl;
 
-	sa1100_pops.pm       = fns->pm;
 	/*
 	 * FIXME: fns->set_wake is unused - this should be called from
 	 * the suspend() callback if device_may_wakeup(dev)) is set.
diff --git a/drivers/tty/serial/samsung_tty.c b/drivers/tty/serial/samsung_tty.c
index f460b47ff6f2..24f3acc6706a 100644
--- a/drivers/tty/serial/samsung_tty.c
+++ b/drivers/tty/serial/samsung_tty.c
@@ -1375,40 +1375,6 @@ static void exynos_usi_init(struct uart_port *port)
 	wr_regl(port, USI_OPTION, val);
 }
 
-/* power power management control */
-
-static void s3c24xx_serial_pm(struct uart_port *port, unsigned int level,
-			      unsigned int old)
-{
-	struct s3c24xx_uart_port *ourport = to_ourport(port);
-	int timeout = 10000;
-
-	ourport->pm_level = level;
-
-	switch (level) {
-	case 3:
-		while (--timeout && !s3c24xx_serial_txempty_nofifo(port))
-			udelay(100);
-
-		if (!IS_ERR(ourport->baudclk))
-			clk_disable_unprepare(ourport->baudclk);
-
-		clk_disable_unprepare(ourport->clk);
-		break;
-
-	case 0:
-		clk_prepare_enable(ourport->clk);
-
-		if (!IS_ERR(ourport->baudclk))
-			clk_prepare_enable(ourport->baudclk);
-
-		exynos_usi_init(port);
-		break;
-	default:
-		dev_err(port->dev, "s3c24xx_serial: unknown pm %d\n", level);
-	}
-}
-
 /* baud rate calculation
  *
  * The UARTs on the S3C2410/S3C2440 can take their clocks from a number
@@ -1755,7 +1721,6 @@ static void s3c24xx_serial_put_poll_char(struct uart_port *port,
 #endif
 
 static const struct uart_ops s3c24xx_serial_ops = {
-	.pm		= s3c24xx_serial_pm,
 	.tx_empty	= s3c24xx_serial_tx_empty,
 	.get_mctrl	= s3c24xx_serial_get_mctrl,
 	.set_mctrl	= s3c24xx_serial_set_mctrl,
@@ -1776,7 +1741,6 @@ static const struct uart_ops s3c24xx_serial_ops = {
 };
 
 static const struct uart_ops s3c64xx_serial_ops = {
-	.pm		= s3c24xx_serial_pm,
 	.tx_empty	= s3c24xx_serial_tx_empty,
 	.get_mctrl	= s3c24xx_serial_get_mctrl,
 	.set_mctrl	= s3c24xx_serial_set_mctrl,
@@ -1797,7 +1761,6 @@ static const struct uart_ops s3c64xx_serial_ops = {
 };
 
 static const struct uart_ops apple_s5l_serial_ops = {
-	.pm		= s3c24xx_serial_pm,
 	.tx_empty	= s3c24xx_serial_tx_empty,
 	.get_mctrl	= s3c24xx_serial_get_mctrl,
 	.set_mctrl	= s3c24xx_serial_set_mctrl,
diff --git a/drivers/tty/serial/sc16is7xx.c b/drivers/tty/serial/sc16is7xx.c
index 0ab788058fa2..7c6c7ba18266 100644
--- a/drivers/tty/serial/sc16is7xx.c
+++ b/drivers/tty/serial/sc16is7xx.c
@@ -1097,12 +1097,6 @@ static int sc16is7xx_verify_port(struct uart_port *port,
 	return 0;
 }
 
-static void sc16is7xx_pm(struct uart_port *port, unsigned int state,
-			 unsigned int oldstate)
-{
-	sc16is7xx_power(port, (state == UART_PM_STATE_ON) ? 1 : 0);
-}
-
 static void sc16is7xx_null_void(struct uart_port *port)
 {
 	/* Do nothing */
@@ -1124,7 +1118,6 @@ static const struct uart_ops sc16is7xx_ops = {
 	.release_port	= sc16is7xx_null_void,
 	.config_port	= sc16is7xx_config_port,
 	.verify_port	= sc16is7xx_verify_port,
-	.pm		= sc16is7xx_pm,
 };
 
 #ifdef CONFIG_GPIOLIB
diff --git a/drivers/tty/serial/serial_txx9.c b/drivers/tty/serial/serial_txx9.c
index 1f8362d5e3b9..8de8855fa0e1 100644
--- a/drivers/tty/serial/serial_txx9.c
+++ b/drivers/tty/serial/serial_txx9.c
@@ -728,22 +728,6 @@ serial_txx9_set_termios(struct uart_port *port, struct ktermios *termios,
 	spin_unlock_irqrestore(&up->port.lock, flags);
 }
 
-static void
-serial_txx9_pm(struct uart_port *port, unsigned int state,
-	      unsigned int oldstate)
-{
-	/*
-	 * If oldstate was -1 this is called from
-	 * uart_configure_port().  In this case do not initialize the
-	 * port now, because the port was already initialized (for
-	 * non-console port) or should not be initialized here (for
-	 * console port).  If we initialized the port here we lose
-	 * serial console settings.
-	 */
-	if (state == 0 && oldstate != -1)
-		serial_txx9_initialize(port);
-}
-
 static int serial_txx9_request_resource(struct uart_txx9_port *up)
 {
 	unsigned int size = TXX9_REGION_SIZE;
@@ -850,7 +834,6 @@ static const struct uart_ops serial_txx9_pops = {
 	.startup	= serial_txx9_startup,
 	.shutdown	= serial_txx9_shutdown,
 	.set_termios	= serial_txx9_set_termios,
-	.pm		= serial_txx9_pm,
 	.type		= serial_txx9_type,
 	.release_port	= serial_txx9_release_port,
 	.request_port	= serial_txx9_request_port,
diff --git a/drivers/tty/serial/sh-sci.c b/drivers/tty/serial/sh-sci.c
index c5c0f39cb1c7..90d1a5781e4e 100644
--- a/drivers/tty/serial/sh-sci.c
+++ b/drivers/tty/serial/sh-sci.c
@@ -2626,21 +2626,6 @@ static void sci_set_termios(struct uart_port *port, struct ktermios *termios,
 		sci_enable_ms(port);
 }
 
-static void sci_pm(struct uart_port *port, unsigned int state,
-		   unsigned int oldstate)
-{
-	struct sci_port *sci_port = to_sci_port(port);
-
-	switch (state) {
-	case UART_PM_STATE_OFF:
-		sci_port_disable(sci_port);
-		break;
-	default:
-		sci_port_enable(sci_port);
-		break;
-	}
-}
-
 static const char *sci_type(struct uart_port *port)
 {
 	switch (port->type) {
@@ -2755,7 +2740,6 @@ static const struct uart_ops sci_uart_ops = {
 	.shutdown	= sci_shutdown,
 	.flush_buffer	= sci_flush_buffer,
 	.set_termios	= sci_set_termios,
-	.pm		= sci_pm,
 	.type		= sci_type,
 	.release_port	= sci_release_port,
 	.request_port	= sci_request_port,
diff --git a/drivers/tty/serial/sprd_serial.c b/drivers/tty/serial/sprd_serial.c
index 9a7ae6384edf..0c707065977f 100644
--- a/drivers/tty/serial/sprd_serial.c
+++ b/drivers/tty/serial/sprd_serial.c
@@ -902,30 +902,9 @@ static int sprd_verify_port(struct uart_port *port, struct serial_struct *ser)
 	return 0;
 }
 
-static void sprd_pm(struct uart_port *port, unsigned int state,
-		unsigned int oldstate)
-{
-	struct sprd_uart_port *sup =
-		container_of(port, struct sprd_uart_port, port);
-
-	switch (state) {
-	case UART_PM_STATE_ON:
-		clk_prepare_enable(sup->clk);
-		break;
-	case UART_PM_STATE_OFF:
-		clk_disable_unprepare(sup->clk);
-		break;
-	}
-}
-
 #ifdef CONFIG_CONSOLE_POLL
 static int sprd_poll_init(struct uart_port *port)
 {
-	if (port->state->pm_state != UART_PM_STATE_ON) {
-		sprd_pm(port, UART_PM_STATE_ON, 0);
-		port->state->pm_state = UART_PM_STATE_ON;
-	}
-
 	return 0;
 }
 
@@ -962,7 +941,6 @@ static const struct uart_ops serial_sprd_ops = {
 	.request_port = sprd_request_port,
 	.config_port = sprd_config_port,
 	.verify_port = sprd_verify_port,
-	.pm = sprd_pm,
 #ifdef CONFIG_CONSOLE_POLL
 	.poll_init	= sprd_poll_init,
 	.poll_get_char	= sprd_poll_get_char,
diff --git a/drivers/tty/serial/st-asc.c b/drivers/tty/serial/st-asc.c
index 5a45633aaea8..50581ec80845 100644
--- a/drivers/tty/serial/st-asc.c
+++ b/drivers/tty/serial/st-asc.c
@@ -474,32 +474,6 @@ static void asc_shutdown(struct uart_port *port)
 	free_irq(port->irq, port);
 }
 
-static void asc_pm(struct uart_port *port, unsigned int state,
-		unsigned int oldstate)
-{
-	struct asc_port *ascport = to_asc_port(port);
-	unsigned long flags;
-	u32 ctl;
-
-	switch (state) {
-	case UART_PM_STATE_ON:
-		clk_prepare_enable(ascport->clk);
-		break;
-	case UART_PM_STATE_OFF:
-		/*
-		 * Disable the ASC baud rate generator, which is as close as
-		 * we can come to turning it off. Note this is not called with
-		 * the port spinlock held.
-		 */
-		spin_lock_irqsave(&port->lock, flags);
-		ctl = asc_in(port, ASC_CTL) & ~ASC_CTL_RUN;
-		asc_out(port, ASC_CTL, ctl);
-		spin_unlock_irqrestore(&port->lock, flags);
-		clk_disable_unprepare(ascport->clk);
-		break;
-	}
-}
-
 static void asc_set_termios(struct uart_port *port, struct ktermios *termios,
 			    struct ktermios *old)
 {
@@ -708,7 +682,6 @@ static const struct uart_ops asc_uart_ops = {
 	.request_port	= asc_request_port,
 	.config_port	= asc_config_port,
 	.verify_port	= asc_verify_port,
-	.pm		= asc_pm,
 #ifdef CONFIG_CONSOLE_POLL
 	.poll_get_char = asc_get_poll_char,
 	.poll_put_char = asc_put_poll_char,
diff --git a/drivers/tty/serial/stm32-usart.c b/drivers/tty/serial/stm32-usart.c
index fc166cc2c856..8e910d06e7f8 100644
--- a/drivers/tty/serial/stm32-usart.c
+++ b/drivers/tty/serial/stm32-usart.c
@@ -971,28 +971,6 @@ stm32_usart_verify_port(struct uart_port *port, struct serial_struct *ser)
 	return -EINVAL;
 }
 
-static void stm32_usart_pm(struct uart_port *port, unsigned int state,
-			   unsigned int oldstate)
-{
-	struct stm32_port *stm32port = container_of(port,
-			struct stm32_port, port);
-	const struct stm32_usart_offsets *ofs = &stm32port->info->ofs;
-	const struct stm32_usart_config *cfg = &stm32port->info->cfg;
-	unsigned long flags;
-
-	switch (state) {
-	case UART_PM_STATE_ON:
-		pm_runtime_get_sync(port->dev);
-		break;
-	case UART_PM_STATE_OFF:
-		spin_lock_irqsave(&port->lock, flags);
-		stm32_usart_clr_bits(port, ofs->cr1, BIT(cfg->uart_enable_bit));
-		spin_unlock_irqrestore(&port->lock, flags);
-		pm_runtime_put_sync(port->dev);
-		break;
-	}
-}
-
 static const struct uart_ops stm32_uart_ops = {
 	.tx_empty	= stm32_usart_tx_empty,
 	.set_mctrl	= stm32_usart_set_mctrl,
@@ -1008,7 +986,6 @@ static const struct uart_ops stm32_uart_ops = {
 	.shutdown	= stm32_usart_shutdown,
 	.flush_buffer	= stm32_usart_flush_buffer,
 	.set_termios	= stm32_usart_set_termios,
-	.pm		= stm32_usart_pm,
 	.type		= stm32_usart_type,
 	.release_port	= stm32_usart_release_port,
 	.request_port	= stm32_usart_request_port,
diff --git a/drivers/tty/serial/uartlite.c b/drivers/tty/serial/uartlite.c
index 36871cebd6a0..18485678b2ad 100644
--- a/drivers/tty/serial/uartlite.c
+++ b/drivers/tty/serial/uartlite.c
@@ -390,21 +390,6 @@ static int ulite_verify_port(struct uart_port *port, struct serial_struct *ser)
 	return -EINVAL;
 }
 
-static void ulite_pm(struct uart_port *port, unsigned int state,
-		     unsigned int oldstate)
-{
-	int ret;
-
-	if (!state) {
-		ret = pm_runtime_get_sync(port->dev);
-		if (ret < 0)
-			dev_err(port->dev, "Failed to enable clocks\n");
-	} else {
-		pm_runtime_mark_last_busy(port->dev);
-		pm_runtime_put_autosuspend(port->dev);
-	}
-}
-
 #ifdef CONFIG_CONSOLE_POLL
 static int ulite_get_poll_char(struct uart_port *port)
 {
@@ -440,7 +425,6 @@ static const struct uart_ops ulite_ops = {
 	.request_port	= ulite_request_port,
 	.config_port	= ulite_config_port,
 	.verify_port	= ulite_verify_port,
-	.pm		= ulite_pm,
 #ifdef CONFIG_CONSOLE_POLL
 	.poll_get_char	= ulite_get_poll_char,
 	.poll_put_char	= ulite_put_poll_char,
diff --git a/drivers/tty/serial/vr41xx_siu.c b/drivers/tty/serial/vr41xx_siu.c
index 647198b1e2b9..b6671fbf9c13 100644
--- a/drivers/tty/serial/vr41xx_siu.c
+++ b/drivers/tty/serial/vr41xx_siu.c
@@ -577,32 +577,6 @@ static void siu_set_termios(struct uart_port *port, struct ktermios *new,
 	spin_unlock_irqrestore(&port->lock, flags);
 }
 
-static void siu_pm(struct uart_port *port, unsigned int state, unsigned int oldstate)
-{
-	switch (state) {
-	case 0:
-		switch (port->type) {
-		case PORT_VR41XX_SIU:
-			vr41xx_supply_clock(SIU_CLOCK);
-			break;
-		case PORT_VR41XX_DSIU:
-			vr41xx_supply_clock(DSIU_CLOCK);
-			break;
-		}
-		break;
-	case 3:
-		switch (port->type) {
-		case PORT_VR41XX_SIU:
-			vr41xx_mask_clock(SIU_CLOCK);
-			break;
-		case PORT_VR41XX_DSIU:
-			vr41xx_mask_clock(DSIU_CLOCK);
-			break;
-		}
-		break;
-	}
-}
-
 static const char *siu_type(struct uart_port *port)
 {
 	return siu_type_name(port);
@@ -676,7 +650,6 @@ static const struct uart_ops siu_uart_ops = {
 	.startup	= siu_startup,
 	.shutdown	= siu_shutdown,
 	.set_termios	= siu_set_termios,
-	.pm		= siu_pm,
 	.type		= siu_type,
 	.release_port	= siu_release_port,
 	.request_port	= siu_request_port,
diff --git a/drivers/tty/serial/xilinx_uartps.c b/drivers/tty/serial/xilinx_uartps.c
index d5e243908d9f..c926f8088816 100644
--- a/drivers/tty/serial/xilinx_uartps.c
+++ b/drivers/tty/serial/xilinx_uartps.c
@@ -1097,20 +1097,6 @@ static void cdns_uart_poll_put_char(struct uart_port *port, unsigned char c)
 }
 #endif
 
-static void cdns_uart_pm(struct uart_port *port, unsigned int state,
-		   unsigned int oldstate)
-{
-	switch (state) {
-	case UART_PM_STATE_OFF:
-		pm_runtime_mark_last_busy(port->dev);
-		pm_runtime_put_autosuspend(port->dev);
-		break;
-	default:
-		pm_runtime_get_sync(port->dev);
-		break;
-	}
-}
-
 static const struct uart_ops cdns_uart_ops = {
 	.set_mctrl	= cdns_uart_set_mctrl,
 	.get_mctrl	= cdns_uart_get_mctrl,
@@ -1122,7 +1108,6 @@ static const struct uart_ops cdns_uart_ops = {
 	.set_termios	= cdns_uart_set_termios,
 	.startup	= cdns_uart_startup,
 	.shutdown	= cdns_uart_shutdown,
-	.pm		= cdns_uart_pm,
 	.type		= cdns_uart_type,
 	.verify_port	= cdns_uart_verify_port,
 	.request_port	= cdns_uart_request_port,
diff --git a/drivers/tty/serial/zs.c b/drivers/tty/serial/zs.c
index 4b4f604646a7..15764e1025a4 100644
--- a/drivers/tty/serial/zs.c
+++ b/drivers/tty/serial/zs.c
@@ -955,24 +955,6 @@ static void zs_set_termios(struct uart_port *uport, struct ktermios *termios,
 	spin_unlock_irqrestore(&scc->zlock, flags);
 }
 
-/*
- * Hack alert!
- * Required solely so that the initial PROM-based console
- * works undisturbed in parallel with this one.
- */
-static void zs_pm(struct uart_port *uport, unsigned int state,
-		  unsigned int oldstate)
-{
-	struct zs_port *zport = to_zport(uport);
-
-	if (state < 3)
-		zport->regs[5] |= TxENAB;
-	else
-		zport->regs[5] &= ~TxENAB;
-	write_zsreg(zport, R5, zport->regs[5]);
-}
-
-
 static const char *zs_type(struct uart_port *uport)
 {
 	return "Z85C30 SCC";
@@ -1054,7 +1036,6 @@ static const struct uart_ops zs_ops = {
 	.startup	= zs_startup,
 	.shutdown	= zs_shutdown,
 	.set_termios	= zs_set_termios,
-	.pm		= zs_pm,
 	.type		= zs_type,
 	.release_port	= zs_release_port,
 	.request_port	= zs_request_port,
@@ -1209,7 +1190,6 @@ static int __init zs_console_setup(struct console *co, char *options)
 		return ret;
 
 	zs_reset(zport);
-	zs_pm(uport, 0, -1);
 
 	if (options)
 		uart_parse_options(options, &baud, &parity, &bits, &flow);
diff --git a/include/linux/serial_8250.h b/include/linux/serial_8250.h
index 8c630c46460a..e6e300eca561 100644
--- a/include/linux/serial_8250.h
+++ b/include/linux/serial_8250.h
@@ -37,8 +37,6 @@ struct plat_serial8250_port {
 				     struct ktermios *);
 	unsigned int	(*get_mctrl)(struct uart_port *);
 	int		(*handle_irq)(struct uart_port *);
-	void		(*pm)(struct uart_port *, unsigned int state,
-			      unsigned old);
 	void		(*handle_break)(struct uart_port *);
 };
 
-- 
2.25.1

