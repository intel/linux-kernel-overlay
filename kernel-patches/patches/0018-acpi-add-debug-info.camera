From 8d0702db8ecc02a767b78c45fd642ee70ef2cd72 Mon Sep 17 00:00:00 2001
From: Chen Meng J <meng.j.chen@intel.com>
Date: Tue, 8 Aug 2023 13:25:26 +0800
Subject: [PATCH 18/20] acpi: add debug info

Change Description:
control logic type for sensor before populate pdata.
gpio function selected in BIOS.
sensor model name.

Signed-off-by: Ng Khai Wen <khai.wen.ng@intel.com>
Signed-off-by: Chen Meng J <meng.j.chen@intel.com>
---
 .../media/platform/intel/ipu6-acpi-pdata.c    | 48 +++++++++++++++++--
 drivers/media/platform/intel/ipu6-acpi.c      |  3 +-
 include/media/ipu-acpi-pdata.h                |  1 +
 3 files changed, 47 insertions(+), 5 deletions(-)

diff --git a/drivers/media/platform/intel/ipu6-acpi-pdata.c b/drivers/media/platform/intel/ipu6-acpi-pdata.c
index 74d8fc9d4b71..87c2aa9402f1 100644
--- a/drivers/media/platform/intel/ipu6-acpi-pdata.c
+++ b/drivers/media/platform/intel/ipu6-acpi-pdata.c
@@ -473,6 +473,11 @@ void set_ti960_gpio(struct control_logic_data *ctl_data, struct serdes_platform_
 
 	if (ctl_data->completed && ctl_data->gpio_num > 0) {
 		for (i = 0; i < ctl_data->gpio_num; i++) {
+			if (ctl_data->gpio[i].func != GPIO_RESET)
+				dev_err(ctl_data->dev,
+					"IPU6 ACPI: Invalid GPIO func: %d\n",
+					ctl_data->gpio[i].func);
+
 			/* check for RESET selection in BIOS */
 			if (ctl_data->gpio[i].valid && ctl_data->gpio[i].func == GPIO_RESET)
 				(*pdata)->FPD_gpio = ctl_data->gpio[i].pin;
@@ -491,6 +496,14 @@ void set_lt_gpio(struct control_logic_data *ctl_data, struct sensor_platform_dat
 
 	if (ctl_data->completed && ctl_data->gpio_num > 0 && !is_dummy) {
 		for (i = 0; i < ctl_data->gpio_num; i++) {
+			/* check for unsupported GPIO function */
+			if (ctl_data->gpio[i].func != GPIO_RESET &&
+			    ctl_data->gpio[i].func != GPIO_READY_STAT &&
+			    ctl_data->gpio[i].func != GPIO_HDMI_DETECT)
+				dev_err(ctl_data->dev,
+					"IPU6 ACPI: Invalid GPIO func: %d\n",
+					ctl_data->gpio[i].func);
+
 			/* check for RESET selection in BIOS */
 			if (ctl_data->gpio[i].valid && ctl_data->gpio[i].func == GPIO_RESET)
 				(*pdata)->reset_pin = ctl_data->gpio[i].pin;
@@ -511,10 +524,12 @@ void set_lt_gpio(struct control_logic_data *ctl_data, struct sensor_platform_dat
 	}
 }
 
-void set_common_gpio(struct sensor_platform_data **pdata)
+void set_common_gpio(struct control_logic_data *ctl_data,
+		     struct sensor_platform_data **pdata)
 {
-	/* TODO: consider remove specific naming such as irq_pin, and use gpios[] */
+	int i;
 
+	/* TODO: consider remove specific naming such as irq_pin, and use gpios[] */
 	(*pdata)->irq_pin = -1;
 	(*pdata)->reset_pin = -1;
 	(*pdata)->detect_pin = -1;
@@ -523,6 +538,14 @@ void set_common_gpio(struct sensor_platform_data **pdata)
 	(*pdata)->gpios[1] = 0;
 	(*pdata)->gpios[2] = 0;
 	(*pdata)->gpios[3] = 0;
+
+	/* all sensors should have RESET GPIO */
+	if (ctl_data->completed && ctl_data->gpio_num > 0)
+		for (i = 0; i < ctl_data->gpio_num; i++)
+			if (ctl_data->gpio[i].func != GPIO_RESET)
+				dev_err(ctl_data->dev,
+					"IPU6 ACPI: Invalid GPIO func: %d\n",
+					ctl_data->gpio[i].func);
 }
 
 int set_csi2(struct ipu_isys_subdev_info **sensor_sd,
@@ -659,7 +682,7 @@ int set_pdata(struct ipu_isys_subdev_info **sensor_sd,
 		if (!strcmp(sensor_name, LT6911UXC_NAME) || !strcmp(sensor_name, LT6911UXE_NAME))
 			set_lt_gpio(ctl_data, &pdata, is_dummy);
 		else
-			set_common_gpio(&pdata);
+			set_common_gpio(ctl_data, &pdata);
 
 		(*sensor_sd)->i2c.board_info.platform_data = pdata;
 	} else if (connect == TYPE_SERDES) {
@@ -779,7 +802,22 @@ int populate_sensor_pdata(struct device *dev,
 				cam_data->i2c_num);
 			return -1;
 		}
-
+		/* LT use LT Control Logic type */
+		if (!strcmp(sensor_name, LT6911UXC_NAME) ||
+		    !strcmp(sensor_name, LT6911UXE_NAME)) {
+			if (ctl_data->type != CL_LT) {
+				dev_err(dev, "IPU6 ACPI: Control Logic Type\n");
+				dev_err(dev, "for %s: %d is Incorrect\n",
+					sensor_name, ctl_data->type);
+				return -EINVAL;
+			}
+		/* Others use DISCRETE Control Logic */
+		} else if (ctl_data->type != CL_DISCRETE) {
+			dev_err(dev, "IPU6 ACPI: Control Logic Type\n");
+			dev_err(dev, "for %s: %d is Incorrect\n",
+				sensor_name, ctl_data->type);
+			return -EINVAL;
+		}
 	} else if (connect == TYPE_SERDES) {
 		/* serdes csi2 info. pprval as deserializer lane */
 		ret = set_csi2(sensor_sd, cam_data->pprval, cam_data->link);
@@ -853,6 +891,8 @@ int get_sensor_pdata(struct i2c_client *client,
 		return -ENOMEM;
 	}
 
+	ctl_data->dev = &client->dev;
+
 	sensor_sd = kzalloc(sizeof(*sensor_sd), GFP_KERNEL);
 	if (!sensor_sd) {
 		kfree(cam_data);
diff --git a/drivers/media/platform/intel/ipu6-acpi.c b/drivers/media/platform/intel/ipu6-acpi.c
index 4c65b604ab09..7f456efbc852 100644
--- a/drivers/media/platform/intel/ipu6-acpi.c
+++ b/drivers/media/platform/intel/ipu6-acpi.c
@@ -140,7 +140,8 @@ static int ipu_i2c_test(struct device *dev, void *priv)
 
 	acpi_id = acpi_match_device(ipu_acpi_match, dev);
 	if (!acpi_id) {
-		pr_err("IPU6 ACPI: ACPI device NOT supported in IPU6 ACPI driver");
+		dev_err(dev, "IPU6 ACPI: ACPI device %s NOT supported\n",
+			dev_name(dev));
 		return 0;
 	}
 
diff --git a/include/media/ipu-acpi-pdata.h b/include/media/ipu-acpi-pdata.h
index 1aef83ded136..479b89c3371d 100644
--- a/include/media/ipu-acpi-pdata.h
+++ b/include/media/ipu-acpi-pdata.h
@@ -11,6 +11,7 @@
 
 #define CL_EMPTY 0
 #define CL_DISCRETE 1
+#define CL_LT 5
 #define SERDES_MAX_PORT 4
 #define SERDES_MAX_GPIO_POWERUP_SEQ 4
 #define LOOP_SIZE 10
-- 
2.25.1

