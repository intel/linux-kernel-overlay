From 8929d0f19b32f4b1c774b743b951ae318230c4c4 Mon Sep 17 00:00:00 2001
From: Alexander Usyskin <alexander.usyskin@intel.com>
Date: Thu, 6 Oct 2022 13:28:06 +0300
Subject: [PATCH 10/18] INTEL_DII: mei: add force wake workaround on session
 open

Upon force wake assert the firmware goes into reset.
Force wake it at the beginnng of the session and
wait till FW restarts itself and link established.
Release FW from force wake only when session closes.
All client should be advised to release sessions as
soon as possible to allow system to go back to low power state.

Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
Reviewed-by: Tomas Winkler <tomas.winkler@intel.com>
---
 drivers/misc/mei/client.c  | 62 ++++++++++++++++++++++++++++++++++++--
 drivers/misc/mei/hw.h      |  3 ++
 drivers/misc/mei/init.c    |  2 ++
 drivers/misc/mei/mei_dev.h |  2 ++
 4 files changed, 67 insertions(+), 2 deletions(-)

diff --git a/drivers/misc/mei/client.c b/drivers/misc/mei/client.c
index dcab98776f95..c72786aa134e 100644
--- a/drivers/misc/mei/client.c
+++ b/drivers/misc/mei/client.c
@@ -636,6 +636,51 @@ struct mei_cl *mei_cl_allocate(struct mei_device *dev)
 	return cl;
 }
 
+
+static inline int mei_cl_forcewake_get_and_wait(struct mei_cl *cl)
+{
+	struct mei_device *dev = cl->dev;
+
+	if (!dev->forcewake_needed)
+		return 0;
+
+	/*
+	 * grab the GT forcewake bit to prevent RC6-exit
+	 * which would cause firmware reset
+	 */
+	dev->ops->forcewake_get(dev);
+
+	/* wait for firmware reset or timeout */
+	cl_dbg(dev, cl, "wait for firmware reset or timeout\n");
+	mutex_unlock(&dev->device_lock);
+	wait_event_timeout(dev->wait_dev_state,
+			   dev->dev_state != MEI_DEV_ENABLED,
+			   dev->timeouts.gt_forcewake);
+	mutex_lock(&dev->device_lock);
+
+	cl_dbg(dev, cl, "firmware reset or timeout dev_state = %d\n", dev->dev_state);
+	if (dev->dev_state >= MEI_DEV_DISABLED) { /* device is going down */
+		cl_err(dev, cl, "device is going down dev_state = %d\n",
+		       dev->dev_state);
+		return -ENODEV;
+	}
+	if (dev->dev_state != MEI_DEV_ENABLED) { /* not timed out */
+		mutex_unlock(&dev->device_lock);
+		wait_event_timeout(dev->wait_dev_state,
+				   dev->dev_state == MEI_DEV_ENABLED,
+				   dev->timeouts.gt_forcewake_link);
+		mutex_lock(&dev->device_lock);
+
+		if (dev->dev_state != MEI_DEV_ENABLED) {
+			cl_err(dev, cl, "device is not back from reset dev_state = %d\n",
+			       dev->dev_state);
+			return -ENODEV;
+		}
+		cl_dbg(dev, cl, "back from reset\n");
+	}
+	return 0;
+}
+
 /**
  * mei_cl_link - allocate host id in the host map
  *
@@ -649,22 +694,29 @@ int mei_cl_link(struct mei_cl *cl)
 {
 	struct mei_device *dev;
 	int id;
+	int ret;
 
 	if (WARN_ON(!cl || !cl->dev))
 		return -EINVAL;
 
 	dev = cl->dev;
 
+	ret = mei_cl_forcewake_get_and_wait(cl);
+	if (ret)
+		goto err;
+
 	id = find_first_zero_bit(dev->host_clients_map, MEI_CLIENTS_MAX);
 	if (id >= MEI_CLIENTS_MAX) {
 		dev_err(dev->dev, "id exceeded %d", MEI_CLIENTS_MAX);
-		return -EMFILE;
+		ret = -EMFILE;
+		goto err;
 	}
 
 	if (dev->open_handle_count >= MEI_MAX_OPEN_HANDLE_COUNT) {
 		dev_err(dev->dev, "open_handle_count exceeded %d",
 			MEI_MAX_OPEN_HANDLE_COUNT);
-		return -EMFILE;
+		ret = -EMFILE;
+		goto err;
 	}
 
 	dev->open_handle_count++;
@@ -678,6 +730,10 @@ int mei_cl_link(struct mei_cl *cl)
 
 	cl_dbg(dev, cl, "link cl\n");
 	return 0;
+
+err:
+	mei_forcewake_put(dev);
+	return ret;
 }
 
 /**
@@ -721,6 +777,8 @@ int mei_cl_unlink(struct mei_cl *cl)
 		!list_empty(&cl->rd_pending) ||
 		!list_empty(&cl->link));
 
+	mei_forcewake_put(dev);
+
 	return 0;
 }
 
diff --git a/drivers/misc/mei/hw.h b/drivers/misc/mei/hw.h
index 2e9cf6f4efb6..ad800a7f3e17 100644
--- a/drivers/misc/mei/hw.h
+++ b/drivers/misc/mei/hw.h
@@ -27,6 +27,9 @@
 #define MKHI_RCV_TIMEOUT 500 /* receive timeout in msec */
 #define MKHI_RCV_TIMEOUT_SLOW 10000 /* receive timeout in msec, slow FW */
 
+#define MEI_GT_FORCEWAKE_TIMEOUT      1 /* Timeout to wait for FW reset after GT Forcewake */
+#define MEI_GT_FORCEWAKE_LINK_TIMEOUT 3 /* Timeout to wait for driver ready after GT Forcewake */
+
 /*
  * FW page size for DMA allocations
  */
diff --git a/drivers/misc/mei/init.c b/drivers/misc/mei/init.c
index af91f86afc58..00500a28f0d4 100644
--- a/drivers/misc/mei/init.c
+++ b/drivers/misc/mei/init.c
@@ -437,6 +437,8 @@ void mei_device_init(struct mei_device *dev,
 	dev->timeouts.client_init = MEI_CLIENTS_INIT_TIMEOUT;
 	dev->timeouts.pgi = mei_secs_to_jiffies(MEI_PGI_TIMEOUT);
 	dev->timeouts.d0i3 = mei_secs_to_jiffies(MEI_D0I3_TIMEOUT);
+	dev->timeouts.gt_forcewake = mei_secs_to_jiffies(MEI_GT_FORCEWAKE_TIMEOUT);
+	dev->timeouts.gt_forcewake_link = mei_secs_to_jiffies(MEI_GT_FORCEWAKE_LINK_TIMEOUT);
 	if (slow_fw) {
 		dev->timeouts.cl_connect = mei_secs_to_jiffies(MEI_CL_CONNECT_TIMEOUT_SLOW);
 		dev->timeouts.hbm = mei_secs_to_jiffies(MEI_HBM_TIMEOUT_SLOW);
diff --git a/drivers/misc/mei/mei_dev.h b/drivers/misc/mei/mei_dev.h
index 30f6e4044dd4..842f80e8a422 100644
--- a/drivers/misc/mei/mei_dev.h
+++ b/drivers/misc/mei/mei_dev.h
@@ -469,6 +469,8 @@ struct mei_dev_timeouts {
 	unsigned int d0i3; /* D0i3 set/unset max response time, in jiffies */
 	unsigned long hbm; /* HBM operation timeout, in jiffies */
 	unsigned long mkhi_recv; /* receive timeout, in jiffies */
+	unsigned long gt_forcewake; /* GT forcewake timeout, in jiffies */
+	unsigned long gt_forcewake_link; /* GT forcewake link timeout, in jiffies */
 };
 
 /**
-- 
2.25.1

