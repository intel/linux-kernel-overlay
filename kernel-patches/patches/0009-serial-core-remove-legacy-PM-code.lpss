From 7674aa4e02a4d46da8a9633d7862692eae670e42 Mon Sep 17 00:00:00 2001
From: "Balaramegowda, ChandanaX Goravi"
 <chandanax.goravi.balaramegowda@intel.com>
Date: Fri, 4 Feb 2022 17:55:03 +0530
Subject: [PATCH 09/10] serial: core: remove legacy PM code

The drivers in serial subsystem has been switched to support runtime PM, remove
legacy PM code from serial_core.c.

Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
---
 drivers/tty/serial/serial_core.c | 54 --------------------------------
 include/linux/serial_core.h      | 15 ---------
 2 files changed, 69 deletions(-)

diff --git a/drivers/tty/serial/serial_core.c b/drivers/tty/serial/serial_core.c
index 6ee755a6b873..581b8ccd87ce 100644
--- a/drivers/tty/serial/serial_core.c
+++ b/drivers/tty/serial/serial_core.c
@@ -46,8 +46,6 @@ static struct lock_class_key port_lock_key;
 static void uart_change_speed(struct tty_struct *tty, struct uart_state *state,
 					struct ktermios *old_termios);
 static void uart_wait_until_sent(struct tty_struct *tty, int timeout);
-static void uart_change_pm(struct uart_state *state,
-			   enum uart_pm_state pm_state);
 
 static void uart_port_shutdown(struct tty_port *port);
 
@@ -205,11 +203,6 @@ static int uart_port_startup(struct tty_struct *tty, struct uart_state *state,
 	if (uport->type == PORT_UNKNOWN)
 		return 1;
 
-	/*
-	 * Make sure the device is in D0 state.
-	 */
-	uart_change_pm(state, UART_PM_STATE_ON);
-
 	/*
 	 * Initialise and allocate the transmit and temporary
 	 * buffer.
@@ -1658,8 +1651,6 @@ static void uart_tty_port_shutdown(struct tty_port *port)
 
 	if (buf)
 		free_page((unsigned long)buf);
-
-	uart_change_pm(state, UART_PM_STATE_OFF);
 }
 
 static void uart_wait_until_sent(struct tty_struct *tty, int timeout)
@@ -1750,8 +1741,6 @@ static void uart_hangup(struct tty_struct *tty)
 		spin_unlock_irqrestore(&port->lock, flags);
 		tty_port_set_active(port, 0);
 		tty_port_tty_set(port, NULL);
-		if (uport && !uart_console(uport))
-			uart_change_pm(state, UART_PM_STATE_OFF);
 		wake_up_interruptible(&port->open_wait);
 		wake_up_interruptible(&port->delta_msr_wait);
 	}
@@ -1898,7 +1887,6 @@ static void uart_line_info(struct seq_file *m, struct uart_driver *drv, int i)
 {
 	struct uart_state *state = drv->state + i;
 	struct tty_port *port = &state->port;
-	enum uart_pm_state pm_state;
 	struct uart_port *uport;
 	char stat_buf[32];
 	unsigned int status;
@@ -1923,17 +1911,12 @@ static void uart_line_info(struct seq_file *m, struct uart_driver *drv, int i)
 	}
 
 	if (capable(CAP_SYS_ADMIN)) {
-		pm_state = state->pm_state;
-		if (pm_state != UART_PM_STATE_ON)
-			uart_change_pm(state, UART_PM_STATE_ON);
 		pm_runtime_get_sync(uport->dev);
 		spin_lock_irq(&uport->lock);
 		status = uport->ops->get_mctrl(uport);
 		spin_unlock_irq(&uport->lock);
 		pm_runtime_mark_last_busy(uport->dev);
 		pm_runtime_put_autosuspend(uport->dev);
-		if (pm_state != UART_PM_STATE_ON)
-			uart_change_pm(state, pm_state);
 
 		seq_printf(m, " tx:%d rx:%d",
 				uport->icount.tx, uport->icount.rx);
@@ -2210,26 +2193,6 @@ uart_set_options(struct uart_port *port, struct console *co,
 EXPORT_SYMBOL_GPL(uart_set_options);
 #endif /* CONFIG_SERIAL_CORE_CONSOLE */
 
-/**
- * uart_change_pm - set power state of the port
- *
- * @state: port descriptor
- * @pm_state: new state
- *
- * Locking: port->mutex has to be held
- */
-static void uart_change_pm(struct uart_state *state,
-			   enum uart_pm_state pm_state)
-{
-	struct uart_port *port = uart_port_check(state);
-
-	if (state->pm_state != pm_state) {
-		if (port && port->ops->pm)
-			port->ops->pm(port, pm_state, state->pm_state);
-		state->pm_state = pm_state;
-	}
-}
-
 struct uart_match {
 	struct uart_port *port;
 	struct uart_driver *driver;
@@ -2304,8 +2267,6 @@ int uart_suspend_port(struct uart_driver *drv, struct uart_port *uport)
 	 */
 	if (uart_console(uport))
 		console_stop(uport->cons);
-
-	uart_change_pm(state, UART_PM_STATE_OFF);
 unlock:
 	mutex_unlock(&port->mutex);
 
@@ -2351,9 +2312,6 @@ int uart_resume_port(struct uart_driver *drv, struct uart_port *uport)
 		if (port->tty && termios.c_cflag == 0)
 			termios = port->tty->termios;
 
-		if (console_suspend_enabled)
-			uart_change_pm(state, UART_PM_STATE_ON);
-
 		pm_runtime_get_sync(uport->dev);
 		uport->ops->set_termios(uport, &termios, NULL);
 		pm_runtime_mark_last_busy(uport->dev);
@@ -2367,7 +2325,6 @@ int uart_resume_port(struct uart_driver *drv, struct uart_port *uport)
 		const struct uart_ops *ops = uport->ops;
 		int ret;
 
-		uart_change_pm(state, UART_PM_STATE_ON);
 		pm_runtime_get_sync(uport->dev);
 		spin_lock_irq(&uport->lock);
 		ops->set_mctrl(uport, 0);
@@ -2486,9 +2443,6 @@ uart_configure_port(struct uart_driver *drv, struct uart_state *state,
 
 		uart_report_port(drv, port);
 
-		/* Power up port for set_mctrl() */
-		uart_change_pm(state, UART_PM_STATE_ON);
-
 		/*
 		 * Ensure that the modem control lines are de-activated.
 		 * keep the DTR setting that is set in uart_set_options()
@@ -2512,13 +2466,6 @@ uart_configure_port(struct uart_driver *drv, struct uart_state *state,
 		 */
 		if (port->cons && !(port->cons->flags & CON_ENABLED))
 			register_console(port->cons);
-
-		/*
-		 * Power down all ports by default, except the
-		 * console if we have one.
-		 */
-		if (!uart_console(port))
-			uart_change_pm(state, UART_PM_STATE_OFF);
 	}
 }
 
@@ -3005,7 +2952,6 @@ int uart_add_one_port(struct uart_driver *drv, struct uart_port *uport)
 	state->uart_port = uport;
 	uport->state = state;
 
-	state->pm_state = UART_PM_STATE_UNDEFINED;
 	uport->cons = drv->cons;
 	uport->minor = drv->tty_driver->minor_start + uport->line;
 	uport->name = kasprintf(GFP_KERNEL, "%s%d", drv->dev_name,
diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 8757b4a6be31..9f3e6eab44e1 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -53,8 +53,6 @@ struct uart_ops {
 	void		(*set_termios)(struct uart_port *, struct ktermios *new,
 				       struct ktermios *old);
 	void		(*set_ldisc)(struct uart_port *, struct ktermios *);
-	void		(*pm)(struct uart_port *, unsigned int state,
-			      unsigned int oldstate);
 
 	/*
 	 * Return a string describing the type of the port
@@ -268,25 +266,12 @@ static inline void serial_port_out(struct uart_port *up, int offset, int value)
 	up->serial_out(up, offset, value);
 }
 
-/**
- * enum uart_pm_state - power states for UARTs
- * @UART_PM_STATE_ON: UART is powered, up and operational
- * @UART_PM_STATE_OFF: UART is powered off
- * @UART_PM_STATE_UNDEFINED: sentinel
- */
-enum uart_pm_state {
-	UART_PM_STATE_ON = 0,
-	UART_PM_STATE_OFF = 3, /* number taken from ACPI */
-	UART_PM_STATE_UNDEFINED,
-};
-
 /*
  * This is the state information which is persistent across opens.
  */
 struct uart_state {
 	struct tty_port		port;
 
-	enum uart_pm_state	pm_state;
 	struct circ_buf		xmit;
 
 	atomic_t		refcount;
-- 
2.25.1

