From 6ec175ddb7035cce9da4f15f145ad319bbbcb68e Mon Sep 17 00:00:00 2001
From: Alexander Usyskin <alexander.usyskin@intel.com>
Date: Thu, 30 Mar 2023 12:48:02 +0300
Subject: [PATCH 17/21] INTEL_DII: mei: put force wake in error flows

Add force wake put in error flows in probe and resume routines.

Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
---
 drivers/misc/mei/gsc-me.c | 34 +++++++++++++++++++++++++++-------
 1 file changed, 27 insertions(+), 7 deletions(-)

diff --git a/drivers/misc/mei/gsc-me.c b/drivers/misc/mei/gsc-me.c
index e3a5eddc4668..7a8104f321d4 100644
--- a/drivers/misc/mei/gsc-me.c
+++ b/drivers/misc/mei/gsc-me.c
@@ -384,6 +384,8 @@ static int mei_gsc_forcewake_get_and_wait(struct mei_device *dev, bool need_runt
 
 	if (!(fw_status.status[0] & PCI_CFG_HFS_1_INITSTATE)) {
 		dev_err(dev->dev, "forcewake: FW not back from reset: %d\n", fw_status.status[0]);
+		dev->gt_forcewake_init_on = false;
+		dev->ops->forcewake_put(dev);
 		return -ENODEV;
 	}
 
@@ -399,6 +401,23 @@ static int mei_gsc_forcewake_get_and_wait(struct mei_device *dev, bool need_runt
 	return 0;
 }
 
+static void mei_gsc_forcewake_put(struct mei_device *dev, bool need_runtime_pm)
+{
+	mutex_lock(&dev->device_lock);
+
+	if (dev->forcewake_needed && dev->gt_forcewake_init_on) {
+		dev->ops->forcewake_put(dev);
+		dev->gt_forcewake_init_on = false;
+
+		if (need_runtime_pm) {
+			dev->ops->forcewake_put(dev);
+			pm_runtime_put_noidle(dev->dev);
+		}
+	}
+
+	mutex_unlock(&dev->device_lock);
+}
+
 static int mei_gsc_probe(struct auxiliary_device *aux_dev,
 			 const struct auxiliary_device_id *aux_dev_id)
 {
@@ -459,7 +478,7 @@ static int mei_gsc_probe(struct auxiliary_device *aux_dev,
 		if (IS_ERR(hw->polling_thread)) {
 			ret = PTR_ERR(hw->polling_thread);
 			dev_err(device, "unable to create kernel thread: %d\n", ret);
-			goto err;
+			goto irq_err;
 		}
 	} else {
 		ret = devm_request_threaded_irq(device, hw->irq,
@@ -468,7 +487,7 @@ static int mei_gsc_probe(struct auxiliary_device *aux_dev,
 						IRQF_ONESHOT, KBUILD_MODNAME, dev);
 		if (ret) {
 			dev_err(device, "irq register failed %d\n", ret);
-			goto err;
+			goto irq_err;
 		}
 	}
 
@@ -499,6 +518,8 @@ static int mei_gsc_probe(struct auxiliary_device *aux_dev,
 	if (!mei_me_hw_use_polling(hw))
 		devm_free_irq(device, hw->irq, dev);
 
+irq_err:
+	mei_gsc_forcewake_put(dev, true);
 err:
 	dev_err(device, "probe failed: %d\n", ret);
 	dev_set_drvdata(device, NULL);
@@ -517,10 +538,7 @@ static void mei_gsc_remove(struct auxiliary_device *aux_dev)
 
 	mei_stop(dev);
 
-	if (dev->forcewake_needed && dev->gt_forcewake_init_on) {
-		dev->ops->forcewake_put(dev);
-		dev->gt_forcewake_init_on = false;
-	}
+	mei_gsc_forcewake_put(dev, true);
 
 	hw = to_me_hw(dev);
 	if (mei_me_hw_use_polling(hw))
@@ -569,8 +587,10 @@ static int __maybe_unused mei_gsc_pm_resume(struct device *device)
 	}
 
 	ret = mei_restart(dev);
-	if (ret)
+	if (ret) {
+		mei_gsc_forcewake_put(dev, false);
 		return ret;
+	}
 
 	/* Start timer if stopped in suspend */
 	schedule_delayed_work(&dev->timer_work, HZ);
-- 
2.25.1

