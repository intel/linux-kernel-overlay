From 7a8c1a95fbe3e4b89a7b82a87eead29eb2026263 Mon Sep 17 00:00:00 2001
From: Ricardo Neri <ricardo.neri-calderon@linux.intel.com>
Date: Fri, 18 Sep 2020 13:46:50 -0700
Subject: [PATCH 18/72] drivers base/topology: Relocate capacity normalization
 code to topology.c

Refactor the capacity normalization code to relocate it to topology.c This
makes it available to computer architectures that do not use the
arch_topology driver but want to use CPU capacity accounting. The
refactored code uses a temporal buffer to store raw capacity as obtained
from hardware. arch_topology continues to provide this temporal buffer but
now it calls the new utility function do_topology_normalize_cpu_scale().
Other callers need to provide their own temporal buffer.

Cc: Andi Kleen <ak@linux.intel.com>
Cc: Len Brown <len.brown@intel.com>
Cc: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Cc: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Cc: Tim Chen <tim.c.chen@linux.intel.com>
Signed-off-by: Ricardo Neri <ricardo.neri-calderon@linux.intel.com>
---
Changes since v4:
  * Introduced this patch.

Changes since v3:
  * N/A

Changes since v2:
  * N/A

Changes since v1:
  * N/A
---
 drivers/base/arch_topology.c | 26 +-------------------------
 drivers/base/topology.c      | 29 +++++++++++++++++++++++++++++
 include/linux/topology.h     |  1 +
 3 files changed, 31 insertions(+), 25 deletions(-)

diff --git a/drivers/base/arch_topology.c b/drivers/base/arch_topology.c
index ac7a52682ccf..2f141d2427f4 100644
--- a/drivers/base/arch_topology.c
+++ b/drivers/base/arch_topology.c
@@ -185,31 +185,7 @@ static int free_raw_capacity(void)
 
 void topology_normalize_cpu_scale(void)
 {
-	u64 capacity;
-	u64 capacity_scale;
-	u32 freq_factor;
-	int cpu;
-
-	if (!raw_capacity)
-		return;
-
-	capacity_scale = 1;
-	for_each_possible_cpu(cpu) {
-		freq_factor = arch_topology_get_factor(cpu);
-		capacity = raw_capacity[cpu] * freq_factor;
-		capacity_scale = max(capacity, capacity_scale);
-	}
-
-	pr_debug("cpu_capacity: capacity_scale=%llu\n", capacity_scale);
-	for_each_possible_cpu(cpu) {
-		freq_factor = arch_topology_get_factor(cpu);
-		capacity = raw_capacity[cpu] * freq_factor;
-		capacity = div64_u64(capacity << SCHED_CAPACITY_SHIFT,
-			capacity_scale);
-		topology_set_cpu_scale(cpu, capacity);
-		pr_debug("cpu_capacity: CPU%d cpu_capacity=%lu\n",
-			cpu, topology_get_cpu_scale(cpu));
-	}
+	do_topology_normalize_cpu_scale(raw_capacity);
 }
 
 bool __init topology_parse_cpu_capacity(struct device_node *cpu_node, int cpu)
diff --git a/drivers/base/topology.c b/drivers/base/topology.c
index 49af9a8c1aee..b56a8a996c5e 100644
--- a/drivers/base/topology.c
+++ b/drivers/base/topology.c
@@ -183,3 +183,32 @@ u32 __weak arch_topology_get_factor(int cpu)
 {
 	return 1;
 }
+
+void do_topology_normalize_cpu_scale(u32 *raw_capacity)
+{
+	u64 capacity;
+	u64 capacity_scale;
+	u32 freq_factor;
+	int cpu;
+
+	if (!raw_capacity)
+		return;
+
+	capacity_scale = 1;
+	for_each_possible_cpu(cpu) {
+		freq_factor = arch_topology_get_factor(cpu);
+		capacity = raw_capacity[cpu] * freq_factor;
+		capacity_scale = max(capacity, capacity_scale);
+	}
+
+	pr_debug("cpu_capacity: capacity_scale=%llu\n", capacity_scale);
+	for_each_possible_cpu(cpu) {
+		freq_factor = arch_topology_get_factor(cpu);
+		capacity = raw_capacity[cpu] * freq_factor;
+		capacity = div64_u64(capacity << SCHED_CAPACITY_SHIFT,
+			capacity_scale);
+		topology_set_cpu_scale(cpu, capacity);
+		pr_debug("cpu_capacity: CPU%d cpu_capacity=%lu\n",
+			cpu, topology_get_cpu_scale(cpu));
+	}
+}
diff --git a/include/linux/topology.h b/include/linux/topology.h
index 4fbfb41b5cd2..76f154a9dfd1 100644
--- a/include/linux/topology.h
+++ b/include/linux/topology.h
@@ -221,4 +221,5 @@ static inline unsigned long topology_get_cpu_scale(int cpu)
 void topology_set_cpu_scale(unsigned int cpu, unsigned long capacity);
 
 u32 arch_topology_get_factor(int cpu);
+void do_topology_normalize_cpu_scale(u32 *raw_capacity);
 #endif /* _LINUX_TOPOLOGY_H */
-- 
2.27.0

