From 2529ee3f2af4a60dde743ef5f4d25b7c2cf1f185 Mon Sep 17 00:00:00 2001
From: Ricardo Neri <ricardo.neri-calderon@linux.intel.com>
Date: Tue, 21 Sep 2021 15:42:34 -0700
Subject: [PATCH 26/41] thermal: intel: hfi: Accommodate systems with irregular
 thermal interrupts

There exist systems in the field (e.g., Lakefield) in which not all CPUs.
get the package level thermal interrupt. Furthermore, it is possible that
the CPUs that do receive the thermal interrupt are not ready to handle it
because the thermal vector in the local APIC has not been enabled. In such
cases it is possible to miss an HFI update it CPUs that are ready do not
receive the thermal interrupt and CPUs that are not ready do.

Work around this issue by checking the status of the HFI thermal interrupt
each time a CPU comes online. If it finds that the status bit is set, it
means that a missed interrupt happened. In such cases, consume the update
and schedule work to process it.

Cc: Andi Kleen <ak@linux.intel.com>
Cc: Aubrey Li <aubrey.li@linux.intel.com>
Cc: Len Brown <len.brown@intel.com>
Cc: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Cc: Tim Chen <tim.c.chen@linux.intel.com>
Cc: "Ravi V. Shankar" <ravi.v.shankar@intel.com>
Signed-off-by: Ricardo Neri <ricardo.neri-calderon@linux.intel.com>
---
 drivers/thermal/intel/intel_hfi.c | 34 +++++++++++++++++++++++++++++++
 1 file changed, 34 insertions(+)

diff --git a/drivers/thermal/intel/intel_hfi.c b/drivers/thermal/intel/intel_hfi.c
index 856abbae83ad..3b4b8c1d7fa6 100644
--- a/drivers/thermal/intel/intel_hfi.c
+++ b/drivers/thermal/intel/intel_hfi.c
@@ -381,6 +381,40 @@ void intel_hfi_online(unsigned int cpu)
 		cpumask_set_cpu(cpu, hfi_instance->cpus);
 		info->hfi_instance = hfi_instance;
 
+		/*
+		 * Both the HFI thermal interrupt and the local APIC thermal LVT
+		 * are enabled when a CPU comes online. On some systems, all
+		 * CPUs get the package thermak interrupt. On others, however,
+		 * only a subset of CPU gets it. In the former case, we always
+		 * get the interrupt as we enable the HFI after having enabled
+		 * the thermal interrupt in the local APIC. However, in the
+		 * latter case, we may miss the interrupt if hardware issues the
+		 * interrupt to a CPU in which the thermal vector has not been
+		 * enabled in the local APIC. We know that this is the case as
+		 * the status bit will be set. In such a case, handle the
+		 * interrupt.
+		 */
+		raw_spin_lock_irq(&hfi_instance->table_lock);
+		rdmsrl(MSR_IA32_PACKAGE_THERM_STATUS, msr_val);
+		if (msr_val & PACKAGE_THERM_STATUS_HFI_UPDATED) {
+			memcpy(hfi_instance->local_table, hfi_instance->hw_table,
+			       hfi_features.nr_table_pages << PAGE_SHIFT);
+
+			msr_val &= THERM_STATUS_CLEAR_PKG_MASK &
+				   ~PACKAGE_THERM_STATUS_HFI_UPDATED;
+			wrmsrl(MSR_IA32_PACKAGE_THERM_STATUS, msr_val);
+
+			raw_spin_unlock_irq(&hfi_instance->table_lock);
+
+			schedule_delayed_work(&hfi_instance->update_work,
+					      HFI_UPDATE_INTERVAL);
+
+			mutex_unlock(&hfi_lock);
+			return;
+		}
+
+		raw_spin_unlock_irq(&hfi_instance->table_lock);
+
 		mutex_unlock(&hfi_lock);
 		return;
 	}
-- 
2.32.0

