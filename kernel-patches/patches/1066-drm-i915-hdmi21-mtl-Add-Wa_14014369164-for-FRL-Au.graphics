From b4a85186bad3ac9b374cf90c76bb33c0107c2fe0 Mon Sep 17 00:00:00 2001
From: Mitul Golani <mitulkumar.ajitkumar.golani@intel.com>
Date: Sun, 15 Jan 2023 18:58:52 +0530
Subject: [PATCH 1066/1096] drm/i915/hdmi21/mtl: Add Wa_14014369164 for FRL
 Audio Overhead

Due to the current FRL implementation there are additional
overheads that are needed to be accounted for when checking
audio bandwidth.

As per HDMI 2.1 "FRL Capacity Computations", calculations are
specified to determine the tri-bytes available in hblank based
on video parameters and compare to the required tri-bytes per
hblank for a given audio format.

There are additional overheads which subtract tri-bytes
from those available in hblank as per Wa_14014369164 specific
to Display Version 14.

Signed-off-by: Mitul Golani <mitulkumar.ajitkumar.golani@intel.com>
---
 drivers/gpu/drm/i915/display/intel_hdmi.c | 81 ++++++++++++++++++++++-
 1 file changed, 79 insertions(+), 2 deletions(-)

diff --git a/drivers/gpu/drm/i915/display/intel_hdmi.c b/drivers/gpu/drm/i915/display/intel_hdmi.c
index c85f6cd9e085..b844bd310ea2 100644
--- a/drivers/gpu/drm/i915/display/intel_hdmi.c
+++ b/drivers/gpu/drm/i915/display/intel_hdmi.c
@@ -63,6 +63,15 @@
 #include "intel_snps_phy.h"
 #include "intel_vdsc.h"
 
+/*
+ * Wa_14014369164
+ * Due to the current HDMI FRL implementation subtract additional overhead
+ * tri-bytes from those available in Hblank. 4 tri-bytes to ensure alignment,
+ * additional 12 tri-bytes to avoid multiple run-length end events on same clock.
+ */
+#define FRL_AUDIO_OVERHEAD_IN_TB_16       16
+#define FRL_AUDIO_OVERHEAD_IN_TB_4        4
+
 static int
 get_dsc_compressed_bpp(int num_slices, int slice_width, int hdmi_max_chunk_bytes,
 		       int src_fractional_bpp, int min_dsc_bpp, int max_dsc_bpp);
@@ -2316,6 +2325,40 @@ static int get_dsc_slice_count(struct intel_hdmi *intel_hdmi,
 			hdmi_max_slices, hdmi_throughput);
 }
 
+static bool
+intel_frl_dfm_dsc_requirement_met(struct drm_i915_private *i915,
+				  struct intel_crtc_state *pipe_config,
+				  struct drm_hdmi_frl_dfm *frl_dfm)
+{
+	struct drm_display_mode *adjusted_mode = &pipe_config->hw.adjusted_mode;
+	unsigned int hfront = adjusted_mode->hsync_start - adjusted_mode->hdisplay;
+	unsigned int tb_front, tb_overhead;
+	unsigned int bpp_x16 = frl_dfm->config.target_bpp_16;
+
+	if (!drm_frl_dfm_dsc_requirement_met(frl_dfm))
+		return false;
+
+	if (DISPLAY_VER(i915) == 14) {
+		/*
+		 * Need to convert pixel value to Tri-Byte value.
+		 * Number of Bytes = (Bppx16 * HFront) / 8 * 16
+		 * Number of Tri-Bytes =
+		 * Ceil(Number Of Bytes / 3) = > Ceil((Bppx16 * HFront) / 24 * 16)
+		 */
+		tb_front = DIV_ROUND_UP((hfront * bpp_x16), (24 * 16));
+		tb_overhead =
+			(tb_front <= FRL_AUDIO_OVERHEAD_IN_TB_16) ?
+			 FRL_AUDIO_OVERHEAD_IN_TB_16 : FRL_AUDIO_OVERHEAD_IN_TB_4;
+		frl_dfm->params.hcblank_target =
+			frl_dfm->params.hcblank_target - tb_overhead;
+
+		if (frl_dfm->params.hcblank_target < frl_dfm->params.hblank_audio_min)
+			return false;
+	}
+
+	return true;
+}
+
 static bool
 intel_hdmi_can_support_frl_mode_with_dsc(struct intel_hdmi *intel_hdmi,
 					 struct intel_crtc_state *pipe_config,
@@ -2323,6 +2366,7 @@ intel_hdmi_can_support_frl_mode_with_dsc(struct intel_hdmi *intel_hdmi,
 {
 	const struct drm_display_mode *adjusted_mode = &pipe_config->hw.adjusted_mode;
 	struct intel_connector *intel_connector = intel_hdmi->attached_connector;
+	struct drm_i915_private *i915 = to_i915(intel_connector->base.dev);
 	struct drm_connector *connector = &intel_connector->base;
 	int hdmi_max_chunk_bytes = connector->display_info.hdmi.dsc_cap.total_chunk_kbytes * 1024;
 	bool hdmi_all_bpp = connector->display_info.hdmi.dsc_cap.all_bpp;
@@ -2358,13 +2402,46 @@ intel_hdmi_can_support_frl_mode_with_dsc(struct intel_hdmi *intel_hdmi,
 		frl_dfm->config.target_bpp_16 = bpp_x16;
 		frl_dfm->config.slice_width = slice_width;
 
-		if (drm_frl_dfm_dsc_requirement_met(frl_dfm))
+		if (intel_frl_dfm_dsc_requirement_met(i915, pipe_config, frl_dfm))
 			return true;
 	}
 
 	return false;
 }
 
+static bool
+intel_frl_dfm_nondsc_requirement_met(struct drm_i915_private *i915,
+				     struct intel_crtc_state *pipe_config,
+				     struct drm_hdmi_frl_dfm *frl_dfm)
+{
+	struct drm_display_mode *adjusted_mode = &pipe_config->hw.adjusted_mode;
+	unsigned int hfront = adjusted_mode->hsync_start - adjusted_mode->hdisplay;
+	int tb_front, tb_overhead;
+	int bpp = pipe_config->pipe_bpp;
+
+	if (!drm_frl_dfm_nondsc_requirement_met(frl_dfm))
+		return false;
+
+	if (DISPLAY_VER(i915) == 14) {
+		/*
+		 * Need to convert pixel value to Tri-Byte value.
+		 * Number of Bytes = (Bpp * HFront) / 8
+		 * Number of Tri-Bytes =
+		 * Ceil(Number Of Bytes / 3) = > Ceil((Bpp * HFront) / 24)
+		 */
+		tb_front = DIV_ROUND_UP((bpp * hfront), 24);
+		tb_overhead =
+			(tb_front <= FRL_AUDIO_OVERHEAD_IN_TB_16) ?
+			 FRL_AUDIO_OVERHEAD_IN_TB_16 : FRL_AUDIO_OVERHEAD_IN_TB_4;
+		frl_dfm->params.tb_blank = frl_dfm->params.tb_blank - tb_overhead;
+
+		if (frl_dfm->params.tb_blank < frl_dfm->params.hblank_audio_min)
+			return false;
+	}
+
+	return true;
+}
+
 static int
 intel_hdmi_compute_frl_config(struct intel_encoder *encoder,
 			      struct intel_crtc_state *pipe_config)
@@ -2406,7 +2483,7 @@ intel_hdmi_compute_frl_config(struct intel_encoder *encoder,
 			frl_dfm.config.audio_hz = audio_freq_hz[j];
 			frl_dfm.config.audio_channels = 8; /*Support 8 channel audio */
 
-			if (drm_frl_dfm_nondsc_requirement_met(&frl_dfm)) {
+			if (intel_frl_dfm_nondsc_requirement_met(dev_priv, pipe_config, &frl_dfm)) {
 				can_support_frl_mode = true;
 				break;
 			}
-- 
2.25.1

