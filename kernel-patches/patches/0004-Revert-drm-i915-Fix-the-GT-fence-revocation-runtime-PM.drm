From f386c5efa4590049394adf7e759339f9c1fa8c21 Mon Sep 17 00:00:00 2001
From: Ranjan Dutta <ranjan.dutta@intel.com>
Date: Fri, 9 Apr 2021 20:08:42 +0800
Subject: [PATCH 04/11] Revert "drm/i915: Fix the GT fence revocation runtime
 PM logic"

This reverts commit 1e2d70d08adede3d5d8426c9fd1af427564a137f.
---
 drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c | 13 +--------
 drivers/gpu/drm/i915/intel_runtime_pm.c      | 29 ++++----------------
 drivers/gpu/drm/i915/intel_runtime_pm.h      |  5 ----
 3 files changed, 6 insertions(+), 41 deletions(-)

diff --git a/drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c b/drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c
index 6614f6736486..7fb36b12fe7a 100644
--- a/drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c
+++ b/drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c
@@ -316,18 +316,7 @@ void i915_vma_revoke_fence(struct i915_vma *vma)
 	WRITE_ONCE(fence->vma, NULL);
 	vma->fence = NULL;
 
-	/*
-	 * Skip the write to HW if and only if the device is currently
-	 * suspended.
-	 *
-	 * If the driver does not currently hold a wakeref (if_in_use == 0),
-	 * the device may currently be runtime suspended, or it may be woken
-	 * up before the suspend takes place. If the device is not suspended
-	 * (powered down) and we skip clearing the fence register, the HW is
-	 * left in an undefined state where we may end up with multiple
-	 * registers overlapping.
-	 */
-	with_intel_runtime_pm_if_active(fence_to_uncore(fence)->rpm, wakeref)
+	with_intel_runtime_pm_if_in_use(fence_to_uncore(fence)->rpm, wakeref)
 		fence_write(fence);
 }
 
diff --git a/drivers/gpu/drm/i915/intel_runtime_pm.c b/drivers/gpu/drm/i915/intel_runtime_pm.c
index 8b725efb2254..153ca9e65382 100644
--- a/drivers/gpu/drm/i915/intel_runtime_pm.c
+++ b/drivers/gpu/drm/i915/intel_runtime_pm.c
@@ -412,20 +412,12 @@ intel_wakeref_t intel_runtime_pm_get(struct intel_runtime_pm *rpm)
 }
 
 /**
- * __intel_runtime_pm_get_if_active - grab a runtime pm reference if device is active
+ * intel_runtime_pm_get_if_in_use - grab a runtime pm reference if device in use
  * @rpm: the intel_runtime_pm structure
- * @ignore_usecount: get a ref even if dev->power.usage_count is 0
  *
  * This function grabs a device-level runtime pm reference if the device is
- * already active and ensures that it is powered up. It is illegal to try
- * and access the HW should intel_runtime_pm_get_if_active() report failure.
- *
- * If @ignore_usecount=true, a reference will be acquired even if there is no
- * user requiring the device to be powered up (dev->power.usage_count == 0).
- * If the function returns false in this case then it's guaranteed that the
- * device's runtime suspend hook has been called already or that it will be
- * called (and hence it's also guaranteed that the device's runtime resume
- * hook will be called eventually).
+ * already in use and ensures that it is powered up. It is illegal to try
+ * and access the HW should intel_runtime_pm_get_if_in_use() report failure.
  *
  * Any runtime pm reference obtained by this function must have a symmetric
  * call to intel_runtime_pm_put() to release the reference again.
@@ -433,8 +425,7 @@ intel_wakeref_t intel_runtime_pm_get(struct intel_runtime_pm *rpm)
  * Returns: the wakeref cookie to pass to intel_runtime_pm_put(), evaluates
  * as True if the wakeref was acquired, or False otherwise.
  */
-static intel_wakeref_t __intel_runtime_pm_get_if_active(struct intel_runtime_pm *rpm,
-							bool ignore_usecount)
+intel_wakeref_t intel_runtime_pm_get_if_in_use(struct intel_runtime_pm *rpm)
 {
 	if (IS_ENABLED(CONFIG_PM)) {
 		/*
@@ -443,7 +434,7 @@ static intel_wakeref_t __intel_runtime_pm_get_if_active(struct intel_runtime_pm
 		 * function, since the power state is undefined. This applies
 		 * atm to the late/early system suspend/resume handlers.
 		 */
-		if (pm_runtime_get_if_active(rpm->kdev, ignore_usecount) <= 0)
+		if (pm_runtime_get_if_in_use(rpm->kdev) <= 0)
 			return 0;
 	}
 
@@ -452,16 +443,6 @@ static intel_wakeref_t __intel_runtime_pm_get_if_active(struct intel_runtime_pm
 	return track_intel_runtime_pm_wakeref(rpm);
 }
 
-intel_wakeref_t intel_runtime_pm_get_if_in_use(struct intel_runtime_pm *rpm)
-{
-	return __intel_runtime_pm_get_if_active(rpm, false);
-}
-
-intel_wakeref_t intel_runtime_pm_get_if_active(struct intel_runtime_pm *rpm)
-{
-	return __intel_runtime_pm_get_if_active(rpm, true);
-}
-
 /**
  * intel_runtime_pm_get_noresume - grab a runtime pm reference
  * @rpm: the intel_runtime_pm structure
diff --git a/drivers/gpu/drm/i915/intel_runtime_pm.h b/drivers/gpu/drm/i915/intel_runtime_pm.h
index 1e4ddd11c12b..ae64ff14c642 100644
--- a/drivers/gpu/drm/i915/intel_runtime_pm.h
+++ b/drivers/gpu/drm/i915/intel_runtime_pm.h
@@ -177,7 +177,6 @@ void intel_runtime_pm_driver_release(struct intel_runtime_pm *rpm);
 
 intel_wakeref_t intel_runtime_pm_get(struct intel_runtime_pm *rpm);
 intel_wakeref_t intel_runtime_pm_get_if_in_use(struct intel_runtime_pm *rpm);
-intel_wakeref_t intel_runtime_pm_get_if_active(struct intel_runtime_pm *rpm);
 intel_wakeref_t intel_runtime_pm_get_noresume(struct intel_runtime_pm *rpm);
 intel_wakeref_t intel_runtime_pm_get_raw(struct intel_runtime_pm *rpm);
 
@@ -189,10 +188,6 @@ intel_wakeref_t intel_runtime_pm_get_raw(struct intel_runtime_pm *rpm);
 	for ((wf) = intel_runtime_pm_get_if_in_use(rpm); (wf); \
 	     intel_runtime_pm_put((rpm), (wf)), (wf) = 0)
 
-#define with_intel_runtime_pm_if_active(rpm, wf) \
-	for ((wf) = intel_runtime_pm_get_if_active(rpm); (wf); \
-	     intel_runtime_pm_put((rpm), (wf)), (wf) = 0)
-
 void intel_runtime_pm_put_unchecked(struct intel_runtime_pm *rpm);
 #if IS_ENABLED(CONFIG_DRM_I915_DEBUG_RUNTIME_PM)
 void intel_runtime_pm_put(struct intel_runtime_pm *rpm, intel_wakeref_t wref);
-- 
2.25.1

