From f4f573909f4273e27e507e2cd7a6e8913a2c8fc8 Mon Sep 17 00:00:00 2001
From: zouxiaoh <xiaohong.zou@intel.com>
Date: Fri, 5 May 2023 16:31:11 +0800
Subject: [PATCH 6/8] add ipu driver for LTS 6.1

add ipu driver for LTS 6.1

Signed-off-by: zouxiaoh <xiaohong.zou@intel.com>
---
 drivers/media/i2c/ar0234.c                    | 2395 ++++++++
 drivers/media/i2c/d4xx.c                      | 4830 +++++++++++++++++
 drivers/media/i2c/hm11b1.c                    | 1184 ++++
 drivers/media/i2c/imx390-mode-1280x960-CROP.h | 3089 +++++++++++
 drivers/media/i2c/imx390.c                    | 2047 +++++++
 .../imx390_mode_1920x1200HDR3_CUST_PWL12.h    | 3891 +++++++++++++
 drivers/media/i2c/lt6911uxc.c                 | 1567 ++++++
 drivers/media/i2c/ov01a10.c                   |  916 ++++
 drivers/media/i2c/ov01a1s.c                   | 1016 ++++
 drivers/media/i2c/ov02c10.c                   | 1303 +++++
 drivers/media/i2c/ov13858_intel.c             | 2067 +++++++
 drivers/media/i2c/ov8856.c                    | 2478 ++-------
 drivers/media/i2c/power_ctrl_logic.c          |  149 +
 drivers/media/i2c/power_ctrl_logic.h          |    9 +
 drivers/media/i2c/ti953-ser.c                 |  139 +
 drivers/media/i2c/ti953.h                     |  122 +
 drivers/media/i2c/ti960-des.c                 | 1616 ++++++
 drivers/media/i2c/ti960-reg.h                 |  150 +
 drivers/media/i2c/ti964-reg.h                 |  128 +
 drivers/media/i2c/ti964.c                     | 1342 +++++
 drivers/media/pci/intel/Makefile              |    8 +-
 drivers/media/pci/intel/ipu-bus.c             |  270 +
 drivers/media/pci/intel/ipu-bus.h             |   69 +
 drivers/media/pci/intel/ipu-buttress.c        | 1452 +++++
 drivers/media/pci/intel/ipu-buttress.h        |  131 +
 drivers/media/pci/intel/ipu-cpd.c             |  468 ++
 drivers/media/pci/intel/ipu-cpd.h             |  110 +
 drivers/media/pci/intel/ipu-dma.c             |  500 ++
 drivers/media/pci/intel/ipu-dma.h             |   19 +
 drivers/media/pci/intel/ipu-fw-com.c          |  501 ++
 drivers/media/pci/intel/ipu-fw-com.h          |   48 +
 drivers/media/pci/intel/ipu-fw-isys.c         |  600 ++
 drivers/media/pci/intel/ipu-fw-isys.h         |  816 +++
 drivers/media/pci/intel/ipu-fw-psys.c         |  430 ++
 drivers/media/pci/intel/ipu-fw-psys.h         |  382 ++
 .../media/pci/intel/ipu-isys-csi2-be-soc.c    |  360 ++
 drivers/media/pci/intel/ipu-isys-csi2-be.c    |  325 ++
 drivers/media/pci/intel/ipu-isys-csi2-be.h    |   71 +
 drivers/media/pci/intel/ipu-isys-csi2.c       |  669 +++
 drivers/media/pci/intel/ipu-isys-csi2.h       |  166 +
 drivers/media/pci/intel/ipu-isys-media.h      |   77 +
 drivers/media/pci/intel/ipu-isys-queue.c      | 1358 +++++
 drivers/media/pci/intel/ipu-isys-queue.h      |  143 +
 drivers/media/pci/intel/ipu-isys-subdev.c     |  662 +++
 drivers/media/pci/intel/ipu-isys-subdev.h     |  152 +
 drivers/media/pci/intel/ipu-isys-tpg.c        |  311 ++
 drivers/media/pci/intel/ipu-isys-tpg.h        |   98 +
 drivers/media/pci/intel/ipu-isys-video.c      | 2090 +++++++
 drivers/media/pci/intel/ipu-isys-video.h      |  192 +
 drivers/media/pci/intel/ipu-isys.c            | 1231 +++++
 drivers/media/pci/intel/ipu-isys.h            |  195 +
 drivers/media/pci/intel/ipu-mmu.c             |  858 +++
 drivers/media/pci/intel/ipu-mmu.h             |   76 +
 drivers/media/pci/intel/ipu-pdata.h           |  245 +
 drivers/media/pci/intel/ipu-psys-compat32.c   |  222 +
 drivers/media/pci/intel/ipu-psys.c            | 1622 ++++++
 drivers/media/pci/intel/ipu-psys.h            |  216 +
 drivers/media/pci/intel/ipu-trace.c           |  910 ++++
 drivers/media/pci/intel/ipu-trace.h           |  147 +
 drivers/media/pci/intel/ipu.c                 |  989 ++++
 drivers/media/pci/intel/ipu.h                 |  118 +
 drivers/media/pci/intel/ipu6/Makefile         |   61 +
 .../media/pci/intel/ipu6/ipu-fw-resources.c   |  103 +
 .../intel/ipu6/ipu-platform-buttress-regs.h   |  329 ++
 .../intel/ipu6/ipu-platform-isys-csi2-reg.h   |  279 +
 .../media/pci/intel/ipu6/ipu-platform-isys.h  |   29 +
 .../media/pci/intel/ipu6/ipu-platform-psys.h  |   78 +
 .../media/pci/intel/ipu6/ipu-platform-regs.h  |  348 ++
 .../pci/intel/ipu6/ipu-platform-resources.h   |  103 +
 drivers/media/pci/intel/ipu6/ipu-platform.h   |   43 +
 drivers/media/pci/intel/ipu6/ipu-resources.c  |  868 +++
 .../media/pci/intel/ipu6/ipu6-fw-resources.c  |  609 +++
 drivers/media/pci/intel/ipu6/ipu6-isys-csi2.c |  654 +++
 drivers/media/pci/intel/ipu6/ipu6-isys-csi2.h |   14 +
 .../media/pci/intel/ipu6/ipu6-isys-dwc-phy.c  |  465 ++
 .../media/pci/intel/ipu6/ipu6-isys-dwc-phy.h  |   15 +
 drivers/media/pci/intel/ipu6/ipu6-isys-gpc.c  |  203 +
 drivers/media/pci/intel/ipu6/ipu6-isys-phy.c  |  667 +++
 drivers/media/pci/intel/ipu6/ipu6-isys-phy.h  |  164 +
 drivers/media/pci/intel/ipu6/ipu6-isys.c      |  190 +
 .../media/pci/intel/ipu6/ipu6-l-scheduler.c   |  615 +++
 .../pci/intel/ipu6/ipu6-platform-resources.h  |  196 +
 drivers/media/pci/intel/ipu6/ipu6-ppg.c       |  560 ++
 drivers/media/pci/intel/ipu6/ipu6-ppg.h       |   38 +
 drivers/media/pci/intel/ipu6/ipu6-psys-gpc.c  |  210 +
 drivers/media/pci/intel/ipu6/ipu6-psys.c      | 1032 ++++
 drivers/media/pci/intel/ipu6/ipu6.c           |  334 ++
 .../pci/intel/ipu6/ipu6ep-fw-resources.c      |  393 ++
 .../intel/ipu6/ipu6ep-platform-resources.h    |   42 +
 .../pci/intel/ipu6/ipu6se-fw-resources.c      |  194 +
 .../intel/ipu6/ipu6se-platform-resources.h    |  103 +
 drivers/media/platform/intel/Makefile         |   18 +-
 .../media/platform/intel/ipu6-acpi-common.c   |  357 ++
 .../media/platform/intel/ipu6-acpi-pdata.c    |  888 +++
 drivers/media/platform/intel/ipu6-acpi.c      |  227 +
 .../media/platform/intel/ipu6-adlrvp-pdata.c  |  621 +++
 .../media/platform/intel/ipu6-tglrvp-pdata.c  |  638 +++
 include/media/ar0234.h                        |   24 +
 include/media/d4xx_pdata.h                    |   27 +
 include/media/imx390.h                        |   24 +
 include/media/ipu-acpi-pdata.h                |  103 +
 include/media/ipu-acpi.h                      |  205 +
 include/media/ipu-isys.h                      |   96 +
 include/media/lt6911uxc.h                     |   24 +
 include/media/ti960.h                         |  110 +
 include/media/ti964.h                         |   71 +
 106 files changed, 60224 insertions(+), 1893 deletions(-)
 create mode 100644 drivers/media/i2c/ar0234.c
 create mode 100644 drivers/media/i2c/d4xx.c
 create mode 100644 drivers/media/i2c/hm11b1.c
 create mode 100644 drivers/media/i2c/imx390-mode-1280x960-CROP.h
 create mode 100644 drivers/media/i2c/imx390.c
 create mode 100644 drivers/media/i2c/imx390_mode_1920x1200HDR3_CUST_PWL12.h
 create mode 100644 drivers/media/i2c/lt6911uxc.c
 create mode 100644 drivers/media/i2c/ov01a10.c
 create mode 100644 drivers/media/i2c/ov01a1s.c
 create mode 100644 drivers/media/i2c/ov02c10.c
 create mode 100644 drivers/media/i2c/ov13858_intel.c
 create mode 100644 drivers/media/i2c/power_ctrl_logic.c
 create mode 100644 drivers/media/i2c/power_ctrl_logic.h
 create mode 100644 drivers/media/i2c/ti953-ser.c
 create mode 100644 drivers/media/i2c/ti953.h
 create mode 100644 drivers/media/i2c/ti960-des.c
 create mode 100644 drivers/media/i2c/ti960-reg.h
 create mode 100644 drivers/media/i2c/ti964-reg.h
 create mode 100644 drivers/media/i2c/ti964.c
 create mode 100644 drivers/media/pci/intel/ipu-bus.c
 create mode 100644 drivers/media/pci/intel/ipu-bus.h
 create mode 100644 drivers/media/pci/intel/ipu-buttress.c
 create mode 100644 drivers/media/pci/intel/ipu-buttress.h
 create mode 100644 drivers/media/pci/intel/ipu-cpd.c
 create mode 100644 drivers/media/pci/intel/ipu-cpd.h
 create mode 100644 drivers/media/pci/intel/ipu-dma.c
 create mode 100644 drivers/media/pci/intel/ipu-dma.h
 create mode 100644 drivers/media/pci/intel/ipu-fw-com.c
 create mode 100644 drivers/media/pci/intel/ipu-fw-com.h
 create mode 100644 drivers/media/pci/intel/ipu-fw-isys.c
 create mode 100644 drivers/media/pci/intel/ipu-fw-isys.h
 create mode 100644 drivers/media/pci/intel/ipu-fw-psys.c
 create mode 100644 drivers/media/pci/intel/ipu-fw-psys.h
 create mode 100644 drivers/media/pci/intel/ipu-isys-csi2-be-soc.c
 create mode 100644 drivers/media/pci/intel/ipu-isys-csi2-be.c
 create mode 100644 drivers/media/pci/intel/ipu-isys-csi2-be.h
 create mode 100644 drivers/media/pci/intel/ipu-isys-csi2.c
 create mode 100644 drivers/media/pci/intel/ipu-isys-csi2.h
 create mode 100644 drivers/media/pci/intel/ipu-isys-media.h
 create mode 100644 drivers/media/pci/intel/ipu-isys-queue.c
 create mode 100644 drivers/media/pci/intel/ipu-isys-queue.h
 create mode 100644 drivers/media/pci/intel/ipu-isys-subdev.c
 create mode 100644 drivers/media/pci/intel/ipu-isys-subdev.h
 create mode 100644 drivers/media/pci/intel/ipu-isys-tpg.c
 create mode 100644 drivers/media/pci/intel/ipu-isys-tpg.h
 create mode 100644 drivers/media/pci/intel/ipu-isys-video.c
 create mode 100644 drivers/media/pci/intel/ipu-isys-video.h
 create mode 100644 drivers/media/pci/intel/ipu-isys.c
 create mode 100644 drivers/media/pci/intel/ipu-isys.h
 create mode 100644 drivers/media/pci/intel/ipu-mmu.c
 create mode 100644 drivers/media/pci/intel/ipu-mmu.h
 create mode 100644 drivers/media/pci/intel/ipu-pdata.h
 create mode 100644 drivers/media/pci/intel/ipu-psys-compat32.c
 create mode 100644 drivers/media/pci/intel/ipu-psys.c
 create mode 100644 drivers/media/pci/intel/ipu-psys.h
 create mode 100644 drivers/media/pci/intel/ipu-trace.c
 create mode 100644 drivers/media/pci/intel/ipu-trace.h
 create mode 100644 drivers/media/pci/intel/ipu.c
 create mode 100644 drivers/media/pci/intel/ipu.h
 create mode 100644 drivers/media/pci/intel/ipu6/Makefile
 create mode 100644 drivers/media/pci/intel/ipu6/ipu-fw-resources.c
 create mode 100644 drivers/media/pci/intel/ipu6/ipu-platform-buttress-regs.h
 create mode 100644 drivers/media/pci/intel/ipu6/ipu-platform-isys-csi2-reg.h
 create mode 100644 drivers/media/pci/intel/ipu6/ipu-platform-isys.h
 create mode 100644 drivers/media/pci/intel/ipu6/ipu-platform-psys.h
 create mode 100644 drivers/media/pci/intel/ipu6/ipu-platform-regs.h
 create mode 100644 drivers/media/pci/intel/ipu6/ipu-platform-resources.h
 create mode 100644 drivers/media/pci/intel/ipu6/ipu-platform.h
 create mode 100644 drivers/media/pci/intel/ipu6/ipu-resources.c
 create mode 100644 drivers/media/pci/intel/ipu6/ipu6-fw-resources.c
 create mode 100644 drivers/media/pci/intel/ipu6/ipu6-isys-csi2.c
 create mode 100644 drivers/media/pci/intel/ipu6/ipu6-isys-csi2.h
 create mode 100644 drivers/media/pci/intel/ipu6/ipu6-isys-dwc-phy.c
 create mode 100644 drivers/media/pci/intel/ipu6/ipu6-isys-dwc-phy.h
 create mode 100644 drivers/media/pci/intel/ipu6/ipu6-isys-gpc.c
 create mode 100644 drivers/media/pci/intel/ipu6/ipu6-isys-phy.c
 create mode 100644 drivers/media/pci/intel/ipu6/ipu6-isys-phy.h
 create mode 100644 drivers/media/pci/intel/ipu6/ipu6-isys.c
 create mode 100644 drivers/media/pci/intel/ipu6/ipu6-l-scheduler.c
 create mode 100644 drivers/media/pci/intel/ipu6/ipu6-platform-resources.h
 create mode 100644 drivers/media/pci/intel/ipu6/ipu6-ppg.c
 create mode 100644 drivers/media/pci/intel/ipu6/ipu6-ppg.h
 create mode 100644 drivers/media/pci/intel/ipu6/ipu6-psys-gpc.c
 create mode 100644 drivers/media/pci/intel/ipu6/ipu6-psys.c
 create mode 100644 drivers/media/pci/intel/ipu6/ipu6.c
 create mode 100644 drivers/media/pci/intel/ipu6/ipu6ep-fw-resources.c
 create mode 100644 drivers/media/pci/intel/ipu6/ipu6ep-platform-resources.h
 create mode 100644 drivers/media/pci/intel/ipu6/ipu6se-fw-resources.c
 create mode 100644 drivers/media/pci/intel/ipu6/ipu6se-platform-resources.h
 create mode 100644 drivers/media/platform/intel/ipu6-acpi-common.c
 create mode 100644 drivers/media/platform/intel/ipu6-acpi-pdata.c
 create mode 100644 drivers/media/platform/intel/ipu6-acpi.c
 create mode 100644 drivers/media/platform/intel/ipu6-adlrvp-pdata.c
 create mode 100644 drivers/media/platform/intel/ipu6-tglrvp-pdata.c
 create mode 100644 include/media/ar0234.h
 create mode 100644 include/media/d4xx_pdata.h
 create mode 100644 include/media/imx390.h
 create mode 100644 include/media/ipu-acpi-pdata.h
 create mode 100644 include/media/ipu-acpi.h
 create mode 100644 include/media/ipu-isys.h
 create mode 100644 include/media/lt6911uxc.h
 create mode 100644 include/media/ti960.h
 create mode 100644 include/media/ti964.h

Index: b/drivers/media/i2c/ar0234.c
===================================================================
--- /dev/null
+++ b/drivers/media/i2c/ar0234.c
@@ -0,0 +1,2395 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (c) 2022 Intel Corporation.
+
+#include <asm/unaligned.h>
+#include <linux/acpi.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/gpio.h>
+#include <linux/version.h>
+#include <linux/interrupt.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-fwnode.h>
+#include <media/ar0234.h>
+#include <linux/version.h>
+
+#include <linux/ipu-isys.h>
+
+#define AR0234_REG_VALUE_08BIT		1
+#define AR0234_REG_VALUE_16BIT		2
+
+#define AR0234_LINK_FREQ_360MHZ		360000000ULL
+#define AR0234_LINK_FREQ_300MHZ		300000000ULL
+#define AR0234_LINK_FREQ_288MHZ		288000000ULL
+#define AR0234_LINK_FREQ_240MHZ		240000000ULL
+#define AR0234_LINK_FREQ_22_5MHZ	22500000ULL
+
+#define FSERIAL_CLK_4_LANE		240000000ULL
+#define FSERIAL_CLK_2_LANE		180000000ULL /* use as pixel rate */
+
+#define PIX_CLK_4_LANE			60000000ULL
+#define PIX_CLK_2_LANE			45000000ULL
+
+#define AR0234_REG_CHIP_ID		0x3000
+#define AR0234_CHIP_ID			0x0A56
+
+#define AR0234_REG_MODE_SELECT		0x301A
+#define AR0234_MODE_STANDBY		0x2058
+#define AR0234_MODE_STREAMING		0x205C
+
+/* vertical-timings from sensor */
+#define AR0234_REG_VTS			0x300A
+#define AR0234_VTS_MAX			0xffff
+
+/* Exposure controls from sensor */
+#define AR0234_REG_EXPOSURE		0x3012
+#define	AR0234_EXPOSURE_MIN		0
+#define AR0234_EXPOSURE_MAX_MARGIN	80
+#define	AR0234_EXPOSURE_STEP		1
+
+/* Analog gain controls from sensor */
+#define AR0234_REG_ANALOG_GAIN		0x3060
+#define	AR0234_ANAL_GAIN_MIN		0
+#define	AR0234_ANAL_GAIN_MAX		0x7f
+#define	AR0234_ANAL_GAIN_STEP		1
+#define	AR0234_ANAL_GAIN_DEFAULT	0xe
+
+/* Digital gain controls from sensor */
+#define AR0234_REG_GLOBAL_GAIN		0x305E
+#define AR0234_DGTL_GAIN_MIN		0
+#define AR0234_DGTL_GAIN_MAX		0x7ff
+#define AR0234_DGTL_GAIN_STEP		1
+#define AR0234_DGTL_GAIN_DEFAULT	0x80
+
+#define AR0234_REG_LED_FLASH_CONTROL	0x3270
+#define AR0234_LED_FLASH_EN		0x100
+#define AR0234_LED_DELAY		0xff
+
+#define AR0234_REG_IMAGE_ORIENTATION	0x301D
+#define AR0234_HFLIP_BIT		0x0
+#define AR0234_VFLIP_BIT		0x1
+
+#define WIN_WIDTH	1280
+#define WIN_HEIGHT	960
+
+#define AR0234_CID_CSI_PORT         (V4L2_CID_USER_BASE | 0x1001)
+#define AR0234_CID_I2C_BUS         (V4L2_CID_USER_BASE | 0x1002)
+#define AR0234_CID_I2C_ID         (V4L2_CID_USER_BASE | 0x1003)
+#define AR0234_CID_I2C_SLAVE_ADDRESS         (V4L2_CID_USER_BASE | 0x1004)
+#define AR0234_CID_FPS         (V4L2_CID_USER_BASE | 0x1005)
+#define AR0234_CID_FRAME_INTERVAL	(V4L2_CID_USER_BASE | 0x1006)
+
+#define to_ar0234(_sd)			container_of(_sd, struct ar0234, sd)
+
+enum {
+	AR0234_LINK_FREQ_360MBPS,
+	AR0234_LINK_FREQ_300MBPS,
+	AR0234_LINK_FREQ_288MBPS,
+	AR0234_LINK_FREQ_240MBPS,
+	AR0234_LINK_FREQ_22_5MBPS,
+};
+
+struct ar0234_reg {
+	u16 address;
+	u16 val;
+};
+
+struct ar0234_reg_list {
+	u32 num_of_regs;
+	const struct ar0234_reg *regs;
+};
+
+struct ar0234_link_freq_config {
+	const struct ar0234_reg_list reg_list;
+};
+
+struct ar0234_mode {
+	/* Frame width in pixels */
+	u32 width;
+
+	/* Frame height in pixels */
+	u32 height;
+
+	/* Horizontal timining size */
+	u32 hts;
+
+	/* Default vertical timining size */
+	u32 vts_def;
+
+	/* Min vertical timining size */
+	u32 vts_min;
+
+	/* Link frequency needed for this resolution */
+	u32 link_freq_index;
+
+	/* MEDIA_BUS_FMT */
+	u32 code;
+
+	/* MIPI_LANES */
+	s32 lanes;
+
+	/* MODE_FPS*/
+	u32 fps;
+
+	/* bit per pixel */
+	u32 bpp;
+
+	/* Sensor register settings for this resolution */
+	const struct ar0234_reg_list reg_list;
+};
+
+static const struct ar0234_reg freq_1280x960_10bit_4lane_300M[] = {
+	{0x302A, 0x0005},
+	{0x302C, 0x0002},
+	{0x302E, 0x0009},
+	{0x3030, 0x00C8},
+	{0x3036, 0x000A},
+	{0x3038, 0x0002},
+	{0x31B0, 0x005C},
+	{0x31B2, 0x0046},
+	{0x31B4, 0x31C6},
+	{0x31B6, 0x2190},
+	{0x31B8, 0x6049},
+	{0x31BA, 0x0208},
+	{0x31BC, 0x8A06},
+	{0x31AE, 0x0204},
+	{0x3002, 0x0080},
+	{0x3004, 0x0148},
+	{0x3006, 0x043F},
+	{0x3008, 0x0647},
+	{0x300A, 0x0983},
+	{0x300C, 0x0268},
+	{0x3012, 0x093E},
+	{0x31AC, 0x0A0A},
+	{0x306E, 0x9010},
+	{0x30A2, 0x0001},
+	{0x30A6, 0x0001},
+	{0x3082, 0x0003},
+	{0x3040, 0x0000},
+	{0x31D0, 0x0000},
+};
+
+static const struct ar0234_reg freq_1280x960_8bit_4lane_240M[] = {
+	{0x302A, 0x0008},
+	{0x302C, 0x0001},
+	{0x302E, 0x0009},
+	{0x3030, 0x00A0},
+	{0x3036, 0x0008},
+	{0x3038, 0x0002},
+	{0x31B0, 0x005B},
+	{0x31B2, 0x0046},
+	{0x31B4, 0x1206},
+	{0x31B6, 0x2193},
+	{0x31B8, 0x604B},
+	{0x31BA, 0x0188},
+	{0x31BC, 0x8A06},
+	{0x31AE, 0x0204},
+	{0x3002, 0x0080},
+	{0x3004, 0x0148},
+	{0x3006, 0x043F},
+	{0x3008, 0x0647},
+	{0x300A, 0x0983},
+	{0x300C, 0x0268},
+	{0x3012, 0x093E},
+	{0x31AC, 0x0A08},
+	{0x306E, 0x9010},
+	{0x30A2, 0x0001},
+	{0x30A6, 0x0001},
+	{0x3082, 0x0003},
+	{0x3040, 0x0000},
+	{0x31D0, 0x0000},
+	{0x3354, 0x002a},
+	{0x3354, 0x002a},
+	{0x3354, 0x002a},
+};
+
+static const struct ar0234_reg freq_1280x960_10bit_2lane_360M[] = {
+	{0x302A, 0x0005},
+	{0x302C, 0x0004},
+	{0x302E, 0x0003},
+	{0x3030, 0x0050},
+	{0x3036, 0x000A},
+	{0x3038, 0x0002},
+	{0x31B0, 0x006E},
+	{0x31B2, 0x0050},
+	{0x31B4, 0x4207},
+	{0x31B6, 0x2213},
+	{0x31B8, 0x704A},
+	{0x31BA, 0x0289},
+	{0x31BC, 0x8C08},
+	{0x31AE, 0x0202},
+	{0x3002, 0x0080},
+	{0x3004, 0x0148},
+	{0x3006, 0x043F},
+	{0x3008, 0x0647},
+	{0x300A, 0x05B5},
+	{0x300C, 0x0268},
+	{0x3012, 0x058C},
+	{0x31AC, 0x0A0A},
+	{0x306E, 0x9010},
+	{0x30A2, 0x0001},
+	{0x30A6, 0x0001},
+	{0x3082, 0x0003},
+	{0x3040, 0x0000},
+	{0x31D0, 0x0000},
+};
+
+static const struct ar0234_reg freq_1280x960_8bit_2lane_288M[] = {
+	{0x302A, 0x0008},
+	{0x302C, 0x0002},
+	{0x302E, 0x0003},
+	{0x3030, 0x0040},
+	{0x3036, 0x0008},
+	{0x3038, 0x0002},
+	{0x31B0, 0x006A},
+	{0x31B2, 0x004F},
+	{0x31B4, 0x1207},
+	{0x31B6, 0x2216},
+	{0x31B8, 0x704B},
+	{0x31BA, 0x0209},
+	{0x31BC, 0x8C08},
+	{0x31AE, 0x0202},
+	{0x3002, 0x0080},
+	{0x3004, 0x0148},
+	{0x3006, 0x043F},
+	{0x3008, 0x0647},
+	{0x300A, 0x05B5},
+	{0x300C, 0x0268},
+	{0x3012, 0x058C},
+	{0x31AC, 0x0A08},
+	{0x306E, 0x9010},
+	{0x30A2, 0x0001},
+	{0x30A6, 0x0001},
+	{0x3082, 0x0003},
+	{0x3040, 0x0000},
+	{0x31D0, 0x0000},
+	{0x3354, 0x002a},
+	{0x3354, 0x002a},
+	{0x3354, 0x002a},
+};
+
+static const struct ar0234_reg freq_1920x1200_10bit_2lane_22_5M[] = {
+{0x302A, 0x0005},		//VT_PIX_CLK_DIV = 5
+{0x302C, 0x0002},		//VT_SYS_CLK_DIV = 2
+{0x302E, 0x0003},		//PRE_PLL_CLK_DIV = 3
+{0x3030, 0x0032},		//PLL_MULTIPLIER = 50
+{0x3036, 0x000A},		//OP_PIX_CLK_DIV = 10
+{0x3038, 0x0002},		//OP_SYS_CLK_DIV = 2
+{0x31B0, 0x004C},		//FRAME_PREAMBLE = 76
+{0x31B2, 0x003C},		//LINE_PREAMBLE = 60
+{0x31B4, 0x31C5},		//MIPI_TIMING_0 = 12741
+{0x31B6, 0x214C},		//MIPI_TIMING_1 = 8524
+{0x31B8, 0x5048},		//MIPI_TIMING_2 = 20552
+{0x31BA, 0x0186},		//MIPI_TIMING_3 = 390
+{0x31BC, 0x0805},		//MIPI_TIMING_4 = 2053
+{0x3354, 0x002B},		//MIPI_CNTRL = 43
+
+{0x301A, 0x2058},		//RESET_REGISTER = 8280
+{0x31AE, 0x0202},		//SERIAL_FORMAT = 514
+{0x3002, 0x0008},		//Y_ADDR_START = 8
+{0x3004, 0x0008},		//X_ADDR_START = 8
+{0x3006, 0x04B7},		//Y_ADDR_END = 1207
+{0x3008, 0x0787},		//X_ADDR_END = 1927
+{0x300A, 0x04C4},		//FRAME_LENGTH_LINES = 1220
+{0x300C, 0x0264},		//LINE_LENGTH_PCK = 612
+{0x3012, 0x0024},		//COARSE_INTEGRATION_TIME = 36
+{0x31AC, 0x0A0A},		//DATA_FORMAT_BITS = 2570
+{0x306E, 0x9010},		//DATAPATH_SELECT = 36880
+{0x30A2, 0x0001},		//X_ODD_INC = 1
+{0x30A6, 0x0001},		//Y_ODD_INC = 1
+{0x3082, 0x0003},		//OPERATION_MODE_CTRL = 3
+{0x3040, 0x0000},		//READ_MODE = 0
+{0x31D0, 0x0000},		//COMPANDING = 0
+{0x301A, 0x205C},		//RESET_REGISTER = 8284
+};
+
+static const struct ar0234_reg mode_1280x960_8bit_4lane[] = {
+	// Reset {
+	{0x301a, 0x00d9},
+	{0x0000, 0x00c8},
+	//		1D-DDC_Parameters {
+	{0x3F4C, 0x121F},
+	{0x3F4E, 0x121F},
+	{0x3F50, 0x0B81},
+	{0x0000, 0x00c8},
+	//		1D-DDC_Parameters }
+	// Reset }
+	// AR0234CS REV2 Sequencer-brt_spots_ablo_gnd_11feb19 {
+	{0x3088, 0x8000},
+	{0x3086, 0xC1AE},
+	{0x3086, 0x327F},
+	{0x3086, 0x5780},
+	{0x3086, 0x272F},
+	{0x3086, 0x7416},
+	{0x3086, 0x7E13},
+	{0x3086, 0x8000},
+	{0x3086, 0x307E},
+	{0x3086, 0xFF80},
+	{0x3086, 0x20C3},
+	{0x3086, 0xB00E},
+	{0x3086, 0x8190},
+	{0x3086, 0x1643},
+	{0x3086, 0x1651},
+	{0x3086, 0x9D3E},
+	{0x3086, 0x9545},
+	{0x3086, 0x2209},
+	{0x3086, 0x3781},
+	{0x3086, 0x9016},
+	{0x3086, 0x4316},
+	{0x3086, 0x7F90},
+	{0x3086, 0x8000},
+	{0x3086, 0x387F},
+	{0x3086, 0x1380},
+	{0x3086, 0x233B},
+	{0x3086, 0x7F93},
+	{0x3086, 0x4502},
+	{0x3086, 0x8000},
+	{0x3086, 0x7FB0},
+	{0x3086, 0x8D66},
+	{0x3086, 0x7F90},
+	{0x3086, 0x8192},
+	{0x3086, 0x3C16},
+	{0x3086, 0x357F},
+	{0x3086, 0x9345},
+	{0x3086, 0x0280},
+	{0x3086, 0x007F},
+	{0x3086, 0xB08D},
+	{0x3086, 0x667F},
+	{0x3086, 0x9081},
+	{0x3086, 0x8237},
+	{0x3086, 0x4502},
+	{0x3086, 0x3681},
+	{0x3086, 0x8044},
+	{0x3086, 0x1631},
+	{0x3086, 0x4374},
+	{0x3086, 0x1678},
+	{0x3086, 0x7B7D},
+	{0x3086, 0x4502},
+	{0x3086, 0x450A},
+	{0x3086, 0x7E12},
+	{0x3086, 0x8180},
+	{0x3086, 0x377F},
+	{0x3086, 0x1045},
+	{0x3086, 0x0A0E},
+	{0x3086, 0x7FD4},
+	{0x3086, 0x8024},
+	{0x3086, 0x0E82},
+	{0x3086, 0x9CC2},
+	{0x3086, 0xAFA8},
+	{0x3086, 0xAA03},
+	{0x3086, 0x430D},
+	{0x3086, 0x2D46},
+	{0x3086, 0x4316},
+	{0x3086, 0x5F16},
+	{0x3086, 0x530D},
+	{0x3086, 0x1660},
+	{0x3086, 0x401E},
+	{0x3086, 0x2904},
+	{0x3086, 0x2984},
+	{0x3086, 0x81E7},
+	{0x3086, 0x816F},
+	{0x3086, 0x1706},
+	{0x3086, 0x81E7},
+	{0x3086, 0x7F81},
+	{0x3086, 0x5C0D},
+	{0x3086, 0x5754},
+	{0x3086, 0x495F},
+	{0x3086, 0x5305},
+	{0x3086, 0x5307},
+	{0x3086, 0x4D2B},
+	{0x3086, 0xF810},
+	{0x3086, 0x164C},
+	{0x3086, 0x0755},
+	{0x3086, 0x562B},
+	{0x3086, 0xB82B},
+	{0x3086, 0x984E},
+	{0x3086, 0x1129},
+	{0x3086, 0x9460},
+	{0x3086, 0x5C09},
+	{0x3086, 0x5C1B},
+	{0x3086, 0x4002},
+	{0x3086, 0x4500},
+	{0x3086, 0x4580},
+	{0x3086, 0x29B6},
+	{0x3086, 0x7F80},
+	{0x3086, 0x4004},
+	{0x3086, 0x7F88},
+	{0x3086, 0x4109},
+	{0x3086, 0x5C0B},
+	{0x3086, 0x29B2},
+	{0x3086, 0x4115},
+	{0x3086, 0x5C03},
+	{0x3086, 0x4105},
+	{0x3086, 0x5F2B},
+	{0x3086, 0x902B},
+	{0x3086, 0x8081},
+	{0x3086, 0x6F40},
+	{0x3086, 0x1041},
+	{0x3086, 0x0160},
+	{0x3086, 0x29A2},
+	{0x3086, 0x29A3},
+	{0x3086, 0x5F4D},
+	{0x3086, 0x1C17},
+	{0x3086, 0x0281},
+	{0x3086, 0xE729},
+	{0x3086, 0x8345},
+	{0x3086, 0x8840},
+	{0x3086, 0x0F7F},
+	{0x3086, 0x8A40},
+	{0x3086, 0x2345},
+	{0x3086, 0x8024},
+	{0x3086, 0x4008},
+	{0x3086, 0x7F88},
+	{0x3086, 0x5D29},
+	{0x3086, 0x9288},
+	{0x3086, 0x102B},
+	{0x3086, 0x0489},
+	{0x3086, 0x165C},
+	{0x3086, 0x4386},
+	{0x3086, 0x170B},
+	{0x3086, 0x5C03},
+	{0x3086, 0x8A48},
+	{0x3086, 0x4D4E},
+	{0x3086, 0x2B80},
+	{0x3086, 0x4C09},
+	{0x3086, 0x4119},
+	{0x3086, 0x816F},
+	{0x3086, 0x4110},
+	{0x3086, 0x4001},
+	{0x3086, 0x6029},
+	{0x3086, 0x8229},
+	{0x3086, 0x8329},
+	{0x3086, 0x435C},
+	{0x3086, 0x055F},
+	{0x3086, 0x4D1C},
+	{0x3086, 0x81E7},
+	{0x3086, 0x4502},
+	{0x3086, 0x8180},
+	{0x3086, 0x7F80},
+	{0x3086, 0x410A},
+	{0x3086, 0x9144},
+	{0x3086, 0x1609},
+	{0x3086, 0x2FC3},
+	{0x3086, 0xB130},
+	{0x3086, 0xC3B1},
+	{0x3086, 0x0343},
+	{0x3086, 0x164A},
+	{0x3086, 0x0A43},
+	{0x3086, 0x160B},
+	{0x3086, 0x4316},
+	{0x3086, 0x8F43},
+	{0x3086, 0x1690},
+	{0x3086, 0x4316},
+	{0x3086, 0x7F81},
+	{0x3086, 0x450A},
+	{0x3086, 0x410F},
+	{0x3086, 0x7F83},
+	{0x3086, 0x5D29},
+	{0x3086, 0x4488},
+	{0x3086, 0x102B},
+	{0x3086, 0x0453},
+	{0x3086, 0x0D40},
+	{0x3086, 0x2345},
+	{0x3086, 0x0240},
+	{0x3086, 0x087F},
+	{0x3086, 0x8053},
+	{0x3086, 0x0D89},
+	{0x3086, 0x165C},
+	{0x3086, 0x4586},
+	{0x3086, 0x170B},
+	{0x3086, 0x5C05},
+	{0x3086, 0x8A60},
+	{0x3086, 0x4B91},
+	{0x3086, 0x4416},
+	{0x3086, 0x09C1},
+	{0x3086, 0x2CA9},
+	{0x3086, 0xAB30},
+	{0x3086, 0x51B3},
+	{0x3086, 0x3D5A},
+	{0x3086, 0x7E3D},
+	{0x3086, 0x7E19},
+	{0x3086, 0x8000},
+	{0x3086, 0x8B1F},
+	{0x3086, 0x2A1F},
+	{0x3086, 0x83A2},
+	{0x3086, 0x7516},
+	{0x3086, 0xAD33},
+	{0x3086, 0x450A},
+	{0x3086, 0x7F53},
+	{0x3086, 0x8023},
+	{0x3086, 0x8C66},
+	{0x3086, 0x7F13},
+	{0x3086, 0x8184},
+	{0x3086, 0x1481},
+	{0x3086, 0x8031},
+	{0x3086, 0x3D64},
+	{0x3086, 0x452A},
+	{0x3086, 0x9451},
+	{0x3086, 0x9E96},
+	{0x3086, 0x3D2B},
+	{0x3086, 0x3D1B},
+	{0x3086, 0x529F},
+	{0x3086, 0x0E3D},
+	{0x3086, 0x083D},
+	{0x3086, 0x167E},
+	{0x3086, 0x307E},
+	{0x3086, 0x1175},
+	{0x3086, 0x163E},
+	{0x3086, 0x970E},
+	{0x3086, 0x82B2},
+	{0x3086, 0x3D7F},
+	{0x3086, 0xAC3E},
+	{0x3086, 0x4502},
+	{0x3086, 0x7E11},
+	{0x3086, 0x7FD0},
+	{0x3086, 0x8000},
+	{0x3086, 0x8C66},
+	{0x3086, 0x7F90},
+	{0x3086, 0x8194},
+	{0x3086, 0x3F44},
+	{0x3086, 0x1681},
+	{0x3086, 0x8416},
+	{0x3086, 0x2C2C},
+	{0x3086, 0x2C2C},
+	// AR0234CS REV2 Sequencer-brt_spots_ablo_gnd_11feb19 }
+	// RECOMMENDED_SETTINGS-Pxlclk90MHz {
+	{0x3044, 0x0410},
+	{0x3094, 0x03D4},
+	{0x3096, 0x0480},
+	{0x30BA, 0x7602},
+	{0x30FE, 0x002A},
+	{0x31DE, 0x0410},
+	{0x3ED6, 0x1435},
+	{0x3ED8, 0x9865},
+	{0x3EDA, 0x7698},
+	{0x3EDC, 0x99FF},
+	{0x3EE2, 0xBB88},
+	{0x3EE4, 0x8836},
+	{0x3EF0, 0x1CF0},
+	{0x3EF2, 0x0000},
+	{0x3EF8, 0x6166},
+	{0x3EFA, 0x3333},
+	{0x3EFC, 0x6634},
+	{0x3276, 0x05DC},
+	{0x3F00, 0x9D05},
+	{0x3EEE, 0xA4FE},
+	{0x30BA, 0x7602},
+	//		Rowbanding_Settings {
+	{0x3EEC, 0x0C0C},
+	{0x3EE8, 0xAAE4},
+	//		Rowbanding_Settings }
+	//		Gain Table 90MHz {
+	//		Gain Table 90MHz }
+	{0x3102, 0x5000},
+	//		AutoExposure Maximum Analog Gain 16x {
+	{0x3EEE, 0xA4AA},
+	//		AutoExposure Maximum Analog Gain 16x }
+	// RECOMMENDED_SETTINGS-Pxlclk90MHz }
+	{0x3270, 0x0100},
+	{0x3270, 0x0100},
+	{0x3270, 0x0100},
+};
+
+static const struct ar0234_reg mode_1280x960_10bit_2lane[] = {
+	{0x0000, 0x00C8},
+	{0x301A, 0x00D9},
+	{0x0000, 0x00C8},
+	{0x3F4C, 0x121F},
+	{0x3F4E, 0x121F},
+	{0x3F50, 0x0B81},
+	{0x31E0, 0x0003},
+	{0x31E0, 0x0003},
+	{0x30B0, 0x0028},
+	{0x0000, 0x00C8},
+	{0x3088, 0x8000},
+	{0x3086, 0xC1AE},
+	{0x3086, 0x327F},
+	{0x3086, 0x5780},
+	{0x3086, 0x272F},
+	{0x3086, 0x7416},
+	{0x3086, 0x7E13},
+	{0x3086, 0x8000},
+	{0x3086, 0x307E},
+	{0x3086, 0xFF80},
+	{0x3086, 0x20C3},
+	{0x3086, 0xB00E},
+	{0x3086, 0x8190},
+	{0x3086, 0x1643},
+	{0x3086, 0x1651},
+	{0x3086, 0x9D3E},
+	{0x3086, 0x9545},
+	{0x3086, 0x2209},
+	{0x3086, 0x3781},
+	{0x3086, 0x9016},
+	{0x3086, 0x4316},
+	{0x3086, 0x7F90},
+	{0x3086, 0x8000},
+	{0x3086, 0x387F},
+	{0x3086, 0x1380},
+	{0x3086, 0x233B},
+	{0x3086, 0x7F93},
+	{0x3086, 0x4502},
+	{0x3086, 0x8000},
+	{0x3086, 0x7FB0},
+	{0x3086, 0x8D66},
+	{0x3086, 0x7F90},
+	{0x3086, 0x8192},
+	{0x3086, 0x3C16},
+	{0x3086, 0x357F},
+	{0x3086, 0x9345},
+	{0x3086, 0x0280},
+	{0x3086, 0x007F},
+	{0x3086, 0xB08D},
+	{0x3086, 0x667F},
+	{0x3086, 0x9081},
+	{0x3086, 0x8237},
+	{0x3086, 0x4502},
+	{0x3086, 0x3681},
+	{0x3086, 0x8044},
+	{0x3086, 0x1631},
+	{0x3086, 0x4374},
+	{0x3086, 0x1678},
+	{0x3086, 0x7B7D},
+	{0x3086, 0x4502},
+	{0x3086, 0x450A},
+	{0x3086, 0x7E12},
+	{0x3086, 0x8180},
+	{0x3086, 0x377F},
+	{0x3086, 0x1045},
+	{0x3086, 0x0A0E},
+	{0x3086, 0x7FD4},
+	{0x3086, 0x8024},
+	{0x3086, 0x0E82},
+	{0x3086, 0x9CC2},
+	{0x3086, 0xAFA8},
+	{0x3086, 0xAA03},
+	{0x3086, 0x430D},
+	{0x3086, 0x2D46},
+	{0x3086, 0x4316},
+	{0x3086, 0x5F16},
+	{0x3086, 0x530D},
+	{0x3086, 0x1660},
+	{0x3086, 0x401E},
+	{0x3086, 0x2904},
+	{0x3086, 0x2984},
+	{0x3086, 0x81E7},
+	{0x3086, 0x816F},
+	{0x3086, 0x1706},
+	{0x3086, 0x81E7},
+	{0x3086, 0x7F81},
+	{0x3086, 0x5C0D},
+	{0x3086, 0x5754},
+	{0x3086, 0x495F},
+	{0x3086, 0x5305},
+	{0x3086, 0x5307},
+	{0x3086, 0x4D2B},
+	{0x3086, 0xF810},
+	{0x3086, 0x164C},
+	{0x3086, 0x0755},
+	{0x3086, 0x562B},
+	{0x3086, 0xB82B},
+	{0x3086, 0x984E},
+	{0x3086, 0x1129},
+	{0x3086, 0x9460},
+	{0x3086, 0x5C09},
+	{0x3086, 0x5C1B},
+	{0x3086, 0x4002},
+	{0x3086, 0x4500},
+	{0x3086, 0x4580},
+	{0x3086, 0x29B6},
+	{0x3086, 0x7F80},
+	{0x3086, 0x4004},
+	{0x3086, 0x7F88},
+	{0x3086, 0x4109},
+	{0x3086, 0x5C0B},
+	{0x3086, 0x29B2},
+	{0x3086, 0x4115},
+	{0x3086, 0x5C03},
+	{0x3086, 0x4105},
+	{0x3086, 0x5F2B},
+	{0x3086, 0x902B},
+	{0x3086, 0x8081},
+	{0x3086, 0x6F40},
+	{0x3086, 0x1041},
+	{0x3086, 0x0160},
+	{0x3086, 0x29A2},
+	{0x3086, 0x29A3},
+	{0x3086, 0x5F4D},
+	{0x3086, 0x1C17},
+	{0x3086, 0x0281},
+	{0x3086, 0xE729},
+	{0x3086, 0x8345},
+	{0x3086, 0x8840},
+	{0x3086, 0x0F7F},
+	{0x3086, 0x8A40},
+	{0x3086, 0x2345},
+	{0x3086, 0x8024},
+	{0x3086, 0x4008},
+	{0x3086, 0x7F88},
+	{0x3086, 0x5D29},
+	{0x3086, 0x9288},
+	{0x3086, 0x102B},
+	{0x3086, 0x0489},
+	{0x3086, 0x165C},
+	{0x3086, 0x4386},
+	{0x3086, 0x170B},
+	{0x3086, 0x5C03},
+	{0x3086, 0x8A48},
+	{0x3086, 0x4D4E},
+	{0x3086, 0x2B80},
+	{0x3086, 0x4C09},
+	{0x3086, 0x4119},
+	{0x3086, 0x816F},
+	{0x3086, 0x4110},
+	{0x3086, 0x4001},
+	{0x3086, 0x6029},
+	{0x3086, 0x8229},
+	{0x3086, 0x8329},
+	{0x3086, 0x435C},
+	{0x3086, 0x055F},
+	{0x3086, 0x4D1C},
+	{0x3086, 0x81E7},
+	{0x3086, 0x4502},
+	{0x3086, 0x8180},
+	{0x3086, 0x7F80},
+	{0x3086, 0x410A},
+	{0x3086, 0x9144},
+	{0x3086, 0x1609},
+	{0x3086, 0x2FC3},
+	{0x3086, 0xB130},
+	{0x3086, 0xC3B1},
+	{0x3086, 0x0343},
+	{0x3086, 0x164A},
+	{0x3086, 0x0A43},
+	{0x3086, 0x160B},
+	{0x3086, 0x4316},
+	{0x3086, 0x8F43},
+	{0x3086, 0x1690},
+	{0x3086, 0x4316},
+	{0x3086, 0x7F81},
+	{0x3086, 0x450A},
+	{0x3086, 0x410F},
+	{0x3086, 0x7F83},
+	{0x3086, 0x5D29},
+	{0x3086, 0x4488},
+	{0x3086, 0x102B},
+	{0x3086, 0x0453},
+	{0x3086, 0x0D40},
+	{0x3086, 0x2345},
+	{0x3086, 0x0240},
+	{0x3086, 0x087F},
+	{0x3086, 0x8053},
+	{0x3086, 0x0D89},
+	{0x3086, 0x165C},
+	{0x3086, 0x4586},
+	{0x3086, 0x170B},
+	{0x3086, 0x5C05},
+	{0x3086, 0x8A60},
+	{0x3086, 0x4B91},
+	{0x3086, 0x4416},
+	{0x3086, 0x09C1},
+	{0x3086, 0x2CA9},
+	{0x3086, 0xAB30},
+	{0x3086, 0x51B3},
+	{0x3086, 0x3D5A},
+	{0x3086, 0x7E3D},
+	{0x3086, 0x7E19},
+	{0x3086, 0x8000},
+	{0x3086, 0x8B1F},
+	{0x3086, 0x2A1F},
+	{0x3086, 0x83A2},
+	{0x3086, 0x7516},
+	{0x3086, 0xAD33},
+	{0x3086, 0x450A},
+	{0x3086, 0x7F53},
+	{0x3086, 0x8023},
+	{0x3086, 0x8C66},
+	{0x3086, 0x7F13},
+	{0x3086, 0x8184},
+	{0x3086, 0x1481},
+	{0x3086, 0x8031},
+	{0x3086, 0x3D64},
+	{0x3086, 0x452A},
+	{0x3086, 0x9451},
+	{0x3086, 0x9E96},
+	{0x3086, 0x3D2B},
+	{0x3086, 0x3D1B},
+	{0x3086, 0x529F},
+	{0x3086, 0x0E3D},
+	{0x3086, 0x083D},
+	{0x3086, 0x167E},
+	{0x3086, 0x307E},
+	{0x3086, 0x1175},
+	{0x3086, 0x163E},
+	{0x3086, 0x970E},
+	{0x3086, 0x82B2},
+	{0x3086, 0x3D7F},
+	{0x3086, 0xAC3E},
+	{0x3086, 0x4502},
+	{0x3086, 0x7E11},
+	{0x3086, 0x7FD0},
+	{0x3086, 0x8000},
+	{0x3086, 0x8C66},
+	{0x3086, 0x7F90},
+	{0x3086, 0x8194},
+	{0x3086, 0x3F44},
+	{0x3086, 0x1681},
+	{0x3086, 0x8416},
+	{0x3086, 0x2C2C},
+	{0x3086, 0x2C2C},
+	{0x302A, 0x0005},
+	{0x302C, 0x0001},
+	{0x302E, 0x0003},
+	{0x3030, 0x0032},
+	{0x3036, 0x000A},
+	{0x3038, 0x0001},
+	{0x30B0, 0x0028},
+	{0x31B0, 0x0082},
+	{0x31B2, 0x005C},
+	{0x31B4, 0x5248},
+	{0x31B6, 0x3257},
+	{0x31B8, 0x904B},
+	{0x31BA, 0x030B},
+	{0x31BC, 0x8E09},
+	{0x3354, 0x002B},
+	{0x31D0, 0x0000},
+	{0x31AE, 0x0204},
+	{0x3002, 0x00D0},
+	{0x3004, 0x0148},
+	{0x3006, 0x048F},
+	{0x3008, 0x0647},
+	{0x3064, 0x1802},
+	{0x300A, 0x04C4},
+	{0x300C, 0x04C4},
+	{0x30A2, 0x0001},
+	{0x30A6, 0x0001},
+	{0x3012, 0x010C},
+	{0x3786, 0x0006},
+	{0x31AE, 0x0202},
+	{0x3088, 0x8050},
+	{0x3086, 0x9237},
+	{0x3044, 0x0410},
+	{0x3094, 0x03D4},
+	{0x3096, 0x0280},
+	{0x30BA, 0x7606},
+	{0x30B0, 0x0028},
+	{0x30BA, 0x7600},
+	{0x30FE, 0x002A},
+	{0x31DE, 0x0410},
+	{0x3ED6, 0x1435},
+	{0x3ED8, 0x9865},
+	{0x3EDA, 0x7698},
+	{0x3EDC, 0x99FF},
+	{0x3EE2, 0xBB88},
+	{0x3EE4, 0x8836},
+	{0x3EF0, 0x1CF0},
+	{0x3EF2, 0x0000},
+	{0x3EF8, 0x6166},
+	{0x3EFA, 0x3333},
+	{0x3EFC, 0x6634},
+	{0x3088, 0x81BA},
+	{0x3086, 0x3D02},
+	{0x3276, 0x05DC},
+	{0x3F00, 0x9D05},
+	{0x3ED2, 0xFA86},
+	{0x3EEE, 0xA4FE},
+	{0x3ECC, 0x6E42},
+	{0x3ECC, 0x0E42},
+	{0x3EEC, 0x0C0C},
+	{0x3EE8, 0xAAE4},
+	{0x3EE6, 0x3363},
+	{0x3EE6, 0x3363},
+	{0x3EE8, 0xAAE4},
+	{0x3EE8, 0xAAE4},
+	{0x3180, 0xC24F},
+	{0x3102, 0x5000},
+	{0x3060, 0x000D},
+	{0x3ED0, 0xFF44},
+	{0x3ED2, 0xAA86},
+	{0x3ED4, 0x031F},
+	{0x3EEE, 0xA4AA},
+};
+
+static const struct ar0234_reg mode_1920x1200_10bit_2lane[] = {
+	{0x0000, 0x00c8},
+	{0x301A, 0x00D9}, // RESET_REGISTER
+	{0x0000, 0x00c8},
+	{0x3F4C, 0x121F}, // RESERVED_MFR_3F4C
+	{0x3F4E, 0x121F}, // RESERVED_MFR_3F4E
+	{0x3F50, 0x0B81}, // RESERVED_MFR_3F50
+	{0x31E0, 0x0003}, // PIX_DEF_ID
+	{0x31E0, 0x0003}, // PIX_DEF_ID
+	{0x30B0, 0x0028}, // DIGITAL_TEST
+	{0x0000, 0x00c8},
+	{0x3088, 0x8000}, // SEQ_CTRL_PORT
+	{0x3086, 0xC1AE}, // SEQ_DATA_PORT
+	{0x3086, 0x327F}, // SEQ_DATA_PORT
+	{0x3086, 0x5780}, // SEQ_DATA_PORT
+	{0x3086, 0x272F}, // SEQ_DATA_PORT
+	{0x3086, 0x7416}, // SEQ_DATA_PORT
+	{0x3086, 0x7E13}, // SEQ_DATA_PORT
+	{0x3086, 0x8000}, // SEQ_DATA_PORT
+	{0x3086, 0x307E}, // SEQ_DATA_PORT
+	{0x3086, 0xFF80}, // SEQ_DATA_PORT
+	{0x3086, 0x20C3}, // SEQ_DATA_PORT
+	{0x3086, 0xB00E}, // SEQ_DATA_PORT
+	{0x3086, 0x8190}, // SEQ_DATA_PORT
+	{0x3086, 0x1643}, // SEQ_DATA_PORT
+	{0x3086, 0x1651}, // SEQ_DATA_PORT
+	{0x3086, 0x9D3E}, // SEQ_DATA_PORT
+	{0x3086, 0x9545}, // SEQ_DATA_PORT
+	{0x3086, 0x2209}, // SEQ_DATA_PORT
+	{0x3086, 0x3781}, // SEQ_DATA_PORT
+	{0x3086, 0x9016}, // SEQ_DATA_PORT
+	{0x3086, 0x4316}, // SEQ_DATA_PORT
+	{0x3086, 0x7F90}, // SEQ_DATA_PORT
+	{0x3086, 0x8000}, // SEQ_DATA_PORT
+	{0x3086, 0x387F}, // SEQ_DATA_PORT
+	{0x3086, 0x1380}, // SEQ_DATA_PORT
+	{0x3086, 0x233B}, // SEQ_DATA_PORT
+	{0x3086, 0x7F93}, // SEQ_DATA_PORT
+	{0x3086, 0x4502}, // SEQ_DATA_PORT
+	{0x3086, 0x8000}, // SEQ_DATA_PORT
+	{0x3086, 0x7FB0}, // SEQ_DATA_PORT
+	{0x3086, 0x8D66}, // SEQ_DATA_PORT
+	{0x3086, 0x7F90}, // SEQ_DATA_PORT
+	{0x3086, 0x8192}, // SEQ_DATA_PORT
+	{0x3086, 0x3C16}, // SEQ_DATA_PORT
+	{0x3086, 0x357F}, // SEQ_DATA_PORT
+	{0x3086, 0x9345}, // SEQ_DATA_PORT
+	{0x3086, 0x0280}, // SEQ_DATA_PORT
+	{0x3086, 0x007F}, // SEQ_DATA_PORT
+	{0x3086, 0xB08D}, // SEQ_DATA_PORT
+	{0x3086, 0x667F}, // SEQ_DATA_PORT
+	{0x3086, 0x9081}, // SEQ_DATA_PORT
+	{0x3086, 0x8237}, // SEQ_DATA_PORT
+	{0x3086, 0x4502}, // SEQ_DATA_PORT
+	{0x3086, 0x3681}, // SEQ_DATA_PORT
+	{0x3086, 0x8044}, // SEQ_DATA_PORT
+	{0x3086, 0x1631}, // SEQ_DATA_PORT
+	{0x3086, 0x4374}, // SEQ_DATA_PORT
+	{0x3086, 0x1678}, // SEQ_DATA_PORT
+	{0x3086, 0x7B7D}, // SEQ_DATA_PORT
+	{0x3086, 0x4502}, // SEQ_DATA_PORT
+	{0x3086, 0x450A}, // SEQ_DATA_PORT
+	{0x3086, 0x7E12}, // SEQ_DATA_PORT
+	{0x3086, 0x8180}, // SEQ_DATA_PORT
+	{0x3086, 0x377F}, // SEQ_DATA_PORT
+	{0x3086, 0x1045}, // SEQ_DATA_PORT
+	{0x3086, 0x0A0E}, // SEQ_DATA_PORT
+	{0x3086, 0x7FD4}, // SEQ_DATA_PORT
+	{0x3086, 0x8024}, // SEQ_DATA_PORT
+	{0x3086, 0x0E82}, // SEQ_DATA_PORT
+	{0x3086, 0x9CC2}, // SEQ_DATA_PORT
+	{0x3086, 0xAFA8}, // SEQ_DATA_PORT
+	{0x3086, 0xAA03}, // SEQ_DATA_PORT
+	{0x3086, 0x430D}, // SEQ_DATA_PORT
+	{0x3086, 0x2D46}, // SEQ_DATA_PORT
+	{0x3086, 0x4316}, // SEQ_DATA_PORT
+	{0x3086, 0x5F16}, // SEQ_DATA_PORT
+	{0x3086, 0x530D}, // SEQ_DATA_PORT
+	{0x3086, 0x1660}, // SEQ_DATA_PORT
+	{0x3086, 0x401E}, // SEQ_DATA_PORT
+	{0x3086, 0x2904}, // SEQ_DATA_PORT
+	{0x3086, 0x2984}, // SEQ_DATA_PORT
+	{0x3086, 0x81E7}, // SEQ_DATA_PORT
+	{0x3086, 0x816F}, // SEQ_DATA_PORT
+	{0x3086, 0x1706}, // SEQ_DATA_PORT
+	{0x3086, 0x81E7}, // SEQ_DATA_PORT
+	{0x3086, 0x7F81}, // SEQ_DATA_PORT
+	{0x3086, 0x5C0D}, // SEQ_DATA_PORT
+	{0x3086, 0x5754}, // SEQ_DATA_PORT
+	{0x3086, 0x495F}, // SEQ_DATA_PORT
+	{0x3086, 0x5305}, // SEQ_DATA_PORT
+	{0x3086, 0x5307}, // SEQ_DATA_PORT
+	{0x3086, 0x4D2B}, // SEQ_DATA_PORT
+	{0x3086, 0xF810}, // SEQ_DATA_PORT
+	{0x3086, 0x164C}, // SEQ_DATA_PORT
+	{0x3086, 0x0755}, // SEQ_DATA_PORT
+	{0x3086, 0x562B}, // SEQ_DATA_PORT
+	{0x3086, 0xB82B}, // SEQ_DATA_PORT
+	{0x3086, 0x984E}, // SEQ_DATA_PORT
+	{0x3086, 0x1129}, // SEQ_DATA_PORT
+	{0x3086, 0x9460}, // SEQ_DATA_PORT
+	{0x3086, 0x5C09}, // SEQ_DATA_PORT
+	{0x3086, 0x5C1B}, // SEQ_DATA_PORT
+	{0x3086, 0x4002}, // SEQ_DATA_PORT
+	{0x3086, 0x4500}, // SEQ_DATA_PORT
+	{0x3086, 0x4580}, // SEQ_DATA_PORT
+	{0x3086, 0x29B6}, // SEQ_DATA_PORT
+	{0x3086, 0x7F80}, // SEQ_DATA_PORT
+	{0x3086, 0x4004}, // SEQ_DATA_PORT
+	{0x3086, 0x7F88}, // SEQ_DATA_PORT
+	{0x3086, 0x4109}, // SEQ_DATA_PORT
+	{0x3086, 0x5C0B}, // SEQ_DATA_PORT
+	{0x3086, 0x29B2}, // SEQ_DATA_PORT
+	{0x3086, 0x4115}, // SEQ_DATA_PORT
+	{0x3086, 0x5C03}, // SEQ_DATA_PORT
+	{0x3086, 0x4105}, // SEQ_DATA_PORT
+	{0x3086, 0x5F2B}, // SEQ_DATA_PORT
+	{0x3086, 0x902B}, // SEQ_DATA_PORT
+	{0x3086, 0x8081}, // SEQ_DATA_PORT
+	{0x3086, 0x6F40}, // SEQ_DATA_PORT
+	{0x3086, 0x1041}, // SEQ_DATA_PORT
+	{0x3086, 0x0160}, // SEQ_DATA_PORT
+	{0x3086, 0x29A2}, // SEQ_DATA_PORT
+	{0x3086, 0x29A3}, // SEQ_DATA_PORT
+	{0x3086, 0x5F4D}, // SEQ_DATA_PORT
+	{0x3086, 0x1C17}, // SEQ_DATA_PORT
+	{0x3086, 0x0281}, // SEQ_DATA_PORT
+	{0x3086, 0xE729}, // SEQ_DATA_PORT
+	{0x3086, 0x8345}, // SEQ_DATA_PORT
+	{0x3086, 0x8840}, // SEQ_DATA_PORT
+	{0x3086, 0x0F7F}, // SEQ_DATA_PORT
+	{0x3086, 0x8A40}, // SEQ_DATA_PORT
+	{0x3086, 0x2345}, // SEQ_DATA_PORT
+	{0x3086, 0x8024}, // SEQ_DATA_PORT
+	{0x3086, 0x4008}, // SEQ_DATA_PORT
+	{0x3086, 0x7F88}, // SEQ_DATA_PORT
+	{0x3086, 0x5D29}, // SEQ_DATA_PORT
+	{0x3086, 0x9288}, // SEQ_DATA_PORT
+	{0x3086, 0x102B}, // SEQ_DATA_PORT
+	{0x3086, 0x0489}, // SEQ_DATA_PORT
+	{0x3086, 0x165C}, // SEQ_DATA_PORT
+	{0x3086, 0x4386}, // SEQ_DATA_PORT
+	{0x3086, 0x170B}, // SEQ_DATA_PORT
+	{0x3086, 0x5C03}, // SEQ_DATA_PORT
+	{0x3086, 0x8A48}, // SEQ_DATA_PORT
+	{0x3086, 0x4D4E}, // SEQ_DATA_PORT
+	{0x3086, 0x2B80}, // SEQ_DATA_PORT
+	{0x3086, 0x4C09}, // SEQ_DATA_PORT
+	{0x3086, 0x4119}, // SEQ_DATA_PORT
+	{0x3086, 0x816F}, // SEQ_DATA_PORT
+	{0x3086, 0x4110}, // SEQ_DATA_PORT
+	{0x3086, 0x4001}, // SEQ_DATA_PORT
+	{0x3086, 0x6029}, // SEQ_DATA_PORT
+	{0x3086, 0x8229}, // SEQ_DATA_PORT
+	{0x3086, 0x8329}, // SEQ_DATA_PORT
+	{0x3086, 0x435C}, // SEQ_DATA_PORT
+	{0x3086, 0x055F}, // SEQ_DATA_PORT
+	{0x3086, 0x4D1C}, // SEQ_DATA_PORT
+	{0x3086, 0x81E7}, // SEQ_DATA_PORT
+	{0x3086, 0x4502}, // SEQ_DATA_PORT
+	{0x3086, 0x8180}, // SEQ_DATA_PORT
+	{0x3086, 0x7F80}, // SEQ_DATA_PORT
+	{0x3086, 0x410A}, // SEQ_DATA_PORT
+	{0x3086, 0x9144}, // SEQ_DATA_PORT
+	{0x3086, 0x1609}, // SEQ_DATA_PORT
+	{0x3086, 0x2FC3}, // SEQ_DATA_PORT
+	{0x3086, 0xB130}, // SEQ_DATA_PORT
+	{0x3086, 0xC3B1}, // SEQ_DATA_PORT
+	{0x3086, 0x0343}, // SEQ_DATA_PORT
+	{0x3086, 0x164A}, // SEQ_DATA_PORT
+	{0x3086, 0x0A43}, // SEQ_DATA_PORT
+	{0x3086, 0x160B}, // SEQ_DATA_PORT
+	{0x3086, 0x4316}, // SEQ_DATA_PORT
+	{0x3086, 0x8F43}, // SEQ_DATA_PORT
+	{0x3086, 0x1690}, // SEQ_DATA_PORT
+	{0x3086, 0x4316}, // SEQ_DATA_PORT
+	{0x3086, 0x7F81}, // SEQ_DATA_PORT
+	{0x3086, 0x450A}, // SEQ_DATA_PORT
+	{0x3086, 0x410F}, // SEQ_DATA_PORT
+	{0x3086, 0x7F83}, // SEQ_DATA_PORT
+	{0x3086, 0x5D29}, // SEQ_DATA_PORT
+	{0x3086, 0x4488}, // SEQ_DATA_PORT
+	{0x3086, 0x102B}, // SEQ_DATA_PORT
+	{0x3086, 0x0453}, // SEQ_DATA_PORT
+	{0x3086, 0x0D40}, // SEQ_DATA_PORT
+	{0x3086, 0x2345}, // SEQ_DATA_PORT
+	{0x3086, 0x0240}, // SEQ_DATA_PORT
+	{0x3086, 0x087F}, // SEQ_DATA_PORT
+	{0x3086, 0x8053}, // SEQ_DATA_PORT
+	{0x3086, 0x0D89}, // SEQ_DATA_PORT
+	{0x3086, 0x165C}, // SEQ_DATA_PORT
+	{0x3086, 0x4586}, // SEQ_DATA_PORT
+	{0x3086, 0x170B}, // SEQ_DATA_PORT
+	{0x3086, 0x5C05}, // SEQ_DATA_PORT
+	{0x3086, 0x8A60}, // SEQ_DATA_PORT
+	{0x3086, 0x4B91}, // SEQ_DATA_PORT
+	{0x3086, 0x4416}, // SEQ_DATA_PORT
+	{0x3086, 0x09C1}, // SEQ_DATA_PORT
+	{0x3086, 0x2CA9}, // SEQ_DATA_PORT
+	{0x3086, 0xAB30}, // SEQ_DATA_PORT
+	{0x3086, 0x51B3}, // SEQ_DATA_PORT
+	{0x3086, 0x3D5A}, // SEQ_DATA_PORT
+	{0x3086, 0x7E3D}, // SEQ_DATA_PORT
+	{0x3086, 0x7E19}, // SEQ_DATA_PORT
+	{0x3086, 0x8000}, // SEQ_DATA_PORT
+	{0x3086, 0x8B1F}, // SEQ_DATA_PORT
+	{0x3086, 0x2A1F}, // SEQ_DATA_PORT
+	{0x3086, 0x83A2}, // SEQ_DATA_PORT
+	{0x3086, 0x7516}, // SEQ_DATA_PORT
+	{0x3086, 0xAD33}, // SEQ_DATA_PORT
+	{0x3086, 0x450A}, // SEQ_DATA_PORT
+	{0x3086, 0x7F53}, // SEQ_DATA_PORT
+	{0x3086, 0x8023}, // SEQ_DATA_PORT
+	{0x3086, 0x8C66}, // SEQ_DATA_PORT
+	{0x3086, 0x7F13}, // SEQ_DATA_PORT
+	{0x3086, 0x8184}, // SEQ_DATA_PORT
+	{0x3086, 0x1481}, // SEQ_DATA_PORT
+	{0x3086, 0x8031}, // SEQ_DATA_PORT
+	{0x3086, 0x3D64}, // SEQ_DATA_PORT
+	{0x3086, 0x452A}, // SEQ_DATA_PORT
+	{0x3086, 0x9451}, // SEQ_DATA_PORT
+	{0x3086, 0x9E96}, // SEQ_DATA_PORT
+	{0x3086, 0x3D2B}, // SEQ_DATA_PORT
+	{0x3086, 0x3D1B}, // SEQ_DATA_PORT
+	{0x3086, 0x529F}, // SEQ_DATA_PORT
+	{0x3086, 0x0E3D}, // SEQ_DATA_PORT
+	{0x3086, 0x083D}, // SEQ_DATA_PORT
+	{0x3086, 0x167E}, // SEQ_DATA_PORT
+	{0x3086, 0x307E}, // SEQ_DATA_PORT
+	{0x3086, 0x1175}, // SEQ_DATA_PORT
+	{0x3086, 0x163E}, // SEQ_DATA_PORT
+	{0x3086, 0x970E}, // SEQ_DATA_PORT
+	{0x3086, 0x82B2}, // SEQ_DATA_PORT
+	{0x3086, 0x3D7F}, // SEQ_DATA_PORT
+	{0x3086, 0xAC3E}, // SEQ_DATA_PORT
+	{0x3086, 0x4502}, // SEQ_DATA_PORT
+	{0x3086, 0x7E11}, // SEQ_DATA_PORT
+	{0x3086, 0x7FD0}, // SEQ_DATA_PORT
+	{0x3086, 0x8000}, // SEQ_DATA_PORT
+	{0x3086, 0x8C66}, // SEQ_DATA_PORT
+	{0x3086, 0x7F90}, // SEQ_DATA_PORT
+	{0x3086, 0x8194}, // SEQ_DATA_PORT
+	{0x3086, 0x3F44}, // SEQ_DATA_PORT
+	{0x3086, 0x1681}, // SEQ_DATA_PORT
+	{0x3086, 0x8416}, // SEQ_DATA_PORT
+	{0x3086, 0x2C2C}, // SEQ_DATA_PORT
+	{0x3086, 0x2C2C}, // SEQ_DATA_PORT
+	{0x302A, 0x0005}, // VT_PIX_CLK_DIV
+	{0x302C, 0x0002}, // VT_SYS_CLK_DIV
+	{0x302E, 0x0003}, // PRE_PLL_CLK_DIV
+	{0x3030, 0x0032}, // PLL_MULTIPLIER
+	{0x3036, 0x000A}, // OP_PIX_CLK_DIV
+	{0x3038, 0x0002}, // OP_SYS_CLK_DIV
+	{0x30B0, 0x0028}, // DIGITAL_TEST
+	{0x31B0, 0x0082}, // FRAME_PREAMBLE
+	{0x31B2, 0x005C}, // LINE_PREAMBLE
+	{0x31B4, 0x5248}, // MIPI_TIMING_0
+	{0x31B6, 0x3257}, // MIPI_TIMING_1
+	{0x31B8, 0x904B}, // MIPI_TIMING_2
+	{0x31BA, 0x030B}, // MIPI_TIMING_3
+	{0x31BC, 0x8E09}, // MIPI_TIMING_4
+	{0x3354, 0x002B}, // MIPI_CNTRL
+	{0x31D0, 0x0000}, // COMPANDING
+	{0x31AE, 0x0204}, // SERIAL_FORMAT
+	{0x3002, 0x0008}, // Y_ADDR_START
+	{0x3004, 0x0008}, // X_ADDR_START
+	{0x3006, 0x04B7}, // Y_ADDR_END
+	{0x3008, 0x0787}, // X_ADDR_END
+	{0x3064, 0x1802}, // SMIA_TEST
+	{0x300A, 0x04C4}, // FRAME_LENGTH_LINES
+	{0x300C, 0x0264}, // LINE_LENGTH_PCK
+	{0x30A2, 0x0001}, // X_ODD_INC
+	{0x30A6, 0x0001}, // Y_ODD_INC
+	{0x3012, 0x02DC}, // COARSE_INTEGRATION_TIME
+	{0x3786, 0x0006}, // DIGITAL_CTRL_1
+	{0x31AE, 0x0202}, // SERIAL_FORMAT
+	{0x3044, 0x0410}, // RESERVED_MFR_3044
+	{0x3094, 0x03D4}, // RESERVED_MFR_3094
+	{0x3096, 0x0480}, // RESERVED_MFR_3096
+	{0x30BA, 0x7606}, // RESERVED_MFR_30BA
+	{0x30B0, 0x0028}, // DIGITAL_TEST
+	{0x30BA, 0x7600}, // RESERVED_MFR_30BA
+	{0x30FE, 0x002A}, // NOISE_PEDESTAL
+	{0x31DE, 0x0410}, // RESERVED_MFR_31DE
+	{0x3ED6, 0x1435}, // RESERVED_MFR_3ED6
+	{0x3ED8, 0x9865}, // RESERVED_MFR_3ED8
+	{0x3EDA, 0x7698}, // RESERVED_MFR_3EDA
+	{0x3EDC, 0x99FF}, // RESERVED_MFR_3EDC
+	{0x3EE2, 0xBB88}, // RESERVED_MFR_3EE2
+	{0x3EE4, 0x8836}, // RESERVED_MFR_3EE4
+	{0x3EF0, 0x1CF0}, // RESERVED_MFR_3EF0
+	{0x3EF2, 0x0000}, // RESERVED_MFR_3EF2
+	{0x3EF8, 0x6166}, // RESERVED_MFR_3EF8
+	{0x3EFA, 0x3333}, // RESERVED_MFR_3EFA
+	{0x3EFC, 0x6634}, // RESERVED_MFR_3EFC
+	{0x3088, 0x81BA}, // SEQ_CTRL_PORT
+	{0x3086, 0x3D02}, // SEQ_DATA_PORT
+	{0x3276, 0x05DC}, // RESERVED_MFR_3276
+	{0x3F00, 0x9D05}, // RESERVED_MFR_3F00
+	{0x3ED2, 0xFA86}, // RESERVED_MFR_3ED2
+	{0x3EEE, 0xA4FE}, // RESERVED_MFR_3EEE
+	{0x3ECC, 0x6D42}, // RESERVED_MFR_3ECC
+	{0x3ECC, 0x0D42}, // RESERVED_MFR_3ECC
+	{0x3EEC, 0x0C0C}, // RESERVED_MFR_3EEC
+	{0x3EE8, 0xAAE4}, // RESERVED_MFR_3EE8
+	{0x3EE6, 0x3363}, // RESERVED_MFR_3EE6
+	{0x3EE6, 0x3363}, // RESERVED_MFR_3EE6
+	{0x3EE8, 0xAAE4}, // RESERVED_MFR_3EE8
+	{0x3EE8, 0xAAE4}, // RESERVED_MFR_3EE8
+	{0x3180, 0xC24F}, // DELTA_DK_CONTROL
+	{0x3102, 0x5000}, // AE_LUMA_TARGET_REG
+	{0x3060, 0x000D}, // ANALOG_GAIN
+	{0x3ED0, 0xFF44}, // RESERVED_MFR_3ED0
+	{0x3ED2, 0xAA86}, // RESERVED_MFR_3ED2
+	{0x3ED4, 0x031F}, // RESERVED_MFR_3ED4
+	{0x3EEE, 0xA4AA}, // RESERVED_MFR_3EEE
+};
+
+static const s64 link_freq_menu_items[] = {
+	AR0234_LINK_FREQ_360MHZ,
+	AR0234_LINK_FREQ_300MHZ,
+	AR0234_LINK_FREQ_288MHZ,
+	AR0234_LINK_FREQ_240MHZ,
+	AR0234_LINK_FREQ_22_5MHZ,
+};
+
+static const struct ar0234_link_freq_config link_freq_configs[] = {
+	[AR0234_LINK_FREQ_360MBPS] = {
+		.reg_list = {
+			.num_of_regs =
+				ARRAY_SIZE(freq_1280x960_10bit_2lane_360M),
+			.regs = freq_1280x960_10bit_2lane_360M,
+		}
+	},
+	[AR0234_LINK_FREQ_300MBPS] = {
+		.reg_list = {
+			.num_of_regs =
+				ARRAY_SIZE(freq_1280x960_10bit_4lane_300M),
+			.regs = freq_1280x960_10bit_4lane_300M,
+		}
+	},
+	[AR0234_LINK_FREQ_288MBPS] = {
+		.reg_list = {
+			.num_of_regs =
+				ARRAY_SIZE(freq_1280x960_8bit_2lane_288M),
+			.regs = freq_1280x960_8bit_2lane_288M,
+		}
+	},
+	[AR0234_LINK_FREQ_240MBPS] = {
+		.reg_list = {
+			.num_of_regs =
+				ARRAY_SIZE(freq_1280x960_8bit_4lane_240M),
+			.regs = freq_1280x960_8bit_4lane_240M,
+		}
+	},
+	[AR0234_LINK_FREQ_22_5MBPS] = {
+		.reg_list = {
+			.num_of_regs =
+				ARRAY_SIZE(freq_1920x1200_10bit_2lane_22_5M),
+			.regs = freq_1920x1200_10bit_2lane_22_5M,
+		}
+	},
+};
+
+static const struct ar0234_mode supported_modes[] = {
+	{
+		.width = WIN_WIDTH,
+		.height = WIN_HEIGHT,
+		.hts = 2464,
+		.vts_def = 2435,
+		.vts_min = 2435,
+		.code = MEDIA_BUS_FMT_SGRBG10_1X10,
+		.lanes = 2,
+		.fps = 30,
+		.bpp = 10,
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(mode_1280x960_10bit_2lane),
+			.regs = mode_1280x960_10bit_2lane,
+		},
+		.link_freq_index = -1,
+	},
+	{
+		.width = WIN_WIDTH,
+		.height = WIN_HEIGHT,
+		.hts = 2464,
+		.vts_def = 2435,
+		.vts_min = 2435,
+		.code = MEDIA_BUS_FMT_SGRBG8_1X8,
+		.lanes = 4,
+		.fps = 40,
+		.bpp = 8,
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(mode_1280x960_8bit_4lane),
+			.regs = mode_1280x960_8bit_4lane,
+		},
+		.link_freq_index = AR0234_LINK_FREQ_240MBPS,
+	},
+	{
+		.width = 1920,
+		.height = 1200,
+		.hts = 2464,
+		.vts_def = 2435,
+		.vts_min = 2435,
+		.code = MEDIA_BUS_FMT_SGRBG10_1X10,
+		.lanes = 2,
+		.fps = 30,
+		.bpp = 10,
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(mode_1920x1200_10bit_2lane),
+			.regs = mode_1920x1200_10bit_2lane,
+		},
+		.link_freq_index = AR0234_LINK_FREQ_22_5MBPS,
+	},
+};
+
+static u32 supported_formats[] = {
+	MEDIA_BUS_FMT_SGRBG10_1X10,
+	MEDIA_BUS_FMT_SGRBG8_1X8,
+};
+
+struct ar0234 {
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_ctrl_handler ctrl_handler;
+
+	/* V4L2 Controls */
+	struct v4l2_ctrl *link_freq;
+	struct v4l2_ctrl *vblank;
+	struct v4l2_ctrl *exposure;
+	struct v4l2_ctrl *analogue_gain;
+	struct v4l2_ctrl *digital_gain;
+	struct v4l2_ctrl *strobe_source;
+	struct v4l2_ctrl *strobe;
+	struct v4l2_ctrl *strobe_stop;
+	struct v4l2_ctrl *timeout;
+	struct v4l2_ctrl *csi_port;
+	struct v4l2_ctrl *i2c_bus;
+	struct v4l2_ctrl *i2c_id;
+	struct v4l2_ctrl *i2c_slave_address;
+	struct v4l2_ctrl *fps;
+	struct v4l2_ctrl *frame_interval;
+	struct v4l2_ctrl *pixel_rate;
+	struct v4l2_ctrl *hblank;
+	struct v4l2_ctrl *vflip;
+	struct v4l2_ctrl *hflip;
+	struct v4l2_ctrl *query_sub_stream;
+	struct v4l2_ctrl *set_sub_stream;
+
+	/* Current mode */
+	const struct ar0234_mode *cur_mode;
+
+	/* To serialize asynchronus callbacks */
+	struct mutex mutex;
+
+	/* Streaming on/off */
+	bool streaming;
+
+	struct ar0234_platform_data *platform_data;
+
+	s64 sub_stream;
+};
+
+static int ar0234_read_reg(struct ar0234 *ar0234, u16 reg, u16 len, u32 *val)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&ar0234->sd);
+	struct i2c_msg msgs[2];
+	u8 addr_buf[2];
+	u8 data_buf[4] = {0};
+	int ret;
+
+	if (len > 4)
+		return -EINVAL;
+
+	put_unaligned_be16(reg, addr_buf);
+	msgs[0].addr = client->addr;
+	msgs[0].flags = 0;
+	msgs[0].len = sizeof(addr_buf);
+	msgs[0].buf = addr_buf;
+	msgs[1].addr = client->addr;
+	msgs[1].flags = I2C_M_RD;
+	msgs[1].len = len;
+	msgs[1].buf = &data_buf[4 - len];
+
+	ret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));
+	if (ret != ARRAY_SIZE(msgs))
+		return -EIO;
+
+	*val = get_unaligned_be32(data_buf);
+
+	return 0;
+}
+
+static int ar0234_write_reg(struct ar0234 *ar0234, u16 reg, u16 len, u32 val)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&ar0234->sd);
+	u8 buf[6];
+
+	if (reg == 0) {
+		msleep(val);
+		return 0;
+	}
+
+	if (len > 4)
+		return -EINVAL;
+
+	put_unaligned_be16(reg, buf);
+	put_unaligned_be32(val << 8 * (4 - len), buf + 2);
+	if (i2c_master_send(client, buf, len + 2) != len + 2)
+		return -EIO;
+
+	return 0;
+}
+
+static int ar0234_write_reg_list(struct ar0234 *ar0234,
+				 const struct ar0234_reg_list *r_list)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&ar0234->sd);
+	unsigned int i;
+	int ret;
+
+	for (i = 0; i < r_list->num_of_regs; i++) {
+		ret = ar0234_write_reg(ar0234, r_list->regs[i].address,
+				AR0234_REG_VALUE_16BIT,
+				       r_list->regs[i].val);
+		if (ret) {
+			dev_err_ratelimited(&client->dev,
+				    "failed to write reg 0x%4.4x. error = %d",
+				    r_list->regs[i].address, ret);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int ar0234_update_digital_gain(struct ar0234 *ar0234, u32 d_gain)
+{
+	return ar0234_write_reg(ar0234, AR0234_REG_GLOBAL_GAIN,
+				AR0234_REG_VALUE_16BIT, d_gain);
+}
+
+static u64 get_pixel_rate(struct ar0234 *ar0234)
+{
+	u64 pixel_rate;
+
+	if (ar0234->cur_mode->lanes == 4)
+		pixel_rate = FSERIAL_CLK_4_LANE;
+	else if (ar0234->cur_mode->lanes == 2)
+		pixel_rate = FSERIAL_CLK_2_LANE;
+	else
+		pixel_rate = FSERIAL_CLK_4_LANE;
+
+	return pixel_rate;
+}
+
+/*
+ * from table 1, AND9820-D.pdf.
+ * for context A, hblank = LLP(0x300C) - active data time.
+ */
+static u64 get_hblank(struct ar0234 *ar0234)
+{
+	u64 hblank;
+	u64 pixel_rate;
+	u64 pixel_clk;
+
+	if (ar0234->cur_mode->lanes == 4) {
+		pixel_rate = FSERIAL_CLK_4_LANE;
+		pixel_clk = PIX_CLK_4_LANE;
+	} else if (ar0234->cur_mode->lanes == 2) {
+		pixel_rate = FSERIAL_CLK_2_LANE;
+		pixel_clk = PIX_CLK_2_LANE;
+	} else {
+		pixel_rate = FSERIAL_CLK_4_LANE;
+		pixel_clk = PIX_CLK_4_LANE;
+	}
+
+	/*
+	 * for pixel clock is ar0234 internal,
+	 * return hblank in the numbers of pixel rate.
+	 */
+	hblank = 0x384 * (pixel_rate / pixel_clk);
+
+	return hblank;
+}
+
+static int ar0234_set_stream(struct v4l2_subdev *sd, int enable);
+
+static int ar0234_set_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct ar0234 *ar0234 = container_of(ctrl->handler,
+					     struct ar0234, ctrl_handler);
+	struct i2c_client *client = v4l2_get_subdevdata(&ar0234->sd);
+	s64 exposure_max;
+	int ret = 0;
+	u32 val;
+
+	if (ctrl->id == V4L2_CID_IPU_SET_SUB_STREAM) {
+		val = (*ctrl->p_new.p_s64 & 0xFFFF);
+		dev_info(&client->dev, "V4L2_CID_IPU_SET_SUB_STREAM %x\n", val);
+		mutex_unlock(&ar0234->mutex);
+		ret = ar0234_set_stream(&ar0234->sd, val & 0x00FF);
+		mutex_lock(&ar0234->mutex);
+		return ret;
+	}
+
+	/* Propagate change of current control to all related controls */
+	if (ctrl->id == V4L2_CID_VBLANK) {
+		/* Update max exposure while meeting expected vblanking */
+		exposure_max = ar0234->cur_mode->height + ctrl->val -
+			       AR0234_EXPOSURE_MAX_MARGIN;
+		__v4l2_ctrl_modify_range(ar0234->exposure,
+					 ar0234->exposure->minimum,
+					 exposure_max, ar0234->exposure->step,
+					 ar0234->cur_mode->height -
+					 AR0234_EXPOSURE_MAX_MARGIN);
+	}
+
+	/* V4L2 controls values will be applied only when power is already up */
+	if (!pm_runtime_get_if_in_use(&client->dev))
+		return 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_ANALOGUE_GAIN:
+		ret = ar0234_write_reg(ar0234, AR0234_REG_ANALOG_GAIN,
+				       AR0234_REG_VALUE_16BIT, ctrl->val);
+		break;
+
+	case V4L2_CID_DIGITAL_GAIN:
+		ret = ar0234_update_digital_gain(ar0234, ctrl->val);
+		break;
+
+	case V4L2_CID_EXPOSURE:
+		/* 4 least significant bits of expsoure are fractional part */
+		ret = ar0234_write_reg(ar0234, AR0234_REG_EXPOSURE,
+				       AR0234_REG_VALUE_16BIT, ctrl->val);
+		break;
+
+	case V4L2_CID_VBLANK:
+		ret = ar0234_write_reg(ar0234, AR0234_REG_VTS,
+				       AR0234_REG_VALUE_16BIT,
+				       ar0234->cur_mode->height + ctrl->val);
+		dev_dbg(&client->dev, "set vblank %d\n", ar0234->cur_mode->height + ctrl->val);
+		break;
+	case V4L2_CID_FLASH_STROBE_SOURCE:
+		dev_dbg(&client->dev, "set led flash source %d\n", ctrl->val);
+		break;
+
+	case V4L2_CID_FLASH_STROBE:
+		if (ar0234->platform_data->gpios[0] != -1) {
+			if (ar0234->strobe_source->val ==
+					V4L2_FLASH_STROBE_SOURCE_SOFTWARE)
+				gpio_set_value(ar0234->platform_data->gpios[0], 1);
+		}
+		dev_info(&client->dev, "turn on led %d\n", ctrl->val);
+
+		break;
+
+	case V4L2_CID_FLASH_STROBE_STOP:
+		if (ar0234->platform_data->gpios[0] != -1) {
+			if (ar0234->strobe_source->val ==
+					V4L2_FLASH_STROBE_SOURCE_SOFTWARE)
+				gpio_set_value(ar0234->platform_data->gpios[0], 0);
+		}
+		dev_info(&client->dev, "turn off led %d\n", ctrl->val);
+		break;
+
+	case V4L2_CID_FLASH_TIMEOUT:
+		ret = ar0234_read_reg(ar0234, AR0234_REG_LED_FLASH_CONTROL,
+				AR0234_REG_VALUE_16BIT, &val);
+
+		ret = ar0234_write_reg(ar0234, AR0234_REG_LED_FLASH_CONTROL,
+				AR0234_REG_VALUE_16BIT,
+				(AR0234_LED_DELAY & ctrl->val) | ((~AR0234_LED_DELAY) & val));
+		dev_info(&client->dev, "set led delay %d\n",
+				AR0234_LED_DELAY & ctrl->val);
+		break;
+	case V4L2_CID_VFLIP:
+		ret = ar0234_read_reg(ar0234, AR0234_REG_IMAGE_ORIENTATION,
+				AR0234_REG_VALUE_08BIT, &val);
+
+		val &= ~(0x1 << AR0234_VFLIP_BIT);
+		val |= ctrl->val << AR0234_VFLIP_BIT;
+		ret = ar0234_write_reg(ar0234, AR0234_REG_IMAGE_ORIENTATION,
+				AR0234_REG_VALUE_08BIT,
+				val);
+		dev_info(&client->dev, "set vflip %d\n", ctrl->val);
+		break;
+	case V4L2_CID_HFLIP:
+		ret = ar0234_read_reg(ar0234, AR0234_REG_IMAGE_ORIENTATION,
+				AR0234_REG_VALUE_08BIT, &val);
+
+		val &= ~(0x1 << AR0234_HFLIP_BIT);
+		val |= ctrl->val << AR0234_HFLIP_BIT;
+		ret = ar0234_write_reg(ar0234, AR0234_REG_IMAGE_ORIENTATION,
+				AR0234_REG_VALUE_08BIT,
+				val);
+		dev_info(&client->dev, "set hflip %d\n", ctrl->val);
+		break;
+	case V4L2_CID_IPU_QUERY_SUB_STREAM:
+		dev_dbg(&client->dev, "query stream\n");
+		break;
+	default:
+		dev_err(&client->dev, "unexpected ctrl id 0x%08x\n", ctrl->id);
+		ret = -EINVAL;
+		break;
+	}
+
+	pm_runtime_put(&client->dev);
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops ar0234_ctrl_ops = {
+	.s_ctrl = ar0234_set_ctrl,
+};
+
+static struct v4l2_ctrl_config ar0234_csi_port = {
+	.ops	= &ar0234_ctrl_ops,
+	.id	= AR0234_CID_CSI_PORT,
+	.type	= V4L2_CTRL_TYPE_INTEGER,
+	.name	= "CSI port",
+	.min	= 1,
+	.max	= 5,
+	.def	= 1,
+	.step	= 1,
+	.flags	= V4L2_CTRL_FLAG_READ_ONLY,
+};
+
+static struct v4l2_ctrl_config ar0234_i2c_bus = {
+	.ops	= &ar0234_ctrl_ops,
+	.id	= AR0234_CID_I2C_BUS,
+	.type	= V4L2_CTRL_TYPE_INTEGER,
+	.name	= "I2C bus",
+	.min	= 0,
+	.max	= MINORMASK,
+	.def	= 0,
+	.step	= 1,
+	.flags	= V4L2_CTRL_FLAG_READ_ONLY,
+};
+
+static struct v4l2_ctrl_config ar0234_i2c_id = {
+	.ops	= &ar0234_ctrl_ops,
+	.id	= AR0234_CID_I2C_ID,
+	.type	= V4L2_CTRL_TYPE_INTEGER,
+	.name	= "I2C id",
+	.min	= 0x10,
+	.max	= 0x77,
+	.def	= 0x10,
+	.step	= 1,
+	.flags	= V4L2_CTRL_FLAG_READ_ONLY,
+};
+
+static struct v4l2_ctrl_config ar0234_i2c_slave_address = {
+	.ops	= &ar0234_ctrl_ops,
+	.id	= AR0234_CID_I2C_SLAVE_ADDRESS,
+	.type	= V4L2_CTRL_TYPE_INTEGER,
+	.name	= "I2C slave address",
+	.min	= 0x0,
+	.max	= 0x7f,
+	.def	= 0x10,
+	.step	= 1,
+	.flags	= V4L2_CTRL_FLAG_READ_ONLY,
+};
+
+static struct v4l2_ctrl_config ar0234_fps = {
+	.ops	= &ar0234_ctrl_ops,
+	.id	= AR0234_CID_FPS,
+	.type	= V4L2_CTRL_TYPE_INTEGER,
+	.name	= "fps",
+	.min	= 10,
+	.max	= 120,
+	.def	= 30,
+	.step	= 1,
+	.flags	= V4L2_CTRL_FLAG_READ_ONLY,
+};
+
+static struct v4l2_ctrl_config ar0234_frame_interval = {
+	.ops	= &ar0234_ctrl_ops,
+	.id	= AR0234_CID_FRAME_INTERVAL,
+	.type	= V4L2_CTRL_TYPE_INTEGER,
+	.name	= "frame interval",
+	.min	= 0,
+	.max	= 1000,
+	.def	= 25,
+	.step	= 1,
+	.flags	= V4L2_CTRL_FLAG_READ_ONLY,
+};
+
+static struct v4l2_ctrl_config ar0234_q_sub_stream = {
+	.ops = &ar0234_ctrl_ops,
+	.id = V4L2_CID_IPU_QUERY_SUB_STREAM,
+	.name = "query virtual channel",
+	.type = V4L2_CTRL_TYPE_INTEGER_MENU,
+	.max = 1,
+	.min = 0,
+	.def = 0,
+	.menu_skip_mask = 0,
+	.qmenu_int = NULL,
+};
+
+static const struct v4l2_ctrl_config ar0234_s_sub_stream = {
+	.ops = &ar0234_ctrl_ops,
+	.id = V4L2_CID_IPU_SET_SUB_STREAM,
+	.name = "set virtual channel",
+	.type = V4L2_CTRL_TYPE_INTEGER64,
+	.max = 0xFFFF,
+	.min = 0,
+	.def = 0,
+	.step = 1,
+};
+
+#define MIPI_CSI2_TYPE_RAW8    0x2a
+#define MIPI_CSI2_TYPE_RAW10   0x2b
+
+static unsigned int mbus_code_to_mipi(u32 code)
+{
+	switch (code) {
+	case MEDIA_BUS_FMT_SGRBG10_1X10:
+		return MIPI_CSI2_TYPE_RAW10;
+	case MEDIA_BUS_FMT_SGRBG8_1X8:
+		return MIPI_CSI2_TYPE_RAW8;
+	default:
+		WARN_ON(1);
+		return -EINVAL;
+	}
+}
+
+static void set_sub_stream_fmt(s64 *sub_stream, u32 code)
+{
+       *sub_stream &= 0xFFFFFFFFFFFF0000;
+       *sub_stream |= code;
+}
+
+static void set_sub_stream_h(s64 *sub_stream, u32 height)
+{
+       s64 val = height;
+       val &= 0xFFFF;
+       *sub_stream &= 0xFFFFFFFF0000FFFF;
+       *sub_stream |= val << 16;
+}
+
+static void set_sub_stream_w(s64 *sub_stream, u32 width)
+{
+       s64 val = width;
+       val &= 0xFFFF;
+       *sub_stream &= 0xFFFF0000FFFFFFFF;
+       *sub_stream |= val << 32;
+}
+
+static void set_sub_stream_dt(s64 *sub_stream, u32 dt)
+{
+       s64 val = dt;
+       val &= 0xFF;
+       *sub_stream &= 0xFF00FFFFFFFFFFFF;
+       *sub_stream |= val << 48;
+}
+
+static void set_sub_stream_vc_id(s64 *sub_stream, u32 vc_id)
+{
+       s64 val = vc_id;
+       val &= 0xFF;
+       *sub_stream &= 0x00FFFFFFFFFFFFFF;
+       *sub_stream |= val << 56;
+}
+
+static int ar0234_init_controls(struct ar0234 *ar0234)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&ar0234->sd);
+	struct v4l2_ctrl_handler *ctrl_hdlr;
+	s64 exposure_max;
+	s64 hblank;
+	int ret;
+
+	ctrl_hdlr = &ar0234->ctrl_handler;
+	ret = v4l2_ctrl_handler_init(ctrl_hdlr, 8);
+	if (ret)
+		return ret;
+
+	ctrl_hdlr->lock = &ar0234->mutex;
+	ar0234->link_freq = v4l2_ctrl_new_int_menu(ctrl_hdlr, &ar0234_ctrl_ops,
+					   V4L2_CID_LINK_FREQ,
+					   ARRAY_SIZE(link_freq_menu_items) - 1,
+					   0, link_freq_menu_items);
+	if (ar0234->link_freq)
+		ar0234->link_freq->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	ar0234->vblank = v4l2_ctrl_new_std(ctrl_hdlr, &ar0234_ctrl_ops,
+			  V4L2_CID_VBLANK,
+			  0,
+			  AR0234_VTS_MAX - ar0234->cur_mode->height, 1,
+			  ar0234->cur_mode->vts_def - ar0234->cur_mode->height);
+	v4l2_ctrl_new_std(ctrl_hdlr, &ar0234_ctrl_ops, V4L2_CID_ANALOGUE_GAIN,
+			  AR0234_ANAL_GAIN_MIN, AR0234_ANAL_GAIN_MAX,
+			  AR0234_ANAL_GAIN_STEP, AR0234_ANAL_GAIN_DEFAULT);
+	v4l2_ctrl_new_std(ctrl_hdlr, &ar0234_ctrl_ops, V4L2_CID_DIGITAL_GAIN,
+			  AR0234_DGTL_GAIN_MIN, AR0234_DGTL_GAIN_MAX,
+			  AR0234_DGTL_GAIN_STEP, AR0234_DGTL_GAIN_DEFAULT);
+	exposure_max = ar0234->cur_mode->vts_def - AR0234_EXPOSURE_MAX_MARGIN;
+	ar0234->exposure = v4l2_ctrl_new_std(ctrl_hdlr, &ar0234_ctrl_ops,
+					     V4L2_CID_EXPOSURE,
+					     AR0234_EXPOSURE_MIN, exposure_max,
+					     AR0234_EXPOSURE_STEP,
+					     exposure_max);
+	ar0234->strobe_source = v4l2_ctrl_new_std_menu(
+			ctrl_hdlr, &ar0234_ctrl_ops,
+			V4L2_CID_FLASH_STROBE_SOURCE,
+			1, 0, 1);
+	ar0234->strobe = v4l2_ctrl_new_std(ctrl_hdlr, &ar0234_ctrl_ops,
+			V4L2_CID_FLASH_STROBE, 0, 0, 0, 0);
+	ar0234->strobe_stop = v4l2_ctrl_new_std(ctrl_hdlr, &ar0234_ctrl_ops,
+			V4L2_CID_FLASH_STROBE_STOP, 0, 0, 0, 0);
+	ar0234->timeout = v4l2_ctrl_new_std(ctrl_hdlr, &ar0234_ctrl_ops,
+			V4L2_CID_FLASH_TIMEOUT, -128, 127, 1, 0);
+
+	ar0234_csi_port.def = ar0234->platform_data->port;
+	ar0234->csi_port =
+		v4l2_ctrl_new_custom(ctrl_hdlr, &ar0234_csi_port, NULL);
+	ar0234_i2c_bus.def = i2c_adapter_id(client->adapter);
+	ar0234->i2c_bus =
+		v4l2_ctrl_new_custom(ctrl_hdlr, &ar0234_i2c_bus, NULL);
+	ar0234_i2c_id.def = client->addr;
+	ar0234->i2c_id = v4l2_ctrl_new_custom(ctrl_hdlr, &ar0234_i2c_id, NULL);
+	ar0234_i2c_slave_address.def = ar0234->platform_data->i2c_slave_address;
+	ar0234->i2c_slave_address = v4l2_ctrl_new_custom(ctrl_hdlr, &ar0234_i2c_slave_address, NULL);
+	ar0234_fps.def = ar0234->cur_mode->fps;
+	ar0234->fps = v4l2_ctrl_new_custom(ctrl_hdlr, &ar0234_fps, NULL);
+	ar0234_frame_interval.def = 1000 / ar0234->cur_mode->fps;
+	ar0234->frame_interval = v4l2_ctrl_new_custom(ctrl_hdlr, &ar0234_frame_interval, NULL);
+
+	ar0234->pixel_rate = v4l2_ctrl_new_std(ctrl_hdlr, &ar0234_ctrl_ops,
+			V4L2_CID_PIXEL_RATE, get_pixel_rate(ar0234), get_pixel_rate(ar0234),
+			1, get_pixel_rate(ar0234));
+	if (ar0234->pixel_rate)
+		ar0234->pixel_rate->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	hblank = get_hblank(ar0234);
+	ar0234->hblank = v4l2_ctrl_new_std(ctrl_hdlr, &ar0234_ctrl_ops, V4L2_CID_HBLANK,
+					hblank, hblank, 1, hblank);
+	if (ar0234->hblank)
+		ar0234->hblank->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	ar0234->vflip = v4l2_ctrl_new_std(ctrl_hdlr, &ar0234_ctrl_ops,
+					  V4L2_CID_VFLIP, 0, 1, 1, 1);
+	ar0234->hflip = v4l2_ctrl_new_std(ctrl_hdlr, &ar0234_ctrl_ops,
+					  V4L2_CID_HFLIP, 0, 1, 1, 0);
+
+	ar0234_q_sub_stream.qmenu_int = &ar0234->sub_stream;
+	ar0234->query_sub_stream = v4l2_ctrl_new_custom(ctrl_hdlr, &ar0234_q_sub_stream, NULL);
+	if (ctrl_hdlr->error) {
+		dev_dbg(&client->dev, "new query sub stream ctrl, error = %d.\n",
+			ctrl_hdlr->error);
+		return ctrl_hdlr->error;
+	}
+
+	ar0234->set_sub_stream = v4l2_ctrl_new_custom(ctrl_hdlr, &ar0234_s_sub_stream, NULL);
+	if (ctrl_hdlr->error) {
+		dev_dbg(&client->dev, "new set sub stream ctrl, error = %d.\n",
+			ctrl_hdlr->error);
+		return ctrl_hdlr->error;
+	}
+
+	if (ctrl_hdlr->error)
+		return ctrl_hdlr->error;
+
+	ar0234->sd.ctrl_handler = ctrl_hdlr;
+
+	return ret;
+}
+
+static void ar0234_update_pad_format(const struct ar0234_mode *mode,
+				     struct v4l2_mbus_framefmt *fmt)
+{
+	fmt->width = mode->width;
+	fmt->height = mode->height;
+	fmt->code = mode->code;
+	fmt->field = V4L2_FIELD_NONE;
+}
+
+static int ar0234_start_streaming(struct ar0234 *ar0234)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&ar0234->sd);
+	const struct ar0234_reg_list *reg_list;
+	int link_freq_index, ret;
+
+	reg_list = &ar0234->cur_mode->reg_list;
+	ret = ar0234_write_reg_list(ar0234, reg_list);
+	if (ret) {
+		dev_err(&client->dev, "failed to set mode");
+		return ret;
+	}
+
+	link_freq_index = ar0234->cur_mode->link_freq_index;
+	if (link_freq_index >= 0) {
+		reg_list = &link_freq_configs[link_freq_index].reg_list;
+		ret = ar0234_write_reg_list(ar0234, reg_list);
+		if (ret) {
+			dev_err(&client->dev, "failed to set plls");
+			return ret;
+		}
+	}
+
+	ar0234->set_sub_stream->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+	ret = __v4l2_ctrl_handler_setup(ar0234->sd.ctrl_handler);
+	ar0234->set_sub_stream->flags &= ~V4L2_CTRL_FLAG_READ_ONLY;
+	if (ret)
+		return ret;
+
+	ret = ar0234_write_reg(ar0234, AR0234_REG_MODE_SELECT,
+			       AR0234_REG_VALUE_16BIT, AR0234_MODE_STREAMING);
+	if (ret) {
+		dev_err(&client->dev, "failed to set stream");
+		return ret;
+	}
+
+	return 0;
+}
+
+static void ar0234_stop_streaming(struct ar0234 *ar0234)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&ar0234->sd);
+
+	if (ar0234_write_reg(ar0234, AR0234_REG_MODE_SELECT,
+			     AR0234_REG_VALUE_16BIT, AR0234_MODE_STANDBY))
+		dev_err(&client->dev, "failed to set stream");
+	/*
+	 * turn off flash, clear possible noise.
+	 */
+	if (ar0234->platform_data->gpios[0] != -1)
+		gpio_set_value(ar0234->platform_data->gpios[0], 0);
+}
+
+static int ar0234_set_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct ar0234 *ar0234 = to_ar0234(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = 0;
+	if (ar0234->streaming == enable)
+		return 0;
+
+	mutex_lock(&ar0234->mutex);
+	if (enable) {
+		ret = pm_runtime_get_sync(&client->dev);
+		if (ret < 0) {
+			pm_runtime_put_noidle(&client->dev);
+			mutex_unlock(&ar0234->mutex);
+			return ret;
+		}
+
+		ret = ar0234_start_streaming(ar0234);
+		if (ret) {
+			enable = 0;
+			ar0234_stop_streaming(ar0234);
+			pm_runtime_put(&client->dev);
+		}
+	} else {
+		ar0234_stop_streaming(ar0234);
+		pm_runtime_put(&client->dev);
+	}
+
+	ar0234->streaming = enable;
+	mutex_unlock(&ar0234->mutex);
+
+	return ret;
+}
+
+static int ar0234_g_frame_interval(struct v4l2_subdev *sd,
+		struct v4l2_subdev_frame_interval *fival)
+{
+	struct ar0234 *ar0234 = to_ar0234(sd);
+
+	fival->pad = 0;
+	fival->interval.numerator = 1;
+	fival->interval.denominator = ar0234->cur_mode->fps;
+
+	return 0;
+}
+
+static int __maybe_unused ar0234_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ar0234 *ar0234 = to_ar0234(sd);
+
+	mutex_lock(&ar0234->mutex);
+	if (ar0234->streaming)
+		ar0234_stop_streaming(ar0234);
+
+	mutex_unlock(&ar0234->mutex);
+
+	return 0;
+}
+
+static int __maybe_unused ar0234_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ar0234 *ar0234 = to_ar0234(sd);
+	int ret;
+
+	mutex_lock(&ar0234->mutex);
+	if (ar0234->streaming) {
+		ret = ar0234_start_streaming(ar0234);
+		if (ret) {
+			ar0234->streaming = false;
+			ar0234_stop_streaming(ar0234);
+			mutex_unlock(&ar0234->mutex);
+			return ret;
+		}
+	}
+
+	mutex_unlock(&ar0234->mutex);
+
+	return 0;
+}
+
+static int ar0234_set_format(struct v4l2_subdev *sd,
+			     struct v4l2_subdev_state *sd_state,
+			     struct v4l2_subdev_format *fmt)
+{
+	struct ar0234 *ar0234 = to_ar0234(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(&ar0234->sd);
+	const struct ar0234_mode *mode;
+	s32 vblank_def;
+	s64 hblank;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(supported_modes); i++) {
+		if (supported_modes[i].width != fmt->format.width
+			|| supported_modes[i].height != fmt->format.height) {
+			dev_dbg(&client->dev, "resolution doesn't match\n");
+			continue;
+		}
+		if (supported_modes[i].code != fmt->format.code) {
+			dev_dbg(&client->dev, "pixel format doesn't match\n");
+			continue;
+		}
+		mode = &supported_modes[i];
+		break;
+	}
+
+	if (i >= ARRAY_SIZE(supported_modes))
+		mode = &supported_modes[0];
+
+	mutex_lock(&ar0234->mutex);
+	ar0234_update_pad_format(mode, &fmt->format);
+	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {
+		*v4l2_subdev_get_try_format(sd, sd_state, fmt->pad) = fmt->format;
+	} else {
+		ar0234->cur_mode = mode;
+		__v4l2_ctrl_s_ctrl(ar0234->link_freq, mode->link_freq_index);
+		__v4l2_ctrl_modify_range(ar0234->pixel_rate,
+					get_pixel_rate(ar0234),
+					get_pixel_rate(ar0234),
+					1,
+					get_pixel_rate(ar0234));
+
+		hblank = get_hblank(ar0234);
+		__v4l2_ctrl_modify_range(ar0234->hblank,
+					hblank,
+					hblank,
+					1,
+					hblank);
+
+		/* Update limits and set FPS to default */
+		vblank_def = mode->vts_def - mode->height;
+		__v4l2_ctrl_modify_range(ar0234->vblank,
+					 0,
+					 AR0234_VTS_MAX - mode->height, 1,
+					 vblank_def);
+		__v4l2_ctrl_s_ctrl(ar0234->vblank, vblank_def);
+
+		__v4l2_ctrl_s_ctrl(ar0234->fps, mode->fps);
+
+		__v4l2_ctrl_s_ctrl(ar0234->frame_interval, 1000 / mode->fps);
+
+		set_sub_stream_fmt(&ar0234->sub_stream, mode->code);
+		set_sub_stream_h(&ar0234->sub_stream, mode->height);
+		set_sub_stream_w(&ar0234->sub_stream, mode->width);
+		set_sub_stream_dt(&ar0234->sub_stream, mbus_code_to_mipi(mode->code));
+		set_sub_stream_vc_id(&ar0234->sub_stream, 0);
+	}
+
+	mutex_unlock(&ar0234->mutex);
+
+	return 0;
+}
+
+static int ar0234_get_format(struct v4l2_subdev *sd,
+			     struct v4l2_subdev_state *sd_state,
+			     struct v4l2_subdev_format *fmt)
+{
+	struct ar0234 *ar0234 = to_ar0234(sd);
+
+	mutex_lock(&ar0234->mutex);
+	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY)
+		fmt->format = *v4l2_subdev_get_try_format(&ar0234->sd,
+							  sd_state, fmt->pad);
+	else
+		ar0234_update_pad_format(ar0234->cur_mode, &fmt->format);
+
+	mutex_unlock(&ar0234->mutex);
+
+	return 0;
+}
+
+static int ar0234_enum_mbus_code(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_state *sd_state,
+				 struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->index >= ARRAY_SIZE(supported_formats))
+		return -EINVAL;
+
+	code->code = supported_formats[code->index];
+
+	return 0;
+}
+
+static int ar0234_enum_frame_size(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_state *sd_state,
+				  struct v4l2_subdev_frame_size_enum *fse)
+{
+	if (fse->index >= ARRAY_SIZE(supported_modes))
+		return -EINVAL;
+
+	fse->min_width = supported_modes[fse->index].width;
+	fse->max_width = fse->min_width;
+	fse->min_height = supported_modes[fse->index].height;
+	fse->max_height = fse->min_height;
+
+	return 0;
+}
+
+static int ar0234_frame_rate[] = { 40, 20 };
+
+static int ar0234_enum_frame_interval(struct v4l2_subdev *subdev,
+		struct v4l2_subdev_state *sd_state,
+		struct v4l2_subdev_frame_interval_enum *fie)
+{
+	int mode_size = ARRAY_SIZE(supported_modes);
+	int i;
+
+	if (fie->index >= ARRAY_SIZE(ar0234_frame_rate))
+		return -EINVAL;
+
+	for (i = 0; i < mode_size; i++)
+		if (fie->code == supported_modes[i].code
+			&& fie->width == supported_modes[i].width
+			&& fie->height == supported_modes[i].height)
+			break;
+
+	if (i == mode_size)
+		return -EINVAL;
+
+	fie->interval.numerator = 1;
+	fie->interval.denominator = ar0234_frame_rate[fie->index];
+
+	return 0;
+}
+
+static int ar0234_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct ar0234 *ar0234 = to_ar0234(sd);
+
+	mutex_lock(&ar0234->mutex);
+	ar0234_update_pad_format(&supported_modes[0],
+				 v4l2_subdev_get_try_format(sd, fh->state, 0));
+	mutex_unlock(&ar0234->mutex);
+
+	return 0;
+}
+
+static const struct v4l2_subdev_video_ops ar0234_video_ops = {
+	.s_stream = ar0234_set_stream,
+	.g_frame_interval = ar0234_g_frame_interval,
+};
+
+static const struct v4l2_subdev_pad_ops ar0234_pad_ops = {
+	.set_fmt = ar0234_set_format,
+	.get_fmt = ar0234_get_format,
+	.enum_mbus_code = ar0234_enum_mbus_code,
+	.enum_frame_size = ar0234_enum_frame_size,
+	.enum_frame_interval = ar0234_enum_frame_interval,
+};
+
+static const struct v4l2_subdev_ops ar0234_subdev_ops = {
+	.video = &ar0234_video_ops,
+	.pad = &ar0234_pad_ops,
+};
+
+static const struct media_entity_operations ar0234_subdev_entity_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+static const struct v4l2_subdev_internal_ops ar0234_internal_ops = {
+	.open = ar0234_open,
+};
+
+static int ar0234_identify_module(struct ar0234 *ar0234)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&ar0234->sd);
+	int ret;
+	u32 val;
+
+	ret = ar0234_read_reg(ar0234, AR0234_REG_CHIP_ID,
+			      AR0234_REG_VALUE_16BIT, &val);
+	if (ret)
+		return ret;
+
+	if (val != AR0234_CHIP_ID) {
+		dev_err(&client->dev, "chip id mismatch: %x!=%x",
+			AR0234_CHIP_ID, val);
+		return -ENXIO;
+	}
+
+	return 0;
+}
+
+static int ar0234_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ar0234 *ar0234 = to_ar0234(sd);
+
+	v4l2_async_unregister_subdev(sd);
+	media_entity_cleanup(&sd->entity);
+	v4l2_ctrl_handler_free(sd->ctrl_handler);
+	pm_runtime_disable(&client->dev);
+	mutex_destroy(&ar0234->mutex);
+
+	return 0;
+}
+
+irqreturn_t ar0234_threaded_irq_fn(int irq, void *dev_id)
+{
+	struct ar0234 *ar0234 = dev_id;
+
+	if ((ar0234->platform_data->gpios[0] != -1) && (ar0234->platform_data->irq_pin != -1)) {
+		mutex_lock(&ar0234->mutex);
+		if (ar0234->streaming == false) {
+			gpio_set_value(ar0234->platform_data->gpios[0], 0);
+			goto ar0234_irq_handled;
+		}
+
+		if (ar0234->strobe_source->val == V4L2_FLASH_STROBE_SOURCE_EXTERNAL) {
+			gpio_set_value(ar0234->platform_data->gpios[0],
+					gpio_get_value(ar0234->platform_data->irq_pin));
+		}
+
+ar0234_irq_handled:
+		mutex_unlock(&ar0234->mutex);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int ar0234_probe(struct i2c_client *client)
+{
+	struct ar0234 *ar0234;
+	int ret;
+
+	ar0234 = devm_kzalloc(&client->dev, sizeof(*ar0234), GFP_KERNEL);
+	if (!ar0234)
+		return -ENOMEM;
+
+	ar0234->platform_data = client->dev.platform_data;
+	if (ar0234->platform_data == NULL) {
+		dev_err(&client->dev, "no platform data provided\n");
+		return -EINVAL;
+	}
+	v4l2_i2c_subdev_init(&ar0234->sd, client, &ar0234_subdev_ops);
+	ret = ar0234_identify_module(ar0234);
+	if (ret) {
+		dev_err(&client->dev, "failed to find sensor: %d", ret);
+		return ret;
+	}
+
+	if (ar0234->platform_data->suffix)
+		snprintf(ar0234->sd.name,
+				sizeof(ar0234->sd.name), "ar0234 %c",
+				ar0234->platform_data->suffix);
+
+	mutex_init(&ar0234->mutex);
+	ar0234->cur_mode = &supported_modes[0];
+	ret = ar0234_init_controls(ar0234);
+	if (ret) {
+		dev_err(&client->dev, "failed to init controls: %d", ret);
+		goto probe_error_v4l2_ctrl_handler_free;
+	}
+
+	ar0234->sd.internal_ops = &ar0234_internal_ops;
+	ar0234->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	ar0234->sd.entity.ops = &ar0234_subdev_entity_ops;
+	ar0234->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;
+	ar0234->pad.flags = MEDIA_PAD_FL_SOURCE;
+	ret = media_entity_pads_init(&ar0234->sd.entity, 1, &ar0234->pad);
+	if (ret) {
+		dev_err(&client->dev, "failed to init entity pads: %d", ret);
+		goto probe_error_v4l2_ctrl_handler_free;
+	}
+
+	if ((ar0234->platform_data->gpios[0] != -1) && (ar0234->platform_data->irq_pin != -1)) {
+		ret = devm_gpio_request(&client->dev,
+				ar0234->platform_data->irq_pin,
+				ar0234->platform_data->irq_pin_name);
+		if (ret) {
+			dev_err(&client->dev, "IRQ pin request failed!\n");
+			goto probe_error_v4l2_ctrl_handler_free;
+		}
+		gpio_direction_input(ar0234->platform_data->irq_pin);
+		ret = devm_request_threaded_irq(&client->dev,
+				gpio_to_irq(ar0234->platform_data->irq_pin),
+				NULL, ar0234_threaded_irq_fn,
+				ar0234->platform_data->irq_pin_flags,
+				ar0234->platform_data->irq_pin_name,
+				ar0234);
+		if (ret) {
+			dev_err(&client->dev, "IRQ request failed!\n");
+			goto probe_error_v4l2_ctrl_handler_free;
+		}
+
+		ret = devm_gpio_request_one(&client->dev,
+				ar0234->platform_data->gpios[0],
+				GPIOF_OUT_INIT_LOW, "LED");
+		if (ret) {
+			dev_err(&client->dev, "LED GPIO pin request failed!\n");
+			goto probe_error_v4l2_ctrl_handler_free;
+		}
+	}
+
+	ret = v4l2_async_register_subdev_sensor(&ar0234->sd);
+	if (ret < 0) {
+		dev_err(&client->dev, "failed to register V4L2 subdev: %d",
+			ret);
+		goto probe_error_media_entity_cleanup;
+	}
+
+	/*
+	 * Device is already turned on by i2c-core with ACPI domain PM.
+	 * Enable runtime PM and turn off the device.
+	 */
+	pm_runtime_set_active(&client->dev);
+	pm_runtime_enable(&client->dev);
+	pm_runtime_idle(&client->dev);
+
+	return 0;
+
+probe_error_media_entity_cleanup:
+	media_entity_cleanup(&ar0234->sd.entity);
+
+probe_error_v4l2_ctrl_handler_free:
+	v4l2_ctrl_handler_free(ar0234->sd.ctrl_handler);
+	mutex_destroy(&ar0234->mutex);
+
+	return ret;
+}
+
+static const struct dev_pm_ops ar0234_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(ar0234_suspend, ar0234_resume)
+};
+
+static const struct i2c_device_id ar0234_id_table[] = {
+	{ "ar0234", 0 },
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(i2c, ar0234_id_table);
+
+static struct i2c_driver ar0234_i2c_driver = {
+	.driver = {
+		.name = "ar0234",
+		.pm = &ar0234_pm_ops,
+	},
+	.probe_new = ar0234_probe,
+	.remove = ar0234_remove,
+	.id_table = ar0234_id_table,
+};
+
+module_i2c_driver(ar0234_i2c_driver);
+
+MODULE_AUTHOR("Chang, Ying <ying.chang@intel.com>");
+MODULE_DESCRIPTION("ar0234 sensor driver");
+MODULE_LICENSE("GPL v2");
Index: b/drivers/media/i2c/d4xx.c
===================================================================
--- /dev/null
+++ b/drivers/media/i2c/d4xx.c
@@ -0,0 +1,4830 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * ds5.c - Intel(R) RealSense(TM) D4XX camera driver
+ *
+ * Copyright (c) 2017-2023, INTEL CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/kernel.h>
+#include <linux/media.h>
+#include <linux/module.h>
+#include <linux/of_gpio.h>
+#include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/videodev2.h>
+#include <linux/version.h>
+
+#include <linux/ipu-isys.h>
+
+#include <media/media-entity.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-mediabus.h>
+#include <media/d4xx_pdata.h>
+
+//#define DS5_DRIVER_NAME "DS5 RealSense camera driver"
+#define DS5_DRIVER_NAME "d4xx"
+#define DS5_DRIVER_NAME_AWG "d4xx-awg"
+#define DS5_DRIVER_NAME_ASR "d4xx-asr"
+#define DS5_DRIVER_NAME_CLASS "d4xx-class"
+#define DS5_DRIVER_NAME_DFU "d4xx-dfu"
+
+#define DS5_MIPI_SUPPORT_LINES		0x0300
+#define DS5_MIPI_SUPPORT_PHY		0x0304
+#define DS5_MIPI_DATARATE_MIN		0x0308
+#define DS5_MIPI_DATARATE_MAX		0x030A
+#define DS5_FW_VERSION			0x030C
+#define DS5_FW_BUILD			0x030E
+#define DS5_DEVICE_TYPE			0x0310
+#define DS5_DEVICE_TYPE_D45X		6
+#define DS5_DEVICE_TYPE_D43X		5
+#define DS5_DEVICE_TYPE_D46X		4
+
+#define DS5_MIPI_LANE_NUMS		0x0400
+#define DS5_MIPI_LANE_DATARATE		0x0402
+#define DS5_MIPI_CONF_STATUS		0x0500
+
+#define DS5_START_STOP_STREAM		0x1000
+#define DS5_DEPTH_STREAM_STATUS		0x1004
+#define DS5_RGB_STREAM_STATUS		0x1008
+#define DS5_IMU_STREAM_STATUS		0x100C
+#define DS5_IR_STREAM_STATUS		0x1014
+
+#define DS5_STREAM_DEPTH		0x0
+#define DS5_STREAM_RGB			0x1
+#define DS5_STREAM_IMU			0x2
+#define DS5_STREAM_IR			0x4
+#define DS5_STREAM_STOP			0x100
+#define DS5_STREAM_START		0x200
+#define DS5_STREAM_IDLE			0x1
+#define DS5_STREAM_STREAMING		0x2
+
+#define DS5_DEPTH_STREAM_DT		0x4000
+#define DS5_DEPTH_STREAM_MD		0x4002
+#define DS5_DEPTH_RES_WIDTH		0x4004
+#define DS5_DEPTH_RES_HEIGHT		0x4008
+#define DS5_DEPTH_FPS			0x400C
+#define DS5_DEPTH_OVERRIDE		0x401C
+
+#define DS5_RGB_STREAM_DT		0x4020
+#define DS5_RGB_STREAM_MD		0x4022
+#define DS5_RGB_RES_WIDTH		0x4024
+#define DS5_RGB_RES_HEIGHT		0x4028
+#define DS5_RGB_FPS			0x402C
+
+#define DS5_IMU_STREAM_DT		0x4040
+#define DS5_IMU_STREAM_MD		0x4042
+#define DS5_IMU_RES_WIDTH		0x4044
+#define DS5_IMU_RES_HEIGHT		0x4048
+#define DS5_IMU_FPS			0x404C
+
+#define DS5_IR_STREAM_DT		0x4080
+#define DS5_IR_STREAM_MD		0x4082
+#define DS5_IR_RES_WIDTH		0x4084
+#define DS5_IR_RES_HEIGHT		0x4088
+#define DS5_IR_FPS			0x408C
+#define DS5_IR_OVERRIDE			0x409C
+
+#define DS5_DEPTH_CONTROL_BASE		0x4100
+#define DS5_RGB_CONTROL_BASE		0x4200
+#define DS5_MANUAL_EXPOSURE_LSB		0x0000
+#define DS5_MANUAL_EXPOSURE_MSB		0x0002
+#define DS5_MANUAL_GAIN			0x0004
+#define DS5_LASER_POWER			0x0008
+#define DS5_AUTO_EXPOSURE_MODE		0x000C
+#define DS5_EXPOSURE_ROI_TOP		0x0010
+#define DS5_EXPOSURE_ROI_LEFT		0x0014
+#define DS5_EXPOSURE_ROI_BOTTOM		0x0018
+#define DS5_EXPOSURE_ROI_RIGHT		0x001C
+#define DS5_MANUAL_LASER_POWER		0x0024
+#define DS5_PWM_FREQUENCY		0x0028
+
+#define DS5_DEPTH_CONFIG_STATUS		0x4800
+#define DS5_RGB_CONFIG_STATUS		0x4802
+#define DS5_IMU_CONFIG_STATUS		0x4804
+#define DS5_IR_CONFIG_STATUS		0x4808
+
+#define DS5_STATUS_STREAMING		0x1
+#define DS5_STATUS_INVALID_DT		0x2
+#define DS5_STATUS_INVALID_RES		0x4
+#define DS5_STATUS_INVALID_FPS		0x8
+
+#define MIPI_LANE_RATE			1000
+
+#define MAX_DEPTH_EXP			200000
+#define MAX_RGB_EXP			10000
+#define DEF_DEPTH_EXP			33000
+#define DEF_RGB_EXP			1660
+
+/* Currently both depth and IR use VC 0 */
+#define DS5_DEPTH_VCHAN_N		0
+#define DS5_MOTION_T_VCHAN_N		0
+//#define DS5_DEBUG_VCHAN_N		1
+//#define DS5_MOTION_T_VCHAN_N		2
+
+#define D4XX_I2C_ADDRESS_1	0x12
+
+enum ds5_mux_pad {
+	DS5_MUX_PAD_EXTERNAL,
+	DS5_MUX_PAD_DEPTH_A,
+	DS5_MUX_PAD_RGB_A,
+	DS5_MUX_PAD_MOTION_T_A,
+	DS5_MUX_PAD_IMU_A,
+	DS5_MUX_PAD_DEPTH_B,
+	DS5_MUX_PAD_RGB_B,
+	DS5_MUX_PAD_MOTION_T_B,
+	DS5_MUX_PAD_IMU_B,
+	DS5_MUX_PAD_COUNT,
+};
+
+#define DS5_N_CONTROLS			8
+
+#define CSI2_MAX_VIRTUAL_CHANNELS	4
+
+#define DFU_WAIT_RET_LEN 6
+
+#define DS5_START_POLL_TIME	10
+#define DS5_START_MAX_TIME	1000
+#define DS5_START_MAX_COUNT	(DS5_START_MAX_TIME / DS5_START_POLL_TIME)
+
+/* DFU definition section */
+#define DFU_MAGIC_NUMBER "/0x01/0x02/0x03/0x04"
+#define DFU_BLOCK_SIZE 1024
+#define ds5_read_with_check(state, addr, val) {\
+	if (ds5_read(state, addr, val))	\
+		return -EINVAL; }
+#define ds5_raw_read_with_check(state, addr, buf, size)	{\
+	if (ds5_raw_read(state, addr, buf, size))	\
+		return -EINVAL; }
+#define ds5_write_with_check(state, addr, val) {\
+	if (ds5_write(state, addr, val))	\
+		return -EINVAL; }
+#define ds5_raw_write_with_check(state, addr, buf, size) {\
+	if (ds5_raw_write(state, addr, buf, size)) \
+		return -EINVAL; }
+#define max9296_write_8_with_check(state, addr, buf) {\
+	if (max9296_write_8(state, addr, buf)) \
+		return -EINVAL; \
+	}
+#define max9295_write_8_with_check(state, addr, buf) {\
+	if (max9295_write_8(state, addr, buf)) \
+		return -EINVAL; \
+	}
+#define D4XX_LINK_FREQ_360MHZ		360000000ULL
+#define D4XX_LINK_FREQ_300MHZ		300000000ULL
+#define D4XX_LINK_FREQ_288MHZ		288000000ULL
+#define D4XX_LINK_FREQ_240MHZ		240000000ULL
+#define D4XX_LINK_FREQ_225MHZ		22500000ULL
+
+enum dfu_fw_state {
+	appIDLE                = 0x0000,
+	appDETACH              = 0x0001,
+	dfuIDLE                = 0x0002,
+	dfuDNLOAD_SYNC         = 0x0003,
+	dfuDNBUSY              = 0x0004,
+	dfuDNLOAD_IDLE         = 0x0005,
+	dfuMANIFEST_SYNC       = 0x0006,
+	dfuMANIFEST            = 0x0007,
+	dfuMANIFEST_WAIT_RESET = 0x0008,
+	dfuUPLOAD_IDLE         = 0x0009,
+	dfuERROR               = 0x000a
+};
+
+enum dfu_state {
+	DS5_DFU_IDLE = 0,
+	DS5_DFU_RECOVERY,
+	DS5_DFU_OPEN,
+	DS5_DFU_IN_PROGRESS,
+	DS5_DFU_DONE,
+	DS5_DFU_ERROR
+} dfu_state_t;
+
+struct hwm_cmd {
+	u16 header;
+	u16 magic_word;
+	u32 opcode;
+	u32 param1;
+	u32 param2;
+	u32 param3;
+	u32 param4;
+	unsigned char Data[0];
+};
+
+static const struct hwm_cmd cmd_switch_to_dfu = {
+	.header = 0x14,
+	.magic_word = 0xCDAB,
+	.opcode = 0x1e,
+	.param1 = 0x01,
+};
+
+enum table_id {
+	COEF_CALIBRATION_ID = 0x19,
+	DEPTH_CALIBRATION_ID = 0x1f,
+	RGB_CALIBRATION_ID = 0x20,
+	IMU_CALIBRATION_ID = 0x22
+} table_id_t;
+
+static const struct hwm_cmd get_calib_data = {
+	.header = 0x14,
+	.magic_word = 0xCDAB,
+	.opcode = 0x15,
+	.param1 = 0x00,	//table_id
+};
+
+static const struct hwm_cmd set_calib_data = {
+	.header = 0x0114,
+	.magic_word = 0xCDAB,
+	.opcode = 0x62,
+	.param1 = 0x00,	//table_id
+	.param2 = 0x02,	//region
+};
+
+static const struct hwm_cmd gvd = {
+	.header = 0x14,
+	.magic_word = 0xCDAB,
+	.opcode = 0x10,
+};
+
+static const struct hwm_cmd set_ae_roi = {
+	.header = 0x14,
+	.magic_word = 0xCDAB,
+	.opcode = 0x44,
+};
+
+static const struct hwm_cmd get_ae_roi = {
+	.header = 0x014,
+	.magic_word = 0xCDAB,
+	.opcode = 0x45,
+};
+
+static const struct hwm_cmd set_ae_setpoint = {
+	.header = 0x18,
+	.magic_word = 0xCDAB,
+	.opcode = 0x2B,
+	.param1 = 0xa, // AE control
+};
+
+static const struct hwm_cmd get_ae_setpoint = {
+	.header = 0x014,
+	.magic_word = 0xCDAB,
+	.opcode = 0x2C,
+	.param1 = 0xa, // AE control
+	.param2 = 0, // get current
+};
+
+static const struct hwm_cmd erb = {
+	.header = 0x14,
+	.magic_word = 0xCDAB,
+	.opcode = 0x17,
+};
+
+static const struct hwm_cmd ewb = {
+	.header = 0x14,
+	.magic_word = 0xCDAB,
+	.opcode = 0x18,
+};
+
+static const s64 link_freq_menu_items[] = {
+	D4XX_LINK_FREQ_360MHZ,
+	D4XX_LINK_FREQ_300MHZ,
+	D4XX_LINK_FREQ_288MHZ,
+	D4XX_LINK_FREQ_240MHZ,
+	D4XX_LINK_FREQ_225MHZ,
+};
+
+struct __fw_status {
+	uint32_t	spare1;
+	uint32_t	FW_lastVersion;
+	uint32_t	FW_highestVersion;
+	uint16_t	FW_DownloadStatus;
+	uint16_t	DFU_isLocked;
+	uint16_t	DFU_version;
+	uint8_t		ivcamSerialNum[8];
+	uint8_t		spare2[42];
+};
+
+/*************************/
+
+struct ds5_ctrls {
+	struct v4l2_ctrl_handler handler;
+	struct v4l2_ctrl_handler handler_depth;
+	struct v4l2_ctrl_handler handler_rgb;
+	struct v4l2_ctrl_handler handler_y8;
+	struct v4l2_ctrl_handler handler_imu;
+	struct {
+		struct v4l2_ctrl *log;
+		struct v4l2_ctrl *fw_version;
+		struct v4l2_ctrl *gvd;
+		struct v4l2_ctrl *get_depth_calib;
+		struct v4l2_ctrl *set_depth_calib;
+		struct v4l2_ctrl *get_coeff_calib;
+		struct v4l2_ctrl *set_coeff_calib;
+		struct v4l2_ctrl *ae_roi_get;
+		struct v4l2_ctrl *ae_roi_set;
+		struct v4l2_ctrl *ae_setpoint_get;
+		struct v4l2_ctrl *ae_setpoint_set;
+		struct v4l2_ctrl *erb;
+		struct v4l2_ctrl *ewb;
+		struct v4l2_ctrl *hwmc;
+		struct v4l2_ctrl *laser_power;
+		struct v4l2_ctrl *manual_laser_power;
+		struct v4l2_ctrl *auto_exp;
+		struct v4l2_ctrl *exposure;
+		/* in DS5 manual gain only works with manual exposure */
+		struct v4l2_ctrl *gain;
+		struct v4l2_ctrl *link_freq;
+		struct v4l2_ctrl *query_sub_stream;
+		struct v4l2_ctrl *set_sub_stream;
+	};
+};
+
+struct ds5_resolution {
+	u16 width;
+	u16 height;
+	u8 n_framerates;
+	const u16 *framerates;
+};
+
+struct ds5_format {
+	unsigned int n_resolutions;
+	const struct ds5_resolution *resolutions;
+	u32 mbus_code;
+	u8 data_type;
+};
+
+struct ds5_sensor {
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_mbus_framefmt format;
+	u16 mux_pad;
+	struct {
+		const struct ds5_format *format;
+		const struct ds5_resolution *resolution;
+		u16 framerate;
+	} config;
+	bool streaming;
+	/*struct ds5_vchan *vchan;*/
+	const struct ds5_format *formats;
+	unsigned int n_formats;
+};
+
+struct ds5_des {
+	struct v4l2_subdev sd;
+	struct media_pad pads[2];
+	struct v4l2_mbus_framefmt format;
+	u16 mux_pad;
+};
+
+#ifdef CONFIG_TEGRA_CAMERA_PLATFORM
+#include <media/camera_common.h>
+#define ds5_mux_subdev camera_common_data
+#else
+struct ds5_mux_subdev {
+	struct v4l2_subdev subdev;
+};
+#endif
+
+struct ds5_variant {
+	const struct ds5_format *formats;
+	unsigned int n_formats;
+};
+
+struct ds5_dfu_dev {
+	struct cdev ds5_cdev;
+	struct class *ds5_class;
+	int device_open_count;
+	enum dfu_state dfu_state_flag;
+	unsigned char *dfu_msg;
+	u16 msg_write_once;
+	unsigned char init_v4l_f;
+};
+
+enum {
+	DS5_DS5U,
+	DS5_ASR,
+	DS5_AWG,
+};
+
+#define NR_OF_DS5_PADS 7
+#define NR_OF_DS5_STREAMS (NR_OF_DS5_PADS - 1)
+
+struct v4l2_mbus_framefmt ds5_ffmts[NR_OF_DS5_PADS];
+
+struct ds5 {
+	struct {
+		struct ds5_sensor sensor;
+	} depth;
+	struct {
+		struct ds5_sensor sensor;
+	} motion_t;
+	struct {
+		struct ds5_sensor sensor;
+	} rgb;
+	struct {
+		struct ds5_sensor sensor;
+	} imu;
+	struct {
+		struct ds5_des des;
+	} max9296;
+	struct {
+		struct ds5_mux_subdev sd;
+		struct media_pad pads[DS5_MUX_PAD_COUNT];
+		struct ds5_sensor *last_set;
+	} mux;
+	struct ds5_ctrls ctrls;
+	struct ds5_dfu_dev dfu_dev;
+	bool power;
+	struct i2c_client *client;
+	/*struct ds5_vchan virtual_channels[CSI2_MAX_VIRTUAL_CHANNELS];*/
+	/* All below pointers are used for writing, cannot be const */
+	struct mutex lock;
+	struct regmap *regmap;
+	struct regmap *regmap_max9296;
+	struct regmap *regmap_max9295;
+	struct regulator *vcc;
+	const struct ds5_variant *variant;
+	int is_depth;
+	int is_y8;
+	int is_rgb;
+	int is_imu;
+	u16 fw_version;
+	u16 fw_build;
+};
+
+struct ds5_counters {
+	unsigned int n_res;
+	unsigned int n_fmt;
+	unsigned int n_ctrl;
+};
+
+#define ds5_from_depth_sd(sd) container_of(sd, struct ds5, depth.sd)
+#define ds5_from_motion_t_sd(sd) container_of(sd, struct ds5, motion_t.sd)
+#define ds5_from_rgb_sd(sd) container_of(sd, struct ds5, rgb.sd)
+
+static inline void msleep_range(unsigned int delay_base)
+{
+	usleep_range(delay_base * 1000, delay_base * 1000 + 500);
+}
+
+static int max9296_write_8(struct ds5 *state, u16 reg, u8 val)
+{
+	int ret;
+
+	ret = regmap_raw_write(state->regmap_max9296, reg, &val, 1);
+	if (ret < 0)
+		dev_err(&state->client->dev, "%s(): i2c write failed %d, 0x%04x = 0x%x\n",
+			__func__, ret, reg, val);
+	else
+		if (state->dfu_dev.dfu_state_flag == DS5_DFU_IDLE)
+			dev_dbg(&state->client->dev, "%s(): i2c write 0x%04x: 0x%x\n",
+				 __func__, reg, val);
+
+	return ret;
+}
+
+static int max9296_read_8(struct ds5 *state, u16 reg, u8 *val)
+{
+	int ret;
+
+	ret = regmap_raw_read(state->regmap_max9296, reg, val, 1);
+	if (ret < 0)
+		dev_err(&state->client->dev, "%s(): i2c read failed %d, 0x%04x\n",
+			__func__, ret, reg);
+	else
+		if (state->dfu_dev.dfu_state_flag == DS5_DFU_IDLE)
+			dev_info(&state->client->dev, "%s(): i2c read 0x%04x = 0x%x\n",
+				 __func__, reg, *val);
+
+	return ret;
+}
+static int max9295_write_8(struct ds5 *state, u16 reg, u8 val)
+{
+	int ret;
+
+	ret = regmap_raw_write(state->regmap_max9295, reg, &val, 1);
+	if (ret < 0)
+		dev_err(&state->client->dev, "%s(): i2c write failed %d, 0x%04x = 0x%x\n",
+			__func__, ret, reg, val);
+	else
+		if (state->dfu_dev.dfu_state_flag == DS5_DFU_IDLE)
+			dev_info(&state->client->dev, "%s(): i2c write 0x%04x: 0x%x\n",
+				 __func__, reg, val);
+
+	return ret;
+}
+
+static int ds5_write_8(struct ds5 *state, u16 reg, u8 val)
+{
+	int ret;
+
+	ret = regmap_raw_write(state->regmap, reg, &val, 1);
+	if (ret < 0)
+		dev_err(&state->client->dev, "%s(): i2c write failed %d, 0x%04x = 0x%x\n",
+			__func__, ret, reg, val);
+	else
+		if (state->dfu_dev.dfu_state_flag == DS5_DFU_IDLE)
+			dev_info(&state->client->dev, "%s(): i2c write 0x%04x: 0x%x\n",
+				 __func__, reg, val);
+
+	return ret;
+}
+
+static int ds5_write(struct ds5 *state, u16 reg, u16 val)
+{
+	int ret;
+	u8 value[2];
+
+	value[1] = val >> 8;
+	value[0] = val & 0x00FF;
+
+	dev_dbg(&state->client->dev,
+			"%s(): writing to register: 0x%04x, value1: 0x%x, value2:0x%x\n",
+			__func__, reg, value[1], value[0]);
+
+	ret = regmap_raw_write(state->regmap, reg, value, sizeof(value));
+	if (ret < 0)
+		dev_err(&state->client->dev,
+				"%s(): i2c write failed %d, 0x%04x = 0x%x\n",
+				__func__, ret, reg, val);
+	else
+		if (state->dfu_dev.dfu_state_flag == DS5_DFU_IDLE)
+			dev_dbg(&state->client->dev, "%s(): i2c write 0x%04x: 0x%x\n",
+				__func__, reg, val);
+
+	return ret;
+}
+
+static int ds5_raw_write(struct ds5 *state, u16 reg,
+		const void *val, size_t val_len)
+{
+	int ret = regmap_raw_write(state->regmap, reg, val, val_len);
+	if (ret < 0)
+		dev_err(&state->client->dev,
+				"%s(): i2c raw write failed %d, %04x size(%d) bytes\n",
+				__func__, ret, reg, (int)val_len);
+	else
+		if (state->dfu_dev.dfu_state_flag == DS5_DFU_IDLE)
+			dev_dbg(&state->client->dev,
+					"%s(): i2c raw write 0x%04x: %d bytes\n",
+					__func__, reg, (int)val_len);
+
+	return ret;
+}
+
+static int ds5_read(struct ds5 *state, u16 reg, u16 *val)
+{
+	int ret = regmap_raw_read(state->regmap, reg, val, 2);
+	if (ret < 0)
+		dev_err(&state->client->dev, "%s(): i2c read failed %d, 0x%04x\n",
+				__func__, ret, reg);
+	else {
+		if (state->dfu_dev.dfu_state_flag == DS5_DFU_IDLE)
+			dev_dbg(&state->client->dev, "%s(): i2c read 0x%04x: 0x%x\n",
+					__func__, reg, *val);
+	}
+
+	return ret;
+}
+
+static int ds5_raw_read(struct ds5 *state, u16 reg, void *val, size_t val_len)
+{
+	int ret = regmap_raw_read(state->regmap, reg, val, val_len);
+	if (ret < 0)
+		dev_err(&state->client->dev, "%s(): i2c read failed %d, 0x%04x\n",
+			__func__, ret, reg);
+
+	return ret;
+}
+
+static int pad_to_substream[DS5_MUX_PAD_COUNT];
+
+static s64 d4xx_query_sub_stream[] = {
+	0, 0, 0, 0, 0, 0
+};
+
+static void set_sub_stream_fmt(int index, u32 code)
+{
+	d4xx_query_sub_stream[index] &= 0xFFFFFFFFFFFF0000;
+	d4xx_query_sub_stream[index] |= code;
+}
+
+static void set_sub_stream_h(int index, u32 height)
+{
+	s64 val = height;
+
+	val &= 0xFFFF;
+	d4xx_query_sub_stream[index] &= 0xFFFFFFFF0000FFFF;
+	d4xx_query_sub_stream[index] |= val << 16;
+}
+
+static void set_sub_stream_w(int index, u32 width)
+{
+	s64 val = width;
+
+	val &= 0xFFFF;
+	d4xx_query_sub_stream[index] &= 0xFFFF0000FFFFFFFF;
+	d4xx_query_sub_stream[index] |= val << 32;
+}
+
+static void set_sub_stream_dt(int index, u32 dt)
+{
+	s64 val = dt;
+
+	val &= 0xFF;
+	d4xx_query_sub_stream[index] &= 0xFF00FFFFFFFFFFFF;
+	d4xx_query_sub_stream[index] |= val << 48;
+}
+
+static void set_sub_stream_vc_id(int index, u32 vc_id)
+{
+	s64 val = vc_id;
+
+	val &= 0xFF;
+	d4xx_query_sub_stream[index] &= 0x00FFFFFFFFFFFFFF;
+	d4xx_query_sub_stream[index] |= val << 56;
+}
+
+static int get_sub_stream_vc_id(int index)
+{
+	s64 val = 0;
+
+	val = d4xx_query_sub_stream[index] >> 56;
+	val &= 0xFF;
+	return (int)val;
+}
+
+static u8 d4xx_set_sub_stream[] = {
+	0, 0, 0, 0, 0, 0
+};
+
+/* Pad ops */
+
+static const u16 ds5_default_framerate = 30;
+
+// **********************
+// FIXME: D16 width must be doubled, because an 8-bit format is used. Check how
+// the Tegra driver propagates resolutions and formats.
+// **********************
+
+//TODO: keep 6, till 5 is supported by FW
+static const u16 ds5_framerates[] = {5, 30};
+
+#define DS5_FRAMERATE_DEFAULT_IDX 1
+
+static const u16 ds5_framerate_30 = 30;
+
+static const u16 ds5_framerate_15_30[] = {15, 30};
+
+static const u16 ds5_framerate_25 = 25;
+
+static const u16 ds5_depth_framerate_to_30[] = {5, 15, 30};
+static const u16 ds5_framerate_to_30[] = {5, 10, 15, 30};
+static const u16 ds5_framerate_to_60[] = {5, 15, 30, 60};
+static const u16 ds5_framerate_to_90[] = {5, 15, 30, 60, 90};
+static const u16 ds5_framerate_100[] = {100};
+static const u16 ds5_framerate_90[] = {90};
+static const u16 ds5_imu_framerates[] = {50, 100, 200, 400};
+
+static const struct ds5_resolution d43x_depth_sizes[] = {
+	{
+		.width = 1280,
+		.height = 720,
+		.framerates = ds5_depth_framerate_to_30,
+		.n_framerates = ARRAY_SIZE(ds5_depth_framerate_to_30),
+	}, {
+		.width =  848,
+		.height = 480,
+		.framerates = ds5_framerate_to_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_90),
+	}, {
+		.width =  848,
+		.height = 100,
+		.framerates = ds5_framerate_100,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_100),
+	}, {
+		.width =  640,
+		.height = 480,
+		.framerates = ds5_framerate_to_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_90),
+	}, {
+		.width =  640,
+		.height = 360,
+		.framerates = ds5_framerate_to_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_90),
+	}, {
+		.width =  480,
+		.height = 270,
+		.framerates = ds5_framerate_to_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_90),
+	}, {
+		.width =  424,
+		.height = 240,
+		.framerates = ds5_framerate_to_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_90),
+	}, {
+		.width =  256,
+		.height = 144,
+		.framerates = ds5_framerate_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_90),
+	},
+};
+
+static const struct ds5_resolution d46x_depth_sizes[] = {
+	{
+		.width = 1280,
+		.height = 960,
+		.framerates = ds5_framerates,
+		.n_framerates = ARRAY_SIZE(ds5_framerates),
+	}, {
+		.width =  640,
+		.height = 480,
+		.framerates = ds5_framerates,
+		.n_framerates = ARRAY_SIZE(ds5_framerates),
+	},
+};
+
+static const struct ds5_resolution y8_sizes[] = {
+	{
+		.width = 1280,
+		.height = 720,
+		.framerates = ds5_depth_framerate_to_30,
+		.n_framerates = ARRAY_SIZE(ds5_depth_framerate_to_30),
+	}, {
+		.width =  848,
+		.height = 480,
+		.framerates = ds5_framerate_to_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_90),
+	}, {
+		.width =  640,
+		.height = 480,
+		.framerates = ds5_framerate_to_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_90),
+	}, {
+		.width =  640,
+		.height = 360,
+		.framerates = ds5_framerate_to_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_90),
+	}, {
+		.width =  480,
+		.height = 270,
+		.framerates = ds5_framerate_to_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_90),
+	}, {
+		.width =  424,
+		.height = 240,
+		.framerates = ds5_framerate_to_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_90),
+	}
+};
+
+static const struct ds5_resolution ds5_rlt_rgb_sizes[] = {
+	{
+		.width = 1280,
+		.height = 800,
+		.framerates = ds5_framerate_to_30,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_30),
+	}, {
+		.width = 1280,
+		.height = 720,
+		.framerates = ds5_framerate_to_30,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_30),
+	}, {
+		.width = 848,
+		.height = 480,
+		.framerates = ds5_framerate_to_60,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_60),
+	}, {
+		.width = 640,
+		.height = 480,
+		.framerates = ds5_framerate_to_60,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_60),
+	}, {
+		.width = 640,
+		.height = 360,
+		.framerates = ds5_framerate_to_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_90),
+	}, {
+		.width = 480,
+		.height = 270,
+		.framerates = ds5_framerate_to_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_90),
+	}, {
+		.width = 424,
+		.height = 240,
+		.framerates = ds5_framerate_to_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_90),
+	},
+};
+
+static const struct ds5_resolution ds5_onsemi_rgb_sizes[] = {
+	{
+		.width = 640,
+		.height = 480,
+		.framerates = ds5_framerate_to_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_90),
+	}, {
+		.width = 960,
+		.height = 720,
+		.framerates = ds5_framerate_to_60,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_60),
+	}, {
+		.width = 1280,
+		.height = 720,
+		.framerates = ds5_framerates,
+		.n_framerates = ARRAY_SIZE(ds5_framerates),
+	}, {
+		.width = 1920,
+		.height = 1080,
+		.framerates = ds5_framerates,
+		.n_framerates = ARRAY_SIZE(ds5_framerates),
+	}, {
+		.width = 2048,
+		.height = 1536,
+		.framerates = ds5_framerates,
+		.n_framerates = ARRAY_SIZE(ds5_framerates),
+	},
+};
+
+static const struct ds5_resolution ds5_size_w10 = {
+	.width =  1920,
+	.height = 1080,
+	.framerates = &ds5_framerate_30,
+	.n_framerates = 1,
+};
+
+static const struct ds5_resolution d43x_calibration_sizes[] = {
+	{
+		.width =  1280,
+		.height = 800,
+		.framerates = ds5_framerate_15_30,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_15_30),
+	},
+};
+
+static const struct ds5_resolution d46x_calibration_sizes[] = {
+	{
+		.width =  1600,
+		.height = 1300,
+		.framerates = ds5_framerate_15_30,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_15_30),
+	},
+};
+
+static const struct ds5_resolution ds5_size_imu[] = {
+	{
+	.width = 32,
+	.height = 1,
+	.framerates = ds5_imu_framerates,
+	.n_framerates = ARRAY_SIZE(ds5_imu_framerates),
+	},
+};
+
+static const struct ds5_format ds5_depth_formats_d43x[] = {
+	{
+		// TODO: 0x31 is replaced with 0x1e since it caused low FPS in Jetson.
+		.data_type = 0x1e,	/* UYVY */
+		.mbus_code = MEDIA_BUS_FMT_UYVY8_1X16,
+		.n_resolutions = ARRAY_SIZE(d43x_depth_sizes),
+		.resolutions = d43x_depth_sizes,
+	}, {
+		.data_type = 0x2a,	/* Y8 */
+		.mbus_code = MEDIA_BUS_FMT_Y8_1X8,
+		.n_resolutions = ARRAY_SIZE(d43x_depth_sizes),
+		.resolutions = d43x_depth_sizes,
+	}, {
+		.data_type = 0x24,	/* 24-bit Calibration */
+		.mbus_code = MEDIA_BUS_FMT_RGB888_1X24,	/* FIXME */
+		.n_resolutions = ARRAY_SIZE(d43x_calibration_sizes),
+		.resolutions = d43x_calibration_sizes,
+	},
+};
+
+static const struct ds5_format ds5_depth_formats_d46x[] = {
+	{
+		// TODO: 0x31 is replaced with 0x1e since it caused low FPS in Jetson.
+		.data_type = 0x1e,	/* Z16 */
+		.mbus_code = MEDIA_BUS_FMT_UYVY8_1X16,
+		.n_resolutions = ARRAY_SIZE(d46x_depth_sizes),
+		.resolutions = d46x_depth_sizes,
+	}, {
+		/* First format: default */
+		.data_type = 0x2a,	/* Y8 */
+		.mbus_code = MEDIA_BUS_FMT_Y8_1X8,
+		.n_resolutions = ARRAY_SIZE(d46x_depth_sizes),
+		.resolutions = d46x_depth_sizes,
+	}, {
+		.data_type = 0x24,	/* 24-bit Calibration */
+		.mbus_code = MEDIA_BUS_FMT_RGB888_1X24,	/* FIXME */
+		.n_resolutions = ARRAY_SIZE(d43x_calibration_sizes),
+		.resolutions = d43x_calibration_sizes,
+	},
+};
+
+#define DS5_DEPTH_N_FORMATS 1
+
+static const struct ds5_format ds5_y_formats_ds5u[] = {
+	{
+		/* First format: default */
+		.data_type = 0x2a,	/* Y8 */
+		.mbus_code = MEDIA_BUS_FMT_SBGGR8_1X8,
+		.n_resolutions = ARRAY_SIZE(y8_sizes),
+		.resolutions = y8_sizes,
+	}, {
+		.data_type = 0x1e,	/* Y8I */
+		.mbus_code = MEDIA_BUS_FMT_UYVY8_1X16,
+		.n_resolutions = ARRAY_SIZE(y8_sizes),
+		.resolutions = y8_sizes,
+	}, {
+		.data_type = 0x24,	/* 24-bit Calibration */
+		.mbus_code = MEDIA_BUS_FMT_RGB888_1X24,	/* FIXME */
+		.n_resolutions = ARRAY_SIZE(d43x_calibration_sizes),
+		.resolutions = d43x_calibration_sizes,
+	},
+};
+
+static const struct ds5_format ds5_rlt_rgb_format = {
+	.data_type = 0x1e,	/* UYVY */
+	.mbus_code = MEDIA_BUS_FMT_YUYV8_1X16,
+	.n_resolutions = ARRAY_SIZE(ds5_rlt_rgb_sizes),
+	.resolutions = ds5_rlt_rgb_sizes,
+};
+#define DS5_RLT_RGB_N_FORMATS 1
+
+static const struct ds5_format ds5_onsemi_rgb_format = {
+	.data_type = 0x1e,	/* UYVY */
+	.mbus_code = MEDIA_BUS_FMT_YUYV8_1X16,
+	.n_resolutions = ARRAY_SIZE(ds5_onsemi_rgb_sizes),
+	.resolutions = ds5_onsemi_rgb_sizes,
+};
+#define DS5_ONSEMI_RGB_N_FORMATS 1
+
+static const struct ds5_variant ds5_variants[] = {
+	[DS5_DS5U] = {
+		.formats = ds5_y_formats_ds5u,
+		.n_formats = ARRAY_SIZE(ds5_y_formats_ds5u),
+	},
+};
+
+static const struct ds5_format ds5_imu_formats[] = {
+	{
+		/* First format: default */
+		.data_type = 0x2a,	/* IMU DT */
+		.mbus_code = MEDIA_BUS_FMT_Y8_1X8,
+		.n_resolutions = ARRAY_SIZE(ds5_size_imu),
+		.resolutions = ds5_size_imu,
+	},
+};
+
+static const struct v4l2_mbus_framefmt ds5_mbus_framefmt_template = {
+	.width = 0,
+	.height = 0,
+	.code = MEDIA_BUS_FMT_FIXED,
+	.field = V4L2_FIELD_NONE,
+	.colorspace = V4L2_COLORSPACE_DEFAULT,
+	.ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT,
+	.quantization = V4L2_QUANTIZATION_DEFAULT,
+	.xfer_func = V4L2_XFER_FUNC_DEFAULT,
+};
+
+/* Get readable sensor name */
+static const char *ds5_get_sensor_name(struct ds5 *state)
+{
+	static const char *sensor_name[] = {"unknown", "RGB", "DEPTH", "Y8", "IMU"};
+	int sensor_id = state->is_rgb * 1 + state->is_depth * 2 + \
+			state->is_y8 * 3 + state->is_imu * 4;
+	if (sensor_id >= (sizeof(sensor_name)/sizeof(*sensor_name)))
+		sensor_id = 0;
+
+	return sensor_name[sensor_id];
+}
+
+static void ds5_set_state_last_set(struct ds5 *state)
+{
+	 dev_info(&state->client->dev, "%s(): %s\n",
+		__func__, ds5_get_sensor_name(state));
+
+	if (state->is_depth)
+		state->mux.last_set = &state->depth.sensor;
+	else if (state->is_rgb)
+		state->mux.last_set = &state->rgb.sensor;
+	else if (state->is_y8)
+		state->mux.last_set = &state->motion_t.sensor;
+	else
+		state->mux.last_set = &state->imu.sensor;
+}
+
+/* This is needed for .get_fmt()
+ * and if streaming is started without .set_fmt()
+ */
+static void ds5_sensor_format_init(struct ds5_sensor *sensor)
+{
+	const struct ds5_format *fmt;
+	struct v4l2_mbus_framefmt *ffmt;
+	unsigned int i;
+
+	if (sensor->config.format)
+		return;
+
+	dev_info(sensor->sd.dev, "%s(): on pad %u\n", __func__, sensor->mux_pad);
+
+	ffmt = &sensor->format;
+	*ffmt = ds5_mbus_framefmt_template;
+	/* Use the first format */
+	fmt = sensor->formats;
+	ffmt->code = fmt->mbus_code;
+	/* and the first resolution */
+	ffmt->width = fmt->resolutions->width;
+	ffmt->height = fmt->resolutions->height;
+
+	sensor->config.format = fmt;
+	sensor->config.resolution = fmt->resolutions;
+	/* Set default framerate to 30, or to 1st one if not supported */
+	for (i = 0; i < fmt->resolutions->n_framerates; i++) {
+		if (fmt->resolutions->framerates[i] == ds5_framerate_30 /* fps */) {
+			sensor->config.framerate = ds5_framerate_30;
+			return;
+		}
+	}
+	sensor->config.framerate = fmt->resolutions->framerates[0];
+}
+
+/* No locking needed for enumeration methods */
+static int ds5_sensor_enum_mbus_code(struct v4l2_subdev *sd,
+				     struct v4l2_subdev_state *v4l2_state,
+				     struct v4l2_subdev_mbus_code_enum *mce)
+{
+	struct ds5_sensor *sensor = container_of(sd, struct ds5_sensor, sd);
+	//struct ds5_vchan *vchan = sensor->vchan;
+	dev_info(sensor->sd.dev, "%s(): sensor %s pad: %d index: %d\n",
+		__func__, sensor->sd.name, mce->pad, mce->index);
+	if (mce->pad)
+		return -EINVAL;
+
+	if (mce->index >= sensor->n_formats)
+		return -EINVAL;
+
+	mce->code = sensor->formats[mce->index].mbus_code;
+
+	return 0;
+}
+
+static int ds5_sensor_enum_frame_size(struct v4l2_subdev *sd,
+				     struct v4l2_subdev_state *v4l2_state,
+				      struct v4l2_subdev_frame_size_enum *fse)
+{
+	struct ds5_sensor *sensor = container_of(sd, struct ds5_sensor, sd);
+	struct ds5 *state = v4l2_get_subdevdata(sd);
+	const struct ds5_format *fmt;
+	unsigned int i;
+
+	dev_info(sensor->sd.dev, "%s(): sensor %s is %s\n",
+		__func__, sensor->sd.name, ds5_get_sensor_name(state));
+
+	for (i = 0, fmt = sensor->formats; i < sensor->n_formats; i++, fmt++)
+		if (fse->code == fmt->mbus_code)
+			break;
+
+	if (i == sensor->n_formats)
+		return -EINVAL;
+
+	if (fse->index >= fmt->n_resolutions)
+		return -EINVAL;
+
+	fse->min_width = fse->max_width = fmt->resolutions[fse->index].width;
+	fse->min_height = fse->max_height = fmt->resolutions[fse->index].height;
+
+	return 0;
+}
+
+static int ds5_sensor_enum_frame_interval(struct v4l2_subdev *sd,
+				     struct v4l2_subdev_state *v4l2_state,
+					  struct v4l2_subdev_frame_interval_enum *fie)
+{
+	struct ds5_sensor *sensor = container_of(sd, struct ds5_sensor, sd);
+	const struct ds5_format *fmt;
+	const struct ds5_resolution *res;
+	unsigned int i;
+
+	for (i = 0, fmt = sensor->formats; i < sensor->n_formats; i++, fmt++)
+		if (fie->code == fmt->mbus_code)
+			break;
+
+	if (i == sensor->n_formats)
+		return -EINVAL;
+
+	for (i = 0, res = fmt->resolutions; i < fmt->n_resolutions; i++, res++)
+		if (res->width == fie->width && res->height == fie->height)
+			break;
+
+	if (i == fmt->n_resolutions)
+		return -EINVAL;
+
+	if (fie->index >= res->n_framerates)
+		return -EINVAL;
+
+	fie->interval.numerator = 1;
+	fie->interval.denominator = res->framerates[fie->index];
+
+	return 0;
+}
+
+static int ds5_sensor_get_fmt(struct v4l2_subdev *sd,
+				     struct v4l2_subdev_state *v4l2_state,
+			      struct v4l2_subdev_format *fmt)
+{
+	struct ds5_sensor *sensor = container_of(sd, struct ds5_sensor, sd);
+	struct ds5 *state = v4l2_get_subdevdata(sd);
+
+	if (fmt->pad)
+		return -EINVAL;
+
+	mutex_lock(&state->lock);
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY)
+		fmt->format = *v4l2_subdev_get_try_format(sd, v4l2_state, fmt->pad);
+	else
+		fmt->format = sensor->format;
+
+	mutex_unlock(&state->lock);
+
+	dev_info(sd->dev, "%s(): pad %x, code %x, res %ux%u\n",
+			__func__, fmt->pad, fmt->format.code,
+			fmt->format.width, fmt->format.height);
+
+	return 0;
+}
+
+/* Called with lock held */
+static const struct ds5_format *ds5_sensor_find_format(
+		struct ds5_sensor *sensor,
+		struct v4l2_mbus_framefmt *ffmt,
+		const struct ds5_resolution **best)
+{
+	const struct ds5_resolution *res;
+	const struct ds5_format *fmt;
+	unsigned long best_delta = ~0;
+	unsigned int i;
+
+	for (i = 0, fmt = sensor->formats; i < sensor->n_formats; i++, fmt++) {
+		if (fmt->mbus_code == ffmt->code)
+			break;
+	}
+	dev_info(sensor->sd.dev, "%s(): mbus_code = %x, code = %x \n",
+		__func__, fmt->mbus_code, ffmt->code);
+
+	if (i == sensor->n_formats) {
+		/* Not found, use default */
+		dev_dbg(sensor->sd.dev, "%s:%d Not found, use default\n",
+			__func__, __LINE__);
+		fmt = sensor->formats;
+	}
+	for (i = 0, res = fmt->resolutions; i < fmt->n_resolutions; i++, res++) {
+		unsigned long delta = abs(ffmt->width * ffmt->height -
+				res->width * res->height);
+		if (delta < best_delta) {
+			best_delta = delta;
+			*best = res;
+		}
+	}
+
+	ffmt->code = fmt->mbus_code;
+	ffmt->width = (*best)->width;
+	ffmt->height = (*best)->height;
+
+	ffmt->field = V4L2_FIELD_NONE;
+	/* Should we use V4L2_COLORSPACE_RAW for Y12I? */
+	ffmt->colorspace = V4L2_COLORSPACE_SRGB;
+
+	return fmt;
+}
+
+#define MIPI_CSI2_TYPE_NULL	0x10
+#define MIPI_CSI2_TYPE_BLANKING		0x11
+#define MIPI_CSI2_TYPE_EMBEDDED8	0x12
+#define MIPI_CSI2_TYPE_YUV422_8		0x1e
+#define MIPI_CSI2_TYPE_YUV422_10	0x1f
+#define MIPI_CSI2_TYPE_RGB565	0x22
+#define MIPI_CSI2_TYPE_RGB888	0x24
+#define MIPI_CSI2_TYPE_RAW6	0x28
+#define MIPI_CSI2_TYPE_RAW7	0x29
+#define MIPI_CSI2_TYPE_RAW8	0x2a
+#define MIPI_CSI2_TYPE_RAW10	0x2b
+#define MIPI_CSI2_TYPE_RAW12	0x2c
+#define MIPI_CSI2_TYPE_RAW14	0x2d
+/* 1-8 */
+#define MIPI_CSI2_TYPE_USER_DEF(i)	(0x30 + (i) - 1)
+
+static unsigned int mbus_code_to_mipi(u32 code)
+{
+	switch (code) {
+	case MEDIA_BUS_FMT_RGB565_1X16:
+		return MIPI_CSI2_TYPE_RGB565;
+	case MEDIA_BUS_FMT_RGB888_1X24:
+		return MIPI_CSI2_TYPE_RGB888;
+	case MEDIA_BUS_FMT_YUYV10_1X20:
+		return MIPI_CSI2_TYPE_YUV422_10;
+	case MEDIA_BUS_FMT_UYVY8_1X16:
+	case MEDIA_BUS_FMT_YUYV8_1X16:
+	case MEDIA_BUS_FMT_VYUY8_1X16:
+		return MIPI_CSI2_TYPE_YUV422_8;
+	case MEDIA_BUS_FMT_SBGGR12_1X12:
+	case MEDIA_BUS_FMT_SGBRG12_1X12:
+	case MEDIA_BUS_FMT_SGRBG12_1X12:
+	case MEDIA_BUS_FMT_SRGGB12_1X12:
+		return MIPI_CSI2_TYPE_RAW12;
+	case MEDIA_BUS_FMT_Y10_1X10:
+	case MEDIA_BUS_FMT_SBGGR10_1X10:
+	case MEDIA_BUS_FMT_SGBRG10_1X10:
+	case MEDIA_BUS_FMT_SGRBG10_1X10:
+	case MEDIA_BUS_FMT_SRGGB10_1X10:
+		return MIPI_CSI2_TYPE_RAW10;
+	case MEDIA_BUS_FMT_Y8_1X8:
+	case MEDIA_BUS_FMT_SBGGR8_1X8:
+	case MEDIA_BUS_FMT_SGBRG8_1X8:
+	case MEDIA_BUS_FMT_SGRBG8_1X8:
+	case MEDIA_BUS_FMT_SRGGB8_1X8:
+		return MIPI_CSI2_TYPE_RAW8;
+	case MEDIA_BUS_FMT_SBGGR10_DPCM8_1X8:
+	case MEDIA_BUS_FMT_SGBRG10_DPCM8_1X8:
+	case MEDIA_BUS_FMT_SGRBG10_DPCM8_1X8:
+	case MEDIA_BUS_FMT_SRGGB10_DPCM8_1X8:
+		return MIPI_CSI2_TYPE_USER_DEF(1);
+	default:
+		WARN_ON(1);
+		return -EINVAL;
+	}
+}
+
+static int __ds5_sensor_set_fmt(struct ds5 *state, struct ds5_sensor *sensor,
+				     struct v4l2_subdev_state *v4l2_state,
+				struct v4l2_subdev_format *fmt)
+{
+	struct v4l2_mbus_framefmt *mf;// = &fmt->format;
+	int substream = -1;
+	//unsigned r;
+
+	dev_dbg(sensor->sd.dev, "%s(): state %p, "
+		"sensor %p, fmt %p, fmt->format %p\n",
+		__func__, state, sensor, fmt,  &fmt->format);
+
+	mf = &fmt->format;
+
+	if (fmt->pad)
+		return -EINVAL;
+
+	mutex_lock(&state->lock);
+
+	sensor->config.format = ds5_sensor_find_format(sensor, mf,
+						&sensor->config.resolution);
+	//r = DS5_FRAMERATE_DEFAULT_IDX < sensor->config.resolution->n_framerates ?
+	//	DS5_FRAMERATE_DEFAULT_IDX : 0;
+	/* FIXME: check if a framerate has been set */
+	//sensor->config.framerate = sensor->config.resolution->framerates[r];
+
+	if (v4l2_state && fmt->which == V4L2_SUBDEV_FORMAT_TRY)
+		*v4l2_subdev_get_try_format(&sensor->sd, v4l2_state, fmt->pad) = *mf;
+
+	else
+// FIXME: use this format in .s_stream()
+		sensor->format = *mf;
+
+	state->mux.last_set = sensor;
+
+	mutex_unlock(&state->lock);
+
+	substream = pad_to_substream[sensor->mux_pad];
+
+	if (substream != -1) {
+		set_sub_stream_fmt(substream, mf->code);
+		set_sub_stream_h(substream, mf->height);
+		set_sub_stream_w(substream, mf->width);
+		set_sub_stream_dt(substream, mbus_code_to_mipi(mf->code));
+	}
+
+	dev_info(sensor->sd.dev, "%s(): fmt->pad: %d, sensor->mux_pad: %d, code: 0x%x, %ux%u substream:%d\n", __func__,
+		fmt->pad, sensor->mux_pad, fmt->format.code,
+		fmt->format.width, fmt->format.height, substream);
+
+	return 0;
+}
+
+static int ds5_sensor_set_fmt(struct v4l2_subdev *sd,
+				     struct v4l2_subdev_state *v4l2_state,
+			      struct v4l2_subdev_format *fmt)
+{
+	struct ds5_sensor *sensor = container_of(sd, struct ds5_sensor, sd);
+	struct ds5 *state = v4l2_get_subdevdata(sd);
+
+	return __ds5_sensor_set_fmt(state, sensor, v4l2_state, fmt);
+}
+
+static int ds5_configure(struct ds5 *state)
+{
+	struct ds5_sensor *sensor;
+	u16 fmt, md_fmt, vc_id;
+	u16 dt_addr, md_addr, override_addr, fps_addr, width_addr, height_addr;
+	int ret;
+
+	if (state->is_depth) {
+		sensor = &state->depth.sensor;
+		dt_addr = DS5_DEPTH_STREAM_DT;
+		md_addr = DS5_DEPTH_STREAM_MD;
+		override_addr = DS5_DEPTH_OVERRIDE;
+		fps_addr = DS5_DEPTH_FPS;
+		width_addr = DS5_DEPTH_RES_WIDTH;
+		height_addr = DS5_DEPTH_RES_HEIGHT;
+		md_fmt = 0x12;
+		vc_id = 0;
+	} else if (state->is_rgb) {
+		sensor = &state->rgb.sensor;
+		dt_addr = DS5_RGB_STREAM_DT;
+		md_addr = DS5_RGB_STREAM_MD;
+		override_addr = 0;
+		fps_addr = DS5_RGB_FPS;
+		width_addr = DS5_RGB_RES_WIDTH;
+		height_addr = DS5_RGB_RES_HEIGHT;
+		md_fmt = 0x12;
+		vc_id = 1;
+	} else if (state->is_y8) {
+		sensor = &state->motion_t.sensor;
+		dt_addr = DS5_IR_STREAM_DT;
+		md_addr = DS5_IR_STREAM_MD;
+		override_addr = DS5_IR_OVERRIDE;
+		fps_addr = DS5_IR_FPS;
+		width_addr = DS5_IR_RES_WIDTH;
+		height_addr = DS5_IR_RES_HEIGHT;
+		md_fmt = 0x12;
+		vc_id = 2;
+	} else if (state->is_imu) {
+		sensor = &state->imu.sensor;
+		dt_addr = DS5_IMU_STREAM_DT;
+		md_addr = DS5_IMU_STREAM_MD;
+		override_addr = 0;
+		fps_addr = DS5_IMU_FPS;
+		width_addr = DS5_IMU_RES_WIDTH;
+		height_addr = DS5_IMU_RES_HEIGHT;
+		vc_id = 3;
+		md_fmt = 0x0;
+	} else {
+		return -EINVAL;
+	}
+
+	fmt = sensor->streaming ? sensor->config.format->data_type : 0;
+
+	/*
+	 * Set depth stream Z16 data type as 0x31
+	 * Set IR stream Y8I data type as 0x32
+	 */
+	if (state->is_depth && fmt != 0)
+		ret = ds5_write(state, dt_addr, 0x31);
+	else if (state->is_y8 && fmt != 0 &&
+		 sensor->config.format->data_type == 0x1E)
+		ret = ds5_write(state, dt_addr, 0x32);
+	else
+		ret = ds5_write(state, dt_addr, fmt);
+	if (ret < 0)
+		return ret;
+
+	ret = ds5_write(state, md_addr, (vc_id << 8) | md_fmt);
+	if (ret < 0)
+		return ret;
+
+	if (!sensor->streaming)
+		return ret;
+
+	if (override_addr != 0) {
+		ret = ds5_write(state, override_addr, fmt);
+		if (ret < 0)
+			return ret;
+	}
+
+	ret = ds5_write(state, fps_addr, sensor->config.framerate);
+	if (ret < 0)
+		return ret;
+
+	ret = ds5_write(state, width_addr, sensor->config.resolution->width);
+	if (ret < 0)
+		return ret;
+
+	ret = ds5_write(state, height_addr, sensor->config.resolution->height);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static const struct v4l2_subdev_pad_ops ds5_depth_pad_ops = {
+	.enum_mbus_code		= ds5_sensor_enum_mbus_code,
+	.enum_frame_size	= ds5_sensor_enum_frame_size,
+	.enum_frame_interval	= ds5_sensor_enum_frame_interval,
+	.get_fmt		= ds5_sensor_get_fmt,
+	.set_fmt		= ds5_sensor_set_fmt,
+};
+
+static int ds5_sensor_g_frame_interval(struct v4l2_subdev *sd,
+		struct v4l2_subdev_frame_interval *fi)
+{
+	struct ds5_sensor *sensor = container_of(sd, struct ds5_sensor, sd);
+
+	if (NULL == sd || NULL == fi)
+		return -EINVAL;
+
+	fi->interval.numerator = 1;
+	fi->interval.denominator = sensor->config.framerate;
+
+	dev_info(sd->dev, "%s(): %s %u\n", __func__, sd->name,
+			fi->interval.denominator);
+
+	return 0;
+}
+static u16 __ds5_probe_framerate(const struct ds5_resolution *res, u16 target);
+
+static int ds5_sensor_s_frame_interval(struct v4l2_subdev *sd,
+		struct v4l2_subdev_frame_interval *fi)
+{
+	struct ds5_sensor *sensor = container_of(sd, struct ds5_sensor, sd);
+	u16 framerate = 1;
+
+	if (NULL == sd || NULL == fi || fi->interval.numerator == 0)
+		return -EINVAL;
+
+	framerate = fi->interval.denominator / fi->interval.numerator;
+	framerate = __ds5_probe_framerate(sensor->config.resolution, framerate);
+	sensor->config.framerate = framerate;
+	fi->interval.numerator = 1;
+	fi->interval.denominator = framerate;
+
+	dev_info(sd->dev, "%s(): %s %u\n", __func__, sd->name, framerate);
+
+	return 0;
+}
+
+static int ds5_sensor_s_stream(struct v4l2_subdev *sd, int on)
+{
+	struct ds5_sensor *sensor = container_of(sd, struct ds5_sensor, sd);
+
+	dev_info(sensor->sd.dev, "%s(): sensor: name=%s state=%d\n", __func__, sensor->sd.name, on);
+
+	sensor->streaming = on;
+
+	return 0;
+}
+
+static const struct v4l2_subdev_video_ops ds5_sensor_video_ops = {
+	.g_frame_interval	= ds5_sensor_g_frame_interval,
+	.s_frame_interval	= ds5_sensor_s_frame_interval,
+	.s_stream		= ds5_sensor_s_stream,
+};
+
+static const struct v4l2_subdev_ops ds5_depth_subdev_ops = {
+	.pad = &ds5_depth_pad_ops,
+	.video = &ds5_sensor_video_ops,
+};
+
+/* Motion detection */
+
+/* FIXME: identical to ds5_depth_pad_ops, use one for both */
+static const struct v4l2_subdev_pad_ops ds5_motion_t_pad_ops = {
+	.enum_mbus_code		= ds5_sensor_enum_mbus_code,
+	.enum_frame_size	= ds5_sensor_enum_frame_size,
+	.enum_frame_interval	= ds5_sensor_enum_frame_interval,
+	.get_fmt		= ds5_sensor_get_fmt,
+	.set_fmt		= ds5_sensor_set_fmt,
+};
+
+static const struct v4l2_subdev_ops ds5_motion_t_subdev_ops = {
+	.pad = &ds5_motion_t_pad_ops,
+	.video = &ds5_sensor_video_ops,
+};
+
+/* FIXME: identical to ds5_depth_pad_ops, use one for both? */
+static const struct v4l2_subdev_pad_ops ds5_rgb_pad_ops = {
+	.enum_mbus_code		= ds5_sensor_enum_mbus_code,
+	.enum_frame_size	= ds5_sensor_enum_frame_size,
+	.enum_frame_interval	= ds5_sensor_enum_frame_interval,
+	.get_fmt		= ds5_sensor_get_fmt,
+	.set_fmt		= ds5_sensor_set_fmt,
+};
+
+static const struct v4l2_subdev_ops ds5_rgb_subdev_ops = {
+	.pad = &ds5_rgb_pad_ops,
+	.video = &ds5_sensor_video_ops,
+};
+
+static const struct v4l2_subdev_pad_ops ds5_imu_pad_ops = {
+	.enum_mbus_code		= ds5_sensor_enum_mbus_code,
+	.enum_frame_size	= ds5_sensor_enum_frame_size,
+	.enum_frame_interval	= ds5_sensor_enum_frame_interval,
+	.get_fmt		= ds5_sensor_get_fmt,
+	.set_fmt		= ds5_sensor_set_fmt,
+};
+
+static const struct v4l2_subdev_ops ds5_imu_subdev_ops = {
+	.pad = &ds5_imu_pad_ops,
+	.video = &ds5_sensor_video_ops,
+};
+
+static int ds5_hw_set_auto_exposure(struct ds5 *state, u32 base, s32 val)
+{
+	if (val != V4L2_EXPOSURE_APERTURE_PRIORITY &&
+		val != V4L2_EXPOSURE_MANUAL)
+		return -EINVAL;
+
+	/*
+	 * In firmware color auto exposure setting follow the uvc_menu_info
+	 * exposure_auto_controls numbers, in drivers/media/usb/uvc/uvc_ctrl.c.
+	 */
+	if (state->is_rgb && val == V4L2_EXPOSURE_APERTURE_PRIORITY)
+		val = 8;
+
+	/*
+	 * In firmware depth auto exposure on: 1, off: 0.
+	 */
+	if (!state->is_rgb) {
+		if (val == V4L2_EXPOSURE_APERTURE_PRIORITY)
+			val = 1;
+		else if (val == V4L2_EXPOSURE_MANUAL)
+			val = 0;
+	}
+
+	return ds5_write(state, base | DS5_AUTO_EXPOSURE_MODE, (u16)val);
+}
+
+/*
+ * Manual exposure in us
+ * Depth/Y8: between 100 and 200000 (200ms)
+ * Color: between 100 and 1000000 (1s)
+ */
+static int ds5_hw_set_exposure(struct ds5 *state, u32 base, s32 val)
+{
+	int ret = -1;
+
+	if (val < 1)
+		val = 1;
+	if ((state->is_depth || state->is_y8) && val > MAX_DEPTH_EXP)
+		val = MAX_DEPTH_EXP;
+	if (state->is_rgb && val > MAX_RGB_EXP)
+		val = MAX_RGB_EXP;
+
+	/*
+	 * Color and depth uses different unit:
+	 *	Color: 1 is 100 us
+	 *	Depth: 1 is 1 us
+	 */
+
+	ret = ds5_write(state, base | DS5_MANUAL_EXPOSURE_MSB, (u16)(val >> 16));
+	if (!ret)
+		ret = ds5_write(state, base | DS5_MANUAL_EXPOSURE_LSB,
+				(u16)(val & 0xffff));
+
+	return ret;
+}
+
+#define DS5_MAX_LOG_WAIT 200
+#define DS5_MAX_LOG_SLEEP 10
+#define DS5_MAX_LOG_POLL (DS5_MAX_LOG_WAIT / DS5_MAX_LOG_SLEEP)
+
+// TODO: why to use DS5_DEPTH_Y_STREAMS_DT?
+#define DS5_CAMERA_CID_BASE	(V4L2_CTRL_CLASS_CAMERA | DS5_DEPTH_STREAM_DT)
+
+#define DS5_CAMERA_CID_LOG			(DS5_CAMERA_CID_BASE+0)
+#define DS5_CAMERA_CID_LASER_POWER		(DS5_CAMERA_CID_BASE+1)
+#define DS5_CAMERA_CID_MANUAL_LASER_POWER	(DS5_CAMERA_CID_BASE+2)
+#define DS5_CAMERA_DEPTH_CALIBRATION_TABLE_GET	(DS5_CAMERA_CID_BASE+3)
+#define DS5_CAMERA_DEPTH_CALIBRATION_TABLE_SET	(DS5_CAMERA_CID_BASE+4)
+#define DS5_CAMERA_COEFF_CALIBRATION_TABLE_GET	(DS5_CAMERA_CID_BASE+5)
+#define DS5_CAMERA_COEFF_CALIBRATION_TABLE_SET	(DS5_CAMERA_CID_BASE+6)
+#define DS5_CAMERA_CID_FW_VERSION		(DS5_CAMERA_CID_BASE+7)
+#define DS5_CAMERA_CID_GVD			(DS5_CAMERA_CID_BASE+8)
+#define DS5_CAMERA_CID_AE_ROI_GET		(DS5_CAMERA_CID_BASE+9)
+#define DS5_CAMERA_CID_AE_ROI_SET		(DS5_CAMERA_CID_BASE+10)
+#define DS5_CAMERA_CID_AE_SETPOINT_GET		(DS5_CAMERA_CID_BASE+11)
+#define DS5_CAMERA_CID_AE_SETPOINT_SET		(DS5_CAMERA_CID_BASE+12)
+#define DS5_CAMERA_CID_ERB			(DS5_CAMERA_CID_BASE+13)
+#define DS5_CAMERA_CID_EWB			(DS5_CAMERA_CID_BASE+14)
+#define DS5_CAMERA_CID_HWMC			(DS5_CAMERA_CID_BASE+15)
+
+#define DS5_CAMERA_CID_PWM			(DS5_CAMERA_CID_BASE+22)
+
+/* the HWMC will remain for legacy tools compatibility,
+ * HWMC_RW used for UVC compatibility
+ */
+#define DS5_CAMERA_CID_HWMC_RW		(DS5_CAMERA_CID_BASE+32)
+
+static int ds5_send_hwmc(struct ds5 *state, u16 cmdLen, struct hwm_cmd *cmd,
+			 bool isRead, u16 *dataLen)
+{
+	int ret = 0;
+	u16 status = 2;
+	int retries = 100;
+	int errorCode;
+	int iter = retries;
+
+	dev_dbg(&state->client->dev,
+			"%s(): HWMC header: 0x%x, magic: 0x%x, opcode: 0x%x, "
+			"param1: %d, param2: %d, param3: %d, param4: %d\n",
+			__func__, cmd->header, cmd->magic_word, cmd->opcode,
+			cmd->param1, cmd->param2, cmd->param3, cmd->param4);
+
+	ds5_raw_write_with_check(state, 0x4900, cmd, cmdLen);
+
+	ds5_write_with_check(state, 0x490C, 0x01); /* execute cmd */
+	do {
+		if (iter != retries)
+			msleep_range(10);
+		ret = ds5_read(state, 0x4904, &status);
+	} while (iter-- && status != 0);
+
+	if (ret || status != 0) {
+		ds5_raw_read(state, 0x4900, &errorCode, 4);
+		dev_err(&state->client->dev,
+				"%s(): HWMC failed, ret: %d, status: %x, error code: %d\n",
+				__func__, ret, status, errorCode);
+		ret = -EAGAIN;
+	}
+
+	if (isRead) {
+		if (*dataLen == 0) {
+			ret = regmap_raw_read(state->regmap, 0x4908, dataLen, sizeof(u16));
+			if (ret)
+				return -EAGAIN;
+		}
+
+		dev_dbg(&state->client->dev, "%s(): HWMC read len: %d\n",
+				__func__, *dataLen);
+		// First 4 bytes of cmd->Data after read will include opcode
+		ds5_raw_read_with_check(state, 0x4900, cmd->Data, *dataLen);
+
+		/*This is neede for libreealsense, to align there code with UVC*/
+		cmd->Data[1000] = (unsigned char)((*dataLen) & 0x00FF);
+		cmd->Data[1001] = (unsigned char)(((*dataLen) & 0xFF00) >> 8);
+	}
+
+	return 0;
+}
+
+#define DS5_HWMC_DATA			0x4900
+#define DS5_HWMC_STATUS			0x4904
+#define DS5_HWMC_RESP_LEN		0x4908
+#define DS5_HWMC_EXEC			0x490C
+
+#define DS5_HWMC_STATUS_OK		0
+#define DS5_HWMC_STATUS_ERR		1
+#define DS5_HWMC_STATUS_WIP		2
+#define DS5_HWMC_BUFFER_SIZE	1024
+
+static int ds5_get_hwmc(struct ds5 *state, unsigned char *data)
+{
+	int ret = 0;
+	u16 status = DS5_HWMC_STATUS_WIP;
+	int retries = 100;
+	int errorCode;
+	u16 tmp_len = 0;
+	const int SIZE_OF_HW_MONITOR_HEADER = 4;
+
+	memset(data, 0, DS5_HWMC_BUFFER_SIZE);
+
+	do {
+		if (retries != 100)
+			msleep_range(1);
+		ret = ds5_read(state, DS5_HWMC_STATUS, &status);
+	} while (!ret && retries-- && status != DS5_HWMC_STATUS_OK);
+
+	if (ret || status != DS5_HWMC_STATUS_OK) {
+		if (status == DS5_HWMC_STATUS_ERR) {
+			ds5_raw_read(state, DS5_HWMC_DATA, &errorCode, sizeof(errorCode));
+			dev_err(&state->client->dev,
+					"%s(): HWMC failed, ret: %d, error code: %d\n",
+					__func__, ret, errorCode);
+		} else {
+			dev_err(&state->client->dev,
+					"%s(): HWMC failed because of timeout, ret: %d\n",
+					__func__, ret);
+		}
+		return -EAGAIN;
+	}
+
+	ret = regmap_raw_read(state->regmap, DS5_HWMC_RESP_LEN,
+			&tmp_len, sizeof(tmp_len));
+	if (ret)
+		return -EAGAIN;
+
+	if (tmp_len > DS5_HWMC_BUFFER_SIZE)
+		return -ENOBUFS;
+
+	dev_dbg(&state->client->dev,
+			"%s(): HWMC read len: %d, lrs_len: %d\n",
+			__func__, tmp_len, tmp_len - SIZE_OF_HW_MONITOR_HEADER);
+
+	ds5_raw_read_with_check(state, DS5_HWMC_DATA, data, tmp_len);
+
+	/* This is needed for librealsense, to align there code with UVC,
+	 * last word is length - 4 bytes header length
+	 */
+	tmp_len -= SIZE_OF_HW_MONITOR_HEADER;
+	data[DS5_HWMC_BUFFER_SIZE - 4] = (unsigned char)(tmp_len & 0x00FF);
+	data[DS5_HWMC_BUFFER_SIZE - 3] = (unsigned char)((tmp_len & 0xFF00) >> 8);
+	data[DS5_HWMC_BUFFER_SIZE - 2] = 0;
+	data[DS5_HWMC_BUFFER_SIZE - 1] = 0;
+
+	return 0;
+}
+
+static int ds5_set_calibration_data(struct ds5 *state,
+		struct hwm_cmd *cmd, u16 length)
+{
+	int ret = -1;
+	int retries = 10;
+	u16 status = 2;
+
+	ds5_raw_write_with_check(state, 0x4900, cmd, length);
+
+	ds5_write_with_check(state, 0x490c, 0x01); /* execute cmd */
+	do {
+		if (retries != 10)
+			msleep_range(200);
+		ret = ds5_read(state, 0x4904, &status);
+	} while (retries-- && status != 0);
+
+	if (ret || status != 0) {
+		dev_err(&state->client->dev,
+				"%s(): Failed to set calibration table %d,"
+				"ret: %d, fw error: %x\n",
+				__func__, cmd->param1, ret, status);
+	}
+
+	return -EINVAL;
+}
+
+static int ds5_s_state(struct ds5 *state, int vc)
+{
+	int ret = 0;
+
+	dev_dbg(&state->client->dev, "%s(): set state for vc: %d\n", __func__, vc);
+
+	switch (vc) {
+	case 0:
+		state->is_depth = 1;
+		state->is_rgb = 0;
+		state->is_y8 = 0;
+		state->is_imu = 0;
+		break;
+	case 1:
+		state->is_depth = 0;
+		state->is_rgb = 1;
+		state->is_y8 = 0;
+		state->is_imu = 0;
+		break;
+	case 2:
+		state->is_depth = 0;
+		state->is_rgb = 0;
+		state->is_y8 = 1;
+		state->is_imu = 0;
+		break;
+	case 3:
+		state->is_depth = 0;
+		state->is_rgb = 0;
+		state->is_y8 = 0;
+		state->is_imu = 1;
+		break;
+	default:
+		dev_warn(&state->client->dev, "%s(): unknown vc: %d\n", __func__, vc);
+		ret = -EINVAL;
+		break;
+	}
+	ds5_set_state_last_set(state);
+	return ret;
+}
+
+static int ds5_mux_s_stream(struct v4l2_subdev *sd, int on);
+
+static int ds5_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct ds5 *state = container_of(ctrl->handler, struct ds5,
+					 ctrls.handler);
+	struct v4l2_subdev *sd = &state->mux.sd.subdev;
+	struct ds5_sensor *sensor = (struct ds5_sensor *)ctrl->priv;
+	int ret = -EINVAL;
+	u16 base = DS5_DEPTH_CONTROL_BASE;
+	u32 val;
+	u16 on;
+	u16 vc_id;
+
+	if (sensor) {
+		switch (sensor->mux_pad) {
+		case DS5_MUX_PAD_DEPTH_A:
+			state = container_of(ctrl->handler, struct ds5, ctrls.handler_depth);
+			state->is_rgb = 0;
+			state->is_depth = 1;
+			state->is_y8 = 0;
+			state->is_imu = 0;
+		break;
+		case DS5_MUX_PAD_RGB_A:
+			state = container_of(ctrl->handler, struct ds5, ctrls.handler_rgb);
+			state->is_rgb = 1;
+			state->is_depth = 0;
+			state->is_y8 = 0;
+			state->is_imu = 0;
+		break;
+		case DS5_MUX_PAD_MOTION_T_A:
+			state = container_of(ctrl->handler, struct ds5, ctrls.handler_y8);
+			state->is_rgb = 0;
+			state->is_depth = 0;
+			state->is_y8 = 1;
+			state->is_imu = 0;
+		break;
+		case DS5_MUX_PAD_IMU_A:
+			state = container_of(ctrl->handler, struct ds5, ctrls.handler_imu);
+			state->is_rgb = 0;
+			state->is_depth = 0;
+			state->is_y8 = 0;
+			state->is_imu = 1;
+		break;
+		default:
+			state->is_rgb = 0;
+			state->is_depth = 0;
+			state->is_y8 = 0;
+			state->is_imu = 1;
+		break;
+
+		}
+	}
+
+	if (state->is_rgb)
+		base = DS5_RGB_CONTROL_BASE;
+
+	v4l2_dbg(3, 1, sd, "ctrl: %s, value: %d\n", ctrl->name, ctrl->val);
+	dev_dbg(&state->client->dev, "%s(): %s - ctrl: %s, value: %d\n",
+		__func__, ds5_get_sensor_name(state), ctrl->name, ctrl->val);
+
+	mutex_lock(&state->lock);
+
+	switch (ctrl->id) {
+	case V4L2_CID_ANALOGUE_GAIN:
+		ret = ds5_write(state, base | DS5_MANUAL_GAIN, ctrl->val);
+		break;
+
+	case V4L2_CID_EXPOSURE_AUTO:
+		ret = ds5_hw_set_auto_exposure(state, base, ctrl->val);
+		break;
+
+	case V4L2_CID_EXPOSURE_ABSOLUTE:
+		ret = ds5_hw_set_exposure(state, base, ctrl->val);
+		break;
+	case DS5_CAMERA_CID_LASER_POWER:
+		if (!state->is_rgb)
+			ret = ds5_write(state, base | DS5_LASER_POWER,
+					ctrl->val);
+		break;
+	case DS5_CAMERA_CID_MANUAL_LASER_POWER:
+		if (!state->is_rgb)
+			ret = ds5_write(state, base | DS5_MANUAL_LASER_POWER,
+					ctrl->val);
+		break;
+	case DS5_CAMERA_DEPTH_CALIBRATION_TABLE_SET: {
+		struct hwm_cmd *calib_cmd;
+
+		dev_dbg(&state->client->dev,
+			"%s(): DS5_CAMERA_DEPTH_CALIBRATION_TABLE_SET \n",
+			__func__);
+		dev_dbg(&state->client->dev,
+			"%s(): table id: 0x%x\n",
+			__func__, *((u8 *)ctrl->p_new.p + 2));
+		if (ctrl->p_new.p && DEPTH_CALIBRATION_ID ==
+				*((u8 *)ctrl->p_new.p + 2)) {
+			calib_cmd = devm_kzalloc(&state->client->dev,
+					sizeof(struct hwm_cmd) + 256, GFP_KERNEL);
+			if (!calib_cmd) {
+				dev_err(&state->client->dev,
+					"%s(): Can't allocate memory for 0x%x\n",
+					__func__, ctrl->id);
+				ret = -ENOMEM;
+				break;
+			}
+			memcpy(calib_cmd, &set_calib_data, sizeof(set_calib_data));
+			calib_cmd->header = 276;
+			calib_cmd->param1 = DEPTH_CALIBRATION_ID;
+			memcpy (calib_cmd->Data, (u8 *)ctrl->p_new.p, 256);
+			ret = ds5_set_calibration_data(state, calib_cmd,
+					sizeof(struct hwm_cmd) + 256);
+			devm_kfree(&state->client->dev, calib_cmd);
+		}
+		break;
+		}
+	case DS5_CAMERA_COEFF_CALIBRATION_TABLE_SET: {
+			struct hwm_cmd *calib_cmd;
+
+			dev_dbg(&state->client->dev,
+				"%s(): DS5_CAMERA_COEFF_CALIBRATION_TABLE_SET \n",
+				__func__);
+			dev_dbg(&state->client->dev,
+				"%s(): table id %d\n",
+				__func__, *((u8 *)ctrl->p_new.p + 2));
+			if (ctrl->p_new.p && COEF_CALIBRATION_ID ==
+					*((u8 *)ctrl->p_new.p + 2)) {
+				calib_cmd = devm_kzalloc(&state->client->dev,
+						sizeof(struct hwm_cmd) + 512, GFP_KERNEL);
+				if (!calib_cmd) {
+					dev_err(&state->client->dev,
+						"%s(): Can't allocate memory for 0x%x\n",
+						__func__, ctrl->id);
+					ret = -ENOMEM;
+					break;
+				}
+			memcpy (calib_cmd, &set_calib_data, sizeof (set_calib_data));
+				calib_cmd->header = 532;
+				calib_cmd->param1 = COEF_CALIBRATION_ID;
+				memcpy(calib_cmd->Data, (u8 *)ctrl->p_new.p, 512);
+				ret = ds5_set_calibration_data(state, calib_cmd,
+						sizeof(struct hwm_cmd) + 512);
+				devm_kfree(&state->client->dev, calib_cmd);
+			}
+		}
+		break;
+	case DS5_CAMERA_CID_AE_ROI_SET: {
+		struct hwm_cmd ae_roi_cmd;
+
+		memcpy(&ae_roi_cmd, &set_ae_roi, sizeof(ae_roi_cmd));
+		ae_roi_cmd.param1 = *((u16 *)ctrl->p_new.p_u16);
+		ae_roi_cmd.param2 = *((u16 *)ctrl->p_new.p_u16 + 1);
+		ae_roi_cmd.param3 = *((u16 *)ctrl->p_new.p_u16 + 2);
+		ae_roi_cmd.param4 = *((u16 *)ctrl->p_new.p_u16 + 3);
+		ret = ds5_send_hwmc(state, sizeof(struct hwm_cmd),
+				&ae_roi_cmd, false, NULL);
+		break;
+		}
+	case DS5_CAMERA_CID_AE_SETPOINT_SET: {
+		struct hwm_cmd *ae_setpoint_cmd;
+
+		if (ctrl->p_new.p_s32) {
+			dev_dbg(&state->client->dev, "%s():0x%x \n",
+				__func__, *(ctrl->p_new.p_s32));
+			ae_setpoint_cmd = devm_kzalloc(&state->client->dev,
+					sizeof(struct hwm_cmd) + 4, GFP_KERNEL);
+			if (!ae_setpoint_cmd) {
+				dev_err(&state->client->dev,
+					"%s(): Can't allocate memory for 0x%x\n",
+					__func__, ctrl->id);
+				ret = -ENOMEM;
+				break;
+			}
+			memcpy(ae_setpoint_cmd, &set_ae_setpoint, sizeof (set_ae_setpoint));
+			memcpy(ae_setpoint_cmd->Data, (u8 *)ctrl->p_new.p_s32, 4);
+			ret = ds5_send_hwmc(state, sizeof(struct hwm_cmd) + 4,
+					ae_setpoint_cmd, false, NULL);
+			devm_kfree(&state->client->dev, ae_setpoint_cmd);
+		}
+		break;
+	}
+	case DS5_CAMERA_CID_ERB:
+		if (ctrl->p_new.p_u8) {
+			u16 offset = 0;
+			u16 size = 0;
+			struct hwm_cmd *erb_cmd;
+
+			offset = *(ctrl->p_new.p_u8) << 8;
+			offset |= *(ctrl->p_new.p_u8 + 1);
+			size = *(ctrl->p_new.p_u8 + 2) << 8;
+			size |= *(ctrl->p_new.p_u8 + 3);
+
+			dev_dbg(&state->client->dev, "%s(): offset %x, size: %x\n",
+							__func__, offset, size);
+
+			erb_cmd = devm_kzalloc(&state->client->dev,
+					sizeof(struct hwm_cmd) + size, GFP_KERNEL);
+			if (!erb_cmd) {
+				dev_err(&state->client->dev,
+					"%s(): Can't allocate memory for 0x%x\n",
+					__func__, ctrl->id);
+				ret = -ENOMEM;
+				break;
+			}
+			memcpy(erb_cmd, &erb, sizeof(struct hwm_cmd));
+			erb_cmd->param1 = offset;
+			erb_cmd->param2 = size;
+			ret = ds5_send_hwmc(state, sizeof(struct hwm_cmd),
+					erb_cmd, true, &size);
+
+			if (ret) {
+				dev_err(&state->client->dev,
+					"%s(): ERB cmd failed, ret: %d,"
+					"requested size: %d, actual size: %d\n",
+					__func__, ret, erb_cmd->param2, size);
+				devm_kfree(&state->client->dev, erb_cmd);
+				return -EAGAIN;
+			}
+
+			// Actual size returned from FW
+			*(ctrl->p_new.p_u8 + 2) = (size & 0xFF00) >> 8;
+			*(ctrl->p_new.p_u8 + 3) = (size & 0x00FF);
+
+			memcpy(ctrl->p_new.p_u8 + 4, erb_cmd->Data + 4, size - 4);
+			dev_dbg(&state->client->dev, "%s(): 0x%x 0x%x 0x%x 0x%x \n",
+				__func__,
+				*(ctrl->p_new.p_u8),
+				*(ctrl->p_new.p_u8+1),
+				*(ctrl->p_new.p_u8+2),
+				*(ctrl->p_new.p_u8+3));
+			devm_kfree(&state->client->dev, erb_cmd);
+		}
+		break;
+	case DS5_CAMERA_CID_EWB:
+		if (ctrl->p_new.p_u8) {
+			u16 offset = 0;
+			u16 size = 0;
+			struct hwm_cmd *ewb_cmd;
+
+			offset = *((u8 *)ctrl->p_new.p_u8) << 8;
+			offset |= *((u8 *)ctrl->p_new.p_u8 + 1);
+			size = *((u8 *)ctrl->p_new.p_u8 + 2) << 8;
+			size |= *((u8 *)ctrl->p_new.p_u8 + 3);
+
+			dev_dbg(&state->client->dev, "%s():0x%x 0x%x 0x%x 0x%x\n",
+					__func__,
+					*((u8 *)ctrl->p_new.p_u8),
+					*((u8 *)ctrl->p_new.p_u8 + 1),
+					*((u8 *)ctrl->p_new.p_u8 + 2),
+					*((u8 *)ctrl->p_new.p_u8 + 3));
+
+			ewb_cmd = devm_kzalloc(&state->client->dev,
+					sizeof(struct hwm_cmd) + size,
+					GFP_KERNEL);
+			if (!ewb_cmd) {
+				dev_err(&state->client->dev,
+					"%s(): Can't allocate memory for 0x%x\n",
+					__func__, ctrl->id);
+				ret = -ENOMEM;
+				break;
+			}
+			memcpy(ewb_cmd, &ewb, sizeof(ewb));
+			ewb_cmd->header = 0x14 + size;
+			ewb_cmd->param1 = offset; // start index
+			ewb_cmd->param2 = size; // size
+			memcpy(ewb_cmd->Data, (u8 *)ctrl->p_new.p_u8 + 4, size);
+			ret = ds5_send_hwmc(state, sizeof(struct hwm_cmd) + size,
+					ewb_cmd, false, NULL);
+
+			if (ret) {
+				dev_err(&state->client->dev,
+					"%s(): EWB cmd failed, ret: %d,"
+					"requested size: %d, actual size: %d\n",
+					__func__, ret, ewb_cmd->param2, size);
+				devm_kfree(&state->client->dev, ewb_cmd);
+				return -EAGAIN;
+			}
+
+			devm_kfree(&state->client->dev, ewb_cmd);
+		}
+		break;
+	case DS5_CAMERA_CID_HWMC:
+		if (ctrl->p_new.p_u8) {
+			u16 dataLen = 0;
+			u16 size = 0;
+
+			size = *((u8 *)ctrl->p_new.p_u8 + 1) << 8;
+			size |= *((u8 *)ctrl->p_new.p_u8 + 0);
+			dev_dbg(&state->client->dev,
+				"%s(): HWMC size %d\n",
+				__func__, size);
+			ret = ds5_send_hwmc(state, size + 4,
+					(struct hwm_cmd *)ctrl->p_new.p_u8, true, &dataLen);
+		}
+		break;
+	case DS5_CAMERA_CID_HWMC_RW:
+		if (ctrl->p_new.p_u8) {
+			u16 size = *((u8 *)ctrl->p_new.p_u8 + 1) << 8;
+
+			size |= *((u8 *)ctrl->p_new.p_u8 + 0);
+			ret = ds5_send_hwmc(state, size + 4,
+					(struct hwm_cmd *)ctrl->p_new.p_u8, false, NULL);
+		}
+		break;
+	case DS5_CAMERA_CID_PWM:
+		if (state->is_depth)
+			ret = ds5_write(state, base | DS5_PWM_FREQUENCY, ctrl->val);
+		break;
+	case V4L2_CID_IPU_SET_SUB_STREAM:
+		val = (*ctrl->p_new.p_s64 & 0xFFFF);
+		dev_info(&state->client->dev, "V4L2_CID_IPU_SET_SUB_STREAM %x\n", val);
+		vc_id = (val >> 8) & 0x00FF;
+		on = val & 0x00FF;
+		if (on == 0xff) {
+			ret = ds5_s_state(state, vc_id);
+			break;
+		}
+		if (vc_id > NR_OF_DS5_STREAMS - 1)
+			dev_err(&state->client->dev, "invalid vc %d\n", vc_id);
+		else
+			d4xx_set_sub_stream[vc_id] = on;
+
+		if (on == 0)
+			ret = ds5_s_state(state, vc_id);
+
+		ret = ds5_mux_s_stream(sd, on);
+		break;
+	}
+
+	mutex_unlock(&state->lock);
+
+	return ret;
+}
+
+static int ds5_get_calibration_data(struct ds5 *state, enum table_id id,
+		unsigned char *table, unsigned int length)
+{
+	struct hwm_cmd *cmd;
+	int ret = -1;
+	int retries = 3;
+	u16 status = 2;
+	u16 table_length;
+
+	cmd = devm_kzalloc(&state->client->dev,
+			sizeof(struct hwm_cmd) + length + 4, GFP_KERNEL);
+	if (!cmd) {
+		dev_err(&state->client->dev, "%s(): Can't allocate memory\n", __func__);
+		return -ENOMEM;
+	}
+
+	memcpy(cmd, &get_calib_data, sizeof(get_calib_data));
+	cmd->param1 = id;
+	ds5_raw_write_with_check(state, 0x4900, cmd, sizeof(struct hwm_cmd));
+	ds5_write_with_check(state, 0x490c, 0x01); /* execute cmd */
+	do {
+		if (retries != 3)
+			msleep_range(10);
+		ret = ds5_read(state, 0x4904, &status);
+	} while (ret && retries-- && status != 0);
+
+	if (ret || status != 0) {
+		dev_err(&state->client->dev,
+				"%s(): Failed to get calibration table %d, fw error: %x\n",
+				__func__, id, status);
+		devm_kfree(&state->client->dev, cmd);
+		return status;
+	}
+
+	// get table length from fw
+	ret = regmap_raw_read(state->regmap, 0x4908,
+			&table_length, sizeof(table_length));
+
+	// read table
+	ds5_raw_read_with_check(state, 0x4900, cmd->Data, table_length);
+
+	// first 4 bytes are opcode HWM, not part of calibration table
+	memcpy(table, cmd->Data + 4, length);
+	devm_kfree(&state->client->dev, cmd);
+	return 0;
+}
+
+static int ds5_gvd(struct ds5 *state, unsigned char *data)
+{
+	struct hwm_cmd cmd;
+	int ret = -1;
+	u16 length = 0;
+	u16 status = 2;
+	u8 retries = 3;
+
+	memcpy(&cmd, &gvd, sizeof(gvd));
+	ds5_raw_write_with_check(state, 0x4900, &cmd, sizeof(cmd));
+	ds5_write_with_check(state, 0x490c, 0x01); /* execute cmd */
+	do {
+		if (retries != 3)
+			msleep_range(10);
+
+		ret = ds5_read(state, 0x4904, &status);
+	} while (ret && retries-- && status != 0);
+
+	if (ret || status != 0) {
+		dev_err(&state->client->dev,
+				"%s(): Failed to read GVD, HWM cmd status: %x\n",
+				__func__, status);
+		return status;
+	}
+
+	ret = regmap_raw_read(state->regmap, 0x4908, &length, sizeof(length));
+	ds5_raw_read_with_check(state, 0x4900, data, length);
+
+	return ret;
+}
+
+static int ds5_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct ds5 *state = container_of(ctrl->handler, struct ds5,
+			ctrls.handler);
+	u16 log_prepare[] = {0x0014, 0xcdab, 0x000f, 0x0000, 0x0400, 0x0000,
+			0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000};
+	u16 execute_cmd = 0x0001;
+	unsigned int i;
+	u32 data;
+	int ret = 0;
+	struct ds5_sensor *sensor = (struct ds5_sensor *)ctrl->priv;
+	u16 base = (state->is_rgb) ? DS5_RGB_CONTROL_BASE : DS5_DEPTH_CONTROL_BASE;
+	u16 reg;
+
+	if (sensor) {
+		switch (sensor->mux_pad) {
+		case DS5_MUX_PAD_DEPTH_A:
+			state = container_of(ctrl->handler, struct ds5, ctrls.handler_depth);
+			state->is_rgb = 0;
+			state->is_depth = 1;
+			state->is_y8 = 0;
+			state->is_imu = 0;
+		break;
+		case DS5_MUX_PAD_RGB_A:
+			state = container_of(ctrl->handler, struct ds5, ctrls.handler_rgb);
+			state->is_rgb = 1;
+			state->is_depth = 0;
+			state->is_y8 = 0;
+			state->is_imu = 0;
+		break;
+		case DS5_MUX_PAD_MOTION_T_A:
+			state = container_of(ctrl->handler, struct ds5, ctrls.handler_y8);
+			state->is_rgb = 0;
+			state->is_depth = 0;
+			state->is_y8 = 1;
+			state->is_imu = 0;
+		break;
+		case DS5_MUX_PAD_IMU_A:
+			state = container_of(ctrl->handler, struct ds5, ctrls.handler_imu);
+			state->is_rgb = 0;
+			state->is_depth = 0;
+			state->is_y8 = 0;
+			state->is_imu = 1;
+		break;
+		default:
+			state->is_rgb = 0;
+			state->is_depth = 0;
+			state->is_y8 = 0;
+			state->is_imu = 1;
+		break;
+
+		}
+	}
+	base = (state->is_rgb) ? DS5_RGB_CONTROL_BASE : DS5_DEPTH_CONTROL_BASE;
+
+	dev_dbg(&state->client->dev, "%s(): %s - ctrl: %s \n",
+		__func__, ds5_get_sensor_name(state), ctrl->name);
+
+	switch (ctrl->id) {
+
+	case V4L2_CID_ANALOGUE_GAIN:
+		if (state->is_imu)
+			return -EINVAL;
+		ret = ds5_read(state, base | DS5_MANUAL_GAIN, ctrl->p_new.p_u16);
+		break;
+
+	case V4L2_CID_EXPOSURE_AUTO:
+		if (state->is_imu)
+			return -EINVAL;
+		ds5_read(state, base | DS5_AUTO_EXPOSURE_MODE, &reg);
+		*ctrl->p_new.p_u16 = reg;
+		/* see ds5_hw_set_auto_exposure */
+		if (!state->is_rgb) {
+			if (reg == 1)
+				*ctrl->p_new.p_u16 = V4L2_EXPOSURE_APERTURE_PRIORITY;
+			else if (reg == 0)
+				*ctrl->p_new.p_u16 = V4L2_EXPOSURE_MANUAL;
+		}
+
+		if (state->is_rgb && reg == 8)
+			*ctrl->p_new.p_u16 = V4L2_EXPOSURE_APERTURE_PRIORITY;
+
+		break;
+
+	case V4L2_CID_EXPOSURE_ABSOLUTE:
+		if (state->is_imu)
+			return -EINVAL;
+		/* see ds5_hw_set_exposure */
+		ds5_read(state, base | DS5_MANUAL_EXPOSURE_MSB, &reg);
+		data = ((u32)reg << 16) & 0xffff0000;
+		ds5_read(state, base | DS5_MANUAL_EXPOSURE_LSB, &reg);
+		data |= reg;
+		*ctrl->p_new.p_u32 = data;
+		break;
+
+	case DS5_CAMERA_CID_LASER_POWER:
+		if (!state->is_rgb)
+			ds5_read(state, base | DS5_LASER_POWER, ctrl->p_new.p_u16);
+		break;
+
+	case DS5_CAMERA_CID_MANUAL_LASER_POWER:
+		if (!state->is_rgb)
+			ds5_read(state, base | DS5_MANUAL_LASER_POWER, ctrl->p_new.p_u16);
+		break;
+
+	case DS5_CAMERA_CID_LOG:
+		// TODO: wrap HWMonitor command
+		//       1. prepare and send command
+		//       2. send command
+		//       3. execute command
+		//       4. wait for ccompletion
+		ret = regmap_raw_write(state->regmap, 0x4900,
+				log_prepare, sizeof(log_prepare));
+		if (ret < 0)
+			return ret;
+
+		ret = regmap_raw_write(state->regmap, 0x490C,
+				&execute_cmd, sizeof(execute_cmd));
+		if (ret < 0)
+			return ret;
+
+		for (i = 0; i < DS5_MAX_LOG_POLL; i++) {
+			ret = regmap_raw_read(state->regmap, 0x4904,
+					&data, sizeof(data));
+			dev_dbg(&state->client->dev, "%s(): log ready 0x%x\n",
+				 __func__, data);
+			if (ret < 0)
+				return ret;
+			if (!data)
+				break;
+			msleep_range(5);
+		}
+
+//		if (i == DS5_MAX_LOG_POLL)
+//			return -ETIMEDOUT;
+
+		ret = regmap_raw_read(state->regmap, 0x4908,
+				&data, sizeof(data));
+		dev_dbg(&state->client->dev, "%s(): log size 0x%x\n",
+			 __func__, data);
+		if (ret < 0)
+			return ret;
+		if (!data)
+			return 0;
+		if (data > 1024)
+			return -ENOBUFS;
+		ret = regmap_raw_read(state->regmap, 0x4900,
+				ctrl->p_new.p_u8, data);
+		break;
+	case DS5_CAMERA_DEPTH_CALIBRATION_TABLE_GET:
+		ret = ds5_get_calibration_data(state, DEPTH_CALIBRATION_ID,
+				ctrl->p_new.p_u8, 256);
+		break;
+	case DS5_CAMERA_COEFF_CALIBRATION_TABLE_GET:
+		ret = ds5_get_calibration_data(state, COEF_CALIBRATION_ID,
+				ctrl->p_new.p_u8, 512);
+		break;
+	case DS5_CAMERA_CID_FW_VERSION:
+		ret = ds5_read(state, DS5_FW_VERSION, &state->fw_version);
+		ret = ds5_read(state, DS5_FW_BUILD, &state->fw_build);
+		*ctrl->p_new.p_u32 = state->fw_version << 16;
+		*ctrl->p_new.p_u32 |= state->fw_build;
+		break;
+	case DS5_CAMERA_CID_GVD:
+		ret = ds5_gvd(state, ctrl->p_new.p_u8);
+		break;
+	case DS5_CAMERA_CID_AE_ROI_GET: {
+		u16 len = 0;
+		struct hwm_cmd *ae_roi_cmd;
+		ae_roi_cmd = devm_kzalloc(&state->client->dev,
+				sizeof(struct hwm_cmd) + 12, GFP_KERNEL);
+		if (!ae_roi_cmd) {
+			dev_err(&state->client->dev,
+				"%s(): Can't allocate memory for 0x%x\n",
+				__func__, ctrl->id);
+			ret = -ENOMEM;
+			break;
+		}
+		memcpy(ae_roi_cmd, &get_ae_roi, sizeof(struct hwm_cmd));
+		ret = ds5_send_hwmc(state, sizeof(struct hwm_cmd),
+				ae_roi_cmd, true, &len);
+		memcpy(ctrl->p_new.p_u16, ae_roi_cmd->Data + 4, 8);
+		devm_kfree(&state->client->dev, ae_roi_cmd);
+		}
+		break;
+	case DS5_CAMERA_CID_AE_SETPOINT_GET: {
+		u16 len = 0;
+		struct hwm_cmd *ae_setpoint_cmd;
+		ae_setpoint_cmd = devm_kzalloc(&state->client->dev,
+				sizeof(struct hwm_cmd) + 8, GFP_KERNEL);
+		if (!ae_setpoint_cmd) {
+			dev_err(&state->client->dev,
+					"%s(): Can't allocate memory for 0x%x\n",
+					__func__, ctrl->id);
+			ret = -ENOMEM;
+			break;
+		}
+		memcpy(ae_setpoint_cmd, &get_ae_setpoint, sizeof(struct hwm_cmd));
+		ret = ds5_send_hwmc(state, sizeof(struct hwm_cmd),
+				ae_setpoint_cmd, true, &len);
+		memcpy(ctrl->p_new.p_s32, ae_setpoint_cmd->Data + 4, 4);
+		dev_dbg(&state->client->dev, "%s(): 0x%x \n",
+			__func__,
+			*(ctrl->p_new.p_s32));
+		devm_kfree(&state->client->dev, ae_setpoint_cmd);
+		}
+		break;
+	case DS5_CAMERA_CID_HWMC_RW:
+		ds5_get_hwmc(state, ctrl->p_new.p_u8);
+		break;
+	case DS5_CAMERA_CID_PWM:
+		if (state->is_depth)
+			ds5_read(state, base | DS5_PWM_FREQUENCY, ctrl->p_new.p_u16);
+		break;
+	case V4L2_CID_IPU_QUERY_SUB_STREAM: {
+		if (sensor) {
+			int vc_id = get_sub_stream_vc_id(pad_to_substream[sensor->mux_pad]);
+
+			dev_dbg(sensor->sd.dev,
+				"%s(): V4L2_CID_IPU_QUERY_SUB_STREAM sensor->mux_pad:%d vc:[%d]\n",
+				__func__, sensor->mux_pad, vc_id);
+			*ctrl->p_new.p_s32 = pad_to_substream[sensor->mux_pad];
+			state->mux.last_set = sensor;
+			} else {
+				/* we are in DS5 MUX case */
+				*ctrl->p_new.p_s32 = -1;
+			}
+		}
+		break;
+	}
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops ds5_ctrl_ops = {
+	.s_ctrl	= ds5_s_ctrl,
+	.g_volatile_ctrl = ds5_g_volatile_ctrl,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_log = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_CID_LOG,
+	.name = "Logger",
+	.type = V4L2_CTRL_TYPE_U8,
+	.dims = {1024},
+	.elem_size = sizeof(u8),
+	.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
+	.step = 1,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_laser_power = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_CID_LASER_POWER,
+	.name = "Laser power on/off",
+	.type = V4L2_CTRL_TYPE_BOOLEAN,
+	.min = 0,
+	.max = 1,
+	.step = 1,
+	.def = 1,
+	.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_manual_laser_power = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_CID_MANUAL_LASER_POWER,
+	.name = "Manual laser power",
+	.type = V4L2_CTRL_TYPE_INTEGER,
+	.min = 0,
+	.max = 360,
+	.step = 30,
+	.def = 150,
+	.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_fw_version = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_CID_FW_VERSION,
+	.name = "fw version",
+	.type = V4L2_CTRL_TYPE_U32,
+	.dims = {1},
+	.elem_size = sizeof(u32),
+	.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
+	.step = 1,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_gvd = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_CID_GVD,
+	.name = "GVD",
+	.type = V4L2_CTRL_TYPE_U8,
+	.dims = {239},
+	.elem_size = sizeof(u8),
+	.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
+	.step = 1,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_get_depth_calib = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_DEPTH_CALIBRATION_TABLE_GET,
+	.name = "get depth calib",
+	.type = V4L2_CTRL_TYPE_U8,
+	.dims = {256},
+	.elem_size = sizeof(u8),
+	.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
+	.step = 1,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_set_depth_calib = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_DEPTH_CALIBRATION_TABLE_SET,
+	.name = "set depth calib",
+	.type = V4L2_CTRL_TYPE_U8,
+	.dims = {256},
+	.elem_size = sizeof(u8),
+	.min = 0,
+	.max = 0xFFFFFFFF,
+	.def = 240,
+	.step = 1,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_get_coeff_calib = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_COEFF_CALIBRATION_TABLE_GET,
+	.name = "get coeff calib",
+	.type = V4L2_CTRL_TYPE_U8,
+	.dims = {512},
+	.elem_size = sizeof(u8),
+	.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
+	.step = 1,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_set_coeff_calib = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_COEFF_CALIBRATION_TABLE_SET,
+	.name = "set coeff calib",
+	.type = V4L2_CTRL_TYPE_U8,
+	.dims = {512},
+	.elem_size = sizeof(u8),
+	.min = 0,
+	.max = 0xFFFFFFFF,
+	.def = 240,
+	.step = 1,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_ae_roi_get = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_CID_AE_ROI_GET,
+	.name = "ae roi get",
+	.type = V4L2_CTRL_TYPE_U8,
+	.dims = {8},
+	.elem_size = sizeof(u16),
+	.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
+	.step = 1,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_ae_roi_set = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_CID_AE_ROI_SET,
+	.name = "ae roi set",
+	.type = V4L2_CTRL_TYPE_U8,
+	.dims = {8},
+	.elem_size = sizeof(u16),
+	.min = 0,
+	.max = 0xFFFFFFFF,
+	.def = 240,
+	.step = 1,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_ae_setpoint_get = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_CID_AE_SETPOINT_GET,
+	.name = "ae setpoint get",
+	.type = V4L2_CTRL_TYPE_INTEGER,
+	.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
+	.step = 1,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_ae_setpoint_set = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_CID_AE_SETPOINT_SET,
+	.name = "ae setpoint set",
+	.type = V4L2_CTRL_TYPE_INTEGER,
+	.min = 0,
+	.max = 4095,
+	.step = 1,
+	.def = 0,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_erb = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_CID_ERB,
+	.name = "ERB eeprom read",
+	.type = V4L2_CTRL_TYPE_U8,
+	.dims = {1020},
+	.elem_size = sizeof(u8),
+	.min = 0,
+	.max = 0xFFFFFFFF,
+	.def = 240,
+	.step = 1,
+	.step = 1,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_ewb = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_CID_EWB,
+	.name = "EWB eeprom write",
+	.type = V4L2_CTRL_TYPE_U8,
+	.dims = {1020},
+	.elem_size = sizeof(u8),
+	.min = 0,
+	.max = 0xFFFFFFFF,
+	.def = 240,
+	.step = 1,
+	.step = 1,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_hwmc = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_CID_HWMC,
+	.name = "HWMC",
+	.type = V4L2_CTRL_TYPE_U8,
+	.dims = {DS5_HWMC_BUFFER_SIZE + 4},
+	.elem_size = sizeof(u8),
+	.min = 0,
+	.max = 0xFFFFFFFF,
+	.def = 240,
+	.step = 1,
+	.step = 1,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_hwmc_rw = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_CID_HWMC_RW,
+	.name = "HWMC_RW",
+	.type = V4L2_CTRL_TYPE_U8,
+	.dims = {DS5_HWMC_BUFFER_SIZE},
+	.elem_size = sizeof(u8),
+	.min = 0,
+	.max = 0xFFFFFFFF,
+	.def = 240,
+	.step = 1,
+	.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_pwm = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_CID_PWM,
+	.name = "PWM Frequency Selector",
+	.type = V4L2_CTRL_TYPE_INTEGER,
+	.min = 0,
+	.max = 1,
+	.step = 1,
+	.def = 1,
+	.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE,
+};
+
+static const struct v4l2_ctrl_config d4xx_controls_link_freq = {
+	.ops = &ds5_ctrl_ops,
+	.id = V4L2_CID_LINK_FREQ,
+	.name = "V4L2_CID_LINK_FREQ",
+	.type = V4L2_CTRL_TYPE_INTEGER_MENU,
+	.max = ARRAY_SIZE(link_freq_menu_items) - 1,
+	.min =  0,
+	.step  = 0,
+	.def = 1,
+	.qmenu_int = link_freq_menu_items,
+};
+
+static const struct v4l2_ctrl_config d4xx_controls_q_sub_stream = {
+	.ops = &ds5_ctrl_ops,
+	.id = V4L2_CID_IPU_QUERY_SUB_STREAM,
+	.name = "query virtual channel",
+	.type = V4L2_CTRL_TYPE_INTEGER_MENU,
+	.max = ARRAY_SIZE(d4xx_query_sub_stream) - 1,
+	.min = 0,
+	.def = 0,
+	.menu_skip_mask = 0,
+	.qmenu_int = d4xx_query_sub_stream,
+};
+
+static const struct v4l2_ctrl_config d4xx_controls_s_sub_stream = {
+	.ops = &ds5_ctrl_ops,
+	.id = V4L2_CID_IPU_SET_SUB_STREAM,
+	.name = "set virtual channel",
+	.type = V4L2_CTRL_TYPE_INTEGER64,
+	.max = 0xFFFF,
+	.min = 0,
+	.def = 0,
+	.step = 1,
+};
+
+static int ds5_mux_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct ds5 *state = v4l2_get_subdevdata(sd);
+
+	dev_info(sd->dev, "%s(): %s (%p)\n", __func__, sd->name, fh);
+	if (state->dfu_dev.dfu_state_flag)
+		return -EBUSY;
+	state->dfu_dev.device_open_count++;
+
+	return 0;
+};
+
+static int ds5_mux_close(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct ds5 *state = v4l2_get_subdevdata(sd);
+
+	dev_info(sd->dev, "%s(): %s (%p)\n", __func__, sd->name, fh);
+	state->dfu_dev.device_open_count--;
+	return 0;
+};
+
+static const struct v4l2_subdev_internal_ops ds5_sensor_internal_ops = {
+	.open = ds5_mux_open,
+	.close = ds5_mux_close,
+};
+
+static int ds5_ctrl_init(struct ds5 *state, int sid)
+{
+	const struct v4l2_ctrl_ops *ops = &ds5_ctrl_ops;
+	struct ds5_ctrls *ctrls = &state->ctrls;
+	struct v4l2_ctrl_handler *hdl = &ctrls->handler;
+	struct v4l2_subdev *sd = &state->mux.sd.subdev;
+	int ret = -1;
+	struct ds5_sensor *sensor = NULL;
+
+	switch (sid) {
+	case 0:
+		hdl = &ctrls->handler_depth;
+		sensor = &state->depth.sensor;
+		break;
+	case 1:
+		hdl = &ctrls->handler_rgb;
+		sensor = &state->rgb.sensor;
+		break;
+	case 2:
+		hdl = &ctrls->handler_y8;
+		sensor = &state->motion_t.sensor;
+		break;
+	case 3:
+		hdl = &ctrls->handler_imu;
+		sensor = &state->imu.sensor;
+		break;
+	default:
+		hdl = &ctrls->handler;
+		sensor = NULL;
+		break;
+	}
+
+	dev_info(NULL, "%s(), line %d sid: %d\n", __func__, __LINE__, sid);
+	ret = v4l2_ctrl_handler_init(hdl, DS5_N_CONTROLS);
+	if (ret < 0) {
+		v4l2_err(sd, "cannot init ctrl handler (%d)\n", ret);
+		return ret;
+	}
+
+	if (sid == 0 || sid == 2) {
+		ctrls->laser_power = v4l2_ctrl_new_custom(hdl,
+						&ds5_ctrl_laser_power,
+						sensor);
+		ctrls->manual_laser_power = v4l2_ctrl_new_custom(hdl,
+						&ds5_ctrl_manual_laser_power,
+						sensor);
+	}
+
+	/* Total gain */
+	if (sid == 0 || sid == 2) {
+		ctrls->gain = v4l2_ctrl_new_std(hdl, ops,
+						V4L2_CID_ANALOGUE_GAIN,
+						16, 248, 1, 16);
+	} else if (sid == 1) {
+		ctrls->gain = v4l2_ctrl_new_std(hdl, ops,
+						V4L2_CID_ANALOGUE_GAIN,
+						0, 128, 1, 64);
+	}
+
+	if (ctrls->gain) {
+		ctrls->gain->priv = sensor;
+		ctrls->gain->flags =
+				V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE;
+	}
+	if (sid >= 0 && sid < 3) {
+
+		ctrls->auto_exp = v4l2_ctrl_new_std_menu(hdl, ops,
+				V4L2_CID_EXPOSURE_AUTO,
+				V4L2_EXPOSURE_APERTURE_PRIORITY,
+				~((1 << V4L2_EXPOSURE_MANUAL) |
+						(1 << V4L2_EXPOSURE_APERTURE_PRIORITY)),
+						V4L2_EXPOSURE_APERTURE_PRIORITY);
+
+		if (ctrls->auto_exp) {
+			ctrls->auto_exp->flags |=
+					V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE;
+			ctrls->auto_exp->priv = sensor;
+		}
+	}
+	/* Exposure time: V4L2_CID_EXPOSURE_ABSOLUTE default unit: 100 us. */
+	if (sid == 0 || sid == 2) {
+		ctrls->exposure = v4l2_ctrl_new_std(hdl, ops,
+					V4L2_CID_EXPOSURE_ABSOLUTE,
+					1, MAX_DEPTH_EXP, 1, DEF_DEPTH_EXP);
+	} else if (sid == 1) {
+		ctrls->exposure = v4l2_ctrl_new_std(hdl, ops,
+					V4L2_CID_EXPOSURE_ABSOLUTE,
+					1, MAX_RGB_EXP, 1, DEF_RGB_EXP);
+	}
+
+	if (ctrls->exposure) {
+		ctrls->exposure->priv = sensor;
+		ctrls->exposure->flags |=
+				V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE;
+		/* override default int type to u32 to match SKU & UVC */
+		ctrls->exposure->type = V4L2_CTRL_TYPE_U32;
+	}
+
+	ctrls->link_freq = v4l2_ctrl_new_custom(hdl, &d4xx_controls_link_freq, sensor);
+	dev_info(sd->dev, "%s(): %p\n", __func__, ctrls->link_freq);
+	if (ctrls->link_freq)
+	    ctrls->link_freq->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	ctrls->query_sub_stream = v4l2_ctrl_new_custom(hdl, &d4xx_controls_q_sub_stream, sensor);
+	ctrls->query_sub_stream->flags |=
+				V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE;
+
+	ctrls->set_sub_stream = v4l2_ctrl_new_custom(hdl, &d4xx_controls_s_sub_stream, sensor);
+	dev_info(NULL, "%s(), line %d\n", __func__, __LINE__);
+	if (hdl->error) {
+		v4l2_err(sd, "error creating controls (%d)\n", hdl->error);
+		ret = hdl->error;
+		v4l2_ctrl_handler_free(hdl);
+		return ret;
+	}
+
+	// ret = v4l2_ctrl_handler_setup(hdl);
+	// if (ret < 0) {
+	//	dev_err(&state->client->dev,
+	//		"failed to set default values for controls\n");
+	//	v4l2_ctrl_handler_free(hdl);
+	//	return ret;
+	// }
+
+	// Add these after v4l2_ctrl_handler_setup so they won't be set up
+	if (sid >= 0 && sid < 3) {
+		ctrls->log = v4l2_ctrl_new_custom(hdl, &ds5_ctrl_log, sensor);
+		ctrls->fw_version = v4l2_ctrl_new_custom(hdl, &ds5_ctrl_fw_version, sensor);
+		ctrls->gvd = v4l2_ctrl_new_custom(hdl, &ds5_ctrl_gvd, sensor);
+		ctrls->get_depth_calib =
+				v4l2_ctrl_new_custom(hdl, &ds5_ctrl_get_depth_calib, sensor);
+		ctrls->set_depth_calib =
+				v4l2_ctrl_new_custom(hdl, &ds5_ctrl_set_depth_calib, sensor);
+		ctrls->get_coeff_calib =
+				v4l2_ctrl_new_custom(hdl, &ds5_ctrl_get_coeff_calib, sensor);
+		ctrls->set_coeff_calib =
+				v4l2_ctrl_new_custom(hdl, &ds5_ctrl_set_coeff_calib, sensor);
+		ctrls->ae_roi_get = v4l2_ctrl_new_custom(hdl, &ds5_ctrl_ae_roi_get, sensor);
+		ctrls->ae_roi_set = v4l2_ctrl_new_custom(hdl, &ds5_ctrl_ae_roi_set, sensor);
+		ctrls->ae_setpoint_get =
+				v4l2_ctrl_new_custom(hdl, &ds5_ctrl_ae_setpoint_get, sensor);
+		ctrls->ae_setpoint_set =
+				v4l2_ctrl_new_custom(hdl, &ds5_ctrl_ae_setpoint_set, sensor);
+		ctrls->erb = v4l2_ctrl_new_custom(hdl, &ds5_ctrl_erb, sensor);
+		ctrls->ewb = v4l2_ctrl_new_custom(hdl, &ds5_ctrl_ewb, sensor);
+		ctrls->hwmc = v4l2_ctrl_new_custom(hdl, &ds5_ctrl_hwmc, sensor);
+		v4l2_ctrl_new_custom(hdl, &ds5_ctrl_hwmc_rw, sensor);
+	}
+	// DEPTH custom
+	if (sid == 0)
+		v4l2_ctrl_new_custom(hdl, &ds5_ctrl_pwm, sensor);
+	// IMU custom
+	if (sid == 3)
+		ctrls->fw_version = v4l2_ctrl_new_custom(hdl, &ds5_ctrl_fw_version, sensor);
+
+	switch (sid) {
+	case 0:
+		state->depth.sensor.sd.ctrl_handler = hdl;
+		dev_info(state->depth.sensor.sd.dev,
+			"%s():%d set ctrl_handler pad:%d\n",
+			__func__, __LINE__, state->depth.sensor.mux_pad);
+		break;
+	case 1:
+		state->rgb.sensor.sd.ctrl_handler = hdl;
+		dev_info(state->rgb.sensor.sd.dev,
+			"%s():%d set ctrl_handler pad:%d\n",
+			__func__, __LINE__, state->rgb.sensor.mux_pad);
+		break;
+	case 2:
+		state->motion_t.sensor.sd.ctrl_handler = hdl;
+		dev_info(state->motion_t.sensor.sd.dev,
+			"%s():%d set ctrl_handler pad:%d\n",
+			__func__, __LINE__, state->motion_t.sensor.mux_pad);
+		break;
+	case 3:
+		state->imu.sensor.sd.ctrl_handler = hdl;
+		dev_info(state->imu.sensor.sd.dev,
+			"%s():%d set ctrl_handler pad:%d\n",
+			__func__, __LINE__, state->imu.sensor.mux_pad);
+		break;
+	default:
+		state->mux.sd.subdev.ctrl_handler = hdl;
+		dev_info(state->mux.sd.subdev.dev,
+			"%s():%d set ctrl_handler for MUX\n", __func__, __LINE__);
+		break;
+	}
+
+	return 0;
+}
+
+static int ds5_sensor_init(struct i2c_client *c, struct ds5 *state,
+		struct ds5_sensor *sensor, const struct v4l2_subdev_ops *ops,
+		const char *name)
+{
+	struct v4l2_subdev *sd = &sensor->sd;
+	struct media_entity *entity = &sensor->sd.entity;
+	struct media_pad *pad = &sensor->pad;
+	dev_t *dev_num = &state->client->dev.devt;
+	struct d4xx_pdata *dpdata = c->dev.platform_data;
+
+	v4l2_i2c_subdev_init(sd, c, ops);
+	sd->owner = NULL;
+	sd->internal_ops = &ds5_sensor_internal_ops;
+	sd->grp_id = *dev_num;
+	v4l2_set_subdevdata(sd, state);
+	/*
+	 * TODO: suffix for 2 D457 connected to 1 Deser
+	 */
+	snprintf(sd->name, sizeof(sd->name), "D4XX %s %c", name, dpdata->subdev_info[0].suffix);
+
+	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	pad->flags = MEDIA_PAD_FL_SOURCE;
+	entity->obj_type = MEDIA_ENTITY_TYPE_V4L2_SUBDEV;
+	entity->function = MEDIA_ENT_F_CAM_SENSOR;
+	return media_entity_pads_init(entity, 1, pad);
+}
+
+static int ds5_sensor_register(struct ds5 *state, struct ds5_sensor *sensor)
+{
+	struct v4l2_subdev *sd = &sensor->sd;
+	struct media_entity *entity = &sensor->sd.entity;
+	int ret = -1;
+
+	// FIXME: is async needed?
+	ret = v4l2_device_register_subdev(state->mux.sd.subdev.v4l2_dev, sd);
+	if (ret < 0) {
+		dev_err(sd->dev, "%s(): %d: %d\n", __func__, __LINE__, ret);
+		return ret;
+	}
+
+	ret = media_create_pad_link(entity, 0,
+			&state->mux.sd.subdev.entity, sensor->mux_pad,
+			MEDIA_LNK_FL_IMMUTABLE | MEDIA_LNK_FL_ENABLED);
+	if (ret < 0) {
+		dev_err(sd->dev, "%s(): %d: %d\n", __func__, __LINE__, ret);
+		goto e_sd;
+	}
+
+	dev_info(sd->dev, "%s(): 0 -> %d\n", __func__, sensor->mux_pad);
+
+	return 0;
+
+e_sd:
+	v4l2_device_unregister_subdev(sd);
+
+	return ret;
+}
+
+static void ds5_sensor_remove(struct ds5_sensor *sensor)
+{
+	v4l2_device_unregister_subdev(&sensor->sd);
+
+	media_entity_cleanup(&sensor->sd.entity);
+}
+
+static int ds5_depth_init(struct i2c_client *c, struct ds5 *state)
+{
+	/* Which mux pad we're connecting to */
+	state->depth.sensor.mux_pad = DS5_MUX_PAD_DEPTH_A;
+	return ds5_sensor_init(c, state, &state->depth.sensor,
+		       &ds5_depth_subdev_ops, "depth");
+}
+
+static int ds5_motion_t_init(struct i2c_client *c, struct ds5 *state)
+{
+	state->motion_t.sensor.mux_pad = DS5_MUX_PAD_MOTION_T_A;
+	return ds5_sensor_init(c, state, &state->motion_t.sensor,
+		       &ds5_motion_t_subdev_ops, "motion detection");
+}
+
+static int ds5_rgb_init(struct i2c_client *c, struct ds5 *state)
+{
+	state->rgb.sensor.mux_pad = DS5_MUX_PAD_RGB_A;
+	return ds5_sensor_init(c, state, &state->rgb.sensor,
+		       &ds5_rgb_subdev_ops, "rgb");
+}
+
+static int ds5_imu_init(struct i2c_client *c, struct ds5 *state)
+{
+	state->imu.sensor.mux_pad = DS5_MUX_PAD_IMU_A;
+	return ds5_sensor_init(c, state, &state->imu.sensor,
+		       &ds5_imu_subdev_ops, "imu");
+}
+
+/* No locking needed */
+static int ds5_mux_enum_mbus_code(struct v4l2_subdev *sd,
+				     struct v4l2_subdev_state *v4l2_state,
+				  struct v4l2_subdev_mbus_code_enum *mce)
+{
+	struct ds5 *state = container_of(sd, struct ds5, mux.sd.subdev);
+	struct v4l2_subdev_mbus_code_enum tmp = *mce;
+	struct v4l2_subdev *remote_sd;
+	int ret = -1;
+
+	dev_info(&state->client->dev, "%s(): %s \n", __func__, sd->name);
+	switch (mce->pad) {
+	case DS5_MUX_PAD_MOTION_T_A:
+		remote_sd = &state->motion_t.sensor.sd;
+		break;
+	case DS5_MUX_PAD_DEPTH_A:
+		remote_sd = &state->depth.sensor.sd;
+		break;
+	case DS5_MUX_PAD_RGB_A:
+		remote_sd = &state->rgb.sensor.sd;
+		break;
+	case DS5_MUX_PAD_IMU_A:
+		remote_sd = &state->imu.sensor.sd;
+		break;
+	case DS5_MUX_PAD_EXTERNAL:
+		if (mce->index >= state->motion_t.sensor.n_formats +
+				state->depth.sensor.n_formats)
+			return -EINVAL;
+
+		/*
+		 * First list Left node / Motion Tracker formats, then depth.
+		 * This should also help because D16 doesn't have a direct
+		 * analog in MIPI CSI-2.
+		 */
+		if (mce->index < state->motion_t.sensor.n_formats) {
+			remote_sd = &state->motion_t.sensor.sd;
+		} else {
+			tmp.index = mce->index - state->motion_t.sensor.n_formats;
+			remote_sd = &state->depth.sensor.sd;
+		}
+
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	tmp.pad = 0;
+	if (state->is_rgb)
+		remote_sd = &state->rgb.sensor.sd;
+	if (state->is_depth)
+		remote_sd = &state->depth.sensor.sd;
+	if (state->is_y8)
+		remote_sd = &state->motion_t.sensor.sd;
+	if (state->is_imu)
+		remote_sd = &state->imu.sensor.sd;
+
+	/* Locks internally */
+	ret = ds5_sensor_enum_mbus_code(remote_sd, v4l2_state, &tmp);
+	if (!ret)
+		mce->code = tmp.code;
+
+	return ret;
+}
+
+/* No locking needed */
+static int ds5_mux_enum_frame_size(struct v4l2_subdev *sd,
+				     struct v4l2_subdev_state *v4l2_state,
+				   struct v4l2_subdev_frame_size_enum *fse)
+{
+	struct ds5 *state = container_of(sd, struct ds5, mux.sd.subdev);
+	struct v4l2_subdev_frame_size_enum tmp = *fse;
+	struct v4l2_subdev *remote_sd;
+	u32 pad = fse->pad;
+	int ret = -1;
+
+	tmp.pad = 0;
+
+	if (state->is_depth)
+		pad = DS5_MUX_PAD_DEPTH_A;
+	if (state->is_y8)
+		pad = DS5_MUX_PAD_MOTION_T_A;
+	if (state->is_rgb)
+		pad = DS5_MUX_PAD_RGB_A;
+	if (state->is_imu)
+		pad = DS5_MUX_PAD_IMU_A;
+
+	switch (pad) {
+	case DS5_MUX_PAD_MOTION_T_A:
+		remote_sd = &state->motion_t.sensor.sd;
+		break;
+	case DS5_MUX_PAD_DEPTH_A:
+		remote_sd = &state->depth.sensor.sd;
+		break;
+	case DS5_MUX_PAD_RGB_A:
+		remote_sd = &state->rgb.sensor.sd;
+		break;
+	case DS5_MUX_PAD_IMU_A:
+		remote_sd = &state->imu.sensor.sd;
+		break;
+	case DS5_MUX_PAD_EXTERNAL:
+		/*
+		 * Assume, that different sensors don't support the same formats
+		 * Try the Depth sensor first, then the Motion Tracker
+		 */
+		remote_sd = &state->depth.sensor.sd;
+		ret = ds5_sensor_enum_frame_size(remote_sd, NULL, &tmp);
+		if (!ret) {
+			*fse = tmp;
+			fse->pad = pad;
+			return 0;
+		}
+
+		remote_sd = &state->motion_t.sensor.sd;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* Locks internally */
+	ret = ds5_sensor_enum_frame_size(remote_sd, NULL, &tmp);
+	if (!ret) {
+		*fse = tmp;
+		fse->pad = pad;
+	}
+
+	return ret;
+}
+
+/* No locking needed */
+static int ds5_mux_enum_frame_interval(struct v4l2_subdev *sd,
+				     struct v4l2_subdev_state *v4l2_state,
+				     struct v4l2_subdev_frame_interval_enum *fie)
+{
+	struct ds5 *state = container_of(sd, struct ds5, mux.sd.subdev);
+	struct v4l2_subdev_frame_interval_enum tmp = *fie;
+	struct v4l2_subdev *remote_sd;
+	u32 pad = fie->pad;
+	int ret = -1;
+
+	tmp.pad = 0;
+
+	dev_err(state->depth.sensor.sd.dev,
+			"%s(): pad %d code %x width %d height %d\n",
+			__func__, pad, tmp.code, tmp.width, tmp.height);
+
+	if (state->is_depth)
+		pad = DS5_MUX_PAD_DEPTH_A;
+	if (state->is_y8)
+		pad = DS5_MUX_PAD_MOTION_T_A;
+	if (state->is_rgb)
+		pad = DS5_MUX_PAD_RGB_A;
+	if (state->is_imu)
+		pad = DS5_MUX_PAD_IMU_A;
+
+	switch (pad) {
+	case DS5_MUX_PAD_MOTION_T_A:
+		remote_sd = &state->motion_t.sensor.sd;
+		break;
+	case DS5_MUX_PAD_DEPTH_A:
+		remote_sd = &state->depth.sensor.sd;
+		break;
+	case DS5_MUX_PAD_RGB_A:
+		remote_sd = &state->rgb.sensor.sd;
+		break;
+	case DS5_MUX_PAD_IMU_A:
+		remote_sd = &state->imu.sensor.sd;
+		break;
+	case DS5_MUX_PAD_EXTERNAL:
+		/* Similar to ds5_mux_enum_frame_size() above */
+		if (state->is_rgb)
+			remote_sd = &state->rgb.sensor.sd;
+		else
+			remote_sd = &state->motion_t.sensor.sd;
+		ret = ds5_sensor_enum_frame_interval(remote_sd, NULL, &tmp);
+		if (!ret) {
+			*fie = tmp;
+			fie->pad = pad;
+			return 0;
+		}
+
+		remote_sd = &state->motion_t.sensor.sd;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* Locks internally */
+	ret = ds5_sensor_enum_frame_interval(remote_sd, NULL, &tmp);
+	if (!ret) {
+		*fie = tmp;
+		fie->pad = pad;
+	}
+
+	return ret;
+}
+
+/* No locking needed */
+static int ds5_mux_set_fmt(struct v4l2_subdev *sd,
+		struct v4l2_subdev_state *v4l2_state,
+		struct v4l2_subdev_format *fmt)
+{
+	struct ds5 *state = container_of(sd, struct ds5, mux.sd.subdev);
+	struct v4l2_mbus_framefmt *ffmt;
+	struct ds5_sensor *sensor = state->mux.last_set;
+	u32 pad = sensor->mux_pad;
+	// u32 pad = fmt->pad;
+	int ret = 0;
+	int substream = -1;
+
+	switch (pad) {
+	case DS5_MUX_PAD_DEPTH_A:
+	case DS5_MUX_PAD_MOTION_T_A:
+	case DS5_MUX_PAD_RGB_A:
+	case DS5_MUX_PAD_IMU_A:
+		//ffmt = &ds5_ffmts[pad];
+		ffmt = &sensor->format;//ds5_ffmts[pad];
+		break;
+	case DS5_MUX_PAD_EXTERNAL:
+		ffmt = &ds5_ffmts[pad];
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+		ffmt->width = fmt->format.width;
+		ffmt->height = fmt->format.height;
+		ffmt->code = fmt->format.code;
+	}
+	fmt->format = *ffmt;
+
+	// substream = pad_to_substream[fmt->pad];
+	substream = pad_to_substream[pad];
+
+	if (substream != -1) {
+		set_sub_stream_fmt(substream, ffmt->code);
+		set_sub_stream_h(substream, ffmt->height);
+		set_sub_stream_w(substream, ffmt->width);
+		set_sub_stream_dt(substream, mbus_code_to_mipi(ffmt->code));
+	}
+
+	dev_info(sd->dev, "%s(): fmt->pad:%d, sensor->mux_pad: %d, \
+		code: 0x%x: %ux%u substream:%d for sensor: %s\n",
+		__func__,
+		fmt->pad, pad, fmt->format.code,
+		fmt->format.width, fmt->format.height,
+		substream, sensor->sd.name);
+
+	return ret;
+}
+
+/* No locking needed */
+static int ds5_mux_get_fmt(struct v4l2_subdev *sd,
+				     struct v4l2_subdev_state *v4l2_state,
+			   struct v4l2_subdev_format *fmt)
+{
+	struct ds5 *state = container_of(sd, struct ds5, mux.sd.subdev);
+	// u32 pad = fmt->pad;
+	int ret = 0;
+	struct ds5_sensor *sensor = state->mux.last_set;
+	u32 pad = sensor->mux_pad;
+
+	dev_info(sd->dev, "%s(): %u %p\n", __func__, pad, state->mux.last_set);
+
+	switch (pad) {
+	case DS5_MUX_PAD_DEPTH_A:
+	case DS5_MUX_PAD_MOTION_T_A:
+	case DS5_MUX_PAD_RGB_A:
+	case DS5_MUX_PAD_IMU_A:
+		//fmt->format = ds5_ffmts[pad];
+		fmt->format = sensor->format;//ds5_ffmts[pad];
+		break;
+	case DS5_MUX_PAD_EXTERNAL:
+	fmt->format = ds5_ffmts[pad];
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	dev_dbg(sd->dev, "%s(): fmt->pad:%d, sensor->mux_pad:%u size:%d-%d, code:0x%x field:%d, color:%d\n",
+		__func__, fmt->pad, pad,
+		fmt->format.width, fmt->format.height, fmt->format.code,
+		fmt->format.field, fmt->format.colorspace);
+	return ret;
+}
+
+/* Video ops */
+static int ds5_mux_g_frame_interval(struct v4l2_subdev *sd,
+		struct v4l2_subdev_frame_interval *fi)
+{
+	struct ds5 *state = container_of(sd, struct ds5, mux.sd.subdev);
+	struct ds5_sensor *sensor = NULL;
+
+	if (NULL == sd || NULL == fi)
+		return -EINVAL;
+
+	sensor = state->mux.last_set;
+
+	fi->interval.numerator = 1;
+	fi->interval.denominator = sensor->config.framerate;
+
+	dev_info(sd->dev, "%s(): %s %u\n", __func__, sd->name,
+			fi->interval.denominator);
+
+	return 0;
+}
+
+static u16 __ds5_probe_framerate(const struct ds5_resolution *res, u16 target)
+{
+	int i;
+	u16 framerate;
+
+	for (i = 0; i < res->n_framerates; i++) {
+		framerate = res->framerates[i];
+		if (target <= framerate)
+			return framerate;
+	}
+
+	return res->framerates[res->n_framerates - 1];
+}
+
+static int ds5_mux_s_frame_interval(struct v4l2_subdev *sd,
+		struct v4l2_subdev_frame_interval *fi)
+{
+	struct ds5 *state = container_of(sd, struct ds5, mux.sd.subdev);
+	struct ds5_sensor *sensor = NULL;
+	u16 framerate = 1;
+
+	if (NULL == sd || NULL == fi || fi->interval.numerator == 0)
+		return -EINVAL;
+
+	sensor = state->mux.last_set;
+
+	framerate = fi->interval.denominator / fi->interval.numerator;
+	framerate = __ds5_probe_framerate(sensor->config.resolution, framerate);
+	sensor->config.framerate = framerate;
+	fi->interval.numerator = 1;
+	fi->interval.denominator = framerate;
+
+	dev_info(sd->dev, "%s(): %s %u\n", __func__, sd->name, framerate);
+
+	return 0;
+}
+
+static int ds5_mux_s_stream(struct v4l2_subdev *sd, int on)
+{
+	struct ds5 *state = container_of(sd, struct ds5, mux.sd.subdev);
+	u16 streaming, status;
+	int ret = 0;
+	unsigned int i = 0;
+	int restore_val = 0;
+	u16 config_status_base, stream_status_base, stream_id, vc_id;
+
+	if (state->is_depth) {
+		config_status_base = DS5_DEPTH_CONFIG_STATUS;
+		stream_status_base = DS5_DEPTH_STREAM_STATUS;
+		stream_id = DS5_STREAM_DEPTH;
+		vc_id = 0;
+	} else if (state->is_rgb) {
+		config_status_base = DS5_RGB_CONFIG_STATUS;
+		stream_status_base = DS5_RGB_STREAM_STATUS;
+		stream_id = DS5_STREAM_RGB;
+		vc_id = 1;
+	} else if (state->is_y8) {
+		config_status_base = DS5_IR_CONFIG_STATUS;
+		stream_status_base = DS5_IR_STREAM_STATUS;
+		stream_id = DS5_STREAM_IR;
+		vc_id = 2;
+	} else if (state->is_imu) {
+		config_status_base = DS5_IMU_CONFIG_STATUS;
+		stream_status_base = DS5_IMU_STREAM_STATUS;
+		stream_id = DS5_STREAM_IMU;
+		vc_id = 3;
+	} else {
+		return -EINVAL;
+	}
+
+	dev_warn(&state->client->dev, "s_stream for stream %s, on = %d\n",
+			state->mux.last_set->sd.name, on);
+
+	restore_val = state->mux.last_set->streaming;
+	state->mux.last_set->streaming = on;
+
+	if (on) {
+
+		ret = ds5_configure(state);
+		if (ret)
+			goto restore_s_state;
+
+		ret = ds5_write(state, DS5_START_STOP_STREAM,
+				DS5_STREAM_START | stream_id);
+		if (ret < 0)
+			goto restore_s_state;
+
+		// check streaming status from FW
+		for (i = 0; i < DS5_START_MAX_COUNT; i++) {
+			ds5_read(state, stream_status_base, &streaming);
+			ds5_read(state, config_status_base, &status);
+			if ((status & DS5_STATUS_STREAMING) &&
+					streaming == DS5_STREAM_STREAMING)
+				break;
+
+			msleep_range(DS5_START_POLL_TIME);
+		}
+
+		if (i == DS5_START_MAX_COUNT) {
+			dev_err(&state->client->dev,
+				"start streaming failed, exit on timeout\n");
+			/* notify fw */
+			ret = ds5_write(state, DS5_START_STOP_STREAM,
+					DS5_STREAM_STOP | stream_id);
+			ret = -EAGAIN;
+			goto restore_s_state;
+		} else {
+			dev_dbg(&state->client->dev, "started after %dms\n",
+				i * DS5_START_POLL_TIME);
+		}
+	} else {
+		ret = ds5_write(state, DS5_START_STOP_STREAM,
+				DS5_STREAM_STOP | stream_id);
+		if (ret < 0)
+			goto restore_s_state;
+	}
+
+	ds5_read(state, config_status_base, &status);
+	ds5_read(state, stream_status_base, &streaming);
+	dev_info(&state->client->dev,
+			"%s %s, stream_status 0x%x:%x, config_status 0x%x:%x\n",
+			ds5_get_sensor_name(state),
+			(on)?"START":"STOP",
+			stream_status_base, streaming,
+			config_status_base, status);
+
+	return ret;
+
+restore_s_state:
+
+	ds5_read(state, config_status_base, &status);
+	dev_err(&state->client->dev,
+			"%s stream toggle failed! %x status 0x%04x\n",
+			ds5_get_sensor_name(state), restore_val, status);
+
+	state->mux.last_set->streaming = restore_val;
+
+	return ret;
+}
+
+//static int ds5_set_power(struct ds5 *state, int on)
+//{
+//	int ret = 0;
+//
+//	mutex_lock(&state->lock);
+//
+//	if (state->power != !on) {
+//		mutex_unlock(&state->lock);
+//		return 0;
+//	}
+//
+////	gpio_set_value_cansleep(state->pwdn_gpio, on);
+//
+//	dev_info(&state->client->dev, "%s(): power %d\n", __func__, on);
+//
+//	usleep_range(100, 200);
+//
+//	if (on) {
+//		state->power = true;
+//	} else {
+//		state->power = false;
+//	}
+//
+//	mutex_unlock(&state->lock);
+//
+//	/* TODO: Restore controls when powering on */
+//	//if (on)
+//	//	ret = v4l2_ctrl_handler_setup(&state->ctrls.handler);
+//
+//	return ret;
+//}
+
+/* Core ops */
+/*static int ds5_mux_set_power(struct v4l2_subdev *sd, int on)
+{
+	struct ds5 *state = container_of(sd, struct ds5, mux.sd.subdev);
+
+	return ds5_set_power(state, on);
+}*/
+
+#define DS5_N_STREAMS 4
+#define DS5_PAD_SOURCE 0
+
+static int ds5_mux_get_frame_desc(struct v4l2_subdev *sd,
+	unsigned int pad, struct v4l2_mbus_frame_desc *desc)
+{
+	unsigned int i;
+
+	desc->num_entries = V4L2_FRAME_DESC_ENTRY_MAX;
+
+	for (i = 0; i < desc->num_entries; i++) {
+		desc->entry[i].flags = 0;
+		desc->entry[i].pixelcode = MEDIA_BUS_FMT_FIXED;
+		desc->entry[i].length = 0;
+		if (i == desc->num_entries - 1) {
+			desc->entry[i].pixelcode = 0x12;
+			desc->entry[i].length = 68;
+		}
+	}
+	return 0;
+}
+
+static const struct v4l2_subdev_pad_ops ds5_mux_pad_ops = {
+	.enum_mbus_code		= ds5_mux_enum_mbus_code,
+	.enum_frame_size	= ds5_mux_enum_frame_size,
+	.enum_frame_interval	= ds5_mux_enum_frame_interval,
+	.get_fmt		= ds5_mux_get_fmt,
+	.set_fmt		= ds5_mux_set_fmt,
+	.get_frame_desc		= ds5_mux_get_frame_desc,
+};
+
+static const struct v4l2_subdev_core_ops ds5_mux_core_ops = {
+	//.s_power = ds5_mux_set_power,
+	.log_status = v4l2_ctrl_subdev_log_status,
+};
+
+static const struct v4l2_subdev_video_ops ds5_mux_video_ops = {
+	.g_frame_interval	= ds5_mux_g_frame_interval,
+	.s_frame_interval	= ds5_mux_s_frame_interval,
+	.s_stream		= ds5_mux_s_stream,
+};
+
+static const struct v4l2_subdev_ops ds5_mux_subdev_ops = {
+	.core = &ds5_mux_core_ops,
+	.pad = &ds5_mux_pad_ops,
+	.video = &ds5_mux_video_ops,
+};
+
+#if 0 /* function not used */
+static int ds5_des_register(struct ds5 *state, struct ds5_des *des)
+{
+	struct v4l2_subdev *sd = &des->sd;
+	int ret;
+
+	// FIXME: is async needed?
+	ret = v4l2_device_register_subdev(state->mux.sd.subdev.v4l2_dev, sd);
+	if (ret < 0) {
+		return ret;
+	}
+
+	//ret = media_create_pad_link(entity, 1, &state->mux.sd.subdev.entity, des->mux_pad,
+	//			       MEDIA_LNK_FL_IMMUTABLE | MEDIA_LNK_FL_ENABLED);
+	//if (ret < 0) {
+	//	goto e_sd;
+       // }
+
+	dev_info(sd->dev, "%s(): 0 -> %d\n", __func__, des->mux_pad);
+
+	return 0;
+
+e_sd:
+	v4l2_device_unregister_subdev(sd);
+
+	return ret;
+}
+#endif
+
+static int ds5_mux_registered(struct v4l2_subdev *sd)
+{
+	struct ds5 *state = v4l2_get_subdevdata(sd);
+	int ret = ds5_sensor_register(state, &state->depth.sensor);
+	if (ret < 0)
+		return ret;
+
+	ret = ds5_sensor_register(state, &state->motion_t.sensor);
+	if (ret < 0)
+		goto e_depth;
+
+	ret = ds5_sensor_register(state, &state->rgb.sensor);
+	if (ret < 0)
+		goto e_rgb;
+
+	ret = ds5_sensor_register(state, &state->imu.sensor);
+	if (ret < 0)
+		goto e_imu;
+
+	return 0;
+
+e_imu:
+	v4l2_device_unregister_subdev(&state->rgb.sensor.sd);
+
+e_rgb:
+	v4l2_device_unregister_subdev(&state->motion_t.sensor.sd);
+
+e_depth:
+	v4l2_device_unregister_subdev(&state->depth.sensor.sd);
+
+	return ret;
+}
+
+static void ds5_mux_unregistered(struct v4l2_subdev *sd)
+{
+	struct ds5 *state = v4l2_get_subdevdata(sd);
+
+	ds5_sensor_remove(&state->imu.sensor);
+	ds5_sensor_remove(&state->rgb.sensor);
+	ds5_sensor_remove(&state->motion_t.sensor);
+	ds5_sensor_remove(&state->depth.sensor);
+}
+
+static const struct v4l2_subdev_internal_ops ds5_mux_internal_ops = {
+	.open = ds5_mux_open,
+	.close = ds5_mux_close,
+	.registered = ds5_mux_registered,
+	.unregistered = ds5_mux_unregistered,
+};
+
+static int ds5_mux_register(struct i2c_client *c, struct ds5 *state)
+{
+	return v4l2_async_register_subdev(&state->mux.sd.subdev);
+}
+
+static int ds5_hw_init(struct i2c_client *c, struct ds5 *state)
+{
+	struct v4l2_subdev *sd = &state->mux.sd.subdev;
+	u16 mipi_status, n_lanes, phy, drate_min, drate_max;
+	int ret = ds5_read(state, DS5_MIPI_SUPPORT_LINES, &n_lanes);
+	if (!ret)
+		ret = ds5_read(state, DS5_MIPI_SUPPORT_PHY, &phy);
+
+	if (!ret)
+		ret = ds5_read(state, DS5_MIPI_DATARATE_MIN, &drate_min);
+
+	if (!ret)
+		ret = ds5_read(state, DS5_MIPI_DATARATE_MAX, &drate_max);
+
+	n_lanes = 2;
+
+	ret = ds5_write(state, DS5_MIPI_LANE_NUMS, n_lanes - 1);
+	if (!ret)
+		ret = ds5_write(state, DS5_MIPI_LANE_DATARATE, MIPI_LANE_RATE);
+
+	ret = ds5_read(state, DS5_MIPI_CONF_STATUS, &mipi_status);
+
+	return ret;
+}
+
+#if 0 /* not used function */
+static int ds5_des_init(struct i2c_client *c, struct ds5 *state)
+{
+	struct v4l2_subdev *sd = &state->max9296.des.sd;
+	struct media_entity *entity = &state->max9296.des.sd.entity;
+	struct media_pad *pads = state->max9296.des.pads;
+	dev_t *dev_num = &state->client->dev.devt;
+
+	state->max9296.des.mux_pad = DS5_MUX_PAD_EXTERNAL;
+
+	dev_info(sd->dev, "%s(): %p %s %p %p", __func__, c, c->name, state, state->client);
+
+	v4l2_i2c_subdev_init(sd, c, &ds5_mux_subdev_ops);
+	sd->owner = THIS_MODULE;
+	sd->internal_ops = &ds5_sensor_internal_ops;
+	sd->grp_id = *dev_num;
+	v4l2_set_subdevdata(sd, state);
+	snprintf(sd->name, sizeof(sd->name), "D4XX %s %d-%04x",
+		"max9296", i2c_adapter_id(c->adapter), 0x48);
+
+	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	pads[0].flags = MEDIA_PAD_FL_SOURCE;
+	pads[1].flags = MEDIA_PAD_FL_SINK;
+	entity->obj_type = MEDIA_ENTITY_TYPE_V4L2_SUBDEV;
+	entity->function = MEDIA_ENT_F_CAM_SENSOR;
+	return media_entity_pads_init(entity, 2, pads);
+}
+#endif
+static int ds5_mux_init(struct i2c_client *c, struct ds5 *state)
+{
+	struct v4l2_subdev *sd = &state->mux.sd.subdev;
+	struct media_entity *entity = &state->mux.sd.subdev.entity;
+	struct media_pad *pads = state->mux.pads, *pad;
+	unsigned int i;
+	int ret;
+
+	struct d4xx_pdata *dpdata = c->dev.platform_data;
+	v4l2_i2c_subdev_init(sd, c, &ds5_mux_subdev_ops);
+	// Set owner to NULL so we can unload the driver module
+	sd->owner = NULL;
+	sd->internal_ops = &ds5_mux_internal_ops;
+	v4l2_set_subdevdata(sd, state);
+	snprintf(sd->name, sizeof(sd->name), "DS5 mux %c", dpdata->suffix);
+
+	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	entity->obj_type = MEDIA_ENTITY_TYPE_V4L2_SUBDEV;
+	entity->function = MEDIA_ENT_F_CAM_SENSOR;
+
+	pads[0].flags = MEDIA_PAD_FL_SOURCE;
+	for (i = 1, pad = pads + 1; i < ARRAY_SIZE(state->mux.pads); i++, pad++)
+		pad->flags = MEDIA_PAD_FL_SINK;
+
+	ret = media_entity_pads_init(entity, ARRAY_SIZE(state->mux.pads), pads);
+	if (ret < 0)
+		return ret;
+
+	/*set for mux*/
+	ret = ds5_ctrl_init(state, -1);
+	if (ret < 0)
+		return ret;
+	/*set for depth*/
+	ret = ds5_ctrl_init(state, 0);
+	if (ret < 0)
+		return ret;
+	/*set for rgb*/
+	ret = ds5_ctrl_init(state, 1);
+	if (ret < 0)
+		return ret;
+	/*set for y8*/
+	ret = ds5_ctrl_init(state, 2);
+	if (ret < 0)
+		return ret;
+	/*set for imu*/
+	ret = ds5_ctrl_init(state, 3);
+	if (ret < 0)
+		return ret;
+
+	ds5_set_state_last_set(state);
+
+#ifdef CONFIG_TEGRA_CAMERA_PLATFORM
+	state->mux.sd.dev = &c->dev;
+	ret = camera_common_initialize(&state->mux.sd, "d4xx");
+	if (ret) {
+		dev_err(&c->dev, "Failed to initialize d4xx.\n");
+		goto e_ctrl;
+	}
+#endif
+
+	return 0;
+
+#ifdef CONFIG_TEGRA_CAMERA_PLATFORM
+e_ctrl:
+	v4l2_ctrl_handler_free(sd->ctrl_handler);
+#endif
+	media_entity_cleanup(entity);
+
+	return ret;
+}
+
+#define USE_Y
+
+static int ds5_fixed_configuration(struct i2c_client *client, struct ds5 *state)
+{
+	struct ds5_sensor *sensor;
+	u16 cfg0 = 0, cfg0_md = 0, cfg1 = 0, cfg1_md = 0;
+	u16 dw = 0, dh = 0, yw = 0, yh = 0, dev_type = 0;
+	int ret;
+
+	ret = ds5_read(state, DS5_DEPTH_STREAM_DT, &cfg0);
+	if (!ret)
+		ret = ds5_read(state, DS5_DEPTH_STREAM_MD, &cfg0_md);
+	if (!ret)
+		ret = ds5_read(state, DS5_DEPTH_RES_WIDTH, &dw);
+	if (!ret)
+		ret = ds5_read(state, DS5_DEPTH_RES_HEIGHT, &dh);
+	if (!ret)
+		ret = ds5_read(state, DS5_IR_STREAM_DT, &cfg1);
+	if (!ret)
+		ret = ds5_read(state, DS5_IR_STREAM_MD, &cfg1_md);
+	if (!ret)
+		ret = ds5_read(state, DS5_IR_RES_WIDTH, &yw);
+	if (!ret)
+		ret = ds5_read(state, DS5_IR_RES_HEIGHT, &yh);
+	if (!ret)
+		ret = ds5_read(state, DS5_DEVICE_TYPE, &dev_type);
+	if (ret < 0)
+		return ret;
+
+	dev_info(&client->dev, "%s(): cfg0 %x %ux%u cfg0_md %x %ux%u\n", __func__,
+		 cfg0, dw, dh, cfg0_md, yw, yh);
+
+	dev_info(&client->dev, "%s(): cfg1 %x %ux%u cfg1_md %x %ux%u\n", __func__,
+		 cfg1, dw, dh, cfg1_md, yw, yh);
+
+	sensor = &state->depth.sensor;
+	switch (dev_type) {
+	case DS5_DEVICE_TYPE_D43X:
+	case DS5_DEVICE_TYPE_D45X:
+		sensor->formats = ds5_depth_formats_d43x;
+		break;
+	case DS5_DEVICE_TYPE_D46X:
+		sensor->formats = ds5_depth_formats_d46x;
+		break;
+	default:
+		sensor->formats = ds5_depth_formats_d46x;
+	}
+	sensor->n_formats = 1;
+	sensor->mux_pad = DS5_MUX_PAD_DEPTH_A;
+
+	sensor = &state->motion_t.sensor;
+	sensor->formats = state->variant->formats;
+	sensor->n_formats = state->variant->n_formats;
+	sensor->mux_pad = DS5_MUX_PAD_MOTION_T_A;
+	switch (dev_type) {
+	// case DS5_DEVICE_TYPE_D45X:
+	case DS5_DEVICE_TYPE_D43X: {
+		unsigned int *calib_resolutions_size =
+			(unsigned int *)&(sensor->formats[ARRAY_SIZE(ds5_y_formats_ds5u)-1].n_resolutions);
+		const struct ds5_resolution **calib_resolutions = (const struct ds5_resolution **)
+					    &(sensor->formats[ARRAY_SIZE(ds5_y_formats_ds5u)-1].resolutions);
+		*calib_resolutions_size = ARRAY_SIZE(d43x_calibration_sizes),
+		*calib_resolutions = d43x_calibration_sizes;
+		break;
+	}
+	case DS5_DEVICE_TYPE_D46X: {
+		dev_info(&client->dev, "%s(): DS5_DEVICE_TYPE_D46X for calib\n", __func__);
+		/*unsigned int *calib_resolutions_size =
+		 *	(unsigned int *)&(sensor->formats[ARRAY_SIZE(ds5_y_formats_ds5u)-1].n_resolutions);
+		 *const struct ds5_resolution **calib_resolutions = (const struct ds5_resolution**)
+		 *			    &(sensor->formats[ARRAY_SIZE(ds5_y_formats_ds5u)-1].resolutions);
+		 **calib_resolutions_size = ARRAY_SIZE(d46x_calibration_sizes),
+		 **calib_resolutions = d46x_calibration_sizes;
+		 */
+		break;
+	}
+	}
+
+	sensor = &state->rgb.sensor;
+	switch (dev_type) {
+	case DS5_DEVICE_TYPE_D43X:
+	case DS5_DEVICE_TYPE_D46X:
+		sensor->formats = &ds5_onsemi_rgb_format;
+		sensor->n_formats = DS5_ONSEMI_RGB_N_FORMATS;
+		break;
+	case DS5_DEVICE_TYPE_D45X:
+		sensor->formats = &ds5_rlt_rgb_format;
+		sensor->n_formats = DS5_RLT_RGB_N_FORMATS;
+		break;
+	default:
+		sensor->formats = &ds5_onsemi_rgb_format;
+		sensor->n_formats = DS5_ONSEMI_RGB_N_FORMATS;
+	}
+	sensor->mux_pad = DS5_MUX_PAD_RGB_A;
+
+	/*sensor->formats = &ds5_onsemi_rgb_format;
+	 *sensor->n_formats = DS5_RGB_N_FORMATS;
+	 *sensor->mux_pad = DS5_MUX_PAD_RGB;
+	 */
+
+	sensor = &state->imu.sensor;
+	sensor->formats = ds5_imu_formats;
+	sensor->n_formats = 1;
+	sensor->mux_pad = DS5_MUX_PAD_IMU_A;
+
+	/* Development: set a configuration during probing */
+	if ((cfg0 & 0xff00) == 0x1800) {
+		/* MIPI CSI-2 YUV420 isn't supported by V4L, reconfigure to Y8 */
+		struct v4l2_subdev_format fmt = {
+			.which = V4L2_SUBDEV_FORMAT_ACTIVE,
+			.pad = 0,
+			/* Use template to fill in .field, .colorspace etc. */
+			.format = ds5_mbus_framefmt_template,
+		};
+
+//#undef USE_Y
+		/* Override .width, .height, .code */
+		fmt.format.width = yw;
+		fmt.format.height = yh;
+		fmt.format.code = MEDIA_BUS_FMT_UYVY8_2X8;
+
+		//state->mux.sd.mode_prop_idx = 0;
+		state->motion_t.sensor.streaming = true;
+		state->depth.sensor.streaming = true;
+		ret = __ds5_sensor_set_fmt(state, &state->motion_t.sensor, NULL, &fmt);
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int ds5_parse_cam(struct i2c_client *client, struct ds5 *state)
+{
+	int ret;
+
+	ret = ds5_fixed_configuration(client, state);
+	if (ret < 0)
+		return ret;
+
+	ds5_sensor_format_init(&state->depth.sensor);
+	ds5_sensor_format_init(&state->motion_t.sensor);
+	ds5_sensor_format_init(&state->rgb.sensor);
+	ds5_sensor_format_init(&state->imu.sensor);
+
+	return 0;
+}
+
+static void ds5_mux_remove(struct ds5 *state)
+{
+#ifdef CONFIG_TEGRA_CAMERA_PLATFORM
+	camera_common_cleanup(&state->mux.sd);
+#endif
+	v4l2_async_unregister_subdev(&state->mux.sd.subdev);
+	v4l2_ctrl_handler_free(state->mux.sd.subdev.ctrl_handler);
+	media_entity_cleanup(&state->mux.sd.subdev.entity);
+}
+
+static const struct regmap_config ds5_regmap_config = {
+	.reg_bits = 16,
+	.val_bits = 8,
+	.reg_format_endian = REGMAP_ENDIAN_NATIVE,
+	.val_format_endian = REGMAP_ENDIAN_NATIVE,
+};
+
+static int ds5_dfu_wait_for_status(struct ds5 *state)
+{
+	int i, ret = 0;
+	u16 status;
+
+	for (i = 0; i < DS5_START_MAX_COUNT; i++) {
+		ds5_read(state, 0x5000, &status);
+		if (status == 0x0001 || status == 0x0002) {
+			dev_err(&state->client->dev,
+					"%s(): dfu failed status(0x%4x)\n",
+					__func__, status);
+			ret = -EREMOTEIO;
+			break;
+		}
+		if (!status)
+			break;
+		msleep_range(DS5_START_POLL_TIME);
+	}
+
+	return ret;
+};
+
+static int ds5_dfu_switch_to_dfu(struct ds5 *state)
+{
+	int ret;
+	int i = DS5_START_MAX_COUNT;
+	u16 status;
+
+	ds5_raw_write_with_check(state, 0x4900,
+			&cmd_switch_to_dfu, sizeof(cmd_switch_to_dfu));
+	ds5_write_with_check(state, 0x490c, 0x01); /* execute cmd */
+	/*Wait for DFU fw to boot*/
+	do {
+		msleep_range(DS5_START_POLL_TIME*10);
+		ret = ds5_read(state, 0x5000, &status);
+	} while (ret && i--);
+	return ret;
+};
+
+static int ds5_dfu_wait_for_get_dfu_status(struct ds5 *state,
+		enum dfu_fw_state exp_state)
+{
+	int ret = 0;
+	u16 status, dfu_state_len = 0x0000;
+	unsigned char dfu_asw_buf[DFU_WAIT_RET_LEN];
+	unsigned int dfu_wr_wait_msec = 0;
+
+	do {
+		ds5_write_with_check(state, 0x5008, 0x0003); // Get Write state
+		do {
+			ds5_read_with_check(state, 0x5000, &status);
+			if (status == 0x0001) {
+				dev_err(&state->client->dev,
+						"%s(): Write status error I2C_STATUS_ERROR(1)\n",
+						__func__);
+				return -EINVAL;
+			} else
+				if (status == 0x0002 && dfu_wr_wait_msec)
+					msleep_range(dfu_wr_wait_msec);
+
+		} while (status);
+
+		ds5_read_with_check(state, 0x5004, &dfu_state_len);
+		if (dfu_state_len != DFU_WAIT_RET_LEN) {
+			dev_err(&state->client->dev,
+					"%s(): Wrong answer len (%d)\n", __func__, dfu_state_len);
+			return -EINVAL;
+		}
+		ds5_raw_read_with_check(state, 0x4e00, &dfu_asw_buf, DFU_WAIT_RET_LEN);
+		if (dfu_asw_buf[0]) {
+			dev_err(&state->client->dev,
+					"%s(): Wrong dfu_status (%d)\n", __func__, dfu_asw_buf[0]);
+			return -EINVAL;
+		}
+		dfu_wr_wait_msec = (((unsigned int)dfu_asw_buf[3]) << 16)
+						| (((unsigned int)dfu_asw_buf[2]) << 8)
+						| dfu_asw_buf[1];
+	} while (dfu_asw_buf[4] == dfuDNBUSY && exp_state == dfuDNLOAD_IDLE);
+
+	if (dfu_asw_buf[4] != exp_state) {
+		dev_notice(&state->client->dev,
+				"%s(): Wrong dfu_state (%d) while expected(%d)\n",
+				__func__, dfu_asw_buf[4], exp_state);
+		ret = -EINVAL;
+	}
+	return ret;
+};
+
+static int ds5_dfu_get_dev_info(struct ds5 *state, struct __fw_status *buf)
+{
+	int ret = 0;
+	u16 len = 0;
+
+	ret = ds5_write(state, 0x5008, 0x0002); //Upload DFU cmd
+	if (!ret)
+		ret = ds5_dfu_wait_for_status(state);
+	if (!ret)
+		ds5_read_with_check(state, 0x5004, &len);
+	/*Sanity check*/
+	if (len == sizeof(struct __fw_status)) {
+		ds5_raw_read_with_check(state, 0x4e00, buf, len);
+	} else {
+		dev_err(&state->client->dev,
+				"%s(): Wrong state size (%d)\n",
+				__func__, len);
+		ret = -EINVAL;
+	}
+	return ret;
+};
+
+static int ds5_dfu_detach(struct ds5 *state)
+{
+	int ret;
+	struct __fw_status buf = {0};
+
+	ds5_write_with_check(state, 0x500c, 0x00);
+	ret = ds5_dfu_wait_for_get_dfu_status(state, dfuIDLE);
+	if (!ret)
+		ret = ds5_dfu_get_dev_info(state, &buf);
+	dev_notice(&state->client->dev, "%s():DFU ver (0x%x) received\n",
+			__func__, buf.DFU_version);
+	dev_notice(&state->client->dev, "%s():FW last version (0x%x) received\n",
+			__func__, buf.FW_lastVersion);
+	dev_notice(&state->client->dev, "%s():FW status (%s)\n",
+			__func__, buf.DFU_isLocked ? "locked" : "unlocked");
+	return ret;
+};
+
+/* When a process reads from our device, this gets called. */
+static ssize_t ds5_dfu_device_read(struct file *flip,
+		char __user *buffer, size_t len, loff_t *offset)
+{
+	struct ds5 *state = flip->private_data;
+	u16 fw_ver, fw_build;
+	char msg[32];
+	int ret = 0;
+
+	if (mutex_lock_interruptible(&state->lock))
+		return -ERESTARTSYS;
+	ret |= ds5_read(state, DS5_FW_VERSION, &fw_ver);
+	ret |= ds5_read(state, DS5_FW_BUILD, &fw_build);
+	if (ret < 0)
+		goto e_dfu_read_failed;
+	snprintf(msg, sizeof(msg), "DFU info: \tver:  %d.%d.%d.%d\n",
+			(fw_ver >> 8) & 0xff, fw_ver & 0xff,
+			(fw_build >> 8) & 0xff, fw_build & 0xff);
+
+	if (copy_to_user(buffer, msg, strlen(msg)))
+		ret = -EFAULT;
+	else {
+		state->dfu_dev.msg_write_once = ~state->dfu_dev.msg_write_once;
+		ret = strlen(msg) & state->dfu_dev.msg_write_once;
+	}
+
+e_dfu_read_failed:
+	mutex_unlock(&state->lock);
+	return ret;
+};
+
+static ssize_t ds5_dfu_device_write(struct file *flip,
+		const char __user *buffer, size_t len, loff_t *offset)
+{
+	struct ds5 *state = flip->private_data;
+	int ret = 0;
+
+	if (mutex_lock_interruptible(&state->lock))
+		return -ERESTARTSYS;
+	switch (state->dfu_dev.dfu_state_flag) {
+
+	case DS5_DFU_OPEN:
+		ret = ds5_dfu_switch_to_dfu(state);
+		if (ret < 0) {
+			dev_err(&state->client->dev, "%s(): Switch to dfu failed (%d)\n",
+					__func__, ret);
+			goto dfu_write_error;
+		}
+	/* fallthrough - procceed to recovery */
+	__attribute__((__fallthrough__));
+	case DS5_DFU_RECOVERY:
+		ret = ds5_dfu_detach(state);
+		if (ret < 0) {
+			dev_err(&state->client->dev, "%s(): Detach failed (%d)\n",
+					__func__, ret);
+			goto dfu_write_error;
+		}
+		state->dfu_dev.dfu_state_flag = DS5_DFU_IN_PROGRESS;
+		state->dfu_dev.init_v4l_f = 1;
+	/* fallthrough - procceed to download */
+	__attribute__((__fallthrough__));
+	case DS5_DFU_IN_PROGRESS: {
+		unsigned int dfu_full_blocks = len / DFU_BLOCK_SIZE;
+		unsigned int dfu_part_blocks = len % DFU_BLOCK_SIZE;
+
+		while (dfu_full_blocks--) {
+			if (copy_from_user(state->dfu_dev.dfu_msg, buffer, DFU_BLOCK_SIZE)) {
+				ret = -EFAULT;
+				goto dfu_write_error;
+			}
+			ret = ds5_raw_write(state, 0x4a00,
+					state->dfu_dev.dfu_msg, DFU_BLOCK_SIZE);
+			if (ret < 0)
+				goto dfu_write_error;
+			ret = ds5_dfu_wait_for_get_dfu_status(state, dfuDNLOAD_IDLE);
+			if (ret < 0)
+				goto dfu_write_error;
+			buffer += DFU_BLOCK_SIZE;
+		}
+		if (copy_from_user(state->dfu_dev.dfu_msg, buffer, dfu_part_blocks)) {
+				ret = -EFAULT;
+				goto dfu_write_error;
+		}
+		if (dfu_part_blocks) {
+			ret = ds5_raw_write(state, 0x4a00,
+					state->dfu_dev.dfu_msg, dfu_part_blocks);
+			if (!ret)
+				ret = ds5_dfu_wait_for_get_dfu_status(state, dfuDNLOAD_IDLE);
+			if (!ret)
+				ret = ds5_write(state, 0x4a04, 0x00); /*Download complete */
+			if (!ret)
+				ret = ds5_dfu_wait_for_get_dfu_status(state, dfuMANIFEST);
+			if (ret < 0)
+				goto dfu_write_error;
+			state->dfu_dev.dfu_state_flag = DS5_DFU_DONE;
+		}
+		dev_notice(&state->client->dev, "%s(): DFU block (%d) bytes written\n",
+				__func__, (int)len);
+		break;
+	}
+	default:
+		dev_err(&state->client->dev, "%s(): Wrong state (%d)\n",
+				__func__, state->dfu_dev.dfu_state_flag);
+		ret = -EINVAL;
+		goto dfu_write_error;
+
+	};
+	mutex_unlock(&state->lock);
+	return len;
+
+dfu_write_error:
+	state->dfu_dev.dfu_state_flag = DS5_DFU_ERROR;
+	// Reset DFU device to IDLE states
+	ret = ds5_write(state, 0x5010, 0x0);
+	if (!ret)
+		state->dfu_dev.dfu_state_flag = DS5_DFU_IDLE;
+	mutex_unlock(&state->lock);
+	return ret;
+};
+
+static int ds5_dfu_device_open(struct inode *inode, struct file *file)
+{
+	struct ds5 *state = container_of(inode->i_cdev, struct ds5,
+			dfu_dev.ds5_cdev);
+
+	if (state->dfu_dev.device_open_count)
+		return -EBUSY;
+	state->dfu_dev.device_open_count++;
+	if (state->dfu_dev.dfu_state_flag != DS5_DFU_RECOVERY)
+		state->dfu_dev.dfu_state_flag = DS5_DFU_OPEN;
+	state->dfu_dev.dfu_msg = devm_kzalloc(&state->client->dev,
+			DFU_BLOCK_SIZE, GFP_KERNEL);
+	if (!state->dfu_dev.dfu_msg)
+		return -ENOMEM;
+
+	file->private_data = state;
+	return 0;
+};
+
+static int ds5_v4l_init(struct i2c_client *c, struct ds5 *state)
+{
+	int ret;
+
+	ret = ds5_parse_cam(c, state);
+	if (ret < 0)
+		return ret;
+
+	ret = ds5_depth_init(c, state);
+	if (ret < 0)
+		return ret;
+
+	ret = ds5_motion_t_init(c, state);
+	if (ret < 0)
+		goto e_depth;
+
+	ret = ds5_rgb_init(c, state);
+	if (ret < 0)
+		goto e_motion_t;
+
+	ret = ds5_imu_init(c, state);
+	if (ret < 0)
+		goto e_rgb;
+
+	ret = ds5_mux_init(c, state);
+	if (ret < 0)
+		goto e_imu;
+
+	ret = ds5_hw_init(c, state);
+	if (ret < 0)
+		goto e_mux;
+
+	ret = ds5_mux_register(c, state);
+	if (ret < 0)
+		goto e_mux;
+
+	return 0;
+e_mux:
+	ds5_mux_remove(state);
+e_imu:
+	media_entity_cleanup(&state->imu.sensor.sd.entity);
+e_rgb:
+	media_entity_cleanup(&state->rgb.sensor.sd.entity);
+e_motion_t:
+	media_entity_cleanup(&state->motion_t.sensor.sd.entity);
+e_depth:
+	media_entity_cleanup(&state->depth.sensor.sd.entity);
+
+	return ret;
+}
+
+static int ds5_dfu_device_release(struct inode *inode, struct file *file)
+{
+	struct ds5 *state = container_of(inode->i_cdev, struct ds5, dfu_dev.ds5_cdev);
+
+	state->dfu_dev.device_open_count--;
+	if (state->dfu_dev.dfu_state_flag != DS5_DFU_RECOVERY)
+		state->dfu_dev.dfu_state_flag = DS5_DFU_IDLE;
+	if (state->dfu_dev.dfu_state_flag == DS5_DFU_DONE
+			&& state->dfu_dev.init_v4l_f)
+		ds5_v4l_init(state->client, state);
+	state->dfu_dev.init_v4l_f = 0;
+	if (state->dfu_dev.dfu_msg)
+		devm_kfree(&state->client->dev, state->dfu_dev.dfu_msg);
+	state->dfu_dev.dfu_msg = NULL;
+
+	return 0;
+};
+
+static const struct file_operations ds5_device_file_ops = {
+	.owner = THIS_MODULE,
+	.read = &ds5_dfu_device_read,
+	.write = &ds5_dfu_device_write,
+	.open = &ds5_dfu_device_open,
+	.release = &ds5_dfu_device_release
+};
+
+struct class *g_ds5_class;
+atomic_t primary_chardev = ATOMIC_INIT(0);
+
+static int ds5_chrdev_init(struct i2c_client *c, struct ds5 *state)
+{
+	struct cdev *ds5_cdev = &state->dfu_dev.ds5_cdev;
+	struct class **ds5_class = &state->dfu_dev.ds5_class;
+	struct d4xx_pdata *pdata = c->dev.platform_data;
+
+	struct device *chr_dev;
+	char dev_name[sizeof(DS5_DRIVER_NAME_DFU) + 8];
+	dev_t *dev_num = &c->dev.devt;
+	int ret;
+
+	dev_dbg(&c->dev, "%s()\n", __func__);
+	/* Request the kernel for N_MINOR devices */
+	ret = alloc_chrdev_region(dev_num, 0, 1, DS5_DRIVER_NAME_DFU);
+	if (ret < 0)
+		return ret;
+
+	if (!atomic_cmpxchg(&primary_chardev, 0, MAJOR(*dev_num))) {
+		dev_dbg(&c->dev, "%s(): <Major, Minor>: <%d, %d>\n",
+				__func__, MAJOR(*dev_num), MINOR(*dev_num));
+		/* Create a class : appears at /sys/class */
+		*ds5_class = class_create(THIS_MODULE, DS5_DRIVER_NAME_CLASS);
+		if (IS_ERR(*ds5_class)) {
+			dev_err(&c->dev, "Could not create class device\n");
+			unregister_chrdev_region(0, 1);
+			ret = PTR_ERR(*ds5_class);
+			return ret;
+		}
+		g_ds5_class = *ds5_class;
+	} else
+		*ds5_class = g_ds5_class;
+	/* Associate the cdev with a set of file_operations */
+	cdev_init(ds5_cdev, &ds5_device_file_ops);
+	/* Build up the current device number. To be used further */
+	*dev_num = MKDEV(MAJOR(*dev_num), MINOR(*dev_num));
+	/* Create a device node for this device. */
+	snprintf(dev_name, sizeof(dev_name), "%s-%c",
+			DS5_DRIVER_NAME_DFU, pdata->suffix);
+	chr_dev = device_create(*ds5_class, NULL, *dev_num, NULL, dev_name);
+	if (IS_ERR(chr_dev)) {
+		ret = PTR_ERR(chr_dev);
+		dev_err(&c->dev, "Could not create device\n");
+		class_destroy(*ds5_class);
+		unregister_chrdev_region(0, 1);
+		return ret;
+	}
+	cdev_add(ds5_cdev, *dev_num, 1);
+	return 0;
+};
+
+static int ds5_chrdev_remove(struct ds5 *state)
+{
+	struct class **ds5_class = &state->dfu_dev.ds5_class;
+	dev_t *dev_num = &state->client->dev.devt;
+	if (!ds5_class) {
+		return 0;
+	}
+	dev_dbg(&state->client->dev, "%s()\n", __func__);
+	unregister_chrdev_region(*dev_num, 1);
+	device_destroy(*ds5_class, *dev_num);
+	if (atomic_cmpxchg(&primary_chardev, MAJOR(*dev_num), 0) == MAJOR(*dev_num))
+		class_destroy(*ds5_class);
+	return 0;
+}
+
+static void ds5_substream_init(void)
+{
+	int i;
+
+	/*
+	 * 0, vc 0, depth
+	 * 1, vc 0, meta data
+	 * 2, vc 1, RGB
+	 * 3, vc 1, meta data
+	 * 4, vc 2, IR
+	 * 5, vc 3, IMU
+	 */
+	set_sub_stream_fmt(0, MEDIA_BUS_FMT_UYVY8_1X16);
+	set_sub_stream_h(0, 480);
+	set_sub_stream_w(0, 640);
+	set_sub_stream_dt(0, mbus_code_to_mipi(MEDIA_BUS_FMT_UYVY8_1X16));
+	set_sub_stream_vc_id(0, 0);
+
+	set_sub_stream_fmt(1, MEDIA_BUS_FMT_SGRBG8_1X8);
+	set_sub_stream_h(1, 1);
+	set_sub_stream_w(1, 68);
+	set_sub_stream_dt(1, MIPI_CSI2_TYPE_EMBEDDED8);
+	set_sub_stream_vc_id(1, 0);
+
+	/*RGB*/
+	set_sub_stream_fmt(2, MEDIA_BUS_FMT_YUYV8_1X16);
+	set_sub_stream_h(2, 640);
+	set_sub_stream_w(2, 480);
+	set_sub_stream_dt(2, mbus_code_to_mipi(MEDIA_BUS_FMT_UYVY8_1X16));
+	set_sub_stream_vc_id(2, 1);
+
+	set_sub_stream_fmt(3, MEDIA_BUS_FMT_SGRBG8_1X8);
+	set_sub_stream_h(3, 1);
+	set_sub_stream_w(3, 68);
+	set_sub_stream_dt(3, MIPI_CSI2_TYPE_EMBEDDED8);
+	set_sub_stream_vc_id(3, 1);
+	/*IR*/
+	set_sub_stream_fmt(4, MEDIA_BUS_FMT_UYVY8_1X16);
+	set_sub_stream_h(4, 640);
+	set_sub_stream_w(4, 480);
+	set_sub_stream_dt(4, mbus_code_to_mipi(MEDIA_BUS_FMT_UYVY8_1X16));
+	set_sub_stream_vc_id(4, 2);
+
+	set_sub_stream_fmt(5, MEDIA_BUS_FMT_UYVY8_1X16);
+	set_sub_stream_h(5, 640);
+	set_sub_stream_w(5, 480);
+	set_sub_stream_dt(5, mbus_code_to_mipi(MEDIA_BUS_FMT_UYVY8_1X16));
+	set_sub_stream_vc_id(5, 3);
+
+	for (i = 0; i < DS5_MUX_PAD_COUNT; i++)
+		pad_to_substream[i] = -1;
+
+	pad_to_substream[DS5_MUX_PAD_DEPTH_A] = 0;
+	pad_to_substream[DS5_MUX_PAD_RGB_A] = 2;
+	pad_to_substream[DS5_MUX_PAD_MOTION_T_A] = 4;
+	pad_to_substream[DS5_MUX_PAD_IMU_A] = 5;
+}
+
+/* SYSFS attributes */
+#ifdef CONFIG_SYSFS
+static ssize_t ds5_fw_ver_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *c = to_i2c_client(dev);
+	struct ds5 *state = container_of(i2c_get_clientdata(c),
+			struct ds5, mux.sd.subdev);
+
+	ds5_read(state, DS5_FW_VERSION, &state->fw_version);
+	ds5_read(state, DS5_FW_BUILD, &state->fw_build);
+
+	return snprintf(buf, PAGE_SIZE, "D4XX Sensor: %s, Version: %d.%d.%d.%d\n",
+			ds5_get_sensor_name(state),
+			(state->fw_version >> 8) & 0xff, state->fw_version & 0xff,
+			(state->fw_build >> 8) & 0xff, state->fw_build & 0xff);
+}
+
+static DEVICE_ATTR_RO(ds5_fw_ver);
+
+/* Derive 'device_attribute' structure for a read register's attribute */
+struct dev_ds5_reg_attribute {
+	struct device_attribute attr;
+	u16 reg;	// register
+	u8 valid;	// validity of above data
+};
+
+/** Read DS5 register.
+ * ds5_read_reg_show will actually read register from ds5 while
+ * ds5_read_reg_store will store register to read
+ * Example:
+ * echo -n "0xc03c" >ds5_read_reg
+ * Read register result:
+ * cat ds5_read_reg
+ * Expected:
+ * reg:0xc93c, result:0x11
+ */
+static ssize_t ds5_read_reg_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	u16 rbuf;
+	int n;
+	struct i2c_client *c = to_i2c_client(dev);
+	struct ds5 *state = container_of(i2c_get_clientdata(c),
+			struct ds5, mux.sd.subdev);
+	struct dev_ds5_reg_attribute *ds5_rw_attr = container_of(attr,
+			struct dev_ds5_reg_attribute, attr);
+	if (ds5_rw_attr->valid != 1)
+		return -EINVAL;
+	ds5_read(state, ds5_rw_attr->reg, &rbuf);
+
+	n = snprintf(buf, PAGE_SIZE, "register:0x%4x, value:0x%02x\n",
+			ds5_rw_attr->reg, rbuf);
+
+	return n;
+}
+
+/** Read DS5 register - Store reg to attr struct pointer
+ * ds5_read_reg_show will actually read register from ds5 while
+ * ds5_read_reg_store will store module, offset and length
+ */
+static ssize_t ds5_read_reg_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct dev_ds5_reg_attribute *ds5_rw_attr = container_of(attr,
+			struct dev_ds5_reg_attribute, attr);
+	int rc = -1;
+	u32 reg;
+
+	ds5_rw_attr->valid = 0;
+	/* Decode input */
+	rc = sscanf(buf, "0x%04x", &reg);
+	if (rc != 1)
+		return -EINVAL;
+	ds5_rw_attr->reg = reg;
+	ds5_rw_attr->valid = 1;
+	return count;
+}
+
+#define DS5_RW_REG_ATTR(_name) \
+		struct dev_ds5_reg_attribute dev_attr_##_name = { \
+			__ATTR(_name, S_IRUGO | S_IWUSR, \
+			ds5_read_reg_show, ds5_read_reg_store), \
+			0, 0 }
+
+static DS5_RW_REG_ATTR(ds5_read_reg);
+
+static ssize_t ds5_write_reg_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct i2c_client *c = to_i2c_client(dev);
+	struct ds5 *state = container_of(i2c_get_clientdata(c),
+			struct ds5, mux.sd.subdev);
+
+	int rc = -1;
+	u32 reg, w_val = 0;
+	u16 val = -1;
+	/* Decode input */
+	rc = sscanf(buf, "0x%04x 0x%04x", &reg, &w_val);
+	if (rc != 2)
+		return -EINVAL;
+	val = w_val & 0xffff;
+	mutex_lock(&state->lock);
+	ds5_write(state, reg, val);
+	mutex_unlock(&state->lock);
+	return count;
+}
+
+static DEVICE_ATTR_WO(ds5_write_reg);
+
+static struct attribute *ds5_attributes[] = {
+		&dev_attr_ds5_fw_ver.attr,
+		&dev_attr_ds5_read_reg.attr.attr,
+		&dev_attr_ds5_write_reg.attr,
+		NULL
+};
+
+static const struct attribute_group ds5_attr_group = {
+	.attrs = ds5_attributes,
+};
+#endif
+
+#define NR_DESER 4
+
+static const struct regmap_config ds5_regmap_max9296 = {
+	.reg_bits = 16,
+	.val_bits = 8,
+	.reg_format_endian = REGMAP_ENDIAN_BIG,
+	.val_format_endian = REGMAP_ENDIAN_NATIVE,
+};
+
+static const struct regmap_config ds5_regmap_max9295 = {
+	.reg_bits = 16,
+	.val_bits = 8,
+	.reg_format_endian = REGMAP_ENDIAN_BIG,
+	.val_format_endian = REGMAP_ENDIAN_NATIVE,
+};
+
+#define RESET_LINK	(0x1 << 6)
+#define RESET_ONESHOT	(0x1 << 5)
+#define AUTO_LINK	(0x1 << 4)
+#define DUAL_LINK	(0x0)
+#define LINK_A		(0x1)
+#define LINK_B		(0x2)
+#define SPLITTER	(0x3)
+static int ds5_i2c_addr_setting(struct i2c_client *c, struct ds5 *state)
+{
+	int ret;
+
+	state->regmap_max9296 = devm_regmap_init_i2c(c, &ds5_regmap_max9296);
+	if (IS_ERR(state->regmap_max9296)) {
+		ret = PTR_ERR(state->regmap_max9296);
+		dev_err(&c->dev, "regmap max9296 init failed: %d\n", ret);
+		return ret;
+	}
+
+	state->regmap_max9295 = devm_regmap_init_i2c(c, &ds5_regmap_max9295);
+	if (IS_ERR(state->regmap_max9295)) {
+		ret = PTR_ERR(state->regmap_max9295);
+		dev_err(&c->dev, "regmap max9295 init failed: %d\n", ret);
+		return ret;
+	}
+
+	c->addr = 0x48;
+	max9296_write_8(state, 0x0010, 0x40);
+	c->addr = 0x4a;
+	max9296_write_8(state, 0x0010, 0x40);
+	c->addr = 0x68;
+	max9296_write_8(state, 0x0010, 0x40);
+	c->addr = 0x6c;
+	max9296_write_8(state, 0x0010, 0x40);
+
+	c->addr = 0x6c;
+	max9296_write_8(state, 0x0010, 0x32);
+	msleep_range(1000);
+
+	c->addr = 0x40;
+	max9295_write_8(state, 0x0000, 0xc8); // 0x64
+	c->addr = 0x64;
+	msleep_range(1000);
+
+	max9295_write_8(state, 0x0044, 0x30); // 0x18
+	max9295_write_8(state, 0x0045, 0x20);
+
+	c->addr = 0x68;
+	max9296_write_8(state, 0x0010, 0x32);
+	msleep_range(1000);
+
+	c->addr = 0x40;
+	max9295_write_8(state, 0x0000, 0xc4); // 0x62
+	c->addr = 0x62;
+	max9295_write_8(state, 0x0044, 0x2c); // 0x16
+	max9295_write_8(state, 0x0045, 0x20);
+
+	c->addr = 0x4a;
+	max9296_write_8(state, 0x0010, 0x32);
+	msleep_range(1000);
+
+	c->addr = 0x40;
+	max9295_write_8(state, 0x0000, 0x88); // 0x44
+	c->addr = 0x44;
+	max9295_write_8(state, 0x0044, 0x28); // 0x14
+	max9295_write_8(state, 0x0045, 0x20);
+
+	c->addr = 0x48;
+	max9296_write_8(state, 0x0010, 0x32);
+	msleep_range(1000);
+
+	c->addr = 0x40;
+	max9295_write_8(state, 0x0000, 0x84); // 0x42
+	c->addr = 0x42;
+	max9295_write_8(state, 0x0044, 0x24); // 0x12
+	max9295_write_8(state, 0x0045, 0x20);
+
+	c->addr = 0x12;
+
+	return 0;
+}
+
+static int ds5_probe(struct i2c_client *c, const struct i2c_device_id *id)
+{
+	struct ds5 *state = devm_kzalloc(&c->dev, sizeof(*state), GFP_KERNEL);
+	u16 rec_state;
+	int ret, retry, err = 0;
+	const char *str;
+
+	if (!state)
+		return -ENOMEM;
+
+	mutex_init(&state->lock);
+
+	dev_warn(&c->dev, "Driver addr 0x%x\n", c->addr);
+
+	state->client = c;
+	dev_warn(&c->dev, "Probing new driver for D45x\n");
+	dev_warn(&c->dev, "Driver data NAEL %d\n", (int)id->driver_data);
+	state->variant = ds5_variants + id->driver_data;
+
+	state->vcc = devm_regulator_get(&c->dev, "vcc");
+	if (IS_ERR(state->vcc)) {
+		ret = PTR_ERR(state->vcc);
+		dev_warn(&c->dev, "failed %d to get vcc regulator\n", ret);
+		return ret;
+	}
+
+	if (state->vcc) {
+		ret = regulator_enable(state->vcc);
+		if (ret < 0) {
+			dev_warn(&c->dev, "failed %d to enable the vcc regulator\n", ret);
+			return ret;
+		}
+	}
+	state->regmap = devm_regmap_init_i2c(c, &ds5_regmap_config);
+	if (IS_ERR(state->regmap)) {
+		ret = PTR_ERR(state->regmap);
+		dev_err(&c->dev, "regmap init failed: %d\n", ret);
+		goto e_regulator;
+	}
+
+	if (c->addr == 0x48)
+		c->addr = 0x12;
+	if (c->addr == 0x4a)
+		c->addr = 0x14;
+	if (c->addr == 0x68)
+		c->addr = 0x16;
+	if (c->addr == 0x6c)
+		c->addr = 0x18;
+
+	if (c->addr == 0x12) {
+		ret = ds5_i2c_addr_setting(c, state);
+		if (ret) {
+			dev_err(&c->dev, "failed apply i2c addr setting\n");
+			return ret;
+		}
+	}
+
+	// Verify communication
+	retry = 10;
+	do {
+	ret = ds5_read(state, 0x5020, &rec_state);
+	} while (retry-- && ret < 0);
+	if (ret < 0) {
+		dev_err(&c->dev,
+			"%s(): cannot communicate with D4XX: %d on addr: 0x%x\n",
+			__func__, ret, c->addr);
+		goto e_regulator;
+	}
+
+	state->is_depth = 0;
+	state->is_y8 = 0;
+	state->is_rgb = 0;
+	state->is_imu = 0;
+#ifdef CONFIG_OF
+	ret = of_property_read_string(c->dev.of_node, "cam-type", &str);
+	if (!ret && !strncmp(str, "Depth", strlen("Depth"))) {
+		state->is_depth = 1;
+	}
+	if (!ret && !strncmp(str, "Y8", strlen("Y8"))) {
+		state->is_y8 = 1;
+	}
+	if (!ret && !strncmp(str, "RGB", strlen("RGB"))) {
+		state->is_rgb = 1;
+	}
+	if (!ret && !strncmp(str, "IMU", strlen("IMU"))) {
+		state->is_imu = 1;
+	}
+#else
+	state->is_depth = 1;
+#endif
+	/* create DFU chardev once */
+	if (state->is_depth) {
+		ret = ds5_chrdev_init(c, state);
+		if (ret < 0)
+			goto e_regulator;
+	}
+
+	ret = ds5_read(state, 0x5020, &rec_state);
+	if (ret < 0) {
+		dev_err(&c->dev, "%s(): cannot communicate with D4XX: %d\n",
+				__func__, ret);
+		goto e_chardev;
+	}
+
+	if (rec_state == 0x201) {
+		dev_info(&c->dev, "%s(): D4XX recovery state\n", __func__);
+		state->dfu_dev.dfu_state_flag = DS5_DFU_RECOVERY;
+		return 0;
+	}
+
+	ds5_read_with_check(state, DS5_FW_VERSION, &state->fw_version);
+	ds5_read_with_check(state, DS5_FW_BUILD, &state->fw_build);
+
+	dev_info(&c->dev, "D4XX Sensor: %s, firmware build: %d.%d.%d.%d\n",
+			ds5_get_sensor_name(state),
+			(state->fw_version >> 8) & 0xff, state->fw_version & 0xff,
+			(state->fw_build >> 8) & 0xff, state->fw_build & 0xff);
+
+	ret = ds5_v4l_init(c, state);
+	if (ret < 0)
+		goto e_chardev;
+	/* Override I2C drvdata */
+	/* i2c_set_clientdata(c, state); */
+
+/*	regulators? clocks?
+ *	devm_regulator_bulk_get(&c->dev, DS5_N_SUPPLIES, state->supplies);
+ *	state->clock = devm_clk_get(&c->dev, DS5_CLK_NAME);
+ *	if (IS_ERR(state->clock)) {
+ *		ret = -EPROBE_DEFER;
+ *		goto err;
+ *	}
+ */
+#ifdef CONFIG_SYSFS
+	/* Custom sysfs attributes */
+	/* create the sysfs file group */
+	err = sysfs_create_group(&state->client->dev.kobj, &ds5_attr_group);
+#endif
+	ds5_substream_init();
+	return 0;
+
+e_chardev:
+	if (state->dfu_dev.ds5_class)
+		ds5_chrdev_remove(state);
+e_regulator:
+	if (state->vcc)
+		regulator_disable(state->vcc);
+	return ret;
+}
+
+static int ds5_remove(struct i2c_client *c)
+{
+	struct ds5 *state = container_of(i2c_get_clientdata(c), struct ds5, mux.sd.subdev);
+
+	dev_info(&c->dev, "D4XX remove %s\n",
+			ds5_get_sensor_name(state));
+	if (state->vcc)
+		regulator_disable(state->vcc);
+//	gpio_free(state->pwdn_gpio);
+	if (state->is_depth) {
+		ds5_chrdev_remove(state);
+	}
+
+	if (state->dfu_dev.dfu_state_flag != DS5_DFU_RECOVERY) {
+#ifdef CONFIG_SYSFS
+		sysfs_remove_group(&c->dev.kobj, &ds5_attr_group);
+#endif
+		ds5_mux_remove(state);
+	}
+	return 0;
+}
+
+static const struct i2c_device_id ds5_id[] = {
+	{ DS5_DRIVER_NAME, DS5_DS5U },
+	{ DS5_DRIVER_NAME_ASR, DS5_ASR },
+	{ DS5_DRIVER_NAME_AWG, DS5_AWG },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, ds5_id);
+
+static struct i2c_driver ds5_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = DS5_DRIVER_NAME
+	},
+	.probe		= ds5_probe,
+	.remove		= ds5_remove,
+	.id_table	= ds5_id,
+};
+
+module_i2c_driver(ds5_i2c_driver);
+
+MODULE_DESCRIPTION("Intel RealSense D4XX Camera Driver");
+MODULE_AUTHOR("Guennadi Liakhovetski <guennadi.liakhovetski@intel.com>,\n\
+				Nael Masalha <nael.masalha@intel.com>,\n\
+				Alexander Gantman <alexander.gantman@intel.com>,\n\
+				Emil Jahshan <emil.jahshan@intel.com>,\n\
+				Xin Zhang <xin.x.zhang@intel.com>,\n\
+				Qingwu Zhang <qingwu.zhang@intel.com>,\n\
+				Evgeni Raikhel <evgeni.raikhel@intel.com>,\n\
+				Shikun Ding <shikun.ding@intel.com>");
+MODULE_AUTHOR("Dmitry Perchanov <dmitry.perchanov@intel.com>");
+MODULE_LICENSE("GPL v2");
+MODULE_VERSION("1.0.2.13");
Index: b/drivers/media/i2c/hm11b1.c
===================================================================
--- /dev/null
+++ b/drivers/media/i2c/hm11b1.c
@@ -0,0 +1,1184 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (c) 2020-2022 Intel Corporation.
+
+#include <asm/unaligned.h>
+#include <linux/acpi.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/version.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-fwnode.h>
+#if IS_ENABLED(CONFIG_INTEL_SKL_INT3472)
+#include <linux/clk.h>
+#include <linux/gpio/consumer.h>
+#elif IS_ENABLED(CONFIG_POWER_CTRL_LOGIC)
+#include "power_ctrl_logic.h"
+#endif
+
+#define HM11B1_LINK_FREQ_384MHZ		384000000ULL
+#define HM11B1_SCLK			72000000LL
+#define HM11B1_MCLK			19200000
+#define HM11B1_DATA_LANES		1
+#define HM11B1_RGB_DEPTH		10
+
+#define HM11B1_REG_CHIP_ID		0x0000
+#define HM11B1_CHIP_ID			0x11B1
+
+#define HM11B1_REG_MODE_SELECT		0x0100
+#define HM11B1_MODE_STANDBY		0x00
+#define HM11B1_MODE_STREAMING		0x01
+
+/* vertical-timings from sensor */
+#define HM11B1_REG_VTS			0x3402
+#define HM11B1_VTS_DEF			0x037d
+#define HM11B1_VTS_MIN			0x0346
+#define HM11B1_VTS_MAX			0xffff
+
+/* horizontal-timings from sensor */
+#define HM11B1_REG_HTS			0x3404
+
+/* Exposure controls from sensor */
+#define HM11B1_REG_EXPOSURE		0x0202
+#define HM11B1_EXPOSURE_MIN		2
+#define HM11B1_EXPOSURE_MAX_MARGIN	2
+#define HM11B1_EXPOSURE_STEP		1
+
+/* Analog gain controls from sensor */
+#define HM11B1_REG_ANALOG_GAIN		0x0205
+#define HM11B1_REG_ANALOG_GAIN_IR	0x0206
+#define HM11B1_ANAL_GAIN_MIN		0
+#define HM11B1_ANAL_GAIN_MAX		0xFF
+#define HM11B1_ANAL_GAIN_STEP		1
+
+/* Digital gain controls from sensor */
+#define HM11B1_REG_DGTL_GAIN		0x0207
+#define HM11B1_REG_DGTL_GAIN_IR		0x0209
+#define HM11B1_DGTL_GAIN_MIN		0x0
+#define HM11B1_DGTL_GAIN_MAX		0x3FF
+#define HM11B1_DGTL_GAIN_STEP		1
+#define HM11B1_DGTL_GAIN_DEFAULT	0x100
+/* register update control */
+#define HM11B1_REG_COMMAND_UPDATE	0x104
+
+/* Test Pattern Control */
+#define HM11B1_REG_TEST_PATTERN		0x0601
+#define HM11B1_TEST_PATTERN_ENABLE	1
+#define HM11B1_TEST_PATTERN_BAR_SHIFT	1
+
+enum {
+	HM11B1_LINK_FREQ_384MHZ_INDEX,
+};
+
+struct hm11b1_reg {
+	u16 address;
+	u8 val;
+};
+
+struct hm11b1_reg_list {
+	u32 num_of_regs;
+	const struct hm11b1_reg *regs;
+};
+
+struct hm11b1_link_freq_config {
+	const struct hm11b1_reg_list reg_list;
+};
+
+struct hm11b1_mode {
+	/* Frame width in pixels */
+	u32 width;
+
+	/* Frame height in pixels */
+	u32 height;
+
+	/* Horizontal timining size */
+	u32 hts;
+
+	/* Default vertical timining size */
+	u32 vts_def;
+
+	/* Min vertical timining size */
+	u32 vts_min;
+
+	/* Link frequency needed for this resolution */
+	u32 link_freq_index;
+
+	/* Sensor register settings for this resolution */
+	const struct hm11b1_reg_list reg_list;
+};
+
+static const struct hm11b1_reg mipi_data_rate_384mbps[] = {
+};
+
+//RAW 10bit 1292x800_30fps_MIPI 384Mbps/lane
+static const struct hm11b1_reg sensor_1292x800_30fps_setting[] = {
+	{0x0103, 0x00},
+	{0x0102, 0x01},
+	{0x0202, 0x03},
+	{0x0203, 0x7C},
+	{0x0205, 0x20},
+	{0x0207, 0x01},
+	{0x0208, 0x00},
+	{0x0209, 0x01},
+	{0x020A, 0x00},
+	{0x0300, 0x91},
+	{0x0301, 0x0A},
+	{0x0302, 0x02},
+	{0x0303, 0x2E},
+	{0x0304, 0x43},
+	{0x0306, 0x00},
+	{0x0307, 0x00},
+	{0x0340, 0x03},
+	{0x0341, 0x60},
+	{0x0342, 0x05},
+	{0x0343, 0xA0},
+	{0x0344, 0x00},
+	{0x0345, 0x00},
+	{0x0346, 0x03},
+	{0x0347, 0x2F},
+	{0x0350, 0xFF},
+	{0x0351, 0x00},
+	{0x0352, 0x00},
+	{0x0370, 0x00},
+	{0x0371, 0x00},
+	{0x0380, 0x00},
+	{0x0381, 0x00},
+	{0x0382, 0x00},
+	{0x1000, 0xC3},
+	{0x1001, 0xD0},
+	{0x100A, 0x13},
+	{0x2000, 0x00},
+	{0x2061, 0x01},
+	{0x2062, 0x00},
+	{0x2063, 0xC8},
+	{0x2100, 0x03},
+	{0x2101, 0xF0},
+	{0x2102, 0xF0},
+	{0x2103, 0x01},
+	{0x2104, 0x10},
+	{0x2105, 0x10},
+	{0x2106, 0x02},
+	{0x2107, 0x0A},
+	{0x2108, 0x10},
+	{0x2109, 0x15},
+	{0x210A, 0x1A},
+	{0x210B, 0x20},
+	{0x210C, 0x08},
+	{0x210D, 0x0A},
+	{0x210E, 0x0F},
+	{0x210F, 0x12},
+	{0x2110, 0x1C},
+	{0x2111, 0x20},
+	{0x2112, 0x23},
+	{0x2113, 0x2A},
+	{0x2114, 0x30},
+	{0x2115, 0x10},
+	{0x2116, 0x00},
+	{0x2117, 0x01},
+	{0x2118, 0x00},
+	{0x2119, 0x06},
+	{0x211A, 0x00},
+	{0x211B, 0x00},
+	{0x2615, 0x08},
+	{0x2616, 0x00},
+	{0x2700, 0x01},
+	{0x2711, 0x01},
+	{0x272F, 0x01},
+	{0x2800, 0x29},
+	{0x2821, 0xCE},
+	{0x2839, 0x27},
+	{0x283A, 0x01},
+	{0x2842, 0x01},
+	{0x2843, 0x00},
+	{0x3022, 0x11},
+	{0x3024, 0x30},
+	{0x3025, 0x12},
+	{0x3026, 0x00},
+	{0x3027, 0x81},
+	{0x3028, 0x01},
+	{0x3029, 0x00},
+	{0x302A, 0x30},
+	{0x3030, 0x00},
+	{0x3032, 0x00},
+	{0x3035, 0x01},
+	{0x303E, 0x00},
+	{0x3051, 0x00},
+	{0x3082, 0x0E},
+	{0x3084, 0x0D},
+	{0x30A8, 0x03},
+	{0x30C4, 0xA0},
+	{0x30D5, 0xC1},
+	{0x30D8, 0x00},
+	{0x30D9, 0x0D},
+	{0x30DB, 0xC2},
+	{0x30DE, 0x25},
+	{0x30E1, 0xC3},
+	{0x30E4, 0x25},
+	{0x30E7, 0xC4},
+	{0x30EA, 0x25},
+	{0x30ED, 0xC5},
+	{0x30F0, 0x25},
+	{0x30F2, 0x0C},
+	{0x30F3, 0x85},
+	{0x30F6, 0x25},
+	{0x30F8, 0x0C},
+	{0x30F9, 0x05},
+	{0x30FB, 0x40},
+	{0x30FC, 0x25},
+	{0x30FD, 0x54},
+	{0x30FE, 0x0C},
+	{0x3100, 0xC2},
+	{0x3103, 0x00},
+	{0x3104, 0x2B},
+	{0x3106, 0xC3},
+	{0x3109, 0x25},
+	{0x310C, 0xC4},
+	{0x310F, 0x25},
+	{0x3112, 0xC5},
+	{0x3115, 0x25},
+	{0x3117, 0x0C},
+	{0x3118, 0x85},
+	{0x311B, 0x25},
+	{0x311D, 0x0C},
+	{0x311E, 0x05},
+	{0x3121, 0x25},
+	{0x3123, 0x0C},
+	{0x3124, 0x0D},
+	{0x3126, 0x40},
+	{0x3127, 0x25},
+	{0x3128, 0x54},
+	{0x3129, 0x0C},
+	{0x3130, 0x20},
+	{0x3134, 0x60},
+	{0x3135, 0xC2},
+	{0x3139, 0x12},
+	{0x313A, 0x07},
+	{0x313F, 0x52},
+	{0x3140, 0x34},
+	{0x3141, 0x2E},
+	{0x314F, 0x07},
+	{0x3151, 0x47},
+	{0x3153, 0xB0},
+	{0x3154, 0x4A},
+	{0x3155, 0xC0},
+	{0x3157, 0x55},
+	{0x3158, 0x01},
+	{0x3165, 0xFF},
+	{0x316B, 0x12},
+	{0x316E, 0x12},
+	{0x3176, 0x12},
+	{0x3178, 0x01},
+	{0x317C, 0x10},
+	{0x317D, 0x05},
+	{0x317F, 0x07},
+	{0x3182, 0x07},
+	{0x3183, 0x11},
+	{0x3184, 0x88},
+	{0x3186, 0x28},
+	{0x3191, 0x00},
+	{0x3192, 0x20},
+	{0x3400, 0x48},
+	{0x3401, 0x00},
+	{0x3402, 0x06},
+	{0x3403, 0xFA},
+	{0x3404, 0x05},
+	{0x3405, 0x40},
+	{0x3406, 0x00},
+	{0x3407, 0x00},
+	{0x3408, 0x03},
+	{0x3409, 0x2F},
+	{0x340A, 0x00},
+	{0x340B, 0x00},
+	{0x340C, 0x00},
+	{0x340D, 0x00},
+	{0x340E, 0x00},
+	{0x340F, 0x00},
+	{0x3410, 0x00},
+	{0x3411, 0x01},
+	{0x3412, 0x00},
+	{0x3413, 0x03},
+	{0x3414, 0xB0},
+	{0x3415, 0x4A},
+	{0x3416, 0xC0},
+	{0x3418, 0x55},
+	{0x3419, 0x03},
+	{0x341B, 0x7D},
+	{0x341C, 0x00},
+	{0x341F, 0x03},
+	{0x3420, 0x00},
+	{0x3421, 0x02},
+	{0x3422, 0x00},
+	{0x3423, 0x02},
+	{0x3424, 0x01},
+	{0x3425, 0x02},
+	{0x3426, 0x00},
+	{0x3427, 0xA2},
+	{0x3428, 0x01},
+	{0x3429, 0x06},
+	{0x342A, 0xF8},
+	{0x3440, 0x01},
+	{0x3441, 0xBE},
+	{0x3442, 0x02},
+	{0x3443, 0x18},
+	{0x3444, 0x03},
+	{0x3445, 0x0C},
+	{0x3446, 0x06},
+	{0x3447, 0x18},
+	{0x3448, 0x09},
+	{0x3449, 0x24},
+	{0x344A, 0x08},
+	{0x344B, 0x08},
+	{0x345C, 0x00},
+	{0x345D, 0x44},
+	{0x345E, 0x02},
+	{0x345F, 0x43},
+	{0x3460, 0x04},
+	{0x3461, 0x3B},
+	{0x3466, 0xF8},
+	{0x3467, 0x43},
+	{0x347D, 0x02},
+	{0x3483, 0x05},
+	{0x3484, 0x0C},
+	{0x3485, 0x03},
+	{0x3486, 0x20},
+	{0x3487, 0x00},
+	{0x3488, 0x00},
+	{0x3489, 0x00},
+	{0x348A, 0x09},
+	{0x348B, 0x00},
+	{0x348C, 0x00},
+	{0x348D, 0x02},
+	{0x348E, 0x01},
+	{0x348F, 0x40},
+	{0x3490, 0x00},
+	{0x3491, 0xC8},
+	{0x3492, 0x00},
+	{0x3493, 0x02},
+	{0x3494, 0x00},
+	{0x3495, 0x02},
+	{0x3496, 0x02},
+	{0x3497, 0x06},
+	{0x3498, 0x05},
+	{0x3499, 0x04},
+	{0x349A, 0x09},
+	{0x349B, 0x05},
+	{0x349C, 0x17},
+	{0x349D, 0x05},
+	{0x349E, 0x00},
+	{0x349F, 0x00},
+	{0x34A0, 0x00},
+	{0x34A1, 0x00},
+	{0x34A2, 0x08},
+	{0x34A3, 0x08},
+	{0x34A4, 0x00},
+	{0x34A5, 0x0B},
+	{0x34A6, 0x0C},
+	{0x34A7, 0x32},
+	{0x34A8, 0x10},
+	{0x34A9, 0xE0},
+	{0x34AA, 0x52},
+	{0x34AB, 0x00},
+	{0x34AC, 0x60},
+	{0x34AD, 0x2B},
+	{0x34AE, 0x25},
+	{0x34AF, 0x48},
+	{0x34B1, 0x06},
+	{0x34B2, 0xF8},
+	{0x34C3, 0xB0},
+	{0x34C4, 0x4A},
+	{0x34C5, 0xC0},
+	{0x34C7, 0x55},
+	{0x34C8, 0x03},
+	{0x34CB, 0x00},
+	{0x353A, 0x00},
+	{0x355E, 0x48},
+	{0x3572, 0xB0},
+	{0x3573, 0x4A},
+	{0x3574, 0xC0},
+	{0x3576, 0x55},
+	{0x3577, 0x03},
+	{0x357A, 0x00},
+	{0x35DA, 0x00},
+	{0x4003, 0x02},
+	{0x4004, 0x02},
+};
+
+static const char * const hm11b1_test_pattern_menu[] = {
+	"Disabled",
+	"Solid Color",
+	"Color Bar",
+	"Color Bar Blending",
+	"PN11",
+};
+
+static const s64 link_freq_menu_items[] = {
+	HM11B1_LINK_FREQ_384MHZ,
+};
+
+static const struct hm11b1_link_freq_config link_freq_configs[] = {
+	[HM11B1_LINK_FREQ_384MHZ_INDEX] = {
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(mipi_data_rate_384mbps),
+			.regs = mipi_data_rate_384mbps,
+		}
+	},
+};
+
+static const struct hm11b1_mode supported_modes[] = {
+	{
+		.width = 1292,
+		.height = 800,
+		.hts = 1344,
+		.vts_def = HM11B1_VTS_DEF,
+		.vts_min = HM11B1_VTS_MIN,
+		.reg_list = {
+			.num_of_regs =
+				ARRAY_SIZE(sensor_1292x800_30fps_setting),
+			.regs = sensor_1292x800_30fps_setting,
+		},
+		.link_freq_index = HM11B1_LINK_FREQ_384MHZ_INDEX,
+	},
+};
+
+struct hm11b1 {
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_ctrl_handler ctrl_handler;
+
+	/* V4L2 Controls */
+	struct v4l2_ctrl *link_freq;
+	struct v4l2_ctrl *pixel_rate;
+	struct v4l2_ctrl *vblank;
+	struct v4l2_ctrl *hblank;
+	struct v4l2_ctrl *exposure;
+
+	/* Current mode */
+	const struct hm11b1_mode *cur_mode;
+
+	/* To serialize asynchronus callbacks */
+	struct mutex mutex;
+
+	/* i2c client */
+	struct i2c_client *client;
+
+#if IS_ENABLED(CONFIG_INTEL_SKL_INT3472)
+	/* GPIO for reset */
+	struct gpio_desc *reset_gpio;
+	/* GPIO for powerdown */
+	struct gpio_desc *powerdown_gpio;
+	/* GPIO for clock enable */
+	struct gpio_desc *clken_gpio;
+	/* GPIO for privacy LED */
+	struct gpio_desc *pled_gpio;
+#endif
+
+	/* Streaming on/off */
+	bool streaming;
+};
+
+static inline struct hm11b1 *to_hm11b1(struct v4l2_subdev *subdev)
+{
+	return container_of(subdev, struct hm11b1, sd);
+}
+
+static u64 to_pixel_rate(u32 f_index)
+{
+	u64 pixel_rate = link_freq_menu_items[f_index] * 2 * HM11B1_DATA_LANES;
+
+	do_div(pixel_rate, HM11B1_RGB_DEPTH);
+
+	return pixel_rate;
+}
+
+static u64 to_pixels_per_line(u32 hts, u32 f_index)
+{
+	u64 ppl = hts * to_pixel_rate(f_index);
+
+	do_div(ppl, HM11B1_SCLK);
+
+	return ppl;
+}
+
+static void hm11b1_set_power(struct hm11b1 *hm11b1, int on)
+{
+#if IS_ENABLED(CONFIG_INTEL_SKL_INT3472)
+	if (!(hm11b1->reset_gpio && hm11b1->powerdown_gpio))
+		return;
+	gpiod_set_value_cansleep(hm11b1->reset_gpio, on);
+	gpiod_set_value_cansleep(hm11b1->powerdown_gpio, on);
+	gpiod_set_value_cansleep(hm11b1->clken_gpio, on);
+	gpiod_set_value_cansleep(hm11b1->pled_gpio, on);
+	msleep(20);
+#elif IS_ENABLED(CONFIG_POWER_CTRL_LOGIC)
+	power_ctrl_logic_set_power(on);
+#endif
+}
+
+static int hm11b1_read_reg(struct hm11b1 *hm11b1, u16 reg, u16 len, u32 *val)
+{
+	struct i2c_client *client = hm11b1->client;
+	struct i2c_msg msgs[2];
+	u8 addr_buf[2];
+	u8 data_buf[4] = {0};
+	int ret = 0;
+
+	if (len > sizeof(data_buf))
+		return -EINVAL;
+
+	put_unaligned_be16(reg, addr_buf);
+	msgs[0].addr = client->addr;
+	msgs[0].flags = 0;
+	msgs[0].len = sizeof(addr_buf);
+	msgs[0].buf = addr_buf;
+	msgs[1].addr = client->addr;
+	msgs[1].flags = I2C_M_RD;
+	msgs[1].len = len;
+	msgs[1].buf = &data_buf[sizeof(data_buf) - len];
+
+	ret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));
+	if (ret != ARRAY_SIZE(msgs))
+		return ret < 0 ? ret : -EIO;
+
+	*val = get_unaligned_be32(data_buf);
+
+	return 0;
+}
+
+static int hm11b1_write_reg(struct hm11b1 *hm11b1, u16 reg, u16 len, u32 val)
+{
+	struct i2c_client *client = hm11b1->client;
+	u8 buf[6];
+	int ret = 0;
+
+	if (len > 4)
+		return -EINVAL;
+
+	put_unaligned_be16(reg, buf);
+	put_unaligned_be32(val << 8 * (4 - len), buf + 2);
+
+	ret = i2c_master_send(client, buf, len + 2);
+	if (ret != len + 2)
+		return ret < 0 ? ret : -EIO;
+
+	return 0;
+}
+
+static int hm11b1_write_reg_list(struct hm11b1 *hm11b1,
+				 const struct hm11b1_reg_list *r_list)
+{
+	struct i2c_client *client = hm11b1->client;
+	unsigned int i;
+	int ret = 0;
+
+	for (i = 0; i < r_list->num_of_regs; i++) {
+		ret = hm11b1_write_reg(hm11b1, r_list->regs[i].address, 1,
+				       r_list->regs[i].val);
+		if (ret) {
+			dev_err_ratelimited(&client->dev,
+					    "write reg 0x%4.4x return err = %d",
+					    r_list->regs[i].address, ret);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int hm11b1_update_digital_gain(struct hm11b1 *hm11b1, u32 d_gain)
+{
+	struct i2c_client *client = hm11b1->client;
+	int ret = 0;
+
+	ret = hm11b1_write_reg(hm11b1, HM11B1_REG_DGTL_GAIN, 2, d_gain);
+	if (ret) {
+		dev_err(&client->dev, "failed to set HM11B1_REG_DGTL_GAIN");
+		return ret;
+	}
+
+	ret = hm11b1_write_reg(hm11b1, HM11B1_REG_DGTL_GAIN_IR, 2, d_gain);
+	if (ret) {
+		dev_err(&client->dev, "failed to set HM11B1_REG_DGTL_GAIN_IR");
+		return ret;
+	}
+
+	return ret;
+}
+
+static int hm11b1_test_pattern(struct hm11b1 *hm11b1, u32 pattern)
+{
+	if (pattern)
+		pattern = pattern << HM11B1_TEST_PATTERN_BAR_SHIFT |
+			  HM11B1_TEST_PATTERN_ENABLE;
+
+	return hm11b1_write_reg(hm11b1, HM11B1_REG_TEST_PATTERN, 1, pattern);
+}
+
+static int hm11b1_set_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct hm11b1 *hm11b1 = container_of(ctrl->handler,
+					     struct hm11b1, ctrl_handler);
+	struct i2c_client *client = hm11b1->client;
+	s64 exposure_max;
+	int ret = 0;
+
+	/* Propagate change of current control to all related controls */
+	if (ctrl->id == V4L2_CID_VBLANK) {
+		/* Update max exposure while meeting expected vblanking */
+		exposure_max = hm11b1->cur_mode->height + ctrl->val -
+			       HM11B1_EXPOSURE_MAX_MARGIN;
+		__v4l2_ctrl_modify_range(hm11b1->exposure,
+					 hm11b1->exposure->minimum,
+					 exposure_max, hm11b1->exposure->step,
+					 exposure_max);
+	}
+
+	/* V4L2 controls values will be applied only when power is already up */
+	if (!pm_runtime_get_if_in_use(&client->dev))
+		return 0;
+
+	ret = hm11b1_write_reg(hm11b1, HM11B1_REG_COMMAND_UPDATE, 1, 1);
+	if (ret) {
+		dev_err(&client->dev, "failed to enable HM11B1_REG_COMMAND_UPDATE");
+		pm_runtime_put(&client->dev);
+		return ret;
+	}
+	switch (ctrl->id) {
+	case V4L2_CID_ANALOGUE_GAIN:
+		ret = hm11b1_write_reg(hm11b1, HM11B1_REG_ANALOG_GAIN, 1,
+				       ctrl->val);
+		ret |= hm11b1_write_reg(hm11b1, HM11B1_REG_ANALOG_GAIN_IR, 1,
+					ctrl->val);
+		break;
+
+	case V4L2_CID_DIGITAL_GAIN:
+		ret = hm11b1_update_digital_gain(hm11b1, ctrl->val);
+		break;
+
+	case V4L2_CID_EXPOSURE:
+		/* 4 least significant bits of expsoure are fractional part */
+		ret = hm11b1_write_reg(hm11b1, HM11B1_REG_EXPOSURE, 2,
+				       ctrl->val);
+		break;
+
+	case V4L2_CID_VBLANK:
+		ret = hm11b1_write_reg(hm11b1, HM11B1_REG_VTS, 2,
+				       hm11b1->cur_mode->height + ctrl->val);
+		break;
+
+	case V4L2_CID_TEST_PATTERN:
+		ret = hm11b1_test_pattern(hm11b1, ctrl->val);
+		break;
+
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	ret |= hm11b1_write_reg(hm11b1, HM11B1_REG_COMMAND_UPDATE, 1, 0);
+	pm_runtime_put(&client->dev);
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops hm11b1_ctrl_ops = {
+	.s_ctrl = hm11b1_set_ctrl,
+};
+
+static int hm11b1_init_controls(struct hm11b1 *hm11b1)
+{
+	struct v4l2_ctrl_handler *ctrl_hdlr;
+	const struct hm11b1_mode *cur_mode;
+	s64 exposure_max, h_blank, pixel_rate;
+	u32 vblank_min, vblank_max, vblank_default;
+	int size;
+	int ret = 0;
+
+	ctrl_hdlr = &hm11b1->ctrl_handler;
+	ret = v4l2_ctrl_handler_init(ctrl_hdlr, 8);
+	if (ret)
+		return ret;
+
+	ctrl_hdlr->lock = &hm11b1->mutex;
+	cur_mode = hm11b1->cur_mode;
+	size = ARRAY_SIZE(link_freq_menu_items);
+
+	hm11b1->link_freq = v4l2_ctrl_new_int_menu(ctrl_hdlr, &hm11b1_ctrl_ops,
+						   V4L2_CID_LINK_FREQ,
+						   size - 1, 0,
+						   link_freq_menu_items);
+	if (hm11b1->link_freq)
+		hm11b1->link_freq->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	pixel_rate = to_pixel_rate(HM11B1_LINK_FREQ_384MHZ_INDEX);
+	hm11b1->pixel_rate = v4l2_ctrl_new_std(ctrl_hdlr, &hm11b1_ctrl_ops,
+					       V4L2_CID_PIXEL_RATE, 0,
+					       pixel_rate, 1, pixel_rate);
+
+	vblank_min = cur_mode->vts_min - cur_mode->height;
+	vblank_max = HM11B1_VTS_MAX - cur_mode->height;
+	vblank_default = cur_mode->vts_def - cur_mode->height;
+	hm11b1->vblank = v4l2_ctrl_new_std(ctrl_hdlr, &hm11b1_ctrl_ops,
+					   V4L2_CID_VBLANK, vblank_min,
+					   vblank_max, 1, vblank_default);
+
+	h_blank = to_pixels_per_line(cur_mode->hts, cur_mode->link_freq_index);
+	h_blank -= cur_mode->width;
+	hm11b1->hblank = v4l2_ctrl_new_std(ctrl_hdlr, &hm11b1_ctrl_ops,
+					   V4L2_CID_HBLANK, h_blank, h_blank, 1,
+					   h_blank);
+	if (hm11b1->hblank)
+		hm11b1->hblank->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	v4l2_ctrl_new_std(ctrl_hdlr, &hm11b1_ctrl_ops, V4L2_CID_ANALOGUE_GAIN,
+			  HM11B1_ANAL_GAIN_MIN, HM11B1_ANAL_GAIN_MAX,
+			  HM11B1_ANAL_GAIN_STEP, HM11B1_ANAL_GAIN_MIN);
+	v4l2_ctrl_new_std(ctrl_hdlr, &hm11b1_ctrl_ops, V4L2_CID_DIGITAL_GAIN,
+			  HM11B1_DGTL_GAIN_MIN, HM11B1_DGTL_GAIN_MAX,
+			  HM11B1_DGTL_GAIN_STEP, HM11B1_DGTL_GAIN_DEFAULT);
+	exposure_max = cur_mode->vts_def - HM11B1_EXPOSURE_MAX_MARGIN;
+	hm11b1->exposure = v4l2_ctrl_new_std(ctrl_hdlr, &hm11b1_ctrl_ops,
+					     V4L2_CID_EXPOSURE,
+					     HM11B1_EXPOSURE_MIN, exposure_max,
+					     HM11B1_EXPOSURE_STEP,
+					     exposure_max);
+	v4l2_ctrl_new_std_menu_items(ctrl_hdlr, &hm11b1_ctrl_ops,
+				     V4L2_CID_TEST_PATTERN,
+				     ARRAY_SIZE(hm11b1_test_pattern_menu) - 1,
+				     0, 0, hm11b1_test_pattern_menu);
+	if (ctrl_hdlr->error)
+		return ctrl_hdlr->error;
+
+	hm11b1->sd.ctrl_handler = ctrl_hdlr;
+
+	return 0;
+}
+
+static void hm11b1_update_pad_format(const struct hm11b1_mode *mode,
+				     struct v4l2_mbus_framefmt *fmt)
+{
+	fmt->width = mode->width;
+	fmt->height = mode->height;
+	fmt->code = MEDIA_BUS_FMT_SGRBG10_1X10;
+	fmt->field = V4L2_FIELD_NONE;
+}
+
+static int hm11b1_start_streaming(struct hm11b1 *hm11b1)
+{
+	struct i2c_client *client = hm11b1->client;
+	const struct hm11b1_reg_list *reg_list;
+	int link_freq_index;
+	int ret = 0;
+
+	hm11b1_set_power(hm11b1, 1);
+	link_freq_index = hm11b1->cur_mode->link_freq_index;
+	reg_list = &link_freq_configs[link_freq_index].reg_list;
+	ret = hm11b1_write_reg_list(hm11b1, reg_list);
+	if (ret) {
+		dev_err(&client->dev, "failed to set plls");
+		return ret;
+	}
+
+	reg_list = &hm11b1->cur_mode->reg_list;
+	ret = hm11b1_write_reg_list(hm11b1, reg_list);
+	if (ret) {
+		dev_err(&client->dev, "failed to set mode");
+		return ret;
+	}
+
+	ret = __v4l2_ctrl_handler_setup(hm11b1->sd.ctrl_handler);
+	if (ret)
+		return ret;
+
+	ret = hm11b1_write_reg(hm11b1, HM11B1_REG_MODE_SELECT, 1,
+			       HM11B1_MODE_STREAMING);
+	if (ret)
+		dev_err(&client->dev, "failed to start streaming");
+
+	return ret;
+}
+
+static void hm11b1_stop_streaming(struct hm11b1 *hm11b1)
+{
+	struct i2c_client *client = hm11b1->client;
+
+	if (hm11b1_write_reg(hm11b1, HM11B1_REG_MODE_SELECT, 1,
+			     HM11B1_MODE_STANDBY))
+		dev_err(&client->dev, "failed to stop streaming");
+	hm11b1_set_power(hm11b1, 0);
+}
+
+static int hm11b1_set_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct hm11b1 *hm11b1 = to_hm11b1(sd);
+	struct i2c_client *client = hm11b1->client;
+	int ret = 0;
+
+	if (hm11b1->streaming == enable)
+		return 0;
+
+	mutex_lock(&hm11b1->mutex);
+	if (enable) {
+		ret = pm_runtime_get_sync(&client->dev);
+		if (ret < 0) {
+			pm_runtime_put_noidle(&client->dev);
+			mutex_unlock(&hm11b1->mutex);
+			return ret;
+		}
+
+		ret = hm11b1_start_streaming(hm11b1);
+		if (ret) {
+			enable = 0;
+			hm11b1_stop_streaming(hm11b1);
+			pm_runtime_put(&client->dev);
+		}
+	} else {
+		hm11b1_stop_streaming(hm11b1);
+		pm_runtime_put(&client->dev);
+	}
+
+	hm11b1->streaming = enable;
+	mutex_unlock(&hm11b1->mutex);
+
+	return ret;
+}
+
+static int __maybe_unused hm11b1_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct hm11b1 *hm11b1 = to_hm11b1(sd);
+
+	mutex_lock(&hm11b1->mutex);
+	if (hm11b1->streaming)
+		hm11b1_stop_streaming(hm11b1);
+
+	mutex_unlock(&hm11b1->mutex);
+
+	return 0;
+}
+
+static int __maybe_unused hm11b1_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct hm11b1 *hm11b1 = to_hm11b1(sd);
+	int ret = 0;
+
+	mutex_lock(&hm11b1->mutex);
+	if (!hm11b1->streaming)
+		goto exit;
+
+	ret = hm11b1_start_streaming(hm11b1);
+	if (ret) {
+		hm11b1->streaming = false;
+		hm11b1_stop_streaming(hm11b1);
+	}
+
+exit:
+	mutex_unlock(&hm11b1->mutex);
+	return ret;
+}
+
+static int hm11b1_set_format(struct v4l2_subdev *sd,
+			     struct v4l2_subdev_state *sd_state,
+			     struct v4l2_subdev_format *fmt)
+{
+	struct hm11b1 *hm11b1 = to_hm11b1(sd);
+	const struct hm11b1_mode *mode;
+	s32 vblank_def, h_blank;
+
+	mode = v4l2_find_nearest_size(supported_modes,
+				      ARRAY_SIZE(supported_modes), width,
+				      height, fmt->format.width,
+				      fmt->format.height);
+
+	mutex_lock(&hm11b1->mutex);
+	hm11b1_update_pad_format(mode, &fmt->format);
+	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {
+		*v4l2_subdev_get_try_format(sd, sd_state, fmt->pad) = fmt->format;
+	} else {
+		hm11b1->cur_mode = mode;
+		__v4l2_ctrl_s_ctrl(hm11b1->link_freq, mode->link_freq_index);
+		__v4l2_ctrl_s_ctrl_int64(hm11b1->pixel_rate,
+					 to_pixel_rate(mode->link_freq_index));
+
+		/* Update limits and set FPS to default */
+		vblank_def = mode->vts_def - mode->height;
+		__v4l2_ctrl_modify_range(hm11b1->vblank,
+					 mode->vts_min - mode->height,
+					 HM11B1_VTS_MAX - mode->height, 1,
+					 vblank_def);
+		__v4l2_ctrl_s_ctrl(hm11b1->vblank, vblank_def);
+		h_blank = to_pixels_per_line(mode->hts, mode->link_freq_index) -
+			  mode->width;
+		__v4l2_ctrl_modify_range(hm11b1->hblank, h_blank, h_blank, 1,
+					 h_blank);
+	}
+	mutex_unlock(&hm11b1->mutex);
+
+	return 0;
+}
+
+static int hm11b1_get_format(struct v4l2_subdev *sd,
+			     struct v4l2_subdev_state *sd_state,
+			     struct v4l2_subdev_format *fmt)
+{
+	struct hm11b1 *hm11b1 = to_hm11b1(sd);
+
+	mutex_lock(&hm11b1->mutex);
+	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY)
+		fmt->format = *v4l2_subdev_get_try_format(&hm11b1->sd,
+							  sd_state, fmt->pad);
+	else
+		hm11b1_update_pad_format(hm11b1->cur_mode, &fmt->format);
+
+	mutex_unlock(&hm11b1->mutex);
+
+	return 0;
+}
+
+static int hm11b1_enum_mbus_code(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_state *sd_state,
+				 struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->index > 0)
+		return -EINVAL;
+
+	code->code = MEDIA_BUS_FMT_SGRBG10_1X10;
+
+	return 0;
+}
+
+static int hm11b1_enum_frame_size(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_state *sd_state,
+				  struct v4l2_subdev_frame_size_enum *fse)
+{
+	if (fse->index >= ARRAY_SIZE(supported_modes))
+		return -EINVAL;
+
+	if (fse->code != MEDIA_BUS_FMT_SGRBG10_1X10)
+		return -EINVAL;
+
+	fse->min_width = supported_modes[fse->index].width;
+	fse->max_width = fse->min_width;
+	fse->min_height = supported_modes[fse->index].height;
+	fse->max_height = fse->min_height;
+
+	return 0;
+}
+
+static int hm11b1_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct hm11b1 *hm11b1 = to_hm11b1(sd);
+
+	mutex_lock(&hm11b1->mutex);
+	hm11b1_update_pad_format(&supported_modes[0],
+				 v4l2_subdev_get_try_format(sd, fh->state, 0));
+	mutex_unlock(&hm11b1->mutex);
+
+	return 0;
+}
+
+static const struct v4l2_subdev_video_ops hm11b1_video_ops = {
+	.s_stream = hm11b1_set_stream,
+};
+
+static const struct v4l2_subdev_pad_ops hm11b1_pad_ops = {
+	.set_fmt = hm11b1_set_format,
+	.get_fmt = hm11b1_get_format,
+	.enum_mbus_code = hm11b1_enum_mbus_code,
+	.enum_frame_size = hm11b1_enum_frame_size,
+};
+
+static const struct v4l2_subdev_ops hm11b1_subdev_ops = {
+	.video = &hm11b1_video_ops,
+	.pad = &hm11b1_pad_ops,
+};
+
+static const struct media_entity_operations hm11b1_subdev_entity_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+static const struct v4l2_subdev_internal_ops hm11b1_internal_ops = {
+	.open = hm11b1_open,
+};
+
+static int hm11b1_identify_module(struct hm11b1 *hm11b1)
+{
+	struct i2c_client *client = hm11b1->client;
+	int ret;
+	u32 val;
+
+	ret = hm11b1_read_reg(hm11b1, HM11B1_REG_CHIP_ID, 2, &val);
+	if (ret)
+		return ret;
+
+	if (val != HM11B1_CHIP_ID) {
+		dev_err(&client->dev, "chip id mismatch: %x!=%x",
+			HM11B1_CHIP_ID, val);
+		return -ENXIO;
+	}
+
+	return 0;
+}
+
+static void hm11b1_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct hm11b1 *hm11b1 = to_hm11b1(sd);
+
+	v4l2_async_unregister_subdev(sd);
+	media_entity_cleanup(&sd->entity);
+	v4l2_ctrl_handler_free(sd->ctrl_handler);
+	pm_runtime_disable(&client->dev);
+	mutex_destroy(&hm11b1->mutex);
+
+}
+
+#if IS_ENABLED(CONFIG_INTEL_SKL_INT3472)
+static int hm11b1_parse_dt(struct hm11b1 *hm11b1)
+{
+	struct device *dev = &hm11b1->client->dev;
+	int ret;
+
+	hm11b1->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	ret = PTR_ERR_OR_ZERO(hm11b1->reset_gpio);
+	if (ret < 0) {
+		dev_err(dev, "error while getting reset gpio: %d\n", ret);
+		return ret;
+	}
+
+	hm11b1->powerdown_gpio = devm_gpiod_get(dev, "powerdown", GPIOD_OUT_HIGH);
+	ret = PTR_ERR_OR_ZERO(hm11b1->powerdown_gpio);
+	if (ret < 0) {
+		dev_err(dev, "error while getting powerdown gpio: %d\n", ret);
+		return ret;
+	}
+
+	hm11b1->clken_gpio = devm_gpiod_get(dev, "clken", GPIOD_OUT_HIGH);
+	ret = PTR_ERR_OR_ZERO(hm11b1->clken_gpio);
+	if (ret < 0) {
+		dev_err(dev, "error while getting clken_gpio gpio: %d\n", ret);
+		return ret;
+	}
+
+	hm11b1->pled_gpio = devm_gpiod_get(dev, "pled", GPIOD_OUT_HIGH);
+	ret = PTR_ERR_OR_ZERO(hm11b1->pled_gpio);
+	if (ret < 0) {
+		dev_err(dev, "error while getting pled gpio: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+#endif
+
+static int hm11b1_probe(struct i2c_client *client)
+{
+	struct hm11b1 *hm11b1;
+	int ret = 0;
+
+	hm11b1 = devm_kzalloc(&client->dev, sizeof(*hm11b1), GFP_KERNEL);
+	if (!hm11b1)
+		return -ENOMEM;
+	hm11b1->client = client;
+
+#if IS_ENABLED(CONFIG_INTEL_SKL_INT3472)
+	ret = hm11b1_parse_dt(hm11b1);
+	if (ret < 0)
+		return -EPROBE_DEFER;
+#elif IS_ENABLED(CONFIG_POWER_CTRL_LOGIC)
+	if (power_ctrl_logic_set_power(1))
+		return -EPROBE_DEFER;
+#endif
+	hm11b1_set_power(hm11b1, 1);
+
+	v4l2_i2c_subdev_init(&hm11b1->sd, client, &hm11b1_subdev_ops);
+	ret = hm11b1_identify_module(hm11b1);
+	if (ret) {
+		dev_err(&client->dev, "failed to find sensor: %d", ret);
+		goto probe_error_power_off;
+	}
+
+	mutex_init(&hm11b1->mutex);
+	hm11b1->cur_mode = &supported_modes[0];
+	ret = hm11b1_init_controls(hm11b1);
+	if (ret) {
+		dev_err(&client->dev, "failed to init controls: %d", ret);
+		goto probe_error_v4l2_ctrl_handler_free;
+	}
+
+	hm11b1->sd.internal_ops = &hm11b1_internal_ops;
+	hm11b1->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	hm11b1->sd.entity.ops = &hm11b1_subdev_entity_ops;
+	hm11b1->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;
+	hm11b1->pad.flags = MEDIA_PAD_FL_SOURCE;
+	ret = media_entity_pads_init(&hm11b1->sd.entity, 1, &hm11b1->pad);
+	if (ret) {
+		dev_err(&client->dev, "failed to init entity pads: %d", ret);
+		goto probe_error_v4l2_ctrl_handler_free;
+	}
+
+	ret = v4l2_async_register_subdev_sensor(&hm11b1->sd);
+	if (ret < 0) {
+		dev_err(&client->dev, "failed to register V4L2 subdev: %d",
+			ret);
+		goto probe_error_media_entity_cleanup;
+	}
+
+	/*
+	 * Device is already turned on by i2c-core with ACPI domain PM.
+	 * Enable runtime PM and turn off the device.
+	 */
+	pm_runtime_set_active(&client->dev);
+	pm_runtime_enable(&client->dev);
+	pm_runtime_idle(&client->dev);
+
+	hm11b1_set_power(hm11b1, 0);
+	return 0;
+
+probe_error_media_entity_cleanup:
+	media_entity_cleanup(&hm11b1->sd.entity);
+
+probe_error_v4l2_ctrl_handler_free:
+	v4l2_ctrl_handler_free(hm11b1->sd.ctrl_handler);
+	mutex_destroy(&hm11b1->mutex);
+
+probe_error_power_off:
+	hm11b1_set_power(hm11b1, 0);
+	return ret;
+}
+
+static const struct dev_pm_ops hm11b1_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(hm11b1_suspend, hm11b1_resume)
+};
+
+#ifdef CONFIG_ACPI
+static const struct acpi_device_id hm11b1_acpi_ids[] = {
+	{"HIMX11B1"},
+	{}
+};
+
+MODULE_DEVICE_TABLE(acpi, hm11b1_acpi_ids);
+#endif
+
+static struct i2c_driver hm11b1_i2c_driver = {
+	.driver = {
+		.name = "hm11b1",
+		.pm = &hm11b1_pm_ops,
+		.acpi_match_table = ACPI_PTR(hm11b1_acpi_ids),
+	},
+	.probe_new = hm11b1_probe,
+	.remove = hm11b1_remove,
+};
+
+module_i2c_driver(hm11b1_i2c_driver);
+
+MODULE_AUTHOR("Qiu, Tianshu <tian.shu.qiu@intel.com>");
+MODULE_AUTHOR("Shawn Tu <shawnx.tu@intel.com>");
+MODULE_AUTHOR("Bingbu Cao <bingbu.cao@intel.com>");
+MODULE_AUTHOR("Lai, Jim <jim.lai@intel.com>");
+MODULE_DESCRIPTION("Himax HM11B1 sensor driver");
+MODULE_LICENSE("GPL v2");
Index: b/drivers/media/i2c/imx390-mode-1280x960-CROP.h
===================================================================
--- /dev/null
+++ b/drivers/media/i2c/imx390-mode-1280x960-CROP.h
@@ -0,0 +1,3089 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/**
+ * @author George Vigelette <gvigelette@d3engineering.com>
+ *
+ * imx390 v4l2 driver for tgl
+ */
+
+#ifndef __IMX390_MODE_1280X960_CROP_H
+#define __IMX390_MODE_1280X960_CROP_H
+
+static const struct imx390_reg imx390_mode_1280x960CROP[] = {
+	{0x2E18, 0x00},             /* disable rear embedded data line */
+	{0x000C, 0xF2},
+	{0x000E, 0x00},
+	{0x0010, 0xF2},
+	{0x0011, 0x02},
+	{0x0012, 0x00},
+	{0x0018, 0x15},
+	{0x0019, 0x00},
+	{0x001A, 0x0C},
+	{0x001B, 0x00},
+	{0x0038, 0x00},
+	{0x003C, 0x00},
+	{0x003D, 0x00},
+	{0x003E, 0x00},
+	{0x0040, 0x00},
+	{0x0041, 0x00},
+	{0x0042, 0x00},
+	{0x0044, 0x00},
+	{0x0045, 0x00},
+	{0x0046, 0x00},
+	{0x0048, 0x00},
+	{0x0049, 0x00},
+	{0x004A, 0x00},
+	{0x004C, 0x00},
+	{0x004D, 0x00},
+	{0x004E, 0x00},
+	{0x0050, 0x00},
+	{0x0051, 0x00},
+	{0x0052, 0x00},
+	{0x0054, 0x00},
+	{0x0055, 0x00},
+	{0x0056, 0x00},
+	{0x0058, 0x00},
+	{0x0059, 0x00},
+	{0x005A, 0x00},
+	{0x005C, 0x00},
+	{0x005D, 0x00},
+	{0x005E, 0x00},
+	{0x0060, 0x00},
+	{0x0061, 0x00},
+	{0x0062, 0x00},
+	{0x0064, 0x00},
+	{0x0065, 0x00},
+	{0x0066, 0x00},
+	{0x0068, 0x00},
+	{0x0069, 0x00},
+	{0x006A, 0x00},
+	{0x0074, 0x00}, /* V_REVERSE and H_REVERSE */
+	{0x0078, 0x01}, /* CROP_ON 0x00 */
+	{0x007C, 0x08}, /* CROP_H_OFFSET 0x00 */
+	{0x007D, 0x00},
+	{0x0080, 0x08}, /* CROP_V_OFFSET 0x00 */
+	{0x0081, 0x00},
+	{0x00F4, 0x1C},
+	{0x00F5, 0xF8},
+	{0x00F6, 0x01},
+	{0x00F8, 0x03},
+	{0x00F9, 0x00},
+	{0x00FA, 0x00},
+	{0x00FB, 0x00},
+	{0x0114, 0x00},
+	{0x0115, 0x01},
+	{0x0118, 0x20},
+	{0x0119, 0x03},
+	{0x011A, 0x00},
+	{0x011B, 0x41},
+	{0x011C, 0x80},
+	{0x011D, 0x00},
+	{0x0120, 0x20},
+	{0x0121, 0x00},
+	{0x0122, 0x00},
+	{0x0123, 0x44},
+	{0x0124, 0x00},
+	{0x0125, 0x01},
+	{0x0128, 0xAC},
+	{0x0129, 0x0D},
+	{0x012A, 0x00},
+	{0x012B, 0xA4},
+	{0x012C, 0x00},
+	{0x012D, 0x01},
+	{0x0130, 0xC4},
+	{0x0131, 0x09},
+	{0x0132, 0x00},
+	{0x0133, 0xDA},
+	{0x013B, 0x01},
+	{0x01C4, 0x00},
+	{0x01C5, 0x00},
+	{0x01CC, 0x01},
+	{0x01D0, 0x09},
+	{0x01D4, 0x01},
+	{0x0332, 0x18},
+	{0x0333, 0x00},
+	{0x0390, 0x00},
+	{0x0391, 0x00},
+	{0x0392, 0x00},
+	{0x03C0, 0x01}, /* SM_CROP_ON_APL 0x00 */
+	{0x2000, 0x55},
+	{0x2001, 0x55},
+	{0x2002, 0x55},
+	{0x2003, 0x05},
+	{0x2004, 0x02},
+	{0x2008, 0x65},
+	{0x2009, 0x04},
+	{0x200A, 0x00},
+	{0x200C, 0x30},
+	{0x200D, 0x11},
+	{0x2010, 0x04},
+	{0x2014, 0x01},
+	{0x2018, 0x02},
+	{0x2019, 0x04},
+	{0x201A, 0x00},
+	{0x201C, 0x21},
+	{0x201D, 0x11},
+	{0x201E, 0x00},
+	{0x201F, 0x00},
+	{0x2020, 0xBC},
+	{0x2021, 0x00},
+	{0x2022, 0x7F},
+	{0x2023, 0x00},
+	{0x2024, 0xBA},
+	{0x2025, 0x00},
+	{0x2026, 0x81},
+	{0x2027, 0x00},
+	{0x2028, 0x7D},
+	{0x2029, 0x90},
+	{0x202A, 0x05},
+	{0x202C, 0xFC},
+	{0x202D, 0x02},
+	{0x202E, 0x25},
+	{0x202F, 0x03},
+	{0x2030, 0x05},
+	{0x2031, 0x02},
+	{0x2032, 0xCA},
+	{0x2033, 0x02},
+	{0x2034, 0xFC},
+	{0x2035, 0x02},
+	{0x2036, 0x25},
+	{0x2037, 0x03},
+	{0x2038, 0x25},
+	{0x2039, 0x97},
+	{0x203A, 0xEC},
+	{0x203B, 0x01},
+	{0x203C, 0xF5},
+	{0x203D, 0x8E},
+	{0x203E, 0x0C},
+	{0x203F, 0x2D},
+	{0x2040, 0x69},
+	{0x2041, 0x01},
+	{0x2042, 0x8E},
+	{0x2043, 0x01},
+	{0x2044, 0x0C},
+	{0x2045, 0x02},
+	{0x2046, 0x31},
+	{0x2047, 0x02},
+	{0x2048, 0x6A},
+	{0x2049, 0x01},
+	{0x204A, 0x8E},
+	{0x204B, 0x01},
+	{0x204C, 0x0D},
+	{0x204D, 0x02},
+	{0x204E, 0x31},
+	{0x204F, 0x02},
+	{0x2050, 0x7B},
+	{0x2051, 0x00},
+	{0x2052, 0x7D},
+	{0x2053, 0x00},
+	{0x2054, 0x95},
+	{0x2055, 0x00},
+	{0x2056, 0x97},
+	{0x2057, 0x00},
+	{0x2058, 0xAD},
+	{0x2059, 0x00},
+	{0x205A, 0xAF},
+	{0x205B, 0x00},
+	{0x205C, 0x92},
+	{0x205D, 0x00},
+	{0x205E, 0x94},
+	{0x205F, 0x00},
+	{0x2060, 0x8E},
+	{0x2061, 0x00},
+	{0x2062, 0x90},
+	{0x2063, 0x00},
+	{0x2064, 0xB1},
+	{0x2065, 0x00},
+	{0x2066, 0xB3},
+	{0x2067, 0x00},
+	{0x2068, 0x08},
+	{0x2069, 0x00},
+	{0x206A, 0x04},
+	{0x206B, 0x00},
+	{0x206C, 0x84},
+	{0x206D, 0x00},
+	{0x206E, 0x80},
+	{0x206F, 0x00},
+	{0x2070, 0x04},
+	{0x2071, 0x00},
+	{0x2072, 0x46},
+	{0x2073, 0x00},
+	{0x2074, 0xE9},
+	{0x2075, 0x01},
+	{0x2076, 0x74},
+	{0x2077, 0x02},
+	{0x2078, 0x80},
+	{0x2079, 0x00},
+	{0x207A, 0xC1},
+	{0x207B, 0x00},
+	{0x207C, 0xFF},
+	{0x207D, 0x03},
+	{0x207E, 0xFF},
+	{0x207F, 0x03},
+	{0x2080, 0x78},
+	{0x2081, 0x00},
+	{0x2082, 0x6A},
+	{0x2083, 0x01},
+	{0x2084, 0xE4},
+	{0x2085, 0x01},
+	{0x2086, 0x2B},
+	{0x2087, 0x03},
+	{0x2088, 0x00},
+	{0x2089, 0x00},
+	{0x208A, 0xFF},
+	{0x208B, 0x03},
+	{0x208C, 0xFF},
+	{0x208D, 0x03},
+	{0x208E, 0xFF},
+	{0x208F, 0x03},
+	{0x2090, 0x7D},
+	{0x2091, 0x00},
+	{0x2092, 0x62},
+	{0x2093, 0x01},
+	{0x2094, 0xE9},
+	{0x2095, 0x01},
+	{0x2096, 0x00},
+	{0x2097, 0x00},
+	{0x2098, 0x7C},
+	{0x2099, 0x00},
+	{0x209A, 0x21},
+	{0x209B, 0x03},
+	{0x209C, 0xE9},
+	{0x209D, 0x01},
+	{0x209E, 0x21},
+	{0x209F, 0x03},
+	{0x20A0, 0xFF},
+	{0x20A1, 0x03},
+	{0x20A2, 0xFF},
+	{0x20A3, 0x03},
+	{0x20A4, 0xFF},
+	{0x20A5, 0x03},
+	{0x20A6, 0xFF},
+	{0x20A7, 0x03},
+	{0x20A8, 0xFF},
+	{0x20A9, 0x03},
+	{0x20AA, 0xFF},
+	{0x20AB, 0x03},
+	{0x20AC, 0xFF},
+	{0x20AD, 0x03},
+	{0x20AE, 0xFF},
+	{0x20AF, 0x03},
+	{0x20B0, 0xFF},
+	{0x20B1, 0x03},
+	{0x20B2, 0xFF},
+	{0x20B3, 0x03},
+	{0x20B4, 0x87},
+	{0x20B5, 0xCC},
+	{0x20B6, 0x87},
+	{0x20B7, 0x08},
+	{0x20B8, 0xF4},
+	{0x20B9, 0xA5},
+	{0x20BA, 0x07},
+	{0x20BC, 0x1F},
+	{0x20BD, 0x01},
+	{0x20BE, 0xF6},
+	{0x20BF, 0x00},
+	{0x20C0, 0x90},
+	{0x20C1, 0x01},
+	{0x20C2, 0x67},
+	{0x20C3, 0x01},
+	{0x20C4, 0xFF},
+	{0x20C5, 0x03},
+	{0x20C6, 0xFF},
+	{0x20C7, 0x03},
+	{0x20C8, 0x33},
+	{0x20C9, 0x02},
+	{0x20CA, 0x0A},
+	{0x20CB, 0x02},
+	{0x20CC, 0x7F},
+	{0x20CD, 0x00},
+	{0x20CE, 0xD2},
+	{0x20CF, 0x00},
+	{0x20D0, 0x81},
+	{0x20D1, 0x00},
+	{0x20D2, 0x87},
+	{0x20D3, 0x00},
+	{0x20D4, 0x09},
+	{0x20D5, 0x00},
+	{0x20D8, 0x7F},
+	{0x20D9, 0x00},
+	{0x20DA, 0x62},
+	{0x20DB, 0x01},
+	{0x20DC, 0x7F},
+	{0x20DD, 0x00},
+	{0x20DE, 0x62},
+	{0x20DF, 0x01},
+	{0x20E0, 0x65},
+	{0x20E1, 0x00},
+	{0x20E2, 0x75},
+	{0x20E3, 0x00},
+	{0x20E4, 0xE0},
+	{0x20E5, 0x00},
+	{0x20E6, 0xF0},
+	{0x20E7, 0x00},
+	{0x20E8, 0x4C},
+	{0x20E9, 0x01},
+	{0x20EA, 0x5C},
+	{0x20EB, 0x01},
+	{0x20EC, 0xD1},
+	{0x20ED, 0x01},
+	{0x20EE, 0xE1},
+	{0x20EF, 0x01},
+	{0x20F0, 0x93},
+	{0x20F1, 0x02},
+	{0x20F2, 0xA3},
+	{0x20F3, 0x02},
+	{0x20F4, 0x0D},
+	{0x20F5, 0x03},
+	{0x20F6, 0x1D},
+	{0x20F7, 0x03},
+	{0x20F8, 0x57},
+	{0x20F9, 0x00},
+	{0x20FA, 0x7B},
+	{0x20FB, 0x00},
+	{0x20FC, 0xD2},
+	{0x20FD, 0x00},
+	{0x20FE, 0xF6},
+	{0x20FF, 0x00},
+	{0x2100, 0x3E},
+	{0x2101, 0x01},
+	{0x2102, 0x60},
+	{0x2103, 0x01},
+	{0x2104, 0xC3},
+	{0x2105, 0x01},
+	{0x2106, 0xE5},
+	{0x2107, 0x01},
+	{0x2108, 0x85},
+	{0x2109, 0x02},
+	{0x210A, 0xA9},
+	{0x210B, 0x02},
+	{0x210C, 0xFF},
+	{0x210D, 0x02},
+	{0x210E, 0x21},
+	{0x210F, 0x03},
+	{0x2110, 0xFF},
+	{0x2111, 0x03},
+	{0x2112, 0x00},
+	{0x2113, 0x00},
+	{0x2114, 0xFF},
+	{0x2115, 0x03},
+	{0x2116, 0xFF},
+	{0x2117, 0x03},
+	{0x2118, 0xFF},
+	{0x2119, 0x03},
+	{0x211A, 0xFF},
+	{0x211B, 0x03},
+	{0x211C, 0xFF},
+	{0x211D, 0x03},
+	{0x211E, 0xFF},
+	{0x211F, 0x03},
+	{0x2120, 0xFF},
+	{0x2121, 0x03},
+	{0x2122, 0xFF},
+	{0x2123, 0x03},
+	{0x2124, 0xFF},
+	{0x2125, 0x03},
+	{0x2126, 0xFF},
+	{0x2127, 0x03},
+	{0x2128, 0x7D},
+	{0x2129, 0x90},
+	{0x212A, 0xD5},
+	{0x212B, 0x07},
+	{0x212C, 0x64},
+	{0x212D, 0x01},
+	{0x2130, 0x5F},
+	{0x2131, 0x7D},
+	{0x2132, 0x05},
+	{0x2134, 0x78},
+	{0x2135, 0x00},
+	{0x2136, 0x76},
+	{0x2137, 0x00},
+	{0x2138, 0xF3},
+	{0x2139, 0x00},
+	{0x213A, 0xF1},
+	{0x213B, 0x00},
+	{0x213C, 0xA6},
+	{0x213D, 0x02},
+	{0x213E, 0xA4},
+	{0x213F, 0x02},
+	{0x2140, 0x7D},
+	{0x2141, 0x00},
+	{0x2142, 0x8D},
+	{0x2143, 0x00},
+	{0x2144, 0xA1},
+	{0x2145, 0x01},
+	{0x2146, 0xB1},
+	{0x2147, 0x01},
+	{0x2148, 0xAB},
+	{0x2149, 0x02},
+	{0x214A, 0xBB},
+	{0x214B, 0x02},
+	{0x214C, 0x17},
+	{0x214D, 0x5C},
+	{0x214E, 0x00},
+	{0x2150, 0x00},
+	{0x2151, 0x00},
+	{0x2152, 0xF8},
+	{0x2153, 0x00},
+	{0x2154, 0xBE},
+	{0x2155, 0x00},
+	{0x2156, 0x7D},
+	{0x2157, 0x00},
+	{0x2158, 0x25},
+	{0x2159, 0x00},
+	{0x215A, 0x7D},
+	{0x215B, 0x00},
+	{0x215C, 0x62},
+	{0x215D, 0x01},
+	{0x215E, 0xFF},
+	{0x215F, 0x03},
+	{0x2160, 0x26},
+	{0x2161, 0x00},
+	{0x2162, 0x7D},
+	{0x2163, 0x00},
+	{0x2164, 0x63},
+	{0x2165, 0x01},
+	{0x2166, 0xFF},
+	{0x2167, 0x03},
+	{0x2168, 0xCB},
+	{0x2169, 0x02},
+	{0x216A, 0xCF},
+	{0x216B, 0x02},
+	{0x216C, 0xFF},
+	{0x216D, 0x03},
+	{0x216E, 0xFF},
+	{0x216F, 0x03},
+	{0x2170, 0xFF},
+	{0x2171, 0x03},
+	{0x2172, 0xFF},
+	{0x2173, 0x03},
+	{0x2174, 0xFF},
+	{0x2175, 0x03},
+	{0x2176, 0xFF},
+	{0x2177, 0x03},
+	{0x2178, 0x7E},
+	{0x2179, 0x00},
+	{0x217A, 0xBD},
+	{0x217B, 0x00},
+	{0x217C, 0xEC},
+	{0x217D, 0x01},
+	{0x217E, 0x7B},
+	{0x217F, 0x02},
+	{0x2180, 0xD1},
+	{0x2181, 0x02},
+	{0x2182, 0x25},
+	{0x2183, 0x03},
+	{0x2184, 0x7F},
+	{0x2185, 0x00},
+	{0x2186, 0xBD},
+	{0x2187, 0x00},
+	{0x2188, 0xED},
+	{0x2189, 0x01},
+	{0x218A, 0x7B},
+	{0x218B, 0x02},
+	{0x218C, 0xD2},
+	{0x218D, 0x02},
+	{0x218E, 0x25},
+	{0x218F, 0x03},
+	{0x2190, 0xFF},
+	{0x2191, 0x03},
+	{0x2192, 0xFF},
+	{0x2193, 0x03},
+	{0x2194, 0xE9},
+	{0x2195, 0x01},
+	{0x2196, 0x21},
+	{0x2197, 0x03},
+	{0x2198, 0x17},
+	{0x2199, 0xFC},
+	{0x219A, 0x7F},
+	{0x219B, 0x01},
+	{0x219C, 0xFF},
+	{0x219D, 0x03},
+	{0x21A0, 0x1B},
+	{0x21A1, 0x1B},
+	{0x21A2, 0x1B},
+	{0x21A3, 0x1B},
+	{0x21A4, 0x2E},
+	{0x21A5, 0x80},
+	{0x21A6, 0x00},
+	{0x21A8, 0x04},
+	{0x21A9, 0x98},
+	{0x21AA, 0x60},
+	{0x21AB, 0x03},
+	{0x21AC, 0x7F},
+	{0x21AD, 0x80},
+	{0x21AE, 0x09},
+	{0x21B0, 0x1C},
+	{0x21B1, 0x00},
+	{0x21B2, 0xA0},
+	{0x21B3, 0x00},
+	{0x21B4, 0x0C},
+	{0x21B5, 0x00},
+	{0x21B6, 0x2D},
+	{0x21B7, 0x00},
+	{0x21B8, 0x20},
+	{0x21B9, 0x00},
+	{0x21BA, 0x02},
+	{0x21BB, 0x00},
+	{0x21BC, 0xCC},
+	{0x21BD, 0x00},
+	{0x21BE, 0x4A},
+	{0x21BF, 0x00},
+	{0x21C0, 0xD0},
+	{0x21C1, 0x00},
+	{0x21C2, 0x44},
+	{0x21C3, 0x00},
+	{0x21C4, 0x00},
+	{0x21C5, 0xE0},
+	{0x21C6, 0x00},
+	{0x21C8, 0x11},
+	{0x21C9, 0x00},
+	{0x21CA, 0x02},
+	{0x21CC, 0x08},
+	{0x21CD, 0xC0},
+	{0x21CE, 0x0C},
+	{0x21D0, 0x44},
+	{0x21D1, 0x00},
+	{0x21D2, 0x02},
+	{0x21D4, 0x02},
+	{0x21D5, 0x20},
+	{0x21D6, 0x2C},
+	{0x21D8, 0xFE},
+	{0x21D9, 0x9D},
+	{0x21DA, 0xDF},
+	{0x21DB, 0x03},
+	{0x21DC, 0x62},
+	{0x21DD, 0x01},
+	{0x21DE, 0x7F},
+	{0x21DF, 0x00},
+	{0x21E0, 0xB7},
+	{0x21E1, 0x01},
+	{0x21E2, 0xB5},
+	{0x21E3, 0x01},
+	{0x21E4, 0xC1},
+	{0x21E5, 0x02},
+	{0x21E6, 0xBF},
+	{0x21E7, 0x02},
+	{0x21E8, 0xB3},
+	{0x21E9, 0x0D},
+	{0x21EA, 0x00},
+	{0x21EB, 0x04},
+	{0x21EC, 0x90},
+	{0x21ED, 0x07},
+	{0x21EE, 0x58},
+	{0x21EF, 0x04},
+	{0x21F0, 0x54},
+	{0x21F1, 0x04},
+	{0x21F4, 0x02},
+	{0x21F5, 0x00},
+	{0x21F6, 0x00},
+	{0x21F8, 0x3C},
+	{0x21F9, 0x00},
+	{0x21FC, 0x28},
+	{0x21FD, 0x00},
+	{0x21FE, 0x3C},
+	{0x21FF, 0x00},
+	{0x2200, 0x00},
+	{0x2204, 0x4C},
+	{0x2205, 0x04},
+	{0x2206, 0x65},
+	{0x2207, 0x04},
+	{0x2208, 0x0A},
+	{0x2209, 0x00},
+	{0x220C, 0x47},
+	{0x220D, 0x00},
+	{0x220E, 0x1F},
+	{0x220F, 0x00},
+	{0x2210, 0x17},
+	{0x2211, 0x00},
+	{0x2212, 0x0F},
+	{0x2213, 0x00},
+	{0x2214, 0x17},
+	{0x2215, 0x00},
+	{0x2216, 0x47},
+	{0x2217, 0x00},
+	{0x2218, 0x0F},
+	{0x2219, 0x00},
+	{0x221A, 0x0F},
+	{0x221B, 0x00},
+	{0x221C, 0x03},
+	{0x2220, 0x20},
+	{0x2221, 0x20},
+	{0x2222, 0x22},
+	{0x2223, 0x02},
+	{0x2224, 0xA7},
+	{0x2225, 0xAA},
+	{0x2226, 0x80},
+	{0x2227, 0x08},
+	{0x2228, 0x01},
+	{0x22B2, 0x92},
+	{0x22B4, 0x20},
+	{0x22B5, 0x00},
+	{0x22B6, 0x20},
+	{0x22B7, 0x00},
+	{0x22B8, 0x20},
+	{0x22B9, 0x00},
+	{0x22BA, 0x20},
+	{0x22BB, 0x00},
+	{0x22BC, 0x20},
+	{0x22BD, 0x00},
+	{0x22BE, 0x20},
+	{0x22BF, 0x00},
+	{0x22C0, 0x20},
+	{0x22C1, 0x00},
+	{0x22C2, 0x20},
+	{0x22C3, 0x00},
+	{0x22C4, 0x20},
+	{0x22C5, 0x00},
+	{0x22C6, 0x20},
+	{0x22C7, 0x00},
+	{0x22C8, 0x20},
+	{0x22C9, 0x00},
+	{0x22CA, 0x20},
+	{0x22CB, 0x00},
+	{0x22CC, 0x20},
+	{0x22CD, 0x00},
+	{0x22CE, 0x20},
+	{0x22CF, 0x00},
+	{0x22DA, 0x00},
+	{0x2308, 0x01},
+	{0x2311, 0x09},
+	{0x2318, 0x40},
+	{0x2319, 0xCD},
+	{0x231A, 0x54},
+	{0x2324, 0x10},
+	{0x2325, 0x00},
+	{0x2328, 0x00},
+	{0x2354, 0x0C},
+	{0x23C0, 0x5D},
+	{0x244C, 0x00},
+	{0x244D, 0x02},
+	{0x244E, 0x54},
+	{0x244F, 0x02},
+	{0x24A0, 0x00},
+	{0x24DA, 0x6F},
+	{0x24DB, 0x00},
+	{0x24DC, 0x62},
+	{0x24DD, 0x01},
+	{0x24EA, 0x32},
+	{0x24EB, 0x00},
+	{0x24EC, 0xDC},
+	{0x24ED, 0x00},
+	{0x24FA, 0x32},
+	{0x24FB, 0x00},
+	{0x24FC, 0xDD},
+	{0x24FD, 0x00},
+	{0x254A, 0x15},
+	{0x254B, 0x01},
+	{0x255A, 0x15},
+	{0x255B, 0x01},
+	{0x2560, 0x01},
+	{0x2561, 0x00},
+	{0x2562, 0x2A},
+	{0x2563, 0x00},
+	{0x2564, 0xF8},
+	{0x2565, 0x00},
+	{0x2566, 0x15},
+	{0x2567, 0x01},
+	{0x2568, 0x0C},
+	{0x2569, 0x02},
+	{0x256A, 0x31},
+	{0x256B, 0x02},
+	{0x2578, 0x90},
+	{0x2579, 0x01},
+	{0x257A, 0x92},
+	{0x257B, 0x01},
+	{0x257C, 0xB8},
+	{0x257D, 0x02},
+	{0x257E, 0xBA},
+	{0x257F, 0x02},
+	{0x2584, 0x90},
+	{0x2585, 0x01},
+	{0x2586, 0x92},
+	{0x2587, 0x01},
+	{0x2588, 0xB8},
+	{0x2589, 0x02},
+	{0x258A, 0xBA},
+	{0x258B, 0x02},
+	{0x26B8, 0x10},
+	{0x26B9, 0x00},
+	{0x26BA, 0x33},
+	{0x26BB, 0x00},
+	{0x26BC, 0x89},
+	{0x26BD, 0x00},
+	{0x26BE, 0xB0},
+	{0x26BF, 0x00},
+	{0x26C4, 0x4E},
+	{0x26C5, 0x00},
+	{0x26C8, 0xC9},
+	{0x26C9, 0x00},
+	{0x26CC, 0x35},
+	{0x26CD, 0x01},
+	{0x26D0, 0xBA},
+	{0x26D1, 0x01},
+	{0x26D4, 0x7C},
+	{0x26D5, 0x02},
+	{0x26D8, 0xF6},
+	{0x26D9, 0x02},
+	{0x26DE, 0x51},
+	{0x26DF, 0x00},
+	{0x26E0, 0x7F},
+	{0x26E1, 0x00},
+	{0x26E2, 0xCC},
+	{0x26E3, 0x00},
+	{0x26E4, 0xF8},
+	{0x26E5, 0x00},
+	{0x26E6, 0x38},
+	{0x26E7, 0x01},
+	{0x26E8, 0x65},
+	{0x26E9, 0x01},
+	{0x26EA, 0xBD},
+	{0x26EB, 0x01},
+	{0x26EE, 0x7F},
+	{0x26EF, 0x02},
+	{0x26F0, 0xAB},
+	{0x26F1, 0x02},
+	{0x26F2, 0xF9},
+	{0x26F3, 0x02},
+	{0x2722, 0x59},
+	{0x2723, 0x02},
+	{0x2938, 0x55},
+	{0x2939, 0x00},
+	{0x293A, 0x17},
+	{0x293B, 0x00},
+	{0x293C, 0xD0},
+	{0x293D, 0x00},
+	{0x293E, 0x91},
+	{0x293F, 0x00},
+	{0x2940, 0x3C},
+	{0x2941, 0x01},
+	{0x2942, 0x0C},
+	{0x2943, 0x01},
+	{0x2944, 0xC1},
+	{0x2945, 0x01},
+	{0x2946, 0x76},
+	{0x2947, 0x01},
+	{0x2948, 0x83},
+	{0x2949, 0x02},
+	{0x294A, 0xFB},
+	{0x294B, 0x01},
+	{0x294C, 0xFD},
+	{0x294D, 0x02},
+	{0x294E, 0xBF},
+	{0x294F, 0x02},
+	{0x2A06, 0xFF},
+	{0x2A07, 0x03},
+	{0x2A20, 0x00},
+	{0x2A21, 0x00},
+	{0x2A22, 0x7D},
+	{0x2A23, 0x00},
+	{0x2B11, 0x19},
+	{0x2B13, 0x15},
+	{0x2B14, 0x14},
+	{0x2B15, 0x13},
+	{0x2B16, 0x12},
+	{0x2B17, 0x11},
+	{0x2B18, 0x10},
+	{0x2B19, 0x0F},
+	{0x2B1A, 0x0E},
+	{0x2B1B, 0x0D},
+	{0x2B1C, 0x0C},
+	{0x2B1D, 0x0B},
+	{0x2B1E, 0x0A},
+	{0x2B1F, 0x09},
+	{0x2B20, 0x08},
+	{0x2B21, 0x07},
+	{0x2B22, 0x06},
+	{0x2B23, 0x05},
+	{0x2B24, 0x04},
+	{0x2B25, 0x03},
+	{0x2B26, 0x03},
+	{0x2B38, 0x01},
+	{0x2B45, 0xE3},
+	{0x2B50, 0x01},
+	{0x2B51, 0x00},
+	{0x2B6D, 0x47},
+	{0x2B70, 0x02},
+	{0x2B71, 0x02},
+	{0x2B72, 0x02},
+	{0x2B7F, 0x7F},
+	{0x2B80, 0x94},
+	{0x2B81, 0x06},
+	{0x2B87, 0x1B},
+	{0x2B88, 0x1B},
+	{0x2B89, 0x17},
+	{0x2B8A, 0x12},
+	{0x2B8B, 0x12},
+	{0x2B8D, 0x2B},
+	{0x2B8E, 0x2B},
+	{0x2B8F, 0x2B},
+	{0x2B90, 0x7F},
+	{0x2B91, 0x1F},
+	{0x2B94, 0x7F},
+	{0x2B95, 0x27},
+	{0x2B98, 0x7F},
+	{0x2B99, 0x57},
+	{0x2BA8, 0xBC},
+	{0x2BA9, 0x62},
+	{0x2BC1, 0x70},
+	{0x2BC5, 0x80},
+	{0x2BD5, 0x30},
+	{0x2BD6, 0xF0},
+	{0x2BD8, 0xDB},
+	{0x2BD9, 0xF6},
+	{0x2BDA, 0x63},
+	{0x2BDB, 0x0C},
+	{0x2BDC, 0x5C},
+	{0x2C98, 0xE1},
+	{0x2C99, 0x2E},
+	{0x2C9B, 0x86},
+	{0x2CA9, 0x80},
+	{0x2CAA, 0x01},
+	{0x2D39, 0x0E},
+	{0x2D54, 0x00},
+	{0x2D5B, 0x58},
+	{0x2D64, 0x02}, /* GRBG */
+	{0x3000, 0x00},
+	{0x3001, 0x00},
+	{0x3002, 0x23},
+	{0x3003, 0xA1},
+	{0x3004, 0x00},
+	{0x3005, 0x20},
+	{0x3006, 0x84},
+	{0x3007, 0x00},
+	{0x3008, 0x06},
+	{0x3009, 0xB4},
+	{0x300A, 0x1F},
+	{0x300B, 0x00},
+	{0x300C, 0x00},
+	{0x300D, 0x1B},
+	{0x300E, 0x90},
+	{0x300F, 0x97},
+	{0x3010, 0x00},
+	{0x3011, 0x00},
+	{0x3012, 0x21},
+	{0x3013, 0x21},
+	{0x3014, 0x00},
+	{0x3015, 0x20},
+	{0x3016, 0x84},
+	{0x3017, 0x00},
+	{0x3018, 0x30},
+	{0x3019, 0x09},
+	{0x301A, 0x46},
+	{0x301B, 0x00},
+	{0x3070, 0xC1},
+	{0x3071, 0x81},
+	{0x3072, 0x29},
+	{0x3073, 0x81},
+	{0x3410, 0x00}, /* crop_h_size */
+	{0x3411, 0x05},
+	{0x3418, 0xBA}, /* crop_v_size */
+	{0x3419, 0x03},
+	{0x34C0, 0xD3},
+	{0x34C1, 0x00},
+	{0x34C2, 0xD3},
+	{0x34C3, 0x00},
+	{0x34C4, 0xD3},
+	{0x34C5, 0x00},
+	{0x34C6, 0xD3},
+	{0x34C7, 0x00},
+	{0x34C8, 0xE2},
+	{0x34C9, 0x21},
+	{0x34CA, 0xE0},
+	{0x34CB, 0x1F},
+	{0x34CC, 0x06},
+	{0x34CD, 0x20},
+	{0x34CE, 0x28},
+	{0x34CF, 0x1F},
+	{0x3584, 0x00},
+	{0x3586, 0x00},
+	{0x3587, 0x01},
+	{0x3588, 0xE6},
+	{0x3589, 0x00},
+	{0x3590, 0x00},
+	{0x3591, 0x00},
+	{0x3594, 0x40},
+	{0x3598, 0x03},
+	{0x3599, 0x00},
+	{0x359A, 0x80},
+	{0x359B, 0x00},
+	{0x359C, 0x00},
+	{0x359D, 0x01},
+	{0x359E, 0x00},
+	{0x359F, 0x02},
+	{0x35A0, 0x00},
+	{0x35A1, 0x04},
+	{0x35A2, 0x20},
+	{0x35A3, 0x00},
+	{0x35A4, 0x40},
+	{0x35A5, 0x00},
+	{0x35A6, 0x80},
+	{0x35A7, 0x00},
+	{0x35A8, 0x00},
+	{0x35A9, 0x01},
+	{0x35AA, 0x3A},
+	{0x35AB, 0x00},
+	{0x35AC, 0x80},
+	{0x35AD, 0x00},
+	{0x35AE, 0x00},
+	{0x35AF, 0x01},
+	{0x35B0, 0x00},
+	{0x35B1, 0x02},
+	{0x35B2, 0x00},
+	{0x35B3, 0x04},
+	{0x35B4, 0x02},
+	{0x35B5, 0x00},
+	{0x35B6, 0x04},
+	{0x35B7, 0x00},
+	{0x35B8, 0x08},
+	{0x35B9, 0x00},
+	{0x35BA, 0x10},
+	{0x35BB, 0x00},
+	{0x35BC, 0x03},
+	{0x35BD, 0x00},
+	{0x35C8, 0x00},
+	{0x35C9, 0x01},
+	{0x35CA, 0x00},
+	{0x35CB, 0x04},
+	{0x35CC, 0x00},
+	{0x35CD, 0x10},
+	{0x35CE, 0x00},
+	{0x35CF, 0x40},
+	{0x35D0, 0x00},
+	{0x35D1, 0x0C},
+	{0x35D2, 0x00},
+	{0x35D3, 0x0C},
+	{0x35D4, 0x00},
+	{0x35D5, 0x0C},
+	{0x35D6, 0x00},
+	{0x35D7, 0x0C},
+	{0x35D8, 0x00},
+	{0x35D9, 0x00},
+	{0x35DA, 0x08},
+	{0x35DB, 0x00},
+	{0x35DC, 0xD8},
+	{0x35DD, 0x0E},
+	{0x35F0, 0x00},
+	{0x35F1, 0x10},
+	{0x35F2, 0x00},
+	{0x35F3, 0x10},
+	{0x35F4, 0x00},
+	{0x35F5, 0x10},
+	{0x35F6, 0x00},
+	{0x35F7, 0x03},
+	{0x35F8, 0x00},
+	{0x35F9, 0x01},
+	{0x35FA, 0x38},
+	{0x35FB, 0x00},
+	{0x35FC, 0xB3},
+	{0x35FD, 0x01},
+	{0x35FE, 0x00},
+	{0x35FF, 0x00},
+	{0x3600, 0x04},
+	{0x3601, 0x06},
+	{0x3604, 0x03},
+	{0x3605, 0x00},
+	{0x3608, 0x03},
+	{0x3609, 0x00},
+	{0x360C, 0x00},
+	{0x360D, 0x00},
+	{0x3610, 0x10},
+	{0x3611, 0x01},
+	{0x3612, 0x00},
+	{0x3613, 0x00},
+	{0x3614, 0x00},
+	{0x3615, 0x00},
+	{0x361C, 0x00},
+	{0x361D, 0x01},
+	{0x361E, 0x00},
+	{0x361F, 0x01},
+	{0x3620, 0x01},
+	{0x3621, 0x00},
+	{0x3622, 0xB0},
+	{0x3623, 0x04},
+	{0x3624, 0xDC},
+	{0x3625, 0x05},
+	{0x3626, 0x00},
+	{0x3627, 0x01},
+	{0x3628, 0xFF},
+	{0x3629, 0x0F},
+	{0x362A, 0x00},
+	{0x362B, 0x10},
+	{0x362C, 0x00},
+	{0x362D, 0x01},
+	{0x3630, 0x40},
+	{0x3631, 0x00},
+	{0x3632, 0x40},
+	{0x3633, 0x00},
+	{0x3634, 0x40},
+	{0x3635, 0x00},
+	{0x3636, 0x40},
+	{0x3637, 0x00},
+	{0x3638, 0x40},
+	{0x3639, 0x00},
+	{0x363A, 0x40},
+	{0x363B, 0x00},
+	{0x363C, 0x40},
+	{0x363D, 0x00},
+	{0x363E, 0x40},
+	{0x363F, 0x00},
+	{0x36C4, 0x99},
+	{0x36C5, 0x09},
+	{0x36C6, 0x18},
+	{0x36C7, 0x07},
+	{0x36C8, 0x65},
+	{0x36C9, 0x0E},
+	{0x36CC, 0x99},
+	{0x36CD, 0x01},
+	{0x36CE, 0x47},
+	{0x36CF, 0x00},
+	{0x36D0, 0x04},
+	{0x36D1, 0x00},
+	{0x36D4, 0x65},
+	{0x36D5, 0x0E},
+	{0x36D6, 0xA4},
+	{0x36D7, 0x0A},
+	{0x36D8, 0x65},
+	{0x36D9, 0x0E},
+	{0x36DC, 0x65},
+	{0x36DD, 0x0E},
+	{0x36DE, 0xA4},
+	{0x36DF, 0x0A},
+	{0x36E0, 0x65},
+	{0x36E1, 0x0E},
+	{0x36E4, 0x65},
+	{0x36E5, 0x0E},
+	{0x36E6, 0xA4},
+	{0x36E7, 0x0A},
+	{0x36E8, 0x65},
+	{0x36E9, 0x0E},
+	{0x36EE, 0x00},
+	{0x36EF, 0x00},
+	{0x36F0, 0x00},
+	{0x36F1, 0x80},
+	{0x36F8, 0x00},
+	{0x3702, 0x03},
+	{0x3703, 0x04},
+	{0x3704, 0x08},
+	{0x370E, 0x0E},
+	{0x3718, 0x62},
+	{0x3719, 0x4A},
+	{0x371A, 0x38},
+	{0x371B, 0x20},
+	{0x371C, 0x64},
+	{0x371D, 0x42},
+	{0x371E, 0x32},
+	{0x371F, 0x1B},
+	{0x3720, 0x9C},
+	{0x3721, 0xA4},
+	{0x3722, 0xAC},
+	{0x3723, 0xB4},
+	{0x3748, 0xAA},
+	{0x3749, 0x96},
+	{0x374A, 0x7D},
+	{0x374B, 0x69},
+	{0x37C0, 0x00},
+	{0x37C1, 0x00},
+	{0x37C2, 0x00},
+	{0x37C4, 0x00},
+	{0x37C5, 0x00},
+	{0x37C6, 0x00},
+	{0x37C8, 0x00},
+	{0x37C9, 0x00},
+	{0x37CA, 0x00},
+	{0x37CC, 0x00},
+	{0x37CD, 0x00},
+	{0x37CE, 0x00},
+	{0x37D0, 0x00},
+	{0x37D1, 0x00},
+	{0x37D2, 0x00},
+	{0x37D4, 0x00},
+	{0x37D5, 0x00},
+	{0x37D6, 0x00},
+	{0x37D8, 0x00},
+	{0x37D9, 0x00},
+	{0x37DA, 0x00},
+	{0x37DC, 0x00},
+	{0x37DD, 0x00},
+	{0x37DE, 0x00},
+	{0x37E0, 0x00},
+	{0x37E1, 0x00},
+	{0x37E2, 0x00},
+	{0x37E4, 0x00},
+	{0x37E5, 0x00},
+	{0x37E6, 0x00},
+	{0x37E8, 0x00},
+	{0x37E9, 0x00},
+	{0x37EA, 0x00},
+	{0x37EC, 0x00},
+	{0x37ED, 0x00},
+	{0x37EE, 0x00},
+	{0x37F0, 0x00},
+	{0x37F4, 0x00},
+	{0x37F5, 0x1E},
+	{0x37F6, 0x34},
+	{0x37F7, 0x00},
+	{0x37F8, 0xFF},
+	{0x37F9, 0xFF},
+	{0x37FA, 0x03},
+	{0x37FC, 0x00},
+	{0x37FD, 0x00},
+	{0x37FE, 0x04},
+	{0x3800, 0xFF},
+	{0x3801, 0xFF},
+	{0x3802, 0x03},
+	{0x3804, 0x00},
+	{0x3805, 0x00},
+	{0x3806, 0x04},
+	{0x3808, 0x00},
+	{0x3809, 0x00},
+	{0x380A, 0x00},
+	{0x380C, 0x00},
+	{0x380D, 0x00},
+	{0x380E, 0x00},
+	{0x3810, 0x00},
+	{0x3811, 0x00},
+	{0x3812, 0x00},
+	{0x3814, 0x00},
+	{0x3815, 0x00},
+	{0x3816, 0x00},
+	{0x3818, 0x00},
+	{0x3819, 0x00},
+	{0x381A, 0x00},
+	{0x381C, 0x00},
+	{0x381D, 0x00},
+	{0x381E, 0x00},
+	{0x3820, 0x00},
+	{0x3821, 0x00},
+	{0x3822, 0x00},
+	{0x3824, 0x00},
+	{0x3825, 0x00},
+	{0x3826, 0x00},
+	{0x3828, 0x00},
+	{0x3829, 0x00},
+	{0x382A, 0x00},
+	{0x382C, 0x00},
+	{0x382D, 0x00},
+	{0x382E, 0x00},
+	{0x3830, 0x00},
+	{0x3831, 0x00},
+	{0x3832, 0x00},
+	{0x3834, 0x00},
+	{0x3835, 0x00},
+	{0x3836, 0x00},
+	{0x3838, 0x00},
+	{0x3839, 0x00},
+	{0x383A, 0x00},
+	{0x383B, 0x00},
+	{0x383C, 0x00},
+	{0x383D, 0x00},
+	{0x383E, 0x00},
+	{0x383F, 0x00},
+	{0x3840, 0x00},
+	{0x3841, 0x00},
+	{0x3842, 0x00},
+	{0x3843, 0x00},
+	{0x3844, 0x00},
+	{0x3845, 0x00},
+	{0x3846, 0x00},
+	{0x3847, 0x00},
+	{0x3848, 0x00},
+	{0x3849, 0x00},
+	{0x384A, 0x00},
+	{0x384B, 0x00},
+	{0x384C, 0x00},
+	{0x384D, 0x00},
+	{0x384E, 0x00},
+	{0x384F, 0x00},
+	{0x3850, 0xFF},
+	{0x3851, 0x0F},
+	{0x3852, 0x00},
+	{0x3853, 0x10},
+	{0x3854, 0xFF},
+	{0x3855, 0x0F},
+	{0x3856, 0x00},
+	{0x3857, 0x10},
+	{0x3858, 0xFF},
+	{0x3859, 0x0F},
+	{0x385A, 0x00},
+	{0x385B, 0x10},
+	{0x385C, 0x02},
+	{0x385D, 0x00},
+	{0x385E, 0x06},
+	{0x385F, 0x00},
+	{0x3860, 0x06},
+	{0x3861, 0x00},
+	{0x3862, 0x08},
+	{0x3863, 0x00},
+	{0x3864, 0x02},
+	{0x3865, 0x00},
+	{0x38A0, 0x01},
+	{0x38A1, 0x01},
+	{0x38A2, 0x00},
+	{0x38A3, 0x01},
+	{0x38A4, 0x07},
+	{0x38A5, 0x00},
+	{0x38A6, 0x04},
+	{0x38A7, 0x05},
+	{0x38A8, 0x00},
+	{0x38A9, 0x00},
+	{0x38AC, 0x00},
+	{0x38AD, 0x00},
+	{0x38AE, 0x01},
+	{0x38B0, 0x02},
+	{0x38B2, 0x22},
+	{0x38B3, 0x00},
+	{0x38B4, 0x17},
+	{0x38B5, 0x00},
+	{0x38B6, 0x11},
+	{0x38B7, 0x00},
+	{0x38B8, 0x0E},
+	{0x38B9, 0x00},
+	{0x38BA, 0x2A},
+	{0x38BB, 0x00},
+	{0x38BC, 0x1C},
+	{0x38BD, 0x00},
+	{0x38BE, 0x14},
+	{0x38BF, 0x00},
+	{0x38C0, 0x10},
+	{0x38C1, 0x00},
+	{0x38C2, 0x31},
+	{0x38C3, 0x00},
+	{0x38C4, 0x21},
+	{0x38C5, 0x00},
+	{0x38C6, 0x18},
+	{0x38C7, 0x00},
+	{0x38C8, 0x12},
+	{0x38C9, 0x00},
+	{0x38CA, 0x3C},
+	{0x38CB, 0x00},
+	{0x38CC, 0x29},
+	{0x38CD, 0x00},
+	{0x38CE, 0x1D},
+	{0x38CF, 0x00},
+	{0x38D0, 0x15},
+	{0x38D1, 0x00},
+	{0x38D2, 0x4E},
+	{0x38D3, 0x00},
+	{0x38D4, 0x35},
+	{0x38D5, 0x00},
+	{0x38D6, 0x26},
+	{0x38D7, 0x00},
+	{0x38D8, 0x1A},
+	{0x38D9, 0x00},
+	{0x38DA, 0x69},
+	{0x38DB, 0x00},
+	{0x38DC, 0x48},
+	{0x38DD, 0x00},
+	{0x38DE, 0x33},
+	{0x38DF, 0x00},
+	{0x38E0, 0x22},
+	{0x38E1, 0x00},
+	{0x38E2, 0x93},
+	{0x38E3, 0x00},
+	{0x38E4, 0x64},
+	{0x38E5, 0x00},
+	{0x38E6, 0x48},
+	{0x38E7, 0x00},
+	{0x38E8, 0x30},
+	{0x38E9, 0x00},
+	{0x38EA, 0xD3},
+	{0x38EB, 0x00},
+	{0x38EC, 0x90},
+	{0x38ED, 0x00},
+	{0x38EE, 0x69},
+	{0x38EF, 0x00},
+	{0x38F0, 0x49},
+	{0x38F1, 0x00},
+	{0x38F2, 0x39},
+	{0x38F3, 0x01},
+	{0x38F4, 0xD5},
+	{0x38F5, 0x00},
+	{0x38F6, 0x9F},
+	{0x38F7, 0x00},
+	{0x38F8, 0x75},
+	{0x38F9, 0x00},
+	{0x38FA, 0x00},
+	{0x38FB, 0x01},
+	{0x38FC, 0x00},
+	{0x38FD, 0x01},
+	{0x38FE, 0x00},
+	{0x38FF, 0x01},
+	{0x3900, 0x00},
+	{0x3901, 0x01},
+	{0x3902, 0x70},
+	{0x3903, 0x00},
+	{0x3904, 0x30},
+	{0x3905, 0x00},
+	{0x3906, 0x25},
+	{0x3907, 0x00},
+	{0x3908, 0x20},
+	{0x3909, 0x00},
+	{0x390A, 0xB2},
+	{0x390B, 0x00},
+	{0x390C, 0x80},
+	{0x390D, 0x00},
+	{0x390E, 0x70},
+	{0x390F, 0x00},
+	{0x3910, 0x50},
+	{0x3911, 0x00},
+	{0x3912, 0xB2},
+	{0x3913, 0x00},
+	{0x3914, 0x80},
+	{0x3915, 0x00},
+	{0x3916, 0x70},
+	{0x3917, 0x00},
+	{0x3918, 0x50},
+	{0x3919, 0x00},
+	{0x391A, 0xB2},
+	{0x391B, 0x00},
+	{0x391C, 0x80},
+	{0x391D, 0x00},
+	{0x391E, 0x70},
+	{0x391F, 0x00},
+	{0x3920, 0x50},
+	{0x3921, 0x00},
+	{0x3922, 0x40},
+	{0x3923, 0x00},
+	{0x3924, 0x40},
+	{0x3925, 0x00},
+	{0x3926, 0x40},
+	{0x3927, 0x00},
+	{0x3928, 0x40},
+	{0x3929, 0x00},
+	{0x392A, 0x80},
+	{0x392B, 0x00},
+	{0x392C, 0x80},
+	{0x392D, 0x00},
+	{0x392E, 0x80},
+	{0x392F, 0x00},
+	{0x3930, 0x80},
+	{0x3931, 0x00},
+	{0x3932, 0x80},
+	{0x3933, 0x80},
+	{0x3934, 0x80},
+	{0x3940, 0x01},
+	{0x3941, 0x01},
+	{0x3942, 0x00},
+	{0x3943, 0x01},
+	{0x3944, 0x07},
+	{0x3945, 0x00},
+	{0x3946, 0x04},
+	{0x3947, 0x05},
+	{0x3948, 0x00},
+	{0x3949, 0x00},
+	{0x394C, 0x00},
+	{0x394D, 0x00},
+	{0x394E, 0x01},
+	{0x3950, 0x03},
+	{0x3952, 0x14},
+	{0x3953, 0x00},
+	{0x3954, 0x0F},
+	{0x3955, 0x00},
+	{0x3956, 0x0E},
+	{0x3957, 0x00},
+	{0x3958, 0x0E},
+	{0x3959, 0x00},
+	{0x395A, 0x19},
+	{0x395B, 0x00},
+	{0x395C, 0x11},
+	{0x395D, 0x00},
+	{0x395E, 0x0F},
+	{0x395F, 0x00},
+	{0x3960, 0x0E},
+	{0x3961, 0x00},
+	{0x3962, 0x1C},
+	{0x3963, 0x00},
+	{0x3964, 0x13},
+	{0x3965, 0x00},
+	{0x3966, 0x0F},
+	{0x3967, 0x00},
+	{0x3968, 0x0E},
+	{0x3969, 0x00},
+	{0x396A, 0x23},
+	{0x396B, 0x00},
+	{0x396C, 0x15},
+	{0x396D, 0x00},
+	{0x396E, 0x11},
+	{0x396F, 0x00},
+	{0x3970, 0x0E},
+	{0x3971, 0x00},
+	{0x3972, 0x2E},
+	{0x3973, 0x00},
+	{0x3974, 0x1A},
+	{0x3975, 0x00},
+	{0x3976, 0x14},
+	{0x3977, 0x00},
+	{0x3978, 0x0F},
+	{0x3979, 0x00},
+	{0x397A, 0x3E},
+	{0x397B, 0x00},
+	{0x397C, 0x23},
+	{0x397D, 0x00},
+	{0x397E, 0x1A},
+	{0x397F, 0x00},
+	{0x3980, 0x12},
+	{0x3981, 0x00},
+	{0x3982, 0x56},
+	{0x3983, 0x00},
+	{0x3984, 0x31},
+	{0x3985, 0x00},
+	{0x3986, 0x25},
+	{0x3987, 0x00},
+	{0x3988, 0x1A},
+	{0x3989, 0x00},
+	{0x398A, 0x7B},
+	{0x398B, 0x00},
+	{0x398C, 0x49},
+	{0x398D, 0x00},
+	{0x398E, 0x39},
+	{0x398F, 0x00},
+	{0x3990, 0x2C},
+	{0x3991, 0x00},
+	{0x3992, 0xB4},
+	{0x3993, 0x00},
+	{0x3994, 0x75},
+	{0x3995, 0x00},
+	{0x3996, 0x61},
+	{0x3997, 0x00},
+	{0x3998, 0x53},
+	{0x3999, 0x00},
+	{0x399A, 0x00},
+	{0x399B, 0x01},
+	{0x399C, 0x00},
+	{0x399D, 0x01},
+	{0x399E, 0x00},
+	{0x399F, 0x01},
+	{0x39A0, 0x00},
+	{0x39A1, 0x01},
+	{0x39A2, 0x70},
+	{0x39A3, 0x00},
+	{0x39A4, 0x30},
+	{0x39A5, 0x00},
+	{0x39A6, 0x25},
+	{0x39A7, 0x00},
+	{0x39A8, 0x20},
+	{0x39A9, 0x00},
+	{0x39AA, 0xB2},
+	{0x39AB, 0x00},
+	{0x39AC, 0x80},
+	{0x39AD, 0x00},
+	{0x39AE, 0x70},
+	{0x39AF, 0x00},
+	{0x39B0, 0x80},
+	{0x39B1, 0x00},
+	{0x39B2, 0xB2},
+	{0x39B3, 0x00},
+	{0x39B4, 0x80},
+	{0x39B5, 0x00},
+	{0x39B6, 0x70},
+	{0x39B7, 0x00},
+	{0x39B8, 0x80},
+	{0x39B9, 0x00},
+	{0x39BA, 0xB2},
+	{0x39BB, 0x00},
+	{0x39BC, 0x80},
+	{0x39BD, 0x00},
+	{0x39BE, 0x70},
+	{0x39BF, 0x00},
+	{0x39C0, 0x80},
+	{0x39C1, 0x00},
+	{0x39C2, 0x40},
+	{0x39C3, 0x00},
+	{0x39C4, 0x40},
+	{0x39C5, 0x00},
+	{0x39C6, 0x40},
+	{0x39C7, 0x00},
+	{0x39C8, 0x40},
+	{0x39C9, 0x00},
+	{0x39CA, 0x80},
+	{0x39CB, 0x00},
+	{0x39CC, 0x80},
+	{0x39CD, 0x00},
+	{0x39CE, 0x80},
+	{0x39CF, 0x00},
+	{0x39D0, 0x80},
+	{0x39D1, 0x00},
+	{0x39D2, 0x80},
+	{0x39D3, 0x80},
+	{0x39D4, 0x80},
+	{0x39E0, 0x01},
+	{0x39E1, 0x00},
+	{0x39E4, 0x40},
+	{0x39E5, 0x01},
+	{0x39E6, 0x01},
+	{0x39E8, 0x00},
+	{0x39E9, 0x01},
+	{0x39EA, 0x00},
+	{0x39EB, 0x00},
+	{0x39EC, 0x01},
+	{0x39ED, 0x00},
+	{0x39EE, 0x01},
+	{0x39F0, 0x03},
+	{0x39F1, 0x04},
+	{0x39F2, 0x0E},
+	{0x39F4, 0x1C},
+	{0x39F5, 0x00},
+	{0x39F6, 0x13},
+	{0x39F7, 0x00},
+	{0x39F8, 0x0D},
+	{0x39F9, 0x00},
+	{0x39FA, 0x07},
+	{0x39FB, 0x00},
+	{0x39FC, 0x38},
+	{0x39FD, 0x00},
+	{0x39FE, 0x1C},
+	{0x39FF, 0x00},
+	{0x3A00, 0x11},
+	{0x3A01, 0x00},
+	{0x3A02, 0x08},
+	{0x3A03, 0x00},
+	{0x3A04, 0x4A},
+	{0x3A05, 0x00},
+	{0x3A06, 0x23},
+	{0x3A07, 0x00},
+	{0x3A08, 0x15},
+	{0x3A09, 0x00},
+	{0x3A0A, 0x09},
+	{0x3A0B, 0x00},
+	{0x3A0C, 0x65},
+	{0x3A0D, 0x00},
+	{0x3A0E, 0x2D},
+	{0x3A0F, 0x00},
+	{0x3A10, 0x1A},
+	{0x3A11, 0x00},
+	{0x3A12, 0x0B},
+	{0x3A13, 0x00},
+	{0x3A14, 0x8D},
+	{0x3A15, 0x00},
+	{0x3A16, 0x3D},
+	{0x3A17, 0x00},
+	{0x3A18, 0x23},
+	{0x3A19, 0x00},
+	{0x3A1A, 0x0E},
+	{0x3A1B, 0x00},
+	{0x3A1C, 0xC5},
+	{0x3A1D, 0x00},
+	{0x3A1E, 0x55},
+	{0x3A1F, 0x00},
+	{0x3A20, 0x30},
+	{0x3A21, 0x00},
+	{0x3A22, 0x13},
+	{0x3A23, 0x00},
+	{0x3A24, 0x16},
+	{0x3A25, 0x01},
+	{0x3A26, 0x76},
+	{0x3A27, 0x00},
+	{0x3A28, 0x42},
+	{0x3A29, 0x00},
+	{0x3A2A, 0x1A},
+	{0x3A2B, 0x00},
+	{0x3A2C, 0x88},
+	{0x3A2D, 0x01},
+	{0x3A2E, 0xA7},
+	{0x3A2F, 0x00},
+	{0x3A30, 0x5D},
+	{0x3A31, 0x00},
+	{0x3A32, 0x24},
+	{0x3A33, 0x00},
+	{0x3A34, 0x2A},
+	{0x3A35, 0x02},
+	{0x3A36, 0xEB},
+	{0x3A37, 0x00},
+	{0x3A38, 0x83},
+	{0x3A39, 0x00},
+	{0x3A3A, 0x32},
+	{0x3A3B, 0x00},
+	{0x3A3C, 0x00},
+	{0x3A3D, 0x01},
+	{0x3A3E, 0x00},
+	{0x3A3F, 0x01},
+	{0x3A40, 0x00},
+	{0x3A41, 0x01},
+	{0x3A42, 0x00},
+	{0x3A43, 0x01},
+	{0x3A44, 0x80},
+	{0x3A45, 0x00},
+	{0x3A46, 0x50},
+	{0x3A47, 0x00},
+	{0x3A48, 0x30},
+	{0x3A49, 0x00},
+	{0x3A4A, 0x20},
+	{0x3A4B, 0x00},
+	{0x3A4C, 0x99},
+	{0x3A4D, 0x00},
+	{0x3A4E, 0x80},
+	{0x3A4F, 0x00},
+	{0x3A50, 0x80},
+	{0x3A51, 0x00},
+	{0x3A52, 0x80},
+	{0x3A53, 0x00},
+	{0x3A54, 0x99},
+	{0x3A55, 0x00},
+	{0x3A56, 0x80},
+	{0x3A57, 0x00},
+	{0x3A58, 0x80},
+	{0x3A59, 0x00},
+	{0x3A5A, 0x80},
+	{0x3A5B, 0x00},
+	{0x3A5C, 0x99},
+	{0x3A5D, 0x00},
+	{0x3A5E, 0x80},
+	{0x3A5F, 0x00},
+	{0x3A60, 0x80},
+	{0x3A61, 0x00},
+	{0x3A62, 0x80},
+	{0x3A63, 0x00},
+	{0x3A64, 0x1C},
+	{0x3A65, 0x00},
+	{0x3A66, 0x13},
+	{0x3A67, 0x00},
+	{0x3A68, 0x0D},
+	{0x3A69, 0x00},
+	{0x3A6A, 0x07},
+	{0x3A6B, 0x00},
+	{0x3A6C, 0x0C},
+	{0x3A6D, 0x00},
+	{0x3A6E, 0x09},
+	{0x3A6F, 0x00},
+	{0x3A70, 0x06},
+	{0x3A71, 0x00},
+	{0x3A72, 0x03},
+	{0x3A73, 0x00},
+	{0x3A74, 0x1F},
+	{0x3A75, 0x00},
+	{0x3A76, 0x1B},
+	{0x3A77, 0x00},
+	{0x3A78, 0x0F},
+	{0x3A79, 0x00},
+	{0x3A7A, 0x08},
+	{0x3A7B, 0x00},
+	{0x3A7C, 0x80},
+	{0x3A7D, 0x00},
+	{0x3A7E, 0x80},
+	{0x3A7F, 0x00},
+	{0x3A80, 0x80},
+	{0x3A81, 0x00},
+	{0x3A82, 0x80},
+	{0x3A83, 0x00},
+	{0x3A84, 0x09},
+	{0x3A85, 0x00},
+	{0x3A86, 0x04},
+	{0x3A87, 0x00},
+	{0x3A88, 0x03},
+	{0x3A89, 0x00},
+	{0x3A8A, 0x01},
+	{0x3A8B, 0x00},
+	{0x3A8C, 0x19},
+	{0x3A8D, 0x01},
+	{0x3A8E, 0xD2},
+	{0x3A8F, 0x00},
+	{0x3A90, 0x8C},
+	{0x3A91, 0x00},
+	{0x3A92, 0x64},
+	{0x3A93, 0x00},
+	{0x3A94, 0xFF},
+	{0x3A95, 0x00},
+	{0x3A96, 0xD2},
+	{0x3A97, 0x00},
+	{0x3A98, 0x8C},
+	{0x3A99, 0x00},
+	{0x3A9A, 0x64},
+	{0x3A9B, 0x00},
+	{0x3A9C, 0x08},
+	{0x3A9D, 0x10},
+	{0x3A9E, 0x80},
+	{0x3A9F, 0x80},
+	{0x3AA0, 0x80},
+	{0x3AA1, 0x04},
+	{0x3AA2, 0x05},
+	{0x3AC0, 0x01},
+	{0x3AC4, 0x81},
+	{0x3AC5, 0x00},
+	{0x3AC6, 0x00},
+	{0x3AC7, 0x00},
+	{0x3AC8, 0x00},
+	{0x3AC9, 0x00},
+	{0x3ACA, 0x00},
+	{0x3ACB, 0x00},
+	{0x3ACC, 0x02},
+	{0x3ACD, 0x00},
+	{0x3ACE, 0x81},
+	{0x3ACF, 0x00},
+	{0x3AD0, 0x00},
+	{0x3AD1, 0x00},
+	{0x3AD2, 0xFD},
+	{0x3AD3, 0x03},
+	{0x3AD4, 0x02},
+	{0x3AD5, 0x00},
+	{0x3AD6, 0x00},
+	{0x3AD7, 0x00},
+	{0x3AD8, 0x81},
+	{0x3AD9, 0x00},
+	{0x3ADA, 0xFD},
+	{0x3ADB, 0x03},
+	{0x3ADC, 0xFF},
+	{0x3ADD, 0x03},
+	{0x3ADE, 0x01},
+	{0x3ADF, 0x00},
+	{0x3AE0, 0x01},
+	{0x3AE1, 0x00},
+	{0x3AE2, 0x7E},
+	{0x3AE3, 0x00},
+	{0x3AF4, 0x00},
+	{0x3AF6, 0x40},
+	{0x3AF7, 0x1E},
+	{0x3AF8, 0x01},
+	{0x3AFA, 0x63},
+	{0x3AFB, 0x09},
+	{0x3AFC, 0x11},
+	{0x3AFD, 0x09},
+	{0x3AFE, 0x00},
+	{0x3AFF, 0x00},
+	{0x3B00, 0x00},
+	{0x3B01, 0x00},
+	{0x3B02, 0x84},
+	{0x3B03, 0x06},
+	{0x3B04, 0x30},
+	{0x3B05, 0x06},
+	{0x3B06, 0x00},
+	{0x3B07, 0x00},
+	{0x3B08, 0x00},
+	{0x3B09, 0x00},
+	{0x3B0A, 0x00},
+	{0x3B0B, 0x00},
+	{0x3B0C, 0x00},
+	{0x3B0D, 0x00},
+	{0x3B0E, 0x00},
+	{0x3B0F, 0x00},
+	{0x3B10, 0x00},
+	{0x3B11, 0x00},
+	{0x3B12, 0x00},
+	{0x3B13, 0x00},
+	{0x3B14, 0x00},
+	{0x3B15, 0x00},
+	{0x3B16, 0x00},
+	{0x3B17, 0x00},
+	{0x3B18, 0x00},
+	{0x3B19, 0x00},
+	{0x3B1A, 0x00},
+	{0x3B1B, 0x00},
+	{0x3B1C, 0x00},
+	{0x3B1D, 0x00},
+	{0x3B1E, 0x00},
+	{0x3B1F, 0x00},
+	{0x3B20, 0x00},
+	{0x3B21, 0x00},
+	{0x3B22, 0x00},
+	{0x3B23, 0x00},
+	{0x3B24, 0x00},
+	{0x3B25, 0x00},
+	{0x3B26, 0x00},
+	{0x3B27, 0x00},
+	{0x3B28, 0x00},
+	{0x3B29, 0x00},
+	{0x3B2A, 0x00},
+	{0x3B2C, 0x00},
+	{0x3B2E, 0x00},
+	{0x3B30, 0x00},
+	{0x3B32, 0x0C},
+	{0x4000, 0xD1},
+	{0x4001, 0xC0},
+	{0x4002, 0xC0},
+	{0x4003, 0xB8},
+	{0x4004, 0xC0},
+	{0x4005, 0xB8},
+	{0x4006, 0xB9},
+	{0x4007, 0xB7},
+	{0x4008, 0xB0},
+	{0x4009, 0xAB},
+	{0x400A, 0xAC},
+	{0x400B, 0xAB},
+	{0x400C, 0xA8},
+	{0x400D, 0xA6},
+	{0x400E, 0xA6},
+	{0x400F, 0xA5},
+	{0x4010, 0xA2},
+	{0x4011, 0xA0},
+	{0x4012, 0xA0},
+	{0x4013, 0x9F},
+	{0x4014, 0xA4},
+	{0x4015, 0xA2},
+	{0x4016, 0xA2},
+	{0x4017, 0x9C},
+	{0x4018, 0xA8},
+	{0x4019, 0xA6},
+	{0x401A, 0xA8},
+	{0x401B, 0xAA},
+	{0x401C, 0xB0},
+	{0x401D, 0xAE},
+	{0x401E, 0xAE},
+	{0x401F, 0xAE},
+	{0x4020, 0xBA},
+	{0x4021, 0xAE},
+	{0x4022, 0xAF},
+	{0x4023, 0xAE},
+	{0x4024, 0xC6},
+	{0x4025, 0xBD},
+	{0x4026, 0xBD},
+	{0x4027, 0xBA},
+	{0x4028, 0xB0},
+	{0x4029, 0xA9},
+	{0x402A, 0xAA},
+	{0x402B, 0xA8},
+	{0x402C, 0x9F},
+	{0x402D, 0x9C},
+	{0x402E, 0x9C},
+	{0x402F, 0x9B},
+	{0x4030, 0x93},
+	{0x4031, 0x91},
+	{0x4032, 0x92},
+	{0x4033, 0x91},
+	{0x4034, 0x8D},
+	{0x4035, 0x8C},
+	{0x4036, 0x8C},
+	{0x4037, 0x8C},
+	{0x4038, 0x8F},
+	{0x4039, 0x8E},
+	{0x403A, 0x8E},
+	{0x403B, 0x8E},
+	{0x403C, 0x98},
+	{0x403D, 0x96},
+	{0x403E, 0x96},
+	{0x403F, 0x95},
+	{0x4040, 0xA4},
+	{0x4041, 0xA0},
+	{0x4042, 0xA0},
+	{0x4043, 0x9E},
+	{0x4044, 0xB3},
+	{0x4045, 0xAE},
+	{0x4046, 0xAF},
+	{0x4047, 0xAB},
+	{0x4048, 0xC2},
+	{0x4049, 0xB7},
+	{0x404A, 0xB8},
+	{0x404B, 0xB5},
+	{0x404C, 0xAB},
+	{0x404D, 0xA4},
+	{0x404E, 0xA5},
+	{0x404F, 0xA3},
+	{0x4050, 0x99},
+	{0x4051, 0x96},
+	{0x4052, 0x96},
+	{0x4053, 0x96},
+	{0x4054, 0x8B},
+	{0x4055, 0x8A},
+	{0x4056, 0x8A},
+	{0x4057, 0x8A},
+	{0x4058, 0x82},
+	{0x4059, 0x81},
+	{0x405A, 0x81},
+	{0x405B, 0x81},
+	{0x405C, 0x85},
+	{0x405D, 0x86},
+	{0x405E, 0x85},
+	{0x405F, 0x85},
+	{0x4060, 0x90},
+	{0x4061, 0x90},
+	{0x4062, 0x8F},
+	{0x4063, 0x8F},
+	{0x4064, 0x9D},
+	{0x4065, 0x9B},
+	{0x4066, 0x9B},
+	{0x4067, 0x9A},
+	{0x4068, 0xAF},
+	{0x4069, 0xAA},
+	{0x406A, 0xAC},
+	{0x406B, 0xAA},
+	{0x406C, 0xC2},
+	{0x406D, 0xB7},
+	{0x406E, 0xB8},
+	{0x406F, 0xB5},
+	{0x4070, 0xAB},
+	{0x4071, 0xA4},
+	{0x4072, 0xA4},
+	{0x4073, 0xA3},
+	{0x4074, 0x99},
+	{0x4075, 0x96},
+	{0x4076, 0x96},
+	{0x4077, 0x96},
+	{0x4078, 0x8B},
+	{0x4079, 0x8A},
+	{0x407A, 0x8A},
+	{0x407B, 0x8A},
+	{0x407C, 0x82},
+	{0x407D, 0x82},
+	{0x407E, 0x82},
+	{0x407F, 0x82},
+	{0x4080, 0x85},
+	{0x4081, 0x86},
+	{0x4082, 0x86},
+	{0x4083, 0x86},
+	{0x4084, 0x90},
+	{0x4085, 0x90},
+	{0x4086, 0x8F},
+	{0x4087, 0x8F},
+	{0x4088, 0x9D},
+	{0x4089, 0x9B},
+	{0x408A, 0x9B},
+	{0x408B, 0x99},
+	{0x408C, 0xAE},
+	{0x408D, 0xAA},
+	{0x408E, 0xAA},
+	{0x408F, 0xA7},
+	{0x4090, 0xC7},
+	{0x4091, 0xBA},
+	{0x4092, 0xBC},
+	{0x4093, 0xB9},
+	{0x4094, 0xB1},
+	{0x4095, 0xA8},
+	{0x4096, 0xA8},
+	{0x4097, 0xA7},
+	{0x4098, 0x9F},
+	{0x4099, 0x9B},
+	{0x409A, 0x9B},
+	{0x409B, 0x9B},
+	{0x409C, 0x93},
+	{0x409D, 0x91},
+	{0x409E, 0x91},
+	{0x409F, 0x91},
+	{0x40A0, 0x8D},
+	{0x40A1, 0x8C},
+	{0x40A2, 0x8C},
+	{0x40A3, 0x8C},
+	{0x40A4, 0x8E},
+	{0x40A5, 0x8E},
+	{0x40A6, 0x8D},
+	{0x40A7, 0x8D},
+	{0x40A8, 0x96},
+	{0x40A9, 0x95},
+	{0x40AA, 0x95},
+	{0x40AB, 0x94},
+	{0x40AC, 0xA2},
+	{0x40AD, 0x9F},
+	{0x40AE, 0x9F},
+	{0x40AF, 0x9D},
+	{0x40B0, 0xB1},
+	{0x40B1, 0xAC},
+	{0x40B2, 0xAB},
+	{0x40B3, 0xAA},
+	{0x40B4, 0xD3},
+	{0x40B5, 0xBC},
+	{0x40B6, 0xBD},
+	{0x40B7, 0xBC},
+	{0x40B8, 0xC1},
+	{0x40B9, 0xB7},
+	{0x40BA, 0xB7},
+	{0x40BB, 0xB5},
+	{0x40BC, 0xB0},
+	{0x40BD, 0xAA},
+	{0x40BE, 0xAA},
+	{0x40BF, 0xAA},
+	{0x40C0, 0xA8},
+	{0x40C1, 0xA4},
+	{0x40C2, 0xA4},
+	{0x40C3, 0xA4},
+	{0x40C4, 0xA2},
+	{0x40C5, 0x9F},
+	{0x40C6, 0x9F},
+	{0x40C7, 0x9F},
+	{0x40C8, 0xA3},
+	{0x40C9, 0xA0},
+	{0x40CA, 0xA0},
+	{0x40CB, 0xA0},
+	{0x40CC, 0xA6},
+	{0x40CD, 0xA3},
+	{0x40CE, 0xA3},
+	{0x40CF, 0xA2},
+	{0x40D0, 0xAF},
+	{0x40D1, 0xAB},
+	{0x40D2, 0xAA},
+	{0x40D3, 0xA8},
+	{0x40D4, 0xBA},
+	{0x40D5, 0xAE},
+	{0x40D6, 0xAE},
+	{0x40D7, 0xAB},
+	{0x4100, 0xBD},
+	{0x4101, 0xBA},
+	{0x4102, 0xBD},
+	{0x4103, 0xB7},
+	{0x4104, 0xB7},
+	{0x4105, 0xB7},
+	{0x4106, 0xB8},
+	{0x4107, 0xB5},
+	{0x4108, 0xAB},
+	{0x4109, 0xAA},
+	{0x410A, 0xAC},
+	{0x410B, 0xAB},
+	{0x410C, 0xA4},
+	{0x410D, 0xA5},
+	{0x410E, 0xA5},
+	{0x410F, 0xA4},
+	{0x4110, 0x9F},
+	{0x4111, 0xA0},
+	{0x4112, 0xA0},
+	{0x4113, 0x9F},
+	{0x4114, 0xA0},
+	{0x4115, 0xA0},
+	{0x4116, 0xA0},
+	{0x4117, 0x9F},
+	{0x4118, 0xA1},
+	{0x4119, 0xA1},
+	{0x411A, 0xA1},
+	{0x411B, 0xA0},
+	{0x411C, 0xA7},
+	{0x411D, 0xA6},
+	{0x411E, 0xA6},
+	{0x411F, 0xA6},
+	{0x4120, 0xA7},
+	{0x4121, 0xA6},
+	{0x4122, 0xA6},
+	{0x4123, 0xA3},
+	{0x4124, 0xB9},
+	{0x4125, 0xB9},
+	{0x4126, 0xBA},
+	{0x4127, 0xB8},
+	{0x4128, 0xA6},
+	{0x4129, 0xA7},
+	{0x412A, 0xA7},
+	{0x412B, 0xA6},
+	{0x412C, 0x9B},
+	{0x412D, 0x9B},
+	{0x412E, 0x9B},
+	{0x412F, 0x9B},
+	{0x4130, 0x91},
+	{0x4131, 0x92},
+	{0x4132, 0x92},
+	{0x4133, 0x91},
+	{0x4134, 0x8C},
+	{0x4135, 0x8C},
+	{0x4136, 0x8C},
+	{0x4137, 0x8C},
+	{0x4138, 0x8D},
+	{0x4139, 0x8D},
+	{0x413A, 0x8D},
+	{0x413B, 0x8D},
+	{0x413C, 0x93},
+	{0x413D, 0x93},
+	{0x413E, 0x93},
+	{0x413F, 0x92},
+	{0x4140, 0x9A},
+	{0x4141, 0x9A},
+	{0x4142, 0x9A},
+	{0x4143, 0x99},
+	{0x4144, 0xA7},
+	{0x4145, 0xA5},
+	{0x4146, 0xA6},
+	{0x4147, 0xA6},
+	{0x4148, 0xB8},
+	{0x4149, 0xB4},
+	{0x414A, 0xB4},
+	{0x414B, 0xB3},
+	{0x414C, 0xA3},
+	{0x414D, 0xA2},
+	{0x414E, 0xA3},
+	{0x414F, 0xA2},
+	{0x4150, 0x96},
+	{0x4151, 0x96},
+	{0x4152, 0x96},
+	{0x4153, 0x96},
+	{0x4154, 0x8A},
+	{0x4155, 0x8A},
+	{0x4156, 0x8A},
+	{0x4157, 0x8A},
+	{0x4158, 0x82},
+	{0x4159, 0x82},
+	{0x415A, 0x82},
+	{0x415B, 0x82},
+	{0x415C, 0x84},
+	{0x415D, 0x85},
+	{0x415E, 0x84},
+	{0x415F, 0x84},
+	{0x4160, 0x8D},
+	{0x4161, 0x8D},
+	{0x4162, 0x8D},
+	{0x4163, 0x8D},
+	{0x4164, 0x96},
+	{0x4165, 0x96},
+	{0x4166, 0x96},
+	{0x4167, 0x95},
+	{0x4168, 0xA5},
+	{0x4169, 0xA2},
+	{0x416A, 0xA3},
+	{0x416B, 0xA2},
+	{0x416C, 0xB7},
+	{0x416D, 0xB3},
+	{0x416E, 0xB5},
+	{0x416F, 0xB4},
+	{0x4170, 0xA4},
+	{0x4171, 0xA2},
+	{0x4172, 0xA3},
+	{0x4173, 0xA2},
+	{0x4174, 0x97},
+	{0x4175, 0x96},
+	{0x4176, 0x96},
+	{0x4177, 0x96},
+	{0x4178, 0x8B},
+	{0x4179, 0x8A},
+	{0x417A, 0x8A},
+	{0x417B, 0x8A},
+	{0x417C, 0x81},
+	{0x417D, 0x81},
+	{0x417E, 0x81},
+	{0x417F, 0x81},
+	{0x4180, 0x84},
+	{0x4181, 0x84},
+	{0x4182, 0x84},
+	{0x4183, 0x84},
+	{0x4184, 0x8C},
+	{0x4185, 0x8D},
+	{0x4186, 0x8D},
+	{0x4187, 0x8D},
+	{0x4188, 0x95},
+	{0x4189, 0x96},
+	{0x418A, 0x96},
+	{0x418B, 0x95},
+	{0x418C, 0xA1},
+	{0x418D, 0xA1},
+	{0x418E, 0xA1},
+	{0x418F, 0xA0},
+	{0x4190, 0xBC},
+	{0x4191, 0xB8},
+	{0x4192, 0xB8},
+	{0x4193, 0xB9},
+	{0x4194, 0xA8},
+	{0x4195, 0xA5},
+	{0x4196, 0xA6},
+	{0x4197, 0xA5},
+	{0x4198, 0x9C},
+	{0x4199, 0x9A},
+	{0x419A, 0x9A},
+	{0x419B, 0x9A},
+	{0x419C, 0x91},
+	{0x419D, 0x91},
+	{0x419E, 0x91},
+	{0x419F, 0x91},
+	{0x41A0, 0x8B},
+	{0x41A1, 0x8B},
+	{0x41A2, 0x8B},
+	{0x41A3, 0x8B},
+	{0x41A4, 0x8C},
+	{0x41A5, 0x8C},
+	{0x41A6, 0x8C},
+	{0x41A7, 0x8C},
+	{0x41A8, 0x91},
+	{0x41A9, 0x92},
+	{0x41AA, 0x91},
+	{0x41AB, 0x91},
+	{0x41AC, 0x98},
+	{0x41AD, 0x99},
+	{0x41AE, 0x99},
+	{0x41AF, 0x98},
+	{0x41B0, 0xA3},
+	{0x41B1, 0xA3},
+	{0x41B2, 0xA3},
+	{0x41B3, 0xA2},
+	{0x41B4, 0xC1},
+	{0x41B5, 0xB8},
+	{0x41B6, 0xB9},
+	{0x41B7, 0xBA},
+	{0x41B8, 0xB8},
+	{0x41B9, 0xB4},
+	{0x41BA, 0xB4},
+	{0x41BB, 0xB4},
+	{0x41BC, 0xAA},
+	{0x41BD, 0xA7},
+	{0x41BE, 0xA7},
+	{0x41BF, 0xA8},
+	{0x41C0, 0xA4},
+	{0x41C1, 0xA2},
+	{0x41C2, 0xA2},
+	{0x41C3, 0xA3},
+	{0x41C4, 0x9E},
+	{0x41C5, 0x9D},
+	{0x41C6, 0x9D},
+	{0x41C7, 0x9D},
+	{0x41C8, 0x9E},
+	{0x41C9, 0x9D},
+	{0x41CA, 0x9D},
+	{0x41CB, 0x9D},
+	{0x41CC, 0x9E},
+	{0x41CD, 0x9E},
+	{0x41CE, 0x9E},
+	{0x41CF, 0x9E},
+	{0x41D0, 0xA3},
+	{0x41D1, 0xA3},
+	{0x41D2, 0xA2},
+	{0x41D3, 0xA1},
+	{0x41D4, 0xA7},
+	{0x41D5, 0xA7},
+	{0x41D6, 0xA7},
+	{0x41D7, 0xA3},
+	{0x4200, 0xCE},
+	{0x4201, 0xC0},
+	{0x4202, 0xC1},
+	{0x4203, 0xB9},
+	{0x4204, 0xC3},
+	{0x4205, 0xB9},
+	{0x4206, 0xBC},
+	{0x4207, 0xBD},
+	{0x4208, 0xB3},
+	{0x4209, 0xAE},
+	{0x420A, 0xAF},
+	{0x420B, 0xAE},
+	{0x420C, 0xAA},
+	{0x420D, 0xA8},
+	{0x420E, 0xA8},
+	{0x420F, 0xA6},
+	{0x4210, 0xA4},
+	{0x4211, 0xA2},
+	{0x4212, 0xA2},
+	{0x4213, 0xA0},
+	{0x4214, 0xA4},
+	{0x4215, 0xA3},
+	{0x4216, 0xA2},
+	{0x4217, 0xA0},
+	{0x4218, 0xA7},
+	{0x4219, 0xA5},
+	{0x421A, 0xA3},
+	{0x421B, 0xA1},
+	{0x421C, 0xB0},
+	{0x421D, 0xA8},
+	{0x421E, 0xA8},
+	{0x421F, 0xA6},
+	{0x4220, 0xB4},
+	{0x4221, 0xAA},
+	{0x4222, 0xA5},
+	{0x4223, 0xA3},
+	{0x4224, 0xC7},
+	{0x4225, 0xBC},
+	{0x4226, 0xBE},
+	{0x4227, 0xBC},
+	{0x4228, 0xB0},
+	{0x4229, 0xA9},
+	{0x422A, 0xA9},
+	{0x422B, 0xA8},
+	{0x422C, 0xA0},
+	{0x422D, 0x9D},
+	{0x422E, 0x9D},
+	{0x422F, 0x9C},
+	{0x4230, 0x94},
+	{0x4231, 0x93},
+	{0x4232, 0x93},
+	{0x4233, 0x92},
+	{0x4234, 0x8E},
+	{0x4235, 0x8D},
+	{0x4236, 0x8D},
+	{0x4237, 0x8C},
+	{0x4238, 0x8F},
+	{0x4239, 0x8E},
+	{0x423A, 0x8E},
+	{0x423B, 0x8D},
+	{0x423C, 0x96},
+	{0x423D, 0x94},
+	{0x423E, 0x94},
+	{0x423F, 0x92},
+	{0x4240, 0xA1},
+	{0x4241, 0x9C},
+	{0x4242, 0x9C},
+	{0x4243, 0x99},
+	{0x4244, 0xB0},
+	{0x4245, 0xA8},
+	{0x4246, 0xAB},
+	{0x4247, 0xA7},
+	{0x4248, 0xC3},
+	{0x4249, 0xB7},
+	{0x424A, 0xB7},
+	{0x424B, 0xBC},
+	{0x424C, 0xAB},
+	{0x424D, 0xA4},
+	{0x424E, 0xA5},
+	{0x424F, 0xA5},
+	{0x4250, 0x9A},
+	{0x4251, 0x97},
+	{0x4252, 0x97},
+	{0x4253, 0x98},
+	{0x4254, 0x8C},
+	{0x4255, 0x8B},
+	{0x4256, 0x8B},
+	{0x4257, 0x8B},
+	{0x4258, 0x82},
+	{0x4259, 0x82},
+	{0x425A, 0x82},
+	{0x425B, 0x82},
+	{0x425C, 0x85},
+	{0x425D, 0x85},
+	{0x425E, 0x85},
+	{0x425F, 0x84},
+	{0x4260, 0x8F},
+	{0x4261, 0x8E},
+	{0x4262, 0x8E},
+	{0x4263, 0x8D},
+	{0x4264, 0x9B},
+	{0x4265, 0x98},
+	{0x4266, 0x98},
+	{0x4267, 0x95},
+	{0x4268, 0xAE},
+	{0x4269, 0xA5},
+	{0x426A, 0xA7},
+	{0x426B, 0xA2},
+	{0x426C, 0xC2},
+	{0x426D, 0xB7},
+	{0x426E, 0xB8},
+	{0x426F, 0xB9},
+	{0x4270, 0xAA},
+	{0x4271, 0xA4},
+	{0x4272, 0xA4},
+	{0x4273, 0xA5},
+	{0x4274, 0x99},
+	{0x4275, 0x96},
+	{0x4276, 0x97},
+	{0x4277, 0x98},
+	{0x4278, 0x8B},
+	{0x4279, 0x8A},
+	{0x427A, 0x8A},
+	{0x427B, 0x8B},
+	{0x427C, 0x81},
+	{0x427D, 0x81},
+	{0x427E, 0x81},
+	{0x427F, 0x82},
+	{0x4280, 0x84},
+	{0x4281, 0x84},
+	{0x4282, 0x84},
+	{0x4283, 0x84},
+	{0x4284, 0x8E},
+	{0x4285, 0x8E},
+	{0x4286, 0x8D},
+	{0x4287, 0x8C},
+	{0x4288, 0x9A},
+	{0x4289, 0x97},
+	{0x428A, 0x97},
+	{0x428B, 0x95},
+	{0x428C, 0xAA},
+	{0x428D, 0xA3},
+	{0x428E, 0xA3},
+	{0x428F, 0xA2},
+	{0x4290, 0xC7},
+	{0x4291, 0xBA},
+	{0x4292, 0xC0},
+	{0x4293, 0xC3},
+	{0x4294, 0xB0},
+	{0x4295, 0xA7},
+	{0x4296, 0xA7},
+	{0x4297, 0xA9},
+	{0x4298, 0x9F},
+	{0x4299, 0x9B},
+	{0x429A, 0x9B},
+	{0x429B, 0x9D},
+	{0x429C, 0x93},
+	{0x429D, 0x91},
+	{0x429E, 0x91},
+	{0x429F, 0x92},
+	{0x42A0, 0x8C},
+	{0x42A1, 0x8B},
+	{0x42A2, 0x8B},
+	{0x42A3, 0x8C},
+	{0x42A4, 0x8D},
+	{0x42A5, 0x8C},
+	{0x42A6, 0x8C},
+	{0x42A7, 0x8C},
+	{0x42A8, 0x94},
+	{0x42A9, 0x93},
+	{0x42AA, 0x92},
+	{0x42AB, 0x91},
+	{0x42AC, 0x9E},
+	{0x42AD, 0x9B},
+	{0x42AE, 0x9B},
+	{0x42AF, 0x98},
+	{0x42B0, 0xAC},
+	{0x42B1, 0xA6},
+	{0x42B2, 0xA6},
+	{0x42B3, 0xA2},
+	{0x42B4, 0xCE},
+	{0x42B5, 0xBA},
+	{0x42B6, 0xBC},
+	{0x42B7, 0xB7},
+	{0x42B8, 0xC5},
+	{0x42B9, 0xB5},
+	{0x42BA, 0xBA},
+	{0x42BB, 0xC0},
+	{0x42BC, 0xB1},
+	{0x42BD, 0xA8},
+	{0x42BE, 0xAE},
+	{0x42BF, 0xAF},
+	{0x42C0, 0xA7},
+	{0x42C1, 0xA3},
+	{0x42C2, 0xA3},
+	{0x42C3, 0xA5},
+	{0x42C4, 0xA0},
+	{0x42C5, 0x9D},
+	{0x42C6, 0x9D},
+	{0x42C7, 0x9F},
+	{0x42C8, 0xA0},
+	{0x42C9, 0x9E},
+	{0x42CA, 0x9E},
+	{0x42CB, 0x9F},
+	{0x42CC, 0xA2},
+	{0x42CD, 0xA0},
+	{0x42CE, 0xA0},
+	{0x42CF, 0xA0},
+	{0x42D0, 0xA8},
+	{0x42D1, 0xA5},
+	{0x42D2, 0xA5},
+	{0x42D3, 0xA2},
+	{0x42D4, 0xB3},
+	{0x42D5, 0xAA},
+	{0x42D6, 0xAB},
+	{0x42D7, 0xA3},
+	{0x42D8, 0x00},
+	{0x42D9, 0x00},
+	{0x4300, 0xA2},
+	{0x4301, 0xAE},
+	{0x4302, 0xAD},
+	{0x4303, 0xB5},
+	{0x4304, 0x95},
+	{0x4305, 0x9A},
+	{0x4306, 0x98},
+	{0x4307, 0x9B},
+	{0x4308, 0x8D},
+	{0x4309, 0x90},
+	{0x430A, 0x8F},
+	{0x430B, 0x91},
+	{0x430C, 0x86},
+	{0x430D, 0x88},
+	{0x430E, 0x87},
+	{0x430F, 0x89},
+	{0x4310, 0x86},
+	{0x4311, 0x87},
+	{0x4312, 0x86},
+	{0x4313, 0x88},
+	{0x4314, 0x89},
+	{0x4315, 0x88},
+	{0x4316, 0x88},
+	{0x4317, 0x8E},
+	{0x4318, 0x90},
+	{0x4319, 0x8F},
+	{0x431A, 0x8C},
+	{0x431B, 0x8C},
+	{0x431C, 0x9C},
+	{0x431D, 0x99},
+	{0x431E, 0x98},
+	{0x431F, 0x99},
+	{0x4320, 0xAB},
+	{0x4321, 0xB0},
+	{0x4322, 0xAD},
+	{0x4323, 0xAF},
+	{0x4324, 0x9B},
+	{0x4325, 0x9F},
+	{0x4326, 0x9E},
+	{0x4327, 0xA1},
+	{0x4328, 0x8E},
+	{0x4329, 0x91},
+	{0x432A, 0x90},
+	{0x432B, 0x93},
+	{0x432C, 0x86},
+	{0x432D, 0x88},
+	{0x432E, 0x87},
+	{0x432F, 0x89},
+	{0x4330, 0x82},
+	{0x4331, 0x84},
+	{0x4332, 0x83},
+	{0x4333, 0x84},
+	{0x4334, 0x82},
+	{0x4335, 0x82},
+	{0x4336, 0x82},
+	{0x4337, 0x83},
+	{0x4338, 0x85},
+	{0x4339, 0x84},
+	{0x433A, 0x84},
+	{0x433B, 0x85},
+	{0x433C, 0x8A},
+	{0x433D, 0x89},
+	{0x433E, 0x88},
+	{0x433F, 0x89},
+	{0x4340, 0x93},
+	{0x4341, 0x91},
+	{0x4342, 0x91},
+	{0x4343, 0x93},
+	{0x4344, 0xA0},
+	{0x4345, 0x9E},
+	{0x4346, 0x9D},
+	{0x4347, 0xA1},
+	{0x4348, 0x95},
+	{0x4349, 0x9B},
+	{0x434A, 0x9A},
+	{0x434B, 0x9C},
+	{0x434C, 0x8A},
+	{0x434D, 0x8D},
+	{0x434E, 0x8C},
+	{0x434F, 0x8D},
+	{0x4350, 0x83},
+	{0x4351, 0x85},
+	{0x4352, 0x84},
+	{0x4353, 0x85},
+	{0x4354, 0x80},
+	{0x4355, 0x81},
+	{0x4356, 0x81},
+	{0x4357, 0x81},
+	{0x4358, 0x80},
+	{0x4359, 0x80},
+	{0x435A, 0x80},
+	{0x435B, 0x80},
+	{0x435C, 0x82},
+	{0x435D, 0x81},
+	{0x435E, 0x81},
+	{0x435F, 0x81},
+	{0x4360, 0x85},
+	{0x4361, 0x84},
+	{0x4362, 0x84},
+	{0x4363, 0x85},
+	{0x4364, 0x8D},
+	{0x4365, 0x8B},
+	{0x4366, 0x8B},
+	{0x4367, 0x8D},
+	{0x4368, 0x98},
+	{0x4369, 0x98},
+	{0x436A, 0x95},
+	{0x436B, 0x98},
+	{0x436C, 0x95},
+	{0x436D, 0x9A},
+	{0x436E, 0x99},
+	{0x436F, 0x9A},
+	{0x4370, 0x8A},
+	{0x4371, 0x8D},
+	{0x4372, 0x8C},
+	{0x4373, 0x8C},
+	{0x4374, 0x83},
+	{0x4375, 0x85},
+	{0x4376, 0x84},
+	{0x4377, 0x84},
+	{0x4378, 0x80},
+	{0x4379, 0x80},
+	{0x437A, 0x80},
+	{0x437B, 0x80},
+	{0x437C, 0x7F},
+	{0x437D, 0x7F},
+	{0x437E, 0x7F},
+	{0x437F, 0x7F},
+	{0x4380, 0x81},
+	{0x4381, 0x80},
+	{0x4382, 0x80},
+	{0x4383, 0x81},
+	{0x4384, 0x84},
+	{0x4385, 0x83},
+	{0x4386, 0x83},
+	{0x4387, 0x84},
+	{0x4388, 0x8B},
+	{0x4389, 0x8A},
+	{0x438A, 0x8A},
+	{0x438B, 0x8C},
+	{0x438C, 0x97},
+	{0x438D, 0x96},
+	{0x438E, 0x96},
+	{0x438F, 0x99},
+	{0x4390, 0x99},
+	{0x4391, 0x9F},
+	{0x4392, 0x9E},
+	{0x4393, 0x9D},
+	{0x4394, 0x8D},
+	{0x4395, 0x90},
+	{0x4396, 0x90},
+	{0x4397, 0x8F},
+	{0x4398, 0x85},
+	{0x4399, 0x87},
+	{0x439A, 0x87},
+	{0x439B, 0x86},
+	{0x439C, 0x81},
+	{0x439D, 0x83},
+	{0x439E, 0x82},
+	{0x439F, 0x82},
+	{0x43A0, 0x80},
+	{0x43A1, 0x81},
+	{0x43A2, 0x81},
+	{0x43A3, 0x81},
+	{0x43A4, 0x82},
+	{0x43A5, 0x82},
+	{0x43A6, 0x82},
+	{0x43A7, 0x82},
+	{0x43A8, 0x86},
+	{0x43A9, 0x85},
+	{0x43AA, 0x85},
+	{0x43AB, 0x87},
+	{0x43AC, 0x8D},
+	{0x43AD, 0x8D},
+	{0x43AE, 0x8D},
+	{0x43AF, 0x90},
+	{0x43B0, 0x9A},
+	{0x43B1, 0x9A},
+	{0x43B2, 0x9B},
+	{0x43B3, 0x9D},
+	{0x43B4, 0xA0},
+	{0x43B5, 0xAD},
+	{0x43B6, 0xAC},
+	{0x43B7, 0xAA},
+	{0x43B8, 0x93},
+	{0x43B9, 0x97},
+	{0x43BA, 0x97},
+	{0x43BB, 0x96},
+	{0x43BC, 0x8B},
+	{0x43BD, 0x8E},
+	{0x43BE, 0x8E},
+	{0x43BF, 0x8C},
+	{0x43C0, 0x83},
+	{0x43C1, 0x85},
+	{0x43C2, 0x85},
+	{0x43C3, 0x84},
+	{0x43C4, 0x82},
+	{0x43C5, 0x84},
+	{0x43C6, 0x83},
+	{0x43C7, 0x83},
+	{0x43C8, 0x83},
+	{0x43C9, 0x84},
+	{0x43CA, 0x84},
+	{0x43CB, 0x85},
+	{0x43CC, 0x8A},
+	{0x43CD, 0x8A},
+	{0x43CE, 0x8A},
+	{0x43CF, 0x8C},
+	{0x43D0, 0x92},
+	{0x43D1, 0x93},
+	{0x43D2, 0x93},
+	{0x43D3, 0x96},
+	{0x43D4, 0x9F},
+	{0x43D5, 0xA6},
+	{0x43D6, 0xA5},
+	{0x43D7, 0xAA},
+	{0x4400, 0xA1},
+	{0x4401, 0xAB},
+	{0x4402, 0xA7},
+	{0x4403, 0xB0},
+	{0x4404, 0x91},
+	{0x4405, 0x96},
+	{0x4406, 0x94},
+	{0x4407, 0x99},
+	{0x4408, 0x8A},
+	{0x4409, 0x8E},
+	{0x440A, 0x8C},
+	{0x440B, 0x8F},
+	{0x440C, 0x85},
+	{0x440D, 0x86},
+	{0x440E, 0x86},
+	{0x440F, 0x88},
+	{0x4410, 0x85},
+	{0x4411, 0x86},
+	{0x4412, 0x85},
+	{0x4413, 0x87},
+	{0x4414, 0x88},
+	{0x4415, 0x87},
+	{0x4416, 0x87},
+	{0x4417, 0x89},
+	{0x4418, 0x91},
+	{0x4419, 0x8F},
+	{0x441A, 0x8F},
+	{0x441B, 0x90},
+	{0x441C, 0x9C},
+	{0x441D, 0x9B},
+	{0x441E, 0x9A},
+	{0x441F, 0x9A},
+	{0x4420, 0xB3},
+	{0x4421, 0xB1},
+	{0x4422, 0xB0},
+	{0x4423, 0xB2},
+	{0x4424, 0x96},
+	{0x4425, 0x9C},
+	{0x4426, 0x9A},
+	{0x4427, 0x9E},
+	{0x4428, 0x8B},
+	{0x4429, 0x8F},
+	{0x442A, 0x8E},
+	{0x442B, 0x91},
+	{0x442C, 0x84},
+	{0x442D, 0x87},
+	{0x442E, 0x86},
+	{0x442F, 0x88},
+	{0x4430, 0x82},
+	{0x4431, 0x83},
+	{0x4432, 0x82},
+	{0x4433, 0x84},
+	{0x4434, 0x82},
+	{0x4435, 0x82},
+	{0x4436, 0x82},
+	{0x4437, 0x83},
+	{0x4438, 0x84},
+	{0x4439, 0x84},
+	{0x443A, 0x84},
+	{0x443B, 0x84},
+	{0x443C, 0x8B},
+	{0x443D, 0x89},
+	{0x443E, 0x89},
+	{0x443F, 0x89},
+	{0x4440, 0x95},
+	{0x4441, 0x93},
+	{0x4442, 0x93},
+	{0x4443, 0x93},
+	{0x4444, 0xA2},
+	{0x4445, 0xA2},
+	{0x4446, 0xA1},
+	{0x4447, 0xA0},
+	{0x4448, 0x8F},
+	{0x4449, 0x97},
+	{0x444A, 0x97},
+	{0x444B, 0x98},
+	{0x444C, 0x87},
+	{0x444D, 0x8B},
+	{0x444E, 0x8A},
+	{0x444F, 0x8B},
+	{0x4450, 0x81},
+	{0x4451, 0x83},
+	{0x4452, 0x83},
+	{0x4453, 0x84},
+	{0x4454, 0x7F},
+	{0x4455, 0x80},
+	{0x4456, 0x80},
+	{0x4457, 0x81},
+	{0x4458, 0x80},
+	{0x4459, 0x80},
+	{0x445A, 0x80},
+	{0x445B, 0x80},
+	{0x445C, 0x82},
+	{0x445D, 0x81},
+	{0x445E, 0x81},
+	{0x445F, 0x81},
+	{0x4460, 0x87},
+	{0x4461, 0x85},
+	{0x4462, 0x85},
+	{0x4463, 0x86},
+	{0x4464, 0x90},
+	{0x4465, 0x8E},
+	{0x4466, 0x8E},
+	{0x4467, 0x8E},
+	{0x4468, 0x9B},
+	{0x4469, 0x9C},
+	{0x446A, 0x9A},
+	{0x446B, 0x9A},
+	{0x446C, 0x91},
+	{0x446D, 0x97},
+	{0x446E, 0x95},
+	{0x446F, 0x95},
+	{0x4470, 0x87},
+	{0x4471, 0x8A},
+	{0x4472, 0x8A},
+	{0x4473, 0x89},
+	{0x4474, 0x81},
+	{0x4475, 0x83},
+	{0x4476, 0x83},
+	{0x4477, 0x83},
+	{0x4478, 0x7F},
+	{0x4479, 0x80},
+	{0x447A, 0x80},
+	{0x447B, 0x80},
+	{0x447C, 0x80},
+	{0x447D, 0x80},
+	{0x447E, 0x80},
+	{0x447F, 0x7F},
+	{0x4480, 0x81},
+	{0x4481, 0x81},
+	{0x4482, 0x81},
+	{0x4483, 0x81},
+	{0x4484, 0x85},
+	{0x4485, 0x85},
+	{0x4486, 0x85},
+	{0x4487, 0x85},
+	{0x4488, 0x8E},
+	{0x4489, 0x8D},
+	{0x448A, 0x8D},
+	{0x448B, 0x8E},
+	{0x448C, 0x9D},
+	{0x448D, 0x9C},
+	{0x448E, 0x9C},
+	{0x448F, 0x9C},
+	{0x4490, 0x94},
+	{0x4491, 0x9B},
+	{0x4492, 0x9A},
+	{0x4493, 0x97},
+	{0x4494, 0x8A},
+	{0x4495, 0x8E},
+	{0x4496, 0x8E},
+	{0x4497, 0x8C},
+	{0x4498, 0x84},
+	{0x4499, 0x86},
+	{0x449A, 0x86},
+	{0x449B, 0x84},
+	{0x449C, 0x81},
+	{0x449D, 0x83},
+	{0x449E, 0x83},
+	{0x449F, 0x81},
+	{0x44A0, 0x81},
+	{0x44A1, 0x82},
+	{0x44A2, 0x82},
+	{0x44A3, 0x81},
+	{0x44A4, 0x83},
+	{0x44A5, 0x83},
+	{0x44A6, 0x83},
+	{0x44A7, 0x83},
+	{0x44A8, 0x88},
+	{0x44A9, 0x88},
+	{0x44AA, 0x88},
+	{0x44AB, 0x88},
+	{0x44AC, 0x91},
+	{0x44AD, 0x91},
+	{0x44AE, 0x91},
+	{0x44AF, 0x92},
+	{0x44B0, 0xA0},
+	{0x44B1, 0xA0},
+	{0x44B2, 0xA0},
+	{0x44B3, 0xA0},
+	{0x44B4, 0x9E},
+	{0x44B5, 0xA9},
+	{0x44B6, 0xA8},
+	{0x44B7, 0xA3},
+	{0x44B8, 0x90},
+	{0x44B9, 0x95},
+	{0x44BA, 0x95},
+	{0x44BB, 0x92},
+	{0x44BC, 0x8A},
+	{0x44BD, 0x8E},
+	{0x44BE, 0x8E},
+	{0x44BF, 0x8B},
+	{0x44C0, 0x84},
+	{0x44C1, 0x86},
+	{0x44C2, 0x86},
+	{0x44C3, 0x84},
+	{0x44C4, 0x84},
+	{0x44C5, 0x85},
+	{0x44C6, 0x85},
+	{0x44C7, 0x84},
+	{0x44C8, 0x86},
+	{0x44C9, 0x87},
+	{0x44CA, 0x87},
+	{0x44CB, 0x86},
+	{0x44CC, 0x8D},
+	{0x44CD, 0x8E},
+	{0x44CE, 0x8E},
+	{0x44CF, 0x8D},
+	{0x44D0, 0x98},
+	{0x44D1, 0x98},
+	{0x44D2, 0x99},
+	{0x44D3, 0x9A},
+	{0x44D4, 0xA9},
+	{0x44D5, 0xAA},
+	{0x44D6, 0xAA},
+	{0x44D7, 0xAD},
+	{0x4500, 0x9F},
+	{0x4501, 0xA8},
+	{0x4502, 0xA5},
+	{0x4503, 0xAF},
+	{0x4504, 0x8F},
+	{0x4505, 0x96},
+	{0x4506, 0x92},
+	{0x4507, 0x94},
+	{0x4508, 0x89},
+	{0x4509, 0x8D},
+	{0x450A, 0x8A},
+	{0x450B, 0x8E},
+	{0x450C, 0x84},
+	{0x450D, 0x85},
+	{0x450E, 0x84},
+	{0x450F, 0x87},
+	{0x4510, 0x84},
+	{0x4511, 0x85},
+	{0x4512, 0x84},
+	{0x4513, 0x86},
+	{0x4514, 0x87},
+	{0x4515, 0x86},
+	{0x4516, 0x86},
+	{0x4517, 0x88},
+	{0x4518, 0x8F},
+	{0x4519, 0x8D},
+	{0x451A, 0x8D},
+	{0x451B, 0x8F},
+	{0x451C, 0x9A},
+	{0x451D, 0x9A},
+	{0x451E, 0x98},
+	{0x451F, 0x9A},
+	{0x4520, 0xAF},
+	{0x4521, 0xAF},
+	{0x4522, 0xB2},
+	{0x4523, 0xB1},
+	{0x4524, 0x95},
+	{0x4525, 0x9B},
+	{0x4526, 0x97},
+	{0x4527, 0x9C},
+	{0x4528, 0x8A},
+	{0x4529, 0x8E},
+	{0x452A, 0x8D},
+	{0x452B, 0x90},
+	{0x452C, 0x84},
+	{0x452D, 0x86},
+	{0x452E, 0x85},
+	{0x452F, 0x87},
+	{0x4530, 0x81},
+	{0x4531, 0x82},
+	{0x4532, 0x82},
+	{0x4533, 0x83},
+	{0x4534, 0x81},
+	{0x4535, 0x81},
+	{0x4536, 0x81},
+	{0x4537, 0x82},
+	{0x4538, 0x84},
+	{0x4539, 0x83},
+	{0x453A, 0x83},
+	{0x453B, 0x84},
+	{0x453C, 0x8A},
+	{0x453D, 0x88},
+	{0x453E, 0x88},
+	{0x453F, 0x89},
+	{0x4540, 0x94},
+	{0x4541, 0x92},
+	{0x4542, 0x91},
+	{0x4543, 0x92},
+	{0x4544, 0xA1},
+	{0x4545, 0xA0},
+	{0x4546, 0x9C},
+	{0x4547, 0x9D},
+	{0x4548, 0x8F},
+	{0x4549, 0x96},
+	{0x454A, 0x95},
+	{0x454B, 0x92},
+	{0x454C, 0x87},
+	{0x454D, 0x8A},
+	{0x454E, 0x89},
+	{0x454F, 0x8A},
+	{0x4550, 0x81},
+	{0x4551, 0x83},
+	{0x4552, 0x82},
+	{0x4553, 0x83},
+	{0x4554, 0x7F},
+	{0x4555, 0x80},
+	{0x4556, 0x80},
+	{0x4557, 0x81},
+	{0x4558, 0x7F},
+	{0x4559, 0x80},
+	{0x455A, 0x7F},
+	{0x455B, 0x80},
+	{0x455C, 0x81},
+	{0x455D, 0x81},
+	{0x455E, 0x81},
+	{0x455F, 0x81},
+	{0x4560, 0x86},
+	{0x4561, 0x85},
+	{0x4562, 0x85},
+	{0x4563, 0x85},
+	{0x4564, 0x8F},
+	{0x4565, 0x8D},
+	{0x4566, 0x8D},
+	{0x4567, 0x8D},
+	{0x4568, 0x99},
+	{0x4569, 0x9A},
+	{0x456A, 0x97},
+	{0x456B, 0x99},
+	{0x456C, 0x90},
+	{0x456D, 0x95},
+	{0x456E, 0x93},
+	{0x456F, 0x92},
+	{0x4570, 0x87},
+	{0x4571, 0x8A},
+	{0x4572, 0x88},
+	{0x4573, 0x87},
+	{0x4574, 0x81},
+	{0x4575, 0x83},
+	{0x4576, 0x82},
+	{0x4577, 0x82},
+	{0x4578, 0x7F},
+	{0x4579, 0x80},
+	{0x457A, 0x80},
+	{0x457B, 0x80},
+	{0x457C, 0x80},
+	{0x457D, 0x80},
+	{0x457E, 0x80},
+	{0x457F, 0x80},
+	{0x4580, 0x81},
+	{0x4581, 0x81},
+	{0x4582, 0x81},
+	{0x4583, 0x81},
+	{0x4584, 0x85},
+	{0x4585, 0x85},
+	{0x4586, 0x84},
+	{0x4587, 0x85},
+	{0x4588, 0x8E},
+	{0x4589, 0x8D},
+	{0x458A, 0x8C},
+	{0x458B, 0x8D},
+	{0x458C, 0x9B},
+	{0x458D, 0x9B},
+	{0x458E, 0x9A},
+	{0x458F, 0x98},
+	{0x4590, 0x94},
+	{0x4591, 0x9A},
+	{0x4592, 0x94},
+	{0x4593, 0x90},
+	{0x4594, 0x8A},
+	{0x4595, 0x8D},
+	{0x4596, 0x8C},
+	{0x4597, 0x89},
+	{0x4598, 0x84},
+	{0x4599, 0x86},
+	{0x459A, 0x85},
+	{0x459B, 0x83},
+	{0x459C, 0x82},
+	{0x459D, 0x83},
+	{0x459E, 0x82},
+	{0x459F, 0x80},
+	{0x45A0, 0x81},
+	{0x45A1, 0x82},
+	{0x45A2, 0x81},
+	{0x45A3, 0x80},
+	{0x45A4, 0x83},
+	{0x45A5, 0x83},
+	{0x45A6, 0x83},
+	{0x45A7, 0x83},
+	{0x45A8, 0x88},
+	{0x45A9, 0x87},
+	{0x45AA, 0x87},
+	{0x45AB, 0x88},
+	{0x45AC, 0x91},
+	{0x45AD, 0x90},
+	{0x45AE, 0x90},
+	{0x45AF, 0x91},
+	{0x45B0, 0x9F},
+	{0x45B1, 0x9F},
+	{0x45B2, 0x9E},
+	{0x45B3, 0x9F},
+	{0x45B4, 0x9F},
+	{0x45B5, 0xA8},
+	{0x45B6, 0xA6},
+	{0x45B7, 0xA7},
+	{0x45B8, 0x8D},
+	{0x45B9, 0x95},
+	{0x45BA, 0x90},
+	{0x45BB, 0x8A},
+	{0x45BC, 0x89},
+	{0x45BD, 0x8D},
+	{0x45BE, 0x88},
+	{0x45BF, 0x86},
+	{0x45C0, 0x84},
+	{0x45C1, 0x86},
+	{0x45C2, 0x85},
+	{0x45C3, 0x82},
+	{0x45C4, 0x84},
+	{0x45C5, 0x85},
+	{0x45C6, 0x85},
+	{0x45C7, 0x83},
+	{0x45C8, 0x86},
+	{0x45C9, 0x86},
+	{0x45CA, 0x86},
+	{0x45CB, 0x85},
+	{0x45CC, 0x8E},
+	{0x45CD, 0x8D},
+	{0x45CE, 0x8D},
+	{0x45CF, 0x8C},
+	{0x45D0, 0x99},
+	{0x45D1, 0x98},
+	{0x45D2, 0x98},
+	{0x45D3, 0x98},
+	{0x45D4, 0xA6},
+	{0x45D5, 0xA9},
+	{0x45D6, 0xA7},
+	{0x45D7, 0xAC},
+};
+
+#endif
Index: b/drivers/media/i2c/imx390.c
===================================================================
--- /dev/null
+++ b/drivers/media/i2c/imx390.c
@@ -0,0 +1,2047 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (c) 2022 Intel Corporation.
+
+#include <asm/unaligned.h>
+#include <linux/acpi.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-fwnode.h>
+#include <linux/version.h>
+#include <media/imx390.h>
+
+#define IMX390_LINK_FREQ_360MHZ		360000000ULL
+#define IMX390_LINK_FREQ_300MHZ		300000000ULL
+#define IMX390_LINK_FREQ_288MHZ		288000000ULL
+#define IMX390_LINK_FREQ_240MHZ		240000000ULL
+
+#define FIXED_POINT_SCALING_FACTOR (1ULL << 22)
+
+#define IMX390_REG_VALUE_08BIT		1
+#define IMX390_REG_VALUE_16BIT		2
+
+#define IMX390_REG_CHIP_ID		0x0330
+#define IMX390_CHIP_ID			0x0
+
+/* vertical-timings from sensor */
+#define IMX390_REG_VTS			0x300A
+#define IMX390_VTS_MAX			0xffff
+
+#define IMX390_CLK_FREQ			(1485000)
+
+/* Exposure controls from sensor */
+#define IMX390_REG_EXPOSURE		0x3012
+#define	IMX390_EXPOSURE_MIN		(30 * FIXED_POINT_SCALING_FACTOR / 1000000)
+#define	IMX390_EXPOSURE_MAX		(33333 * FIXED_POINT_SCALING_FACTOR / 1000000)
+#define	IMX390_EXPOSURE_DEF		(11000 * FIXED_POINT_SCALING_FACTOR / 1000000)
+#define	IMX390_EXPOSURE_STEP		(1 * FIXED_POINT_SCALING_FACTOR / 1000000)
+
+/* Analog gain controls from sensor */
+#define	IMX390_ANAL_GAIN_MIN		0
+#define	IMX390_ANAL_GAIN_MAX		0x64
+#define	IMX390_ANAL_GAIN_STEP		1
+#define	IMX390_ANAL_GAIN_DEFAULT	0x1c
+
+/* Digital gain controls from sensor */
+#define IMX390_DGTL_GAIN_MIN		0
+#define IMX390_DGTL_GAIN_MAX		0x7ff
+#define IMX390_DGTL_GAIN_STEP		1
+#define IMX390_DGTL_GAIN_DEFAULT	0x80
+
+#define IMX390_GAIN_MIN			0
+#define IMX390_GAIN_DEFAULT		0x80
+
+#define IMX390_RED_BALANCE_MIN		0
+#define IMX390_RED_BALANCE_MAX		0xfff
+#define IMX390_RED_BALANCE_STEP		1
+#define IMX390_RED_BALANCE_DEF		0x100
+
+#define IMX390_BLUE_BALANCE_MIN		0
+#define IMX390_BLUE_BALANCE_MAX		0xfff
+#define IMX390_BLUE_BALANCE_STEP	1
+#define IMX390_BLUE_BALANCE_DEF		0x100
+
+#define MAX(a, b)		(((a) > (b)) ? (a) : (b))
+
+#define IMX390_CID_CSI_PORT         (V4L2_CID_USER_BASE | 0x1001)
+#define IMX390_CID_I2C_BUS         (V4L2_CID_USER_BASE | 0x1002)
+#define IMX390_CID_I2C_ID         (V4L2_CID_USER_BASE | 0x1003)
+#define IMX390_CID_I2C_SLAVE_ADDRESS         (V4L2_CID_USER_BASE | 0x1004)
+#define IMX390_CID_FPS         (V4L2_CID_USER_BASE | 0x1005)
+#define IMX390_CID_FRAME_INTERVAL	(V4L2_CID_USER_BASE | 0x1006)
+
+/*
+ * dummy CID
+ */
+#define V4L2_CID_IMX390_BASE		(V4L2_CID_USER_BASE + 0x2050)
+
+#define V4L2_CID_FRAME_LENGTH_LINES (V4L2_CID_IMX390_BASE + 1)
+#define V4L2_CID_LINE_LENGTH_PIXELS (V4L2_CID_IMX390_BASE + 2)
+#define IMX390_CID_SENSOR_THERMAL_DATA (V4L2_CID_IMX390_BASE + 3)
+
+/*
+ * Select sensor mode directly, driver programs media pad
+ * formats as in configuration file
+ */
+#define IMX390_CID_SENSOR_MODE (V4L2_CID_IMX390_BASE + 4)
+
+/* IMX230 HDR specific controls */
+#define IMX390_CID_IMX230_HDR_MODE		(V4L2_CID_IMX390_BASE + 5)
+#define IMX390_CID_IMX230_HDR_ET_RATIO	(V4L2_CID_IMX390_BASE + 6)
+
+/* Set multi-exposure frame in HDR with different exposure value */
+#define IMX390_CID_EXPOSURE_SHS1		(V4L2_CID_IMX390_BASE + 8)
+#define IMX390_CID_EXPOSURE_SHS2		(V4L2_CID_IMX390_BASE + 9)
+#define IMX390_CID_EXPOSURE_SHS3		(V4L2_CID_IMX390_BASE + 10)
+#define IMX390_CID_EXPOSURE_RHS1		(V4L2_CID_IMX390_BASE + 11)
+#define IMX390_CID_EXPOSURE_RHS2		(V4L2_CID_IMX390_BASE + 12)
+
+/* Switch to enable/disable PDAF settings */
+#define IMX390_CID_SENSOR_PDAF		(V4L2_CID_IMX390_BASE + 13)
+
+/* Set multi-digital gain */
+#define IMX390_CID_DIGITAL_GAIN_L		(V4L2_CID_IMX390_BASE + 14)
+#define IMX390_CID_DIGITAL_GAIN_S		(V4L2_CID_IMX390_BASE + 15)
+#define IMX390_CID_DIGITAL_GAIN_VS		(V4L2_CID_IMX390_BASE + 16)
+
+/* Get sensor bit linear */
+#define IMX390_CID_SENSOR_BIT_LINEAR	(V4L2_CID_IMX390_BASE + 17)
+
+/* set sensor msb align*/
+#define IMX390_CID_MSB_ALIGN		(V4L2_CID_IMX390_BASE + 18)
+
+/* enable/disable auto exposure */
+#define IMX390_CID_AUTO_EXPOSURE_DEBUG	(V4L2_CID_IMX390_BASE + 19)
+
+/* set analog gain for HDR frames */
+#define IMX390_CID_ANALOG_GAIN_L		(V4L2_CID_IMX390_BASE + 20)
+#define IMX390_CID_ANALOG_GAIN_S		(V4L2_CID_IMX390_BASE + 21)
+#define IMX390_CID_ANALOG_GAIN_VS		(V4L2_CID_IMX390_BASE + 22)
+
+/* Set exposure mode: Linear mode or 2-/3-/4-HDR mode */
+#define IMX390_CID_EXPOSURE_MODE		(V4L2_CID_IMX390_BASE + 23)
+
+/* Set HDR mode exposure ratio */
+#define IMX390_CID_EXPOSURE_HDR_RATIO	(V4L2_CID_IMX390_BASE + 24)
+
+/* choose hcg/lcg for linear analog */
+#define IMX390_CID_ANALOG_LINEAR_CG	(V4L2_CID_IMX390_BASE + 25)
+
+/* Digital gain controls from sensor */
+#define IMX390_DUMMY_MIN		0
+#define IMX390_DUMMY_MAX		0x7ff
+#define IMX390_DUMMY_STEP		1
+#define IMX390_DUMMY_DEF		0x1
+
+/*
+ * end of dummy CID
+ */
+
+#define to_imx390(_sd)			container_of(_sd, struct imx390, sd)
+
+/**
+ * Register addresses (see data sheet/register map)
+ */
+enum {
+	IMX390_REG_STANDBY = 0x0000,
+	IMX390_REG_REG_HOLD = 0x0008,
+	IMX390_REG_SHS1 = 0x000c,
+	IMX390_REG_SHS2 = 0x0010,
+	IMX390_REG_AGAIN_SP1H = 0x0018,
+	IMX390_REG_AGAIN_SP1L = 0x001a,
+
+	/* default bayer order RGGB */
+	IMX390_REG_WBGAIN_R = 0x0030,
+	IMX390_REG_WBGAIN_GR = 0x0032,
+	IMX390_REG_WBGAIN_GB = 0x0034,
+	IMX390_REG_WBGAIN_B = 0x0036,
+
+	IMX390_REG_OBB_CLAMP_CTRL_SEL = 0x0083,
+	IMX390_REG_REAR_EMBDATA_LINE = 0x2E18,
+	IMX390_REG_REV1 = 0x3060,
+	IMX390_REG_REV2 = 0x3064,
+	IMX390_REG_REV3 = 0x3067,
+	IMX390_REG_WBGAIN_FORCE_X1 = 0x36A8,
+};
+
+enum {
+	IMX390_LINK_FREQ_360MBPS,
+	IMX390_LINK_FREQ_300MBPS,
+	IMX390_LINK_FREQ_288MBPS,
+	IMX390_LINK_FREQ_240MBPS,
+};
+
+struct imx390_reg {
+	u16 address;
+	u16 val;
+};
+
+struct imx390_reg_list {
+	u32 num_of_regs;
+	const struct imx390_reg *regs;
+};
+
+struct imx390_link_freq_config {
+	const struct imx390_reg_list reg_list;
+};
+
+struct imx390_mode {
+	/* Frame width in pixels */
+	u32 width;
+
+	/* Frame height in pixels */
+	u32 height;
+
+	bool hdr_en;
+
+	/* Horizontal timining size */
+	u32 hts;
+
+	/* Default vertical timining size */
+	u32 vts_def;
+
+	/* Min vertical timining size */
+	u32 vts_min;
+
+	/* Link frequency needed for this resolution */
+	u32 link_freq_index;
+
+	/* MEDIA_BUS_FMT */
+	u32 code;
+
+	/* MIPI_LANES */
+	s32 lanes;
+
+	/* MODE_FPS*/
+	u32 fps;
+
+	/* bit per pixel */
+	u32 bpp;
+
+	/* Sensor register settings for this resolution */
+	const struct imx390_reg_list reg_list;
+};
+
+struct imx390 {
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_ctrl_handler ctrl_handler;
+
+	/* V4L2 Controls */
+	struct v4l2_ctrl *link_freq;
+	struct v4l2_ctrl *mipi_lanes;
+	struct v4l2_ctrl *vblank;
+	struct v4l2_ctrl *exposure;
+	struct v4l2_ctrl *analogue_gain;
+	struct v4l2_ctrl *digital_gain;
+	struct v4l2_ctrl *gain;
+	struct v4l2_ctrl *strobe_source;
+	struct v4l2_ctrl *strobe;
+	struct v4l2_ctrl *strobe_stop;
+	struct v4l2_ctrl *timeout;
+	struct v4l2_ctrl *csi_port;
+	struct v4l2_ctrl *i2c_bus;
+	struct v4l2_ctrl *i2c_id;
+	struct v4l2_ctrl *i2c_slave_address;
+	struct v4l2_ctrl *fps;
+	struct v4l2_ctrl *frame_interval;
+	struct v4l2_ctrl *pixel_rate;
+	struct v4l2_ctrl *hblank;
+	struct v4l2_ctrl *red_balance;
+	struct v4l2_ctrl *blue_balance;
+	struct v4l2_ctrl *dummy_exp_shs1;
+	struct v4l2_ctrl *dummy_exp_shs2;
+	struct v4l2_ctrl *dummy_exp_shs3;
+	struct v4l2_ctrl *dummy_exp_rhs1;
+	struct v4l2_ctrl *dummy_exp_rhs2;
+	struct v4l2_ctrl *dummy_dg_l;
+	struct v4l2_ctrl *dummy_dg_s;
+	struct v4l2_ctrl *dummy_dg_vs;
+	struct v4l2_ctrl *dummy_ag_l;
+	struct v4l2_ctrl *dummy_ag_s;
+	struct v4l2_ctrl *dummy_ag_vs;
+	struct v4l2_ctrl *lsc_pattern;
+
+	/* Current mode */
+	const struct imx390_mode *cur_mode;
+	/* Previous mode */
+	const struct imx390_mode *pre_mode;
+
+	/* To serialize asynchronus callbacks */
+	struct mutex mutex;
+
+	/* Streaming on/off */
+	bool streaming;
+
+	struct imx390_platform_data *platform_data;
+};
+
+#include "imx390-mode-1280x960-CROP.h"
+#include "imx390_mode_1920x1200HDR3_CUST_PWL12.h"
+
+static int imx390_group_hold_enable(struct imx390 *imx390, s32 val);
+
+enum {
+	LSC_PATTERN_DISABLED = 0,
+	LSC_PATTERN_UNITY,
+	LSC_PATTERN_TABLE,
+};
+
+static const char * const lsc_qmenu[] = {
+	"Disabled",
+	"all 0x80",
+	"table",
+};
+
+static const struct imx390_reg imx390_lsc_pattern_unity[] = {
+	{0x4000, 0x80},
+	{0x4001, 0x80},
+	{0x4002, 0x80},
+	{0x4003, 0x80},
+	{0x4004, 0x80},
+	{0x4005, 0x80},
+	{0x4006, 0x80},
+	{0x4007, 0x80},
+	{0x4008, 0x80},
+	{0x4009, 0x80},
+	{0x400A, 0x80},
+	{0x400B, 0x80},
+	{0x400C, 0x80},
+	{0x400D, 0x80},
+	{0x400E, 0x80},
+	{0x400F, 0x80},
+	{0x4010, 0x80},
+	{0x4011, 0x80},
+	{0x4012, 0x80},
+	{0x4013, 0x80},
+	{0x4014, 0x80},
+	{0x4015, 0x80},
+	{0x4016, 0x80},
+	{0x4017, 0x80},
+	{0x4018, 0x80},
+	{0x4019, 0x80},
+	{0x401A, 0x80},
+	{0x401B, 0x80},
+	{0x401C, 0x80},
+	{0x401D, 0x80},
+	{0x401E, 0x80},
+	{0x401F, 0x80},
+	{0x4020, 0x80},
+	{0x4021, 0x80},
+	{0x4022, 0x80},
+	{0x4023, 0x80},
+	{0x4024, 0x80},
+	{0x4025, 0x80},
+	{0x4026, 0x80},
+	{0x4027, 0x80},
+	{0x4028, 0x80},
+	{0x4029, 0x80},
+	{0x402A, 0x80},
+	{0x402B, 0x80},
+	{0x402C, 0x80},
+	{0x402D, 0x80},
+	{0x402E, 0x80},
+	{0x402F, 0x80},
+	{0x4030, 0x80},
+	{0x4031, 0x80},
+	{0x4032, 0x80},
+	{0x4033, 0x80},
+	{0x4034, 0x80},
+	{0x4035, 0x80},
+	{0x4036, 0x80},
+	{0x4037, 0x80},
+	{0x4038, 0x80},
+	{0x4039, 0x80},
+	{0x403A, 0x80},
+	{0x403B, 0x80},
+	{0x403C, 0x80},
+	{0x403D, 0x80},
+	{0x403E, 0x80},
+	{0x403F, 0x80},
+	{0x4040, 0x80},
+	{0x4041, 0x80},
+	{0x4042, 0x80},
+	{0x4043, 0x80},
+	{0x4044, 0x80},
+	{0x4045, 0x80},
+	{0x4046, 0x80},
+	{0x4047, 0x80},
+	{0x4048, 0x80},
+	{0x4049, 0x80},
+	{0x404A, 0x80},
+	{0x404B, 0x80},
+	{0x404C, 0x80},
+	{0x404D, 0x80},
+	{0x404E, 0x80},
+	{0x404F, 0x80},
+	{0x4050, 0x80},
+	{0x4051, 0x80},
+	{0x4052, 0x80},
+	{0x4053, 0x80},
+	{0x4054, 0x80},
+	{0x4055, 0x80},
+	{0x4056, 0x80},
+	{0x4057, 0x80},
+	{0x4058, 0x80},
+	{0x4059, 0x80},
+	{0x405A, 0x80},
+	{0x405B, 0x80},
+	{0x405C, 0x80},
+	{0x405D, 0x80},
+	{0x405E, 0x80},
+	{0x405F, 0x80},
+	{0x4060, 0x80},
+	{0x4061, 0x80},
+	{0x4062, 0x80},
+	{0x4063, 0x80},
+	{0x4064, 0x80},
+	{0x4065, 0x80},
+	{0x4066, 0x80},
+	{0x4067, 0x80},
+	{0x4068, 0x80},
+	{0x4069, 0x80},
+	{0x406A, 0x80},
+	{0x406B, 0x80},
+	{0x406C, 0x80},
+	{0x406D, 0x80},
+	{0x406E, 0x80},
+	{0x406F, 0x80},
+	{0x4070, 0x80},
+	{0x4071, 0x80},
+	{0x4072, 0x80},
+	{0x4073, 0x80},
+	{0x4074, 0x80},
+	{0x4075, 0x80},
+	{0x4076, 0x80},
+	{0x4077, 0x80},
+	{0x4078, 0x80},
+	{0x4079, 0x80},
+	{0x407A, 0x80},
+	{0x407B, 0x80},
+	{0x407C, 0x80},
+	{0x407D, 0x80},
+	{0x407E, 0x80},
+	{0x407F, 0x80},
+	{0x4080, 0x80},
+	{0x4081, 0x80},
+	{0x4082, 0x80},
+	{0x4083, 0x80},
+	{0x4084, 0x80},
+	{0x4085, 0x80},
+	{0x4086, 0x80},
+	{0x4087, 0x80},
+	{0x4088, 0x80},
+	{0x4089, 0x80},
+	{0x408A, 0x80},
+	{0x408B, 0x80},
+	{0x408C, 0x80},
+	{0x408D, 0x80},
+	{0x408E, 0x80},
+	{0x408F, 0x80},
+	{0x4090, 0x80},
+	{0x4091, 0x80},
+	{0x4092, 0x80},
+	{0x4093, 0x80},
+	{0x4094, 0x80},
+	{0x4095, 0x80},
+	{0x4096, 0x80},
+	{0x4097, 0x80},
+	{0x4098, 0x80},
+	{0x4099, 0x80},
+	{0x409A, 0x80},
+	{0x409B, 0x80},
+	{0x409C, 0x80},
+	{0x409D, 0x80},
+	{0x409E, 0x80},
+	{0x409F, 0x80},
+	{0x40A0, 0x80},
+	{0x40A1, 0x80},
+	{0x40A2, 0x80},
+	{0x40A3, 0x80},
+	{0x40A4, 0x80},
+	{0x40A5, 0x80},
+	{0x40A6, 0x80},
+	{0x40A7, 0x80},
+	{0x40A8, 0x80},
+	{0x40A9, 0x80},
+	{0x40AA, 0x80},
+	{0x40AB, 0x80},
+	{0x40AC, 0x80},
+	{0x40AD, 0x80},
+	{0x40AE, 0x80},
+	{0x40AF, 0x80},
+	{0x40B0, 0x80},
+	{0x40B1, 0x80},
+	{0x40B2, 0x80},
+	{0x40B3, 0x80},
+	{0x40B4, 0x80},
+	{0x40B5, 0x80},
+	{0x40B6, 0x80},
+	{0x40B7, 0x80},
+	{0x40B8, 0x80},
+	{0x40B9, 0x80},
+	{0x40BA, 0x80},
+	{0x40BB, 0x80},
+	{0x40BC, 0x80},
+	{0x40BD, 0x80},
+	{0x40BE, 0x80},
+	{0x40BF, 0x80},
+	{0x40C0, 0x80},
+	{0x40C1, 0x80},
+	{0x40C2, 0x80},
+	{0x40C3, 0x80},
+	{0x40C4, 0x80},
+	{0x40C5, 0x80},
+	{0x40C6, 0x80},
+	{0x40C7, 0x80},
+	{0x40C8, 0x80},
+	{0x40C9, 0x80},
+	{0x40CA, 0x80},
+	{0x40CB, 0x80},
+	{0x40CC, 0x80},
+	{0x40CD, 0x80},
+	{0x40CE, 0x80},
+	{0x40CF, 0x80},
+	{0x40D0, 0x80},
+	{0x40D1, 0x80},
+	{0x40D2, 0x80},
+	{0x40D3, 0x80},
+	{0x40D4, 0x80},
+	{0x40D5, 0x80},
+	{0x40D6, 0x80},
+	{0x40D7, 0x80},
+};
+
+static const struct imx390_reg_list lsc_unity_list = {
+	.num_of_regs = ARRAY_SIZE(imx390_lsc_pattern_unity),
+	.regs = imx390_lsc_pattern_unity,
+};
+
+static const struct imx390_reg imx390_lsc_pattern_vendor_def[] = {
+	{0x01D0, 0x01}, /* SHD_ON                    */
+	{0x3AF6, 0x00}, /* SHD_DIFF_ACCURACY         */
+	{0x4000, 0x64}, /* SHD_KNOT_1_R0             */
+	{0x4001, 0x5D}, /* SHD_KNOT_1_GR0            */
+	{0x4002, 0x5D}, /* SHD_KNOT_1_GB0            */
+	{0x4003, 0x5B}, /* SHD_KNOT_1_B0             */
+	{0x4004, 0x6D}, /* SHD_KNOT_1_R1             */
+	{0x4005, 0x69}, /* SHD_KNOT_1_GR1            */
+	{0x4006, 0x69}, /* SHD_KNOT_1_GB1            */
+	{0x4007, 0x67}, /* SHD_KNOT_1_B1             */
+	{0x4008, 0x74}, /* SHD_KNOT_1_R2             */
+	{0x4009, 0x71}, /* SHD_KNOT_1_GR2            */
+	{0x400A, 0x71}, /* SHD_KNOT_1_GB2            */
+	{0x400B, 0x70}, /* SHD_KNOT_1_B2             */
+	{0x400C, 0x77}, /* SHD_KNOT_1_R3             */
+	{0x400D, 0x76}, /* SHD_KNOT_1_GR3            */
+	{0x400E, 0x76}, /* SHD_KNOT_1_GB3            */
+	{0x400F, 0x75}, /* SHD_KNOT_1_B3             */
+	{0x4010, 0x78}, /* SHD_KNOT_1_R4             */
+	{0x4011, 0x77}, /* SHD_KNOT_1_GR4            */
+	{0x4012, 0x77}, /* SHD_KNOT_1_GB4            */
+	{0x4013, 0x76}, /* SHD_KNOT_1_B4             */
+	{0x4014, 0x77}, /* SHD_KNOT_1_R5             */
+	{0x4015, 0x75}, /* SHD_KNOT_1_GR5            */
+	{0x4016, 0x75}, /* SHD_KNOT_1_GB5            */
+	{0x4017, 0x74}, /* SHD_KNOT_1_B5             */
+	{0x4018, 0x72}, /* SHD_KNOT_1_R6             */
+	{0x4019, 0x70}, /* SHD_KNOT_1_GR6            */
+	{0x401A, 0x70}, /* SHD_KNOT_1_GB6            */
+	{0x401B, 0x6F}, /* SHD_KNOT_1_B6             */
+	{0x401C, 0x6B}, /* SHD_KNOT_1_R7             */
+	{0x401D, 0x67}, /* SHD_KNOT_1_GR7            */
+	{0x401E, 0x67}, /* SHD_KNOT_1_GB7            */
+	{0x401F, 0x66}, /* SHD_KNOT_1_B7             */
+	{0x4020, 0x61}, /* SHD_KNOT_1_R8             */
+	{0x4021, 0x5B}, /* SHD_KNOT_1_GR8            */
+	{0x4022, 0x5B}, /* SHD_KNOT_1_GB8            */
+	{0x4023, 0x59}, /* SHD_KNOT_1_B8             */
+	{0x4024, 0x69}, /* SHD_KNOT_1_R9             */
+	{0x4025, 0x63}, /* SHD_KNOT_1_GR9            */
+	{0x4026, 0x63}, /* SHD_KNOT_1_GB9            */
+	{0x4027, 0x62}, /* SHD_KNOT_1_B9             */
+	{0x4028, 0x71}, /* SHD_KNOT_1_R10            */
+	{0x4029, 0x6E}, /* SHD_KNOT_1_GR10           */
+	{0x402A, 0x6E}, /* SHD_KNOT_1_GB10           */
+	{0x402B, 0x6D}, /* SHD_KNOT_1_B10            */
+	{0x402C, 0x78}, /* SHD_KNOT_1_R11            */
+	{0x402D, 0x76}, /* SHD_KNOT_1_GR11           */
+	{0x402E, 0x76}, /* SHD_KNOT_1_GB11           */
+	{0x402F, 0x76}, /* SHD_KNOT_1_B11            */
+	{0x4030, 0x7C}, /* SHD_KNOT_1_R12            */
+	{0x4031, 0x7B}, /* SHD_KNOT_1_GR12           */
+	{0x4032, 0x7B}, /* SHD_KNOT_1_GB12           */
+	{0x4033, 0x7B}, /* SHD_KNOT_1_B12            */
+	{0x4034, 0x7D}, /* SHD_KNOT_1_R13            */
+	{0x4035, 0x7D}, /* SHD_KNOT_1_GR13           */
+	{0x4036, 0x7D}, /* SHD_KNOT_1_GB13           */
+	{0x4037, 0x7C}, /* SHD_KNOT_1_B13            */
+	{0x4038, 0x7B}, /* SHD_KNOT_1_R14            */
+	{0x4039, 0x7B}, /* SHD_KNOT_1_GR14           */
+	{0x403A, 0x7B}, /* SHD_KNOT_1_GB14           */
+	{0x403B, 0x7A}, /* SHD_KNOT_1_B14            */
+	{0x403C, 0x77}, /* SHD_KNOT_1_R15            */
+	{0x403D, 0x75}, /* SHD_KNOT_1_GR15           */
+	{0x403E, 0x76}, /* SHD_KNOT_1_GB15           */
+	{0x403F, 0x75}, /* SHD_KNOT_1_B15            */
+	{0x4040, 0x70}, /* SHD_KNOT_1_R16            */
+	{0x4041, 0x6D}, /* SHD_KNOT_1_GR16           */
+	{0x4042, 0x6D}, /* SHD_KNOT_1_GB16           */
+	{0x4043, 0x6C}, /* SHD_KNOT_1_B16            */
+	{0x4044, 0x67}, /* SHD_KNOT_1_R17            */
+	{0x4045, 0x61}, /* SHD_KNOT_1_GR17           */
+	{0x4046, 0x61}, /* SHD_KNOT_1_GB17           */
+	{0x4047, 0x60}, /* SHD_KNOT_1_B17            */
+	{0x4048, 0x6B}, /* SHD_KNOT_1_R18            */
+	{0x4049, 0x66}, /* SHD_KNOT_1_GR18           */
+	{0x404A, 0x66}, /* SHD_KNOT_1_GB18           */
+	{0x404B, 0x65}, /* SHD_KNOT_1_B18            */
+	{0x404C, 0x74}, /* SHD_KNOT_1_R19            */
+	{0x404D, 0x71}, /* SHD_KNOT_1_GR19           */
+	{0x404E, 0x71}, /* SHD_KNOT_1_GB19           */
+	{0x404F, 0x70}, /* SHD_KNOT_1_B19            */
+	{0x4050, 0x7B}, /* SHD_KNOT_1_R20            */
+	{0x4051, 0x7A}, /* SHD_KNOT_1_GR20           */
+	{0x4052, 0x7A}, /* SHD_KNOT_1_GB20           */
+	{0x4053, 0x79}, /* SHD_KNOT_1_B20            */
+	{0x4054, 0x7F}, /* SHD_KNOT_1_R21            */
+	{0x4055, 0x7E}, /* SHD_KNOT_1_GR21           */
+	{0x4056, 0x7E}, /* SHD_KNOT_1_GB21           */
+	{0x4057, 0x7E}, /* SHD_KNOT_1_B21            */
+	{0x4058, 0x80}, /* SHD_KNOT_1_R22            */
+	{0x4059, 0x80}, /* SHD_KNOT_1_GR22           */
+	{0x405A, 0x80}, /* SHD_KNOT_1_GB22           */
+	{0x405B, 0x80}, /* SHD_KNOT_1_B22            */
+	{0x405C, 0x7E}, /* SHD_KNOT_1_R23            */
+	{0x405D, 0x7E}, /* SHD_KNOT_1_GR23           */
+	{0x405E, 0x7E}, /* SHD_KNOT_1_GB23           */
+	{0x405F, 0x7D}, /* SHD_KNOT_1_B23            */
+	{0x4060, 0x7A}, /* SHD_KNOT_1_R24            */
+	{0x4061, 0x79}, /* SHD_KNOT_1_GR24           */
+	{0x4062, 0x79}, /* SHD_KNOT_1_GB24           */
+	{0x4063, 0x78}, /* SHD_KNOT_1_B24            */
+	{0x4064, 0x73}, /* SHD_KNOT_1_R25            */
+	{0x4065, 0x70}, /* SHD_KNOT_1_GR25           */
+	{0x4066, 0x70}, /* SHD_KNOT_1_GB25           */
+	{0x4067, 0x6F}, /* SHD_KNOT_1_B25            */
+	{0x4068, 0x69}, /* SHD_KNOT_1_R26            */
+	{0x4069, 0x64}, /* SHD_KNOT_1_GR26           */
+	{0x406A, 0x64}, /* SHD_KNOT_1_GB26           */
+	{0x406B, 0x63}, /* SHD_KNOT_1_B26            */
+	{0x406C, 0x6B}, /* SHD_KNOT_1_R27            */
+	{0x406D, 0x66}, /* SHD_KNOT_1_GR27           */
+	{0x406E, 0x66}, /* SHD_KNOT_1_GB27           */
+	{0x406F, 0x65}, /* SHD_KNOT_1_B27            */
+	{0x4070, 0x74}, /* SHD_KNOT_1_R28            */
+	{0x4071, 0x71}, /* SHD_KNOT_1_GR28           */
+	{0x4072, 0x71}, /* SHD_KNOT_1_GB28           */
+	{0x4073, 0x70}, /* SHD_KNOT_1_B28            */
+	{0x4074, 0x7B}, /* SHD_KNOT_1_R29            */
+	{0x4075, 0x79}, /* SHD_KNOT_1_GR29           */
+	{0x4076, 0x79}, /* SHD_KNOT_1_GB29           */
+	{0x4077, 0x79}, /* SHD_KNOT_1_B29            */
+	{0x4078, 0x7E}, /* SHD_KNOT_1_R30            */
+	{0x4079, 0x7D}, /* SHD_KNOT_1_GR30           */
+	{0x407A, 0x7D}, /* SHD_KNOT_1_GB30           */
+	{0x407B, 0x7D}, /* SHD_KNOT_1_B30            */
+	{0x407C, 0x7F}, /* SHD_KNOT_1_R31            */
+	{0x407D, 0x7F}, /* SHD_KNOT_1_GR31           */
+	{0x407E, 0x7F}, /* SHD_KNOT_1_GB31           */
+	{0x407F, 0x7F}, /* SHD_KNOT_1_B31            */
+	{0x4080, 0x7E}, /* SHD_KNOT_1_R32            */
+	{0x4081, 0x7D}, /* SHD_KNOT_1_GR32           */
+	{0x4082, 0x7D}, /* SHD_KNOT_1_GB32           */
+	{0x4083, 0x7D}, /* SHD_KNOT_1_B32            */
+	{0x4084, 0x7A}, /* SHD_KNOT_1_R33            */
+	{0x4085, 0x78}, /* SHD_KNOT_1_GR33           */
+	{0x4086, 0x78}, /* SHD_KNOT_1_GB33           */
+	{0x4087, 0x78}, /* SHD_KNOT_1_B33            */
+	{0x4088, 0x73}, /* SHD_KNOT_1_R34            */
+	{0x4089, 0x70}, /* SHD_KNOT_1_GR34           */
+	{0x408A, 0x70}, /* SHD_KNOT_1_GB34           */
+	{0x408B, 0x6F}, /* SHD_KNOT_1_B34            */
+	{0x408C, 0x69}, /* SHD_KNOT_1_R35            */
+	{0x408D, 0x64}, /* SHD_KNOT_1_GR35           */
+	{0x408E, 0x64}, /* SHD_KNOT_1_GB35           */
+	{0x408F, 0x63}, /* SHD_KNOT_1_B35            */
+	{0x4090, 0x68}, /* SHD_KNOT_1_R36            */
+	{0x4091, 0x62}, /* SHD_KNOT_1_GR36           */
+	{0x4092, 0x62}, /* SHD_KNOT_1_GB36           */
+	{0x4093, 0x61}, /* SHD_KNOT_1_B36            */
+	{0x4094, 0x71}, /* SHD_KNOT_1_R37            */
+	{0x4095, 0x6D}, /* SHD_KNOT_1_GR37           */
+	{0x4096, 0x6D}, /* SHD_KNOT_1_GB37           */
+	{0x4097, 0x6D}, /* SHD_KNOT_1_B37            */
+	{0x4098, 0x77}, /* SHD_KNOT_1_R38            */
+	{0x4099, 0x75}, /* SHD_KNOT_1_GR38           */
+	{0x409A, 0x75}, /* SHD_KNOT_1_GB38           */
+	{0x409B, 0x75}, /* SHD_KNOT_1_B38            */
+	{0x409C, 0x7B}, /* SHD_KNOT_1_R39            */
+	{0x409D, 0x7A}, /* SHD_KNOT_1_GR39           */
+	{0x409E, 0x7A}, /* SHD_KNOT_1_GB39           */
+	{0x409F, 0x7A}, /* SHD_KNOT_1_B39            */
+	{0x40A0, 0x7C}, /* SHD_KNOT_1_R40            */
+	{0x40A1, 0x7B}, /* SHD_KNOT_1_GR40           */
+	{0x40A2, 0x7B}, /* SHD_KNOT_1_GB40           */
+	{0x40A3, 0x7B}, /* SHD_KNOT_1_B40            */
+	{0x40A4, 0x7B}, /* SHD_KNOT_1_R41            */
+	{0x40A5, 0x79}, /* SHD_KNOT_1_GR41           */
+	{0x40A6, 0x79}, /* SHD_KNOT_1_GB41           */
+	{0x40A7, 0x79}, /* SHD_KNOT_1_B41            */
+	{0x40A8, 0x77}, /* SHD_KNOT_1_R42            */
+	{0x40A9, 0x74}, /* SHD_KNOT_1_GR42           */
+	{0x40AA, 0x74}, /* SHD_KNOT_1_GB42           */
+	{0x40AB, 0x74}, /* SHD_KNOT_1_B42            */
+	{0x40AC, 0x70}, /* SHD_KNOT_1_R43            */
+	{0x40AD, 0x6C}, /* SHD_KNOT_1_GR43           */
+	{0x40AE, 0x6C}, /* SHD_KNOT_1_GB43           */
+	{0x40AF, 0x6C}, /* SHD_KNOT_1_B43            */
+	{0x40B0, 0x66}, /* SHD_KNOT_1_R44            */
+	{0x40B1, 0x60}, /* SHD_KNOT_1_GR44           */
+	{0x40B2, 0x60}, /* SHD_KNOT_1_GB44           */
+	{0x40B3, 0x5F}, /* SHD_KNOT_1_B44            */
+	{0x40B4, 0x62}, /* SHD_KNOT_1_R45            */
+	{0x40B5, 0x5B}, /* SHD_KNOT_1_GR45           */
+	{0x40B6, 0x5B}, /* SHD_KNOT_1_GB45           */
+	{0x40B7, 0x5A}, /* SHD_KNOT_1_B45            */
+	{0x40B8, 0x6B}, /* SHD_KNOT_1_R46            */
+	{0x40B9, 0x66}, /* SHD_KNOT_1_GR46           */
+	{0x40BA, 0x66}, /* SHD_KNOT_1_GB46           */
+	{0x40BB, 0x65}, /* SHD_KNOT_1_B46            */
+	{0x40BC, 0x71}, /* SHD_KNOT_1_R47            */
+	{0x40BD, 0x6E}, /* SHD_KNOT_1_GR47           */
+	{0x40BE, 0x6E}, /* SHD_KNOT_1_GB47           */
+	{0x40BF, 0x6D}, /* SHD_KNOT_1_B47            */
+	{0x40C0, 0x75}, /* SHD_KNOT_1_R48            */
+	{0x40C1, 0x72}, /* SHD_KNOT_1_GR48           */
+	{0x40C2, 0x72}, /* SHD_KNOT_1_GB48           */
+	{0x40C3, 0x72}, /* SHD_KNOT_1_B48            */
+	{0x40C4, 0x76}, /* SHD_KNOT_1_R49            */
+	{0x40C5, 0x74}, /* SHD_KNOT_1_GR49           */
+	{0x40C6, 0x74}, /* SHD_KNOT_1_GB49           */
+	{0x40C7, 0x74}, /* SHD_KNOT_1_B49            */
+	{0x40C8, 0x75}, /* SHD_KNOT_1_R50            */
+	{0x40C9, 0x72}, /* SHD_KNOT_1_GR50           */
+	{0x40CA, 0x72}, /* SHD_KNOT_1_GB50           */
+	{0x40CB, 0x72}, /* SHD_KNOT_1_B50            */
+	{0x40CC, 0x71}, /* SHD_KNOT_1_R51            */
+	{0x40CD, 0x6D}, /* SHD_KNOT_1_GR51           */
+	{0x40CE, 0x6D}, /* SHD_KNOT_1_GB51           */
+	{0x40CF, 0x6D}, /* SHD_KNOT_1_B51            */
+	{0x40D0, 0x6A}, /* SHD_KNOT_1_R52            */
+	{0x40D1, 0x64}, /* SHD_KNOT_1_GR52           */
+	{0x40D2, 0x64}, /* SHD_KNOT_1_GB52           */
+	{0x40D3, 0x64}, /* SHD_KNOT_1_B52            */
+	{0x40D4, 0x61}, /* SHD_KNOT_1_R53            */
+	{0x40D5, 0x59}, /* SHD_KNOT_1_GR53           */
+	{0x40D6, 0x59}, /* SHD_KNOT_1_GB53           */
+	{0x40D7, 0x58}, /* SHD_KNOT_1_B53            */
+	{0x4300, 0x8E}, /* SHD_KNOT_DIFF_1_R0        */
+	{0x4301, 0x8B}, /* SHD_KNOT_DIFF_1_GR0       */
+	{0x4302, 0x8B}, /* SHD_KNOT_DIFF_1_GB0       */
+	{0x4303, 0x8C}, /* SHD_KNOT_DIFF_1_B0        */
+	{0x4304, 0x88}, /* SHD_KNOT_DIFF_1_R1        */
+	{0x4305, 0x88}, /* SHD_KNOT_DIFF_1_GR1       */
+	{0x4306, 0x88}, /* SHD_KNOT_DIFF_1_GB1       */
+	{0x4307, 0x88}, /* SHD_KNOT_DIFF_1_B1        */
+	{0x4308, 0x88}, /* SHD_KNOT_DIFF_1_R2        */
+	{0x4309, 0x84}, /* SHD_KNOT_DIFF_1_GR2       */
+	{0x430A, 0x84}, /* SHD_KNOT_DIFF_1_GB2       */
+	{0x430B, 0x85}, /* SHD_KNOT_DIFF_1_B2        */
+	{0x430C, 0x83}, /* SHD_KNOT_DIFF_1_R3        */
+	{0x430D, 0x82}, /* SHD_KNOT_DIFF_1_GR3       */
+	{0x430E, 0x82}, /* SHD_KNOT_DIFF_1_GB3       */
+	{0x430F, 0x82}, /* SHD_KNOT_DIFF_1_B3        */
+	{0x4310, 0x84}, /* SHD_KNOT_DIFF_1_R4        */
+	{0x4311, 0x83}, /* SHD_KNOT_DIFF_1_GR4       */
+	{0x4312, 0x83}, /* SHD_KNOT_DIFF_1_GB4       */
+	{0x4313, 0x83}, /* SHD_KNOT_DIFF_1_B4        */
+	{0x4314, 0x84}, /* SHD_KNOT_DIFF_1_R5        */
+	{0x4315, 0x85}, /* SHD_KNOT_DIFF_1_GR5       */
+	{0x4316, 0x85}, /* SHD_KNOT_DIFF_1_GB5       */
+	{0x4317, 0x84}, /* SHD_KNOT_DIFF_1_B5        */
+	{0x4318, 0x86}, /* SHD_KNOT_DIFF_1_R6        */
+	{0x4319, 0x87}, /* SHD_KNOT_DIFF_1_GR6       */
+	{0x431A, 0x87}, /* SHD_KNOT_DIFF_1_GB6       */
+	{0x431B, 0x87}, /* SHD_KNOT_DIFF_1_B6        */
+	{0x431C, 0x8D}, /* SHD_KNOT_DIFF_1_R7        */
+	{0x431D, 0x8B}, /* SHD_KNOT_DIFF_1_GR7       */
+	{0x431E, 0x8B}, /* SHD_KNOT_DIFF_1_GB7       */
+	{0x431F, 0x8C}, /* SHD_KNOT_DIFF_1_B7        */
+	{0x4320, 0x93}, /* SHD_KNOT_DIFF_1_R8        */
+	{0x4321, 0x91}, /* SHD_KNOT_DIFF_1_GR8       */
+	{0x4322, 0x90}, /* SHD_KNOT_DIFF_1_GB8       */
+	{0x4323, 0x91}, /* SHD_KNOT_DIFF_1_B8        */
+	{0x4324, 0x8A}, /* SHD_KNOT_DIFF_1_R9        */
+	{0x4325, 0x89}, /* SHD_KNOT_DIFF_1_GR9       */
+	{0x4326, 0x89}, /* SHD_KNOT_DIFF_1_GB9       */
+	{0x4327, 0x8A}, /* SHD_KNOT_DIFF_1_B9        */
+	{0x4328, 0x87}, /* SHD_KNOT_DIFF_1_R10       */
+	{0x4329, 0x85}, /* SHD_KNOT_DIFF_1_GR10      */
+	{0x432A, 0x85}, /* SHD_KNOT_DIFF_1_GB10      */
+	{0x432B, 0x86}, /* SHD_KNOT_DIFF_1_B10       */
+	{0x432C, 0x84}, /* SHD_KNOT_DIFF_1_R11       */
+	{0x432D, 0x82}, /* SHD_KNOT_DIFF_1_GR11      */
+	{0x432E, 0x82}, /* SHD_KNOT_DIFF_1_GB11      */
+	{0x432F, 0x83}, /* SHD_KNOT_DIFF_1_B11       */
+	{0x4330, 0x82}, /* SHD_KNOT_DIFF_1_R12       */
+	{0x4331, 0x81}, /* SHD_KNOT_DIFF_1_GR12      */
+	{0x4332, 0x81}, /* SHD_KNOT_DIFF_1_GB12      */
+	{0x4333, 0x81}, /* SHD_KNOT_DIFF_1_B12       */
+	{0x4334, 0x81}, /* SHD_KNOT_DIFF_1_R13       */
+	{0x4335, 0x81}, /* SHD_KNOT_DIFF_1_GR13      */
+	{0x4336, 0x81}, /* SHD_KNOT_DIFF_1_GB13      */
+	{0x4337, 0x81}, /* SHD_KNOT_DIFF_1_B13       */
+	{0x4338, 0x82}, /* SHD_KNOT_DIFF_1_R14       */
+	{0x4339, 0x82}, /* SHD_KNOT_DIFF_1_GR14      */
+	{0x433A, 0x82}, /* SHD_KNOT_DIFF_1_GB14      */
+	{0x433B, 0x82}, /* SHD_KNOT_DIFF_1_B14       */
+	{0x433C, 0x85}, /* SHD_KNOT_DIFF_1_R15       */
+	{0x433D, 0x85}, /* SHD_KNOT_DIFF_1_GR15      */
+	{0x433E, 0x85}, /* SHD_KNOT_DIFF_1_GB15      */
+	{0x433F, 0x85}, /* SHD_KNOT_DIFF_1_B15       */
+	{0x4340, 0x8A}, /* SHD_KNOT_DIFF_1_R16       */
+	{0x4341, 0x89}, /* SHD_KNOT_DIFF_1_GR16      */
+	{0x4342, 0x89}, /* SHD_KNOT_DIFF_1_GB16      */
+	{0x4343, 0x89}, /* SHD_KNOT_DIFF_1_B16       */
+	{0x4344, 0x91}, /* SHD_KNOT_DIFF_1_R17       */
+	{0x4345, 0x8E}, /* SHD_KNOT_DIFF_1_GR17      */
+	{0x4346, 0x8E}, /* SHD_KNOT_DIFF_1_GB17      */
+	{0x4347, 0x8F}, /* SHD_KNOT_DIFF_1_B17       */
+	{0x4348, 0x8A}, /* SHD_KNOT_DIFF_1_R18       */
+	{0x4349, 0x87}, /* SHD_KNOT_DIFF_1_GR18      */
+	{0x434A, 0x87}, /* SHD_KNOT_DIFF_1_GB18      */
+	{0x434B, 0x89}, /* SHD_KNOT_DIFF_1_B18       */
+	{0x434C, 0x85}, /* SHD_KNOT_DIFF_1_R19       */
+	{0x434D, 0x84}, /* SHD_KNOT_DIFF_1_GR19      */
+	{0x434E, 0x84}, /* SHD_KNOT_DIFF_1_GB19      */
+	{0x434F, 0x85}, /* SHD_KNOT_DIFF_1_B19       */
+	{0x4350, 0x82}, /* SHD_KNOT_DIFF_1_R20       */
+	{0x4351, 0x82}, /* SHD_KNOT_DIFF_1_GR20      */
+	{0x4352, 0x82}, /* SHD_KNOT_DIFF_1_GB20      */
+	{0x4353, 0x82}, /* SHD_KNOT_DIFF_1_B20       */
+	{0x4354, 0x81}, /* SHD_KNOT_DIFF_1_R21       */
+	{0x4355, 0x81}, /* SHD_KNOT_DIFF_1_GR21      */
+	{0x4356, 0x81}, /* SHD_KNOT_DIFF_1_GB21      */
+	{0x4357, 0x81}, /* SHD_KNOT_DIFF_1_B21       */
+	{0x4358, 0x80}, /* SHD_KNOT_DIFF_1_R22       */
+	{0x4359, 0x80}, /* SHD_KNOT_DIFF_1_GR22      */
+	{0x435A, 0x80}, /* SHD_KNOT_DIFF_1_GB22      */
+	{0x435B, 0x80}, /* SHD_KNOT_DIFF_1_B22       */
+	{0x435C, 0x81}, /* SHD_KNOT_DIFF_1_R23       */
+	{0x435D, 0x81}, /* SHD_KNOT_DIFF_1_GR23      */
+	{0x435E, 0x81}, /* SHD_KNOT_DIFF_1_GB23      */
+	{0x435F, 0x81}, /* SHD_KNOT_DIFF_1_B23       */
+	{0x4360, 0x84}, /* SHD_KNOT_DIFF_1_R24       */
+	{0x4361, 0x84}, /* SHD_KNOT_DIFF_1_GR24      */
+	{0x4362, 0x84}, /* SHD_KNOT_DIFF_1_GB24      */
+	{0x4363, 0x83}, /* SHD_KNOT_DIFF_1_B24       */
+	{0x4364, 0x88}, /* SHD_KNOT_DIFF_1_R25       */
+	{0x4365, 0x88}, /* SHD_KNOT_DIFF_1_GR25      */
+	{0x4366, 0x88}, /* SHD_KNOT_DIFF_1_GB25      */
+	{0x4367, 0x87}, /* SHD_KNOT_DIFF_1_B25       */
+	{0x4368, 0x8E}, /* SHD_KNOT_DIFF_1_R26       */
+	{0x4369, 0x8D}, /* SHD_KNOT_DIFF_1_GR26      */
+	{0x436A, 0x8D}, /* SHD_KNOT_DIFF_1_GB26      */
+	{0x436B, 0x8C}, /* SHD_KNOT_DIFF_1_B26       */
+	{0x436C, 0x87}, /* SHD_KNOT_DIFF_1_R27       */
+	{0x436D, 0x86}, /* SHD_KNOT_DIFF_1_GR27      */
+	{0x436E, 0x86}, /* SHD_KNOT_DIFF_1_GB27      */
+	{0x436F, 0x88}, /* SHD_KNOT_DIFF_1_B27       */
+	{0x4370, 0x85}, /* SHD_KNOT_DIFF_1_R28       */
+	{0x4371, 0x84}, /* SHD_KNOT_DIFF_1_GR28      */
+	{0x4372, 0x84}, /* SHD_KNOT_DIFF_1_GB28      */
+	{0x4373, 0x85}, /* SHD_KNOT_DIFF_1_B28       */
+	{0x4374, 0x83}, /* SHD_KNOT_DIFF_1_R29       */
+	{0x4375, 0x82}, /* SHD_KNOT_DIFF_1_GR29      */
+	{0x4376, 0x82}, /* SHD_KNOT_DIFF_1_GB29      */
+	{0x4377, 0x82}, /* SHD_KNOT_DIFF_1_B29       */
+	{0x4378, 0x81}, /* SHD_KNOT_DIFF_1_R30       */
+	{0x4379, 0x80}, /* SHD_KNOT_DIFF_1_GR30      */
+	{0x437A, 0x80}, /* SHD_KNOT_DIFF_1_GB30      */
+	{0x437B, 0x80}, /* SHD_KNOT_DIFF_1_B30       */
+	{0x437C, 0x80}, /* SHD_KNOT_DIFF_1_R31       */
+	{0x437D, 0x80}, /* SHD_KNOT_DIFF_1_GR31      */
+	{0x437E, 0x80}, /* SHD_KNOT_DIFF_1_GB31      */
+	{0x437F, 0x80}, /* SHD_KNOT_DIFF_1_B31       */
+	{0x4380, 0x81}, /* SHD_KNOT_DIFF_1_R32       */
+	{0x4381, 0x81}, /* SHD_KNOT_DIFF_1_GR32      */
+	{0x4382, 0x81}, /* SHD_KNOT_DIFF_1_GB32      */
+	{0x4383, 0x80}, /* SHD_KNOT_DIFF_1_B32       */
+	{0x4384, 0x84}, /* SHD_KNOT_DIFF_1_R33       */
+	{0x4385, 0x84}, /* SHD_KNOT_DIFF_1_GR33      */
+	{0x4386, 0x84}, /* SHD_KNOT_DIFF_1_GB33      */
+	{0x4387, 0x83}, /* SHD_KNOT_DIFF_1_B33       */
+	{0x4388, 0x88}, /* SHD_KNOT_DIFF_1_R34       */
+	{0x4389, 0x88}, /* SHD_KNOT_DIFF_1_GR34      */
+	{0x438A, 0x88}, /* SHD_KNOT_DIFF_1_GB34      */
+	{0x438B, 0x87}, /* SHD_KNOT_DIFF_1_B34       */
+	{0x438C, 0x8E}, /* SHD_KNOT_DIFF_1_R35       */
+	{0x438D, 0x8E}, /* SHD_KNOT_DIFF_1_GR35      */
+	{0x438E, 0x8E}, /* SHD_KNOT_DIFF_1_GB35      */
+	{0x438F, 0x8C}, /* SHD_KNOT_DIFF_1_B35       */
+	{0x4390, 0x89}, /* SHD_KNOT_DIFF_1_R36       */
+	{0x4391, 0x88}, /* SHD_KNOT_DIFF_1_GR36      */
+	{0x4392, 0x88}, /* SHD_KNOT_DIFF_1_GB36      */
+	{0x4393, 0x8A}, /* SHD_KNOT_DIFF_1_B36       */
+	{0x4394, 0x86}, /* SHD_KNOT_DIFF_1_R37       */
+	{0x4395, 0x85}, /* SHD_KNOT_DIFF_1_GR37      */
+	{0x4396, 0x85}, /* SHD_KNOT_DIFF_1_GB37      */
+	{0x4397, 0x86}, /* SHD_KNOT_DIFF_1_B37       */
+	{0x4398, 0x83}, /* SHD_KNOT_DIFF_1_R38       */
+	{0x4399, 0x83}, /* SHD_KNOT_DIFF_1_GR38      */
+	{0x439A, 0x83}, /* SHD_KNOT_DIFF_1_GB38      */
+	{0x439B, 0x83}, /* SHD_KNOT_DIFF_1_B38       */
+	{0x439C, 0x81}, /* SHD_KNOT_DIFF_1_R39       */
+	{0x439D, 0x81}, /* SHD_KNOT_DIFF_1_GR39      */
+	{0x439E, 0x81}, /* SHD_KNOT_DIFF_1_GB39      */
+	{0x439F, 0x81}, /* SHD_KNOT_DIFF_1_B39       */
+	{0x43A0, 0x81}, /* SHD_KNOT_DIFF_1_R40       */
+	{0x43A1, 0x81}, /* SHD_KNOT_DIFF_1_GR40      */
+	{0x43A2, 0x81}, /* SHD_KNOT_DIFF_1_GB40      */
+	{0x43A3, 0x81}, /* SHD_KNOT_DIFF_1_B40       */
+	{0x43A4, 0x82}, /* SHD_KNOT_DIFF_1_R41       */
+	{0x43A5, 0x82}, /* SHD_KNOT_DIFF_1_GR41      */
+	{0x43A6, 0x82}, /* SHD_KNOT_DIFF_1_GB41      */
+	{0x43A7, 0x81}, /* SHD_KNOT_DIFF_1_B41       */
+	{0x43A8, 0x84}, /* SHD_KNOT_DIFF_1_R42       */
+	{0x43A9, 0x85}, /* SHD_KNOT_DIFF_1_GR42      */
+	{0x43AA, 0x85}, /* SHD_KNOT_DIFF_1_GB42      */
+	{0x43AB, 0x83}, /* SHD_KNOT_DIFF_1_B42       */
+	{0x43AC, 0x8A}, /* SHD_KNOT_DIFF_1_R43       */
+	{0x43AD, 0x8A}, /* SHD_KNOT_DIFF_1_GR43      */
+	{0x43AE, 0x8A}, /* SHD_KNOT_DIFF_1_GB43      */
+	{0x43AF, 0x88}, /* SHD_KNOT_DIFF_1_B43       */
+	{0x43B0, 0x93}, /* SHD_KNOT_DIFF_1_R44       */
+	{0x43B1, 0x91}, /* SHD_KNOT_DIFF_1_GR44      */
+	{0x43B2, 0x91}, /* SHD_KNOT_DIFF_1_GB44      */
+	{0x43B3, 0x8F}, /* SHD_KNOT_DIFF_1_B44       */
+	{0x43B4, 0x8B}, /* SHD_KNOT_DIFF_1_R45       */
+	{0x43B5, 0x8A}, /* SHD_KNOT_DIFF_1_GR45      */
+	{0x43B6, 0x8A}, /* SHD_KNOT_DIFF_1_GB45      */
+	{0x43B7, 0x8C}, /* SHD_KNOT_DIFF_1_B45       */
+	{0x43B8, 0x89}, /* SHD_KNOT_DIFF_1_R46       */
+	{0x43B9, 0x87}, /* SHD_KNOT_DIFF_1_GR46      */
+	{0x43BA, 0x87}, /* SHD_KNOT_DIFF_1_GB46      */
+	{0x43BB, 0x89}, /* SHD_KNOT_DIFF_1_B46       */
+	{0x43BC, 0x84}, /* SHD_KNOT_DIFF_1_R47       */
+	{0x43BD, 0x84}, /* SHD_KNOT_DIFF_1_GR47      */
+	{0x43BE, 0x84}, /* SHD_KNOT_DIFF_1_GB47      */
+	{0x43BF, 0x84}, /* SHD_KNOT_DIFF_1_B47       */
+	{0x43C0, 0x83}, /* SHD_KNOT_DIFF_1_R48       */
+	{0x43C1, 0x83}, /* SHD_KNOT_DIFF_1_GR48      */
+	{0x43C2, 0x83}, /* SHD_KNOT_DIFF_1_GB48      */
+	{0x43C3, 0x83}, /* SHD_KNOT_DIFF_1_B48       */
+	{0x43C4, 0x82}, /* SHD_KNOT_DIFF_1_R49       */
+	{0x43C5, 0x83}, /* SHD_KNOT_DIFF_1_GR49      */
+	{0x43C6, 0x83}, /* SHD_KNOT_DIFF_1_GB49      */
+	{0x43C7, 0x82}, /* SHD_KNOT_DIFF_1_B49       */
+	{0x43C8, 0x83}, /* SHD_KNOT_DIFF_1_R50       */
+	{0x43C9, 0x84}, /* SHD_KNOT_DIFF_1_GR50      */
+	{0x43CA, 0x84}, /* SHD_KNOT_DIFF_1_GB50      */
+	{0x43CB, 0x83}, /* SHD_KNOT_DIFF_1_B50       */
+	{0x43CC, 0x86}, /* SHD_KNOT_DIFF_1_R51       */
+	{0x43CD, 0x86}, /* SHD_KNOT_DIFF_1_GR51      */
+	{0x43CE, 0x86}, /* SHD_KNOT_DIFF_1_GB51      */
+	{0x43CF, 0x85}, /* SHD_KNOT_DIFF_1_B51       */
+	{0x43D0, 0x8E}, /* SHD_KNOT_DIFF_1_R52       */
+	{0x43D1, 0x8D}, /* SHD_KNOT_DIFF_1_GR52      */
+	{0x43D2, 0x8D}, /* SHD_KNOT_DIFF_1_GB52      */
+	{0x43D3, 0x8B}, /* SHD_KNOT_DIFF_1_B52       */
+	{0x43D4, 0x94}, /* SHD_KNOT_DIFF_1_R53       */
+	{0x43D5, 0x93}, /* SHD_KNOT_DIFF_1_GR53      */
+	{0x43D6, 0x93}, /* SHD_KNOT_DIFF_1_GB53      */
+	{0x43D7, 0x91}, /* SHD_KNOT_DIFF_1_B53       */
+	{0x34C0, 0xDD}, /* AE_SENSRATIO_SP1H_SP1L_R  */
+	{0x34C1, 0x00}, /* AE_SENSRATIO_SP1H_SP1L_R  */
+	{0x34C2, 0xF1}, /* AE_SENSRATIO_SP1H_SP1L_GR */
+	{0x34C3, 0x00}, /* AE_SENSRATIO_SP1H_SP1L_GR */
+	{0x34C4, 0xEC}, /* AE_SENSRATIO_SP1H_SP1L_GB */
+	{0x34C5, 0x00}, /* AE_SENSRATIO_SP1H_SP1L_GB */
+	{0x34C6, 0xE5}, /* AE_SENSRATIO_SP1H_SP1L_B  */
+	{0x34C7, 0x00}, /* AE_SENSRATIO_SP1H_SP1L_B  */
+	{0x34C8, 0xE7}, /* AE_SENSRATIO_SP1H_SP2_R   */
+	{0x34C9, 0x1B}, /* AE_SENSRATIO_SP1H_SP2_R   */
+	{0x34CA, 0x02}, /* AE_SENSRATIO_SP1H_SP2_GR  */
+	{0x34CB, 0x1D}, /* AE_SENSRATIO_SP1H_SP2_GR  */
+	{0x34CC, 0x5E}, /* AE_SENSRATIO_SP1H_SP2_GB  */
+	{0x34CD, 0x1C}, /* AE_SENSRATIO_SP1H_SP2_GB  */
+	{0x34CE, 0x4B}, /* AE_SENSRATIO_SP1H_SP2_B   */
+	{0x34CF, 0x1B}, /* AE_SENSRATIO_SP1H_SP2_B   */
+	{0x3053, 0x00}, /* "OTP_SENSRATIOEN		"    */
+	{0x3630, 0x40}, /* WDC_SGAIN_ADJ_SP1_R       */
+	{0x3631, 0x00}, /* WDC_SGAIN_ADJ_SP1_R       */
+	{0x3632, 0x40}, /* WDC_SGAIN_ADJ_SP1_GR      */
+	{0x3633, 0x00}, /* WDC_SGAIN_ADJ_SP1_GR      */
+	{0x3634, 0x40}, /* WDC_SGAIN_ADJ_SP1_GB      */
+	{0x3635, 0x00}, /* WDC_SGAIN_ADJ_SP1_GB      */
+	{0x3636, 0x40}, /* WDC_SGAIN_ADJ_SP1_B       */
+	{0x3637, 0x00}, /* WDC_SGAIN_ADJ_SP1_B       */
+	{0x3638, 0x40}, /* WDC_SGAIN_ADJ_SP2_R       */
+	{0x3639, 0x00}, /* WDC_SGAIN_ADJ_SP2_R       */
+	{0x363A, 0x40}, /* WDC_SGAIN_ADJ_SP2_GR      */
+	{0x363B, 0x00}, /* WDC_SGAIN_ADJ_SP2_GR      */
+	{0x363C, 0x40}, /* WDC_SGAIN_ADJ_SP2_GB      */
+	{0x363D, 0x00}, /* WDC_SGAIN_ADJ_SP2_GB      */
+	{0x363E, 0x40}, /* WDC_SGAIN_ADJ_SP2_B       */
+	{0x363F, 0x00}, /* WDC_SGAIN_ADJ_SP2_B       */
+	{0x3838, 0xB3}, /* OBB_CLAMP_OFFSET_R_SP1H   */
+	{0x3839, 0xFF}, /* OBB_CLAMP_OFFSET_R_SP1H   */
+	{0x383A, 0xB5}, /* OBB_CLAMP_OFFSET_GR_SP1H  */
+	{0x383B, 0xFF}, /* OBB_CLAMP_OFFSET_GR_SP1H  */
+	{0x383C, 0xB4}, /* OBB_CLAMP_OFFSET_GB_SP1H  */
+	{0x383D, 0xFF}, /* OBB_CLAMP_OFFSET_GB_SP1H  */
+	{0x383E, 0xB7}, /* OBB_CLAMP_OFFSET_B_SP1H   */
+	{0x383F, 0xFF}, /* OBB_CLAMP_OFFSET_B_SP1H   */
+	{0x3840, 0xE3}, /* OBB_CLAMP_OFFSET_R_SP1L   */
+	{0x3841, 0xFF}, /* OBB_CLAMP_OFFSET_R_SP1L   */
+	{0x3842, 0xE6}, /* OBB_CLAMP_OFFSET_GR_SP1L  */
+	{0x3843, 0xFF}, /* OBB_CLAMP_OFFSET_GR_SP1L  */
+	{0x3844, 0xF9}, /* OBB_CLAMP_OFFSET_GB_SP1L  */
+	{0x3845, 0xFF}, /* OBB_CLAMP_OFFSET_GB_SP1L  */
+	{0x3846, 0xFE}, /* OBB_CLAMP_OFFSET_B_SP1L   */
+	{0x3847, 0xFF}, /* OBB_CLAMP_OFFSET_B_SP1L   */
+	{0x3848, 0xC9}, /* OBB_CLAMP_OFFSET_R_SP2    */
+	{0x3849, 0xFF}, /* OBB_CLAMP_OFFSET_R_SP2    */
+	{0x384A, 0xCA}, /* OBB_CLAMP_OFFSET_GR_SP2   */
+	{0x384B, 0xFF}, /* OBB_CLAMP_OFFSET_GR_SP2   */
+	{0x384C, 0xE5}, /* OBB_CLAMP_OFFSET_GB_SP2   */
+	{0x384D, 0xFF}, /* OBB_CLAMP_OFFSET_GB_SP2   */
+	{0x384E, 0xF0}, /* OBB_CLAMP_OFFSET_B_SP2    */
+	{0x384F, 0xFF}, /* OBB_CLAMP_OFFSET_B_SP2    */
+};
+
+static const struct imx390_reg_list lsc_vendor_def_list = {
+	.num_of_regs = ARRAY_SIZE(imx390_lsc_pattern_vendor_def),
+	.regs = imx390_lsc_pattern_vendor_def,
+};
+
+static const s64 link_freq_menu_items[] = {
+	IMX390_LINK_FREQ_360MHZ,
+	IMX390_LINK_FREQ_300MHZ,
+	IMX390_LINK_FREQ_288MHZ,
+	IMX390_LINK_FREQ_240MHZ,
+};
+
+static const struct imx390_mode supported_modes[] = {
+	{
+		.width = 1280,
+		.height = 960,
+		.hdr_en = false,
+		.hts = 2464,
+		.vts_def = 2435,
+		.vts_min = 2435,
+		.code = MEDIA_BUS_FMT_SGRBG12_1X12,
+		.lanes = 4,
+		.fps = 30,
+		.bpp = 12,
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(imx390_mode_1280x960CROP),
+			.regs = imx390_mode_1280x960CROP,
+		},
+		.link_freq_index = -1,
+	},
+	{
+		.width = 1920,
+		.height = 1200,
+		.hdr_en = true,
+		.hts = 2464,
+		.vts_def = 2435,
+		.vts_min = 2435,
+		.code = MEDIA_BUS_FMT_SGRBG12_1X12,
+		.lanes = 4,
+		.fps = 30,
+		.bpp = 12,
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(imx390_mode_1920x1200HDR3_CUST_PWL12),
+			.regs = imx390_mode_1920x1200HDR3_CUST_PWL12,
+		},
+		.link_freq_index = -1,
+	},
+};
+
+static u32 supported_formats[] = {
+	MEDIA_BUS_FMT_SGRBG12_1X12,
+};
+
+static int imx390_read_reg(struct imx390 *imx390, u16 reg, u16 len, u32 *val)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&imx390->sd);
+	struct i2c_msg msgs[2];
+	u8 addr_buf[2];
+	u8 data_buf[4] = {0};
+	int ret;
+
+	if (len > 4)
+		return -EINVAL;
+
+	put_unaligned_be16(reg, addr_buf);
+	msgs[0].addr = client->addr;
+	msgs[0].flags = 0;
+	msgs[0].len = sizeof(addr_buf);
+	msgs[0].buf = addr_buf;
+	msgs[1].addr = client->addr;
+	msgs[1].flags = I2C_M_RD;
+	msgs[1].len = len;
+	msgs[1].buf = &data_buf[4 - len];
+
+	ret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));
+	if (ret != ARRAY_SIZE(msgs))
+		return -EIO;
+
+	*val = get_unaligned_be32(data_buf);
+
+	return 0;
+}
+
+static int imx390_write_reg(struct imx390 *imx390, u16 reg, u16 len, u32 val)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&imx390->sd);
+	u8 buf[6];
+
+	if (len > 4)
+		return -EINVAL;
+
+	dev_dbg(&client->dev, "%s, reg %x len %x, val %x\n", __func__, reg, len, val);
+	put_unaligned_be16(reg, buf);
+	put_unaligned_be32(val << 8 * (4 - len), buf + 2);
+	if (i2c_master_send(client, buf, len + 2) != len + 2)
+		return -EIO;
+
+	return 0;
+}
+
+static int imx390_write_reg_list(struct imx390 *imx390,
+				 const struct imx390_reg_list *r_list)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&imx390->sd);
+	unsigned int i;
+	int ret;
+
+	for (i = 0; i < r_list->num_of_regs; i++) {
+		ret = imx390_write_reg(imx390, r_list->regs[i].address,
+				IMX390_REG_VALUE_08BIT,
+				       r_list->regs[i].val);
+		if (ret) {
+			dev_err_ratelimited(&client->dev,
+				    "failed to write reg 0x%4.4x. error = %d",
+				    r_list->regs[i].address, ret);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int imx390_is_hdr(struct imx390 *imx390)
+{
+	// int mode_ix = self->s_data->sensor_mode_id;
+	// return imx390_modes_formats[mode_ix].hdr_en;
+
+	if (imx390->cur_mode->hdr_en)
+		return 1;
+
+	return 0;
+}
+
+static int imx390_group_hold_enable(struct imx390 *imx390, s32 val)
+{
+	int ret = 0;
+	struct i2c_client *client = v4l2_get_subdevdata(&imx390->sd);
+
+	dev_dbg(&client->dev, "group hold: %d", val);
+
+	ret = imx390_write_reg(imx390, IMX390_REG_REG_HOLD, IMX390_REG_VALUE_08BIT, val ? 1:0);
+
+	if (ret)
+		dev_err(&client->dev, "failed to set group hold");
+
+	return ret;
+}
+
+/**
+ * imx390 gain is 0 to 30 in .3db steps.
+ *
+ * @param self driver instance
+ * @param val gain
+ *
+ * @return 0 on success
+ */
+static int imx390_gain_set(struct imx390 *imx390, s64 val)
+{
+	u16 gain = 0;
+	u32 prevgain = 0;
+
+	gain = (u16)val; // * 10 / 3 / FIXED_POINT_SCALING_FACTOR;
+
+	if (gain > 100)
+		gain = 100;
+
+	if (gain < 0)
+		gain = 0;
+
+	imx390_read_reg(imx390, IMX390_REG_AGAIN_SP1H, IMX390_REG_VALUE_08BIT, &prevgain);
+
+	imx390_group_hold_enable(imx390, 1);
+
+	imx390_write_reg(imx390, IMX390_REG_AGAIN_SP1H, IMX390_REG_VALUE_08BIT,  gain & 0xff);
+	imx390_write_reg(imx390, IMX390_REG_AGAIN_SP1H + 1, IMX390_REG_VALUE_08BIT, (gain >> 8) & 0xff);
+
+	imx390_group_hold_enable(imx390, 0);
+
+	imx390_read_reg(imx390, IMX390_REG_AGAIN_SP1H, IMX390_REG_VALUE_08BIT, &prevgain);
+
+	return 0;
+}
+
+static u64 get_pixel_rate(struct imx390 *imx390)
+{
+	u64 pixel_rate = 72000000;
+
+	return pixel_rate;
+}
+
+/*
+ * from table 1, AND9820-D.pdf.
+ * for context A, hblank = LLP(0x300C) - active data time.
+ */
+static u64 get_hblank(struct imx390 *imx390)
+{
+	u64 hblank = 0;
+
+	return hblank;
+}
+
+static int imx390_exposure_raw_set(struct imx390 *self, u32 exp)
+{
+	/* This should never be called in HDR mode but we'll put check
+	 * in to be safe.
+	 */
+	if (imx390_is_hdr(self))
+		return 0;
+
+	imx390_group_hold_enable(self, 1);
+
+	struct imx390_reg exposure_array[] = {
+		/* 20 bit value 0xc, 0xd, 0xe */
+		{IMX390_REG_SHS1, exp & 0xff},
+		{IMX390_REG_SHS1 + 1, (exp & 0xff00) >> 8},
+		{IMX390_REG_SHS1 + 2, (exp & 0xf0000) >> 16},
+
+		/* 20 bit value  0x10, 0x11, 0x12 */
+		{IMX390_REG_SHS2, exp & 0xff},
+		{IMX390_REG_SHS2 + 1, (exp & 0xff00) >> 8},
+		{IMX390_REG_SHS2 + 2, (exp & 0xf0000) >> 16},
+	};
+
+	const struct imx390_reg_list exp_list = {
+		.num_of_regs = ARRAY_SIZE(exposure_array),
+		.regs = exposure_array,
+	};
+
+	/* True means to print the register values. This is a small
+	 * table so it's OK.
+	 */
+	imx390_write_reg_list(self, &exp_list);
+	imx390_group_hold_enable(self, 0);
+	return 0;
+}
+
+static int imx390_exposure_set(struct imx390 *self, s64 val)
+{
+	u32 coarse_time;
+	u32 reg;
+	u32 pixclk = 72000000;
+	u32 linelen = self->cur_mode->width;
+
+	/* This is figuring out how many lines are output for the
+	 * desired exposure time.
+	 */
+	/* pixel clock * TIME / line_length */
+	coarse_time = pixclk * val / linelen / FIXED_POINT_SCALING_FACTOR;
+
+	/* The 390 is configured such that the SHS registers are the
+	 * difference between VMAX and the exposure time expressed as
+	 * lines.
+	 */
+	/* FRAME_LENGTH is VMAX */
+	/* VMAX=1125 */
+	reg =  1125 - coarse_time;
+	/* The data sheet says values of 0 and 1 are prohibited...and
+	 * also says that the default value is 1...
+	 */
+	if (reg < 2)
+		reg = 2;
+	else if (reg >= 0x100000)
+		reg = 0x100000 - 1;
+
+	return imx390_exposure_raw_set(self, reg);
+}
+
+static int imx390_white_balance_set(struct imx390 *self)
+{
+	u16 cf00, cf01, cf10, cf11;
+	u16 red, blue;
+	u16 max_chroma, r, g, b;
+	struct i2c_client *client = v4l2_get_subdevdata(&self->sd);
+
+	dev_dbg(&client->dev, "%s\n", __func__);
+	red = *self->red_balance->p_new.p_s32;
+	blue = *self->blue_balance->p_new.p_s32;
+
+	max_chroma = MAX(MAX(red, 0x100), blue);
+	r = (max_chroma * 0x100) / red;
+	g = max_chroma;
+	b = (max_chroma * 0x100) / blue;
+
+	cf00 = IMX390_REG_WBGAIN_R;
+	cf01 = IMX390_REG_WBGAIN_GR;
+	cf10 = IMX390_REG_WBGAIN_GB;
+	cf11 = IMX390_REG_WBGAIN_B;
+
+	imx390_group_hold_enable(self, 1);
+	dev_dbg(&client->dev, "self->cur_mode->code[%x] MEDIA_BUS_FMT_SGRBG12_1X12[%x]\n", self->cur_mode->code, MEDIA_BUS_FMT_SGRBG12_1X12);
+	if (self->cur_mode->code == MEDIA_BUS_FMT_SGRBG12_1X12) {
+		imx390_write_reg(self, IMX390_REG_WBGAIN_FORCE_X1, IMX390_REG_VALUE_08BIT, 0);
+
+		imx390_write_reg(self, cf00, IMX390_REG_VALUE_08BIT, r & 0xff);
+		imx390_write_reg(self, cf00 + 1, IMX390_REG_VALUE_08BIT, (r & 0xff00) >> 8);
+		imx390_write_reg(self, cf01, IMX390_REG_VALUE_08BIT, g & 0xff);
+		imx390_write_reg(self, cf01 + 1, IMX390_REG_VALUE_08BIT, (g & 0xff00) >> 8);
+		imx390_write_reg(self, cf10, IMX390_REG_VALUE_08BIT, g & 0xff);
+		imx390_write_reg(self, cf10 + 1, IMX390_REG_VALUE_08BIT, (g & 0xff00) >> 8);
+		imx390_write_reg(self, cf11, IMX390_REG_VALUE_08BIT, b & 0xff);
+		imx390_write_reg(self, cf11 + 1, IMX390_REG_VALUE_08BIT, (b & 0xff00) >> 8);
+	}
+	imx390_group_hold_enable(self, 0);
+
+	return 0;
+}
+
+/*
+ * imx390_set_lsc_pattern
+ * len shading correction pattern
+ */
+static int imx390_set_lsc_pattern(struct imx390 *self, int val)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&self->sd);
+	int ret = 0;
+
+	if (val == LSC_PATTERN_UNITY)
+		ret = imx390_write_reg_list(self, &lsc_unity_list);
+
+	if (val == LSC_PATTERN_TABLE)
+		ret = imx390_write_reg_list(self, &lsc_vendor_def_list);
+
+	if (!ret)
+		dev_dbg(&client->dev,
+			"%s : LSC PATTERN control success\n", __func__);
+	else
+		dev_err(&client->dev, "%s ret = %d\n", __func__, ret);
+
+	return ret;
+}
+
+static int imx390_set_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct imx390 *imx390 = container_of(ctrl->handler,
+					     struct imx390, ctrl_handler);
+	struct i2c_client *client = v4l2_get_subdevdata(&imx390->sd);
+	int ret = 0;
+
+	switch (ctrl->id) {
+	case IMX390_CID_EXPOSURE_SHS1:
+	case IMX390_CID_EXPOSURE_SHS2:
+	case IMX390_CID_EXPOSURE_SHS3:
+	case IMX390_CID_EXPOSURE_RHS1:
+	case IMX390_CID_EXPOSURE_RHS2:
+	case IMX390_CID_DIGITAL_GAIN_L:
+	case IMX390_CID_DIGITAL_GAIN_S:
+	case IMX390_CID_DIGITAL_GAIN_VS:
+	case IMX390_CID_ANALOG_GAIN_L:
+	case IMX390_CID_ANALOG_GAIN_S:
+	case IMX390_CID_ANALOG_GAIN_VS:
+	case V4L2_CID_DIGITAL_GAIN:
+	case V4L2_CID_GAIN:
+		ret = 0;
+		break;
+	case V4L2_CID_ANALOGUE_GAIN:
+		ret = imx390_gain_set(imx390, *ctrl->p_new.p_s64);
+		break;
+	case V4L2_CID_EXPOSURE:
+		ret = imx390_exposure_set(imx390, *ctrl->p_new.p_s64);
+		break;
+	case V4L2_CID_VBLANK:
+		ret = imx390_write_reg(imx390, IMX390_REG_VTS,
+				IMX390_REG_VALUE_16BIT,
+				imx390->cur_mode->height + ctrl->val);
+		break;
+	case V4L2_CID_RED_BALANCE:
+	case V4L2_CID_BLUE_BALANCE:
+		ret = imx390_white_balance_set(imx390);
+		break;
+	case V4L2_CID_TEST_PATTERN:
+		ret = imx390_set_lsc_pattern(imx390, ctrl->val);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	pm_runtime_put(&client->dev);
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops imx390_ctrl_ops = {
+	.s_ctrl = imx390_set_ctrl,
+};
+
+static int imx390_init_controls(struct imx390 *imx390)
+{
+	struct v4l2_ctrl_handler *ctrl_hdlr;
+	s64 hblank;
+	int ret;
+	struct v4l2_ctrl_config cfg = { 0 };
+
+	ctrl_hdlr = &imx390->ctrl_handler;
+	ret = v4l2_ctrl_handler_init(ctrl_hdlr, 8);
+	if (ret)
+		return ret;
+
+	ctrl_hdlr->lock = &imx390->mutex;
+	imx390->link_freq = v4l2_ctrl_new_int_menu(ctrl_hdlr, &imx390_ctrl_ops,
+					   V4L2_CID_LINK_FREQ,
+					   ARRAY_SIZE(link_freq_menu_items) - 1,
+					   0, link_freq_menu_items);
+	if (imx390->link_freq)
+		imx390->link_freq->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	imx390->vblank = v4l2_ctrl_new_std(ctrl_hdlr, &imx390_ctrl_ops,
+			  V4L2_CID_VBLANK,
+			  0,
+			  IMX390_VTS_MAX - imx390->cur_mode->height, 1,
+			  imx390->cur_mode->vts_def - imx390->cur_mode->height);
+
+	imx390->gain = v4l2_ctrl_new_std(
+			ctrl_hdlr,
+			&imx390_ctrl_ops,
+			V4L2_CID_GAIN, IMX390_GAIN_MIN,
+			IMX390_DGTL_GAIN_MAX * IMX390_ANAL_GAIN_MAX, 1,
+			IMX390_GAIN_DEFAULT);
+
+	imx390->analogue_gain = v4l2_ctrl_new_std(ctrl_hdlr, &imx390_ctrl_ops, V4L2_CID_ANALOGUE_GAIN,
+			  IMX390_ANAL_GAIN_MIN, IMX390_ANAL_GAIN_MAX,
+			  IMX390_ANAL_GAIN_STEP, IMX390_ANAL_GAIN_DEFAULT);
+
+	imx390->digital_gain = v4l2_ctrl_new_std(ctrl_hdlr, &imx390_ctrl_ops, V4L2_CID_DIGITAL_GAIN,
+			IMX390_DGTL_GAIN_MIN, IMX390_DGTL_GAIN_MAX,
+			IMX390_DGTL_GAIN_STEP, IMX390_DGTL_GAIN_DEFAULT);
+
+	imx390->exposure = v4l2_ctrl_new_std(ctrl_hdlr, &imx390_ctrl_ops,
+					     V4L2_CID_EXPOSURE,
+					     IMX390_EXPOSURE_MIN,
+					     IMX390_EXPOSURE_MAX,
+					     IMX390_EXPOSURE_STEP,
+					     IMX390_EXPOSURE_DEF);
+
+	imx390->pixel_rate = v4l2_ctrl_new_std(ctrl_hdlr, &imx390_ctrl_ops,
+			V4L2_CID_PIXEL_RATE, get_pixel_rate(imx390), get_pixel_rate(imx390),
+			1, get_pixel_rate(imx390));
+
+	if (imx390->pixel_rate)
+		imx390->pixel_rate->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	hblank = get_hblank(imx390);
+	imx390->hblank = v4l2_ctrl_new_std(ctrl_hdlr, &imx390_ctrl_ops, V4L2_CID_HBLANK,
+					hblank, hblank, 1, hblank);
+	if (imx390->hblank)
+		imx390->hblank->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	imx390->red_balance = v4l2_ctrl_new_std(ctrl_hdlr, &imx390_ctrl_ops,
+					     V4L2_CID_RED_BALANCE,
+					     IMX390_RED_BALANCE_MIN,
+					     IMX390_RED_BALANCE_MAX,
+					     IMX390_RED_BALANCE_STEP,
+					     IMX390_RED_BALANCE_DEF);
+
+	imx390->blue_balance = v4l2_ctrl_new_std(ctrl_hdlr, &imx390_ctrl_ops,
+					     V4L2_CID_BLUE_BALANCE,
+					     IMX390_BLUE_BALANCE_MIN,
+					     IMX390_BLUE_BALANCE_MAX,
+					     IMX390_BLUE_BALANCE_STEP,
+					     IMX390_BLUE_BALANCE_DEF);
+
+	cfg.ops = &imx390_ctrl_ops;
+	cfg.id = IMX390_CID_EXPOSURE_SHS1;
+	cfg.name = "IMX390_CID_EXPOSURE_SHS1";
+	cfg.type = V4L2_CTRL_TYPE_INTEGER;
+	cfg.max = IMX390_DUMMY_MAX;
+	cfg.min = IMX390_DUMMY_MIN;
+	cfg.step = IMX390_DUMMY_STEP;
+	cfg.def = IMX390_DUMMY_DEF;
+	cfg.qmenu = 0; cfg.elem_size = 0;
+	imx390->dummy_exp_shs1 = v4l2_ctrl_new_custom(ctrl_hdlr, &cfg, NULL);
+
+	cfg.id = IMX390_CID_EXPOSURE_SHS2;
+	cfg.name = "IMX390_CID_EXPOSURE_SHS2";
+	imx390->dummy_exp_shs2 = v4l2_ctrl_new_custom(ctrl_hdlr, &cfg, NULL);
+
+	cfg.id = IMX390_CID_EXPOSURE_SHS3;
+	cfg.name = "IMX390_CID_EXPOSURE_SHS3";
+	imx390->dummy_exp_shs3 = v4l2_ctrl_new_custom(ctrl_hdlr, &cfg, NULL);
+
+	cfg.id = IMX390_CID_EXPOSURE_RHS1;
+	cfg.name = "IMX390_CID_EXPOSURE_RHS1";
+	imx390->dummy_exp_rhs1 = v4l2_ctrl_new_custom(ctrl_hdlr, &cfg, NULL);
+
+	cfg.id = IMX390_CID_EXPOSURE_RHS2;
+	cfg.name = "IMX390_CID_EXPOSURE_RHS2";
+	imx390->dummy_exp_rhs2 = v4l2_ctrl_new_custom(ctrl_hdlr, &cfg, NULL);
+
+	cfg.id = IMX390_CID_DIGITAL_GAIN_L;
+	cfg.name = "IMX390_CID_DIGITAL_GAIN_L";
+	imx390->dummy_dg_l = v4l2_ctrl_new_custom(ctrl_hdlr, &cfg, NULL);
+
+	cfg.id = IMX390_CID_DIGITAL_GAIN_S;
+	cfg.name = "IMX390_CID_DIGITAL_GAIN_S";
+	imx390->dummy_dg_s = v4l2_ctrl_new_custom(ctrl_hdlr, &cfg, NULL);
+
+	cfg.id = IMX390_CID_DIGITAL_GAIN_VS;
+	cfg.name = "IMX390_CID_DIGITAL_GAIN_VS";
+	imx390->dummy_dg_vs = v4l2_ctrl_new_custom(ctrl_hdlr, &cfg, NULL);
+
+	cfg.id = IMX390_CID_ANALOG_GAIN_L;
+	cfg.name = "IMX390_CID_ANALOG_GAIN_L";
+	imx390->dummy_ag_l = v4l2_ctrl_new_custom(ctrl_hdlr, &cfg, NULL);
+
+	cfg.id = IMX390_CID_ANALOG_GAIN_S;
+	cfg.name = "IMX390_CID_ANALOG_GAIN_S";
+	imx390->dummy_ag_s = v4l2_ctrl_new_custom(ctrl_hdlr, &cfg, NULL);
+
+	cfg.id = IMX390_CID_ANALOG_GAIN_VS;
+	cfg.name = "IMX390_CID_ANALOG_GAIN_VS";
+	imx390->dummy_ag_vs = v4l2_ctrl_new_custom(ctrl_hdlr, &cfg, NULL);
+
+	imx390->lsc_pattern = v4l2_ctrl_new_std_menu_items(
+		ctrl_hdlr, &imx390_ctrl_ops,
+		V4L2_CID_TEST_PATTERN,
+		ARRAY_SIZE(lsc_qmenu) - 1, 0, 0, lsc_qmenu);
+
+	if (ctrl_hdlr->error)
+		return ctrl_hdlr->error;
+
+	imx390->sd.ctrl_handler = ctrl_hdlr;
+
+	return 0;
+}
+
+static void imx390_update_pad_format(const struct imx390_mode *mode,
+				     struct v4l2_mbus_framefmt *fmt)
+{
+	fmt->width = mode->width;
+	fmt->height = mode->height;
+	fmt->code = mode->code;
+	fmt->field = V4L2_FIELD_NONE;
+}
+
+static int imx390_start_streaming(struct imx390 *imx390)
+{
+	int retries, ret;
+	struct i2c_client *client = v4l2_get_subdevdata(&imx390->sd);
+	const struct imx390_reg_list *reg_list;
+
+	if (imx390->cur_mode != imx390->pre_mode) {
+		reg_list = &imx390->cur_mode->reg_list;
+		ret = imx390_write_reg_list(imx390, reg_list);
+		if (ret) {
+			dev_err(&client->dev, "failed to set stream mode");
+			return ret;
+		}
+		imx390->pre_mode = imx390->cur_mode;
+	} else
+		dev_dbg(&client->dev, "same mode, skip write reg list");
+
+	/*
+	 * WA: i2c write to IMX390_REG_STANDBY no response randomly,
+	 * pipeline fails to start.
+	 * retries 1000 times, wait for i2c recover, pipeline started
+	 * with extra delay, instead of fails.
+	 */
+	retries = 1000;
+	do {
+		ret = imx390_write_reg(imx390, IMX390_REG_STANDBY,
+			IMX390_REG_VALUE_08BIT, 0);
+		if (ret)
+			dev_err(&client->dev, "retry to write STANDBY");
+	} while (ret && retries--);
+
+	if (ret) {
+		dev_err(&client->dev, "failed to set stream");
+		return ret;
+	}
+
+	return 0;
+}
+
+static void imx390_stop_streaming(struct imx390 *imx390)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&imx390->sd);
+
+	if (imx390_write_reg(imx390, IMX390_REG_STANDBY,
+			       IMX390_REG_VALUE_08BIT, 1))
+		dev_err(&client->dev, "failed to set stream");
+}
+
+static int imx390_set_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct imx390 *imx390 = to_imx390(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = 0;
+
+	if (imx390->streaming == enable)
+		return 0;
+
+	mutex_lock(&imx390->mutex);
+	if (enable) {
+		ret = pm_runtime_get_sync(&client->dev);
+		if (ret < 0) {
+			pm_runtime_put_noidle(&client->dev);
+			mutex_unlock(&imx390->mutex);
+			return ret;
+		}
+
+		ret = imx390_start_streaming(imx390);
+		if (ret) {
+			enable = 0;
+			imx390_stop_streaming(imx390);
+			pm_runtime_put(&client->dev);
+		}
+	} else {
+		imx390_stop_streaming(imx390);
+		pm_runtime_put(&client->dev);
+	}
+
+	imx390->streaming = enable;
+
+	mutex_unlock(&imx390->mutex);
+
+	return ret;
+}
+
+static int imx390_g_frame_interval(struct v4l2_subdev *sd,
+		struct v4l2_subdev_frame_interval *fival)
+{
+	struct imx390 *imx390 = to_imx390(sd);
+
+	fival->pad = 0;
+	fival->interval.numerator = 1;
+	fival->interval.denominator = imx390->cur_mode->fps;
+
+	return 0;
+}
+
+static int __maybe_unused imx390_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct imx390 *imx390 = to_imx390(sd);
+
+	mutex_lock(&imx390->mutex);
+	if (imx390->streaming)
+		imx390_stop_streaming(imx390);
+
+	mutex_unlock(&imx390->mutex);
+
+	return 0;
+}
+
+static int __maybe_unused imx390_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct imx390 *imx390 = to_imx390(sd);
+	int ret;
+
+	mutex_lock(&imx390->mutex);
+	if (imx390->streaming) {
+		ret = imx390_start_streaming(imx390);
+		if (ret) {
+			imx390->streaming = false;
+			imx390_stop_streaming(imx390);
+			mutex_unlock(&imx390->mutex);
+			return ret;
+		}
+	}
+
+	mutex_unlock(&imx390->mutex);
+
+	return 0;
+}
+
+static int imx390_set_format(struct v4l2_subdev *sd,
+			     struct v4l2_subdev_state *sd_state,
+			     struct v4l2_subdev_format *fmt)
+{
+	struct imx390 *imx390 = to_imx390(sd);
+	const struct imx390_mode *mode;
+	int ret = 0;
+	s32 vblank_def;
+	s64 hblank;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(supported_modes); i++)
+		if (supported_modes[i].code == fmt->format.code) {
+			if (supported_modes[i].width == fmt->format.width
+					&& supported_modes[i].height == fmt->format.height) {
+				mode = &supported_modes[i];
+				break;
+
+			}
+		}
+
+	if (i >= ARRAY_SIZE(supported_modes))
+		mode = &supported_modes[0];
+
+	mutex_lock(&imx390->mutex);
+
+	fmt->format.code = supported_formats[0];
+
+	imx390_update_pad_format(mode, &fmt->format);
+	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {
+		*v4l2_subdev_get_try_format(sd, sd_state, fmt->pad) = fmt->format;
+	} else {
+		imx390->cur_mode = mode;
+		__v4l2_ctrl_s_ctrl(imx390->link_freq, mode->link_freq_index);
+		__v4l2_ctrl_modify_range(imx390->pixel_rate,
+					get_pixel_rate(imx390),
+					get_pixel_rate(imx390),
+					1,
+					get_pixel_rate(imx390));
+
+		hblank = get_hblank(imx390);
+		__v4l2_ctrl_modify_range(imx390->hblank,
+					hblank,
+					hblank,
+					1,
+					hblank);
+
+		/* Update limits and set FPS to default */
+		vblank_def = mode->vts_def - mode->height;
+		__v4l2_ctrl_modify_range(imx390->vblank,
+					 0,
+					 IMX390_VTS_MAX - mode->height, 1,
+					 vblank_def);
+		//__v4l2_ctrl_s_ctrl(imx390->vblank, vblank_def);
+	}
+
+	mutex_unlock(&imx390->mutex);
+
+	return 0;
+}
+
+static int imx390_get_format(struct v4l2_subdev *sd,
+			     struct v4l2_subdev_state *sd_state,
+			     struct v4l2_subdev_format *fmt)
+{
+	struct imx390 *imx390 = to_imx390(sd);
+
+	mutex_lock(&imx390->mutex);
+	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY)
+		fmt->format = *v4l2_subdev_get_try_format(&imx390->sd, sd_state,
+							  fmt->pad);
+	else
+		imx390_update_pad_format(imx390->cur_mode, &fmt->format);
+
+	mutex_unlock(&imx390->mutex);
+
+	return 0;
+}
+
+static int imx390_get_frame_desc(struct v4l2_subdev *sd,
+	unsigned int pad, struct v4l2_mbus_frame_desc *desc)
+{
+	unsigned int i;
+
+	desc->num_entries = V4L2_FRAME_DESC_ENTRY_MAX;
+
+	for (i = 0; i < desc->num_entries; i++) {
+		desc->entry[i].flags = 0;
+		desc->entry[i].pixelcode = MEDIA_BUS_FMT_FIXED;
+		desc->entry[i].length = 0;
+	}
+
+	return 0;
+}
+
+static int imx390_enum_mbus_code(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_state *sd_state,
+				 struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->index >= ARRAY_SIZE(supported_formats))
+		return -EINVAL;
+
+	code->code = supported_formats[code->index];
+
+	return 0;
+}
+
+static int imx390_enum_frame_size(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_state *sd_state,
+				  struct v4l2_subdev_frame_size_enum *fse)
+{
+	if (fse->index >= ARRAY_SIZE(supported_modes))
+		return -EINVAL;
+
+	fse->min_width = supported_modes[fse->index].width;
+	fse->max_width = fse->min_width;
+	fse->min_height = supported_modes[fse->index].height;
+	fse->max_height = fse->min_height;
+
+	return 0;
+}
+
+static int imx390_frame_rate[] = { 40, 20 };
+
+static int imx390_enum_frame_interval(struct v4l2_subdev *subdev,
+		struct v4l2_subdev_state *sd_state,
+		struct v4l2_subdev_frame_interval_enum *fie)
+{
+	int mode_size = ARRAY_SIZE(supported_modes);
+	int i;
+
+	if (fie->index >= ARRAY_SIZE(imx390_frame_rate))
+		return -EINVAL;
+
+	for (i = 0; i < mode_size; i++)
+		if (fie->code == supported_modes[i].code
+			&& fie->width == supported_modes[i].width
+			&& fie->height == supported_modes[i].height)
+			break;
+
+	if (i == mode_size)
+		return -EINVAL;
+
+	fie->interval.numerator = 1;
+	fie->interval.denominator = imx390_frame_rate[fie->index];
+
+	return 0;
+}
+
+static int imx390_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct imx390 *imx390 = to_imx390(sd);
+
+	mutex_lock(&imx390->mutex);
+	imx390_update_pad_format(&supported_modes[0],
+				 v4l2_subdev_get_try_format(sd, fh->state, 0));
+	mutex_unlock(&imx390->mutex);
+
+	return 0;
+}
+
+static const struct v4l2_subdev_video_ops imx390_video_ops = {
+	.s_stream = imx390_set_stream,
+	.g_frame_interval = imx390_g_frame_interval,
+};
+
+static const struct v4l2_subdev_pad_ops imx390_pad_ops = {
+	.set_fmt = imx390_set_format,
+	.get_fmt = imx390_get_format,
+	.get_frame_desc = imx390_get_frame_desc,
+	.enum_mbus_code = imx390_enum_mbus_code,
+	.enum_frame_size = imx390_enum_frame_size,
+	.enum_frame_interval = imx390_enum_frame_interval,
+};
+
+static const struct v4l2_subdev_ops imx390_subdev_ops = {
+	.video = &imx390_video_ops,
+	.pad = &imx390_pad_ops,
+};
+
+static const struct media_entity_operations imx390_subdev_entity_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+static const struct v4l2_subdev_internal_ops imx390_internal_ops = {
+	.open = imx390_open,
+};
+
+static int imx390_identify_module(struct imx390 *imx390)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&imx390->sd);
+	int ret;
+	u32 val;
+
+	ret = imx390_read_reg(imx390, IMX390_REG_CHIP_ID,
+			      IMX390_REG_VALUE_08BIT, &val);
+	if (ret)
+		return ret;
+
+	return 0;
+
+	/* chip id not known yet */
+	if (val != IMX390_CHIP_ID) {
+		dev_err(&client->dev, "chip id mismatch: %x!=%x",
+			IMX390_CHIP_ID, val);
+		return -ENXIO;
+	}
+
+	return 0;
+}
+
+static int imx390_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct imx390 *imx390 = to_imx390(sd);
+
+	v4l2_async_unregister_subdev(sd);
+	media_entity_cleanup(&sd->entity);
+	v4l2_ctrl_handler_free(sd->ctrl_handler);
+	pm_runtime_disable(&client->dev);
+	mutex_destroy(&imx390->mutex);
+
+	return 0;
+}
+
+irqreturn_t imx390_threaded_irq_fn(int irq, void *dev_id)
+{
+	struct imx390 *imx390 = dev_id;
+
+	mutex_lock(&imx390->mutex);
+	if (imx390->streaming == false) {
+		gpio_set_value(imx390->platform_data->gpios[0], 0);
+		goto imx390_irq_handled;
+	}
+	if (imx390->strobe_source->val == V4L2_FLASH_STROBE_SOURCE_EXTERNAL) {
+
+		gpio_set_value(imx390->platform_data->gpios[0],
+				gpio_get_value(imx390->platform_data->irq_pin));
+	}
+
+imx390_irq_handled:
+	mutex_unlock(&imx390->mutex);
+	return IRQ_HANDLED;
+}
+
+static int imx390_probe(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd;
+	struct imx390 *imx390;
+	const struct imx390_reg_list *reg_list;
+	int ret;
+
+	imx390 = devm_kzalloc(&client->dev, sizeof(*imx390), GFP_KERNEL);
+	if (!imx390)
+		return -ENOMEM;
+
+	imx390->platform_data = client->dev.platform_data;
+	if (imx390->platform_data == NULL) {
+		dev_err(&client->dev, "no platform data provided\n");
+		return -EINVAL;
+	}
+
+	/* initialize subdevice */
+	sd = &imx390->sd;
+	v4l2_i2c_subdev_init(sd, client, &imx390_subdev_ops);
+	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE | V4L2_SUBDEV_FL_HAS_EVENTS;
+	sd->internal_ops = &imx390_internal_ops;
+	sd->entity.ops = &imx390_subdev_entity_ops;
+
+	/* initialize subdev media pad */
+	imx390->pad.flags = MEDIA_PAD_FL_SOURCE;
+	sd->entity.function = MEDIA_ENT_F_CAM_SENSOR;
+	ret = media_entity_pads_init(&sd->entity, 1, &imx390->pad);
+	if (ret < 0) {
+		dev_err(&client->dev,
+			"%s : media entity init Failed %d\n", __func__, ret);
+		return ret;
+	}
+
+	ret = imx390_identify_module(imx390);
+	if (ret) {
+		dev_err(&client->dev, "failed to find sensor: %d", ret);
+		return ret;
+	}
+
+	if (imx390->platform_data->suffix)
+		snprintf(imx390->sd.name,
+				sizeof(imx390->sd.name), "imx390 %c",
+				imx390->platform_data->suffix);
+
+	mutex_init(&imx390->mutex);
+
+	/* 1920x1200 default */
+	imx390->cur_mode = &supported_modes[1];
+	imx390->pre_mode = imx390->cur_mode;
+
+	reg_list = &imx390->cur_mode->reg_list;
+	ret = imx390_write_reg_list(imx390, reg_list);
+	if (ret) {
+		dev_err(&client->dev, "failed to apply preset mode");
+		return ret;
+	}
+
+	ret = imx390_init_controls(imx390);
+	if (ret) {
+		dev_err(&client->dev, "failed to init controls: %d", ret);
+		goto probe_error_v4l2_ctrl_handler_free;
+	}
+
+	ret = v4l2_async_register_subdev_sensor(&imx390->sd);
+	if (ret < 0) {
+		dev_err(&client->dev, "failed to register V4L2 subdev: %d",
+			ret);
+		goto probe_error_media_entity_cleanup;
+	}
+
+	/*
+	 * Device is already turned on by i2c-core with ACPI domain PM.
+	 * Enable runtime PM and turn off the device.
+	 */
+	pm_runtime_set_active(&client->dev);
+	pm_runtime_enable(&client->dev);
+	pm_runtime_idle(&client->dev);
+
+	return 0;
+
+probe_error_media_entity_cleanup:
+	media_entity_cleanup(&imx390->sd.entity);
+
+probe_error_v4l2_ctrl_handler_free:
+	v4l2_ctrl_handler_free(imx390->sd.ctrl_handler);
+	mutex_destroy(&imx390->mutex);
+
+	return ret;
+}
+
+static const struct dev_pm_ops imx390_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(imx390_suspend, imx390_resume)
+};
+
+static const struct i2c_device_id imx390_id_table[] = {
+	{ "imx390", 0 },
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(i2c, imx390_id_table);
+
+static struct i2c_driver imx390_i2c_driver = {
+	.driver = {
+		.name = "imx390",
+		.pm = &imx390_pm_ops,
+	},
+	.probe_new = imx390_probe,
+	.remove = imx390_remove,
+	.id_table = imx390_id_table,
+};
+
+module_i2c_driver(imx390_i2c_driver);
+
+MODULE_AUTHOR("Chang, Ying <ying.chang@intel.com>");
+MODULE_DESCRIPTION("imx390 sensor driver");
+MODULE_LICENSE("GPL v2");
Index: b/drivers/media/i2c/imx390_mode_1920x1200HDR3_CUST_PWL12.h
===================================================================
--- /dev/null
+++ b/drivers/media/i2c/imx390_mode_1920x1200HDR3_CUST_PWL12.h
@@ -0,0 +1,3891 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/**
+ * @author George Vigelette <gvigelette@d3engineering.com>
+ *
+ * imx390 v4l2 driver for tgl
+ **/
+
+#ifndef __GRBG_1920x1200_HDR3_CUST_PWL12_M4_30_27M_H
+#define __GRBG_1920x1200_HDR3_CUST_PWL12_M4_30_27M_H
+
+static const struct imx390_reg imx390_mode_1920x1200HDR3_CUST_PWL12[] = {
+{0x2E18, 0x00},		/* disable rear embedded data line */
+{0x000C, 0x45},
+{0x000D, 0x03},
+{0x000E, 0x00},
+{0x0010, 0x45},
+{0x0011, 0x03},
+{0x0012, 0x00},
+{0x0018, 0x1C},
+{0x0019, 0x00},
+{0x001A, 0x0C},
+{0x001B, 0x00},
+{0x0038, 0x00},
+{0x003C, 0x00},
+{0x003D, 0x00},
+{0x003E, 0x00},
+{0x0040, 0x00},
+{0x0041, 0x00},
+{0x0042, 0x00},
+{0x0044, 0x00},
+{0x0045, 0x00},
+{0x0046, 0x00},
+{0x0048, 0x00},
+{0x0049, 0x00},
+{0x004A, 0x00},
+{0x004C, 0x00},
+{0x004D, 0x00},
+{0x004E, 0x00},
+{0x0050, 0x00},
+{0x0051, 0x00},
+{0x0052, 0x00},
+{0x0054, 0x00},
+{0x0055, 0x00},
+{0x0056, 0x00},
+{0x0058, 0x00},
+{0x0059, 0x00},
+{0x005A, 0x00},
+{0x005C, 0x00},
+{0x005D, 0x00},
+{0x005E, 0x00},
+{0x0060, 0x00},
+{0x0061, 0x00},
+{0x0062, 0x00},
+{0x0064, 0x00},
+{0x0065, 0x00},
+{0x0066, 0x00},
+{0x0068, 0x00},
+{0x0069, 0x00},
+{0x006A, 0x00},
+{0x0078, 0x01},
+{0x007C, 0x08},
+{0x007D, 0x00},
+{0x0080, 0x08},
+{0x0081, 0x00},
+{0x0090, 0x00},
+{0x00F4, 0x1C},
+{0x00F5, 0xF8},
+{0x00F6, 0x01},
+{0x00F8, 0x03},
+{0x00F9, 0x01},
+{0x00FA, 0x00},
+{0x00FB, 0x02},
+{0x0114, 0x00},
+{0x0115, 0x01},
+{0x0118, 0x20},
+{0x0119, 0x03},
+{0x011A, 0x00},
+{0x011B, 0x41},
+{0x011C, 0x80},
+{0x011D, 0x00},
+{0x0120, 0x20},
+{0x0121, 0x00},
+{0x0122, 0x00},
+{0x0123, 0x44},
+{0x0124, 0x00},
+{0x0125, 0x01},
+{0x0128, 0x17},
+{0x0129, 0x06},
+{0x012A, 0x00},
+{0x012B, 0xA4},
+{0x012C, 0x00},
+{0x012D, 0x01},
+{0x0130, 0xD0},
+{0x0131, 0x07},
+{0x0132, 0x00},
+{0x0133, 0xDA},
+{0x0134, 0x00},
+{0x0136, 0xF0},
+{0x0137, 0x00},
+{0x013A, 0x00},
+{0x013B, 0x00},
+{0x013C, 0x00},
+{0x013D, 0x00},
+{0x013E, 0x00},
+{0x0140, 0x00},
+{0x0141, 0x00},
+{0x0142, 0x00},
+{0x0144, 0xDF},
+{0x0145, 0x01},
+{0x0146, 0x00},
+{0x0148, 0xDF},
+{0x0149, 0x01},
+{0x014A, 0x00},
+{0x014C, 0x9E},
+{0x014D, 0x05},
+{0x014E, 0x00},
+{0x0150, 0x45},
+{0x0151, 0x03},
+{0x0152, 0x00},
+{0x0154, 0xDB},
+{0x0155, 0x10},
+{0x0156, 0x00},
+{0x0158, 0xD6},
+{0x0159, 0x04},
+{0x015A, 0x00},
+{0x015C, 0x91},
+{0x015D, 0x32},
+{0x015E, 0x00},
+{0x0160, 0x98},
+{0x0161, 0x06},
+{0x0162, 0x00},
+{0x0164, 0xB4},
+{0x0165, 0x97},
+{0x0166, 0x00},
+{0x0168, 0x8F},
+{0x0169, 0x08},
+{0x016A, 0x00},
+{0x016C, 0x1C},
+{0x016D, 0xC7},
+{0x016E, 0x01},
+{0x0170, 0xC3},
+{0x0171, 0x0A},
+{0x0172, 0x00},
+{0x0174, 0x55},
+{0x0175, 0x55},
+{0x0176, 0x05},
+{0x0178, 0x3B},
+{0x0179, 0x0D},
+{0x017A, 0x00},
+{0x017C, 0xFF},
+{0x017D, 0xFF},
+{0x017E, 0x0F},
+{0x0180, 0xFF},
+{0x0181, 0x0F},
+{0x0182, 0x00},
+{0x0184, 0xFF},
+{0x0185, 0xFF},
+{0x0186, 0x0F},
+{0x0188, 0xFF},
+{0x0189, 0x0F},
+{0x018A, 0x00},
+{0x018C, 0xFF},
+{0x018D, 0xFF},
+{0x018E, 0xFF},
+{0x0190, 0xFF},
+{0x0191, 0x0F},
+{0x0192, 0x00},
+{0x0194, 0xFF},
+{0x0195, 0x0F},
+{0x0196, 0x00},
+{0x0198, 0x00},
+{0x0199, 0x00},
+{0x019A, 0x00},
+{0x019B, 0x01},
+{0x019C, 0xE8},
+{0x019D, 0x98},
+{0x019E, 0x5F},
+{0x019F, 0x00},
+{0x01A0, 0xD7},
+{0x01A1, 0xB2},
+{0x01A2, 0x23},
+{0x01A3, 0x00},
+{0x01A4, 0xB0},
+{0x01A5, 0x54},
+{0x01A6, 0x0D},
+{0x01A7, 0x00},
+{0x01A8, 0x63},
+{0x01A9, 0xFA},
+{0x01AA, 0x04},
+{0x01AB, 0x00},
+{0x01AC, 0xE4},
+{0x01AD, 0xDB},
+{0x01AE, 0x01},
+{0x01AF, 0x00},
+{0x01B0, 0xB5},
+{0x01B1, 0xB1},
+{0x01B2, 0x00},
+{0x01B3, 0x00},
+{0x01B4, 0x5C},
+{0x01B5, 0x42},
+{0x01B6, 0x00},
+{0x01B7, 0x00},
+{0x01B8, 0xC8},
+{0x01B9, 0x18},
+{0x01BA, 0x00},
+{0x01BB, 0x00},
+{0x01BC, 0x00},
+{0x01BD, 0x00},
+{0x01BE, 0x00},
+{0x01BF, 0x00},
+{0x01C0, 0x00},
+{0x01C1, 0x00},
+{0x01C2, 0x00},
+{0x01C3, 0x00},
+{0x01C4, 0x00},
+{0x01C5, 0x00},
+{0x01CC, 0x01},
+{0x01D0, 0x09},
+{0x01D4, 0x01},
+{0x0332, 0x9B},
+{0x0333, 0x03},
+{0x0390, 0x00},
+{0x0391, 0x00},
+{0x0392, 0x00},
+{0x03C0, 0x01},
+{0x2000, 0x55},
+{0x2001, 0x55},
+{0x2002, 0x55},
+{0x2003, 0x05},
+{0x2004, 0x02},
+{0x2008, 0xE2},
+{0x2009, 0x04},
+{0x200A, 0x00},
+{0x200C, 0xE4},
+{0x200D, 0x0C},
+{0x2010, 0x04},
+{0x2014, 0x01},
+{0x2018, 0xA0},
+{0x2019, 0x04},
+{0x201A, 0x00},
+{0x201C, 0x01},
+{0x201D, 0x13},
+{0x201E, 0x00},
+{0x201F, 0x00},
+{0x2020, 0xBC},
+{0x2021, 0x00},
+{0x2022, 0x7F},
+{0x2023, 0x00},
+{0x2024, 0xBA},
+{0x2025, 0x00},
+{0x2026, 0x81},
+{0x2027, 0x00},
+{0x2028, 0x7D},
+{0x2029, 0x90},
+{0x202A, 0x05},
+{0x202C, 0xFC},
+{0x202D, 0x02},
+{0x202E, 0x25},
+{0x202F, 0x03},
+{0x2030, 0x05},
+{0x2031, 0x02},
+{0x2032, 0xCA},
+{0x2033, 0x02},
+{0x2034, 0xFC},
+{0x2035, 0x02},
+{0x2036, 0x25},
+{0x2037, 0x03},
+{0x2038, 0xF8},
+{0x2039, 0xE4},
+{0x203A, 0xE3},
+{0x203B, 0x01},
+{0x203C, 0xF5},
+{0x203D, 0x8E},
+{0x203E, 0x0C},
+{0x203F, 0x2D},
+{0x2040, 0x69},
+{0x2041, 0x01},
+{0x2042, 0x8E},
+{0x2043, 0x01},
+{0x2044, 0x0C},
+{0x2045, 0x02},
+{0x2046, 0x31},
+{0x2047, 0x02},
+{0x2048, 0x6A},
+{0x2049, 0x01},
+{0x204A, 0x8E},
+{0x204B, 0x01},
+{0x204C, 0x0D},
+{0x204D, 0x02},
+{0x204E, 0x31},
+{0x204F, 0x02},
+{0x2050, 0x7B},
+{0x2051, 0x00},
+{0x2052, 0x7D},
+{0x2053, 0x00},
+{0x2054, 0x95},
+{0x2055, 0x00},
+{0x2056, 0x97},
+{0x2057, 0x00},
+{0x2058, 0xAD},
+{0x2059, 0x00},
+{0x205A, 0xAF},
+{0x205B, 0x00},
+{0x205C, 0x92},
+{0x205D, 0x00},
+{0x205E, 0x94},
+{0x205F, 0x00},
+{0x2060, 0x8E},
+{0x2061, 0x00},
+{0x2062, 0x90},
+{0x2063, 0x00},
+{0x2064, 0xB1},
+{0x2065, 0x00},
+{0x2066, 0xB3},
+{0x2067, 0x00},
+{0x2068, 0x08},
+{0x2069, 0x00},
+{0x206A, 0x04},
+{0x206B, 0x00},
+{0x206C, 0x84},
+{0x206D, 0x00},
+{0x206E, 0x80},
+{0x206F, 0x00},
+{0x2070, 0x04},
+{0x2071, 0x00},
+{0x2072, 0x46},
+{0x2073, 0x00},
+{0x2074, 0xE9},
+{0x2075, 0x01},
+{0x2076, 0x74},
+{0x2077, 0x02},
+{0x2078, 0x80},
+{0x2079, 0x00},
+{0x207A, 0xC1},
+{0x207B, 0x00},
+{0x207C, 0xFF},
+{0x207D, 0x03},
+{0x207E, 0xFF},
+{0x207F, 0x03},
+{0x2080, 0x78},
+{0x2081, 0x00},
+{0x2082, 0x6A},
+{0x2083, 0x01},
+{0x2084, 0xE4},
+{0x2085, 0x01},
+{0x2086, 0x2B},
+{0x2087, 0x03},
+{0x2088, 0x00},
+{0x2089, 0x00},
+{0x208A, 0xFF},
+{0x208B, 0x03},
+{0x208C, 0xFF},
+{0x208D, 0x03},
+{0x208E, 0xFF},
+{0x208F, 0x03},
+{0x2090, 0x7D},
+{0x2091, 0x00},
+{0x2092, 0x62},
+{0x2093, 0x01},
+{0x2094, 0xE9},
+{0x2095, 0x01},
+{0x2096, 0x00},
+{0x2097, 0x00},
+{0x2098, 0x7C},
+{0x2099, 0x00},
+{0x209A, 0x21},
+{0x209B, 0x03},
+{0x209C, 0xE9},
+{0x209D, 0x01},
+{0x209E, 0x21},
+{0x209F, 0x03},
+{0x20A0, 0xFF},
+{0x20A1, 0x03},
+{0x20A2, 0xFF},
+{0x20A3, 0x03},
+{0x20A4, 0xFF},
+{0x20A5, 0x03},
+{0x20A6, 0xFF},
+{0x20A7, 0x03},
+{0x20A8, 0xFF},
+{0x20A9, 0x03},
+{0x20AA, 0xFF},
+{0x20AB, 0x03},
+{0x20AC, 0xFF},
+{0x20AD, 0x03},
+{0x20AE, 0xFF},
+{0x20AF, 0x03},
+{0x20B0, 0xFF},
+{0x20B1, 0x03},
+{0x20B2, 0xFF},
+{0x20B3, 0x03},
+{0x20B4, 0x87},
+{0x20B5, 0xCC},
+{0x20B6, 0x87},
+{0x20B7, 0x08},
+{0x20B8, 0xF4},
+{0x20B9, 0xA5},
+{0x20BA, 0x07},
+{0x20BC, 0x1F},
+{0x20BD, 0x01},
+{0x20BE, 0xF6},
+{0x20BF, 0x00},
+{0x20C0, 0x90},
+{0x20C1, 0x01},
+{0x20C2, 0x67},
+{0x20C3, 0x01},
+{0x20C4, 0xFF},
+{0x20C5, 0x03},
+{0x20C6, 0xFF},
+{0x20C7, 0x03},
+{0x20C8, 0x33},
+{0x20C9, 0x02},
+{0x20CA, 0x0A},
+{0x20CB, 0x02},
+{0x20CC, 0x7F},
+{0x20CD, 0x00},
+{0x20CE, 0xD2},
+{0x20CF, 0x00},
+{0x20D0, 0x81},
+{0x20D1, 0x00},
+{0x20D2, 0x87},
+{0x20D3, 0x00},
+{0x20D4, 0x09},
+{0x20D5, 0x00},
+{0x20D8, 0x7F},
+{0x20D9, 0x00},
+{0x20DA, 0x62},
+{0x20DB, 0x01},
+{0x20DC, 0x7F},
+{0x20DD, 0x00},
+{0x20DE, 0x62},
+{0x20DF, 0x01},
+{0x20E0, 0x65},
+{0x20E1, 0x00},
+{0x20E2, 0x75},
+{0x20E3, 0x00},
+{0x20E4, 0xE0},
+{0x20E5, 0x00},
+{0x20E6, 0xF0},
+{0x20E7, 0x00},
+{0x20E8, 0x4C},
+{0x20E9, 0x01},
+{0x20EA, 0x5C},
+{0x20EB, 0x01},
+{0x20EC, 0xD1},
+{0x20ED, 0x01},
+{0x20EE, 0xE1},
+{0x20EF, 0x01},
+{0x20F0, 0x93},
+{0x20F1, 0x02},
+{0x20F2, 0xA3},
+{0x20F3, 0x02},
+{0x20F4, 0x0D},
+{0x20F5, 0x03},
+{0x20F6, 0x1D},
+{0x20F7, 0x03},
+{0x20F8, 0x57},
+{0x20F9, 0x00},
+{0x20FA, 0x7B},
+{0x20FB, 0x00},
+{0x20FC, 0xD2},
+{0x20FD, 0x00},
+{0x20FE, 0xF6},
+{0x20FF, 0x00},
+{0x2100, 0x3E},
+{0x2101, 0x01},
+{0x2102, 0x60},
+{0x2103, 0x01},
+{0x2104, 0xC3},
+{0x2105, 0x01},
+{0x2106, 0xE5},
+{0x2107, 0x01},
+{0x2108, 0x85},
+{0x2109, 0x02},
+{0x210A, 0xA9},
+{0x210B, 0x02},
+{0x210C, 0xFF},
+{0x210D, 0x02},
+{0x210E, 0x21},
+{0x210F, 0x03},
+{0x2110, 0xFF},
+{0x2111, 0x03},
+{0x2112, 0x00},
+{0x2113, 0x00},
+{0x2114, 0xFF},
+{0x2115, 0x03},
+{0x2116, 0xFF},
+{0x2117, 0x03},
+{0x2118, 0xFF},
+{0x2119, 0x03},
+{0x211A, 0xFF},
+{0x211B, 0x03},
+{0x211C, 0xFF},
+{0x211D, 0x03},
+{0x211E, 0xFF},
+{0x211F, 0x03},
+{0x2120, 0xFF},
+{0x2121, 0x03},
+{0x2122, 0xFF},
+{0x2123, 0x03},
+{0x2124, 0xFF},
+{0x2125, 0x03},
+{0x2126, 0xFF},
+{0x2127, 0x03},
+{0x2128, 0x7D},
+{0x2129, 0x90},
+{0x212A, 0xD5},
+{0x212B, 0x07},
+{0x212C, 0x64},
+{0x212D, 0x01},
+{0x2130, 0x5F},
+{0x2131, 0x7D},
+{0x2132, 0x05},
+{0x2134, 0x78},
+{0x2135, 0x00},
+{0x2136, 0x76},
+{0x2137, 0x00},
+{0x2138, 0xF3},
+{0x2139, 0x00},
+{0x213A, 0xF1},
+{0x213B, 0x00},
+{0x213C, 0xA6},
+{0x213D, 0x02},
+{0x213E, 0xA4},
+{0x213F, 0x02},
+{0x2140, 0x7D},
+{0x2141, 0x00},
+{0x2142, 0x8D},
+{0x2143, 0x00},
+{0x2144, 0xA1},
+{0x2145, 0x01},
+{0x2146, 0xB1},
+{0x2147, 0x01},
+{0x2148, 0xAB},
+{0x2149, 0x02},
+{0x214A, 0xBB},
+{0x214B, 0x02},
+{0x214C, 0x17},
+{0x214D, 0x5C},
+{0x214E, 0x00},
+{0x2150, 0x00},
+{0x2151, 0x00},
+{0x2152, 0xF8},
+{0x2153, 0x00},
+{0x2154, 0x45},
+{0x2155, 0x00},
+{0x2156, 0x00},
+{0x2157, 0x00},
+{0x2158, 0x25},
+{0x2159, 0x00},
+{0x215A, 0x7D},
+{0x215B, 0x00},
+{0x215C, 0x62},
+{0x215D, 0x01},
+{0x215E, 0xFF},
+{0x215F, 0x03},
+{0x2160, 0x26},
+{0x2161, 0x00},
+{0x2162, 0x7D},
+{0x2163, 0x00},
+{0x2164, 0x63},
+{0x2165, 0x01},
+{0x2166, 0xFF},
+{0x2167, 0x03},
+{0x2168, 0xCB},
+{0x2169, 0x02},
+{0x216A, 0xCF},
+{0x216B, 0x02},
+{0x216C, 0xFF},
+{0x216D, 0x03},
+{0x216E, 0xFF},
+{0x216F, 0x03},
+{0x2170, 0xFF},
+{0x2171, 0x03},
+{0x2172, 0xFF},
+{0x2173, 0x03},
+{0x2174, 0xFF},
+{0x2175, 0x03},
+{0x2176, 0xFF},
+{0x2177, 0x03},
+{0x2178, 0x7E},
+{0x2179, 0x00},
+{0x217A, 0xBD},
+{0x217B, 0x00},
+{0x217C, 0xEC},
+{0x217D, 0x01},
+{0x217E, 0x7B},
+{0x217F, 0x02},
+{0x2180, 0xD1},
+{0x2181, 0x02},
+{0x2182, 0x25},
+{0x2183, 0x03},
+{0x2184, 0x7F},
+{0x2185, 0x00},
+{0x2186, 0xBD},
+{0x2187, 0x00},
+{0x2188, 0xED},
+{0x2189, 0x01},
+{0x218A, 0x7B},
+{0x218B, 0x02},
+{0x218C, 0xD2},
+{0x218D, 0x02},
+{0x218E, 0x25},
+{0x218F, 0x03},
+{0x2190, 0xFF},
+{0x2191, 0x03},
+{0x2192, 0xFF},
+{0x2193, 0x03},
+{0x2194, 0xE9},
+{0x2195, 0x01},
+{0x2196, 0x21},
+{0x2197, 0x03},
+{0x2198, 0x17},
+{0x2199, 0xFC},
+{0x219A, 0x7F},
+{0x219B, 0x01},
+{0x219C, 0xFF},
+{0x219D, 0x03},
+{0x21A0, 0x1B},
+{0x21A1, 0x1B},
+{0x21A2, 0x1B},
+{0x21A3, 0x01},
+{0x21A4, 0x2E},
+{0x21A5, 0x80},
+{0x21A6, 0x00},
+{0x21A8, 0x04},
+{0x21A9, 0x98},
+{0x21AA, 0x60},
+{0x21AB, 0x03},
+{0x21AC, 0x7F},
+{0x21AD, 0x80},
+{0x21AE, 0x09},
+{0x21B0, 0x1C},
+{0x21B1, 0x00},
+{0x21B2, 0xA0},
+{0x21B3, 0x00},
+{0x21B4, 0x0C},
+{0x21B5, 0x00},
+{0x21B6, 0x2D},
+{0x21B7, 0x00},
+{0x21B8, 0x20},
+{0x21B9, 0x00},
+{0x21BA, 0x02},
+{0x21BB, 0x00},
+{0x21BC, 0xCC},
+{0x21BD, 0x00},
+{0x21BE, 0x4A},
+{0x21BF, 0x00},
+{0x21C0, 0xD0},
+{0x21C1, 0x00},
+{0x21C2, 0x44},
+{0x21C3, 0x00},
+{0x21C4, 0x00},
+{0x21C5, 0xE0},
+{0x21C6, 0x00},
+{0x21C8, 0x11},
+{0x21C9, 0x00},
+{0x21CA, 0x02},
+{0x21CC, 0x08},
+{0x21CD, 0xC0},
+{0x21CE, 0x0C},
+{0x21D0, 0x44},
+{0x21D1, 0x00},
+{0x21D2, 0x02},
+{0x21D4, 0x02},
+{0x21D5, 0x20},
+{0x21D6, 0x2C},
+{0x21D8, 0xFE},
+{0x21D9, 0x9D},
+{0x21DA, 0xDF},
+{0x21DB, 0x03},
+{0x21DC, 0x62},
+{0x21DD, 0x01},
+{0x21DE, 0x7F},
+{0x21DF, 0x00},
+{0x21E0, 0xB7},
+{0x21E1, 0x01},
+{0x21E2, 0xB5},
+{0x21E3, 0x01},
+{0x21E4, 0xC1},
+{0x21E5, 0x02},
+{0x21E6, 0xBF},
+{0x21E7, 0x02},
+{0x21E8, 0xB3},
+{0x21E9, 0x4D},
+{0x21EA, 0x00},
+{0x21EB, 0x04},
+{0x21EC, 0x90},
+{0x21ED, 0x07},
+{0x21EE, 0xD0},
+{0x21EF, 0x04},
+{0x21F0, 0xCC},
+{0x21F1, 0x04},
+{0x21F4, 0x02},
+{0x21F5, 0x00},
+{0x21F6, 0x00},
+{0x21F8, 0x00},
+{0x21F9, 0x00},
+{0x21FC, 0x28},
+{0x21FD, 0x00},
+{0x21FE, 0x00},
+{0x21FF, 0x00},
+{0x2200, 0x00},
+{0x2204, 0x56},
+{0x2205, 0x04},
+{0x2206, 0xE2},
+{0x2207, 0x04},
+{0x2208, 0x0A},
+{0x2209, 0x00},
+{0x220C, 0x47},
+{0x220D, 0x00},
+{0x220E, 0x1F},
+{0x220F, 0x00},
+{0x2210, 0x17},
+{0x2211, 0x00},
+{0x2212, 0x0F},
+{0x2213, 0x00},
+{0x2214, 0x17},
+{0x2215, 0x00},
+{0x2216, 0x47},
+{0x2217, 0x00},
+{0x2218, 0x0F},
+{0x2219, 0x00},
+{0x221A, 0x0F},
+{0x221B, 0x00},
+{0x221C, 0x03},
+{0x2220, 0x20},
+{0x2221, 0x10},
+{0x2222, 0x11},
+{0x2223, 0x01},
+{0x2224, 0xC7},
+{0x2225, 0xAA},
+{0x2226, 0x80},
+{0x2227, 0x08},
+{0x2228, 0x01},
+{0x2260, 0xFF},
+{0x2261, 0x1F},
+{0x2262, 0x00},
+{0x2263, 0x00},
+{0x2264, 0x00},
+{0x2265, 0x00},
+{0x2266, 0xFF},
+{0x2267, 0x1F},
+{0x2268, 0x00},
+{0x2269, 0x00},
+{0x226A, 0xFF},
+{0x226B, 0x1F},
+{0x226C, 0x00},
+{0x226D, 0x00},
+{0x226E, 0xFF},
+{0x226F, 0x1F},
+{0x227C, 0xFF},
+{0x227D, 0x1F},
+{0x227E, 0x00},
+{0x227F, 0x10},
+{0x2280, 0xFF},
+{0x2281, 0x1F},
+{0x2282, 0x00},
+{0x2283, 0x10},
+{0x2284, 0xFF},
+{0x2285, 0x1F},
+{0x2286, 0x00},
+{0x2287, 0x10},
+{0x22B2, 0x92},
+{0x22B4, 0x20},
+{0x22B5, 0x00},
+{0x22B6, 0x20},
+{0x22B7, 0x00},
+{0x22B8, 0x20},
+{0x22B9, 0x00},
+{0x22BA, 0x20},
+{0x22BB, 0x00},
+{0x22BC, 0x20},
+{0x22BD, 0x00},
+{0x22BE, 0x20},
+{0x22BF, 0x00},
+{0x22C0, 0x20},
+{0x22C1, 0x00},
+{0x22C2, 0x20},
+{0x22C3, 0x00},
+{0x22C4, 0x20},
+{0x22C5, 0x00},
+{0x22C6, 0x20},
+{0x22C7, 0x00},
+{0x22C8, 0x20},
+{0x22C9, 0x00},
+{0x22CA, 0x20},
+{0x22CB, 0x00},
+{0x22CC, 0x20},
+{0x22CD, 0x00},
+{0x22CE, 0x20},
+{0x22CF, 0x00},
+{0x22DA, 0x00},
+{0x22EF, 0x82},
+{0x2308, 0x01},
+{0x2310, 0x73},
+{0x2311, 0x89},
+{0x2318, 0x40},
+{0x2319, 0xCD},
+{0x231A, 0x54},
+{0x2324, 0x20},
+{0x2325, 0x00},
+{0x2328, 0x00},
+{0x234A, 0x9F},
+{0x234B, 0x07},
+{0x2354, 0x0C},
+{0x23C0, 0x5D},
+{0x23C2, 0x02},
+{0x244C, 0x00},
+{0x244D, 0x02},
+{0x244E, 0x54},
+{0x244F, 0x02},
+{0x24A0, 0x00},
+{0x24A4, 0x16},
+{0x24A5, 0x01},
+{0x24A6, 0xA6},
+{0x24A7, 0x02},
+{0x24A8, 0xD5},
+{0x24A9, 0x02},
+{0x24BC, 0x17},
+{0x24BD, 0x01},
+{0x24BE, 0xA7},
+{0x24BF, 0x02},
+{0x24C0, 0xD5},
+{0x24C1, 0x02},
+{0x24DA, 0x6F},
+{0x24DB, 0x00},
+{0x24DC, 0x62},
+{0x24DD, 0x01},
+{0x24EA, 0x32},
+{0x24EB, 0x00},
+{0x24EC, 0xDC},
+{0x24ED, 0x00},
+{0x24FA, 0x32},
+{0x24FB, 0x00},
+{0x24FC, 0xDD},
+{0x24FD, 0x00},
+{0x254A, 0x15},
+{0x254B, 0x01},
+{0x255A, 0x15},
+{0x255B, 0x01},
+{0x2560, 0x01},
+{0x2561, 0x00},
+{0x2562, 0x2A},
+{0x2563, 0x00},
+{0x2564, 0xF8},
+{0x2565, 0x00},
+{0x2566, 0x15},
+{0x2567, 0x01},
+{0x2568, 0x0C},
+{0x2569, 0x02},
+{0x256A, 0x31},
+{0x256B, 0x02},
+{0x2578, 0x90},
+{0x2579, 0x01},
+{0x257A, 0x92},
+{0x257B, 0x01},
+{0x257C, 0xB8},
+{0x257D, 0x02},
+{0x257E, 0xBA},
+{0x257F, 0x02},
+{0x2584, 0x90},
+{0x2585, 0x01},
+{0x2586, 0x92},
+{0x2587, 0x01},
+{0x2588, 0xB8},
+{0x2589, 0x02},
+{0x258A, 0xBA},
+{0x258B, 0x02},
+{0x267A, 0xF8},
+{0x267B, 0x00},
+{0x267C, 0x16},
+{0x267D, 0x01},
+{0x267E, 0xA6},
+{0x267F, 0x02},
+{0x2680, 0xD5},
+{0x2681, 0x02},
+{0x2690, 0xF8},
+{0x2691, 0x00},
+{0x2694, 0xA6},
+{0x2695, 0x02},
+{0x2696, 0x16},
+{0x2697, 0x01},
+{0x269A, 0xD5},
+{0x269B, 0x02},
+{0x26B8, 0x10},
+{0x26B9, 0x00},
+{0x26BA, 0x33},
+{0x26BB, 0x00},
+{0x26BC, 0x89},
+{0x26BD, 0x00},
+{0x26BE, 0xB0},
+{0x26BF, 0x00},
+{0x26C4, 0x4E},
+{0x26C5, 0x00},
+{0x26C8, 0xC9},
+{0x26C9, 0x00},
+{0x26CC, 0x35},
+{0x26CD, 0x01},
+{0x26D0, 0xBA},
+{0x26D1, 0x01},
+{0x26D4, 0x7C},
+{0x26D5, 0x02},
+{0x26D8, 0xF6},
+{0x26D9, 0x02},
+{0x26DE, 0x51},
+{0x26DF, 0x00},
+{0x26E0, 0x7F},
+{0x26E1, 0x00},
+{0x26E2, 0xCC},
+{0x26E3, 0x00},
+{0x26E4, 0xF8},
+{0x26E5, 0x00},
+{0x26E6, 0x38},
+{0x26E7, 0x01},
+{0x26E8, 0x65},
+{0x26E9, 0x01},
+{0x26EA, 0xBD},
+{0x26EB, 0x01},
+{0x26EE, 0x7F},
+{0x26EF, 0x02},
+{0x26F0, 0xAB},
+{0x26F1, 0x02},
+{0x26F2, 0xF9},
+{0x26F3, 0x02},
+{0x2722, 0x59},
+{0x2723, 0x02},
+{0x2938, 0x55},
+{0x2939, 0x00},
+{0x293A, 0x17},
+{0x293B, 0x00},
+{0x293C, 0xD0},
+{0x293D, 0x00},
+{0x293E, 0x91},
+{0x293F, 0x00},
+{0x2940, 0x3C},
+{0x2941, 0x01},
+{0x2942, 0x0C},
+{0x2943, 0x01},
+{0x2944, 0xC1},
+{0x2945, 0x01},
+{0x2946, 0x76},
+{0x2947, 0x01},
+{0x2948, 0x83},
+{0x2949, 0x02},
+{0x294A, 0xFB},
+{0x294B, 0x01},
+{0x294C, 0xFD},
+{0x294D, 0x02},
+{0x294E, 0xBF},
+{0x294F, 0x02},
+{0x2A06, 0x25},
+{0x2A07, 0x03},
+{0x2A0C, 0xBE},
+{0x2A0D, 0x00},
+{0x2A0E, 0x7D},
+{0x2A0F, 0x00},
+{0x2A20, 0x00},
+{0x2A21, 0x00},
+{0x2A22, 0x7D},
+{0x2A23, 0x00},
+{0x2B11, 0x19},
+{0x2B13, 0x15},
+{0x2B14, 0x14},
+{0x2B15, 0x13},
+{0x2B16, 0x12},
+{0x2B17, 0x11},
+{0x2B18, 0x10},
+{0x2B19, 0x0F},
+{0x2B1A, 0x0E},
+{0x2B1B, 0x0D},
+{0x2B1C, 0x0C},
+{0x2B1D, 0x0B},
+{0x2B1E, 0x0A},
+{0x2B1F, 0x09},
+{0x2B20, 0x08},
+{0x2B21, 0x07},
+{0x2B22, 0x06},
+{0x2B23, 0x05},
+{0x2B24, 0x04},
+{0x2B25, 0x03},
+{0x2B26, 0x03},
+{0x2B38, 0x01},
+{0x2B45, 0xE3},
+{0x2B50, 0x01},
+{0x2B51, 0x00},
+{0x2B6D, 0x47},
+{0x2B70, 0x04},
+{0x2B71, 0x02},
+{0x2B72, 0x02},
+{0x2B7B, 0x42},
+{0x2B7F, 0x7F},
+{0x2B80, 0x94},
+{0x2B81, 0x06},
+{0x2B87, 0x1B},
+{0x2B88, 0x1A},
+{0x2B89, 0x17},
+{0x2B8A, 0x12},
+{0x2B8B, 0x01},
+{0x2B8D, 0x2B},
+{0x2B8E, 0x2B},
+{0x2B8F, 0x1B},
+{0x2B90, 0xBF},
+{0x2B91, 0x0F},
+{0x2B92, 0x73},
+{0x2B93, 0x0E},
+{0x2B94, 0xBF},
+{0x2B95, 0x07},
+{0x2B96, 0x73},
+{0x2B97, 0x0E},
+{0x2B98, 0xBF},
+{0x2B99, 0x57},
+{0x2B9B, 0x2A},
+{0x2BA8, 0xBC},
+{0x2BA9, 0x62},
+{0x2BC5, 0x80},
+{0x2BD5, 0x30},
+{0x2BD6, 0xF0},
+{0x2BD8, 0x5B},
+{0x2BD9, 0xF0},
+{0x2BDA, 0x21},
+{0x2BDB, 0x0E},
+{0x2BDC, 0x5E},
+{0x2BFE, 0x02},
+{0x2BFF, 0x00},
+{0x2C98, 0xE1},
+{0x2C99, 0x2E},
+{0x2C9B, 0x80},
+{0x2CA9, 0x80},
+{0x2CAA, 0x01},
+{0x2CBF, 0x08},
+{0x2D39, 0x0E},
+{0x2D50, 0x80},
+{0x2D54, 0x00},
+{0x2D5B, 0x58},
+{0x2D64, 0x66}, // GRBG
+{0x2D65, 0x80}, // GRBG
+{0x2DFC, 0x00}, // disable spmg
+{0x2DFD, 0x01},
+{0x2E24, 0x01}, // disable spmg
+{0x3000, 0x00},
+{0x3001, 0x00},
+{0x3002, 0x23},
+{0x3003, 0xA1},
+{0x3004, 0x00},
+{0x3005, 0x20},
+{0x3006, 0x6E},
+{0x3007, 0x00},
+{0x3008, 0x06},
+{0x3009, 0xB4},
+{0x300A, 0x1F},
+{0x300B, 0x00},
+{0x300C, 0x00},
+{0x300D, 0x1B},
+{0x300E, 0x90},
+{0x300F, 0x97},
+{0x3010, 0x00},
+{0x3011, 0x00},
+{0x3012, 0x11},
+{0x3013, 0x21},
+{0x3014, 0x00},
+{0x3015, 0x20},
+{0x3016, 0x94},
+{0x3017, 0x00},
+{0x3018, 0x30},
+{0x3019, 0x09},
+{0x301A, 0x46},
+{0x301B, 0x00},
+{0x30A0, 0xCD},
+{0x30A1, 0x0C},
+{0x30A2, 0xBA},
+{0x30A3, 0x0C},
+{0x30A4, 0x5F},
+{0x30A5, 0x00},
+{0x30A6, 0x43},
+{0x30A7, 0x00},
+{0x30A8, 0xC8},
+{0x30A9, 0x0A},
+{0x30AA, 0x0B},
+{0x30AB, 0x08},
+{0x30AC, 0x4B},
+{0x30AD, 0x03},
+{0x30AE, 0x37},
+{0x30AF, 0x03},
+{0x30B0, 0x65},
+{0x30B1, 0x09},
+{0x30B2, 0x7A},
+{0x30B3, 0x09},
+{0x30B4, 0x20},
+{0x30B5, 0x00},
+{0x30B6, 0x28},
+{0x30B7, 0x00},
+{0x30B8, 0x91},
+{0x30B9, 0x04},
+{0x30BA, 0x75},
+{0x30BB, 0x05},
+{0x30BC, 0x7C},
+{0x30BD, 0x01},
+{0x30BE, 0x87},
+{0x30BF, 0x01},
+{0x3370, 0x01},
+{0x3374, 0x00},
+{0x3375, 0x00},
+{0x3376, 0x01},
+{0x3377, 0x00},
+{0x3410, 0x80},
+{0x3411, 0x07},
+{0x3418, 0xB0},
+{0x3419, 0x04},
+{0x3450, 0x00}, /* use continuous clock */
+{0x34BE, 0x7A},
+{0x34BF, 0x02},
+{0x3584, 0x00},
+{0x3586, 0x00},
+{0x3587, 0x01},
+{0x3588, 0xE6},
+{0x3589, 0x00},
+{0x3590, 0x00},
+{0x3591, 0x00},
+{0x3594, 0x40},
+{0x3598, 0x03},
+{0x3599, 0x00},
+{0x359A, 0x80},
+{0x359B, 0x00},
+{0x359C, 0x00},
+{0x359D, 0x01},
+{0x359E, 0x00},
+{0x359F, 0x02},
+{0x35A0, 0x00},
+{0x35A1, 0x04},
+{0x35A2, 0x20},
+{0x35A3, 0x00},
+{0x35A4, 0x40},
+{0x35A5, 0x00},
+{0x35A6, 0x80},
+{0x35A7, 0x00},
+{0x35A8, 0x00},
+{0x35A9, 0x01},
+{0x35AC, 0x80},
+{0x35AD, 0x00},
+{0x35AE, 0x00},
+{0x35AF, 0x01},
+{0x35B0, 0x00},
+{0x35B1, 0x02},
+{0x35B2, 0x00},
+{0x35B3, 0x04},
+{0x35B4, 0x02},
+{0x35B5, 0x00},
+{0x35B6, 0x04},
+{0x35B7, 0x00},
+{0x35B8, 0x08},
+{0x35B9, 0x00},
+{0x35BA, 0x10},
+{0x35BB, 0x00},
+{0x35C8, 0x00},
+{0x35C9, 0x01},
+{0x35CA, 0x00},
+{0x35CB, 0x04},
+{0x35CC, 0x00},
+{0x35CD, 0x10},
+{0x35CE, 0x00},
+{0x35CF, 0x40},
+{0x35D0, 0x00},
+{0x35D1, 0x0C},
+{0x35D2, 0x00},
+{0x35D3, 0x0C},
+{0x35D4, 0x00},
+{0x35D5, 0x0C},
+{0x35D6, 0x00},
+{0x35D7, 0x0C},
+{0x35D8, 0x00},
+{0x35D9, 0x00},
+{0x35DA, 0x08},
+{0x35DB, 0x00},
+{0x35DC, 0xD8},
+{0x35DD, 0x0E},
+{0x35F0, 0x00},
+{0x35F1, 0x10},
+{0x35F2, 0x00},
+{0x35F3, 0x10},
+{0x35F4, 0x00},
+{0x35F5, 0x10},
+{0x35F6, 0x00},
+{0x35F7, 0x04},
+{0x35F8, 0x00},
+{0x35F9, 0x03},
+{0x35FA, 0x38},
+{0x35FB, 0x00},
+{0x35FC, 0xB3},
+{0x35FD, 0x01},
+{0x35FE, 0x00},
+{0x35FF, 0x00},
+{0x3600, 0x05},
+{0x3601, 0x06},
+{0x3604, 0x03},
+{0x3605, 0x00},
+{0x3608, 0x03},
+{0x3609, 0x00},
+{0x360C, 0x01},
+{0x360D, 0x00},
+{0x3610, 0x10},
+{0x3611, 0x01},
+{0x3612, 0x00},
+{0x3613, 0x00},
+{0x3614, 0x00},
+{0x3615, 0x00},
+{0x361C, 0x00},
+{0x361D, 0x01},
+{0x361E, 0x01},
+{0x361F, 0x00},
+{0x3620, 0x00},
+{0x3621, 0x01},
+{0x3622, 0xB0},
+{0x3623, 0x04},
+{0x3624, 0xDC},
+{0x3625, 0x05},
+{0x3626, 0x00},
+{0x3627, 0x01},
+{0x3628, 0xFF},
+{0x3629, 0x0F},
+{0x362A, 0x00},
+{0x362B, 0x10},
+{0x362C, 0x00},
+{0x362D, 0x01},
+{0x3630, 0x42},
+{0x3631, 0x00},
+{0x3632, 0x43},
+{0x3633, 0x00},
+{0x3634, 0x43},
+{0x3635, 0x00},
+{0x3636, 0x43},
+{0x3637, 0x00},
+{0x3638, 0x47},
+{0x3639, 0x00},
+{0x363A, 0x46},
+{0x363B, 0x00},
+{0x363C, 0x45},
+{0x363D, 0x00},
+{0x363E, 0x46},
+{0x363F, 0x00},
+{0x3650, 0x00},  // set to default from 0x01 FSYNC Enable/Disable
+{0x36C4, 0xFF},
+{0x36C5, 0x0F},
+{0x36C6, 0xFF},
+{0x36C7, 0x0F},
+{0x36C8, 0xFF},
+{0x36C9, 0x0F},
+{0x36CC, 0x00},
+{0x36CD, 0x00},
+{0x36CE, 0x00},
+{0x36CF, 0x00},
+{0x36D0, 0x00},
+{0x36D1, 0x00},
+{0x36D4, 0xFF},
+{0x36D5, 0x0F},
+{0x36D6, 0xFF},
+{0x36D7, 0x0F},
+{0x36D8, 0xFF},
+{0x36D9, 0x0F},
+{0x36DC, 0xFF},
+{0x36DD, 0x0F},
+{0x36DE, 0xFF},
+{0x36DF, 0x0F},
+{0x36E0, 0xFF},
+{0x36E1, 0x0F},
+{0x36E4, 0xFF},
+{0x36E5, 0x0F},
+{0x36E6, 0xFF},
+{0x36E7, 0x0F},
+{0x36E8, 0xFF},
+{0x36E9, 0x0F},
+{0x36EE, 0x00},
+{0x36EF, 0x00},
+{0x36F0, 0x00},
+{0x36F1, 0x80},
+{0x36F8, 0x00},
+{0x3700, 0x03},
+{0x3701, 0x05},
+{0x3702, 0x03},
+{0x3703, 0x04},
+{0x3704, 0x08},
+{0x3705, 0x03},
+{0x3706, 0x03},
+{0x3707, 0x03},
+{0x3708, 0x03},
+{0x3709, 0x03},
+{0x370A, 0x03},
+{0x370B, 0x03},
+{0x370C, 0x03},
+{0x370D, 0x03},
+{0x370E, 0x0E},
+{0x3718, 0x62},
+{0x3719, 0x4A},
+{0x371A, 0x38},
+{0x371B, 0x20},
+{0x371C, 0x64},
+{0x371D, 0x42},
+{0x371E, 0x32},
+{0x371F, 0x1B},
+{0x3720, 0x98},
+{0x3721, 0xA0},
+{0x3722, 0xA8},
+{0x3723, 0xB0},
+{0x3748, 0xA5},
+{0x3749, 0x9B},
+{0x374A, 0x91},
+{0x374B, 0x7D},
+{0x37C0, 0x00},
+{0x37C1, 0x00},
+{0x37C2, 0x00},
+{0x37C4, 0x00},
+{0x37C5, 0x00},
+{0x37C6, 0x00},
+{0x37C8, 0x00},
+{0x37C9, 0x00},
+{0x37CA, 0x00},
+{0x37CC, 0x00},
+{0x37CD, 0x00},
+{0x37CE, 0x00},
+{0x37D0, 0x00},
+{0x37D1, 0x00},
+{0x37D2, 0x00},
+{0x37D4, 0x00},
+{0x37D5, 0x00},
+{0x37D6, 0x00},
+{0x37D8, 0x00},
+{0x37D9, 0x00},
+{0x37DA, 0x00},
+{0x37DC, 0x00},
+{0x37DD, 0x00},
+{0x37DE, 0x00},
+{0x37E0, 0x00},
+{0x37E1, 0x00},
+{0x37E2, 0x00},
+{0x37E4, 0x00},
+{0x37E5, 0x00},
+{0x37E6, 0x00},
+{0x37E8, 0x00},
+{0x37E9, 0x00},
+{0x37EA, 0x00},
+{0x37EC, 0x00},
+{0x37ED, 0x00},
+{0x37EE, 0x00},
+{0x37F0, 0x00},
+{0x37F4, 0x00},
+{0x37F5, 0x1E},
+{0x37F6, 0x34},
+{0x37F7, 0x00},
+{0x37F8, 0xFF},
+{0x37F9, 0xFF},
+{0x37FA, 0x03},
+{0x37FC, 0x00},
+{0x37FD, 0x00},
+{0x37FE, 0x04},
+{0x3800, 0xFF},
+{0x3801, 0xFF},
+{0x3802, 0x03},
+{0x3804, 0x00},
+{0x3805, 0x00},
+{0x3806, 0x04},
+{0x3808, 0x00},
+{0x3809, 0x00},
+{0x380A, 0x00},
+{0x380C, 0x00},
+{0x380D, 0x00},
+{0x380E, 0x00},
+{0x3810, 0x00},
+{0x3811, 0x00},
+{0x3812, 0x00},
+{0x3814, 0x00},
+{0x3815, 0x00},
+{0x3816, 0x00},
+{0x3818, 0x00},
+{0x3819, 0x00},
+{0x381A, 0x00},
+{0x381C, 0x00},
+{0x381D, 0x00},
+{0x381E, 0x00},
+{0x3820, 0x00},
+{0x3821, 0x00},
+{0x3822, 0x00},
+{0x3824, 0x00},
+{0x3825, 0x00},
+{0x3826, 0x00},
+{0x3828, 0x00},
+{0x3829, 0x00},
+{0x382A, 0x00},
+{0x382C, 0x00},
+{0x382D, 0x00},
+{0x382E, 0x00},
+{0x3830, 0x00},
+{0x3831, 0x00},
+{0x3832, 0x00},
+{0x3834, 0x00},
+{0x3835, 0x00},
+{0x3836, 0x00},
+{0x3838, 0xE7},
+{0x3839, 0xFF},
+{0x383A, 0x0C},
+{0x383B, 0x00},
+{0x383C, 0xFD},
+{0x383D, 0xFF},
+{0x383E, 0xF7},
+{0x383F, 0xFF},
+{0x3840, 0x00},
+{0x3841, 0x00},
+{0x3842, 0x00},
+{0x3843, 0x00},
+{0x3844, 0x00},
+{0x3845, 0x00},
+{0x3846, 0x00},
+{0x3847, 0x00},
+{0x3848, 0xB6},
+{0x3849, 0xFF},
+{0x384A, 0xB6},
+{0x384B, 0xFF},
+{0x384C, 0xB3},
+{0x384D, 0xFF},
+{0x384E, 0xAF},
+{0x384F, 0xFF},
+{0x3850, 0xFF},
+{0x3851, 0x0F},
+{0x3852, 0x00},
+{0x3853, 0x10},
+{0x3854, 0xFF},
+{0x3855, 0x0F},
+{0x3856, 0x00},
+{0x3857, 0x10},
+{0x3858, 0xFF},
+{0x3859, 0x0F},
+{0x385A, 0x00},
+{0x385B, 0x10},
+{0x385C, 0x02},
+{0x385D, 0x00},
+{0x385E, 0x06},
+{0x385F, 0x00},
+{0x3860, 0x06},
+{0x3861, 0x00},
+{0x3862, 0x08},
+{0x3863, 0x00},
+{0x3864, 0x02},
+{0x3865, 0x00},
+{0x3870, 0x00},
+{0x3871, 0x01},
+{0x38A0, 0x01},
+{0x38A1, 0x01},
+{0x38A2, 0x00},
+{0x38A3, 0x01},
+{0x38A4, 0x03},
+{0x38A5, 0x00},
+{0x38A6, 0x04},
+{0x38A7, 0x04},
+{0x38A8, 0x00},
+{0x38A9, 0x00},
+{0x38AC, 0x00},
+{0x38AD, 0x00},
+{0x38AE, 0x01},
+{0x38B0, 0x02},
+{0x38B2, 0x06},
+{0x38B3, 0x00},
+{0x38B4, 0x02},
+{0x38B5, 0x00},
+{0x38B6, 0x01},
+{0x38B7, 0x00},
+{0x38B8, 0x01},
+{0x38B9, 0x00},
+{0x38BA, 0x20},
+{0x38BB, 0x00},
+{0x38BC, 0x14},
+{0x38BD, 0x00},
+{0x38BE, 0x0C},
+{0x38BF, 0x00},
+{0x38C0, 0x09},
+{0x38C1, 0x00},
+{0x38C2, 0x27},
+{0x38C3, 0x00},
+{0x38C4, 0x20},
+{0x38C5, 0x00},
+{0x38C6, 0x13},
+{0x38C7, 0x00},
+{0x38C8, 0x0C},
+{0x38C9, 0x00},
+{0x38CA, 0x35},
+{0x38CB, 0x00},
+{0x38CC, 0x25},
+{0x38CD, 0x00},
+{0x38CE, 0x1B},
+{0x38CF, 0x00},
+{0x38D0, 0x11},
+{0x38D1, 0x00},
+{0x38D2, 0x4E},
+{0x38D3, 0x00},
+{0x38D4, 0x31},
+{0x38D5, 0x00},
+{0x38D6, 0x25},
+{0x38D7, 0x00},
+{0x38D8, 0x18},
+{0x38D9, 0x00},
+{0x38DA, 0x6E},
+{0x38DB, 0x00},
+{0x38DC, 0x46},
+{0x38DD, 0x00},
+{0x38DE, 0x32},
+{0x38DF, 0x00},
+{0x38E0, 0x22},
+{0x38E1, 0x00},
+{0x38E2, 0x93},
+{0x38E3, 0x00},
+{0x38E4, 0x5F},
+{0x38E5, 0x00},
+{0x38E6, 0x44},
+{0x38E7, 0x00},
+{0x38E8, 0x31},
+{0x38E9, 0x00},
+{0x38EA, 0xD8},
+{0x38EB, 0x00},
+{0x38EC, 0x8D},
+{0x38ED, 0x00},
+{0x38EE, 0x6A},
+{0x38EF, 0x00},
+{0x38F0, 0x49},
+{0x38F1, 0x00},
+{0x38F2, 0x22},
+{0x38F3, 0x01},
+{0x38F4, 0xC8},
+{0x38F5, 0x00},
+{0x38F6, 0x8E},
+{0x38F7, 0x00},
+{0x38F8, 0x60},
+{0x38F9, 0x00},
+{0x38FA, 0x00},
+{0x38FB, 0x01},
+{0x38FC, 0x00},
+{0x38FD, 0x01},
+{0x38FE, 0x00},
+{0x38FF, 0x01},
+{0x3900, 0x00},
+{0x3901, 0x01},
+{0x3902, 0x60},
+{0x3903, 0x00},
+{0x3904, 0x25},
+{0x3905, 0x00},
+{0x3906, 0x18},
+{0x3907, 0x00},
+{0x3908, 0x10},
+{0x3909, 0x00},
+{0x390A, 0xFF},
+{0x390B, 0x00},
+{0x390C, 0xD5},
+{0x390D, 0x00},
+{0x390E, 0xAA},
+{0x390F, 0x00},
+{0x3910, 0x85},
+{0x3911, 0x00},
+{0x3912, 0xFF},
+{0x3913, 0x00},
+{0x3914, 0xD5},
+{0x3915, 0x00},
+{0x3916, 0xAA},
+{0x3917, 0x00},
+{0x3918, 0x85},
+{0x3919, 0x00},
+{0x391A, 0xFF},
+{0x391B, 0x00},
+{0x391C, 0xD5},
+{0x391D, 0x00},
+{0x391E, 0xAA},
+{0x391F, 0x00},
+{0x3920, 0x85},
+{0x3921, 0x00},
+{0x3922, 0x40},
+{0x3923, 0x00},
+{0x3924, 0x40},
+{0x3925, 0x00},
+{0x3926, 0x40},
+{0x3927, 0x00},
+{0x3928, 0x40},
+{0x3929, 0x00},
+{0x392A, 0x80},
+{0x392B, 0x00},
+{0x392C, 0x80},
+{0x392D, 0x00},
+{0x392E, 0x80},
+{0x392F, 0x00},
+{0x3930, 0x80},
+{0x3931, 0x00},
+{0x3932, 0x4C},
+{0x3933, 0x4C},
+{0x3934, 0x4C},
+{0x3940, 0x01},
+{0x3941, 0x01},
+{0x3942, 0x00},
+{0x3943, 0x01},
+{0x3944, 0x03},
+{0x3945, 0x00},
+{0x3946, 0x04},
+{0x3947, 0x04},
+{0x3948, 0x00},
+{0x3949, 0x00},
+{0x394C, 0x00},
+{0x394D, 0x00},
+{0x394E, 0x01},
+{0x3950, 0x03},
+{0x3952, 0x05},
+{0x3953, 0x00},
+{0x3954, 0x02},
+{0x3955, 0x00},
+{0x3956, 0x02},
+{0x3957, 0x00},
+{0x3958, 0x01},
+{0x3959, 0x00},
+{0x395A, 0x12},
+{0x395B, 0x00},
+{0x395C, 0x09},
+{0x395D, 0x00},
+{0x395E, 0x07},
+{0x395F, 0x00},
+{0x3960, 0x04},
+{0x3961, 0x00},
+{0x3962, 0x1A},
+{0x3963, 0x00},
+{0x3964, 0x0E},
+{0x3965, 0x00},
+{0x3966, 0x09},
+{0x3967, 0x00},
+{0x3968, 0x06},
+{0x3969, 0x00},
+{0x396A, 0x21},
+{0x396B, 0x00},
+{0x396C, 0x11},
+{0x396D, 0x00},
+{0x396E, 0x0C},
+{0x396F, 0x00},
+{0x3970, 0x08},
+{0x3971, 0x00},
+{0x3972, 0x29},
+{0x3973, 0x00},
+{0x3974, 0x18},
+{0x3975, 0x00},
+{0x3976, 0x11},
+{0x3977, 0x00},
+{0x3978, 0x0D},
+{0x3979, 0x00},
+{0x397A, 0x3A},
+{0x397B, 0x00},
+{0x397C, 0x21},
+{0x397D, 0x00},
+{0x397E, 0x19},
+{0x397F, 0x00},
+{0x3980, 0x12},
+{0x3981, 0x00},
+{0x3982, 0x52},
+{0x3983, 0x00},
+{0x3984, 0x2F},
+{0x3985, 0x00},
+{0x3986, 0x24},
+{0x3987, 0x00},
+{0x3988, 0x18},
+{0x3989, 0x00},
+{0x398A, 0x78},
+{0x398B, 0x00},
+{0x398C, 0x44},
+{0x398D, 0x00},
+{0x398E, 0x34},
+{0x398F, 0x00},
+{0x3990, 0x27},
+{0x3991, 0x00},
+{0x3992, 0xA1},
+{0x3993, 0x00},
+{0x3994, 0x61},
+{0x3995, 0x00},
+{0x3996, 0x4E},
+{0x3997, 0x00},
+{0x3998, 0x37},
+{0x3999, 0x00},
+{0x399A, 0x00},
+{0x399B, 0x01},
+{0x399C, 0x00},
+{0x399D, 0x01},
+{0x399E, 0x00},
+{0x399F, 0x01},
+{0x39A0, 0x00},
+{0x39A1, 0x01},
+{0x39A2, 0x60},
+{0x39A3, 0x00},
+{0x39A4, 0x20},
+{0x39A5, 0x00},
+{0x39A6, 0x15},
+{0x39A7, 0x00},
+{0x39A8, 0x10},
+{0x39A9, 0x00},
+{0x39AA, 0xFF},
+{0x39AB, 0x00},
+{0x39AC, 0xD5},
+{0x39AD, 0x00},
+{0x39AE, 0xAA},
+{0x39AF, 0x00},
+{0x39B0, 0x85},
+{0x39B1, 0x00},
+{0x39B2, 0xFF},
+{0x39B3, 0x00},
+{0x39B4, 0xD5},
+{0x39B5, 0x00},
+{0x39B6, 0xAA},
+{0x39B7, 0x00},
+{0x39B8, 0x85},
+{0x39B9, 0x00},
+{0x39BA, 0xFF},
+{0x39BB, 0x00},
+{0x39BC, 0xD5},
+{0x39BD, 0x00},
+{0x39BE, 0xAA},
+{0x39BF, 0x00},
+{0x39C0, 0x85},
+{0x39C1, 0x00},
+{0x39C2, 0x40},
+{0x39C3, 0x00},
+{0x39C4, 0x40},
+{0x39C5, 0x00},
+{0x39C6, 0x40},
+{0x39C7, 0x00},
+{0x39C8, 0x40},
+{0x39C9, 0x00},
+{0x39CA, 0x80},
+{0x39CB, 0x00},
+{0x39CC, 0x80},
+{0x39CD, 0x00},
+{0x39CE, 0x80},
+{0x39CF, 0x00},
+{0x39D0, 0x80},
+{0x39D1, 0x00},
+{0x39D2, 0x4C},
+{0x39D3, 0x4C},
+{0x39D4, 0x4C},
+{0x39E0, 0x01},
+{0x39E1, 0x01},
+{0x39E4, 0x40},
+{0x39E5, 0x01},
+{0x39E6, 0x01},
+{0x39E8, 0x00},
+{0x39E9, 0x01},
+{0x39EA, 0x00},
+{0x39EB, 0x00},
+{0x39EC, 0x01},
+{0x39ED, 0x00},
+{0x39EE, 0x01},
+{0x39F0, 0x03},
+{0x39F1, 0x04},
+{0x39F2, 0x0E},
+{0x39F4, 0x0B},
+{0x39F5, 0x00},
+{0x39F6, 0x07},
+{0x39F7, 0x00},
+{0x39F8, 0x05},
+{0x39F9, 0x00},
+{0x39FA, 0x02},
+{0x39FB, 0x00},
+{0x39FC, 0x34},
+{0x39FD, 0x00},
+{0x39FE, 0x1B},
+{0x39FF, 0x00},
+{0x3A00, 0x13},
+{0x3A01, 0x00},
+{0x3A02, 0x09},
+{0x3A03, 0x00},
+{0x3A04, 0x4D},
+{0x3A05, 0x00},
+{0x3A06, 0x22},
+{0x3A07, 0x00},
+{0x3A08, 0x14},
+{0x3A09, 0x00},
+{0x3A0A, 0x09},
+{0x3A0B, 0x00},
+{0x3A0C, 0x61},
+{0x3A0D, 0x00},
+{0x3A0E, 0x22},
+{0x3A0F, 0x00},
+{0x3A10, 0x15},
+{0x3A11, 0x00},
+{0x3A12, 0x0A},
+{0x3A13, 0x00},
+{0x3A14, 0x6D},
+{0x3A15, 0x00},
+{0x3A16, 0x24},
+{0x3A17, 0x00},
+{0x3A18, 0x16},
+{0x3A19, 0x00},
+{0x3A1A, 0x0B},
+{0x3A1B, 0x00},
+{0x3A1C, 0x6F},
+{0x3A1D, 0x00},
+{0x3A1E, 0x26},
+{0x3A1F, 0x00},
+{0x3A20, 0x18},
+{0x3A21, 0x00},
+{0x3A22, 0x0E},
+{0x3A23, 0x00},
+{0x3A24, 0x72},
+{0x3A25, 0x00},
+{0x3A26, 0x2B},
+{0x3A27, 0x00},
+{0x3A28, 0x1E},
+{0x3A29, 0x00},
+{0x3A2A, 0x13},
+{0x3A2B, 0x00},
+{0x3A2C, 0x7B},
+{0x3A2D, 0x00},
+{0x3A2E, 0x37},
+{0x3A2F, 0x00},
+{0x3A30, 0x29},
+{0x3A31, 0x00},
+{0x3A32, 0x1F},
+{0x3A33, 0x00},
+{0x3A34, 0x94},
+{0x3A35, 0x00},
+{0x3A36, 0x4E},
+{0x3A37, 0x00},
+{0x3A38, 0x42},
+{0x3A39, 0x00},
+{0x3A3A, 0x36},
+{0x3A3B, 0x00},
+{0x3A3C, 0x00},
+{0x3A3D, 0x01},
+{0x3A3E, 0x00},
+{0x3A3F, 0x01},
+{0x3A40, 0x00},
+{0x3A41, 0x01},
+{0x3A42, 0x00},
+{0x3A43, 0x01},
+{0x3A44, 0x70},
+{0x3A45, 0x00},
+{0x3A46, 0x25},
+{0x3A47, 0x00},
+{0x3A48, 0x18},
+{0x3A49, 0x00},
+{0x3A4A, 0x10},
+{0x3A4B, 0x00},
+{0x3A4C, 0xFF},
+{0x3A4D, 0x00},
+{0x3A4E, 0xD5},
+{0x3A4F, 0x00},
+{0x3A50, 0xAA},
+{0x3A51, 0x00},
+{0x3A52, 0x85},
+{0x3A53, 0x00},
+{0x3A54, 0xFF},
+{0x3A55, 0x00},
+{0x3A56, 0xD5},
+{0x3A57, 0x00},
+{0x3A58, 0xAA},
+{0x3A59, 0x00},
+{0x3A5A, 0x85},
+{0x3A5B, 0x00},
+{0x3A5C, 0xFF},
+{0x3A5D, 0x00},
+{0x3A5E, 0xD5},
+{0x3A5F, 0x00},
+{0x3A60, 0xAA},
+{0x3A61, 0x00},
+{0x3A62, 0x85},
+{0x3A63, 0x00},
+{0x3A64, 0x1C},
+{0x3A65, 0x00},
+{0x3A66, 0x13},
+{0x3A67, 0x00},
+{0x3A68, 0x0D},
+{0x3A69, 0x00},
+{0x3A6A, 0x07},
+{0x3A6B, 0x00},
+{0x3A6C, 0x0D},
+{0x3A6D, 0x00},
+{0x3A6E, 0x0B},
+{0x3A6F, 0x00},
+{0x3A70, 0x06},
+{0x3A71, 0x00},
+{0x3A72, 0x05},
+{0x3A73, 0x00},
+{0x3A74, 0x19},
+{0x3A75, 0x00},
+{0x3A76, 0x14},
+{0x3A77, 0x00},
+{0x3A78, 0x0F},
+{0x3A79, 0x00},
+{0x3A7A, 0x0A},
+{0x3A7B, 0x00},
+{0x3A7C, 0x80},
+{0x3A7D, 0x00},
+{0x3A7E, 0x80},
+{0x3A7F, 0x00},
+{0x3A80, 0x80},
+{0x3A81, 0x00},
+{0x3A82, 0x80},
+{0x3A83, 0x00},
+{0x3A84, 0x08},
+{0x3A85, 0x00},
+{0x3A86, 0x05},
+{0x3A87, 0x00},
+{0x3A88, 0x04},
+{0x3A89, 0x00},
+{0x3A8A, 0x03},
+{0x3A8B, 0x00},
+{0x3A8C, 0xCD},
+{0x3A8D, 0x00},
+{0x3A8E, 0xAA},
+{0x3A8F, 0x00},
+{0x3A90, 0x8C},
+{0x3A91, 0x00},
+{0x3A92, 0x64},
+{0x3A93, 0x00},
+{0x3A94, 0xCD},
+{0x3A95, 0x00},
+{0x3A96, 0xAA},
+{0x3A97, 0x00},
+{0x3A98, 0x8C},
+{0x3A99, 0x00},
+{0x3A9A, 0x64},
+{0x3A9B, 0x00},
+{0x3A9C, 0x08},
+{0x3A9D, 0x10},
+{0x3A9E, 0x4C},
+{0x3A9F, 0x4C},
+{0x3AA0, 0x4C},
+{0x3AA1, 0x04},
+{0x3AA2, 0x04},
+{0x3AC0, 0x01},
+{0x3AC4, 0x81},
+{0x3AC5, 0x00},
+{0x3AC6, 0x00},
+{0x3AC7, 0x00},
+{0x3AC8, 0x00},
+{0x3AC9, 0x00},
+{0x3ACA, 0x00},
+{0x3ACB, 0x00},
+{0x3ACC, 0x02},
+{0x3ACD, 0x00},
+{0x3ACE, 0x81},
+{0x3ACF, 0x00},
+{0x3AD0, 0x00},
+{0x3AD1, 0x00},
+{0x3AD2, 0xFD},
+{0x3AD3, 0x03},
+{0x3AD4, 0x02},
+{0x3AD5, 0x00},
+{0x3AD6, 0x00},
+{0x3AD7, 0x00},
+{0x3AD8, 0x81},
+{0x3AD9, 0x00},
+{0x3ADA, 0xFD},
+{0x3ADB, 0x03},
+{0x3ADC, 0xFF},
+{0x3ADD, 0x03},
+{0x3ADE, 0x01},
+{0x3ADF, 0x00},
+{0x3AE0, 0x01},
+{0x3AE1, 0x00},
+{0x3AE2, 0x7E},
+{0x3AE3, 0x00},
+{0x3AF4, 0x00},
+{0x3AF6, 0x40},
+{0x3AF7, 0x1E},
+{0x3AF8, 0x00},
+{0x3AFA, 0x00},
+{0x3AFB, 0x00},
+{0x3AFC, 0x00},
+{0x3AFD, 0x00},
+{0x3AFE, 0x00},
+{0x3AFF, 0x00},
+{0x3B00, 0x00},
+{0x3B01, 0x00},
+{0x3B02, 0x00},
+{0x3B03, 0x00},
+{0x3B04, 0x00},
+{0x3B05, 0x00},
+{0x3B06, 0x00},
+{0x3B07, 0x00},
+{0x3B08, 0x00},
+{0x3B09, 0x00},
+{0x3B0A, 0x00},
+{0x3B0B, 0x00},
+{0x3B0C, 0x00},
+{0x3B0D, 0x00},
+{0x3B0E, 0x00},
+{0x3B0F, 0x00},
+{0x3B10, 0x00},
+{0x3B11, 0x00},
+{0x3B12, 0x00},
+{0x3B13, 0x00},
+{0x3B14, 0x00},
+{0x3B15, 0x00},
+{0x3B16, 0x00},
+{0x3B17, 0x00},
+{0x3B18, 0x00},
+{0x3B19, 0x00},
+{0x3B1A, 0x00},
+{0x3B1B, 0x00},
+{0x3B1C, 0x00},
+{0x3B1D, 0x00},
+{0x3B1E, 0x00},
+{0x3B1F, 0x00},
+{0x3B20, 0x00},
+{0x3B21, 0x00},
+{0x3B22, 0x00},
+{0x3B23, 0x00},
+{0x3B24, 0x00},
+{0x3B25, 0x00},
+{0x3B26, 0x00},
+{0x3B27, 0x00},
+{0x3B28, 0x00},
+{0x3B29, 0x00},
+{0x3B2A, 0x00},
+{0x3B2C, 0x00},
+{0x3B2E, 0x00},
+{0x3B30, 0x00},
+{0x3B32, 0x0C},
+{0x4000, 0xD0},
+{0x4001, 0xC8},
+{0x4002, 0xC8},
+{0x4003, 0xC6},
+{0x4004, 0xBA},
+{0x4005, 0xB5},
+{0x4006, 0xB5},
+{0x4007, 0xB4},
+{0x4008, 0xAA},
+{0x4009, 0xA7},
+{0x400A, 0xA7},
+{0x400B, 0xA7},
+{0x400C, 0xA1},
+{0x400D, 0x9F},
+{0x400E, 0x9F},
+{0x400F, 0x9F},
+{0x4010, 0x9C},
+{0x4011, 0x9B},
+{0x4012, 0x9B},
+{0x4013, 0x9B},
+{0x4014, 0x9F},
+{0x4015, 0x9E},
+{0x4016, 0x9D},
+{0x4017, 0x9E},
+{0x4018, 0xA7},
+{0x4019, 0xA4},
+{0x401A, 0xA4},
+{0x401B, 0xA4},
+{0x401C, 0xB5},
+{0x401D, 0xB0},
+{0x401E, 0xB0},
+{0x401F, 0xB0},
+{0x4020, 0xC9},
+{0x4021, 0xC1},
+{0x4022, 0xC1},
+{0x4023, 0xC0},
+{0x4024, 0xC3},
+{0x4025, 0xBB},
+{0x4026, 0xBC},
+{0x4027, 0xBA},
+{0x4028, 0xA5},
+{0x4029, 0xA1},
+{0x402A, 0xA1},
+{0x402B, 0xA0},
+{0x402C, 0x99},
+{0x402D, 0x97},
+{0x402E, 0x97},
+{0x402F, 0x96},
+{0x4030, 0x8F},
+{0x4031, 0x8E},
+{0x4032, 0x8E},
+{0x4033, 0x8E},
+{0x4034, 0x8A},
+{0x4035, 0x8A},
+{0x4036, 0x8A},
+{0x4037, 0x8A},
+{0x4038, 0x8D},
+{0x4039, 0x8D},
+{0x403A, 0x8D},
+{0x403B, 0x8D},
+{0x403C, 0x96},
+{0x403D, 0x94},
+{0x403E, 0x94},
+{0x403F, 0x94},
+{0x4040, 0xA2},
+{0x4041, 0x9E},
+{0x4042, 0x9E},
+{0x4043, 0x9D},
+{0x4044, 0xBC},
+{0x4045, 0xB5},
+{0x4046, 0xB5},
+{0x4047, 0xB4},
+{0x4048, 0xBC},
+{0x4049, 0xB5},
+{0x404A, 0xB5},
+{0x404B, 0xB3},
+{0x404C, 0xA3},
+{0x404D, 0x9F},
+{0x404E, 0x9F},
+{0x404F, 0x9E},
+{0x4050, 0x95},
+{0x4051, 0x93},
+{0x4052, 0x93},
+{0x4053, 0x93},
+{0x4054, 0x89},
+{0x4055, 0x88},
+{0x4056, 0x88},
+{0x4057, 0x88},
+{0x4058, 0x81},
+{0x4059, 0x81},
+{0x405A, 0x81},
+{0x405B, 0x81},
+{0x405C, 0x86},
+{0x405D, 0x86},
+{0x405E, 0x86},
+{0x405F, 0x86},
+{0x4060, 0x92},
+{0x4061, 0x90},
+{0x4062, 0x90},
+{0x4063, 0x90},
+{0x4064, 0x9E},
+{0x4065, 0x9B},
+{0x4066, 0x9B},
+{0x4067, 0x9A},
+{0x4068, 0xB5},
+{0x4069, 0xAE},
+{0x406A, 0xAE},
+{0x406B, 0xAE},
+{0x406C, 0xBE},
+{0x406D, 0xB6},
+{0x406E, 0xB7},
+{0x406F, 0xB5},
+{0x4070, 0xA4},
+{0x4071, 0xA0},
+{0x4072, 0xA0},
+{0x4073, 0x9F},
+{0x4074, 0x96},
+{0x4075, 0x94},
+{0x4076, 0x94},
+{0x4077, 0x94},
+{0x4078, 0x8A},
+{0x4079, 0x8A},
+{0x407A, 0x8A},
+{0x407B, 0x8A},
+{0x407C, 0x83},
+{0x407D, 0x83},
+{0x407E, 0x83},
+{0x407F, 0x83},
+{0x4080, 0x88},
+{0x4081, 0x87},
+{0x4082, 0x87},
+{0x4083, 0x88},
+{0x4084, 0x93},
+{0x4085, 0x91},
+{0x4086, 0x91},
+{0x4087, 0x91},
+{0x4088, 0xA0},
+{0x4089, 0x9C},
+{0x408A, 0x9C},
+{0x408B, 0x9C},
+{0x408C, 0xB6},
+{0x408D, 0xAF},
+{0x408E, 0xAF},
+{0x408F, 0xAF},
+{0x4090, 0xCA},
+{0x4091, 0xC1},
+{0x4092, 0xC1},
+{0x4093, 0xBF},
+{0x4094, 0xAB},
+{0x4095, 0xA5},
+{0x4096, 0xA5},
+{0x4097, 0xA4},
+{0x4098, 0x9E},
+{0x4099, 0x9A},
+{0x409A, 0x9A},
+{0x409B, 0x9A},
+{0x409C, 0x94},
+{0x409D, 0x92},
+{0x409E, 0x92},
+{0x409F, 0x92},
+{0x40A0, 0x8F},
+{0x40A1, 0x8E},
+{0x40A2, 0x8E},
+{0x40A3, 0x8E},
+{0x40A4, 0x92},
+{0x40A5, 0x90},
+{0x40A6, 0x90},
+{0x40A7, 0x90},
+{0x40A8, 0x9A},
+{0x40A9, 0x97},
+{0x40AA, 0x97},
+{0x40AB, 0x97},
+{0x40AC, 0xA6},
+{0x40AD, 0xA0},
+{0x40AE, 0xA0},
+{0x40AF, 0xA0},
+{0x40B0, 0xC1},
+{0x40B1, 0xB9},
+{0x40B2, 0xB9},
+{0x40B3, 0xB8},
+{0x40B4, 0xDD},
+{0x40B5, 0xD2},
+{0x40B6, 0xD2},
+{0x40B7, 0xCF},
+{0x40B8, 0xC6},
+{0x40B9, 0xBF},
+{0x40BA, 0xBF},
+{0x40BB, 0xBD},
+{0x40BC, 0xB5},
+{0x40BD, 0xB0},
+{0x40BE, 0xB0},
+{0x40BF, 0xAF},
+{0x40C0, 0xAB},
+{0x40C1, 0xA8},
+{0x40C2, 0xA8},
+{0x40C3, 0xA7},
+{0x40C4, 0xA7},
+{0x40C5, 0xA3},
+{0x40C6, 0xA3},
+{0x40C7, 0xA3},
+{0x40C8, 0xA9},
+{0x40C9, 0xA6},
+{0x40CA, 0xA6},
+{0x40CB, 0xA6},
+{0x40CC, 0xB0},
+{0x40CD, 0xAB},
+{0x40CE, 0xAB},
+{0x40CF, 0xAB},
+{0x40D0, 0xBF},
+{0x40D1, 0xB7},
+{0x40D2, 0xB7},
+{0x40D3, 0xB7},
+{0x40D4, 0xD2},
+{0x40D5, 0xC8},
+{0x40D6, 0xC7},
+{0x40D7, 0xC7},
+{0x4100, 0x80},
+{0x4101, 0x80},
+{0x4102, 0x80},
+{0x4103, 0x80},
+{0x4104, 0x80},
+{0x4105, 0x80},
+{0x4106, 0x80},
+{0x4107, 0x80},
+{0x4108, 0x80},
+{0x4109, 0x80},
+{0x410A, 0x80},
+{0x410B, 0x80},
+{0x410C, 0x80},
+{0x410D, 0x80},
+{0x410E, 0x80},
+{0x410F, 0x80},
+{0x4110, 0x80},
+{0x4111, 0x80},
+{0x4112, 0x80},
+{0x4113, 0x80},
+{0x4114, 0x80},
+{0x4115, 0x80},
+{0x4116, 0x80},
+{0x4117, 0x80},
+{0x4118, 0x80},
+{0x4119, 0x80},
+{0x411A, 0x80},
+{0x411B, 0x80},
+{0x411C, 0x80},
+{0x411D, 0x80},
+{0x411E, 0x80},
+{0x411F, 0x80},
+{0x4120, 0x80},
+{0x4121, 0x80},
+{0x4122, 0x80},
+{0x4123, 0x80},
+{0x4124, 0x80},
+{0x4125, 0x80},
+{0x4126, 0x80},
+{0x4127, 0x80},
+{0x4128, 0x80},
+{0x4129, 0x80},
+{0x412A, 0x80},
+{0x412B, 0x80},
+{0x412C, 0x80},
+{0x412D, 0x80},
+{0x412E, 0x80},
+{0x412F, 0x80},
+{0x4130, 0x80},
+{0x4131, 0x80},
+{0x4132, 0x80},
+{0x4133, 0x80},
+{0x4134, 0x80},
+{0x4135, 0x80},
+{0x4136, 0x80},
+{0x4137, 0x80},
+{0x4138, 0x80},
+{0x4139, 0x80},
+{0x413A, 0x80},
+{0x413B, 0x80},
+{0x413C, 0x80},
+{0x413D, 0x80},
+{0x413E, 0x80},
+{0x413F, 0x80},
+{0x4140, 0x80},
+{0x4141, 0x80},
+{0x4142, 0x80},
+{0x4143, 0x80},
+{0x4144, 0x80},
+{0x4145, 0x80},
+{0x4146, 0x80},
+{0x4147, 0x80},
+{0x4148, 0x80},
+{0x4149, 0x80},
+{0x414A, 0x80},
+{0x414B, 0x80},
+{0x414C, 0x80},
+{0x414D, 0x80},
+{0x414E, 0x80},
+{0x414F, 0x80},
+{0x4150, 0x80},
+{0x4151, 0x80},
+{0x4152, 0x80},
+{0x4153, 0x80},
+{0x4154, 0x80},
+{0x4155, 0x80},
+{0x4156, 0x80},
+{0x4157, 0x80},
+{0x4158, 0x80},
+{0x4159, 0x80},
+{0x415A, 0x80},
+{0x415B, 0x80},
+{0x415C, 0x80},
+{0x415D, 0x80},
+{0x415E, 0x80},
+{0x415F, 0x80},
+{0x4160, 0x80},
+{0x4161, 0x80},
+{0x4162, 0x80},
+{0x4163, 0x80},
+{0x4164, 0x80},
+{0x4165, 0x80},
+{0x4166, 0x80},
+{0x4167, 0x80},
+{0x4168, 0x80},
+{0x4169, 0x80},
+{0x416A, 0x80},
+{0x416B, 0x80},
+{0x416C, 0x80},
+{0x416D, 0x80},
+{0x416E, 0x80},
+{0x416F, 0x80},
+{0x4170, 0x80},
+{0x4171, 0x80},
+{0x4172, 0x80},
+{0x4173, 0x80},
+{0x4174, 0x80},
+{0x4175, 0x80},
+{0x4176, 0x80},
+{0x4177, 0x80},
+{0x4178, 0x80},
+{0x4179, 0x80},
+{0x417A, 0x80},
+{0x417B, 0x80},
+{0x417C, 0x80},
+{0x417D, 0x80},
+{0x417E, 0x80},
+{0x417F, 0x80},
+{0x4180, 0x80},
+{0x4181, 0x80},
+{0x4182, 0x80},
+{0x4183, 0x80},
+{0x4184, 0x80},
+{0x4185, 0x80},
+{0x4186, 0x80},
+{0x4187, 0x80},
+{0x4188, 0x80},
+{0x4189, 0x80},
+{0x418A, 0x80},
+{0x418B, 0x80},
+{0x418C, 0x80},
+{0x418D, 0x80},
+{0x418E, 0x80},
+{0x418F, 0x80},
+{0x4190, 0x80},
+{0x4191, 0x80},
+{0x4192, 0x80},
+{0x4193, 0x80},
+{0x4194, 0x80},
+{0x4195, 0x80},
+{0x4196, 0x80},
+{0x4197, 0x80},
+{0x4198, 0x80},
+{0x4199, 0x80},
+{0x419A, 0x80},
+{0x419B, 0x80},
+{0x419C, 0x80},
+{0x419D, 0x80},
+{0x419E, 0x80},
+{0x419F, 0x80},
+{0x41A0, 0x80},
+{0x41A1, 0x80},
+{0x41A2, 0x80},
+{0x41A3, 0x80},
+{0x41A4, 0x80},
+{0x41A5, 0x80},
+{0x41A6, 0x80},
+{0x41A7, 0x80},
+{0x41A8, 0x80},
+{0x41A9, 0x80},
+{0x41AA, 0x80},
+{0x41AB, 0x80},
+{0x41AC, 0x80},
+{0x41AD, 0x80},
+{0x41AE, 0x80},
+{0x41AF, 0x80},
+{0x41B0, 0x80},
+{0x41B1, 0x80},
+{0x41B2, 0x80},
+{0x41B3, 0x80},
+{0x41B4, 0x80},
+{0x41B5, 0x80},
+{0x41B6, 0x80},
+{0x41B7, 0x80},
+{0x41B8, 0x80},
+{0x41B9, 0x80},
+{0x41BA, 0x80},
+{0x41BB, 0x80},
+{0x41BC, 0x80},
+{0x41BD, 0x80},
+{0x41BE, 0x80},
+{0x41BF, 0x80},
+{0x41C0, 0x80},
+{0x41C1, 0x80},
+{0x41C2, 0x80},
+{0x41C3, 0x80},
+{0x41C4, 0x80},
+{0x41C5, 0x80},
+{0x41C6, 0x80},
+{0x41C7, 0x80},
+{0x41C8, 0x80},
+{0x41C9, 0x80},
+{0x41CA, 0x80},
+{0x41CB, 0x80},
+{0x41CC, 0x80},
+{0x41CD, 0x80},
+{0x41CE, 0x80},
+{0x41CF, 0x80},
+{0x41D0, 0x80},
+{0x41D1, 0x80},
+{0x41D2, 0x80},
+{0x41D3, 0x80},
+{0x41D4, 0x80},
+{0x41D5, 0x80},
+{0x41D6, 0x80},
+{0x41D7, 0x80},
+{0x4200, 0x80},
+{0x4201, 0x80},
+{0x4202, 0x80},
+{0x4203, 0x80},
+{0x4204, 0x80},
+{0x4205, 0x80},
+{0x4206, 0x80},
+{0x4207, 0x80},
+{0x4208, 0x80},
+{0x4209, 0x80},
+{0x420A, 0x80},
+{0x420B, 0x80},
+{0x420C, 0x80},
+{0x420D, 0x80},
+{0x420E, 0x80},
+{0x420F, 0x80},
+{0x4210, 0x80},
+{0x4211, 0x80},
+{0x4212, 0x80},
+{0x4213, 0x80},
+{0x4214, 0x80},
+{0x4215, 0x80},
+{0x4216, 0x80},
+{0x4217, 0x80},
+{0x4218, 0x80},
+{0x4219, 0x80},
+{0x421A, 0x80},
+{0x421B, 0x80},
+{0x421C, 0x80},
+{0x421D, 0x80},
+{0x421E, 0x80},
+{0x421F, 0x80},
+{0x4220, 0x80},
+{0x4221, 0x80},
+{0x4222, 0x80},
+{0x4223, 0x80},
+{0x4224, 0x80},
+{0x4225, 0x80},
+{0x4226, 0x80},
+{0x4227, 0x80},
+{0x4228, 0x80},
+{0x4229, 0x80},
+{0x422A, 0x80},
+{0x422B, 0x80},
+{0x422C, 0x80},
+{0x422D, 0x80},
+{0x422E, 0x80},
+{0x422F, 0x80},
+{0x4230, 0x80},
+{0x4231, 0x80},
+{0x4232, 0x80},
+{0x4233, 0x80},
+{0x4234, 0x80},
+{0x4235, 0x80},
+{0x4236, 0x80},
+{0x4237, 0x80},
+{0x4238, 0x80},
+{0x4239, 0x80},
+{0x423A, 0x80},
+{0x423B, 0x80},
+{0x423C, 0x80},
+{0x423D, 0x80},
+{0x423E, 0x80},
+{0x423F, 0x80},
+{0x4240, 0x80},
+{0x4241, 0x80},
+{0x4242, 0x80},
+{0x4243, 0x80},
+{0x4244, 0x80},
+{0x4245, 0x80},
+{0x4246, 0x80},
+{0x4247, 0x80},
+{0x4248, 0x80},
+{0x4249, 0x80},
+{0x424A, 0x80},
+{0x424B, 0x80},
+{0x424C, 0x80},
+{0x424D, 0x80},
+{0x424E, 0x80},
+{0x424F, 0x80},
+{0x4250, 0x80},
+{0x4251, 0x80},
+{0x4252, 0x80},
+{0x4253, 0x80},
+{0x4254, 0x80},
+{0x4255, 0x80},
+{0x4256, 0x80},
+{0x4257, 0x80},
+{0x4258, 0x80},
+{0x4259, 0x80},
+{0x425A, 0x80},
+{0x425B, 0x80},
+{0x425C, 0x80},
+{0x425D, 0x80},
+{0x425E, 0x80},
+{0x425F, 0x80},
+{0x4260, 0x80},
+{0x4261, 0x80},
+{0x4262, 0x80},
+{0x4263, 0x80},
+{0x4264, 0x80},
+{0x4265, 0x80},
+{0x4266, 0x80},
+{0x4267, 0x80},
+{0x4268, 0x80},
+{0x4269, 0x80},
+{0x426A, 0x80},
+{0x426B, 0x80},
+{0x426C, 0x80},
+{0x426D, 0x80},
+{0x426E, 0x80},
+{0x426F, 0x80},
+{0x4270, 0x80},
+{0x4271, 0x80},
+{0x4272, 0x80},
+{0x4273, 0x80},
+{0x4274, 0x80},
+{0x4275, 0x80},
+{0x4276, 0x80},
+{0x4277, 0x80},
+{0x4278, 0x80},
+{0x4279, 0x80},
+{0x427A, 0x80},
+{0x427B, 0x80},
+{0x427C, 0x80},
+{0x427D, 0x80},
+{0x427E, 0x80},
+{0x427F, 0x80},
+{0x4280, 0x80},
+{0x4281, 0x80},
+{0x4282, 0x80},
+{0x4283, 0x80},
+{0x4284, 0x80},
+{0x4285, 0x80},
+{0x4286, 0x80},
+{0x4287, 0x80},
+{0x4288, 0x80},
+{0x4289, 0x80},
+{0x428A, 0x80},
+{0x428B, 0x80},
+{0x428C, 0x80},
+{0x428D, 0x80},
+{0x428E, 0x80},
+{0x428F, 0x80},
+{0x4290, 0x80},
+{0x4291, 0x80},
+{0x4292, 0x80},
+{0x4293, 0x80},
+{0x4294, 0x80},
+{0x4295, 0x80},
+{0x4296, 0x80},
+{0x4297, 0x80},
+{0x4298, 0x80},
+{0x4299, 0x80},
+{0x429A, 0x80},
+{0x429B, 0x80},
+{0x429C, 0x80},
+{0x429D, 0x80},
+{0x429E, 0x80},
+{0x429F, 0x80},
+{0x42A0, 0x80},
+{0x42A1, 0x80},
+{0x42A2, 0x80},
+{0x42A3, 0x80},
+{0x42A4, 0x80},
+{0x42A5, 0x80},
+{0x42A6, 0x80},
+{0x42A7, 0x80},
+{0x42A8, 0x80},
+{0x42A9, 0x80},
+{0x42AA, 0x80},
+{0x42AB, 0x80},
+{0x42AC, 0x80},
+{0x42AD, 0x80},
+{0x42AE, 0x80},
+{0x42AF, 0x80},
+{0x42B0, 0x80},
+{0x42B1, 0x80},
+{0x42B2, 0x80},
+{0x42B3, 0x80},
+{0x42B4, 0x80},
+{0x42B5, 0x80},
+{0x42B6, 0x80},
+{0x42B7, 0x80},
+{0x42B8, 0x80},
+{0x42B9, 0x80},
+{0x42BA, 0x80},
+{0x42BB, 0x80},
+{0x42BC, 0x80},
+{0x42BD, 0x80},
+{0x42BE, 0x80},
+{0x42BF, 0x80},
+{0x42C0, 0x80},
+{0x42C1, 0x80},
+{0x42C2, 0x80},
+{0x42C3, 0x80},
+{0x42C4, 0x80},
+{0x42C5, 0x80},
+{0x42C6, 0x80},
+{0x42C7, 0x80},
+{0x42C8, 0x80},
+{0x42C9, 0x80},
+{0x42CA, 0x80},
+{0x42CB, 0x80},
+{0x42CC, 0x80},
+{0x42CD, 0x80},
+{0x42CE, 0x80},
+{0x42CF, 0x80},
+{0x42D0, 0x80},
+{0x42D1, 0x80},
+{0x42D2, 0x80},
+{0x42D3, 0x80},
+{0x42D4, 0x80},
+{0x42D5, 0x80},
+{0x42D6, 0x80},
+{0x42D7, 0x80},
+{0x42D8, 0x00},
+{0x42D9, 0x00},
+{0x4300, 0x8C},
+{0x4301, 0x88},
+{0x4302, 0x88},
+{0x4303, 0x8A},
+{0x4304, 0x88},
+{0x4305, 0x84},
+{0x4306, 0x84},
+{0x4307, 0x86},
+{0x4308, 0x84},
+{0x4309, 0x82},
+{0x430A, 0x82},
+{0x430B, 0x82},
+{0x430C, 0x81},
+{0x430D, 0x7F},
+{0x430E, 0x7F},
+{0x430F, 0x80},
+{0x4310, 0x7F},
+{0x4311, 0x7F},
+{0x4312, 0x7F},
+{0x4313, 0x80},
+{0x4314, 0x80},
+{0x4315, 0x80},
+{0x4316, 0x7F},
+{0x4317, 0x80},
+{0x4318, 0x83},
+{0x4319, 0x82},
+{0x431A, 0x82},
+{0x431B, 0x82},
+{0x431C, 0x83},
+{0x431D, 0x83},
+{0x431E, 0x83},
+{0x431F, 0x83},
+{0x4320, 0x88},
+{0x4321, 0x87},
+{0x4322, 0x86},
+{0x4323, 0x88},
+{0x4324, 0x8A},
+{0x4325, 0x86},
+{0x4326, 0x86},
+{0x4327, 0x88},
+{0x4328, 0x85},
+{0x4329, 0x82},
+{0x432A, 0x82},
+{0x432B, 0x84},
+{0x432C, 0x81},
+{0x432D, 0x80},
+{0x432E, 0x80},
+{0x432F, 0x81},
+{0x4330, 0x80},
+{0x4331, 0x7F},
+{0x4332, 0x7F},
+{0x4333, 0x80},
+{0x4334, 0x7F},
+{0x4335, 0x7F},
+{0x4336, 0x7F},
+{0x4337, 0x80},
+{0x4338, 0x80},
+{0x4339, 0x7F},
+{0x433A, 0x7F},
+{0x433B, 0x80},
+{0x433C, 0x81},
+{0x433D, 0x80},
+{0x433E, 0x80},
+{0x433F, 0x81},
+{0x4340, 0x82},
+{0x4341, 0x82},
+{0x4342, 0x82},
+{0x4343, 0x83},
+{0x4344, 0x85},
+{0x4345, 0x85},
+{0x4346, 0x85},
+{0x4347, 0x86},
+{0x4348, 0x88},
+{0x4349, 0x86},
+{0x434A, 0x86},
+{0x434B, 0x87},
+{0x434C, 0x84},
+{0x434D, 0x82},
+{0x434E, 0x82},
+{0x434F, 0x83},
+{0x4350, 0x81},
+{0x4351, 0x80},
+{0x4352, 0x80},
+{0x4353, 0x81},
+{0x4354, 0x80},
+{0x4355, 0x7F},
+{0x4356, 0x7F},
+{0x4357, 0x80},
+{0x4358, 0x80},
+{0x4359, 0x80},
+{0x435A, 0x80},
+{0x435B, 0x80},
+{0x435C, 0x80},
+{0x435D, 0x80},
+{0x435E, 0x80},
+{0x435F, 0x80},
+{0x4360, 0x80},
+{0x4361, 0x80},
+{0x4362, 0x80},
+{0x4363, 0x80},
+{0x4364, 0x82},
+{0x4365, 0x82},
+{0x4366, 0x82},
+{0x4367, 0x83},
+{0x4368, 0x87},
+{0x4369, 0x86},
+{0x436A, 0x86},
+{0x436B, 0x87},
+{0x436C, 0x89},
+{0x436D, 0x87},
+{0x436E, 0x87},
+{0x436F, 0x88},
+{0x4370, 0x85},
+{0x4371, 0x83},
+{0x4372, 0x83},
+{0x4373, 0x84},
+{0x4374, 0x82},
+{0x4375, 0x81},
+{0x4376, 0x81},
+{0x4377, 0x81},
+{0x4378, 0x80},
+{0x4379, 0x80},
+{0x437A, 0x80},
+{0x437B, 0x80},
+{0x437C, 0x80},
+{0x437D, 0x80},
+{0x437E, 0x80},
+{0x437F, 0x80},
+{0x4380, 0x80},
+{0x4381, 0x80},
+{0x4382, 0x80},
+{0x4383, 0x80},
+{0x4384, 0x81},
+{0x4385, 0x81},
+{0x4386, 0x81},
+{0x4387, 0x80},
+{0x4388, 0x83},
+{0x4389, 0x83},
+{0x438A, 0x83},
+{0x438B, 0x83},
+{0x438C, 0x87},
+{0x438D, 0x87},
+{0x438E, 0x86},
+{0x438F, 0x86},
+{0x4390, 0x8C},
+{0x4391, 0x88},
+{0x4392, 0x89},
+{0x4393, 0x8C},
+{0x4394, 0x87},
+{0x4395, 0x85},
+{0x4396, 0x85},
+{0x4397, 0x86},
+{0x4398, 0x83},
+{0x4399, 0x82},
+{0x439A, 0x82},
+{0x439B, 0x83},
+{0x439C, 0x81},
+{0x439D, 0x81},
+{0x439E, 0x81},
+{0x439F, 0x81},
+{0x43A0, 0x81},
+{0x43A1, 0x81},
+{0x43A2, 0x81},
+{0x43A3, 0x81},
+{0x43A4, 0x80},
+{0x43A5, 0x81},
+{0x43A6, 0x81},
+{0x43A7, 0x80},
+{0x43A8, 0x81},
+{0x43A9, 0x82},
+{0x43AA, 0x82},
+{0x43AB, 0x81},
+{0x43AC, 0x84},
+{0x43AD, 0x84},
+{0x43AE, 0x84},
+{0x43AF, 0x84},
+{0x43B0, 0x88},
+{0x43B1, 0x88},
+{0x43B2, 0x88},
+{0x43B3, 0x88},
+{0x43B4, 0x8F},
+{0x43B5, 0x8B},
+{0x43B6, 0x8C},
+{0x43B7, 0x90},
+{0x43B8, 0x8A},
+{0x43B9, 0x87},
+{0x43BA, 0x88},
+{0x43BB, 0x8B},
+{0x43BC, 0x85},
+{0x43BD, 0x84},
+{0x43BE, 0x84},
+{0x43BF, 0x85},
+{0x43C0, 0x83},
+{0x43C1, 0x82},
+{0x43C2, 0x83},
+{0x43C3, 0x83},
+{0x43C4, 0x82},
+{0x43C5, 0x81},
+{0x43C6, 0x81},
+{0x43C7, 0x82},
+{0x43C8, 0x81},
+{0x43C9, 0x81},
+{0x43CA, 0x81},
+{0x43CB, 0x80},
+{0x43CC, 0x83},
+{0x43CD, 0x83},
+{0x43CE, 0x82},
+{0x43CF, 0x82},
+{0x43D0, 0x86},
+{0x43D1, 0x85},
+{0x43D2, 0x85},
+{0x43D3, 0x86},
+{0x43D4, 0x8A},
+{0x43D5, 0x89},
+{0x43D6, 0x89},
+{0x43D7, 0x89},
+{0x4400, 0x80},
+{0x4401, 0x80},
+{0x4402, 0x80},
+{0x4403, 0x80},
+{0x4404, 0x80},
+{0x4405, 0x80},
+{0x4406, 0x80},
+{0x4407, 0x80},
+{0x4408, 0x80},
+{0x4409, 0x80},
+{0x440A, 0x80},
+{0x440B, 0x80},
+{0x440C, 0x80},
+{0x440D, 0x80},
+{0x440E, 0x80},
+{0x440F, 0x80},
+{0x4410, 0x80},
+{0x4411, 0x80},
+{0x4412, 0x80},
+{0x4413, 0x80},
+{0x4414, 0x80},
+{0x4415, 0x80},
+{0x4416, 0x80},
+{0x4417, 0x80},
+{0x4418, 0x80},
+{0x4419, 0x80},
+{0x441A, 0x80},
+{0x441B, 0x80},
+{0x441C, 0x80},
+{0x441D, 0x80},
+{0x441E, 0x80},
+{0x441F, 0x80},
+{0x4420, 0x80},
+{0x4421, 0x80},
+{0x4422, 0x80},
+{0x4423, 0x80},
+{0x4424, 0x80},
+{0x4425, 0x80},
+{0x4426, 0x80},
+{0x4427, 0x80},
+{0x4428, 0x80},
+{0x4429, 0x80},
+{0x442A, 0x80},
+{0x442B, 0x80},
+{0x442C, 0x80},
+{0x442D, 0x80},
+{0x442E, 0x80},
+{0x442F, 0x80},
+{0x4430, 0x80},
+{0x4431, 0x80},
+{0x4432, 0x80},
+{0x4433, 0x80},
+{0x4434, 0x80},
+{0x4435, 0x80},
+{0x4436, 0x80},
+{0x4437, 0x80},
+{0x4438, 0x80},
+{0x4439, 0x80},
+{0x443A, 0x80},
+{0x443B, 0x80},
+{0x443C, 0x80},
+{0x443D, 0x80},
+{0x443E, 0x80},
+{0x443F, 0x80},
+{0x4440, 0x80},
+{0x4441, 0x80},
+{0x4442, 0x80},
+{0x4443, 0x80},
+{0x4444, 0x80},
+{0x4445, 0x80},
+{0x4446, 0x80},
+{0x4447, 0x80},
+{0x4448, 0x80},
+{0x4449, 0x80},
+{0x444A, 0x80},
+{0x444B, 0x80},
+{0x444C, 0x80},
+{0x444D, 0x80},
+{0x444E, 0x80},
+{0x444F, 0x80},
+{0x4450, 0x80},
+{0x4451, 0x80},
+{0x4452, 0x80},
+{0x4453, 0x80},
+{0x4454, 0x80},
+{0x4455, 0x80},
+{0x4456, 0x80},
+{0x4457, 0x80},
+{0x4458, 0x80},
+{0x4459, 0x80},
+{0x445A, 0x80},
+{0x445B, 0x80},
+{0x445C, 0x80},
+{0x445D, 0x80},
+{0x445E, 0x80},
+{0x445F, 0x80},
+{0x4460, 0x80},
+{0x4461, 0x80},
+{0x4462, 0x80},
+{0x4463, 0x80},
+{0x4464, 0x80},
+{0x4465, 0x80},
+{0x4466, 0x80},
+{0x4467, 0x80},
+{0x4468, 0x80},
+{0x4469, 0x80},
+{0x446A, 0x80},
+{0x446B, 0x80},
+{0x446C, 0x80},
+{0x446D, 0x80},
+{0x446E, 0x80},
+{0x446F, 0x80},
+{0x4470, 0x80},
+{0x4471, 0x80},
+{0x4472, 0x80},
+{0x4473, 0x80},
+{0x4474, 0x80},
+{0x4475, 0x80},
+{0x4476, 0x80},
+{0x4477, 0x80},
+{0x4478, 0x80},
+{0x4479, 0x80},
+{0x447A, 0x80},
+{0x447B, 0x80},
+{0x447C, 0x80},
+{0x447D, 0x80},
+{0x447E, 0x80},
+{0x447F, 0x80},
+{0x4480, 0x80},
+{0x4481, 0x80},
+{0x4482, 0x80},
+{0x4483, 0x80},
+{0x4484, 0x80},
+{0x4485, 0x80},
+{0x4486, 0x80},
+{0x4487, 0x80},
+{0x4488, 0x80},
+{0x4489, 0x80},
+{0x448A, 0x80},
+{0x448B, 0x80},
+{0x448C, 0x80},
+{0x448D, 0x80},
+{0x448E, 0x80},
+{0x448F, 0x80},
+{0x4490, 0x80},
+{0x4491, 0x80},
+{0x4492, 0x80},
+{0x4493, 0x80},
+{0x4494, 0x80},
+{0x4495, 0x80},
+{0x4496, 0x80},
+{0x4497, 0x80},
+{0x4498, 0x80},
+{0x4499, 0x80},
+{0x449A, 0x80},
+{0x449B, 0x80},
+{0x449C, 0x80},
+{0x449D, 0x80},
+{0x449E, 0x80},
+{0x449F, 0x80},
+{0x44A0, 0x80},
+{0x44A1, 0x80},
+{0x44A2, 0x80},
+{0x44A3, 0x80},
+{0x44A4, 0x80},
+{0x44A5, 0x80},
+{0x44A6, 0x80},
+{0x44A7, 0x80},
+{0x44A8, 0x80},
+{0x44A9, 0x80},
+{0x44AA, 0x80},
+{0x44AB, 0x80},
+{0x44AC, 0x80},
+{0x44AD, 0x80},
+{0x44AE, 0x80},
+{0x44AF, 0x80},
+{0x44B0, 0x80},
+{0x44B1, 0x80},
+{0x44B2, 0x80},
+{0x44B3, 0x80},
+{0x44B4, 0x80},
+{0x44B5, 0x80},
+{0x44B6, 0x80},
+{0x44B7, 0x80},
+{0x44B8, 0x80},
+{0x44B9, 0x80},
+{0x44BA, 0x80},
+{0x44BB, 0x80},
+{0x44BC, 0x80},
+{0x44BD, 0x80},
+{0x44BE, 0x80},
+{0x44BF, 0x80},
+{0x44C0, 0x80},
+{0x44C1, 0x80},
+{0x44C2, 0x80},
+{0x44C3, 0x80},
+{0x44C4, 0x80},
+{0x44C5, 0x80},
+{0x44C6, 0x80},
+{0x44C7, 0x80},
+{0x44C8, 0x80},
+{0x44C9, 0x80},
+{0x44CA, 0x80},
+{0x44CB, 0x80},
+{0x44CC, 0x80},
+{0x44CD, 0x80},
+{0x44CE, 0x80},
+{0x44CF, 0x80},
+{0x44D0, 0x80},
+{0x44D1, 0x80},
+{0x44D2, 0x80},
+{0x44D3, 0x80},
+{0x44D4, 0x80},
+{0x44D5, 0x80},
+{0x44D6, 0x80},
+{0x44D7, 0x80},
+{0x4500, 0x80},
+{0x4501, 0x80},
+{0x4502, 0x80},
+{0x4503, 0x80},
+{0x4504, 0x80},
+{0x4505, 0x80},
+{0x4506, 0x80},
+{0x4507, 0x80},
+{0x4508, 0x80},
+{0x4509, 0x80},
+{0x450A, 0x80},
+{0x450B, 0x80},
+{0x450C, 0x80},
+{0x450D, 0x80},
+{0x450E, 0x80},
+{0x450F, 0x80},
+{0x4510, 0x80},
+{0x4511, 0x80},
+{0x4512, 0x80},
+{0x4513, 0x80},
+{0x4514, 0x80},
+{0x4515, 0x80},
+{0x4516, 0x80},
+{0x4517, 0x80},
+{0x4518, 0x80},
+{0x4519, 0x80},
+{0x451A, 0x80},
+{0x451B, 0x80},
+{0x451C, 0x80},
+{0x451D, 0x80},
+{0x451E, 0x80},
+{0x451F, 0x80},
+{0x4520, 0x80},
+{0x4521, 0x80},
+{0x4522, 0x80},
+{0x4523, 0x80},
+{0x4524, 0x80},
+{0x4525, 0x80},
+{0x4526, 0x80},
+{0x4527, 0x80},
+{0x4528, 0x80},
+{0x4529, 0x80},
+{0x452A, 0x80},
+{0x452B, 0x80},
+{0x452C, 0x80},
+{0x452D, 0x80},
+{0x452E, 0x80},
+{0x452F, 0x80},
+{0x4530, 0x80},
+{0x4531, 0x80},
+{0x4532, 0x80},
+{0x4533, 0x80},
+{0x4534, 0x80},
+{0x4535, 0x80},
+{0x4536, 0x80},
+{0x4537, 0x80},
+{0x4538, 0x80},
+{0x4539, 0x80},
+{0x453A, 0x80},
+{0x453B, 0x80},
+{0x453C, 0x80},
+{0x453D, 0x80},
+{0x453E, 0x80},
+{0x453F, 0x80},
+{0x4540, 0x80},
+{0x4541, 0x80},
+{0x4542, 0x80},
+{0x4543, 0x80},
+{0x4544, 0x80},
+{0x4545, 0x80},
+{0x4546, 0x80},
+{0x4547, 0x80},
+{0x4548, 0x80},
+{0x4549, 0x80},
+{0x454A, 0x80},
+{0x454B, 0x80},
+{0x454C, 0x80},
+{0x454D, 0x80},
+{0x454E, 0x80},
+{0x454F, 0x80},
+{0x4550, 0x80},
+{0x4551, 0x80},
+{0x4552, 0x80},
+{0x4553, 0x80},
+{0x4554, 0x80},
+{0x4555, 0x80},
+{0x4556, 0x80},
+{0x4557, 0x80},
+{0x4558, 0x80},
+{0x4559, 0x80},
+{0x455A, 0x80},
+{0x455B, 0x80},
+{0x455C, 0x80},
+{0x455D, 0x80},
+{0x455E, 0x80},
+{0x455F, 0x80},
+{0x4560, 0x80},
+{0x4561, 0x80},
+{0x4562, 0x80},
+{0x4563, 0x80},
+{0x4564, 0x80},
+{0x4565, 0x80},
+{0x4566, 0x80},
+{0x4567, 0x80},
+{0x4568, 0x80},
+{0x4569, 0x80},
+{0x456A, 0x80},
+{0x456B, 0x80},
+{0x456C, 0x80},
+{0x456D, 0x80},
+{0x456E, 0x80},
+{0x456F, 0x80},
+{0x4570, 0x80},
+{0x4571, 0x80},
+{0x4572, 0x80},
+{0x4573, 0x80},
+{0x4574, 0x80},
+{0x4575, 0x80},
+{0x4576, 0x80},
+{0x4577, 0x80},
+{0x4578, 0x80},
+{0x4579, 0x80},
+{0x457A, 0x80},
+{0x457B, 0x80},
+{0x457C, 0x80},
+{0x457D, 0x80},
+{0x457E, 0x80},
+{0x457F, 0x80},
+{0x4580, 0x80},
+{0x4581, 0x80},
+{0x4582, 0x80},
+{0x4583, 0x80},
+{0x4584, 0x80},
+{0x4585, 0x80},
+{0x4586, 0x80},
+{0x4587, 0x80},
+{0x4588, 0x80},
+{0x4589, 0x80},
+{0x458A, 0x80},
+{0x458B, 0x80},
+{0x458C, 0x80},
+{0x458D, 0x80},
+{0x458E, 0x80},
+{0x458F, 0x80},
+{0x4590, 0x80},
+{0x4591, 0x80},
+{0x4592, 0x80},
+{0x4593, 0x80},
+{0x4594, 0x80},
+{0x4595, 0x80},
+{0x4596, 0x80},
+{0x4597, 0x80},
+{0x4598, 0x80},
+{0x4599, 0x80},
+{0x459A, 0x80},
+{0x459B, 0x80},
+{0x459C, 0x80},
+{0x459D, 0x80},
+{0x459E, 0x80},
+{0x459F, 0x80},
+{0x45A0, 0x80},
+{0x45A1, 0x80},
+{0x45A2, 0x80},
+{0x45A3, 0x80},
+{0x45A4, 0x80},
+{0x45A5, 0x80},
+{0x45A6, 0x80},
+{0x45A7, 0x80},
+{0x45A8, 0x80},
+{0x45A9, 0x80},
+{0x45AA, 0x80},
+{0x45AB, 0x80},
+{0x45AC, 0x80},
+{0x45AD, 0x80},
+{0x45AE, 0x80},
+{0x45AF, 0x80},
+{0x45B0, 0x80},
+{0x45B1, 0x80},
+{0x45B2, 0x80},
+{0x45B3, 0x80},
+{0x45B4, 0x80},
+{0x45B5, 0x80},
+{0x45B6, 0x80},
+{0x45B7, 0x80},
+{0x45B8, 0x80},
+{0x45B9, 0x80},
+{0x45BA, 0x80},
+{0x45BB, 0x80},
+{0x45BC, 0x80},
+{0x45BD, 0x80},
+{0x45BE, 0x80},
+{0x45BF, 0x80},
+{0x45C0, 0x80},
+{0x45C1, 0x80},
+{0x45C2, 0x80},
+{0x45C3, 0x80},
+{0x45C4, 0x80},
+{0x45C5, 0x80},
+{0x45C6, 0x80},
+{0x45C7, 0x80},
+{0x45C8, 0x80},
+{0x45C9, 0x80},
+{0x45CA, 0x80},
+{0x45CB, 0x80},
+{0x45CC, 0x80},
+{0x45CD, 0x80},
+{0x45CE, 0x80},
+{0x45CF, 0x80},
+{0x45D0, 0x80},
+{0x45D1, 0x80},
+{0x45D2, 0x80},
+{0x45D3, 0x80},
+{0x45D4, 0x80},
+{0x45D5, 0x80},
+{0x45D6, 0x80},
+{0x45D7, 0x80},
+{0x7000, 0xAB},
+{0x7001, 0xBA},
+{0x7002, 0x40},
+{0x7003, 0x02},
+{0x7004, 0x00},
+{0x7005, 0x00},
+{0x7006, 0x00},
+{0x7007, 0x00},
+{0x7008, 0x00},
+{0x7009, 0x00},
+{0x700A, 0x00},
+{0x700B, 0x00},
+{0x700C, 0x00},
+{0x700D, 0x00},
+{0x700E, 0x00},
+{0x700F, 0x00},
+{0x7010, 0x55},
+{0x7011, 0x88},
+{0x7012, 0x40},
+{0x7013, 0x01},
+{0x7014, 0x72},
+{0x7015, 0xF1},
+{0x7016, 0x02},
+{0x7017, 0xF8},
+{0x7018, 0x00},
+{0x7019, 0x00},
+{0x701A, 0x00},
+{0x701B, 0x00},
+{0x701C, 0x00},
+{0x701D, 0x00},
+{0x701E, 0x00},
+{0x701F, 0x00},
+{0x7020, 0x00},
+{0x7021, 0x00},
+{0x7022, 0x00},
+{0x7023, 0x00},
+{0x7024, 0x00},
+{0x7025, 0x00},
+{0x7026, 0x00},
+{0x7027, 0x00},
+{0x7028, 0x00},
+{0x7029, 0x00},
+{0x702A, 0x00},
+{0x702B, 0x00},
+{0x702C, 0x00},
+{0x702D, 0x00},
+{0x702E, 0x00},
+{0x702F, 0x00},
+{0x7030, 0x00},
+{0x7031, 0x00},
+{0x7032, 0x00},
+{0x7033, 0x00},
+{0x7034, 0x00},
+{0x7035, 0x00},
+{0x7036, 0x00},
+{0x7037, 0x00},
+{0x7038, 0x00},
+{0x7039, 0x00},
+{0x703A, 0x00},
+{0x703B, 0x00},
+{0x703C, 0x00},
+{0x703D, 0x00},
+{0x703E, 0x00},
+{0x703F, 0x00},
+{0x7040, 0x00},
+{0x7041, 0x00},
+{0x7042, 0x00},
+{0x7043, 0x00},
+{0x7044, 0x00},
+{0x7045, 0x00},
+{0x7046, 0x00},
+{0x7047, 0x00},
+{0x7048, 0x00},
+{0x7049, 0x00},
+{0x704A, 0x00},
+{0x704B, 0x00},
+{0x704C, 0x00},
+{0x704D, 0x00},
+{0x704E, 0x00},
+{0x704F, 0x00},
+{0x7050, 0x00},
+{0x7051, 0x00},
+{0x7052, 0x00},
+{0x7053, 0x00},
+{0x7054, 0x00},
+{0x7055, 0x00},
+{0x7056, 0x00},
+{0x7057, 0x00},
+{0x7058, 0x00},
+{0x7059, 0x00},
+{0x705A, 0x00},
+{0x705B, 0x00},
+{0x705C, 0x00},
+{0x705D, 0x00},
+{0x705E, 0x00},
+{0x705F, 0x00},
+{0x7060, 0x00},
+{0x7061, 0x00},
+{0x7062, 0x00},
+{0x7063, 0x00},
+{0x7064, 0x00},
+{0x7065, 0x00},
+{0x7066, 0x00},
+{0x7067, 0x00},
+{0x7068, 0x00},
+{0x7069, 0x00},
+{0x706A, 0x00},
+{0x706B, 0x00},
+{0x706C, 0x00},
+{0x706D, 0x00},
+{0x706E, 0x00},
+{0x706F, 0x00},
+{0x7070, 0x00},
+{0x7071, 0x00},
+{0x7072, 0x00},
+{0x7073, 0x00},
+{0x7074, 0x00},
+{0x7075, 0x00},
+{0x7076, 0x00},
+{0x7077, 0x00},
+{0x7078, 0x00},
+{0x7079, 0x00},
+{0x707A, 0x00},
+{0x707B, 0x00},
+{0x707C, 0x00},
+{0x707D, 0x00},
+{0x707E, 0x00},
+{0x707F, 0x00},
+{0x7080, 0x00},
+{0x7081, 0x00},
+{0x7082, 0x00},
+{0x7083, 0x00},
+{0x7084, 0x00},
+{0x7085, 0x00},
+{0x7086, 0x00},
+{0x7087, 0x00},
+{0x7088, 0x00},
+{0x7089, 0x00},
+{0x708A, 0x00},
+{0x708B, 0x00},
+{0x708C, 0x00},
+{0x708D, 0x00},
+{0x708E, 0x00},
+{0x708F, 0x00},
+{0x7090, 0x00},
+{0x7091, 0xF0},
+{0x7092, 0x02},
+{0x7093, 0xF8},
+{0x7094, 0x8D},
+{0x7095, 0xF6},
+{0x7096, 0xFA},
+{0x7097, 0xFF},
+{0x7098, 0xF0},
+{0x7099, 0xB5},
+{0x709A, 0x04},
+{0x709B, 0x46},
+{0x709C, 0x8F},
+{0x709D, 0xB0},
+{0x709E, 0x5F},
+{0x709F, 0x48},
+{0x70A0, 0x0C},
+{0x70A1, 0x90},
+{0x70A2, 0x5F},
+{0x70A3, 0x48},
+{0x70A4, 0x06},
+{0x70A5, 0x90},
+{0x70A6, 0x20},
+{0x70A7, 0x46},
+{0x70A8, 0x34},
+{0x70A9, 0x30},
+{0x70AA, 0x0B},
+{0x70AB, 0x90},
+{0x70AC, 0x5B},
+{0x70AD, 0x48},
+{0x70AE, 0x5A},
+{0x70AF, 0x49},
+{0x70B0, 0x26},
+{0x70B1, 0x46},
+{0x70B2, 0x66},
+{0x70B3, 0x30},
+{0x70B4, 0x3A},
+{0x70B5, 0x31},
+{0x70B6, 0x3C},
+{0x70B7, 0x36},
+{0x70B8, 0x05},
+{0x70B9, 0x90},
+{0x70BA, 0x0A},
+{0x70BB, 0x30},
+{0x70BC, 0x04},
+{0x70BD, 0x90},
+{0x70BE, 0x59},
+{0x70BF, 0x48},
+{0x70C0, 0x55},
+{0x70C1, 0x4A},
+{0x70C2, 0x40},
+{0x70C3, 0x6E},
+{0x70C4, 0xC0},
+{0x70C5, 0x07},
+{0x70C6, 0x7D},
+{0x70C7, 0xD1},
+{0x70C8, 0x17},
+{0x70C9, 0x88},
+{0x70CA, 0x0A},
+{0x70CB, 0x5E},
+{0x70CC, 0x0D},
+{0x70CD, 0x92},
+{0x70CE, 0x53},
+{0x70CF, 0x49},
+{0x70D0, 0x55},
+{0x70D1, 0x48},
+{0x70D2, 0x94},
+{0x70D3, 0x31},
+{0x70D4, 0x89},
+{0x70D5, 0x6B},
+{0x70D6, 0x80},
+{0x70D7, 0x68},
+{0x70D8, 0x09},
+{0x70D9, 0x02},
+{0x70DA, 0x00},
+{0x70DB, 0x03},
+{0x70DC, 0x09},
+{0x70DD, 0x0E},
+{0x70DE, 0x00},
+{0x70DF, 0x0B},
+{0x70E0, 0x49},
+{0x70E1, 0x1C},
+{0x70E2, 0x48},
+{0x70E3, 0x43},
+{0x70E4, 0x4D},
+{0x70E5, 0x49},
+{0x70E6, 0x6C},
+{0x70E7, 0x39},
+{0x70E8, 0x8A},
+{0x70E9, 0x6A},
+{0x70EA, 0x07},
+{0x70EB, 0x92},
+{0x70EC, 0xCA},
+{0x70ED, 0x6A},
+{0x70EE, 0x00},
+{0x70EF, 0x21},
+{0x70F0, 0xC9},
+{0x70F1, 0x43},
+{0x70F2, 0x03},
+{0x70F3, 0x92},
+{0x70F4, 0x00},
+{0x70F5, 0x22},
+{0x70F6, 0x00},
+{0x70F7, 0x91},
+{0x70F8, 0x01},
+{0x70F9, 0x92},
+{0x70FA, 0x39},
+{0x70FB, 0x46},
+{0x70FC, 0x8F},
+{0x70FD, 0xF6},
+{0x70FE, 0xCE},
+{0x70FF, 0xFB},
+{0x7100, 0x01},
+{0x7101, 0x22},
+{0x7102, 0x00},
+{0x7103, 0x23},
+{0x7104, 0x8C},
+{0x7105, 0xF6},
+{0x7106, 0x02},
+{0x7107, 0xFA},
+{0x7108, 0x00},
+{0x7109, 0x21},
+{0x710A, 0x05},
+{0x710B, 0x46},
+{0x710C, 0x01},
+{0x710D, 0x91},
+{0x710E, 0x00},
+{0x710F, 0x90},
+{0x7110, 0x39},
+{0x7111, 0x46},
+{0x7112, 0x07},
+{0x7113, 0x98},
+{0x7114, 0x8F},
+{0x7115, 0xF6},
+{0x7116, 0xC2},
+{0x7117, 0xFB},
+{0x7118, 0x0D},
+{0x7119, 0x9A},
+{0x711A, 0xD3},
+{0x711B, 0x17},
+{0x711C, 0x80},
+{0x711D, 0x18},
+{0x711E, 0x59},
+{0x711F, 0x41},
+{0x7120, 0x01},
+{0x7121, 0x22},
+{0x7122, 0x00},
+{0x7123, 0x23},
+{0x7124, 0x8C},
+{0x7125, 0xF6},
+{0x7126, 0xCD},
+{0x7127, 0xF9},
+{0x7128, 0x07},
+{0x7129, 0x90},
+{0x712A, 0x00},
+{0x712B, 0x20},
+{0x712C, 0x01},
+{0x712D, 0x90},
+{0x712E, 0x00},
+{0x712F, 0x95},
+{0x7130, 0x39},
+{0x7131, 0x46},
+{0x7132, 0x03},
+{0x7133, 0x98},
+{0x7134, 0x8F},
+{0x7135, 0xF6},
+{0x7136, 0xB2},
+{0x7137, 0xFB},
+{0x7138, 0x01},
+{0x7139, 0x22},
+{0x713A, 0x00},
+{0x713B, 0x23},
+{0x713C, 0x8C},
+{0x713D, 0xF6},
+{0x713E, 0xE6},
+{0x713F, 0xF9},
+{0x7140, 0x02},
+{0x7141, 0x46},
+{0x7142, 0x07},
+{0x7143, 0x98},
+{0x7144, 0x00},
+{0x7145, 0x23},
+{0x7146, 0x81},
+{0x7147, 0x0B},
+{0x7148, 0x80},
+{0x7149, 0x04},
+{0x714A, 0x7A},
+{0x714B, 0xF6},
+{0x714C, 0x54},
+{0x714D, 0xF8},
+{0x714E, 0x37},
+{0x714F, 0x4A},
+{0x7150, 0x00},
+{0x7151, 0x23},
+{0x7152, 0x00},
+{0x7153, 0x92},
+{0x7154, 0x01},
+{0x7155, 0x93},
+{0x7156, 0x01},
+{0x7157, 0x22},
+{0x7158, 0x8C},
+{0x7159, 0xF6},
+{0x715A, 0xD8},
+{0x715B, 0xF9},
+{0x715C, 0x05},
+{0x715D, 0x46},
+{0x715E, 0x60},
+{0x715F, 0x68},
+{0x7160, 0x00},
+{0x7161, 0x23},
+{0x7162, 0x01},
+{0x7163, 0x0C},
+{0x7164, 0x00},
+{0x7165, 0x04},
+{0x7166, 0xE2},
+{0x7167, 0x68},
+{0x7168, 0x7A},
+{0x7169, 0xF6},
+{0x716A, 0x45},
+{0x716B, 0xF8},
+{0x716C, 0x00},
+{0x716D, 0x22},
+{0x716E, 0xD2},
+{0x716F, 0x43},
+{0x7170, 0x00},
+{0x7171, 0x23},
+{0x7172, 0x00},
+{0x7173, 0x92},
+{0x7174, 0x01},
+{0x7175, 0x93},
+{0x7176, 0x1A},
+{0x7177, 0x46},
+{0x7178, 0x8C},
+{0x7179, 0xF6},
+{0x717A, 0xC8},
+{0x717B, 0xF9},
+{0x717C, 0x29},
+{0x717D, 0x46},
+{0x717E, 0x8F},
+{0x717F, 0xF6},
+{0x7180, 0x8D},
+{0x7181, 0xFB},
+{0x7182, 0x8A},
+{0x7183, 0x03},
+{0x7184, 0x80},
+{0x7185, 0x0C},
+{0x7186, 0x10},
+{0x7187, 0x43},
+{0x7188, 0x00},
+{0x7189, 0x22},
+{0x718A, 0xD2},
+{0x718B, 0x43},
+{0x718C, 0x00},
+{0x718D, 0x23},
+{0x718E, 0x00},
+{0x718F, 0x92},
+{0x7190, 0x89},
+{0x7191, 0x0C},
+{0x7192, 0x01},
+{0x7193, 0x93},
+{0x7194, 0x1A},
+{0x7195, 0x46},
+{0x7196, 0x8C},
+{0x7197, 0xF6},
+{0x7198, 0xB9},
+{0x7199, 0xF9},
+{0x719A, 0x00},
+{0x719B, 0x24},
+{0x719C, 0x03},
+{0x719D, 0x90},
+{0x719E, 0x0C},
+{0x719F, 0x98},
+{0x71A0, 0x61},
+{0x71A1, 0x00},
+{0x71A2, 0x45},
+{0x71A3, 0x5A},
+{0x71A4, 0x06},
+{0x71A5, 0x98},
+{0x71A6, 0x22},
+{0x71A7, 0x4A},
+{0x71A8, 0x40},
+{0x71A9, 0x5A},
+{0x71AA, 0x00},
+{0x71AB, 0x21},
+{0x71AC, 0x8C},
+{0x71AD, 0xF6},
+{0x71AE, 0xBE},
+{0x71AF, 0xF9},
+{0x71B0, 0x07},
+{0x71B1, 0x46},
+{0x71B2, 0x28},
+{0x71B3, 0x46},
+{0x71B4, 0x03},
+{0x71B5, 0x99},
+{0x71B6, 0x8F},
+{0x71B7, 0xF6},
+{0x71B8, 0x71},
+{0x71B9, 0xFB},
+{0x71BA, 0x3A},
+{0x71BB, 0x46},
+{0x71BC, 0x00},
+{0x71BD, 0x23},
+{0x71BE, 0x79},
+{0x71BF, 0xF6},
+{0x71C0, 0xCA},
+{0x71C1, 0xFF},
+{0x71C2, 0x00},
+{0x71C3, 0xE0},
+{0x71C4, 0x0F},
+{0x71C5, 0xE0},
+{0x71C6, 0x8A},
+{0x71C7, 0x02},
+{0x71C8, 0x80},
+{0x71C9, 0x0D},
+{0x71CA, 0x10},
+{0x71CB, 0x43},
+{0x71CC, 0x19},
+{0x71CD, 0x4A},
+{0x71CE, 0x00},
+{0x71CF, 0x23},
+{0x71D0, 0x00},
+{0x71D1, 0x92},
+{0x71D2, 0x89},
+{0x71D3, 0x0D},
+{0x71D4, 0x01},
+{0x71D5, 0x93},
+{0x71D6, 0x40},
+{0x71D7, 0x22},
+{0x71D8, 0x8C},
+{0x71D9, 0xF6},
+{0x71DA, 0x98},
+{0x71DB, 0xF9},
+{0x71DC, 0xA1},
+{0x71DD, 0x00},
+{0x71DE, 0x64},
+{0x71DF, 0x1C},
+{0x71E0, 0x70},
+{0x71E1, 0x50},
+{0x71E2, 0x04},
+{0x71E3, 0x2C},
+{0x71E4, 0xDB},
+{0x71E5, 0xD3},
+{0x71E6, 0x14},
+{0x71E7, 0x4D},
+{0x71E8, 0x00},
+{0x71E9, 0x24},
+{0x71EA, 0x0B},
+{0x71EB, 0x98},
+{0x71EC, 0x67},
+{0x71ED, 0x00},
+{0x71EE, 0xC0},
+{0x71EF, 0x5B},
+{0x71F0, 0x2A},
+{0x71F1, 0x46},
+{0x71F2, 0x40},
+{0x71F3, 0x21},
+{0x71F4, 0x8C},
+{0x71F5, 0xF6},
+{0x71F6, 0x9A},
+{0x71F7, 0xF9},
+{0x71F8, 0x05},
+{0x71F9, 0x99},
+{0x71FA, 0x0E},
+{0x71FB, 0x4A},
+{0x71FC, 0xC8},
+{0x71FD, 0x53},
+{0x71FE, 0xA7},
+{0x71FF, 0x00},
+{0x7200, 0xF0},
+{0x7201, 0x59},
+{0x7202, 0x40},
+{0x7203, 0x21},
+{0x7204, 0x8C},
+{0x7205, 0xF6},
+{0x7206, 0x7B},
+{0x7207, 0xF9},
+{0x7208, 0x04},
+{0x7209, 0x99},
+{0x720A, 0x64},
+{0x720B, 0x1C},
+{0x720C, 0xC8},
+{0x720D, 0x51},
+{0x720E, 0x04},
+{0x720F, 0x2C},
+{0x7210, 0xEB},
+{0x7211, 0xD3},
+{0x7212, 0x0F},
+{0x7213, 0xB0},
+{0x7214, 0xF0},
+{0x7215, 0xBD},
+{0x7216, 0x00},
+{0x7217, 0x00},
+{0x7218, 0x76},
+{0x7219, 0x69},
+{0x721A, 0x18},
+{0x721B, 0x00},
+{0x721C, 0xEC},
+{0x721D, 0x58},
+{0x721E, 0x18},
+{0x721F, 0x00},
+{0x7220, 0x38},
+{0x7221, 0x36},
+{0x7222, 0x18},
+{0x7223, 0x00},
+{0x7224, 0x00},
+{0x7225, 0x35},
+{0x7226, 0x18},
+{0x7227, 0x00},
+{0x7228, 0x00},
+{0x7229, 0x20},
+{0x722A, 0x18},
+{0x722B, 0x00},
+{0x722C, 0xFF},
+{0x722D, 0xFF},
+{0x722E, 0xFF},
+{0x722F, 0x3F},
+{0x7230, 0xFF},
+{0x7231, 0x07},
+{0x7232, 0x00},
+{0x7233, 0x00},
+{0x7234, 0xFF},
+{0x7235, 0xFF},
+{0x7236, 0x07},
+{0x7237, 0x00},
+{0x7238, 0xFF},
+{0x7239, 0x1F},
+{0x723A, 0x00},
+{0x723B, 0x00},
+{0x723C, 0x01},
+{0x723D, 0xF6},
+{0x723E, 0x45},
+{0x723F, 0x12},
+};
+
+#endif
Index: b/drivers/media/i2c/lt6911uxc.c
===================================================================
--- /dev/null
+++ b/drivers/media/i2c/lt6911uxc.c
@@ -0,0 +1,1567 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (c) 2022-2023 Intel Corporation.
+
+#include <asm/unaligned.h>
+#include <linux/acpi.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/v4l2-dv-timings.h>
+
+#include <media/v4l2-dv-timings.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-event.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-fwnode.h>
+#include <linux/types.h>
+
+#include <linux/version.h>
+#include <media/lt6911uxc.h>
+
+/* v4l2 debug level */
+static int debug;
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "debug level (0-3)");
+
+#define FSERIAL_CLK_4_LANE		240000000ULL
+#define FSERIAL_CLK_2_LANE		144000000ULL
+
+#define PIX_CLK_4_LANE			60000000ULL
+#define PIX_CLK_2_LANE			18000000ULL
+
+// LT6911UXC Register Setting
+
+#define LT6911UXC_REG_VALUE_08BIT		1
+#define LT6911UXC_REG_VALUE_16BIT		2
+#define LT6911UXC_CHIP_ID			0x1704
+
+#define LT6911UXC_CID_CSI_PORT	(V4L2_CID_USER_BASE | 0x1001)
+#define LT6911UXC_CID_I2C_BUS	(V4L2_CID_USER_BASE | 0x1002)
+#define LT6911UXC_CID_I2C_ID	(V4L2_CID_USER_BASE | 0x1003)
+#define LT6911UXC_CID_I2C_SLAVE_ADDRESS	(V4L2_CID_USER_BASE | 0x1004)
+#define LT6911UXC_CID_FPS	(V4L2_CID_USER_BASE | 0x1005)
+#define LT6911UXC_CID_FRAME_INTERVAL	(V4L2_CID_USER_BASE | 0x1006)
+#define LT6911UXC_CID_AUDIO_SAMPLING_RATE	(V4L2_CID_USER_BASE | 0x1007)
+#define LT6911UXC_CID_AUDIO_PRESENT	(V4L2_CID_USER_BASE | 0x1008)
+
+#define REG_CHIP_ID	0x8100
+
+/* Control */
+#define REG_BANK	0xFF
+
+#define REG_ENABLE_I2C	0x80EE
+#define REG_DISABLE_WD	0x8010
+
+/* Resolution registers */
+#define REG_H_TOTAL	0x867C	/* horizontal half total pixel */
+#define REG_H_ACTIVE	0x8680	/* horizontal half active pixel */
+#define REG_H_FP_0P5	0x8678	/* horizontal half front porch pixel */
+#define REG_H_BP_0P5	0x8676	/* horizontal half back porch pixel */
+#define REG_H_SW_0P5	0x8672	/* hsync half length pixel  */
+#define REG_V_TOTAL	0x867A	/* vertical total lines */
+#define REG_V_ACTIVE	0x867E	/* vertical active lines */
+#define REG_V_BP	0x8674	/* vertical back porch lines */
+#define REG_V_FP	0x8675	/* vertical front porch lines */
+#define REG_V_SW	0x8671	/* vsync length lines */
+#define REG_SYNC_POL	0x8670	/* hsync/vsync polarity flags */
+#define REG_BKB0_A2_REG	0xB0A2
+#define REG_FM1_FREQ_IN2	0x8548
+#define REG_FM1_FREQ_IN1	0x8549
+#define REG_FM1_FREQ_IN0	0x854A
+
+#define REG_AD_HALF_PCLK	0x8540
+
+#define REG_TMDS_CLK_IN2	0x8750
+#define REG_TMDS_CLK_IN1	0x8751
+#define REG_TMDS_CLK_IN0	0x8752
+
+/* MIPI-TX */
+#define REG_MIPI_TX_CTRL	0x811D
+#define REG_MIPI_LANES		0x86A2
+#define REG_MIPI_CLK_MODE	0xD468
+
+/* Audio sample rate */
+#define REG_INT_AUDIO		0x86A5
+#define AUDIO_DISCONNECT	0x88
+#define AUDIO_SR_HIGH		0x55
+#define AUDIO_SR_LOW		0xAA
+#define REG_AUDIO_SR		0xB0AB
+
+/* Interrupts */
+#define REG_INT_HDMI	0x86A3
+#define REG_INT_RESPOND	0x86A6
+#define INT_HDMI_STABLE	0x55
+#define INT_HDMI_DISCONNECT	0x88
+
+#define REG_INT_AUDIO	0x86A5
+#define INT_AUDIO_DISCONNECT	0x88
+#define INT_AUDIO_SR_HIGH	0x55
+#define INT_AUDIO_SR_LOW	0xAA
+
+/* FPS registers */
+#define MASK_FMI_FREQ2	0x0F
+#define MASK_VSYNC_POL	(1 << 1)
+#define MASK_HSYNC_POL	(1 << 0)
+
+/* Frame ID registers */
+#define REG_FRAME_ID	0xD40E
+#define REG_FRAME_STATUS	0xD414
+
+#define LT69111UXC_IRQ_MODE
+#define MAX_MIPI_PORT_USE 3
+
+static const struct v4l2_dv_timings_cap lt6911uxc_timings_cap_4kp30 = {
+	.type = V4L2_DV_BT_656_1120,
+	/* keep this initialization for compatibility with GCC < 4.4.6 */
+	.reserved = { 0 },
+	/* Pixel clock from REF_01 p. 20. Min/max height/width are unknown */
+	V4L2_INIT_BT_TIMINGS(
+		160, 3840,				/* min/max width */
+		120, 2160,				/* min/max height */
+		25000000, 297000000,			/* min/max pixelclock */
+		V4L2_DV_BT_STD_CEA861 | V4L2_DV_BT_STD_DMT |
+		V4L2_DV_BT_STD_CVT,
+		V4L2_DV_BT_CAP_PROGRESSIVE | V4L2_DV_BT_CAP_CUSTOM |
+		V4L2_DV_BT_CAP_REDUCED_BLANKING)
+};
+
+struct lt6911uxc_mode {
+	/* Frame width in pixels */
+	u32 width;
+
+	/* Frame height in pixels */
+	u32 height;
+
+	/* Horizontal timining size */
+	u32 hts;
+
+	/* Default vertical timining size */
+	u32 vts_def;
+
+	/* Min vertical timining size */
+	u32 vts_min;
+
+	/* Link frequency needed for this resolution */
+	u32 link_freq_index;
+
+	/* MEDIA_BUS_FMT */
+	u32 code;
+
+	/* REG_MIPI_LANES */
+	s32 lanes;
+
+	/* MODE_FPS*/
+	u32 fps;
+
+	/* Bit per pixel */
+	u32 bpp;
+
+	/* Pixel rate*/
+	s64 pixel_clk;
+
+	/* Byte rate*/
+	u32 byte_clk;
+
+	/* Audio sample rate*/
+	u32 audio_sample_rate;
+};
+
+struct lt6911uxc_state {
+	struct v4l2_subdev sd;
+	struct v4l2_ctrl_handler ctrl_handler;
+	struct v4l2_ctrl *audio_sampling_rate_ctrl;
+	struct v4l2_ctrl *audio_present_ctrl;
+	struct v4l2_ctrl *csi_port;
+	struct v4l2_ctrl *i2c_bus;
+	struct v4l2_ctrl *i2c_id;
+	struct v4l2_ctrl *i2c_slave_address;
+	struct v4l2_ctrl *fps;
+	struct v4l2_ctrl *frame_interval;
+	struct v4l2_ctrl *pixel_rate;
+	struct v4l2_ctrl *link_freq;
+	struct v4l2_ctrl *vblank;
+	struct v4l2_ctrl *exposure;
+	struct v4l2_ctrl *analogue_gain;
+	struct v4l2_ctrl *digital_gain;
+	struct v4l2_ctrl *strobe_source;
+	struct v4l2_ctrl *strobe;
+	struct v4l2_ctrl *strobe_stop;
+	struct v4l2_ctrl *timeout;
+	struct v4l2_ctrl *hblank;
+
+	struct v4l2_dv_timings timings;
+	struct v4l2_dv_timings detected_timings;
+
+	struct i2c_client *i2c_client;
+
+	struct media_pad pad;
+	struct mutex mutex;
+	struct lt6911uxc_platform_data  *platform_data;
+
+	/* Current mode */
+	struct lt6911uxc_mode *cur_mode;
+
+	bool streaming;
+
+	u8 bank_i2c;
+	bool enable_i2c;
+
+	u32 mbus_fmt_code;			/* current media bus format */
+
+	u32 thread_run;
+	struct task_struct *poll_task;
+	bool auxiliary_port;
+
+	s64 sub_stream;
+};
+
+static const struct v4l2_event lt6911uxc_ev_source_change = {
+	.type = V4L2_EVENT_SOURCE_CHANGE,
+	.u.src_change.changes = V4L2_EVENT_SRC_CH_RESOLUTION,
+};
+
+static const struct v4l2_event lt6911uxc_ev_stream_end = {
+	.type = V4L2_EVENT_EOS,
+};
+
+static inline struct lt6911uxc_state *to_state(struct v4l2_subdev *sd)
+{
+	return container_of(sd, struct lt6911uxc_state, sd);
+}
+
+static void lt6911uxc_reg_bank(struct v4l2_subdev *sd, u8 bank)
+{
+	struct lt6911uxc_state *lt6911uxc = to_state(sd);
+	struct i2c_client *client = lt6911uxc->i2c_client;
+	int ret;
+	struct i2c_msg msg;
+	u8 data[2];
+	u8 address;
+
+	if (lt6911uxc->bank_i2c == bank)
+		return;
+	dev_dbg(&client->dev, "i2c: change register bank to 0x%02X\n",
+		bank);
+
+	address = 0xFF;
+	msg.addr = client->addr;
+	msg.buf = data;
+	msg.len = 2;
+	msg.flags = 0;
+
+	data[0] = address;
+	data[1] = bank;
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret != 1) {
+		dev_info(&client->dev, "%s: switch to bank 0x%x from 0x%x failed\n",
+			__func__, bank, client->addr);
+		return;
+	}
+	lt6911uxc->bank_i2c = bank;
+}
+
+static void lt6911uxc_i2c_wr8(struct v4l2_subdev *sd, u16 reg, u8 val)
+{
+	struct lt6911uxc_state *lt6911uxc = to_state(sd);
+	struct i2c_client *client = lt6911uxc->i2c_client;
+	int ret;
+	struct i2c_msg msg;
+	u8 data[2];
+	u8 address;
+
+	/* write register bank offset */
+	u8 bank = (reg >> 8) & 0xFF;
+
+	lt6911uxc_reg_bank(sd, bank);
+	address = reg & 0xFF;
+	msg.addr = client->addr;
+	msg.buf = data;
+	msg.len = 2;
+	msg.flags = 0;
+
+	data[0] = address;
+	data[1] = val;
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+
+	if (ret != 1) {
+		dev_info(&client->dev, "%s: write register 0x%x from 0x%x failed\n",
+			__func__, reg, client->addr);
+	}
+	dev_dbg(&client->dev, "i2c: write register: 0x%04X = 0x%02X\n",
+		reg, val);
+}
+
+static void lt6911uxc_i2c_rd(struct v4l2_subdev *sd, u16 reg, u8 *values, u32 n)
+{
+	struct lt6911uxc_state *lt6911uxc = to_state(sd);
+	struct i2c_client *client = lt6911uxc->i2c_client;
+	int ret;
+	u8 reg_addr[1] = { (u8)(reg & 0xff) };
+	u8 bank_addr   = (u8)((reg >> 8) & 0xFF);
+
+	struct i2c_msg msgs[] = {
+		{
+			.addr = client->addr,
+			.flags = 0,		/* write */
+			.len = 1,
+			.buf = reg_addr,
+		},
+		{
+			.addr = client->addr,
+			.flags = I2C_M_RD,	/* read n bytes */
+			.len = n,
+			.buf = values,
+		},
+	};
+
+	/* write register bank offset */
+	lt6911uxc_reg_bank(sd, bank_addr);
+
+	ret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));
+	if (ret != ARRAY_SIZE(msgs)) {
+		dev_info(&client->dev, "%s: read register 0x%04X from 0x%x failed\n",
+			__func__, reg, client->addr);
+	}
+}
+
+static u8 lt6911uxc_i2c_rd8(struct v4l2_subdev *sd, u16 reg)
+{
+	u8 val = 0;
+
+	lt6911uxc_i2c_rd(sd, reg, &val, 1);
+
+	dev_dbg(sd->dev, "i2c: read 0x%04X = 0x%02X\n", reg, val);
+	return val;
+}
+
+static u16 lt6911uxc_i2c_rd16(struct v4l2_subdev *sd, u16 reg)
+{
+	u16 val = 0;
+	u8 tmp;
+
+	lt6911uxc_i2c_rd(sd, reg, (u8 *)&val, 2);
+	/* high byte always at lower address -> swap */
+	tmp = val & 0xFF;
+	val = (val >> 8) | tmp << 8;
+
+	dev_dbg(sd->dev, "i2c: read 0x%04X = 0x%04X\n", reg, val);
+	return val;
+}
+
+static void lt6911uxc_ext_control(
+	struct lt6911uxc_state *lt6911uxc,
+	bool enable)
+{
+	if (!lt6911uxc)
+		return;
+
+	if (lt6911uxc->enable_i2c == enable)
+		return;
+
+	lt6911uxc->enable_i2c = enable;
+	if (enable) {
+		lt6911uxc_i2c_wr8(&lt6911uxc->sd, REG_ENABLE_I2C, 0x01);
+		lt6911uxc_i2c_wr8(&lt6911uxc->sd, REG_DISABLE_WD, 0x00);
+	} else
+		lt6911uxc_i2c_wr8(&lt6911uxc->sd, REG_ENABLE_I2C, 0x00);
+}
+
+static int lt6911uxc_csi_enable(struct v4l2_subdev *sd, bool enable)
+{
+	if (enable)
+		lt6911uxc_i2c_wr8(sd, REG_MIPI_TX_CTRL, 0xFB);
+	else
+		lt6911uxc_i2c_wr8(sd, REG_MIPI_TX_CTRL, 0x00);
+	return 0;
+}
+
+static int lt6911uxc_get_audio_sampling_rate(struct lt6911uxc_state *lt6911uxc)
+{
+	int audio_fs, idx;
+	static const int eps = 1500;
+	static const int rates_default[] = {
+		32000, 44100, 48000, 88200, 96000, 176400, 192000
+	};
+
+	audio_fs = lt6911uxc_i2c_rd8(&lt6911uxc->sd, REG_AUDIO_SR) * 1000;
+	dev_dbg(&lt6911uxc->i2c_client->dev, "%s: Audio sample rate %d [Hz]\n",
+		__func__, audio_fs);
+
+	/* audio_fs is an approximation of sample rate - search nearest */
+	for (idx = 0; idx < ARRAY_SIZE(rates_default); ++idx) {
+		if ((rates_default[idx] - eps < audio_fs) &&
+		    (rates_default[idx] + eps > audio_fs))
+			return rates_default[idx];
+	}
+	dev_info(&lt6911uxc->i2c_client->dev, "%s: unhandled sampling rate %d [Hz]",
+		__func__, audio_fs);
+	return 0;
+}
+
+static int lt6911uxc_log_status(struct v4l2_subdev *sd)
+{
+
+#ifdef TIMINGS_ENABLE
+	struct lt6911uxc_state *lt6911uxc = to_state(sd);
+
+	v4l2_info(sd, "----- Timings -----\n");
+	if (!&lt6911uxc->detected_timings.bt.width) {
+		v4l2_info(sd, "no video detected\n");
+	} else {
+		v4l2_print_dv_timings(sd->name, "detected format: ",
+				&lt6911uxc->detected_timings, true);
+	}
+	v4l2_print_dv_timings(sd->name, "configured format: ",
+		&lt6911uxc->timings, true);
+#endif
+	return 0;
+}
+
+static int lt6911uxc_subscribe_event(struct v4l2_subdev *sd, struct v4l2_fh *fh,
+		struct v4l2_event_subscription *sub)
+{
+	dev_info(sd->dev, "%s():\n", __func__);
+
+	switch (sub->type) {
+	case V4L2_EVENT_SOURCE_CHANGE:
+		return v4l2_src_change_event_subdev_subscribe(sd, fh, sub);
+	case V4L2_EVENT_EOS:
+		return v4l2_event_subscribe(fh, sub, 2, NULL);
+	default:
+		return -EINVAL;
+	}
+}
+
+static const struct v4l2_dv_timings_cap *lt6911uxc_g_timings_cap(
+		struct lt6911uxc_state *lt6911uxc)
+{
+	return &lt6911uxc_timings_cap_4kp30;
+}
+
+static int lt6911uxc_g_input_status(struct v4l2_subdev *sd, u32 *status)
+{
+	struct lt6911uxc_state *lt6911uxc = to_state(sd);
+
+	*status = 0;
+	*status |= lt6911uxc->streaming ? V4L2_IN_ST_NO_SIGNAL : 0;
+
+	v4l2_dbg(1, debug, sd, "%s: status = 0x%x\n", __func__, *status);
+	return 0;
+}
+
+static int __maybe_unused lt6911uxc_s_dv_timings(struct v4l2_subdev *sd,
+		struct v4l2_dv_timings *timings)
+{
+	struct lt6911uxc_state *lt6911uxc = to_state(sd);
+
+	v4l2_dbg(3, debug, sd, "%s():\n", __func__);
+
+	if (!v4l2_valid_dv_timings(timings, lt6911uxc_g_timings_cap(lt6911uxc),
+				   NULL, NULL)) {
+		v4l2_err(sd, "%s: timings out of range\n", __func__);
+		return -EINVAL;
+	}
+
+	v4l2_find_dv_timings_cap(timings, lt6911uxc_g_timings_cap(lt6911uxc), 0,
+				 NULL, NULL);
+	memset(timings->bt.reserved, 0, sizeof(timings->bt.reserved));
+	lt6911uxc->timings = *timings;
+	return 0;
+}
+
+static int lt6911uxc_g_dv_timings(struct v4l2_subdev *sd,
+		struct v4l2_dv_timings *timings)
+{
+	struct lt6911uxc_state *lt6911uxc = to_state(sd);
+
+	v4l2_dbg(3, debug, sd, "%s():\n", __func__);
+
+	*timings = lt6911uxc->timings;
+	return 0;
+}
+
+static int __maybe_unused lt6911uxc_query_dv_timings(struct v4l2_subdev *sd,
+		struct v4l2_dv_timings *timings)
+{
+	struct lt6911uxc_state *lt6911uxc = to_state(sd);
+
+	v4l2_dbg(3, debug, sd, "%s():\n", __func__);
+
+	if (false == lt6911uxc->streaming) {
+		v4l2_warn(sd, "%s: no valid signal\n", __func__);
+		return -ENOLINK;
+	}
+
+	if (!v4l2_valid_dv_timings(&lt6911uxc->detected_timings,
+		lt6911uxc_g_timings_cap(lt6911uxc), NULL, NULL)) {
+		v4l2_warn(sd, "%s: timings out of range\n", __func__);
+		return -ERANGE;
+	}
+
+	*timings = lt6911uxc->detected_timings;
+	return 0;
+}
+
+static const struct v4l2_ctrl_config lt6911uxc_ctrl_audio_sampling_rate = {
+	.id = LT6911UXC_CID_AUDIO_SAMPLING_RATE,
+	.name = "Audio Sampling Rate",
+	.type = V4L2_CTRL_TYPE_INTEGER,
+	.min = 32000,
+	.max = 192000,
+	.step = 100,
+	.def = 48000,
+	.flags = V4L2_CTRL_FLAG_READ_ONLY,
+};
+
+static const struct v4l2_ctrl_config lt6911uxc_ctrl_audio_present = {
+	.id = LT6911UXC_CID_AUDIO_PRESENT,
+	.name = "Audio Present",
+	.type = V4L2_CTRL_TYPE_BOOLEAN,
+	.min = 0,
+	.max = 1,
+	.step = 1,
+	.def = 0,
+	.flags = V4L2_CTRL_FLAG_READ_ONLY,
+};
+
+static u64 __maybe_unused get_hblank(struct lt6911uxc_state *lt6911uxc)
+{
+	u64 hblank;
+	u64 pixel_rate;
+	u64 pixel_clk;
+
+	if (lt6911uxc->cur_mode->lanes == 4) {
+		pixel_rate = FSERIAL_CLK_4_LANE;
+		pixel_clk = PIX_CLK_4_LANE;
+	} else if (lt6911uxc->cur_mode->lanes == 2) {
+		pixel_rate = FSERIAL_CLK_2_LANE;
+		pixel_clk = PIX_CLK_2_LANE;
+	} else {
+		pixel_rate = FSERIAL_CLK_4_LANE;
+		pixel_clk = PIX_CLK_4_LANE;
+	}
+
+	if (pixel_clk)
+		hblank = 0x128 * (pixel_rate / pixel_clk);
+	else
+		hblank = 1184;
+
+	return hblank;
+}
+
+static int lt6911uxc_set_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct lt6911uxc_state *lt6911uxc = container_of(ctrl->handler,
+				struct lt6911uxc_state, ctrl_handler);
+	struct i2c_client *client = v4l2_get_subdevdata(&lt6911uxc->sd);
+	s64 exposure_max;
+	int ret = 0;
+
+	/* Propagate change of current control to all related controls */
+	if (ctrl->id == V4L2_CID_VBLANK) {
+		/* Update max exposure while meeting expected vblanking */
+		exposure_max = 1;
+		__v4l2_ctrl_modify_range(lt6911uxc->exposure,
+					 lt6911uxc->exposure->minimum,
+					 exposure_max,
+					 lt6911uxc->exposure->step,
+					 lt6911uxc->cur_mode->height - 1);
+	}
+
+	/* V4L2 controls values will be applied only when power is already up */
+	if (!pm_runtime_get_if_in_use(&client->dev))
+		return 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_ANALOGUE_GAIN:
+		dev_dbg(&client->dev, "set analogue gain.\n");
+		break;
+
+	case V4L2_CID_DIGITAL_GAIN:
+		dev_dbg(&client->dev, "set digital gain.\n");
+		break;
+
+	case V4L2_CID_EXPOSURE:
+		dev_dbg(&client->dev, "set exposure time.\n");
+		break;
+
+	case V4L2_CID_VBLANK:
+		dev_dbg(&client->dev, "set vblank %d\n",
+			lt6911uxc->cur_mode->height + ctrl->val);
+		break;
+	case V4L2_CID_FLASH_STROBE_SOURCE:
+		dev_dbg(&client->dev, "set led flash source %d\n", ctrl->val);
+		break;
+
+	case V4L2_CID_FLASH_STROBE:
+		dev_dbg(&client->dev, "set flash strobe.\n");
+		break;
+
+	case V4L2_CID_FLASH_STROBE_STOP:
+		dev_dbg(&client->dev, "turn off led %d\n", ctrl->val);
+		break;
+
+	case V4L2_CID_FLASH_TIMEOUT:
+		dev_dbg(&client->dev, "set led delay\n");
+		break;
+
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	pm_runtime_put(&client->dev);
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops lt6911uxc_ctrl_ops = {
+	.s_ctrl = lt6911uxc_set_ctrl,
+};
+
+static struct v4l2_ctrl_config lt6911uxc_csi_port = {
+	.ops	= &lt6911uxc_ctrl_ops,
+	.id	= LT6911UXC_CID_CSI_PORT,
+	.type	= V4L2_CTRL_TYPE_INTEGER,
+	.name	= "CSI port",
+	.min	= 0,
+	.max	= 5,
+	.def	= 1,
+	.step	= 1,
+	.flags	= V4L2_CTRL_FLAG_READ_ONLY,
+};
+
+static struct v4l2_ctrl_config lt6911uxc_i2c_bus = {
+	.ops	= &lt6911uxc_ctrl_ops,
+	.id	= LT6911UXC_CID_I2C_BUS,
+	.type	= V4L2_CTRL_TYPE_INTEGER,
+	.name	= "I2C bus",
+	.min	= 0,
+	.max	= MINORMASK,
+	.def	= 0,
+	.step	= 1,
+	.flags	= V4L2_CTRL_FLAG_READ_ONLY,
+};
+
+static struct v4l2_ctrl_config lt6911uxc_i2c_id = {
+	.ops	= &lt6911uxc_ctrl_ops,
+	.id	= LT6911UXC_CID_I2C_ID,
+	.type	= V4L2_CTRL_TYPE_INTEGER,
+	.name	= "I2C id",
+	.min	= 0x10,
+	.max	= 0x77,
+	.def	= 0x10,
+	.step	= 1,
+	.flags	= V4L2_CTRL_FLAG_READ_ONLY,
+};
+
+static struct v4l2_ctrl_config lt6911uxc_i2c_slave_address = {
+	.ops	= &lt6911uxc_ctrl_ops,
+	.id	= LT6911UXC_CID_I2C_SLAVE_ADDRESS,
+	.type	= V4L2_CTRL_TYPE_INTEGER,
+	.name	= "I2C slave address",
+	.min	= 0x0,
+	.max	= 0x7f,
+	.def	= 0x2b,
+	.step	= 1,
+	.flags	= V4L2_CTRL_FLAG_READ_ONLY,
+};
+
+static struct v4l2_ctrl_config lt6911uxc_fps = {
+	.ops	= &lt6911uxc_ctrl_ops,
+	.id	= LT6911UXC_CID_FPS,
+	.type	= V4L2_CTRL_TYPE_INTEGER,
+	.name	= "fps",
+	.min	= 25,
+	.max	= 60,
+	.def	= 30,
+	.step	= 1,
+	.flags	= V4L2_CTRL_FLAG_READ_ONLY,
+};
+
+static struct v4l2_ctrl_config lt6911uxc_frame_interval = {
+	.ops	= &lt6911uxc_ctrl_ops,
+	.id	= LT6911UXC_CID_FRAME_INTERVAL,
+	.type	= V4L2_CTRL_TYPE_INTEGER,
+	.name	= "frame interval",
+	.min	= 16,
+	.max	= 40,
+	.def	= 33,
+	.step	= 1,
+	.flags	= V4L2_CTRL_FLAG_READ_ONLY,
+};
+
+static u64 get_pixel_rate(struct lt6911uxc_state *lt6911uxc)
+{
+	if (lt6911uxc->cur_mode->lanes)
+		return lt6911uxc->cur_mode->width * lt6911uxc->cur_mode->height *
+			lt6911uxc->cur_mode->fps * 16 / lt6911uxc->cur_mode->lanes;
+	else
+		return 995328000; /* default value: 4K@30 */
+}
+
+static int lt6911uxc_init_controls(struct lt6911uxc_state *lt6911uxc)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&lt6911uxc->sd);
+	struct v4l2_ctrl_handler *ctrl_hdlr;
+	s64 hblank;
+	int ret;
+
+	ctrl_hdlr = &lt6911uxc->ctrl_handler;
+	ret = v4l2_ctrl_handler_init(ctrl_hdlr, 8);
+	if (ret)
+		return ret;
+
+	ctrl_hdlr->lock = &lt6911uxc->mutex;
+	lt6911uxc->link_freq =
+		v4l2_ctrl_new_int_menu(ctrl_hdlr,
+			&lt6911uxc_ctrl_ops,
+			V4L2_CID_LINK_FREQ,
+			sizeof(lt6911uxc->cur_mode->pixel_clk),
+			0, &lt6911uxc->cur_mode->pixel_clk);
+	if (ctrl_hdlr->error) {
+		dev_dbg(&client->dev, "Set link_freq ctrl_hdlr, err=%d.\n",
+			ctrl_hdlr->error);
+		return ctrl_hdlr->error;
+	}
+	if (lt6911uxc->link_freq)
+		lt6911uxc->link_freq->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	lt6911uxc->vblank = v4l2_ctrl_new_std(ctrl_hdlr,
+				&lt6911uxc_ctrl_ops,
+				V4L2_CID_VBLANK, 0, 1, 1, 1);
+	if (ctrl_hdlr->error) {
+		dev_dbg(&client->dev, "Set vblank ctrl_hdlr, err=%d.\n",
+			ctrl_hdlr->error);
+		return ctrl_hdlr->error;
+	}
+
+	lt6911uxc->analogue_gain = v4l2_ctrl_new_std(ctrl_hdlr,
+			&lt6911uxc_ctrl_ops,
+			V4L2_CID_ANALOGUE_GAIN, 0, 1, 1, 1);
+	if (ctrl_hdlr->error) {
+		dev_dbg(&client->dev, "Set analogue_gain ctrl_hdlr, err=%d.\n",
+			ctrl_hdlr->error);
+		return ctrl_hdlr->error;
+	}
+
+	lt6911uxc->digital_gain = v4l2_ctrl_new_std(ctrl_hdlr,
+			&lt6911uxc_ctrl_ops,
+			V4L2_CID_DIGITAL_GAIN,	0, 1, 1, 1);
+	if (ctrl_hdlr->error) {
+		dev_dbg(&client->dev, "Set digital_gain ctrl_hdlr, err=%d.\n",
+			ctrl_hdlr->error);
+		return ctrl_hdlr->error;
+	}
+
+	lt6911uxc->exposure = v4l2_ctrl_new_std(ctrl_hdlr,
+				&lt6911uxc_ctrl_ops,
+				V4L2_CID_EXPOSURE, 0, 1, 1, 1);
+	if (ctrl_hdlr->error) {
+		dev_dbg(&client->dev, "Set exposure ctrl_hdlr, err=%d.\n",
+			ctrl_hdlr->error);
+		return ctrl_hdlr->error;
+	}
+	lt6911uxc_csi_port.def = lt6911uxc->platform_data->port;
+	lt6911uxc->csi_port =
+		v4l2_ctrl_new_custom(ctrl_hdlr, &lt6911uxc_csi_port, NULL);
+	if (ctrl_hdlr->error) {
+		dev_dbg(&client->dev, "Set csi_port ctrl_hdlr, err=%d.\n",
+			ctrl_hdlr->error);
+		return ctrl_hdlr->error;
+	}
+
+	lt6911uxc_i2c_bus.def = i2c_adapter_id(client->adapter);
+	lt6911uxc->i2c_bus =
+		v4l2_ctrl_new_custom(ctrl_hdlr, &lt6911uxc_i2c_bus, NULL);
+	if (ctrl_hdlr->error) {
+		dev_dbg(&client->dev, "Set i2c_bus ctrl_hdlr, err=%d.\n",
+			ctrl_hdlr->error);
+		return ctrl_hdlr->error;
+	}
+
+	lt6911uxc_i2c_id.def = client->addr;
+	lt6911uxc->i2c_id = v4l2_ctrl_new_custom(ctrl_hdlr,
+				&lt6911uxc_i2c_id, NULL);
+	if (ctrl_hdlr->error) {
+		dev_dbg(&client->dev, "Set i2c_id ctrl_hdlr, err=%d.\n",
+			ctrl_hdlr->error);
+		return ctrl_hdlr->error;
+	}
+
+	lt6911uxc_i2c_slave_address.def =
+		lt6911uxc->platform_data->i2c_slave_address;
+	lt6911uxc->i2c_slave_address = v4l2_ctrl_new_custom(ctrl_hdlr,
+					&lt6911uxc_i2c_slave_address, NULL);
+	if (ctrl_hdlr->error) {
+		dev_dbg(&client->dev, "Set i2c_slave_address ctrl_hdlr, err=%d.\n",
+			ctrl_hdlr->error);
+		return ctrl_hdlr->error;
+	}
+
+	lt6911uxc_fps.def = lt6911uxc->cur_mode->fps;
+	lt6911uxc->fps = v4l2_ctrl_new_custom(ctrl_hdlr, &lt6911uxc_fps, NULL);
+	if (ctrl_hdlr->error) {
+		dev_dbg(&client->dev, "Set fps ctrl_hdlr, err=%d.\n",
+			ctrl_hdlr->error);
+		return ctrl_hdlr->error;
+	}
+
+	if (lt6911uxc->cur_mode->fps)
+		lt6911uxc_frame_interval.def = 1000 / lt6911uxc->cur_mode->fps;
+	else
+		lt6911uxc_frame_interval.def = 33;
+
+	lt6911uxc->frame_interval = v4l2_ctrl_new_custom(ctrl_hdlr,
+					&lt6911uxc_frame_interval, NULL);
+	if (ctrl_hdlr->error) {
+		dev_dbg(&client->dev, "Set frame_interval ctrl_hdlr, err=%d.\n",
+			ctrl_hdlr->error);
+		return ctrl_hdlr->error;
+	}
+
+	lt6911uxc->pixel_rate = v4l2_ctrl_new_std(ctrl_hdlr,
+				&lt6911uxc_ctrl_ops,
+				V4L2_CID_PIXEL_RATE,
+				get_pixel_rate(lt6911uxc),
+				get_pixel_rate(lt6911uxc), 1,
+				get_pixel_rate(lt6911uxc));
+	if (ctrl_hdlr->error) {
+		dev_dbg(&client->dev, "Set pixel_rate ctrl_hdlr, err=%d.\n",
+			ctrl_hdlr->error);
+		return ctrl_hdlr->error;
+	}
+	if (lt6911uxc->pixel_rate)
+		lt6911uxc->pixel_rate->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	hblank = 1;
+	lt6911uxc->hblank = v4l2_ctrl_new_std(ctrl_hdlr,
+				&lt6911uxc_ctrl_ops,
+				V4L2_CID_HBLANK, 0, 1, 1, 1);
+	if (ctrl_hdlr->error) {
+		dev_dbg(&client->dev, "Set hblank ctrl_hdlr, err=%d.\n",
+			ctrl_hdlr->error);
+		return ctrl_hdlr->error;
+	}
+	if (lt6911uxc->hblank)
+		lt6911uxc->hblank->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	/* custom v4l2 audio controls */
+	lt6911uxc->audio_sampling_rate_ctrl = v4l2_ctrl_new_custom(
+		ctrl_hdlr, &lt6911uxc_ctrl_audio_sampling_rate, NULL);
+	if (ctrl_hdlr->error) {
+		dev_dbg(&client->dev, "Set audio sampling rate ctrl, err=%d.\n",
+			 ctrl_hdlr->error);
+		return ctrl_hdlr->error;
+	}
+	lt6911uxc->audio_present_ctrl = v4l2_ctrl_new_custom(ctrl_hdlr,
+		&lt6911uxc_ctrl_audio_present, NULL);
+	if (ctrl_hdlr->error) {
+		dev_dbg(&client->dev, "Set audio present ctrl, error = %d.\n",
+			ctrl_hdlr->error);
+		return ctrl_hdlr->error;
+	}
+
+	lt6911uxc->sd.ctrl_handler = ctrl_hdlr;
+	return 0;
+}
+
+static void lt6911uxc_update_pad_format(const struct lt6911uxc_mode *mode,
+				     struct v4l2_mbus_framefmt *fmt)
+{
+	fmt->width = mode->width;
+	fmt->height = mode->height;
+	fmt->code = mode->code;
+	fmt->field = V4L2_FIELD_NONE;
+}
+
+static int lt6911uxc_start_streaming(struct lt6911uxc_state *lt6911uxc)
+{
+	int ret = 0;
+
+	if (lt6911uxc->auxiliary_port == true)
+		return 0;
+
+	lt6911uxc_ext_control(lt6911uxc, true);
+	lt6911uxc_csi_enable(&lt6911uxc->sd, true);
+	lt6911uxc_ext_control(lt6911uxc, false);
+
+	ret = __v4l2_ctrl_handler_setup(lt6911uxc->sd.ctrl_handler);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static void lt6911uxc_stop_streaming(struct lt6911uxc_state *lt6911uxc)
+{
+	if (lt6911uxc->auxiliary_port == true)
+		return;
+
+	/*The fps of 1080p60fps will be dropped to half when the CSI disabled. */
+	lt6911uxc_ext_control(lt6911uxc, true);
+	lt6911uxc_csi_enable(&lt6911uxc->sd, false);
+	lt6911uxc_ext_control(lt6911uxc, false);
+}
+
+static int lt6911uxc_set_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct lt6911uxc_state *lt6911uxc = to_state(sd);
+	int ret = 0;
+
+	if (lt6911uxc->streaming == enable)
+		return 0;
+
+	if (lt6911uxc->auxiliary_port == true)
+		return 0;
+
+	mutex_lock(&lt6911uxc->mutex);
+	if (enable) {
+		dev_dbg(sd->dev, "[%s()], start streaming.\n", __func__);
+		ret = lt6911uxc_start_streaming(lt6911uxc);
+		if (ret) {
+			enable = 0;
+			lt6911uxc_stop_streaming(lt6911uxc);
+		}
+	} else {
+		dev_dbg(sd->dev, "[%s()], stop streaming.\n", __func__);
+		lt6911uxc_stop_streaming(lt6911uxc);
+	}
+	mutex_unlock(&lt6911uxc->mutex);
+
+	lt6911uxc->streaming = enable;
+
+	return ret;
+}
+
+static int lt6911uxc_g_frame_interval(struct v4l2_subdev *sd,
+		struct v4l2_subdev_frame_interval *fival)
+{
+	struct lt6911uxc_state *lt6911uxc = to_state(sd);
+
+	fival->pad = 0;
+	fival->interval.numerator = 1;
+	fival->interval.denominator = lt6911uxc->cur_mode->fps;
+
+	return 0;
+}
+
+static int lt6911uxc_set_format(struct v4l2_subdev *sd,
+				struct v4l2_subdev_state *sd_state,
+			     struct v4l2_subdev_format *fmt)
+{
+	struct lt6911uxc_state *lt6911uxc = to_state(sd);
+	s32 vblank_def;
+	s64 hblank;
+
+	mutex_lock(&lt6911uxc->mutex);
+	lt6911uxc_update_pad_format(lt6911uxc->cur_mode, &fmt->format);
+	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {
+		*v4l2_subdev_get_try_format(sd, sd_state, fmt->pad) = fmt->format;
+	} else {
+		__v4l2_ctrl_s_ctrl(lt6911uxc->link_freq,
+			lt6911uxc->cur_mode->link_freq_index);
+		__v4l2_ctrl_modify_range(lt6911uxc->pixel_rate,
+			25000000, 297000000, 1,
+			get_pixel_rate(lt6911uxc));
+
+		hblank = get_hblank(lt6911uxc);
+		__v4l2_ctrl_modify_range(lt6911uxc->hblank,
+					hblank,
+					hblank,
+					1,
+					hblank);
+
+		/* Update limits and set FPS to default */
+		vblank_def = lt6911uxc->cur_mode->vts_def - lt6911uxc->cur_mode->height;
+		__v4l2_ctrl_modify_range(lt6911uxc->vblank,
+					 0,
+					 0xffff - lt6911uxc->cur_mode->height, 1,
+					 vblank_def);
+		__v4l2_ctrl_s_ctrl(lt6911uxc->vblank, vblank_def);
+
+		__v4l2_ctrl_s_ctrl(lt6911uxc->fps, lt6911uxc->cur_mode->fps);
+
+		if (lt6911uxc->cur_mode->fps)
+			__v4l2_ctrl_s_ctrl(lt6911uxc->frame_interval, 1000 / lt6911uxc->cur_mode->fps);
+		else
+			__v4l2_ctrl_s_ctrl(lt6911uxc->frame_interval, 33);
+	}
+	mutex_unlock(&lt6911uxc->mutex);
+
+	return 0;
+}
+
+static int lt6911uxc_get_format(struct v4l2_subdev *sd,
+			     struct v4l2_subdev_state *sd_state,
+			     struct v4l2_subdev_format *fmt)
+{
+	struct lt6911uxc_state *lt6911uxc = to_state(sd);
+
+	mutex_lock(&lt6911uxc->mutex);
+	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY)
+		fmt->format = *v4l2_subdev_get_try_format(&lt6911uxc->sd, sd_state,
+							fmt->pad);
+	else
+		lt6911uxc_update_pad_format(lt6911uxc->cur_mode, &fmt->format);
+
+	mutex_unlock(&lt6911uxc->mutex);
+
+	return 0;
+}
+
+static int lt6911uxc_enum_mbus_code(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_state *sd_state,
+				 struct v4l2_subdev_mbus_code_enum *code)
+{
+	struct lt6911uxc_state *lt6911uxc = to_state(sd);
+
+	code->code = lt6911uxc->cur_mode->code;
+	return 0;
+}
+
+static int lt6911uxc_enum_frame_size(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_state *sd_state,
+				  struct v4l2_subdev_frame_size_enum *fse)
+{
+	struct lt6911uxc_state *lt6911uxc = to_state(sd);
+
+	fse->min_width = lt6911uxc->cur_mode->width;
+	fse->max_width = fse->min_width;
+	fse->min_height = lt6911uxc->cur_mode->height;
+	fse->max_height = fse->min_height;
+
+	return 0;
+}
+
+static int lt6911uxc_enum_frame_interval(struct v4l2_subdev *sd,
+		struct v4l2_subdev_state *sd_state,
+		struct v4l2_subdev_frame_interval_enum *fie)
+{
+	struct lt6911uxc_state *lt6911uxc = to_state(sd);
+
+	fie->interval.numerator = 1;
+	fie->interval.denominator = lt6911uxc->cur_mode->fps;
+
+	return 0;
+}
+
+static int lt6911uxc_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct lt6911uxc_state *lt6911uxc = to_state(sd);
+
+	if (!lt6911uxc->auxiliary_port)
+		lt6911uxc_set_stream(sd, true);
+	lt6911uxc_update_pad_format(lt6911uxc->cur_mode,
+			v4l2_subdev_get_try_format(sd, fh->state, 0));
+
+	return 0;
+}
+
+static int lt6911uxc_close(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+
+	struct lt6911uxc_state *lt6911uxc = to_state(sd);
+
+	if (!lt6911uxc->auxiliary_port)
+		lt6911uxc_set_stream(sd, false);
+
+	return 0;
+}
+
+static const struct v4l2_subdev_internal_ops lt6911uxc_subdev_internal_ops = {
+	.open = lt6911uxc_open,
+	.close = lt6911uxc_close,
+};
+
+static const struct v4l2_subdev_video_ops lt6911uxc_video_ops = {
+	.s_stream = lt6911uxc_set_stream,
+	.g_frame_interval = lt6911uxc_g_frame_interval,
+	.g_input_status	= lt6911uxc_g_input_status,
+//	.s_dv_timings	= lt6911uxc_s_dv_timings,
+	.g_dv_timings	= lt6911uxc_g_dv_timings,
+//	.query_dv_timings	= lt6911uxc_query_dv_timings,
+	.s_stream	= lt6911uxc_set_stream,
+};
+
+static const struct v4l2_subdev_pad_ops lt6911uxc_pad_ops = {
+	.set_fmt = lt6911uxc_set_format,
+	.get_fmt = lt6911uxc_get_format,
+	.enum_mbus_code = lt6911uxc_enum_mbus_code,
+	.enum_frame_size = lt6911uxc_enum_frame_size,
+	.enum_frame_interval = lt6911uxc_enum_frame_interval,
+};
+
+static struct v4l2_subdev_core_ops lt6911uxc_subdev_core_ops = {
+	.log_status	= lt6911uxc_log_status,
+	.subscribe_event	= lt6911uxc_subscribe_event,
+	.unsubscribe_event	= v4l2_event_subdev_unsubscribe,
+};
+
+static const struct v4l2_subdev_ops lt6911uxc_subdev_ops = {
+	.core = &lt6911uxc_subdev_core_ops,
+	.video = &lt6911uxc_video_ops,
+	.pad = &lt6911uxc_pad_ops,
+};
+
+static const struct media_entity_operations lt6911uxc_subdev_entity_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+static const struct v4l2_subdev_internal_ops lt6911uxc_internal_ops = {
+	.open = lt6911uxc_open,
+};
+
+static int lt6911uxc_identify_module(struct lt6911uxc_state *lt6911uxc)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&lt6911uxc->sd);
+	u16 val;
+
+	val = lt6911uxc_i2c_rd16(&lt6911uxc->sd, REG_CHIP_ID);
+
+	if (val != LT6911UXC_CHIP_ID) {
+		dev_err(&client->dev, "chip id mismatch: %x!=%x",
+			LT6911UXC_CHIP_ID, val);
+		return -ENXIO;
+	}
+	dev_info(&client->dev,
+		"Found lt6911uxc Bridge Chip, ID is 0x%x\n", val);
+	return 0;
+}
+
+static void lt6911uxc_remove(struct i2c_client *client)
+{
+}
+
+static int lt6911uxc_video_status_update(struct lt6911uxc_state *lt6911uxc)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&lt6911uxc->sd);
+	u16 val = 0;
+	u8 int_event = 0;
+	u32 tmds_clk = 0;
+	u32 byte_clock = 0, pixel_clk = 0;
+	u8 is_hdmi_2_0 = 0;
+	u32 htotal = 0, vtotal = 0;
+	u32 width = 0, height = 0;
+	u32 fps = 0, lanes = 4;
+	u8 fm0 = 0,  fm1 = 0, fm2 = 0;
+
+	/* Read interrupt event */
+	int_event = lt6911uxc_i2c_rd8(&lt6911uxc->sd,
+			REG_INT_HDMI);
+	switch (int_event) {
+	case INT_HDMI_STABLE:
+		dev_dbg(&client->dev, "Video signal stable\n");
+
+		/* byte clock / MIPI clock */
+		lt6911uxc_i2c_wr8(&lt6911uxc->sd,
+			REG_AD_HALF_PCLK, 0x1B);
+		usleep_range(10000, 10100);
+		fm2 = lt6911uxc_i2c_rd8(&lt6911uxc->sd,
+			REG_FM1_FREQ_IN2) & MASK_FMI_FREQ2;
+		fm1 = lt6911uxc_i2c_rd8(&lt6911uxc->sd,
+			REG_FM1_FREQ_IN1);
+		fm0 = lt6911uxc_i2c_rd8(&lt6911uxc->sd,
+			REG_FM1_FREQ_IN0);
+
+		byte_clock = (fm2<<16 | fm1<<8 | fm0) * 1000;
+
+		/* TMDS clock / Pixel clock*/
+		val =  lt6911uxc_i2c_rd8(&lt6911uxc->sd,
+			REG_TMDS_CLK_IN2);
+		tmds_clk |= ((val & 0x0f) << 16);
+		val =  lt6911uxc_i2c_rd8(&lt6911uxc->sd,
+			REG_TMDS_CLK_IN1);
+		tmds_clk |= (val << 8);
+		val =  lt6911uxc_i2c_rd8(&lt6911uxc->sd,
+			REG_TMDS_CLK_IN0);
+		tmds_clk |= val;
+
+		val = lt6911uxc_i2c_rd8(&lt6911uxc->sd,
+			REG_BKB0_A2_REG);
+		is_hdmi_2_0 = val & (1<<0) ? !0 : !!0;
+		pixel_clk = (is_hdmi_2_0 ? 4 * tmds_clk : tmds_clk) * 1000;
+
+		/* video frame size */
+		htotal = lt6911uxc_i2c_rd16(&lt6911uxc->sd,
+			 REG_H_TOTAL) * 2;
+		vtotal = lt6911uxc_i2c_rd16(&lt6911uxc->sd,
+			 REG_V_TOTAL);
+		width = lt6911uxc_i2c_rd16(&lt6911uxc->sd,
+			 REG_H_ACTIVE) * 2;
+		height = lt6911uxc_i2c_rd16(&lt6911uxc->sd,
+			 REG_V_ACTIVE);
+		if (htotal && vtotal)
+			fps = pixel_clk / (htotal * vtotal);
+		lanes = lt6911uxc_i2c_rd8(&lt6911uxc->sd,
+			 REG_MIPI_LANES);
+
+		lt6911uxc->cur_mode->height = height;
+		lt6911uxc->cur_mode->fps = fps;
+		lt6911uxc->cur_mode->code = MEDIA_BUS_FMT_UYVY8_1X16;
+
+		if (lanes == 8) {
+			/* 4K60fps with 2 MIPI ports*/
+			if (width >= 3840)
+				lt6911uxc->cur_mode->width = width/2; /* YUV422 */
+			else
+				lt6911uxc->cur_mode->width = width; /* YUV420 */
+			lt6911uxc->cur_mode->lanes = lanes/2;
+			lt6911uxc->cur_mode->pixel_clk = pixel_clk/2;
+			lt6911uxc->cur_mode->byte_clk = byte_clock/2;
+		} else {
+			lt6911uxc->cur_mode->width = width;
+			lt6911uxc->cur_mode->lanes = lanes;
+			lt6911uxc->cur_mode->pixel_clk = pixel_clk;
+			lt6911uxc->cur_mode->byte_clk = byte_clock;
+		}
+		v4l2_subdev_notify_event(&lt6911uxc->sd,
+			&lt6911uxc_ev_source_change);
+
+		dev_dbg(&client->dev,  "Pixel Clk:%u, %lld\n",
+			pixel_clk, lt6911uxc->cur_mode->pixel_clk);
+		dev_dbg(&client->dev,
+			"width:%u, height:%u, fps:%u, lanes: %d\n",
+			lt6911uxc->cur_mode->width,
+			lt6911uxc->cur_mode->height,
+			lt6911uxc->cur_mode->fps,
+			lt6911uxc->cur_mode->lanes);
+	break;
+	case INT_HDMI_DISCONNECT:
+		lt6911uxc->cur_mode->width = 0;
+		lt6911uxc->cur_mode->height = 0;
+		lt6911uxc->cur_mode->fps = 30;
+		lt6911uxc->cur_mode->pixel_clk = 0;
+		lt6911uxc->cur_mode->code = MEDIA_BUS_FMT_UYVY8_1X16;
+		lt6911uxc->cur_mode->byte_clk = 0;
+		lt6911uxc->cur_mode->lanes = 4;
+		v4l2_subdev_notify_event(&lt6911uxc->sd,
+			&lt6911uxc_ev_stream_end);
+
+		dev_dbg(&client->dev, "Video signal disconnected\n");
+	break;
+	default:
+		dev_dbg(&client->dev, "Unhandled video= 0x%02X\n", int_event);
+	return  -ENOLINK;
+	}
+
+	return 0;
+}
+
+static void lt6911uxc_audio_status_update(struct lt6911uxc_state *lt6911uxc)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&lt6911uxc->sd);
+	u8 int_event;
+	int audio_fs = 0;
+
+	/* read interrupt event */
+	int_event = lt6911uxc_i2c_rd8(&lt6911uxc->sd, REG_INT_AUDIO);
+	dev_dbg(&client->dev, "Audio event:0x%02X\n", int_event);
+
+	switch (int_event) {
+	case AUDIO_DISCONNECT:
+		dev_dbg(&client->dev, "Audio signal disconnected\n");
+		audio_fs = 0;
+		lt6911uxc->cur_mode->audio_sample_rate = 0;
+		break;
+	case AUDIO_SR_HIGH:
+	case AUDIO_SR_LOW:
+			audio_fs = lt6911uxc_get_audio_sampling_rate(lt6911uxc);
+			lt6911uxc->cur_mode->audio_sample_rate = audio_fs;
+			dev_dbg(&client->dev,
+				"Sampling rate changed: %d\n", audio_fs);
+		break;
+	default:
+		dev_dbg(&client->dev, "Unhandled audio= 0x%02X\n", int_event);
+		// use the default value for avoiding problem
+		lt6911uxc->cur_mode->audio_sample_rate = 0;
+		break;
+	}
+
+	__v4l2_ctrl_s_ctrl(lt6911uxc->audio_present_ctrl,
+		(lt6911uxc->cur_mode->audio_sample_rate != 0));
+
+	if (lt6911uxc->cur_mode->audio_sample_rate)
+		__v4l2_ctrl_s_ctrl(lt6911uxc->audio_sampling_rate_ctrl,
+			lt6911uxc->cur_mode->audio_sample_rate);
+}
+
+static void  lt6911uxc_check_status(struct lt6911uxc_state *lt6911uxc)
+{
+	mutex_lock(&lt6911uxc->mutex);
+	lt6911uxc_ext_control(lt6911uxc, true);
+	lt6911uxc_video_status_update(lt6911uxc);
+	lt6911uxc_audio_status_update(lt6911uxc);
+	lt6911uxc_i2c_wr8(&lt6911uxc->sd, REG_INT_RESPOND, 1);
+	lt6911uxc_ext_control(lt6911uxc, false);
+	mutex_unlock(&lt6911uxc->mutex);
+}
+
+static irqreturn_t lt6911uxc_threaded_irq_fn(int irq, void *dev_id)
+{
+	struct v4l2_subdev *sd = dev_id;
+	struct lt6911uxc_state *lt6911uxc;
+
+	if (!sd) {
+		dev_err(NULL, "Invalid dev_id argument!\n");
+		return IRQ_NONE;
+	}
+
+	lt6911uxc = to_state(sd);
+	if (!lt6911uxc) {
+		dev_err(sd->dev, "Invalid lt6911uxc state argument!\n");
+		return IRQ_NONE;
+	}
+
+	dev_dbg(sd->dev, "%s in kthread %d\n", __func__, current->pid);
+	lt6911uxc_check_status(lt6911uxc);
+	return IRQ_HANDLED;
+}
+
+static int lt6911uxc_probe(struct i2c_client *client)
+{
+	struct lt6911uxc_state *lt6911uxc;
+	struct v4l2_subdev *sd;
+	int ret;
+
+	lt6911uxc = devm_kzalloc(&client->dev, sizeof(struct lt6911uxc_state),
+			     GFP_KERNEL);
+	if (!lt6911uxc)
+		return -ENOMEM;
+
+	lt6911uxc->cur_mode = devm_kzalloc(&client->dev, sizeof(struct lt6911uxc_mode),
+	     GFP_KERNEL);
+	if (!lt6911uxc->cur_mode)
+		return -ENOMEM;
+
+	memset(lt6911uxc->cur_mode, 0, sizeof(struct lt6911uxc_mode));
+	lt6911uxc->cur_mode->width = 3840,
+	lt6911uxc->cur_mode->height = 2160,
+	lt6911uxc->cur_mode->code = MEDIA_BUS_FMT_UYVY8_1X16,
+	lt6911uxc->cur_mode->lanes = 4,
+	lt6911uxc->cur_mode->fps = 30,
+	lt6911uxc->cur_mode->bpp = 8,
+	lt6911uxc->cur_mode->pixel_clk = 297000000,
+	lt6911uxc->cur_mode->byte_clk = 168000000,
+	lt6911uxc->cur_mode->audio_sample_rate = 48000,
+
+	lt6911uxc->platform_data = client->dev.platform_data;
+	if (lt6911uxc->platform_data == NULL) {
+		dev_err(&client->dev, "no platform data provided\n");
+		return -EINVAL;
+	}
+
+	lt6911uxc->i2c_client = client;
+	sd = &lt6911uxc->sd;
+	v4l2_i2c_subdev_init(sd, client, &lt6911uxc_subdev_ops);
+
+	if (lt6911uxc->platform_data->suffix)
+		snprintf(lt6911uxc->sd.name,
+			sizeof(lt6911uxc->sd.name), "lt6911uxc %c",
+			lt6911uxc->platform_data->suffix);
+
+	mutex_init(&lt6911uxc->mutex);
+
+	if (-1 != lt6911uxc->platform_data->reset_pin)
+		if (!gpio_get_value(lt6911uxc->platform_data->reset_pin))
+			gpio_set_value(lt6911uxc->platform_data->reset_pin, 1);
+
+	if (-1 != lt6911uxc->platform_data->irq_pin) {
+		lt6911uxc->auxiliary_port = false;
+		dev_info(&client->dev, "Probing lt6911uxc chip...\n");
+
+		lt6911uxc_ext_control(lt6911uxc, true);
+		ret = lt6911uxc_identify_module(lt6911uxc);
+		if (ret) {
+			dev_err(&client->dev, "failed to find chip: %d", ret);
+			return ret;
+		}
+		lt6911uxc_ext_control(lt6911uxc, false);
+
+		ret = lt6911uxc_init_controls(lt6911uxc);
+		if (ret) {
+			dev_info(&client->dev,  "Could not init control %d!\n", ret);
+			goto probe_error_v4l2_ctrl_handler_free;
+		}
+
+		lt6911uxc->sd.internal_ops = &lt6911uxc_internal_ops;
+		lt6911uxc->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+		lt6911uxc->sd.entity.ops = &lt6911uxc_subdev_entity_ops;
+		lt6911uxc->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;
+		lt6911uxc->pad.flags = MEDIA_PAD_FL_SOURCE;
+		ret = media_entity_pads_init(&lt6911uxc->sd.entity, 1, &lt6911uxc->pad);
+		if (ret) {
+			dev_err(&client->dev, "Init entity pads failed:%d\n", ret);
+			goto probe_error_v4l2_ctrl_handler_free;
+		}
+
+		/* Setting irq */
+		ret = devm_gpio_request_one(&client->dev,
+				lt6911uxc->platform_data->irq_pin,
+				GPIOF_OUT_INIT_HIGH, "Interrupt signal");
+		if (ret) {
+			dev_err(&client->dev, "IRQ pin %d (name: %s) request failed! ret: %d\n",
+				lt6911uxc->platform_data->irq_pin,
+				lt6911uxc->platform_data->irq_pin_name, ret);
+			goto probe_error_v4l2_ctrl_handler_free;
+		}
+
+		ret = gpio_direction_input(lt6911uxc->platform_data->irq_pin);
+		if (ret) {
+			dev_err(&client->dev, "Set gpio pin %d direction input failed! ret: %d\n",
+				lt6911uxc->platform_data->irq_pin, ret);
+			goto probe_error_v4l2_ctrl_handler_free;
+		}
+
+		ret = devm_request_threaded_irq(&client->dev,
+				gpio_to_irq(lt6911uxc->platform_data->irq_pin),
+				NULL, lt6911uxc_threaded_irq_fn,
+				lt6911uxc->platform_data->irq_pin_flags,
+				lt6911uxc->platform_data->irq_pin_name, lt6911uxc);
+		if (ret) {
+			dev_err(&client->dev, "IRQ request failed! ret: %d\n", ret);
+			goto probe_error_v4l2_ctrl_handler_free;
+		}
+		/* Check the current status */
+		usleep_range(200000, 205000);
+		lt6911uxc_check_status(lt6911uxc);
+		/* Stop to transmit MIPI data firstly waiting for IPU ready */
+		lt6911uxc_stop_streaming(lt6911uxc);
+	} else {
+		/* 4K60fps mode, the setting needs to be fixed on 1920x2160@60fps*/
+		lt6911uxc->auxiliary_port = true;
+		lt6911uxc->cur_mode->width = 1920,
+		lt6911uxc->cur_mode->height = 2160,
+		lt6911uxc->cur_mode->fps = 60,
+
+		ret = lt6911uxc_init_controls(lt6911uxc);
+		if (ret) {
+			dev_info(&client->dev,  "Could not init control %d!\n", ret);
+			goto probe_error_v4l2_ctrl_handler_free;
+		}
+
+		lt6911uxc->sd.internal_ops = &lt6911uxc_internal_ops;
+		lt6911uxc->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+		lt6911uxc->sd.entity.ops = &lt6911uxc_subdev_entity_ops;
+		lt6911uxc->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;
+		lt6911uxc->pad.flags = MEDIA_PAD_FL_SOURCE;
+		ret = media_entity_pads_init(&lt6911uxc->sd.entity, 1, &lt6911uxc->pad);
+		if (ret) {
+			dev_err(&client->dev, "Init entity pads failed:%d\n", ret);
+			goto probe_error_v4l2_ctrl_handler_free;
+		}
+	}
+
+	lt6911uxc->sd.dev = &client->dev;
+	lt6911uxc->sd.internal_ops = &lt6911uxc_subdev_internal_ops;
+	lt6911uxc->sd.flags |=
+			V4L2_SUBDEV_FL_HAS_DEVNODE | V4L2_SUBDEV_FL_HAS_EVENTS;
+	ret = v4l2_async_register_subdev_sensor(&lt6911uxc->sd);
+	if (ret < 0) {
+		dev_err(&client->dev, "failed to register V4L2 subdev: %d",
+			ret);
+		goto probe_error_media_entity_cleanup;
+	}
+
+	/*
+	 * Device is already turned on by i2c-core with ACPI domain PM.
+	 * Enable runtime PM and turn off the device.
+	 */
+	pm_runtime_set_active(&client->dev);
+	pm_runtime_enable(&client->dev);
+	pm_runtime_idle(&client->dev);
+	dev_info(&client->dev, "End to probe lt6911uxc Bridge Chip.\n");
+	return 0;
+
+probe_error_media_entity_cleanup:
+	media_entity_cleanup(&lt6911uxc->sd.entity);
+
+probe_error_v4l2_ctrl_handler_free:
+	v4l2_ctrl_handler_free(lt6911uxc->sd.ctrl_handler);
+	mutex_destroy(&lt6911uxc->mutex);
+
+	return ret;
+}
+
+static int lt6911uxc_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct lt6911uxc_state *lt6911uxc = to_state(sd);
+
+	if (-1 != lt6911uxc->platform_data->reset_pin)
+		if (gpio_get_value(lt6911uxc->platform_data->reset_pin))
+			gpio_set_value(lt6911uxc->platform_data->reset_pin, 0);
+
+	mutex_lock(&lt6911uxc->mutex);
+	if (lt6911uxc->streaming)
+		lt6911uxc_stop_streaming(lt6911uxc);
+
+	mutex_unlock(&lt6911uxc->mutex);
+	dev_dbg(sd->dev, "suspend streaming...\n");
+	return 0;
+}
+
+static int lt6911uxc_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct lt6911uxc_state *lt6911uxc = to_state(sd);
+	int ret;
+
+	if (-1 != lt6911uxc->platform_data->reset_pin)
+		if (!gpio_get_value(lt6911uxc->platform_data->reset_pin))
+			gpio_set_value(lt6911uxc->platform_data->reset_pin, 1);
+
+	usleep_range(200000, 205000);
+	//recheck the current HDMI status in case changed
+	lt6911uxc_check_status(lt6911uxc);
+
+	mutex_lock(&lt6911uxc->mutex);
+	if (lt6911uxc->streaming) {
+		ret = lt6911uxc_start_streaming(lt6911uxc);
+		if (ret) {
+			lt6911uxc->streaming = false;
+			lt6911uxc_stop_streaming(lt6911uxc);
+			mutex_unlock(&lt6911uxc->mutex);
+			return ret;
+		}
+	}
+	mutex_unlock(&lt6911uxc->mutex);
+	dev_dbg(sd->dev, "resume streaming...\n");
+	return 0;
+}
+
+static const struct dev_pm_ops lt6911uxc_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lt6911uxc_suspend, lt6911uxc_resume)
+};
+
+static const struct i2c_device_id lt6911uxc_id_table[] = {
+	{ "lt6911uxc", 0 },
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(i2c, lt6911uxc_id_table);
+
+static struct i2c_driver lt6911uxc_i2c_driver = {
+	.driver = {
+		.name = "lt6911uxc",
+		.pm = &lt6911uxc_pm_ops,
+	},
+	.probe_new = lt6911uxc_probe,
+	.remove = lt6911uxc_remove,
+	.id_table = lt6911uxc_id_table,
+};
+
+module_i2c_driver(lt6911uxc_i2c_driver);
+
+MODULE_AUTHOR("Fu Wei <wei.a.fu@intel.com>");
+MODULE_DESCRIPTION("lt6911uxc HDMI to MIPI Bridge Driver");
+MODULE_LICENSE("GPL v2");
Index: b/drivers/media/i2c/ov01a10.c
===================================================================
--- /dev/null
+++ b/drivers/media/i2c/ov01a10.c
@@ -0,0 +1,916 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (c) 2020-2022 Intel Corporation.
+
+#include <asm/unaligned.h>
+#include <linux/acpi.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/version.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-fwnode.h>
+
+#define OV01A10_LINK_FREQ_400MHZ	400000000ULL
+#define OV01A10_SCLK			40000000LL
+#define OV01A10_MCLK			19200000
+#define OV01A10_DATA_LANES		1
+#define OV01A10_RGB_DEPTH		10
+
+#define OV01A10_REG_CHIP_ID		0x300a
+#define OV01A10_CHIP_ID			0x560141
+
+#define OV01A10_REG_MODE_SELECT		0x0100
+#define OV01A10_MODE_STANDBY		0x00
+#define OV01A10_MODE_STREAMING		0x01
+
+/* vertical-timings from sensor */
+#define OV01A10_REG_VTS			0x380e
+#define OV01A10_VTS_DEF			0x0380
+#define OV01A10_VTS_MIN			0x0380
+#define OV01A10_VTS_MAX			0xffff
+
+/* Exposure controls from sensor */
+#define OV01A10_REG_EXPOSURE		0x3501
+#define OV01A10_EXPOSURE_MIN		4
+#define OV01A10_EXPOSURE_MAX_MARGIN	8
+#define OV01A10_EXPOSURE_STEP		1
+
+/* Analog gain controls from sensor */
+#define OV01A10_REG_ANALOG_GAIN		0x3508
+#define OV01A10_ANAL_GAIN_MIN		0x100
+#define OV01A10_ANAL_GAIN_MAX		0xffff
+#define OV01A10_ANAL_GAIN_STEP		1
+
+/* Digital gain controls from sensor */
+#define OV01A10_REG_DIGILAL_GAIN_B	0x350A
+#define OV01A10_REG_DIGITAL_GAIN_GB	0x3510
+#define OV01A10_REG_DIGITAL_GAIN_GR	0x3513
+#define OV01A10_REG_DIGITAL_GAIN_R	0x3516
+#define OV01A10_DGTL_GAIN_MIN		0
+#define OV01A10_DGTL_GAIN_MAX		0x3ffff
+#define OV01A10_DGTL_GAIN_STEP		1
+#define OV01A10_DGTL_GAIN_DEFAULT	1024
+
+/* Test Pattern Control */
+#define OV01A10_REG_TEST_PATTERN		0x4503
+#define OV01A10_TEST_PATTERN_ENABLE	BIT(7)
+#define OV01A10_TEST_PATTERN_BAR_SHIFT	0
+
+enum {
+	OV01A10_LINK_FREQ_400MHZ_INDEX,
+};
+
+struct ov01a10_reg {
+	u16 address;
+	u8 val;
+};
+
+struct ov01a10_reg_list {
+	u32 num_of_regs;
+	const struct ov01a10_reg *regs;
+};
+
+struct ov01a10_link_freq_config {
+	const struct ov01a10_reg_list reg_list;
+};
+
+struct ov01a10_mode {
+	/* Frame width in pixels */
+	u32 width;
+
+	/* Frame height in pixels */
+	u32 height;
+
+	/* Horizontal timining size */
+	u32 hts;
+
+	/* Default vertical timining size */
+	u32 vts_def;
+
+	/* Min vertical timining size */
+	u32 vts_min;
+
+	/* Link frequency needed for this resolution */
+	u32 link_freq_index;
+
+	/* Sensor register settings for this resolution */
+	const struct ov01a10_reg_list reg_list;
+};
+
+static const struct ov01a10_reg mipi_data_rate_720mbps[] = {
+};
+
+static const struct ov01a10_reg sensor_1280x800_setting[] = {
+	{0x0103, 0x01},
+	{0x0302, 0x00},
+	{0x0303, 0x06},
+	{0x0304, 0x01},
+	{0x0305, 0xe0},
+	{0x0306, 0x00},
+	{0x0308, 0x01},
+	{0x0309, 0x00},
+	{0x030c, 0x01},
+	{0x0322, 0x01},
+	{0x0323, 0x06},
+	{0x0324, 0x01},
+	{0x0325, 0x68},
+	{0x3002, 0xa1},
+	{0x301e, 0xf0},
+	{0x3022, 0x01},
+	{0x3501, 0x03},
+	{0x3502, 0x78},
+	{0x3504, 0x0c},
+	{0x3508, 0x01},
+	{0x3509, 0x00},
+	{0x3601, 0xc0},
+	{0x3603, 0x71},
+	{0x3610, 0x68},
+	{0x3611, 0x86},
+	{0x3640, 0x10},
+	{0x3641, 0x80},
+	{0x3642, 0xdc},
+	{0x3646, 0x55},
+	{0x3647, 0x57},
+	{0x364b, 0x00},
+	{0x3653, 0x10},
+	{0x3655, 0x00},
+	{0x3656, 0x00},
+	{0x365f, 0x0f},
+	{0x3661, 0x45},
+	{0x3662, 0x24},
+	{0x3663, 0x11},
+	{0x3664, 0x07},
+	{0x3709, 0x34},
+	{0x370b, 0x6f},
+	{0x3714, 0x22},
+	{0x371b, 0x27},
+	{0x371c, 0x67},
+	{0x371d, 0xa7},
+	{0x371e, 0xe7},
+	{0x3730, 0x81},
+	{0x3733, 0x10},
+	{0x3734, 0x40},
+	{0x3737, 0x04},
+	{0x3739, 0x1c},
+	{0x3767, 0x00},
+	{0x376c, 0x81},
+	{0x3772, 0x14},
+	{0x37c2, 0x04},
+	{0x37d8, 0x03},
+	{0x37d9, 0x0c},
+	{0x37e0, 0x00},
+	{0x37e1, 0x08},
+	{0x37e2, 0x10},
+	{0x37e3, 0x04},
+	{0x37e4, 0x04},
+	{0x37e5, 0x03},
+	{0x37e6, 0x04},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0x00},
+	{0x3804, 0x05},
+	{0x3805, 0x0f},
+	{0x3806, 0x03},
+	{0x3807, 0x2f},
+	{0x3808, 0x05},
+	{0x3809, 0x00},
+	{0x380a, 0x03},
+	{0x380b, 0x20},
+	{0x380c, 0x02},
+	{0x380d, 0xe8},
+	{0x380e, 0x03},
+	{0x380f, 0x80},
+	{0x3810, 0x00},
+	{0x3811, 0x09},
+	{0x3812, 0x00},
+	{0x3813, 0x08},
+	{0x3814, 0x01},
+	{0x3815, 0x01},
+	{0x3816, 0x01},
+	{0x3817, 0x01},
+	{0x3820, 0xa8},
+	{0x3822, 0x13},
+	{0x3832, 0x28},
+	{0x3833, 0x10},
+	{0x3b00, 0x00},
+	{0x3c80, 0x00},
+	{0x3c88, 0x02},
+	{0x3c8c, 0x07},
+	{0x3c8d, 0x40},
+	{0x3cc7, 0x80},
+	{0x4000, 0xc3},
+	{0x4001, 0xe0},
+	{0x4003, 0x40},
+	{0x4008, 0x02},
+	{0x4009, 0x19},
+	{0x400a, 0x01},
+	{0x400b, 0x6c},
+	{0x4011, 0x00},
+	{0x4041, 0x00},
+	{0x4300, 0xff},
+	{0x4301, 0x00},
+	{0x4302, 0x0f},
+	{0x4503, 0x00},
+	{0x4601, 0x50},
+	{0x4800, 0x64},
+	{0x481f, 0x34},
+	{0x4825, 0x33},
+	{0x4837, 0x11},
+	{0x4881, 0x40},
+	{0x4883, 0x01},
+	{0x4890, 0x00},
+	{0x4901, 0x00},
+	{0x4902, 0x00},
+	{0x4b00, 0x2a},
+	{0x4b0d, 0x00},
+	{0x450a, 0x04},
+	{0x450b, 0x00},
+	{0x5000, 0x65},
+	{0x5200, 0x18},
+	{0x5004, 0x00},
+	{0x5080, 0x40},
+	{0x0305, 0xf4},
+	{0x0325, 0xc2},
+	{0x380c, 0x05},
+	{0x380d, 0xd0},
+};
+
+static const char * const ov01a10_test_pattern_menu[] = {
+	"Disabled",
+	"Color Bar",
+	"Top-Bottom Darker Color Bar",
+	"Right-Left Darker Color Bar",
+	"Color Bar type 4",
+};
+
+static const s64 link_freq_menu_items[] = {
+	OV01A10_LINK_FREQ_400MHZ,
+};
+
+static const struct ov01a10_link_freq_config link_freq_configs[] = {
+	[OV01A10_LINK_FREQ_400MHZ_INDEX] = {
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(mipi_data_rate_720mbps),
+			.regs = mipi_data_rate_720mbps,
+		}
+	},
+};
+
+static const struct ov01a10_mode supported_modes[] = {
+	{
+		.width = 1280,
+		.height = 800,
+		.hts = 1488,
+		.vts_def = OV01A10_VTS_DEF,
+		.vts_min = OV01A10_VTS_MIN,
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(sensor_1280x800_setting),
+			.regs = sensor_1280x800_setting,
+		},
+		.link_freq_index = OV01A10_LINK_FREQ_400MHZ_INDEX,
+	},
+};
+
+struct ov01a10 {
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_ctrl_handler ctrl_handler;
+
+	/* V4L2 Controls */
+	struct v4l2_ctrl *link_freq;
+	struct v4l2_ctrl *pixel_rate;
+	struct v4l2_ctrl *vblank;
+	struct v4l2_ctrl *hblank;
+	struct v4l2_ctrl *exposure;
+
+	/* Current mode */
+	const struct ov01a10_mode *cur_mode;
+
+	/* To serialize asynchronus callbacks */
+	struct mutex mutex;
+
+	/* Streaming on/off */
+	bool streaming;
+};
+
+static inline struct ov01a10 *to_ov01a10(struct v4l2_subdev *subdev)
+{
+	return container_of(subdev, struct ov01a10, sd);
+}
+
+static int ov01a10_read_reg(struct ov01a10 *ov01a10, u16 reg, u16 len, u32 *val)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&ov01a10->sd);
+	struct i2c_msg msgs[2];
+	u8 addr_buf[2];
+	u8 data_buf[4] = {0};
+	int ret = 0;
+
+	if (len > sizeof(data_buf))
+		return -EINVAL;
+
+	put_unaligned_be16(reg, addr_buf);
+	msgs[0].addr = client->addr;
+	msgs[0].flags = 0;
+	msgs[0].len = sizeof(addr_buf);
+	msgs[0].buf = addr_buf;
+	msgs[1].addr = client->addr;
+	msgs[1].flags = I2C_M_RD;
+	msgs[1].len = len;
+	msgs[1].buf = &data_buf[sizeof(data_buf) - len];
+
+	ret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));
+
+	if (ret != ARRAY_SIZE(msgs))
+		return ret < 0 ? ret : -EIO;
+
+	*val = get_unaligned_be32(data_buf);
+
+	return 0;
+}
+
+static int ov01a10_write_reg(struct ov01a10 *ov01a10, u16 reg, u16 len, u32 val)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&ov01a10->sd);
+	u8 buf[6];
+	int ret = 0;
+
+	if (len > 4)
+		return -EINVAL;
+
+	put_unaligned_be16(reg, buf);
+	put_unaligned_be32(val << 8 * (4 - len), buf + 2);
+
+	ret = i2c_master_send(client, buf, len + 2);
+	if (ret != len + 2)
+		return ret < 0 ? ret : -EIO;
+
+	return 0;
+}
+
+static int ov01a10_write_reg_list(struct ov01a10 *ov01a10,
+				  const struct ov01a10_reg_list *r_list)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&ov01a10->sd);
+	unsigned int i;
+	int ret = 0;
+
+	for (i = 0; i < r_list->num_of_regs; i++) {
+		ret = ov01a10_write_reg(ov01a10, r_list->regs[i].address, 1,
+					r_list->regs[i].val);
+		if (ret) {
+			dev_err_ratelimited(&client->dev,
+					    "write reg 0x%4.4x return err = %d",
+					    r_list->regs[i].address, ret);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int ov01a10_update_digital_gain(struct ov01a10 *ov01a10, u32 d_gain)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&ov01a10->sd);
+	u32 real = d_gain << 6;
+	int ret = 0;
+
+	ret = ov01a10_write_reg(ov01a10, OV01A10_REG_DIGILAL_GAIN_B, 3, real);
+	if (ret) {
+		dev_err(&client->dev, "failed to set OV01A10_REG_DIGITAL_GAIN_B");
+		return ret;
+	}
+	ret = ov01a10_write_reg(ov01a10, OV01A10_REG_DIGITAL_GAIN_GB, 3, real);
+	if (ret) {
+		dev_err(&client->dev, "failed to set OV01A10_REG_DIGITAL_GAIN_GB");
+		return ret;
+	}
+	ret = ov01a10_write_reg(ov01a10, OV01A10_REG_DIGITAL_GAIN_GR, 3, real);
+	if (ret) {
+		dev_err(&client->dev, "failed to set OV01A10_REG_DIGITAL_GAIN_GR");
+		return ret;
+	}
+
+	ret = ov01a10_write_reg(ov01a10, OV01A10_REG_DIGITAL_GAIN_R, 3, real);
+	if (ret) {
+		dev_err(&client->dev, "failed to set OV01A10_REG_DIGITAL_GAIN_R");
+		return ret;
+	}
+	return ret;
+}
+
+static int ov01a10_test_pattern(struct ov01a10 *ov01a10, u32 pattern)
+{
+	if (pattern)
+		pattern = (pattern - 1) << OV01A10_TEST_PATTERN_BAR_SHIFT |
+			  OV01A10_TEST_PATTERN_ENABLE;
+
+	return ov01a10_write_reg(ov01a10, OV01A10_REG_TEST_PATTERN, 1, pattern);
+}
+
+static int ov01a10_set_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct ov01a10 *ov01a10 = container_of(ctrl->handler,
+					     struct ov01a10, ctrl_handler);
+	struct i2c_client *client = v4l2_get_subdevdata(&ov01a10->sd);
+	s64 exposure_max;
+	int ret = 0;
+
+	/* Propagate change of current control to all related controls */
+	if (ctrl->id == V4L2_CID_VBLANK) {
+		/* Update max exposure while meeting expected vblanking */
+		exposure_max = ov01a10->cur_mode->height + ctrl->val -
+			       OV01A10_EXPOSURE_MAX_MARGIN;
+		__v4l2_ctrl_modify_range(ov01a10->exposure,
+					 ov01a10->exposure->minimum,
+					 exposure_max, ov01a10->exposure->step,
+					 exposure_max);
+	}
+
+	/* V4L2 controls values will be applied only when power is already up */
+	if (!pm_runtime_get_if_in_use(&client->dev))
+		return 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_ANALOGUE_GAIN:
+		ret = ov01a10_write_reg(ov01a10, OV01A10_REG_ANALOG_GAIN, 2,
+					ctrl->val);
+		break;
+
+	case V4L2_CID_DIGITAL_GAIN:
+		ret = ov01a10_update_digital_gain(ov01a10, ctrl->val);
+		break;
+
+	case V4L2_CID_EXPOSURE:
+		ret = ov01a10_write_reg(ov01a10, OV01A10_REG_EXPOSURE, 2,
+					ctrl->val);
+		break;
+
+	case V4L2_CID_VBLANK:
+		ret = ov01a10_write_reg(ov01a10, OV01A10_REG_VTS, 2,
+					ov01a10->cur_mode->height + ctrl->val);
+		break;
+
+	case V4L2_CID_TEST_PATTERN:
+		ret = ov01a10_test_pattern(ov01a10, ctrl->val);
+		break;
+
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	pm_runtime_put(&client->dev);
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops ov01a10_ctrl_ops = {
+	.s_ctrl = ov01a10_set_ctrl,
+};
+
+static int ov01a10_init_controls(struct ov01a10 *ov01a10)
+{
+	struct v4l2_ctrl_handler *ctrl_hdlr;
+	const struct ov01a10_mode *cur_mode;
+	s64 exposure_max, h_blank;
+	u32 vblank_min, vblank_max, vblank_default;
+	int size;
+	int ret = 0;
+
+	ctrl_hdlr = &ov01a10->ctrl_handler;
+	ret = v4l2_ctrl_handler_init(ctrl_hdlr, 8);
+	if (ret)
+		return ret;
+
+	ctrl_hdlr->lock = &ov01a10->mutex;
+	cur_mode = ov01a10->cur_mode;
+	size = ARRAY_SIZE(link_freq_menu_items);
+
+	ov01a10->link_freq = v4l2_ctrl_new_int_menu(ctrl_hdlr,
+						    &ov01a10_ctrl_ops,
+						    V4L2_CID_LINK_FREQ,
+						    size - 1, 0,
+						    link_freq_menu_items);
+	if (ov01a10->link_freq)
+		ov01a10->link_freq->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	ov01a10->pixel_rate = v4l2_ctrl_new_std(ctrl_hdlr, &ov01a10_ctrl_ops,
+						V4L2_CID_PIXEL_RATE, 0,
+						OV01A10_SCLK, 1, OV01A10_SCLK);
+
+	vblank_min = cur_mode->vts_min - cur_mode->height;
+	vblank_max = OV01A10_VTS_MAX - cur_mode->height;
+	vblank_default = cur_mode->vts_def - cur_mode->height;
+	ov01a10->vblank = v4l2_ctrl_new_std(ctrl_hdlr, &ov01a10_ctrl_ops,
+					    V4L2_CID_VBLANK, vblank_min,
+					    vblank_max, 1, vblank_default);
+
+	h_blank = cur_mode->hts - cur_mode->width;
+	ov01a10->hblank = v4l2_ctrl_new_std(ctrl_hdlr, &ov01a10_ctrl_ops,
+					    V4L2_CID_HBLANK, h_blank, h_blank,
+					    1, h_blank);
+	if (ov01a10->hblank)
+		ov01a10->hblank->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	v4l2_ctrl_new_std(ctrl_hdlr, &ov01a10_ctrl_ops, V4L2_CID_ANALOGUE_GAIN,
+			  OV01A10_ANAL_GAIN_MIN, OV01A10_ANAL_GAIN_MAX,
+			  OV01A10_ANAL_GAIN_STEP, OV01A10_ANAL_GAIN_MIN);
+	v4l2_ctrl_new_std(ctrl_hdlr, &ov01a10_ctrl_ops, V4L2_CID_DIGITAL_GAIN,
+			  OV01A10_DGTL_GAIN_MIN, OV01A10_DGTL_GAIN_MAX,
+			  OV01A10_DGTL_GAIN_STEP, OV01A10_DGTL_GAIN_DEFAULT);
+	exposure_max = cur_mode->vts_def - OV01A10_EXPOSURE_MAX_MARGIN;
+	ov01a10->exposure = v4l2_ctrl_new_std(ctrl_hdlr, &ov01a10_ctrl_ops,
+					      V4L2_CID_EXPOSURE,
+					      OV01A10_EXPOSURE_MIN,
+					      exposure_max,
+					      OV01A10_EXPOSURE_STEP,
+					      exposure_max);
+	v4l2_ctrl_new_std_menu_items(ctrl_hdlr, &ov01a10_ctrl_ops,
+				     V4L2_CID_TEST_PATTERN,
+				     ARRAY_SIZE(ov01a10_test_pattern_menu) - 1,
+				     0, 0, ov01a10_test_pattern_menu);
+	if (ctrl_hdlr->error)
+		return ctrl_hdlr->error;
+
+	ov01a10->sd.ctrl_handler = ctrl_hdlr;
+
+	return 0;
+}
+
+static void ov01a10_update_pad_format(const struct ov01a10_mode *mode,
+				      struct v4l2_mbus_framefmt *fmt)
+{
+	fmt->width = mode->width;
+	fmt->height = mode->height;
+	fmt->code = MEDIA_BUS_FMT_SBGGR10_1X10;
+	fmt->field = V4L2_FIELD_NONE;
+}
+
+static int ov01a10_start_streaming(struct ov01a10 *ov01a10)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&ov01a10->sd);
+	const struct ov01a10_reg_list *reg_list;
+	int link_freq_index;
+	int ret = 0;
+	link_freq_index = ov01a10->cur_mode->link_freq_index;
+	reg_list = &link_freq_configs[link_freq_index].reg_list;
+	ret = ov01a10_write_reg_list(ov01a10, reg_list);
+	if (ret) {
+		dev_err(&client->dev, "failed to set plls");
+		return ret;
+	}
+
+	reg_list = &ov01a10->cur_mode->reg_list;
+	ret = ov01a10_write_reg_list(ov01a10, reg_list);
+	if (ret) {
+		dev_err(&client->dev, "failed to set mode");
+		return ret;
+	}
+
+	ret = __v4l2_ctrl_handler_setup(ov01a10->sd.ctrl_handler);
+	if (ret)
+		return ret;
+
+	ret = ov01a10_write_reg(ov01a10, OV01A10_REG_MODE_SELECT, 1,
+				OV01A10_MODE_STREAMING);
+	if (ret)
+		dev_err(&client->dev, "failed to start streaming");
+
+	return ret;
+}
+
+static void ov01a10_stop_streaming(struct ov01a10 *ov01a10)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&ov01a10->sd);
+	int ret = 0;
+
+	ret = ov01a10_write_reg(ov01a10, OV01A10_REG_MODE_SELECT, 1,
+				OV01A10_MODE_STANDBY);
+	if (ret)
+		dev_err(&client->dev, "failed to stop streaming");
+}
+
+static int ov01a10_set_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct ov01a10 *ov01a10 = to_ov01a10(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = 0;
+
+	if (ov01a10->streaming == enable)
+		return 0;
+
+	mutex_lock(&ov01a10->mutex);
+	if (enable) {
+		ret = pm_runtime_get_sync(&client->dev);
+		if (ret < 0) {
+			pm_runtime_put_noidle(&client->dev);
+			mutex_unlock(&ov01a10->mutex);
+			return ret;
+		}
+
+		ret = ov01a10_start_streaming(ov01a10);
+		if (ret) {
+			enable = 0;
+			ov01a10_stop_streaming(ov01a10);
+			pm_runtime_put(&client->dev);
+		}
+	} else {
+		ov01a10_stop_streaming(ov01a10);
+		pm_runtime_put(&client->dev);
+	}
+
+	ov01a10->streaming = enable;
+	mutex_unlock(&ov01a10->mutex);
+
+	return ret;
+}
+
+static int __maybe_unused ov01a10_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov01a10 *ov01a10 = to_ov01a10(sd);
+
+	mutex_lock(&ov01a10->mutex);
+	if (ov01a10->streaming)
+		ov01a10_stop_streaming(ov01a10);
+
+	mutex_unlock(&ov01a10->mutex);
+
+	return 0;
+}
+
+static int __maybe_unused ov01a10_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov01a10 *ov01a10 = to_ov01a10(sd);
+	int ret = 0;
+
+	mutex_lock(&ov01a10->mutex);
+	if (!ov01a10->streaming)
+		goto exit;
+
+	ret = ov01a10_start_streaming(ov01a10);
+	if (ret) {
+		ov01a10->streaming = false;
+		ov01a10_stop_streaming(ov01a10);
+	}
+
+exit:
+	mutex_unlock(&ov01a10->mutex);
+	return ret;
+}
+
+static int ov01a10_set_format(struct v4l2_subdev *sd,
+			      struct v4l2_subdev_state *sd_state,
+			      struct v4l2_subdev_format *fmt)
+{
+	struct ov01a10 *ov01a10 = to_ov01a10(sd);
+	const struct ov01a10_mode *mode;
+	s32 vblank_def, h_blank;
+
+	mode = v4l2_find_nearest_size(supported_modes,
+				      ARRAY_SIZE(supported_modes), width,
+				      height, fmt->format.width,
+				      fmt->format.height);
+
+	mutex_lock(&ov01a10->mutex);
+	ov01a10_update_pad_format(mode, &fmt->format);
+	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {
+		*v4l2_subdev_get_try_format(sd, sd_state, fmt->pad) = fmt->format;
+	} else {
+		ov01a10->cur_mode = mode;
+		__v4l2_ctrl_s_ctrl(ov01a10->link_freq, mode->link_freq_index);
+		__v4l2_ctrl_s_ctrl_int64(ov01a10->pixel_rate, OV01A10_SCLK);
+
+		/* Update limits and set FPS to default */
+		vblank_def = mode->vts_def - mode->height;
+		__v4l2_ctrl_modify_range(ov01a10->vblank,
+					 mode->vts_min - mode->height,
+					 OV01A10_VTS_MAX - mode->height, 1,
+					 vblank_def);
+		__v4l2_ctrl_s_ctrl(ov01a10->vblank, vblank_def);
+		h_blank = mode->hts - mode->width;
+		__v4l2_ctrl_modify_range(ov01a10->hblank, h_blank, h_blank, 1,
+					 h_blank);
+	}
+	mutex_unlock(&ov01a10->mutex);
+
+	return 0;
+}
+
+static int ov01a10_get_format(struct v4l2_subdev *sd,
+			      struct v4l2_subdev_state *sd_state,
+			      struct v4l2_subdev_format *fmt)
+{
+	struct ov01a10 *ov01a10 = to_ov01a10(sd);
+
+	mutex_lock(&ov01a10->mutex);
+	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY)
+		fmt->format = *v4l2_subdev_get_try_format(&ov01a10->sd,
+							  sd_state, fmt->pad);
+	else
+		ov01a10_update_pad_format(ov01a10->cur_mode, &fmt->format);
+
+	mutex_unlock(&ov01a10->mutex);
+
+	return 0;
+}
+
+static int ov01a10_enum_mbus_code(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_state *sd_state,
+				  struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->index > 0)
+		return -EINVAL;
+
+	code->code = MEDIA_BUS_FMT_SBGGR10_1X10;
+
+	return 0;
+}
+
+static int ov01a10_enum_frame_size(struct v4l2_subdev *sd,
+				   struct v4l2_subdev_state *sd_state,
+				   struct v4l2_subdev_frame_size_enum *fse)
+{
+	if (fse->index >= ARRAY_SIZE(supported_modes))
+		return -EINVAL;
+
+	if (fse->code != MEDIA_BUS_FMT_SBGGR10_1X10)
+		return -EINVAL;
+
+	fse->min_width = supported_modes[fse->index].width;
+	fse->max_width = fse->min_width;
+	fse->min_height = supported_modes[fse->index].height;
+	fse->max_height = fse->min_height;
+
+	return 0;
+}
+
+static int ov01a10_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct ov01a10 *ov01a10 = to_ov01a10(sd);
+
+	mutex_lock(&ov01a10->mutex);
+	ov01a10_update_pad_format(&supported_modes[0],
+				  v4l2_subdev_get_try_format(sd, fh->state, 0));
+	mutex_unlock(&ov01a10->mutex);
+
+	return 0;
+}
+
+static const struct v4l2_subdev_video_ops ov01a10_video_ops = {
+	.s_stream = ov01a10_set_stream,
+};
+
+static const struct v4l2_subdev_pad_ops ov01a10_pad_ops = {
+	.set_fmt = ov01a10_set_format,
+	.get_fmt = ov01a10_get_format,
+	.enum_mbus_code = ov01a10_enum_mbus_code,
+	.enum_frame_size = ov01a10_enum_frame_size,
+};
+
+static const struct v4l2_subdev_ops ov01a10_subdev_ops = {
+	.video = &ov01a10_video_ops,
+	.pad = &ov01a10_pad_ops,
+};
+
+static const struct media_entity_operations ov01a10_subdev_entity_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+static const struct v4l2_subdev_internal_ops ov01a10_internal_ops = {
+	.open = ov01a10_open,
+};
+
+static int ov01a10_identify_module(struct ov01a10 *ov01a10)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&ov01a10->sd);
+	int ret;
+	u32 val;
+
+	ret = ov01a10_read_reg(ov01a10, OV01A10_REG_CHIP_ID, 3, &val);
+	if (ret)
+		return ret;
+
+	if (val != OV01A10_CHIP_ID) {
+		dev_err(&client->dev, "chip id mismatch: %x!=%x",
+			OV01A10_CHIP_ID, val);
+		return -ENXIO;
+	}
+
+	return 0;
+}
+
+static void ov01a10_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov01a10 *ov01a10 = to_ov01a10(sd);
+
+	v4l2_async_unregister_subdev(sd);
+	media_entity_cleanup(&sd->entity);
+	v4l2_ctrl_handler_free(sd->ctrl_handler);
+	pm_runtime_disable(&client->dev);
+	mutex_destroy(&ov01a10->mutex);
+
+}
+
+static int ov01a10_probe(struct i2c_client *client)
+{
+	struct ov01a10 *ov01a10;
+	int ret = 0;
+
+	ov01a10 = devm_kzalloc(&client->dev, sizeof(*ov01a10), GFP_KERNEL);
+	if (!ov01a10) {
+		ret = -ENOMEM;
+		goto probe_error_ret;
+	}
+
+	v4l2_i2c_subdev_init(&ov01a10->sd, client, &ov01a10_subdev_ops);
+
+	ret = ov01a10_identify_module(ov01a10);
+	if (ret) {
+		dev_err(&client->dev, "failed to find sensor: %d", ret);
+		goto probe_error_ret;
+	}
+
+	mutex_init(&ov01a10->mutex);
+	ov01a10->cur_mode = &supported_modes[0];
+	ret = ov01a10_init_controls(ov01a10);
+	if (ret) {
+		dev_err(&client->dev, "failed to init controls: %d", ret);
+		goto probe_error_v4l2_ctrl_handler_free;
+	}
+
+	ov01a10->sd.internal_ops = &ov01a10_internal_ops;
+	ov01a10->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	ov01a10->sd.entity.ops = &ov01a10_subdev_entity_ops;
+	ov01a10->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;
+	ov01a10->pad.flags = MEDIA_PAD_FL_SOURCE;
+	ret = media_entity_pads_init(&ov01a10->sd.entity, 1, &ov01a10->pad);
+	if (ret) {
+		dev_err(&client->dev, "failed to init entity pads: %d", ret);
+		goto probe_error_v4l2_ctrl_handler_free;
+	}
+
+	ret = v4l2_async_register_subdev_sensor(&ov01a10->sd);
+	if (ret < 0) {
+		dev_err(&client->dev, "failed to register V4L2 subdev: %d",
+			ret);
+		goto probe_error_media_entity_cleanup;
+	}
+
+	/*
+	 * Device is already turned on by i2c-core with ACPI domain PM.
+	 * Enable runtime PM and turn off the device.
+	 */
+	pm_runtime_set_active(&client->dev);
+	pm_runtime_enable(&client->dev);
+	pm_runtime_idle(&client->dev);
+
+	return 0;
+
+probe_error_media_entity_cleanup:
+	media_entity_cleanup(&ov01a10->sd.entity);
+
+probe_error_v4l2_ctrl_handler_free:
+	v4l2_ctrl_handler_free(ov01a10->sd.ctrl_handler);
+	mutex_destroy(&ov01a10->mutex);
+
+probe_error_ret:
+	return ret;
+}
+
+static const struct dev_pm_ops ov01a10_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(ov01a10_suspend, ov01a10_resume)
+};
+
+#ifdef CONFIG_ACPI
+static const struct acpi_device_id ov01a10_acpi_ids[] = {
+	{"OVTI01A0"},
+	{}
+};
+
+MODULE_DEVICE_TABLE(acpi, ov01a10_acpi_ids);
+#endif
+
+static struct i2c_driver ov01a10_i2c_driver = {
+	.driver = {
+		.name = "ov01a10",
+		.pm = &ov01a10_pm_ops,
+		.acpi_match_table = ACPI_PTR(ov01a10_acpi_ids),
+	},
+	.probe_new = ov01a10_probe,
+	.remove = ov01a10_remove,
+};
+
+module_i2c_driver(ov01a10_i2c_driver);
+
+MODULE_AUTHOR("Wang Yating <yating.wang@intel.com>");
+MODULE_DESCRIPTION("OmniVision OV01A10 sensor driver");
+MODULE_LICENSE("GPL v2");
Index: b/drivers/media/i2c/ov01a1s.c
===================================================================
--- /dev/null
+++ b/drivers/media/i2c/ov01a1s.c
@@ -0,0 +1,1016 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (c) 2020-2022 Intel Corporation.
+
+#include <asm/unaligned.h>
+#include <linux/acpi.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/version.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-fwnode.h>
+#if IS_ENABLED(CONFIG_INTEL_SKL_INT3472)
+#include <linux/clk.h>
+#include <linux/gpio/consumer.h>
+#elif IS_ENABLED(CONFIG_POWER_CTRL_LOGIC)
+#include "power_ctrl_logic.h"
+#endif
+
+#define OV01A1S_LINK_FREQ_400MHZ	400000000ULL
+#define OV01A1S_SCLK			40000000LL
+#define OV01A1S_MCLK			19200000
+#define OV01A1S_DATA_LANES		1
+#define OV01A1S_RGB_DEPTH		10
+
+#define OV01A1S_REG_CHIP_ID		0x300a
+#define OV01A1S_CHIP_ID			0x560141
+
+#define OV01A1S_REG_MODE_SELECT		0x0100
+#define OV01A1S_MODE_STANDBY		0x00
+#define OV01A1S_MODE_STREAMING		0x01
+
+/* vertical-timings from sensor */
+#define OV01A1S_REG_VTS			0x380e
+#define OV01A1S_VTS_DEF			0x0380
+#define OV01A1S_VTS_MIN			0x0380
+#define OV01A1S_VTS_MAX			0xffff
+
+/* Exposure controls from sensor */
+#define OV01A1S_REG_EXPOSURE		0x3501
+#define OV01A1S_EXPOSURE_MIN		4
+#define OV01A1S_EXPOSURE_MAX_MARGIN	8
+#define OV01A1S_EXPOSURE_STEP		1
+
+/* Analog gain controls from sensor */
+#define OV01A1S_REG_ANALOG_GAIN		0x3508
+#define OV01A1S_ANAL_GAIN_MIN		0x100
+#define OV01A1S_ANAL_GAIN_MAX		0xffff
+#define OV01A1S_ANAL_GAIN_STEP		1
+
+/* Digital gain controls from sensor */
+#define OV01A1S_REG_DIGILAL_GAIN_B	0x350A
+#define OV01A1S_REG_DIGITAL_GAIN_GB	0x3510
+#define OV01A1S_REG_DIGITAL_GAIN_GR	0x3513
+#define OV01A1S_REG_DIGITAL_GAIN_R	0x3516
+#define OV01A1S_DGTL_GAIN_MIN		0
+#define OV01A1S_DGTL_GAIN_MAX		0x3ffff
+#define OV01A1S_DGTL_GAIN_STEP		1
+#define OV01A1S_DGTL_GAIN_DEFAULT	1024
+
+/* Test Pattern Control */
+#define OV01A1S_REG_TEST_PATTERN		0x4503
+#define OV01A1S_TEST_PATTERN_ENABLE	BIT(7)
+#define OV01A1S_TEST_PATTERN_BAR_SHIFT	0
+
+enum {
+	OV01A1S_LINK_FREQ_400MHZ_INDEX,
+};
+
+struct ov01a1s_reg {
+	u16 address;
+	u8 val;
+};
+
+struct ov01a1s_reg_list {
+	u32 num_of_regs;
+	const struct ov01a1s_reg *regs;
+};
+
+struct ov01a1s_link_freq_config {
+	const struct ov01a1s_reg_list reg_list;
+};
+
+struct ov01a1s_mode {
+	/* Frame width in pixels */
+	u32 width;
+
+	/* Frame height in pixels */
+	u32 height;
+
+	/* Horizontal timining size */
+	u32 hts;
+
+	/* Default vertical timining size */
+	u32 vts_def;
+
+	/* Min vertical timining size */
+	u32 vts_min;
+
+	/* Link frequency needed for this resolution */
+	u32 link_freq_index;
+
+	/* Sensor register settings for this resolution */
+	const struct ov01a1s_reg_list reg_list;
+};
+
+static const struct ov01a1s_reg mipi_data_rate_720mbps[] = {
+};
+
+static const struct ov01a1s_reg sensor_1296x800_setting[] = {
+	{0x0103, 0x01},
+	{0x0302, 0x00},
+	{0x0303, 0x06},
+	{0x0304, 0x01},
+	{0x0305, 0x90},
+	{0x0306, 0x00},
+	{0x0308, 0x01},
+	{0x0309, 0x00},
+	{0x030c, 0x01},
+	{0x0322, 0x01},
+	{0x0323, 0x06},
+	{0x0324, 0x01},
+	{0x0325, 0x68},
+	{0x3002, 0xa1},
+	{0x301e, 0xf0},
+	{0x3022, 0x01},
+	{0x3501, 0x03},
+	{0x3502, 0x78},
+	{0x3504, 0x0c},
+	{0x3508, 0x01},
+	{0x3509, 0x00},
+	{0x3601, 0xc0},
+	{0x3603, 0x71},
+	{0x3610, 0x68},
+	{0x3611, 0x86},
+	{0x3640, 0x10},
+	{0x3641, 0x80},
+	{0x3642, 0xdc},
+	{0x3646, 0x55},
+	{0x3647, 0x57},
+	{0x364b, 0x00},
+	{0x3653, 0x10},
+	{0x3655, 0x00},
+	{0x3656, 0x00},
+	{0x365f, 0x0f},
+	{0x3661, 0x45},
+	{0x3662, 0x24},
+	{0x3663, 0x11},
+	{0x3664, 0x07},
+	{0x3709, 0x34},
+	{0x370b, 0x6f},
+	{0x3714, 0x22},
+	{0x371b, 0x27},
+	{0x371c, 0x67},
+	{0x371d, 0xa7},
+	{0x371e, 0xe7},
+	{0x3730, 0x81},
+	{0x3733, 0x10},
+	{0x3734, 0x40},
+	{0x3737, 0x04},
+	{0x3739, 0x1c},
+	{0x3767, 0x00},
+	{0x376c, 0x81},
+	{0x3772, 0x14},
+	{0x37c2, 0x04},
+	{0x37d8, 0x03},
+	{0x37d9, 0x0c},
+	{0x37e0, 0x00},
+	{0x37e1, 0x08},
+	{0x37e2, 0x10},
+	{0x37e3, 0x04},
+	{0x37e4, 0x04},
+	{0x37e5, 0x03},
+	{0x37e6, 0x04},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0x00},
+	{0x3804, 0x05},
+	{0x3805, 0x0f},
+	{0x3806, 0x03},
+	{0x3807, 0x2f},
+	{0x3808, 0x05},
+	{0x3809, 0x00},
+	{0x380a, 0x03},
+	{0x380b, 0x1e},
+	{0x380c, 0x05},
+	{0x380d, 0xd0},
+	{0x380e, 0x03},
+	{0x380f, 0x80},
+	{0x3810, 0x00},
+	{0x3811, 0x09},
+	{0x3812, 0x00},
+	{0x3813, 0x08},
+	{0x3814, 0x01},
+	{0x3815, 0x01},
+	{0x3816, 0x01},
+	{0x3817, 0x01},
+	{0x3820, 0xa8},
+	{0x3822, 0x03},
+	{0x3832, 0x28},
+	{0x3833, 0x10},
+	{0x3b00, 0x00},
+	{0x3c80, 0x00},
+	{0x3c88, 0x02},
+	{0x3c8c, 0x07},
+	{0x3c8d, 0x40},
+	{0x3cc7, 0x80},
+	{0x4000, 0xc3},
+	{0x4001, 0xe0},
+	{0x4003, 0x40},
+	{0x4008, 0x02},
+	{0x4009, 0x19},
+	{0x400a, 0x01},
+	{0x400b, 0x6c},
+	{0x4011, 0x00},
+	{0x4041, 0x00},
+	{0x4300, 0xff},
+	{0x4301, 0x00},
+	{0x4302, 0x0f},
+	{0x4503, 0x00},
+	{0x4601, 0x50},
+	{0x481f, 0x34},
+	{0x4825, 0x33},
+	{0x4837, 0x14},
+	{0x4881, 0x40},
+	{0x4883, 0x01},
+	{0x4890, 0x00},
+	{0x4901, 0x00},
+	{0x4902, 0x00},
+	{0x4b00, 0x2a},
+	{0x4b0d, 0x00},
+	{0x450a, 0x04},
+	{0x450b, 0x00},
+	{0x5000, 0x65},
+	{0x5004, 0x00},
+	{0x5080, 0x40},
+	{0x5200, 0x18},
+	{0x4837, 0x14},
+	{0x0305, 0xf4},
+	{0x0325, 0xc2},
+	{0x3808, 0x05},
+	{0x3809, 0x10},
+	{0x380a, 0x03},
+	{0x380b, 0x1e},
+	{0x3810, 0x00},
+	{0x3811, 0x00},
+	{0x3812, 0x00},
+	{0x3813, 0x09},
+	{0x3820, 0x88},
+	{0x373d, 0x24},
+};
+
+static const char * const ov01a1s_test_pattern_menu[] = {
+	"Disabled",
+	"Color Bar",
+	"Top-Bottom Darker Color Bar",
+	"Right-Left Darker Color Bar",
+	"Color Bar type 4",
+};
+
+static const s64 link_freq_menu_items[] = {
+	OV01A1S_LINK_FREQ_400MHZ,
+};
+
+static const struct ov01a1s_link_freq_config link_freq_configs[] = {
+	[OV01A1S_LINK_FREQ_400MHZ_INDEX] = {
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(mipi_data_rate_720mbps),
+			.regs = mipi_data_rate_720mbps,
+		}
+	},
+};
+
+static const struct ov01a1s_mode supported_modes[] = {
+	{
+		.width = 1296,
+		.height = 798,
+		.hts = 1488,
+		.vts_def = OV01A1S_VTS_DEF,
+		.vts_min = OV01A1S_VTS_MIN,
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(sensor_1296x800_setting),
+			.regs = sensor_1296x800_setting,
+		},
+		.link_freq_index = OV01A1S_LINK_FREQ_400MHZ_INDEX,
+	},
+};
+
+struct ov01a1s {
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_ctrl_handler ctrl_handler;
+
+	/* V4L2 Controls */
+	struct v4l2_ctrl *link_freq;
+	struct v4l2_ctrl *pixel_rate;
+	struct v4l2_ctrl *vblank;
+	struct v4l2_ctrl *hblank;
+	struct v4l2_ctrl *exposure;
+
+	/* Current mode */
+	const struct ov01a1s_mode *cur_mode;
+
+	/* To serialize asynchronus callbacks */
+	struct mutex mutex;
+
+	/* i2c client */
+	struct i2c_client *client;
+
+#if IS_ENABLED(CONFIG_INTEL_SKL_INT3472)
+	/* GPIO for reset */
+	struct gpio_desc *reset_gpio;
+	/* GPIO for powerdown */
+	struct gpio_desc *powerdown_gpio;
+	/* GPIO for clock enable */
+	struct gpio_desc *clken_gpio;
+	/* GPIO for privacy LED */
+	struct gpio_desc *pled_gpio;
+#endif
+
+	/* Streaming on/off */
+	bool streaming;
+};
+
+static inline struct ov01a1s *to_ov01a1s(struct v4l2_subdev *subdev)
+{
+	return container_of(subdev, struct ov01a1s, sd);
+}
+
+static void ov01a1s_set_power(struct ov01a1s *ov01a1s, int on)
+{
+#if IS_ENABLED(CONFIG_INTEL_SKL_INT3472)
+	if (!(ov01a1s->reset_gpio && ov01a1s->powerdown_gpio))
+		return;
+	gpiod_set_value_cansleep(ov01a1s->reset_gpio, on);
+	gpiod_set_value_cansleep(ov01a1s->powerdown_gpio, on);
+	gpiod_set_value_cansleep(ov01a1s->clken_gpio, on);
+	gpiod_set_value_cansleep(ov01a1s->pled_gpio, on);
+	msleep(20);
+#elif IS_ENABLED(CONFIG_POWER_CTRL_LOGIC)
+	power_ctrl_logic_set_power(on);
+#endif
+}
+
+static int ov01a1s_read_reg(struct ov01a1s *ov01a1s, u16 reg, u16 len, u32 *val)
+{
+	struct i2c_client *client = ov01a1s->client;
+	struct i2c_msg msgs[2];
+	u8 addr_buf[2];
+	u8 data_buf[4] = {0};
+	int ret = 0;
+
+	if (len > sizeof(data_buf))
+		return -EINVAL;
+
+	put_unaligned_be16(reg, addr_buf);
+	msgs[0].addr = client->addr;
+	msgs[0].flags = 0;
+	msgs[0].len = sizeof(addr_buf);
+	msgs[0].buf = addr_buf;
+	msgs[1].addr = client->addr;
+	msgs[1].flags = I2C_M_RD;
+	msgs[1].len = len;
+	msgs[1].buf = &data_buf[sizeof(data_buf) - len];
+
+	ret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));
+	if (ret != ARRAY_SIZE(msgs))
+		return ret < 0 ? ret : -EIO;
+
+	*val = get_unaligned_be32(data_buf);
+
+	return 0;
+}
+
+static int ov01a1s_write_reg(struct ov01a1s *ov01a1s, u16 reg, u16 len, u32 val)
+{
+	struct i2c_client *client = ov01a1s->client;
+	u8 buf[6];
+	int ret = 0;
+
+	if (len > 4)
+		return -EINVAL;
+
+	put_unaligned_be16(reg, buf);
+	put_unaligned_be32(val << 8 * (4 - len), buf + 2);
+
+	ret = i2c_master_send(client, buf, len + 2);
+	if (ret != len + 2)
+		return ret < 0 ? ret : -EIO;
+
+	return 0;
+}
+
+static int ov01a1s_write_reg_list(struct ov01a1s *ov01a1s,
+				  const struct ov01a1s_reg_list *r_list)
+{
+	struct i2c_client *client = ov01a1s->client;
+	unsigned int i;
+	int ret = 0;
+
+	for (i = 0; i < r_list->num_of_regs; i++) {
+		ret = ov01a1s_write_reg(ov01a1s, r_list->regs[i].address, 1,
+					r_list->regs[i].val);
+		if (ret) {
+			dev_err_ratelimited(&client->dev,
+					    "write reg 0x%4.4x return err = %d",
+					    r_list->regs[i].address, ret);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int ov01a1s_update_digital_gain(struct ov01a1s *ov01a1s, u32 d_gain)
+{
+	struct i2c_client *client = ov01a1s->client;
+	u32 real = d_gain << 6;
+	int ret = 0;
+
+	ret = ov01a1s_write_reg(ov01a1s, OV01A1S_REG_DIGILAL_GAIN_B, 3, real);
+	if (ret) {
+		dev_err(&client->dev, "failed to set OV01A1S_REG_DIGITAL_GAIN_B");
+		return ret;
+	}
+	ret = ov01a1s_write_reg(ov01a1s, OV01A1S_REG_DIGITAL_GAIN_GB, 3, real);
+	if (ret) {
+		dev_err(&client->dev, "failed to set OV01A1S_REG_DIGITAL_GAIN_GB");
+		return ret;
+	}
+	ret = ov01a1s_write_reg(ov01a1s, OV01A1S_REG_DIGITAL_GAIN_GR, 3, real);
+	if (ret) {
+		dev_err(&client->dev, "failed to set OV01A1S_REG_DIGITAL_GAIN_GR");
+		return ret;
+	}
+
+	ret = ov01a1s_write_reg(ov01a1s, OV01A1S_REG_DIGITAL_GAIN_R, 3, real);
+	if (ret) {
+		dev_err(&client->dev, "failed to set OV01A1S_REG_DIGITAL_GAIN_R");
+		return ret;
+	}
+	return ret;
+}
+
+static int ov01a1s_test_pattern(struct ov01a1s *ov01a1s, u32 pattern)
+{
+	if (pattern)
+		pattern = (pattern - 1) << OV01A1S_TEST_PATTERN_BAR_SHIFT |
+			  OV01A1S_TEST_PATTERN_ENABLE;
+
+	return ov01a1s_write_reg(ov01a1s, OV01A1S_REG_TEST_PATTERN, 1, pattern);
+}
+
+static int ov01a1s_set_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct ov01a1s *ov01a1s = container_of(ctrl->handler,
+					     struct ov01a1s, ctrl_handler);
+	struct i2c_client *client = ov01a1s->client;
+	s64 exposure_max;
+	int ret = 0;
+
+	/* Propagate change of current control to all related controls */
+	if (ctrl->id == V4L2_CID_VBLANK) {
+		/* Update max exposure while meeting expected vblanking */
+		exposure_max = ov01a1s->cur_mode->height + ctrl->val -
+			       OV01A1S_EXPOSURE_MAX_MARGIN;
+		__v4l2_ctrl_modify_range(ov01a1s->exposure,
+					 ov01a1s->exposure->minimum,
+					 exposure_max, ov01a1s->exposure->step,
+					 exposure_max);
+	}
+
+	/* V4L2 controls values will be applied only when power is already up */
+	if (!pm_runtime_get_if_in_use(&client->dev))
+		return 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_ANALOGUE_GAIN:
+		ret = ov01a1s_write_reg(ov01a1s, OV01A1S_REG_ANALOG_GAIN, 2,
+					ctrl->val);
+		break;
+
+	case V4L2_CID_DIGITAL_GAIN:
+		ret = ov01a1s_update_digital_gain(ov01a1s, ctrl->val);
+		break;
+
+	case V4L2_CID_EXPOSURE:
+		ret = ov01a1s_write_reg(ov01a1s, OV01A1S_REG_EXPOSURE, 2,
+					ctrl->val);
+		break;
+
+	case V4L2_CID_VBLANK:
+		ret = ov01a1s_write_reg(ov01a1s, OV01A1S_REG_VTS, 2,
+					ov01a1s->cur_mode->height + ctrl->val);
+		break;
+
+	case V4L2_CID_TEST_PATTERN:
+		ret = ov01a1s_test_pattern(ov01a1s, ctrl->val);
+		break;
+
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	pm_runtime_put(&client->dev);
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops ov01a1s_ctrl_ops = {
+	.s_ctrl = ov01a1s_set_ctrl,
+};
+
+static int ov01a1s_init_controls(struct ov01a1s *ov01a1s)
+{
+	struct v4l2_ctrl_handler *ctrl_hdlr;
+	const struct ov01a1s_mode *cur_mode;
+	s64 exposure_max, h_blank;
+	u32 vblank_min, vblank_max, vblank_default;
+	int size;
+	int ret = 0;
+
+	ctrl_hdlr = &ov01a1s->ctrl_handler;
+	ret = v4l2_ctrl_handler_init(ctrl_hdlr, 8);
+	if (ret)
+		return ret;
+
+	ctrl_hdlr->lock = &ov01a1s->mutex;
+	cur_mode = ov01a1s->cur_mode;
+	size = ARRAY_SIZE(link_freq_menu_items);
+
+	ov01a1s->link_freq = v4l2_ctrl_new_int_menu(ctrl_hdlr,
+						    &ov01a1s_ctrl_ops,
+						    V4L2_CID_LINK_FREQ,
+						    size - 1, 0,
+						    link_freq_menu_items);
+	if (ov01a1s->link_freq)
+		ov01a1s->link_freq->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	ov01a1s->pixel_rate = v4l2_ctrl_new_std(ctrl_hdlr, &ov01a1s_ctrl_ops,
+						V4L2_CID_PIXEL_RATE, 0,
+						OV01A1S_SCLK, 1, OV01A1S_SCLK);
+
+	vblank_min = cur_mode->vts_min - cur_mode->height;
+	vblank_max = OV01A1S_VTS_MAX - cur_mode->height;
+	vblank_default = cur_mode->vts_def - cur_mode->height;
+	ov01a1s->vblank = v4l2_ctrl_new_std(ctrl_hdlr, &ov01a1s_ctrl_ops,
+					    V4L2_CID_VBLANK, vblank_min,
+					    vblank_max, 1, vblank_default);
+
+	h_blank = cur_mode->hts - cur_mode->width;
+	ov01a1s->hblank = v4l2_ctrl_new_std(ctrl_hdlr, &ov01a1s_ctrl_ops,
+					    V4L2_CID_HBLANK, h_blank, h_blank,
+					    1, h_blank);
+	if (ov01a1s->hblank)
+		ov01a1s->hblank->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	v4l2_ctrl_new_std(ctrl_hdlr, &ov01a1s_ctrl_ops, V4L2_CID_ANALOGUE_GAIN,
+			  OV01A1S_ANAL_GAIN_MIN, OV01A1S_ANAL_GAIN_MAX,
+			  OV01A1S_ANAL_GAIN_STEP, OV01A1S_ANAL_GAIN_MIN);
+	v4l2_ctrl_new_std(ctrl_hdlr, &ov01a1s_ctrl_ops, V4L2_CID_DIGITAL_GAIN,
+			  OV01A1S_DGTL_GAIN_MIN, OV01A1S_DGTL_GAIN_MAX,
+			  OV01A1S_DGTL_GAIN_STEP, OV01A1S_DGTL_GAIN_DEFAULT);
+	exposure_max = cur_mode->vts_def - OV01A1S_EXPOSURE_MAX_MARGIN;
+	ov01a1s->exposure = v4l2_ctrl_new_std(ctrl_hdlr, &ov01a1s_ctrl_ops,
+					      V4L2_CID_EXPOSURE,
+					      OV01A1S_EXPOSURE_MIN,
+					      exposure_max,
+					      OV01A1S_EXPOSURE_STEP,
+					      exposure_max);
+	v4l2_ctrl_new_std_menu_items(ctrl_hdlr, &ov01a1s_ctrl_ops,
+				     V4L2_CID_TEST_PATTERN,
+				     ARRAY_SIZE(ov01a1s_test_pattern_menu) - 1,
+				     0, 0, ov01a1s_test_pattern_menu);
+	if (ctrl_hdlr->error)
+		return ctrl_hdlr->error;
+
+	ov01a1s->sd.ctrl_handler = ctrl_hdlr;
+
+	return 0;
+}
+
+static void ov01a1s_update_pad_format(const struct ov01a1s_mode *mode,
+				      struct v4l2_mbus_framefmt *fmt)
+{
+	fmt->width = mode->width;
+	fmt->height = mode->height;
+	fmt->code = MEDIA_BUS_FMT_SGRBG10_1X10;
+	fmt->field = V4L2_FIELD_NONE;
+}
+
+static int ov01a1s_start_streaming(struct ov01a1s *ov01a1s)
+{
+	struct i2c_client *client = ov01a1s->client;
+	const struct ov01a1s_reg_list *reg_list;
+	int link_freq_index;
+	int ret = 0;
+	ov01a1s_set_power(ov01a1s, 1);
+	link_freq_index = ov01a1s->cur_mode->link_freq_index;
+	reg_list = &link_freq_configs[link_freq_index].reg_list;
+	ret = ov01a1s_write_reg_list(ov01a1s, reg_list);
+	if (ret) {
+		dev_err(&client->dev, "failed to set plls");
+		return ret;
+	}
+
+	reg_list = &ov01a1s->cur_mode->reg_list;
+	ret = ov01a1s_write_reg_list(ov01a1s, reg_list);
+	if (ret) {
+		dev_err(&client->dev, "failed to set mode");
+		return ret;
+	}
+
+	ret = __v4l2_ctrl_handler_setup(ov01a1s->sd.ctrl_handler);
+	if (ret)
+		return ret;
+
+	ret = ov01a1s_write_reg(ov01a1s, OV01A1S_REG_MODE_SELECT, 1,
+				OV01A1S_MODE_STREAMING);
+	if (ret)
+		dev_err(&client->dev, "failed to start streaming");
+
+	return ret;
+}
+
+static void ov01a1s_stop_streaming(struct ov01a1s *ov01a1s)
+{
+	struct i2c_client *client = ov01a1s->client;
+	int ret = 0;
+
+	ret = ov01a1s_write_reg(ov01a1s, OV01A1S_REG_MODE_SELECT, 1,
+				OV01A1S_MODE_STANDBY);
+	if (ret)
+		dev_err(&client->dev, "failed to stop streaming");
+	ov01a1s_set_power(ov01a1s, 0);
+}
+
+static int ov01a1s_set_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct ov01a1s *ov01a1s = to_ov01a1s(sd);
+	struct i2c_client *client = ov01a1s->client;
+	int ret = 0;
+
+	if (ov01a1s->streaming == enable)
+		return 0;
+
+	mutex_lock(&ov01a1s->mutex);
+	if (enable) {
+		ret = pm_runtime_get_sync(&client->dev);
+		if (ret < 0) {
+			pm_runtime_put_noidle(&client->dev);
+			mutex_unlock(&ov01a1s->mutex);
+			return ret;
+		}
+
+		ret = ov01a1s_start_streaming(ov01a1s);
+		if (ret) {
+			enable = 0;
+			ov01a1s_stop_streaming(ov01a1s);
+			pm_runtime_put(&client->dev);
+		}
+	} else {
+		ov01a1s_stop_streaming(ov01a1s);
+		pm_runtime_put(&client->dev);
+	}
+
+	ov01a1s->streaming = enable;
+	mutex_unlock(&ov01a1s->mutex);
+
+	return ret;
+}
+
+static int __maybe_unused ov01a1s_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov01a1s *ov01a1s = to_ov01a1s(sd);
+
+	mutex_lock(&ov01a1s->mutex);
+	if (ov01a1s->streaming)
+		ov01a1s_stop_streaming(ov01a1s);
+
+	mutex_unlock(&ov01a1s->mutex);
+
+	return 0;
+}
+
+static int __maybe_unused ov01a1s_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov01a1s *ov01a1s = to_ov01a1s(sd);
+	int ret = 0;
+
+	mutex_lock(&ov01a1s->mutex);
+	if (!ov01a1s->streaming)
+		goto exit;
+
+	ret = ov01a1s_start_streaming(ov01a1s);
+	if (ret) {
+		ov01a1s->streaming = false;
+		ov01a1s_stop_streaming(ov01a1s);
+	}
+
+exit:
+	mutex_unlock(&ov01a1s->mutex);
+	return ret;
+}
+
+static int ov01a1s_set_format(struct v4l2_subdev *sd,
+			      struct v4l2_subdev_state *sd_state,
+			      struct v4l2_subdev_format *fmt)
+{
+	struct ov01a1s *ov01a1s = to_ov01a1s(sd);
+	const struct ov01a1s_mode *mode;
+	s32 vblank_def, h_blank;
+
+	mode = v4l2_find_nearest_size(supported_modes,
+				      ARRAY_SIZE(supported_modes), width,
+				      height, fmt->format.width,
+				      fmt->format.height);
+
+	mutex_lock(&ov01a1s->mutex);
+	ov01a1s_update_pad_format(mode, &fmt->format);
+	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {
+		*v4l2_subdev_get_try_format(sd, sd_state, fmt->pad) = fmt->format;
+	} else {
+		ov01a1s->cur_mode = mode;
+		__v4l2_ctrl_s_ctrl(ov01a1s->link_freq, mode->link_freq_index);
+		__v4l2_ctrl_s_ctrl_int64(ov01a1s->pixel_rate, OV01A1S_SCLK);
+
+		/* Update limits and set FPS to default */
+		vblank_def = mode->vts_def - mode->height;
+		__v4l2_ctrl_modify_range(ov01a1s->vblank,
+					 mode->vts_min - mode->height,
+					 OV01A1S_VTS_MAX - mode->height, 1,
+					 vblank_def);
+		__v4l2_ctrl_s_ctrl(ov01a1s->vblank, vblank_def);
+		h_blank = mode->hts - mode->width;
+		__v4l2_ctrl_modify_range(ov01a1s->hblank, h_blank, h_blank, 1,
+					 h_blank);
+	}
+	mutex_unlock(&ov01a1s->mutex);
+
+	return 0;
+}
+
+static int ov01a1s_get_format(struct v4l2_subdev *sd,
+			      struct v4l2_subdev_state *sd_state,
+			      struct v4l2_subdev_format *fmt)
+{
+	struct ov01a1s *ov01a1s = to_ov01a1s(sd);
+
+	mutex_lock(&ov01a1s->mutex);
+	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY)
+		fmt->format = *v4l2_subdev_get_try_format(&ov01a1s->sd,
+							  sd_state, fmt->pad);
+	else
+		ov01a1s_update_pad_format(ov01a1s->cur_mode, &fmt->format);
+
+	mutex_unlock(&ov01a1s->mutex);
+
+	return 0;
+}
+
+static int ov01a1s_enum_mbus_code(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_state *sd_state,
+				  struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->index > 0)
+		return -EINVAL;
+
+	code->code = MEDIA_BUS_FMT_SGRBG10_1X10;
+
+	return 0;
+}
+
+static int ov01a1s_enum_frame_size(struct v4l2_subdev *sd,
+				   struct v4l2_subdev_state *sd_state,
+				   struct v4l2_subdev_frame_size_enum *fse)
+{
+	if (fse->index >= ARRAY_SIZE(supported_modes))
+		return -EINVAL;
+
+	if (fse->code != MEDIA_BUS_FMT_SGRBG10_1X10)
+		return -EINVAL;
+
+	fse->min_width = supported_modes[fse->index].width;
+	fse->max_width = fse->min_width;
+	fse->min_height = supported_modes[fse->index].height;
+	fse->max_height = fse->min_height;
+
+	return 0;
+}
+
+static int ov01a1s_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct ov01a1s *ov01a1s = to_ov01a1s(sd);
+
+	mutex_lock(&ov01a1s->mutex);
+	ov01a1s_update_pad_format(&supported_modes[0],
+				  v4l2_subdev_get_try_format(sd, fh->state, 0));
+	mutex_unlock(&ov01a1s->mutex);
+
+	return 0;
+}
+
+static const struct v4l2_subdev_video_ops ov01a1s_video_ops = {
+	.s_stream = ov01a1s_set_stream,
+};
+
+static const struct v4l2_subdev_pad_ops ov01a1s_pad_ops = {
+	.set_fmt = ov01a1s_set_format,
+	.get_fmt = ov01a1s_get_format,
+	.enum_mbus_code = ov01a1s_enum_mbus_code,
+	.enum_frame_size = ov01a1s_enum_frame_size,
+};
+
+static const struct v4l2_subdev_ops ov01a1s_subdev_ops = {
+	.video = &ov01a1s_video_ops,
+	.pad = &ov01a1s_pad_ops,
+};
+
+static const struct media_entity_operations ov01a1s_subdev_entity_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+static const struct v4l2_subdev_internal_ops ov01a1s_internal_ops = {
+	.open = ov01a1s_open,
+};
+
+static int ov01a1s_identify_module(struct ov01a1s *ov01a1s)
+{
+	struct i2c_client *client = ov01a1s->client;
+	int ret;
+	u32 val;
+
+	ret = ov01a1s_read_reg(ov01a1s, OV01A1S_REG_CHIP_ID, 3, &val);
+	if (ret)
+		return ret;
+
+	if (val != OV01A1S_CHIP_ID) {
+		dev_err(&client->dev, "chip id mismatch: %x!=%x",
+			OV01A1S_CHIP_ID, val);
+		return -ENXIO;
+	}
+
+	return 0;
+}
+
+static void ov01a1s_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov01a1s *ov01a1s = to_ov01a1s(sd);
+
+	v4l2_async_unregister_subdev(sd);
+	media_entity_cleanup(&sd->entity);
+	v4l2_ctrl_handler_free(sd->ctrl_handler);
+	pm_runtime_disable(&client->dev);
+	mutex_destroy(&ov01a1s->mutex);
+
+}
+
+#if IS_ENABLED(CONFIG_INTEL_SKL_INT3472)
+static int ov01a1s_parse_dt(struct ov01a1s *ov01a1s)
+{
+	struct device *dev = &ov01a1s->client->dev;
+	int ret;
+
+	ov01a1s->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	ret = PTR_ERR_OR_ZERO(ov01a1s->reset_gpio);
+	if (ret < 0) {
+		dev_err(dev, "error while getting reset gpio: %d\n", ret);
+		return -EPROBE_DEFER;
+	}
+
+	ov01a1s->powerdown_gpio = devm_gpiod_get(dev, "powerdown", GPIOD_OUT_HIGH);
+	ret = PTR_ERR_OR_ZERO(ov01a1s->powerdown_gpio);
+	if (ret < 0) {
+		dev_err(dev, "error while getting powerdown gpio: %d\n", ret);
+		return -EPROBE_DEFER;
+	}
+
+	ov01a1s->clken_gpio = devm_gpiod_get(dev, "clken", GPIOD_OUT_HIGH);
+	ret = PTR_ERR_OR_ZERO(ov01a1s->clken_gpio);
+	if (ret < 0) {
+		dev_err(dev, "error while getting clken_gpio gpio: %d\n", ret);
+		return -EPROBE_DEFER;
+	}
+
+	ov01a1s->pled_gpio = devm_gpiod_get(dev, "pled", GPIOD_OUT_HIGH);
+	ret = PTR_ERR_OR_ZERO(ov01a1s->pled_gpio);
+	if (ret < 0) {
+		dev_err(dev, "error while getting pled gpio: %d\n", ret);
+		return -EPROBE_DEFER;
+	}
+
+	return 0;
+}
+#endif
+
+static int ov01a1s_probe(struct i2c_client *client)
+{
+	struct ov01a1s *ov01a1s;
+	int ret = 0;
+
+	ov01a1s = devm_kzalloc(&client->dev, sizeof(*ov01a1s), GFP_KERNEL);
+	if (!ov01a1s)
+		return -ENOMEM;
+	ov01a1s->client = client;
+
+#if IS_ENABLED(CONFIG_INTEL_SKL_INT3472)
+	if (ret == -EAGAIN)
+		ret = ov01a1s_parse_dt(ov01a1s);
+#elif IS_ENABLED(CONFIG_POWER_CTRL_LOGIC)
+	if (ret == -EAGAIN)
+		ret = power_ctrl_logic_set_power(1);
+#endif
+	if (ret == -EAGAIN)
+		return -EPROBE_DEFER;
+	else if (ret)
+		return ret;
+
+	ov01a1s_set_power(ov01a1s, 1);
+
+	v4l2_i2c_subdev_init(&ov01a1s->sd, client, &ov01a1s_subdev_ops);
+	ret = ov01a1s_identify_module(ov01a1s);
+	if (ret) {
+		dev_err(&client->dev, "failed to find sensor: %d", ret);
+		goto probe_error_power_off;
+	}
+
+	mutex_init(&ov01a1s->mutex);
+	ov01a1s->cur_mode = &supported_modes[0];
+	ret = ov01a1s_init_controls(ov01a1s);
+	if (ret) {
+		dev_err(&client->dev, "failed to init controls: %d", ret);
+		goto probe_error_v4l2_ctrl_handler_free;
+	}
+
+	ov01a1s->sd.internal_ops = &ov01a1s_internal_ops;
+	ov01a1s->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	ov01a1s->sd.entity.ops = &ov01a1s_subdev_entity_ops;
+	ov01a1s->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;
+	ov01a1s->pad.flags = MEDIA_PAD_FL_SOURCE;
+	ret = media_entity_pads_init(&ov01a1s->sd.entity, 1, &ov01a1s->pad);
+	if (ret) {
+		dev_err(&client->dev, "failed to init entity pads: %d", ret);
+		goto probe_error_v4l2_ctrl_handler_free;
+	}
+
+	ret = v4l2_async_register_subdev_sensor(&ov01a1s->sd);
+	if (ret < 0) {
+		dev_err(&client->dev, "failed to register V4L2 subdev: %d",
+			ret);
+		goto probe_error_media_entity_cleanup;
+	}
+
+	/*
+	 * Device is already turned on by i2c-core with ACPI domain PM.
+	 * Enable runtime PM and turn off the device.
+	 */
+	pm_runtime_set_active(&client->dev);
+	pm_runtime_enable(&client->dev);
+	pm_runtime_idle(&client->dev);
+
+	ov01a1s_set_power(ov01a1s, 0);
+	return 0;
+
+probe_error_media_entity_cleanup:
+	media_entity_cleanup(&ov01a1s->sd.entity);
+
+probe_error_v4l2_ctrl_handler_free:
+	v4l2_ctrl_handler_free(ov01a1s->sd.ctrl_handler);
+	mutex_destroy(&ov01a1s->mutex);
+
+probe_error_power_off:
+	ov01a1s_set_power(ov01a1s, 0);
+	return ret;
+}
+
+static const struct dev_pm_ops ov01a1s_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(ov01a1s_suspend, ov01a1s_resume)
+};
+
+#ifdef CONFIG_ACPI
+static const struct acpi_device_id ov01a1s_acpi_ids[] = {
+	{ "OVTI01AS" },
+	{}
+};
+
+MODULE_DEVICE_TABLE(acpi, ov01a1s_acpi_ids);
+#endif
+
+static struct i2c_driver ov01a1s_i2c_driver = {
+	.driver = {
+		.name = "ov01a1s",
+		.pm = &ov01a1s_pm_ops,
+		.acpi_match_table = ACPI_PTR(ov01a1s_acpi_ids),
+	},
+	.probe_new = ov01a1s_probe,
+	.remove = ov01a1s_remove,
+};
+
+module_i2c_driver(ov01a1s_i2c_driver);
+
+MODULE_AUTHOR("Xu, Chongyang <chongyang.xu@intel.com>");
+MODULE_AUTHOR("Lai, Jim <jim.lai@intel.com>");
+MODULE_AUTHOR("Qiu, Tianshu <tian.shu.qiu@intel.com>");
+MODULE_AUTHOR("Shawn Tu <shawnx.tu@intel.com>");
+MODULE_AUTHOR("Bingbu Cao <bingbu.cao@intel.com>");
+MODULE_DESCRIPTION("OmniVision OV01A1S sensor driver");
+MODULE_LICENSE("GPL v2");
Index: b/drivers/media/i2c/ov02c10.c
===================================================================
--- /dev/null
+++ b/drivers/media/i2c/ov02c10.c
@@ -0,0 +1,1303 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (c) 2022 Intel Corporation.
+
+#include <asm/unaligned.h>
+#include <linux/acpi.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/version.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-fwnode.h>
+
+#define OV02C10_LINK_FREQ_400MHZ	400000000ULL
+#define OV02C10_SCLK			80000000LL
+#define OV02C10_MCLK			19200000
+#define OV02C10_DATA_LANES		1
+#define OV02C10_RGB_DEPTH		10
+
+#define OV02C10_REG_CHIP_ID		0x300a
+#define OV02C10_CHIP_ID			0x560243
+
+#define OV02C10_REG_MODE_SELECT		0x0100
+#define OV02C10_MODE_STANDBY		0x00
+#define OV02C10_MODE_STREAMING		0x01
+
+/* vertical-timings from sensor */
+#define OV02C10_REG_VTS			0x380e
+#define OV02C10_VTS_MAX			0xffff
+
+/* Exposure controls from sensor */
+#define OV02C10_REG_EXPOSURE		0x3501
+#define OV02C10_EXPOSURE_MIN		4
+#define OV02C10_EXPOSURE_MAX_MARGIN	8
+#define OV02C10_EXPOSURE_STEP		1
+
+/* Analog gain controls from sensor */
+#define OV02C10_REG_ANALOG_GAIN		0x3508
+#define OV02C10_ANAL_GAIN_MIN		0x10
+#define OV02C10_ANAL_GAIN_MAX		0xf8
+#define OV02C10_ANAL_GAIN_STEP		1
+#define OV02C10_ANAL_GAIN_DEFAULT	0x10
+
+/* Digital gain controls from sensor */
+#define OV02C10_REG_DIGILAL_GAIN	0x350a
+#define OV02C10_DGTL_GAIN_MIN		0x0400
+#define OV02C10_DGTL_GAIN_MAX		0x3fff
+#define OV02C10_DGTL_GAIN_STEP		1
+#define OV02C10_DGTL_GAIN_DEFAULT	0x0400
+
+/* Test Pattern Control */
+#define OV02C10_REG_TEST_PATTERN		0x4503
+#define OV02C10_TEST_PATTERN_ENABLE	BIT(7)
+#define OV02C10_TEST_PATTERN_BAR_SHIFT	0
+
+enum {
+	OV02C10_LINK_FREQ_400MHZ_INDEX,
+};
+
+struct ov02c10_reg {
+	u16 address;
+	u8 val;
+};
+
+struct ov02c10_reg_list {
+	u32 num_of_regs;
+	const struct ov02c10_reg *regs;
+};
+
+struct ov02c10_link_freq_config {
+	const struct ov02c10_reg_list reg_list;
+};
+
+struct ov02c10_mode {
+	/* Frame width in pixels */
+	u32 width;
+
+	/* Frame height in pixels */
+	u32 height;
+
+	/* Horizontal timining size */
+	u32 hts;
+
+	/* Default vertical timining size */
+	u32 vts_def;
+
+	/* Min vertical timining size */
+	u32 vts_min;
+
+	/* Link frequency needed for this resolution */
+	u32 link_freq_index;
+
+	/* MIPI lanes used */
+	u8 mipi_lanes;
+
+	/* Sensor register settings for this resolution */
+	const struct ov02c10_reg_list reg_list;
+};
+
+struct mipi_camera_link_ssdb {
+	u8 version;
+	u8 sku;
+	u8 guid_csi2[16];
+	u8 devfunction;
+	u8 bus;
+	u32 dphylinkenfuses;
+	u32 clockdiv;
+	u8 link;
+	u8 lanes;
+	u32 csiparams[10];
+	u32 maxlanespeed;
+	u8 sensorcalibfileidx;
+	u8 sensorcalibfileidxInMBZ[3];
+	u8 romtype;
+	u8 vcmtype;
+	u8 platforminfo;
+	u8 platformsubinfo;
+	u8 flash;
+	u8 privacyled;
+	u8 degree;
+	u8 mipilinkdefined;
+	u32 mclkspeed;
+	u8 controllogicid;
+	u8 reserved1[3];
+	u8 mclkport;
+	u8 reserved2[13];
+} __packed;
+
+static const struct ov02c10_reg mipi_data_rate_960mbps[] = {
+};
+
+static const struct ov02c10_reg sensor_1928x1092_1lane_30fps_setting[] = {
+	{0x0301, 0x08},
+	{0x0303, 0x06},
+	{0x0304, 0x01},
+	{0x0305, 0xe0},
+	{0x0313, 0x40},
+	{0x031c, 0x4f},
+	{0x301b, 0xd2},
+	{0x3020, 0x97},
+	{0x3022, 0x01},
+	{0x3026, 0xb4},
+	{0x3027, 0xe1},
+	{0x303b, 0x00},
+	{0x303c, 0x4f},
+	{0x303d, 0xe6},
+	{0x303e, 0x00},
+	{0x303f, 0x03},
+	{0x3021, 0x23},
+	{0x3501, 0x04},
+	{0x3502, 0x6c},
+	{0x3504, 0x0c},
+	{0x3507, 0x00},
+	{0x3508, 0x08},
+	{0x3509, 0x00},
+	{0x350a, 0x01},
+	{0x350b, 0x00},
+	{0x350c, 0x41},
+	{0x3600, 0x84},
+	{0x3603, 0x08},
+	{0x3610, 0x57},
+	{0x3611, 0x1b},
+	{0x3613, 0x78},
+	{0x3623, 0x00},
+	{0x3632, 0xa0},
+	{0x3642, 0xe8},
+	{0x364c, 0x70},
+	{0x365f, 0x0f},
+	{0x3708, 0x30},
+	{0x3714, 0x24},
+	{0x3725, 0x02},
+	{0x3737, 0x08},
+	{0x3739, 0x28},
+	{0x3749, 0x32},
+	{0x374a, 0x32},
+	{0x374b, 0x32},
+	{0x374c, 0x32},
+	{0x374d, 0x81},
+	{0x374e, 0x81},
+	{0x374f, 0x81},
+	{0x3752, 0x36},
+	{0x3753, 0x36},
+	{0x3754, 0x36},
+	{0x3761, 0x00},
+	{0x376c, 0x81},
+	{0x3774, 0x18},
+	{0x3776, 0x08},
+	{0x377c, 0x81},
+	{0x377d, 0x81},
+	{0x377e, 0x81},
+	{0x37a0, 0x44},
+	{0x37a6, 0x44},
+	{0x37aa, 0x0d},
+	{0x37ae, 0x00},
+	{0x37cb, 0x03},
+	{0x37cc, 0x01},
+	{0x37d8, 0x02},
+	{0x37d9, 0x10},
+	{0x37e1, 0x10},
+	{0x37e2, 0x18},
+	{0x37e3, 0x08},
+	{0x37e4, 0x08},
+	{0x37e5, 0x02},
+	{0x37e6, 0x08},
+
+	// 1928x1092
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0x00},
+	{0x3804, 0x07},
+	{0x3805, 0x8f},
+	{0x3806, 0x04},
+	{0x3807, 0x47},
+	{0x3808, 0x07},
+	{0x3809, 0x88},
+	{0x380a, 0x04},
+	{0x380b, 0x44},
+	{0x380c, 0x08},
+	{0x380d, 0xe8},
+	{0x380e, 0x04},
+	{0x380f, 0x8c},
+	{0x3810, 0x00},
+	{0x3811, 0x03},
+	{0x3812, 0x00},
+	{0x3813, 0x03},
+	{0x3814, 0x01},
+	{0x3815, 0x01},
+	{0x3816, 0x01},
+	{0x3817, 0x01},
+
+	{0x3820, 0xa8},
+	{0x3821, 0x00},
+	{0x3822, 0x80},
+	{0x3823, 0x08},
+	{0x3824, 0x00},
+	{0x3825, 0x20},
+	{0x3826, 0x00},
+	{0x3827, 0x08},
+	{0x382a, 0x00},
+	{0x382b, 0x08},
+	{0x382d, 0x00},
+	{0x382e, 0x00},
+	{0x382f, 0x23},
+	{0x3834, 0x00},
+	{0x3839, 0x00},
+	{0x383a, 0xd1},
+	{0x383e, 0x03},
+	{0x393d, 0x29},
+	{0x393f, 0x6e},
+	{0x394b, 0x06},
+	{0x394c, 0x06},
+	{0x394d, 0x08},
+	{0x394e, 0x0b},
+	{0x394f, 0x01},
+	{0x3950, 0x01},
+	{0x3951, 0x01},
+	{0x3952, 0x01},
+	{0x3953, 0x01},
+	{0x3954, 0x01},
+	{0x3955, 0x01},
+	{0x3956, 0x01},
+	{0x3957, 0x0e},
+	{0x3958, 0x08},
+	{0x3959, 0x08},
+	{0x395a, 0x08},
+	{0x395b, 0x13},
+	{0x395c, 0x09},
+	{0x395d, 0x05},
+	{0x395e, 0x02},
+	{0x395f, 0x00},
+	{0x395f, 0x00},
+	{0x3960, 0x00},
+	{0x3961, 0x00},
+	{0x3962, 0x00},
+	{0x3963, 0x00},
+	{0x3964, 0x00},
+	{0x3965, 0x00},
+	{0x3966, 0x00},
+	{0x3967, 0x00},
+	{0x3968, 0x01},
+	{0x3969, 0x01},
+	{0x396a, 0x01},
+	{0x396b, 0x01},
+	{0x396c, 0x10},
+	{0x396d, 0xf0},
+	{0x396e, 0x11},
+	{0x396f, 0x00},
+	{0x3970, 0x37},
+	{0x3971, 0x37},
+	{0x3972, 0x37},
+	{0x3973, 0x37},
+	{0x3974, 0x00},
+	{0x3975, 0x3c},
+	{0x3976, 0x3c},
+	{0x3977, 0x3c},
+	{0x3978, 0x3c},
+	{0x3c00, 0x0f},
+	{0x3c20, 0x01},
+	{0x3c21, 0x08},
+	{0x3f00, 0x8b},
+	{0x3f02, 0x0f},
+	{0x4000, 0xc3},
+	{0x4001, 0xe0},
+	{0x4002, 0x00},
+	{0x4003, 0x40},
+	{0x4008, 0x04},
+	{0x4009, 0x23},
+	{0x400a, 0x04},
+	{0x400b, 0x01},
+	{0x4077, 0x06},
+	{0x4078, 0x00},
+	{0x4079, 0x1a},
+	{0x407a, 0x7f},
+	{0x407b, 0x01},
+	{0x4080, 0x03},
+	{0x4081, 0x84},
+	{0x4308, 0x03},
+	{0x4309, 0xff},
+	{0x430d, 0x00},
+	{0x4806, 0x00},
+	{0x4813, 0x00},
+	{0x4837, 0x10},
+	{0x4857, 0x05},
+	{0x4500, 0x07},
+	{0x4501, 0x00},
+	{0x4503, 0x00},
+	{0x450a, 0x04},
+	{0x450e, 0x00},
+	{0x450f, 0x00},
+	{0x4800, 0x24},
+	{0x4900, 0x00},
+	{0x4901, 0x00},
+	{0x4902, 0x01},
+	{0x5000, 0xf5},
+	{0x5001, 0x50},
+	{0x5006, 0x00},
+	{0x5080, 0x40},
+	{0x5181, 0x2b},
+	{0x5202, 0xa3},
+	{0x5206, 0x01},
+	{0x5207, 0x00},
+	{0x520a, 0x01},
+	{0x520b, 0x00},
+	{0x365d, 0x00},
+	{0x4815, 0x40},
+	{0x4816, 0x12},
+	{0x4f00, 0x01},
+	// plls
+	{0x0303, 0x05},
+	{0x0305, 0x90},
+	{0x0316, 0x90},
+	{0x3016, 0x12},
+};
+static const struct ov02c10_reg sensor_1928x1092_2lane_30fps_setting[] = {
+	{0x0301, 0x08},
+	{0x0303, 0x06},
+	{0x0304, 0x01},
+	{0x0305, 0xe0},
+	{0x0313, 0x40},
+	{0x031c, 0x4f},
+	{0x301b, 0xf0},
+	{0x3020, 0x97},
+	{0x3022, 0x01},
+	{0x3026, 0xb4},
+	{0x3027, 0xf1},
+	{0x303b, 0x00},
+	{0x303c, 0x4f},
+	{0x303d, 0xe6},
+	{0x303e, 0x00},
+	{0x303f, 0x03},
+	{0x3021, 0x23},
+	{0x3501, 0x04},
+	{0x3502, 0x6c},
+	{0x3504, 0x0c},
+	{0x3507, 0x00},
+	{0x3508, 0x08},
+	{0x3509, 0x00},
+	{0x350a, 0x01},
+	{0x350b, 0x00},
+	{0x350c, 0x41},
+	{0x3600, 0x84},
+	{0x3603, 0x08},
+	{0x3610, 0x57},
+	{0x3611, 0x1b},
+	{0x3613, 0x78},
+	{0x3623, 0x00},
+	{0x3632, 0xa0},
+	{0x3642, 0xe8},
+	{0x364c, 0x70},
+	{0x365f, 0x0f},
+	{0x3708, 0x30},
+	{0x3714, 0x24},
+	{0x3725, 0x02},
+	{0x3737, 0x08},
+	{0x3739, 0x28},
+	{0x3749, 0x32},
+	{0x374a, 0x32},
+	{0x374b, 0x32},
+	{0x374c, 0x32},
+	{0x374d, 0x81},
+	{0x374e, 0x81},
+	{0x374f, 0x81},
+	{0x3752, 0x36},
+	{0x3753, 0x36},
+	{0x3754, 0x36},
+	{0x3761, 0x00},
+	{0x376c, 0x81},
+	{0x3774, 0x18},
+	{0x3776, 0x08},
+	{0x377c, 0x81},
+	{0x377d, 0x81},
+	{0x377e, 0x81},
+	{0x37a0, 0x44},
+	{0x37a6, 0x44},
+	{0x37aa, 0x0d},
+	{0x37ae, 0x00},
+	{0x37cb, 0x03},
+	{0x37cc, 0x01},
+	{0x37d8, 0x02},
+	{0x37d9, 0x10},
+	{0x37e1, 0x10},
+	{0x37e2, 0x18},
+	{0x37e3, 0x08},
+	{0x37e4, 0x08},
+	{0x37e5, 0x02},
+	{0x37e6, 0x08},
+
+	// 1928x1092
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0x00},
+	{0x3804, 0x07},
+	{0x3805, 0x8f},
+	{0x3806, 0x04},
+	{0x3807, 0x47},
+	{0x3808, 0x07},
+	{0x3809, 0x88},
+	{0x380a, 0x04},
+	{0x380b, 0x44},
+	{0x380c, 0x04},
+	{0x380d, 0x74},
+	{0x380e, 0x09},
+	{0x380f, 0x18},
+	{0x3810, 0x00},
+	{0x3811, 0x03},
+	{0x3812, 0x00},
+	{0x3813, 0x03},
+	{0x3814, 0x01},
+	{0x3815, 0x01},
+	{0x3816, 0x01},
+	{0x3817, 0x01},
+
+	{0x3820, 0xa8},
+	{0x3821, 0x00},
+	{0x3822, 0x80},
+	{0x3823, 0x08},
+	{0x3824, 0x00},
+	{0x3825, 0x20},
+	{0x3826, 0x00},
+	{0x3827, 0x08},
+	{0x382a, 0x00},
+	{0x382b, 0x08},
+	{0x382d, 0x00},
+	{0x382e, 0x00},
+	{0x382f, 0x23},
+	{0x3834, 0x00},
+	{0x3839, 0x00},
+	{0x383a, 0xd1},
+	{0x383e, 0x03},
+	{0x393d, 0x29},
+	{0x393f, 0x6e},
+	{0x394b, 0x06},
+	{0x394c, 0x06},
+	{0x394d, 0x08},
+	{0x394e, 0x0a},
+	{0x394f, 0x01},
+	{0x3950, 0x01},
+	{0x3951, 0x01},
+	{0x3952, 0x01},
+	{0x3953, 0x01},
+	{0x3954, 0x01},
+	{0x3955, 0x01},
+	{0x3956, 0x01},
+	{0x3957, 0x0e},
+	{0x3958, 0x08},
+	{0x3959, 0x08},
+	{0x395a, 0x08},
+	{0x395b, 0x13},
+	{0x395c, 0x09},
+	{0x395d, 0x05},
+	{0x395e, 0x02},
+	{0x395f, 0x00},
+	{0x395f, 0x00},
+	{0x3960, 0x00},
+	{0x3961, 0x00},
+	{0x3962, 0x00},
+	{0x3963, 0x00},
+	{0x3964, 0x00},
+	{0x3965, 0x00},
+	{0x3966, 0x00},
+	{0x3967, 0x00},
+	{0x3968, 0x01},
+	{0x3969, 0x01},
+	{0x396a, 0x01},
+	{0x396b, 0x01},
+	{0x396c, 0x10},
+	{0x396d, 0xf0},
+	{0x396e, 0x11},
+	{0x396f, 0x00},
+	{0x3970, 0x37},
+	{0x3971, 0x37},
+	{0x3972, 0x37},
+	{0x3973, 0x37},
+	{0x3974, 0x00},
+	{0x3975, 0x3c},
+	{0x3976, 0x3c},
+	{0x3977, 0x3c},
+	{0x3978, 0x3c},
+	{0x3c00, 0x0f},
+	{0x3c20, 0x01},
+	{0x3c21, 0x08},
+	{0x3f00, 0x8b},
+	{0x3f02, 0x0f},
+	{0x4000, 0xc3},
+	{0x4001, 0xe0},
+	{0x4002, 0x00},
+	{0x4003, 0x40},
+	{0x4008, 0x04},
+	{0x4009, 0x23},
+	{0x400a, 0x04},
+	{0x400b, 0x01},
+	{0x4041, 0x20},
+	{0x4077, 0x06},
+	{0x4078, 0x00},
+	{0x4079, 0x1a},
+	{0x407a, 0x7f},
+	{0x407b, 0x01},
+	{0x4080, 0x03},
+	{0x4081, 0x84},
+	{0x4308, 0x03},
+	{0x4309, 0xff},
+	{0x430d, 0x00},
+	{0x4806, 0x00},
+	{0x4813, 0x00},
+	{0x4837, 0x10},
+	{0x4857, 0x05},
+	{0x4884, 0x04},
+	{0x4500, 0x07},
+	{0x4501, 0x00},
+	{0x4503, 0x00},
+	{0x450a, 0x04},
+	{0x450e, 0x00},
+	{0x450f, 0x00},
+	{0x4800, 0x64},
+	{0x4900, 0x00},
+	{0x4901, 0x00},
+	{0x4902, 0x01},
+	{0x4d00, 0x03},
+	{0x4d01, 0xd8},
+	{0x4d02, 0xba},
+	{0x4d03, 0xa0},
+	{0x4d04, 0xb7},
+	{0x4d05, 0x34},
+	{0x4d0d, 0x00},
+	{0x5000, 0xfd},
+	{0x5001, 0x50},
+	{0x5006, 0x00},
+	{0x5080, 0x40},
+	{0x5181, 0x2b},
+	{0x5202, 0xa3},
+	{0x5206, 0x01},
+	{0x5207, 0x00},
+	{0x520a, 0x01},
+	{0x520b, 0x00},
+	{0x365d, 0x00},
+	{0x4815, 0x40},
+	{0x4816, 0x12},
+	{0x481f, 0x30},
+	{0x4f00, 0x01},
+	// plls
+	{0x0303, 0x05},
+	{0x0305, 0x90},
+	{0x0316, 0x90},
+	{0x3016, 0x32},
+};
+
+static const char * const ov02c10_test_pattern_menu[] = {
+	"Disabled",
+	"Color Bar",
+	"Top-Bottom Darker Color Bar",
+	"Right-Left Darker Color Bar",
+	"Color Bar type 4",
+};
+
+static const s64 link_freq_menu_items[] = {
+	OV02C10_LINK_FREQ_400MHZ,
+};
+
+static const struct ov02c10_link_freq_config link_freq_configs[] = {
+	[OV02C10_LINK_FREQ_400MHZ_INDEX] = {
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(mipi_data_rate_960mbps),
+			.regs = mipi_data_rate_960mbps,
+		}
+	},
+};
+
+static const struct ov02c10_mode supported_modes[] = {
+	{
+		.width = 1928,
+		.height = 1092,
+		.hts = 2280,
+		.vts_def = 1164,
+		.vts_min = 1164,
+		.mipi_lanes = 1,
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(sensor_1928x1092_1lane_30fps_setting),
+			.regs = sensor_1928x1092_1lane_30fps_setting,
+		},
+		.link_freq_index = OV02C10_LINK_FREQ_400MHZ_INDEX,
+	},
+	{
+		.width = 1928,
+		.height = 1092,
+		.hts = 1140,
+		.vts_def = 2328,
+		.vts_min = 2328,
+		.mipi_lanes = 2,
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(sensor_1928x1092_2lane_30fps_setting),
+			.regs = sensor_1928x1092_2lane_30fps_setting,
+		},
+		.link_freq_index = OV02C10_LINK_FREQ_400MHZ_INDEX,
+	},
+};
+
+struct ov02c10 {
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_ctrl_handler ctrl_handler;
+
+	/* V4L2 Controls */
+	struct v4l2_ctrl *link_freq;
+	struct v4l2_ctrl *pixel_rate;
+	struct v4l2_ctrl *vblank;
+	struct v4l2_ctrl *hblank;
+	struct v4l2_ctrl *exposure;
+	/* Current mode */
+	const struct ov02c10_mode *cur_mode;
+
+	/* To serialize asynchronus callbacks */
+	struct mutex mutex;
+
+	/* MIPI lanes used */
+	u8 mipi_lanes;
+
+	/* Streaming on/off */
+	bool streaming;
+};
+
+static inline struct ov02c10 *to_ov02c10(struct v4l2_subdev *subdev)
+{
+	return container_of(subdev, struct ov02c10, sd);
+}
+
+static int ov02c10_read_reg(struct ov02c10 *ov02c10, u16 reg, u16 len, u32 *val)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&ov02c10->sd);
+	struct i2c_msg msgs[2];
+	u8 addr_buf[2];
+	u8 data_buf[4] = {0};
+	int ret = 0;
+
+	if (len > sizeof(data_buf))
+		return -EINVAL;
+
+	put_unaligned_be16(reg, addr_buf);
+	msgs[0].addr = client->addr;
+	msgs[0].flags = 0;
+	msgs[0].len = sizeof(addr_buf);
+	msgs[0].buf = addr_buf;
+	msgs[1].addr = client->addr;
+	msgs[1].flags = I2C_M_RD;
+	msgs[1].len = len;
+	msgs[1].buf = &data_buf[sizeof(data_buf) - len];
+
+	ret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));
+
+	if (ret != ARRAY_SIZE(msgs))
+		return ret < 0 ? ret : -EIO;
+
+	*val = get_unaligned_be32(data_buf);
+
+	return 0;
+}
+
+static int ov02c10_write_reg(struct ov02c10 *ov02c10, u16 reg, u16 len, u32 val)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&ov02c10->sd);
+	u8 buf[6];
+	int ret = 0;
+
+	if (len > 4)
+		return -EINVAL;
+
+	put_unaligned_be16(reg, buf);
+	put_unaligned_be32(val << 8 * (4 - len), buf + 2);
+
+	ret = i2c_master_send(client, buf, len + 2);
+	if (ret != len + 2)
+		return ret < 0 ? ret : -EIO;
+
+	return 0;
+}
+
+static int ov02c10_write_reg_list(struct ov02c10 *ov02c10,
+				  const struct ov02c10_reg_list *r_list)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&ov02c10->sd);
+	unsigned int i;
+	int ret = 0;
+
+	for (i = 0; i < r_list->num_of_regs; i++) {
+		ret = ov02c10_write_reg(ov02c10, r_list->regs[i].address, 1,
+					r_list->regs[i].val);
+		if (ret) {
+			dev_err_ratelimited(&client->dev,
+					    "write reg 0x%4.4x return err = %d",
+					    r_list->regs[i].address, ret);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int ov02c10_test_pattern(struct ov02c10 *ov02c10, u32 pattern)
+{
+	if (pattern)
+		pattern = (pattern - 1) << OV02C10_TEST_PATTERN_BAR_SHIFT |
+			  OV02C10_TEST_PATTERN_ENABLE;
+
+	return ov02c10_write_reg(ov02c10, OV02C10_REG_TEST_PATTERN, 1, pattern);
+}
+
+static int ov02c10_set_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct ov02c10 *ov02c10 = container_of(ctrl->handler,
+					     struct ov02c10, ctrl_handler);
+	struct i2c_client *client = v4l2_get_subdevdata(&ov02c10->sd);
+	s64 exposure_max;
+	int ret = 0;
+
+	/* Propagate change of current control to all related controls */
+	if (ctrl->id == V4L2_CID_VBLANK) {
+		/* Update max exposure while meeting expected vblanking */
+		exposure_max = ov02c10->cur_mode->height + ctrl->val -
+			       OV02C10_EXPOSURE_MAX_MARGIN;
+		__v4l2_ctrl_modify_range(ov02c10->exposure,
+					 ov02c10->exposure->minimum,
+					 exposure_max, ov02c10->exposure->step,
+					 exposure_max);
+	}
+
+	/* V4L2 controls values will be applied only when power is already up */
+	if (!pm_runtime_get_if_in_use(&client->dev))
+		return 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_ANALOGUE_GAIN:
+		ret = ov02c10_write_reg(ov02c10, OV02C10_REG_ANALOG_GAIN, 2,
+					ctrl->val << 4);
+		break;
+
+	case V4L2_CID_DIGITAL_GAIN:
+		ret = ov02c10_write_reg(ov02c10, OV02C10_REG_DIGILAL_GAIN, 3,
+					ctrl->val << 6);
+		break;
+
+	case V4L2_CID_EXPOSURE:
+		ret = ov02c10_write_reg(ov02c10, OV02C10_REG_EXPOSURE, 2,
+					ctrl->val);
+		break;
+
+	case V4L2_CID_VBLANK:
+		ret = ov02c10_write_reg(ov02c10, OV02C10_REG_VTS, 2,
+					ov02c10->cur_mode->height + ctrl->val);
+		break;
+
+	case V4L2_CID_TEST_PATTERN:
+		ret = ov02c10_test_pattern(ov02c10, ctrl->val);
+		break;
+
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	pm_runtime_put(&client->dev);
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops ov02c10_ctrl_ops = {
+	.s_ctrl = ov02c10_set_ctrl,
+};
+
+static int ov02c10_init_controls(struct ov02c10 *ov02c10)
+{
+	struct v4l2_ctrl_handler *ctrl_hdlr;
+	const struct ov02c10_mode *cur_mode;
+	s64 exposure_max, h_blank;
+	u32 vblank_min, vblank_max, vblank_default;
+	int size;
+	int ret = 0;
+
+	ctrl_hdlr = &ov02c10->ctrl_handler;
+	ret = v4l2_ctrl_handler_init(ctrl_hdlr, 8);
+	if (ret)
+		return ret;
+
+	ctrl_hdlr->lock = &ov02c10->mutex;
+	cur_mode = ov02c10->cur_mode;
+	size = ARRAY_SIZE(link_freq_menu_items);
+
+	ov02c10->link_freq = v4l2_ctrl_new_int_menu(ctrl_hdlr,
+						    &ov02c10_ctrl_ops,
+						    V4L2_CID_LINK_FREQ,
+						    size - 1, 0,
+						    link_freq_menu_items);
+	if (ov02c10->link_freq)
+		ov02c10->link_freq->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	ov02c10->pixel_rate = v4l2_ctrl_new_std(ctrl_hdlr, &ov02c10_ctrl_ops,
+						V4L2_CID_PIXEL_RATE, 0,
+						OV02C10_SCLK, 1, OV02C10_SCLK);
+
+	vblank_min = cur_mode->vts_min - cur_mode->height;
+	vblank_max = OV02C10_VTS_MAX - cur_mode->height;
+	vblank_default = cur_mode->vts_def - cur_mode->height;
+	ov02c10->vblank = v4l2_ctrl_new_std(ctrl_hdlr, &ov02c10_ctrl_ops,
+					    V4L2_CID_VBLANK, vblank_min,
+					    vblank_max, 1, vblank_default);
+
+	h_blank = cur_mode->hts - cur_mode->width;
+	ov02c10->hblank = v4l2_ctrl_new_std(ctrl_hdlr, &ov02c10_ctrl_ops,
+					    V4L2_CID_HBLANK, h_blank, h_blank,
+					    1, h_blank);
+	if (ov02c10->hblank)
+		ov02c10->hblank->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	v4l2_ctrl_new_std(ctrl_hdlr, &ov02c10_ctrl_ops, V4L2_CID_ANALOGUE_GAIN,
+			  OV02C10_ANAL_GAIN_MIN, OV02C10_ANAL_GAIN_MAX,
+			  OV02C10_ANAL_GAIN_STEP, OV02C10_ANAL_GAIN_DEFAULT);
+	v4l2_ctrl_new_std(ctrl_hdlr, &ov02c10_ctrl_ops, V4L2_CID_DIGITAL_GAIN,
+			  OV02C10_DGTL_GAIN_MIN, OV02C10_DGTL_GAIN_MAX,
+			  OV02C10_DGTL_GAIN_STEP, OV02C10_DGTL_GAIN_DEFAULT);
+	exposure_max = cur_mode->vts_def - OV02C10_EXPOSURE_MAX_MARGIN;
+	ov02c10->exposure = v4l2_ctrl_new_std(ctrl_hdlr, &ov02c10_ctrl_ops,
+					      V4L2_CID_EXPOSURE,
+					      OV02C10_EXPOSURE_MIN,
+					      exposure_max,
+					      OV02C10_EXPOSURE_STEP,
+					      exposure_max);
+	v4l2_ctrl_new_std_menu_items(ctrl_hdlr, &ov02c10_ctrl_ops,
+				     V4L2_CID_TEST_PATTERN,
+				     ARRAY_SIZE(ov02c10_test_pattern_menu) - 1,
+				     0, 0, ov02c10_test_pattern_menu);
+	if (ctrl_hdlr->error)
+		return ctrl_hdlr->error;
+
+	ov02c10->sd.ctrl_handler = ctrl_hdlr;
+
+	return 0;
+}
+
+static void ov02c10_update_pad_format(const struct ov02c10_mode *mode,
+				      struct v4l2_mbus_framefmt *fmt)
+{
+	fmt->width = mode->width;
+	fmt->height = mode->height;
+	fmt->code = MEDIA_BUS_FMT_SGRBG10_1X10;
+	fmt->field = V4L2_FIELD_NONE;
+}
+
+static int ov02c10_start_streaming(struct ov02c10 *ov02c10)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&ov02c10->sd);
+	const struct ov02c10_reg_list *reg_list;
+	int link_freq_index;
+	int ret = 0;
+	link_freq_index = ov02c10->cur_mode->link_freq_index;
+	reg_list = &link_freq_configs[link_freq_index].reg_list;
+	ret = ov02c10_write_reg_list(ov02c10, reg_list);
+	if (ret) {
+		dev_err(&client->dev, "failed to set plls");
+		return ret;
+	}
+
+	reg_list = &ov02c10->cur_mode->reg_list;
+	ret = ov02c10_write_reg_list(ov02c10, reg_list);
+	if (ret) {
+		dev_err(&client->dev, "failed to set mode");
+		return ret;
+	}
+
+	ret = __v4l2_ctrl_handler_setup(ov02c10->sd.ctrl_handler);
+	if (ret)
+		return ret;
+
+	ret = ov02c10_write_reg(ov02c10, OV02C10_REG_MODE_SELECT, 1,
+				OV02C10_MODE_STREAMING);
+	if (ret)
+		dev_err(&client->dev, "failed to start streaming");
+
+	return ret;
+}
+
+static void ov02c10_stop_streaming(struct ov02c10 *ov02c10)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&ov02c10->sd);
+	int ret = 0;
+
+	ret = ov02c10_write_reg(ov02c10, OV02C10_REG_MODE_SELECT, 1,
+				OV02C10_MODE_STANDBY);
+	if (ret)
+		dev_err(&client->dev, "failed to stop streaming");
+}
+
+static int ov02c10_set_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct ov02c10 *ov02c10 = to_ov02c10(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = 0;
+
+	if (ov02c10->streaming == enable)
+		return 0;
+
+	mutex_lock(&ov02c10->mutex);
+	if (enable) {
+		ret = pm_runtime_get_sync(&client->dev);
+		if (ret < 0) {
+			pm_runtime_put_noidle(&client->dev);
+			mutex_unlock(&ov02c10->mutex);
+			return ret;
+		}
+
+		ret = ov02c10_start_streaming(ov02c10);
+		if (ret) {
+			enable = 0;
+			ov02c10_stop_streaming(ov02c10);
+			pm_runtime_put(&client->dev);
+		}
+	} else {
+		ov02c10_stop_streaming(ov02c10);
+		pm_runtime_put(&client->dev);
+	}
+
+	ov02c10->streaming = enable;
+	mutex_unlock(&ov02c10->mutex);
+
+	return ret;
+}
+
+static int __maybe_unused ov02c10_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov02c10 *ov02c10 = to_ov02c10(sd);
+
+	mutex_lock(&ov02c10->mutex);
+	if (ov02c10->streaming)
+		ov02c10_stop_streaming(ov02c10);
+
+	mutex_unlock(&ov02c10->mutex);
+
+	return 0;
+}
+
+static int __maybe_unused ov02c10_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov02c10 *ov02c10 = to_ov02c10(sd);
+	int ret = 0;
+
+	mutex_lock(&ov02c10->mutex);
+	if (!ov02c10->streaming)
+		goto exit;
+
+	ret = ov02c10_start_streaming(ov02c10);
+	if (ret) {
+		ov02c10->streaming = false;
+		ov02c10_stop_streaming(ov02c10);
+	}
+
+exit:
+	mutex_unlock(&ov02c10->mutex);
+	return ret;
+}
+
+static int ov02c10_set_format(struct v4l2_subdev *sd,
+			      struct v4l2_subdev_state *sd_state,
+			      struct v4l2_subdev_format *fmt)
+{
+	struct ov02c10 *ov02c10 = to_ov02c10(sd);
+	const struct ov02c10_mode *mode;
+	s32 vblank_def, h_blank;
+
+	if (ov02c10->mipi_lanes == 1)
+		mode = &supported_modes[0];
+	else if (ov02c10->mipi_lanes == 2)
+		mode = &supported_modes[1];
+	else {
+		mode = v4l2_find_nearest_size(supported_modes,
+					      ARRAY_SIZE(supported_modes),
+					      width, height, fmt->format.width,
+					      fmt->format.height);
+	}
+
+	mutex_lock(&ov02c10->mutex);
+	ov02c10_update_pad_format(mode, &fmt->format);
+	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {
+		*v4l2_subdev_get_try_format(sd, sd_state, fmt->pad) = fmt->format;
+	} else {
+		ov02c10->cur_mode = mode;
+		__v4l2_ctrl_s_ctrl(ov02c10->link_freq, mode->link_freq_index);
+		__v4l2_ctrl_s_ctrl_int64(ov02c10->pixel_rate, OV02C10_SCLK);
+
+		/* Update limits and set FPS to default */
+		vblank_def = mode->vts_def - mode->height;
+		__v4l2_ctrl_modify_range(ov02c10->vblank,
+					 mode->vts_min - mode->height,
+					 OV02C10_VTS_MAX - mode->height, 1,
+					 vblank_def);
+		__v4l2_ctrl_s_ctrl(ov02c10->vblank, vblank_def);
+		h_blank = mode->hts - mode->width;
+		__v4l2_ctrl_modify_range(ov02c10->hblank, h_blank, h_blank, 1,
+					 h_blank);
+	}
+	mutex_unlock(&ov02c10->mutex);
+
+	return 0;
+}
+
+static int ov02c10_get_format(struct v4l2_subdev *sd,
+			      struct v4l2_subdev_state *sd_state,
+			      struct v4l2_subdev_format *fmt)
+{
+	struct ov02c10 *ov02c10 = to_ov02c10(sd);
+
+	mutex_lock(&ov02c10->mutex);
+	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY)
+		fmt->format = *v4l2_subdev_get_try_format(&ov02c10->sd,
+							  sd_state, fmt->pad);
+	else
+		ov02c10_update_pad_format(ov02c10->cur_mode, &fmt->format);
+
+	mutex_unlock(&ov02c10->mutex);
+
+	return 0;
+}
+
+static int ov02c10_enum_mbus_code(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_state *sd_state,
+				  struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->index > 0)
+		return -EINVAL;
+
+	code->code = MEDIA_BUS_FMT_SGRBG10_1X10;
+
+	return 0;
+}
+
+static int ov02c10_enum_frame_size(struct v4l2_subdev *sd,
+				   struct v4l2_subdev_state *sd_state,
+				   struct v4l2_subdev_frame_size_enum *fse)
+{
+	if (fse->index >= ARRAY_SIZE(supported_modes))
+		return -EINVAL;
+
+	if (fse->code != MEDIA_BUS_FMT_SGRBG10_1X10)
+		return -EINVAL;
+
+	fse->min_width = supported_modes[fse->index].width;
+	fse->max_width = fse->min_width;
+	fse->min_height = supported_modes[fse->index].height;
+	fse->max_height = fse->min_height;
+
+	return 0;
+}
+
+static int ov02c10_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct ov02c10 *ov02c10 = to_ov02c10(sd);
+
+	mutex_lock(&ov02c10->mutex);
+	ov02c10_update_pad_format(&supported_modes[0],
+				  v4l2_subdev_get_try_format(sd, fh->state, 0));
+	mutex_unlock(&ov02c10->mutex);
+
+	return 0;
+}
+
+static const struct v4l2_subdev_video_ops ov02c10_video_ops = {
+	.s_stream = ov02c10_set_stream,
+};
+
+static const struct v4l2_subdev_pad_ops ov02c10_pad_ops = {
+	.set_fmt = ov02c10_set_format,
+	.get_fmt = ov02c10_get_format,
+	.enum_mbus_code = ov02c10_enum_mbus_code,
+	.enum_frame_size = ov02c10_enum_frame_size,
+};
+
+static const struct v4l2_subdev_ops ov02c10_subdev_ops = {
+	.video = &ov02c10_video_ops,
+	.pad = &ov02c10_pad_ops,
+};
+
+static const struct media_entity_operations ov02c10_subdev_entity_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+static const struct v4l2_subdev_internal_ops ov02c10_internal_ops = {
+	.open = ov02c10_open,
+};
+
+static void ov02c10_read_mipi_lanes(struct ov02c10 *ov02c10)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&ov02c10->sd);
+	struct mipi_camera_link_ssdb ssdb;
+	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+	struct acpi_device *adev = ACPI_COMPANION(&client->dev);
+	union acpi_object *obj;
+	acpi_status status;
+
+	ov02c10->mipi_lanes = OV02C10_DATA_LANES;
+	if (!adev) {
+		dev_info(&client->dev, "Not ACPI device\n");
+		return;
+	}
+	status = acpi_evaluate_object(adev->handle, "SSDB", NULL, &buffer);
+	if (ACPI_FAILURE(status)) {
+		dev_info(&client->dev, "ACPI fail: %d\n", -ENODEV);
+		return;
+	}
+
+	obj = buffer.pointer;
+	if (!obj) {
+		dev_info(&client->dev, "Couldn't locate ACPI buffer\n");
+		return;
+	}
+
+	if (obj->type != ACPI_TYPE_BUFFER) {
+		dev_info(&client->dev, "Not an ACPI buffer\n");
+		goto out_free_buff;
+	}
+
+	if (obj->buffer.length > sizeof(ssdb)) {
+		dev_err(&client->dev, "Given buffer is too small\n");
+		goto out_free_buff;
+	}
+	memcpy(&ssdb, obj->buffer.pointer, obj->buffer.length);
+	ov02c10->mipi_lanes = ssdb.lanes;
+
+out_free_buff:
+	kfree(buffer.pointer);
+}
+
+static int ov02c10_identify_module(struct ov02c10 *ov02c10)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&ov02c10->sd);
+	int ret;
+	u32 val;
+
+	ret = ov02c10_read_reg(ov02c10, OV02C10_REG_CHIP_ID, 3, &val);
+	if (ret)
+		return ret;
+
+	if (val != OV02C10_CHIP_ID) {
+		dev_err(&client->dev, "chip id mismatch: %x!=%x",
+			OV02C10_CHIP_ID, val);
+		return -ENXIO;
+	}
+
+	return 0;
+}
+
+static void ov02c10_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov02c10 *ov02c10 = to_ov02c10(sd);
+
+	v4l2_async_unregister_subdev(sd);
+	media_entity_cleanup(&sd->entity);
+	v4l2_ctrl_handler_free(sd->ctrl_handler);
+	pm_runtime_disable(&client->dev);
+	mutex_destroy(&ov02c10->mutex);
+
+}
+
+static int ov02c10_probe(struct i2c_client *client)
+{
+	struct ov02c10 *ov02c10;
+	int ret = 0;
+
+	ov02c10 = devm_kzalloc(&client->dev, sizeof(*ov02c10), GFP_KERNEL);
+	if (!ov02c10) {
+		ret = -ENOMEM;
+		goto probe_error_ret;
+	}
+
+	v4l2_i2c_subdev_init(&ov02c10->sd, client, &ov02c10_subdev_ops);
+
+	ret = ov02c10_identify_module(ov02c10);
+	if (ret) {
+		dev_err(&client->dev, "failed to find sensor: %d", ret);
+		goto probe_error_ret;
+	}
+
+	ov02c10_read_mipi_lanes(ov02c10);
+	mutex_init(&ov02c10->mutex);
+	ov02c10->cur_mode = &supported_modes[0];
+	if (ov02c10->mipi_lanes == 2)
+		ov02c10->cur_mode = &supported_modes[1];
+	ret = ov02c10_init_controls(ov02c10);
+	if (ret) {
+		dev_err(&client->dev, "failed to init controls: %d", ret);
+		goto probe_error_v4l2_ctrl_handler_free;
+	}
+
+	ov02c10->sd.internal_ops = &ov02c10_internal_ops;
+	ov02c10->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	ov02c10->sd.entity.ops = &ov02c10_subdev_entity_ops;
+	ov02c10->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;
+	ov02c10->pad.flags = MEDIA_PAD_FL_SOURCE;
+	ret = media_entity_pads_init(&ov02c10->sd.entity, 1, &ov02c10->pad);
+	if (ret) {
+		dev_err(&client->dev, "failed to init entity pads: %d", ret);
+		goto probe_error_v4l2_ctrl_handler_free;
+	}
+
+	ret = v4l2_async_register_subdev_sensor(&ov02c10->sd);
+	if (ret < 0) {
+		dev_err(&client->dev, "failed to register V4L2 subdev: %d",
+			ret);
+		goto probe_error_media_entity_cleanup;
+	}
+
+	/*
+	 * Device is already turned on by i2c-core with ACPI domain PM.
+	 * Enable runtime PM and turn off the device.
+	 */
+	pm_runtime_set_active(&client->dev);
+	pm_runtime_enable(&client->dev);
+	pm_runtime_idle(&client->dev);
+
+	return 0;
+
+probe_error_media_entity_cleanup:
+	media_entity_cleanup(&ov02c10->sd.entity);
+
+probe_error_v4l2_ctrl_handler_free:
+	v4l2_ctrl_handler_free(ov02c10->sd.ctrl_handler);
+	mutex_destroy(&ov02c10->mutex);
+
+probe_error_ret:
+	return ret;
+}
+
+static const struct dev_pm_ops ov02c10_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(ov02c10_suspend, ov02c10_resume)
+};
+
+#ifdef CONFIG_ACPI
+static const struct acpi_device_id ov02c10_acpi_ids[] = {
+	{"OVTI02C1"},
+	{}
+};
+
+MODULE_DEVICE_TABLE(acpi, ov02c10_acpi_ids);
+#endif
+
+static struct i2c_driver ov02c10_i2c_driver = {
+	.driver = {
+		.name = "ov02c10",
+		.pm = &ov02c10_pm_ops,
+		.acpi_match_table = ACPI_PTR(ov02c10_acpi_ids),
+	},
+	.probe_new = ov02c10_probe,
+	.remove = ov02c10_remove,
+};
+
+module_i2c_driver(ov02c10_i2c_driver);
+
+MODULE_AUTHOR("Hao Yao <hao.yao@intel.com>");
+MODULE_DESCRIPTION("OmniVision OV02C10 sensor driver");
+MODULE_LICENSE("GPL v2");
Index: b/drivers/media/i2c/ov13858_intel.c
===================================================================
--- /dev/null
+++ b/drivers/media/i2c/ov13858_intel.c
@@ -0,0 +1,2067 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (c) 2022 Intel Corporation.
+
+#include <linux/acpi.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/version.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-fwnode.h>
+
+#define OV13858_REG_VALUE_08BIT		1
+#define OV13858_REG_VALUE_16BIT		2
+#define OV13858_REG_VALUE_24BIT		3
+
+#define OV13858_REG_MODE_SELECT		0x0100
+#define OV13858_MODE_STANDBY		0x00
+#define OV13858_MODE_STREAMING		0x01
+
+#define OV13858_REG_SOFTWARE_RST	0x0103
+#define OV13858_SOFTWARE_RST		0x01
+
+/* PLL1 generates PCLK and MIPI_PHY_CLK */
+#define OV13858_REG_PLL1_CTRL_0		0x0300
+#define OV13858_REG_PLL1_CTRL_1		0x0301
+#define OV13858_REG_PLL1_CTRL_2		0x0302
+#define OV13858_REG_PLL1_CTRL_3		0x0303
+#define OV13858_REG_PLL1_CTRL_4		0x0304
+#define OV13858_REG_PLL1_CTRL_5		0x0305
+
+/* PLL2 generates DAC_CLK, SCLK and SRAM_CLK */
+#define OV13858_REG_PLL2_CTRL_B		0x030b
+#define OV13858_REG_PLL2_CTRL_C		0x030c
+#define OV13858_REG_PLL2_CTRL_D		0x030d
+#define OV13858_REG_PLL2_CTRL_E		0x030e
+#define OV13858_REG_PLL2_CTRL_F		0x030f
+#define OV13858_REG_PLL2_CTRL_12	0x0312
+#define OV13858_REG_MIPI_SC_CTRL0	0x3016
+#define OV13858_REG_MIPI_SC_CTRL1	0x3022
+
+/* Chip ID */
+#define OV13858_REG_CHIP_ID		0x300a
+#define OV13858_CHIP_ID			0x00d855
+
+/* V_TIMING internal */
+#define OV13858_REG_VTS			0x380e
+#define OV13858_VTS_30FPS		0x0c8e /* 30 fps */
+#define OV13858_VTS_60FPS		0x0648 /* 60 fps */
+#define OV13858_VTS_MAX			0x7fff
+
+/* HBLANK control - read only */
+#define OV13858_PPL_270MHZ		2244
+#define OV13858_PPL_540MHZ		4488
+
+/* Exposure control */
+#define OV13858_REG_EXPOSURE		0x3500
+#define OV13858_EXPOSURE_MIN		4
+#define OV13858_EXPOSURE_STEP		1
+#define OV13858_EXPOSURE_DEFAULT	0x640
+
+/* Format1 control */
+#define OV13858_REG_FORMAT1		0x3820
+#define OV13858_FORMAT1_DFT		0xA0
+
+/* Analog gain control */
+#define OV13858_REG_ANALOG_GAIN		0x3508
+#define OV13858_ANA_GAIN_MIN		0
+#define OV13858_ANA_GAIN_MAX		0x1fff
+#define OV13858_ANA_GAIN_STEP		1
+#define OV13858_ANA_GAIN_DEFAULT	0x80
+
+/* Digital gain control */
+#define OV13858_REG_B_MWB_GAIN		0x5100
+#define OV13858_REG_G_MWB_GAIN		0x5102
+#define OV13858_REG_R_MWB_GAIN		0x5104
+#define OV13858_DGTL_GAIN_MIN		0
+#define OV13858_DGTL_GAIN_MAX		16384	/* Max = 16 X */
+#define OV13858_DGTL_GAIN_DEFAULT	1024	/* Default gain = 1 X */
+#define OV13858_DGTL_GAIN_STEP		1	/* Each step = 1/1024 */
+
+/* Test Pattern Control */
+#define OV13858_REG_TEST_PATTERN	0x4503
+#define OV13858_TEST_PATTERN_ENABLE	BIT(7)
+#define OV13858_TEST_PATTERN_MASK	0xfc
+
+/* Number of frames to skip */
+#define OV13858_NUM_OF_SKIP_FRAMES	2
+
+struct ov13858_reg {
+	u16 address;
+	u8 val;
+};
+
+struct ov13858_reg_list {
+	u32 num_of_regs;
+	const struct ov13858_reg *regs;
+};
+
+/* Link frequency config */
+struct ov13858_link_freq_config {
+	u32 pixels_per_line;
+
+	/* PLL registers for this link frequency */
+	struct ov13858_reg_list reg_list;
+};
+
+/* Mode : resolution and related config&values */
+struct ov13858_mode {
+	/* Frame width */
+	u32 width;
+	/* Frame height */
+	u32 height;
+
+	/* V-timing */
+	u32 vts_def;
+	u32 vts_min;
+
+	/* Index of Link frequency config to be used */
+	u32 link_freq_index;
+	/* Default register values */
+	struct ov13858_reg_list reg_list;
+};
+
+/* Format1: used for vertical/horizontal flip */
+union ov13858_format1 {
+	u8 val;
+	struct {
+		u8 d0     : 3; /* bit[0:2] */
+		u8 hflip  : 1; /* 0 enable,  1 disable */
+		u8 vflip  : 1; /* 0 disable, 1 enable  */
+		u8 d1     : 3; /* bit[5:7] */
+	} bits;
+};
+
+/* 4224x3136 needs 1080Mbps/lane, 4 lanes */
+static const struct ov13858_reg mipi_data_rate_1080mbps[] = {
+	/* PLL1 registers */
+	{OV13858_REG_PLL1_CTRL_0, 0x07},
+	{OV13858_REG_PLL1_CTRL_1, 0x01},
+	{OV13858_REG_PLL1_CTRL_2, 0xc2},
+	{OV13858_REG_PLL1_CTRL_3, 0x00},
+	{OV13858_REG_PLL1_CTRL_4, 0x00},
+	{OV13858_REG_PLL1_CTRL_5, 0x01},
+
+	/* PLL2 registers */
+	{OV13858_REG_PLL2_CTRL_B, 0x05},
+	{OV13858_REG_PLL2_CTRL_C, 0x01},
+	{OV13858_REG_PLL2_CTRL_D, 0x0e},
+	{OV13858_REG_PLL2_CTRL_E, 0x05},
+	{OV13858_REG_PLL2_CTRL_F, 0x01},
+	{OV13858_REG_PLL2_CTRL_12, 0x01},
+	{OV13858_REG_MIPI_SC_CTRL0, 0x72},
+	{OV13858_REG_MIPI_SC_CTRL1, 0x01},
+};
+
+/*
+ * 2112x1568, 2112x1188, 1056x784 need 540Mbps/lane,
+ * 4 lanes
+ */
+static const struct ov13858_reg mipi_data_rate_540mbps[] = {
+	/* PLL1 registers */
+	{OV13858_REG_PLL1_CTRL_0, 0x07},
+	{OV13858_REG_PLL1_CTRL_1, 0x01},
+	{OV13858_REG_PLL1_CTRL_2, 0xc2},
+	{OV13858_REG_PLL1_CTRL_3, 0x01},
+	{OV13858_REG_PLL1_CTRL_4, 0x00},
+	{OV13858_REG_PLL1_CTRL_5, 0x01},
+
+	/* PLL2 registers */
+	{OV13858_REG_PLL2_CTRL_B, 0x05},
+	{OV13858_REG_PLL2_CTRL_C, 0x01},
+	{OV13858_REG_PLL2_CTRL_D, 0x0e},
+	{OV13858_REG_PLL2_CTRL_E, 0x05},
+	{OV13858_REG_PLL2_CTRL_F, 0x01},
+	{OV13858_REG_PLL2_CTRL_12, 0x01},
+	{OV13858_REG_MIPI_SC_CTRL0, 0x72},
+	{OV13858_REG_MIPI_SC_CTRL1, 0x01},
+};
+
+static const struct ov13858_reg mode_4224x3136_regs[] = {
+	{0x3013, 0x32},
+	{0x301b, 0xf0},
+	{0x301f, 0xd0},
+	{0x3106, 0x15},
+	{0x3107, 0x23},
+	{0x350a, 0x00},
+	{0x350e, 0x00},
+	{0x3510, 0x00},
+	{0x3511, 0x02},
+	{0x3512, 0x00},
+	{0x3600, 0x2b},
+	{0x3601, 0x52},
+	{0x3602, 0x60},
+	{0x3612, 0x05},
+	{0x3613, 0xa4},
+	{0x3620, 0x80},
+	{0x3621, 0x10},
+	{0x3622, 0x30},
+	{0x3624, 0x1c},
+	{0x3640, 0x10},
+	{0x3641, 0x70},
+	{0x3660, 0x04},
+	{0x3661, 0x80},
+	{0x3662, 0x12},
+	{0x3664, 0x73},
+	{0x3665, 0xa7},
+	{0x366e, 0xff},
+	{0x366f, 0xf4},
+	{0x3674, 0x00},
+	{0x3679, 0x0c},
+	{0x367f, 0x01},
+	{0x3680, 0x0c},
+	{0x3681, 0x50},
+	{0x3682, 0x50},
+	{0x3683, 0xa9},
+	{0x3684, 0xa9},
+	{0x3709, 0x5f},
+	{0x3714, 0x24},
+	{0x371a, 0x3e},
+	{0x3737, 0x04},
+	{0x3738, 0xcc},
+	{0x3739, 0x12},
+	{0x373d, 0x26},
+	{0x3764, 0x20},
+	{0x3765, 0x20},
+	{0x37a1, 0x36},
+	{0x37a8, 0x3b},
+	{0x37ab, 0x31},
+	{0x37c2, 0x04},
+	{0x37c3, 0xf1},
+	{0x37c5, 0x00},
+	{0x37d8, 0x03},
+	{0x37d9, 0x0c},
+	{0x37da, 0xc2},
+	{0x37dc, 0x02},
+	{0x37e0, 0x00},
+	{0x37e1, 0x0a},
+	{0x37e2, 0x14},
+	{0x37e3, 0x04},
+	{0x37e4, 0x2a},
+	{0x37e5, 0x03},
+	{0x37e6, 0x04},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0x08},
+	{0x3804, 0x10},
+	{0x3805, 0x9f},
+	{0x3806, 0x0c},
+	{0x3807, 0x57},
+	{0x3808, 0x10},
+	{0x3809, 0x80},
+	{0x380a, 0x0c},
+	{0x380b, 0x40},
+	{0x380c, 0x04},
+	{0x380d, 0x62},
+	{0x380e, 0x0c},
+	{0x380f, 0x8e},
+	{0x3811, 0x04},
+	{0x3813, 0x05},
+	{0x3814, 0x01},
+	{0x3815, 0x01},
+	{0x3816, 0x01},
+	{0x3817, 0x01},
+	{0x3820, 0xa8},
+	{0x3821, 0x00},
+	{0x3822, 0xc2},
+	{0x3823, 0x18},
+	{0x3826, 0x11},
+	{0x3827, 0x1c},
+	{0x3829, 0x03},
+	{0x3832, 0x00},
+	{0x3c80, 0x00},
+	{0x3c87, 0x01},
+	{0x3c8c, 0x19},
+	{0x3c8d, 0x1c},
+	{0x3c90, 0x00},
+	{0x3c91, 0x00},
+	{0x3c92, 0x00},
+	{0x3c93, 0x00},
+	{0x3c94, 0x40},
+	{0x3c95, 0x54},
+	{0x3c96, 0x34},
+	{0x3c97, 0x04},
+	{0x3c98, 0x00},
+	{0x3d8c, 0x73},
+	{0x3d8d, 0xc0},
+	{0x3f00, 0x0b},
+	{0x3f03, 0x00},
+	{0x4001, 0xe0},
+	{0x4008, 0x00},
+	{0x4009, 0x0f},
+	{0x4011, 0xf0},
+	{0x4017, 0x08},
+	{0x4050, 0x04},
+	{0x4051, 0x0b},
+	{0x4052, 0x00},
+	{0x4053, 0x80},
+	{0x4054, 0x00},
+	{0x4055, 0x80},
+	{0x4056, 0x00},
+	{0x4057, 0x80},
+	{0x4058, 0x00},
+	{0x4059, 0x80},
+	{0x405e, 0x20},
+	{0x4500, 0x07},
+	{0x4503, 0x00},
+	{0x450a, 0x04},
+	{0x4809, 0x04},
+	{0x480c, 0x12},
+	{0x481f, 0x30},
+	{0x4833, 0x10},
+	{0x4837, 0x0e},
+	{0x4902, 0x01},
+	{0x4d00, 0x03},
+	{0x4d01, 0xc9},
+	{0x4d02, 0xbc},
+	{0x4d03, 0xd7},
+	{0x4d04, 0xf0},
+	{0x4d05, 0xa2},
+	{0x5000, 0xfd},
+	{0x5001, 0x01},
+	{0x5040, 0x39},
+	{0x5041, 0x10},
+	{0x5042, 0x10},
+	{0x5043, 0x84},
+	{0x5044, 0x62},
+	{0x5180, 0x00},
+	{0x5181, 0x10},
+	{0x5182, 0x02},
+	{0x5183, 0x0f},
+	{0x5200, 0x1b},
+	{0x520b, 0x07},
+	{0x520c, 0x0f},
+	{0x5300, 0x04},
+	{0x5301, 0x0c},
+	{0x5302, 0x0c},
+	{0x5303, 0x0f},
+	{0x5304, 0x00},
+	{0x5305, 0x70},
+	{0x5306, 0x00},
+	{0x5307, 0x80},
+	{0x5308, 0x00},
+	{0x5309, 0xa5},
+	{0x530a, 0x00},
+	{0x530b, 0xd3},
+	{0x530c, 0x00},
+	{0x530d, 0xf0},
+	{0x530e, 0x01},
+	{0x530f, 0x10},
+	{0x5310, 0x01},
+	{0x5311, 0x20},
+	{0x5312, 0x01},
+	{0x5313, 0x20},
+	{0x5314, 0x01},
+	{0x5315, 0x20},
+	{0x5316, 0x08},
+	{0x5317, 0x08},
+	{0x5318, 0x10},
+	{0x5319, 0x88},
+	{0x531a, 0x88},
+	{0x531b, 0xa9},
+	{0x531c, 0xaa},
+	{0x531d, 0x0a},
+	{0x5405, 0x02},
+	{0x5406, 0x67},
+	{0x5407, 0x01},
+	{0x5408, 0x4a},
+};
+
+static const struct ov13858_reg mode_4096x3072_regs[] = {
+	{0x3012, 0x40},
+	{0x3013, 0x72},
+	{0x301b, 0xf0},
+	{0x301f, 0xd0},
+	{0x3106, 0x15},
+	{0x3107, 0x23},
+	{0x3500, 0x00},
+	{0x3501, 0x80},
+	{0x3502, 0x00},
+	{0x3508, 0x02},
+	{0x3509, 0x00},
+	{0x350a, 0x00},
+	{0x350e, 0x00},
+	{0x3510, 0x00},
+	{0x3511, 0x02},
+	{0x3512, 0x00},
+	{0x3600, 0x2b},
+	{0x3601, 0x52},
+	{0x3602, 0x60},
+	{0x3612, 0x05},
+	{0x3613, 0xa4},
+	{0x3620, 0x80},
+	{0x3621, 0x10},
+	{0x3622, 0x30},
+	{0x3624, 0x1c},
+	{0x3640, 0x10},
+	{0x3641, 0x70},
+	{0x3660, 0x04},
+	{0x3661, 0x80},
+	{0x3662, 0x12},
+	{0x3664, 0x73},
+	{0x3665, 0xa7},
+	{0x366e, 0xff},
+	{0x366f, 0xf4},
+	{0x3674, 0x00},
+	{0x3679, 0x0c},
+	{0x367f, 0x01},
+	{0x3680, 0x0c},
+	{0x3681, 0x50},
+	{0x3682, 0x50},
+	{0x3683, 0xa9},
+	{0x3684, 0xa9},
+	{0x3706, 0x40},
+	{0x3709, 0x5f},
+	{0x3714, 0x24},
+	{0x371a, 0x3e},
+	{0x3737, 0x04},
+	{0x3738, 0xcc},
+	{0x3739, 0x12},
+	{0x373d, 0x26},
+	{0x3764, 0x20},
+	{0x3765, 0x20},
+	{0x37a1, 0x36},
+	{0x37a8, 0x3b},
+	{0x37ab, 0x31},
+	{0x37c2, 0x04},
+	{0x37c3, 0xf1},
+	{0x37c5, 0x00},
+	{0x37d8, 0x03},
+	{0x37d9, 0x0c},
+	{0x37da, 0xc2},
+	{0x37dc, 0x02},
+	{0x37e0, 0x00},
+	{0x37e1, 0x0a},
+	{0x37e2, 0x14},
+	{0x37e3, 0x04},
+	{0x37e4, 0x2a},
+	{0x37e5, 0x03},
+	{0x37e6, 0x04},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0x08},
+	{0x3804, 0x10},
+	{0x3805, 0x9f},
+	{0x3806, 0x0c},
+	{0x3807, 0x57},
+	{0x3808, 0x10},
+	{0x3809, 0x00},
+	{0x380a, 0x0c},
+	{0x380b, 0x00},
+	{0x380c, 0x04},
+	{0x380d, 0x62},
+	{0x380e, 0x0c},
+	{0x380f, 0x8e},
+	{0x3810, 0x00},
+	{0x3811, 0x50},
+	{0x3812, 0x00},
+	{0x3813, 0x29},
+	{0x3814, 0x01},
+	{0x3815, 0x01},
+	{0x3816, 0x01},
+	{0x3817, 0x01},
+	{0x3820, 0xa8},
+	{0x3821, 0x00},
+	{0x3822, 0xc2},
+	{0x3823, 0x18},
+	{0x3826, 0x11},
+	{0x3827, 0x1c},
+	{0x3829, 0x03},
+	{0x3832, 0x00},
+	{0x3c80, 0x00},
+	{0x3c87, 0x01},
+	{0x3c8c, 0x19},
+	{0x3c8d, 0x1c},
+	{0x3c90, 0x00},
+	{0x3c91, 0x00},
+	{0x3c92, 0x00},
+	{0x3c93, 0x00},
+	{0x3c94, 0x40},
+	{0x3c95, 0x54},
+	{0x3c96, 0x34},
+	{0x3c97, 0x04},
+	{0x3c98, 0x00},
+	{0x3d8c, 0x73},
+	{0x3d8d, 0xc0},
+	{0x3f00, 0x0b},
+	{0x3f03, 0x00},
+	{0x4001, 0xe0},
+	{0x4008, 0x00},
+	{0x4009, 0x0f},
+	{0x4011, 0xf0},
+	{0x4017, 0x08},
+	{0x4050, 0x04},
+	{0x4051, 0x0b},
+	{0x4052, 0x00},
+	{0x4053, 0x80},
+	{0x4054, 0x00},
+	{0x4055, 0x80},
+	{0x4056, 0x00},
+	{0x4057, 0x80},
+	{0x4058, 0x00},
+	{0x4059, 0x80},
+	{0x405e, 0x20},
+	{0x4500, 0x07},
+	{0x4503, 0x00},
+	{0x450a, 0x04},
+	{0x4809, 0x04},
+	{0x480c, 0x12},
+	{0x481f, 0x30},
+	{0x4833, 0x10},
+	{0x4837, 0x0e},
+	{0x4902, 0x01},
+	{0x4d00, 0x03},
+	{0x4d01, 0xc9},
+	{0x4d02, 0xbc},
+	{0x4d03, 0xd7},
+	{0x4d04, 0xf0},
+	{0x4d05, 0xa2},
+	{0x5000, 0xfd},
+	{0x5001, 0x01},
+	{0x5040, 0x39},
+	{0x5041, 0x10},
+	{0x5042, 0x10},
+	{0x5043, 0x84},
+	{0x5044, 0x62},
+	{0x5180, 0x00},
+	{0x5181, 0x10},
+	{0x5182, 0x02},
+	{0x5183, 0x0f},
+	{0x5200, 0x1b},
+	{0x520b, 0x07},
+	{0x520c, 0x0f},
+	{0x5300, 0x04},
+	{0x5301, 0x0c},
+	{0x5302, 0x0c},
+	{0x5303, 0x0f},
+	{0x5304, 0x00},
+	{0x5305, 0x70},
+	{0x5306, 0x00},
+	{0x5307, 0x80},
+	{0x5308, 0x00},
+	{0x5309, 0xa5},
+	{0x530a, 0x00},
+	{0x530b, 0xd3},
+	{0x530c, 0x00},
+	{0x530d, 0xf0},
+	{0x530e, 0x01},
+	{0x530f, 0x10},
+	{0x5310, 0x01},
+	{0x5311, 0x20},
+	{0x5312, 0x01},
+	{0x5313, 0x20},
+	{0x5314, 0x01},
+	{0x5315, 0x20},
+	{0x5316, 0x08},
+	{0x5317, 0x08},
+	{0x5318, 0x10},
+	{0x5319, 0x88},
+	{0x531a, 0x88},
+	{0x531b, 0xa9},
+	{0x531c, 0xaa},
+	{0x531d, 0x0a},
+	{0x5405, 0x02},
+	{0x5406, 0x67},
+	{0x5407, 0x01},
+	{0x5408, 0x4a},
+};
+
+static const struct ov13858_reg mode_2112x1568_regs[] = {
+	{0x3013, 0x32},
+	{0x301b, 0xf0},
+	{0x301f, 0xd0},
+	{0x3106, 0x15},
+	{0x3107, 0x23},
+	{0x350a, 0x00},
+	{0x350e, 0x00},
+	{0x3510, 0x00},
+	{0x3511, 0x02},
+	{0x3512, 0x00},
+	{0x3600, 0x2b},
+	{0x3601, 0x52},
+	{0x3602, 0x60},
+	{0x3612, 0x05},
+	{0x3613, 0xa4},
+	{0x3620, 0x80},
+	{0x3621, 0x10},
+	{0x3622, 0x30},
+	{0x3624, 0x1c},
+	{0x3640, 0x10},
+	{0x3641, 0x70},
+	{0x3660, 0x04},
+	{0x3661, 0x80},
+	{0x3662, 0x10},
+	{0x3664, 0x73},
+	{0x3665, 0xa7},
+	{0x366e, 0xff},
+	{0x366f, 0xf4},
+	{0x3674, 0x00},
+	{0x3679, 0x0c},
+	{0x367f, 0x01},
+	{0x3680, 0x0c},
+	{0x3681, 0x50},
+	{0x3682, 0x50},
+	{0x3683, 0xa9},
+	{0x3684, 0xa9},
+	{0x3709, 0x5f},
+	{0x3714, 0x28},
+	{0x371a, 0x3e},
+	{0x3737, 0x08},
+	{0x3738, 0xcc},
+	{0x3739, 0x20},
+	{0x373d, 0x26},
+	{0x3764, 0x20},
+	{0x3765, 0x20},
+	{0x37a1, 0x36},
+	{0x37a8, 0x3b},
+	{0x37ab, 0x31},
+	{0x37c2, 0x14},
+	{0x37c3, 0xf1},
+	{0x37c5, 0x00},
+	{0x37d8, 0x03},
+	{0x37d9, 0x0c},
+	{0x37da, 0xc2},
+	{0x37dc, 0x02},
+	{0x37e0, 0x00},
+	{0x37e1, 0x0a},
+	{0x37e2, 0x14},
+	{0x37e3, 0x08},
+	{0x37e4, 0x38},
+	{0x37e5, 0x03},
+	{0x37e6, 0x08},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0x00},
+	{0x3804, 0x10},
+	{0x3805, 0x9f},
+	{0x3806, 0x0c},
+	{0x3807, 0x5f},
+	{0x3808, 0x08},
+	{0x3809, 0x40},
+	{0x380a, 0x06},
+	{0x380b, 0x20},
+	{0x380c, 0x04},
+	{0x380d, 0x62},
+	{0x380e, 0x0c},
+	{0x380f, 0x8e},
+	{0x3811, 0x04},
+	{0x3813, 0x05},
+	{0x3814, 0x03},
+	{0x3815, 0x01},
+	{0x3816, 0x03},
+	{0x3817, 0x01},
+	{0x3820, 0xab},
+	{0x3821, 0x00},
+	{0x3822, 0xc2},
+	{0x3823, 0x18},
+	{0x3826, 0x04},
+	{0x3827, 0x90},
+	{0x3829, 0x07},
+	{0x3832, 0x00},
+	{0x3c80, 0x00},
+	{0x3c87, 0x01},
+	{0x3c8c, 0x19},
+	{0x3c8d, 0x1c},
+	{0x3c90, 0x00},
+	{0x3c91, 0x00},
+	{0x3c92, 0x00},
+	{0x3c93, 0x00},
+	{0x3c94, 0x40},
+	{0x3c95, 0x54},
+	{0x3c96, 0x34},
+	{0x3c97, 0x04},
+	{0x3c98, 0x00},
+	{0x3d8c, 0x73},
+	{0x3d8d, 0xc0},
+	{0x3f00, 0x0b},
+	{0x3f03, 0x00},
+	{0x4001, 0xe0},
+	{0x4008, 0x00},
+	{0x4009, 0x0d},
+	{0x4011, 0xf0},
+	{0x4017, 0x08},
+	{0x4050, 0x04},
+	{0x4051, 0x0b},
+	{0x4052, 0x00},
+	{0x4053, 0x80},
+	{0x4054, 0x00},
+	{0x4055, 0x80},
+	{0x4056, 0x00},
+	{0x4057, 0x80},
+	{0x4058, 0x00},
+	{0x4059, 0x80},
+	{0x405e, 0x20},
+	{0x4500, 0x07},
+	{0x4503, 0x00},
+	{0x450a, 0x04},
+	{0x4809, 0x04},
+	{0x480c, 0x12},
+	{0x481f, 0x30},
+	{0x4833, 0x10},
+	{0x4837, 0x1c},
+	{0x4902, 0x01},
+	{0x4d00, 0x03},
+	{0x4d01, 0xc9},
+	{0x4d02, 0xbc},
+	{0x4d03, 0xd7},
+	{0x4d04, 0xf0},
+	{0x4d05, 0xa2},
+	{0x5000, 0xfd},
+	{0x5001, 0x01},
+	{0x5040, 0x39},
+	{0x5041, 0x10},
+	{0x5042, 0x10},
+	{0x5043, 0x84},
+	{0x5044, 0x62},
+	{0x5180, 0x00},
+	{0x5181, 0x10},
+	{0x5182, 0x02},
+	{0x5183, 0x0f},
+	{0x5200, 0x1b},
+	{0x520b, 0x07},
+	{0x520c, 0x0f},
+	{0x5300, 0x04},
+	{0x5301, 0x0c},
+	{0x5302, 0x0c},
+	{0x5303, 0x0f},
+	{0x5304, 0x00},
+	{0x5305, 0x70},
+	{0x5306, 0x00},
+	{0x5307, 0x80},
+	{0x5308, 0x00},
+	{0x5309, 0xa5},
+	{0x530a, 0x00},
+	{0x530b, 0xd3},
+	{0x530c, 0x00},
+	{0x530d, 0xf0},
+	{0x530e, 0x01},
+	{0x530f, 0x10},
+	{0x5310, 0x01},
+	{0x5311, 0x20},
+	{0x5312, 0x01},
+	{0x5313, 0x20},
+	{0x5314, 0x01},
+	{0x5315, 0x20},
+	{0x5316, 0x08},
+	{0x5317, 0x08},
+	{0x5318, 0x10},
+	{0x5319, 0x88},
+	{0x531a, 0x88},
+	{0x531b, 0xa9},
+	{0x531c, 0xaa},
+	{0x531d, 0x0a},
+	{0x5405, 0x02},
+	{0x5406, 0x67},
+	{0x5407, 0x01},
+	{0x5408, 0x4a},
+};
+
+static const struct ov13858_reg mode_2112x1188_regs[] = {
+	{0x3013, 0x32},
+	{0x301b, 0xf0},
+	{0x301f, 0xd0},
+	{0x3106, 0x15},
+	{0x3107, 0x23},
+	{0x350a, 0x00},
+	{0x350e, 0x00},
+	{0x3510, 0x00},
+	{0x3511, 0x02},
+	{0x3512, 0x00},
+	{0x3600, 0x2b},
+	{0x3601, 0x52},
+	{0x3602, 0x60},
+	{0x3612, 0x05},
+	{0x3613, 0xa4},
+	{0x3620, 0x80},
+	{0x3621, 0x10},
+	{0x3622, 0x30},
+	{0x3624, 0x1c},
+	{0x3640, 0x10},
+	{0x3641, 0x70},
+	{0x3660, 0x04},
+	{0x3661, 0x80},
+	{0x3662, 0x10},
+	{0x3664, 0x73},
+	{0x3665, 0xa7},
+	{0x366e, 0xff},
+	{0x366f, 0xf4},
+	{0x3674, 0x00},
+	{0x3679, 0x0c},
+	{0x367f, 0x01},
+	{0x3680, 0x0c},
+	{0x3681, 0x50},
+	{0x3682, 0x50},
+	{0x3683, 0xa9},
+	{0x3684, 0xa9},
+	{0x3709, 0x5f},
+	{0x3714, 0x28},
+	{0x371a, 0x3e},
+	{0x3737, 0x08},
+	{0x3738, 0xcc},
+	{0x3739, 0x20},
+	{0x373d, 0x26},
+	{0x3764, 0x20},
+	{0x3765, 0x20},
+	{0x37a1, 0x36},
+	{0x37a8, 0x3b},
+	{0x37ab, 0x31},
+	{0x37c2, 0x14},
+	{0x37c3, 0xf1},
+	{0x37c5, 0x00},
+	{0x37d8, 0x03},
+	{0x37d9, 0x0c},
+	{0x37da, 0xc2},
+	{0x37dc, 0x02},
+	{0x37e0, 0x00},
+	{0x37e1, 0x0a},
+	{0x37e2, 0x14},
+	{0x37e3, 0x08},
+	{0x37e4, 0x38},
+	{0x37e5, 0x03},
+	{0x37e6, 0x08},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x01},
+	{0x3803, 0x84},
+	{0x3804, 0x10},
+	{0x3805, 0x9f},
+	{0x3806, 0x0a},
+	{0x3807, 0xd3},
+	{0x3808, 0x08},
+	{0x3809, 0x40},
+	{0x380a, 0x04},
+	{0x380b, 0xa4},
+	{0x380c, 0x04},
+	{0x380d, 0x62},
+	{0x380e, 0x0c},
+	{0x380f, 0x8e},
+	{0x3811, 0x08},
+	{0x3813, 0x03},
+	{0x3814, 0x03},
+	{0x3815, 0x01},
+	{0x3816, 0x03},
+	{0x3817, 0x01},
+	{0x3820, 0xab},
+	{0x3821, 0x00},
+	{0x3822, 0xc2},
+	{0x3823, 0x18},
+	{0x3826, 0x04},
+	{0x3827, 0x90},
+	{0x3829, 0x07},
+	{0x3832, 0x00},
+	{0x3c80, 0x00},
+	{0x3c87, 0x01},
+	{0x3c8c, 0x19},
+	{0x3c8d, 0x1c},
+	{0x3c90, 0x00},
+	{0x3c91, 0x00},
+	{0x3c92, 0x00},
+	{0x3c93, 0x00},
+	{0x3c94, 0x40},
+	{0x3c95, 0x54},
+	{0x3c96, 0x34},
+	{0x3c97, 0x04},
+	{0x3c98, 0x00},
+	{0x3d8c, 0x73},
+	{0x3d8d, 0xc0},
+	{0x3f00, 0x0b},
+	{0x3f03, 0x00},
+	{0x4001, 0xe0},
+	{0x4008, 0x00},
+	{0x4009, 0x0d},
+	{0x4011, 0xf0},
+	{0x4017, 0x08},
+	{0x4050, 0x04},
+	{0x4051, 0x0b},
+	{0x4052, 0x00},
+	{0x4053, 0x80},
+	{0x4054, 0x00},
+	{0x4055, 0x80},
+	{0x4056, 0x00},
+	{0x4057, 0x80},
+	{0x4058, 0x00},
+	{0x4059, 0x80},
+	{0x405e, 0x20},
+	{0x4500, 0x07},
+	{0x4503, 0x00},
+	{0x450a, 0x04},
+	{0x4809, 0x04},
+	{0x480c, 0x12},
+	{0x481f, 0x30},
+	{0x4833, 0x10},
+	{0x4837, 0x1c},
+	{0x4902, 0x01},
+	{0x4d00, 0x03},
+	{0x4d01, 0xc9},
+	{0x4d02, 0xbc},
+	{0x4d03, 0xd7},
+	{0x4d04, 0xf0},
+	{0x4d05, 0xa2},
+	{0x5000, 0xfd},
+	{0x5001, 0x01},
+	{0x5040, 0x39},
+	{0x5041, 0x10},
+	{0x5042, 0x10},
+	{0x5043, 0x84},
+	{0x5044, 0x62},
+	{0x5180, 0x00},
+	{0x5181, 0x10},
+	{0x5182, 0x02},
+	{0x5183, 0x0f},
+	{0x5200, 0x1b},
+	{0x520b, 0x07},
+	{0x520c, 0x0f},
+	{0x5300, 0x04},
+	{0x5301, 0x0c},
+	{0x5302, 0x0c},
+	{0x5303, 0x0f},
+	{0x5304, 0x00},
+	{0x5305, 0x70},
+	{0x5306, 0x00},
+	{0x5307, 0x80},
+	{0x5308, 0x00},
+	{0x5309, 0xa5},
+	{0x530a, 0x00},
+	{0x530b, 0xd3},
+	{0x530c, 0x00},
+	{0x530d, 0xf0},
+	{0x530e, 0x01},
+	{0x530f, 0x10},
+	{0x5310, 0x01},
+	{0x5311, 0x20},
+	{0x5312, 0x01},
+	{0x5313, 0x20},
+	{0x5314, 0x01},
+	{0x5315, 0x20},
+	{0x5316, 0x08},
+	{0x5317, 0x08},
+	{0x5318, 0x10},
+	{0x5319, 0x88},
+	{0x531a, 0x88},
+	{0x531b, 0xa9},
+	{0x531c, 0xaa},
+	{0x531d, 0x0a},
+	{0x5405, 0x02},
+	{0x5406, 0x67},
+	{0x5407, 0x01},
+	{0x5408, 0x4a},
+};
+
+static const struct ov13858_reg mode_1056x784_regs[] = {
+	{0x3013, 0x32},
+	{0x301b, 0xf0},
+	{0x301f, 0xd0},
+	{0x3106, 0x15},
+	{0x3107, 0x23},
+	{0x350a, 0x00},
+	{0x350e, 0x00},
+	{0x3510, 0x00},
+	{0x3511, 0x02},
+	{0x3512, 0x00},
+	{0x3600, 0x2b},
+	{0x3601, 0x52},
+	{0x3602, 0x60},
+	{0x3612, 0x05},
+	{0x3613, 0xa4},
+	{0x3620, 0x80},
+	{0x3621, 0x10},
+	{0x3622, 0x30},
+	{0x3624, 0x1c},
+	{0x3640, 0x10},
+	{0x3641, 0x70},
+	{0x3660, 0x04},
+	{0x3661, 0x80},
+	{0x3662, 0x08},
+	{0x3664, 0x73},
+	{0x3665, 0xa7},
+	{0x366e, 0xff},
+	{0x366f, 0xf4},
+	{0x3674, 0x00},
+	{0x3679, 0x0c},
+	{0x367f, 0x01},
+	{0x3680, 0x0c},
+	{0x3681, 0x50},
+	{0x3682, 0x50},
+	{0x3683, 0xa9},
+	{0x3684, 0xa9},
+	{0x3709, 0x5f},
+	{0x3714, 0x30},
+	{0x371a, 0x3e},
+	{0x3737, 0x08},
+	{0x3738, 0xcc},
+	{0x3739, 0x20},
+	{0x373d, 0x26},
+	{0x3764, 0x20},
+	{0x3765, 0x20},
+	{0x37a1, 0x36},
+	{0x37a8, 0x3b},
+	{0x37ab, 0x31},
+	{0x37c2, 0x2c},
+	{0x37c3, 0xf1},
+	{0x37c5, 0x00},
+	{0x37d8, 0x03},
+	{0x37d9, 0x06},
+	{0x37da, 0xc2},
+	{0x37dc, 0x02},
+	{0x37e0, 0x00},
+	{0x37e1, 0x0a},
+	{0x37e2, 0x14},
+	{0x37e3, 0x08},
+	{0x37e4, 0x36},
+	{0x37e5, 0x03},
+	{0x37e6, 0x08},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0x00},
+	{0x3804, 0x10},
+	{0x3805, 0x9f},
+	{0x3806, 0x0c},
+	{0x3807, 0x5f},
+	{0x3808, 0x04},
+	{0x3809, 0x20},
+	{0x380a, 0x03},
+	{0x380b, 0x10},
+	{0x380c, 0x04},
+	{0x380d, 0x62},
+	{0x380e, 0x0c},
+	{0x380f, 0x8e},
+	{0x3811, 0x04},
+	{0x3813, 0x05},
+	{0x3814, 0x07},
+	{0x3815, 0x01},
+	{0x3816, 0x07},
+	{0x3817, 0x01},
+	{0x3820, 0xac},
+	{0x3821, 0x00},
+	{0x3822, 0xc2},
+	{0x3823, 0x18},
+	{0x3826, 0x04},
+	{0x3827, 0x48},
+	{0x3829, 0x03},
+	{0x3832, 0x00},
+	{0x3c80, 0x00},
+	{0x3c87, 0x01},
+	{0x3c8c, 0x19},
+	{0x3c8d, 0x1c},
+	{0x3c90, 0x00},
+	{0x3c91, 0x00},
+	{0x3c92, 0x00},
+	{0x3c93, 0x00},
+	{0x3c94, 0x40},
+	{0x3c95, 0x54},
+	{0x3c96, 0x34},
+	{0x3c97, 0x04},
+	{0x3c98, 0x00},
+	{0x3d8c, 0x73},
+	{0x3d8d, 0xc0},
+	{0x3f00, 0x0b},
+	{0x3f03, 0x00},
+	{0x4001, 0xe0},
+	{0x4008, 0x00},
+	{0x4009, 0x05},
+	{0x4011, 0xf0},
+	{0x4017, 0x08},
+	{0x4050, 0x02},
+	{0x4051, 0x05},
+	{0x4052, 0x00},
+	{0x4053, 0x80},
+	{0x4054, 0x00},
+	{0x4055, 0x80},
+	{0x4056, 0x00},
+	{0x4057, 0x80},
+	{0x4058, 0x00},
+	{0x4059, 0x80},
+	{0x405e, 0x20},
+	{0x4500, 0x07},
+	{0x4503, 0x00},
+	{0x450a, 0x04},
+	{0x4809, 0x04},
+	{0x480c, 0x12},
+	{0x481f, 0x30},
+	{0x4833, 0x10},
+	{0x4837, 0x1e},
+	{0x4902, 0x02},
+	{0x4d00, 0x03},
+	{0x4d01, 0xc9},
+	{0x4d02, 0xbc},
+	{0x4d03, 0xd7},
+	{0x4d04, 0xf0},
+	{0x4d05, 0xa2},
+	{0x5000, 0xfd},
+	{0x5001, 0x01},
+	{0x5040, 0x39},
+	{0x5041, 0x10},
+	{0x5042, 0x10},
+	{0x5043, 0x84},
+	{0x5044, 0x62},
+	{0x5180, 0x00},
+	{0x5181, 0x10},
+	{0x5182, 0x02},
+	{0x5183, 0x0f},
+	{0x5200, 0x1b},
+	{0x520b, 0x07},
+	{0x520c, 0x0f},
+	{0x5300, 0x04},
+	{0x5301, 0x0c},
+	{0x5302, 0x0c},
+	{0x5303, 0x0f},
+	{0x5304, 0x00},
+	{0x5305, 0x70},
+	{0x5306, 0x00},
+	{0x5307, 0x80},
+	{0x5308, 0x00},
+	{0x5309, 0xa5},
+	{0x530a, 0x00},
+	{0x530b, 0xd3},
+	{0x530c, 0x00},
+	{0x530d, 0xf0},
+	{0x530e, 0x01},
+	{0x530f, 0x10},
+	{0x5310, 0x01},
+	{0x5311, 0x20},
+	{0x5312, 0x01},
+	{0x5313, 0x20},
+	{0x5314, 0x01},
+	{0x5315, 0x20},
+	{0x5316, 0x08},
+	{0x5317, 0x08},
+	{0x5318, 0x10},
+	{0x5319, 0x88},
+	{0x531a, 0x88},
+	{0x531b, 0xa9},
+	{0x531c, 0xaa},
+	{0x531d, 0x0a},
+	{0x5405, 0x02},
+	{0x5406, 0x67},
+	{0x5407, 0x01},
+	{0x5408, 0x4a},
+};
+
+static const char * const ov13858_test_pattern_menu[] = {
+	"Disabled",
+	"Vertical Color Bar Type 1",
+	"Vertical Color Bar Type 2",
+	"Vertical Color Bar Type 3",
+	"Vertical Color Bar Type 4"
+};
+
+/* Configurations for supported link frequencies */
+#define OV13858_NUM_OF_LINK_FREQS	2
+#define OV13858_LINK_FREQ_540MHZ	540000000ULL
+#define OV13858_LINK_FREQ_270MHZ	270000000ULL
+#define OV13858_LINK_FREQ_INDEX_0	0
+#define OV13858_LINK_FREQ_INDEX_1	1
+
+/*
+ * pixel_rate = link_freq * data-rate * nr_of_lanes / bits_per_sample
+ * data rate => double data rate; number of lanes => 4; bits per pixel => 10
+ */
+static u64 link_freq_to_pixel_rate(u64 f)
+{
+	f *= 2 * 4;
+	do_div(f, 10);
+
+	return f;
+}
+
+/* Menu items for LINK_FREQ V4L2 control */
+static const s64 link_freq_menu_items[OV13858_NUM_OF_LINK_FREQS] = {
+	OV13858_LINK_FREQ_540MHZ,
+	OV13858_LINK_FREQ_270MHZ
+};
+
+/* Link frequency configs */
+static const struct ov13858_link_freq_config
+			link_freq_configs[OV13858_NUM_OF_LINK_FREQS] = {
+	{
+		.pixels_per_line = OV13858_PPL_540MHZ,
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(mipi_data_rate_1080mbps),
+			.regs = mipi_data_rate_1080mbps,
+		}
+	},
+	{
+		.pixels_per_line = OV13858_PPL_270MHZ,
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(mipi_data_rate_540mbps),
+			.regs = mipi_data_rate_540mbps,
+		}
+	}
+};
+
+/* Mode configs */
+static const struct ov13858_mode supported_modes[] = {
+	{
+		.width = 4096,
+		.height = 3072,
+		.vts_def = OV13858_VTS_30FPS,
+		.vts_min = OV13858_VTS_30FPS,
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(mode_4096x3072_regs),
+			.regs = mode_4096x3072_regs,
+		},
+		.link_freq_index = OV13858_LINK_FREQ_INDEX_0,
+	},
+	{
+		.width = 4224,
+		.height = 3136,
+		.vts_def = OV13858_VTS_30FPS,
+		.vts_min = OV13858_VTS_30FPS,
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(mode_4224x3136_regs),
+			.regs = mode_4224x3136_regs,
+		},
+		.link_freq_index = OV13858_LINK_FREQ_INDEX_0,
+	},
+	{
+		.width = 2112,
+		.height = 1568,
+		.vts_def = OV13858_VTS_30FPS,
+		.vts_min = 1608,
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(mode_2112x1568_regs),
+			.regs = mode_2112x1568_regs,
+		},
+		.link_freq_index = OV13858_LINK_FREQ_INDEX_1,
+	},
+	{
+		.width = 2112,
+		.height = 1188,
+		.vts_def = OV13858_VTS_30FPS,
+		.vts_min = 1608,
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(mode_2112x1188_regs),
+			.regs = mode_2112x1188_regs,
+		},
+		.link_freq_index = OV13858_LINK_FREQ_INDEX_1,
+	},
+	{
+		.width = 1056,
+		.height = 784,
+		.vts_def = OV13858_VTS_30FPS,
+		.vts_min = 804,
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(mode_1056x784_regs),
+			.regs = mode_1056x784_regs,
+		},
+		.link_freq_index = OV13858_LINK_FREQ_INDEX_1,
+	}
+};
+
+struct ov13858 {
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+
+	struct v4l2_ctrl_handler ctrl_handler;
+	/* V4L2 Controls */
+	struct v4l2_ctrl *link_freq;
+	struct v4l2_ctrl *pixel_rate;
+	struct v4l2_ctrl *vblank;
+	struct v4l2_ctrl *hblank;
+	struct v4l2_ctrl *exposure;
+	struct v4l2_ctrl *hflip;
+	struct v4l2_ctrl *vflip;
+
+	/* Current mode */
+	const struct ov13858_mode *cur_mode;
+	/* Current format1 */
+	union ov13858_format1 fmt1;
+
+	/* Mutex for serialized access */
+	struct mutex mutex;
+
+	/* Streaming on/off */
+	bool streaming;
+};
+
+#define to_ov13858(_sd)	container_of(_sd, struct ov13858, sd)
+
+/* Read registers up to 4 at a time */
+static int ov13858_read_reg(struct ov13858 *ov13858, u16 reg, u32 len,
+			    u32 *val)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&ov13858->sd);
+	struct i2c_msg msgs[2];
+	u8 *data_be_p;
+	int ret;
+	__be32 data_be = 0;
+	__be16 reg_addr_be = cpu_to_be16(reg);
+
+	if (len > 4)
+		return -EINVAL;
+
+	data_be_p = (u8 *)&data_be;
+	/* Write register address */
+	msgs[0].addr = client->addr;
+	msgs[0].flags = 0;
+	msgs[0].len = 2;
+	msgs[0].buf = (u8 *)&reg_addr_be;
+
+	/* Read data from register */
+	msgs[1].addr = client->addr;
+	msgs[1].flags = I2C_M_RD;
+	msgs[1].len = len;
+	msgs[1].buf = &data_be_p[4 - len];
+
+	ret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));
+	if (ret != ARRAY_SIZE(msgs))
+		return -EIO;
+
+	*val = be32_to_cpu(data_be);
+
+	return 0;
+}
+
+/* Write registers up to 4 at a time */
+static int ov13858_write_reg(struct ov13858 *ov13858, u16 reg, u32 len,
+			     u32 __val)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&ov13858->sd);
+	int buf_i, val_i;
+	u8 buf[6], *val_p;
+	__be32 val;
+
+	if (len > 4)
+		return -EINVAL;
+
+	buf[0] = reg >> 8;
+	buf[1] = reg & 0xff;
+
+	val = cpu_to_be32(__val);
+	val_p = (u8 *)&val;
+	buf_i = 2;
+	val_i = 4 - len;
+
+	while (val_i < 4)
+		buf[buf_i++] = val_p[val_i++];
+
+	if (i2c_master_send(client, buf, len + 2) != len + 2)
+		return -EIO;
+
+	return 0;
+}
+
+/* Write a list of registers */
+static int ov13858_write_regs(struct ov13858 *ov13858,
+			      const struct ov13858_reg *regs, u32 len)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&ov13858->sd);
+	int ret;
+	u32 i;
+
+	for (i = 0; i < len; i++) {
+		ret = ov13858_write_reg(ov13858, regs[i].address, 1,
+					regs[i].val);
+		if (ret) {
+			dev_err_ratelimited(
+				&client->dev,
+				"Failed to write reg 0x%4.4x. error = %d\n",
+				regs[i].address, ret);
+
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int ov13858_write_reg_list(struct ov13858 *ov13858,
+				  const struct ov13858_reg_list *r_list)
+{
+	return ov13858_write_regs(ov13858, r_list->regs, r_list->num_of_regs);
+}
+
+/* Open sub-device */
+static int ov13858_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct ov13858 *ov13858 = to_ov13858(sd);
+	struct v4l2_mbus_framefmt *try_fmt = v4l2_subdev_get_try_format(sd,
+									fh->pad,
+									0);
+
+	mutex_lock(&ov13858->mutex);
+
+	/* Initialize try_fmt */
+	try_fmt->width = ov13858->cur_mode->width;
+	try_fmt->height = ov13858->cur_mode->height;
+	try_fmt->code = MEDIA_BUS_FMT_SGRBG10_1X10;
+	try_fmt->field = V4L2_FIELD_NONE;
+
+	/* No crop or compose */
+	mutex_unlock(&ov13858->mutex);
+
+	return 0;
+}
+
+static int ov13858_update_digital_gain(struct ov13858 *ov13858, u32 d_gain)
+{
+	int ret;
+
+	ret = ov13858_write_reg(ov13858, OV13858_REG_B_MWB_GAIN,
+				OV13858_REG_VALUE_16BIT, d_gain);
+	if (ret)
+		return ret;
+
+	ret = ov13858_write_reg(ov13858, OV13858_REG_G_MWB_GAIN,
+				OV13858_REG_VALUE_16BIT, d_gain);
+	if (ret)
+		return ret;
+
+	ret = ov13858_write_reg(ov13858, OV13858_REG_R_MWB_GAIN,
+				OV13858_REG_VALUE_16BIT, d_gain);
+
+	return ret;
+}
+
+static int ov13858_enable_test_pattern(struct ov13858 *ov13858, u32 pattern)
+{
+	int ret;
+	u32 val;
+
+	ret = ov13858_read_reg(ov13858, OV13858_REG_TEST_PATTERN,
+			       OV13858_REG_VALUE_08BIT, &val);
+	if (ret)
+		return ret;
+
+	if (pattern) {
+		val &= OV13858_TEST_PATTERN_MASK;
+		val |= (pattern - 1) | OV13858_TEST_PATTERN_ENABLE;
+	} else {
+		val &= ~OV13858_TEST_PATTERN_ENABLE;
+	}
+
+	return ov13858_write_reg(ov13858, OV13858_REG_TEST_PATTERN,
+				 OV13858_REG_VALUE_08BIT, val);
+}
+
+static int ov13858_set_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct ov13858 *ov13858 = container_of(ctrl->handler,
+					       struct ov13858, ctrl_handler);
+	struct i2c_client *client = v4l2_get_subdevdata(&ov13858->sd);
+	s64 max;
+	int ret;
+
+	/* Propagate change of current control to all related controls */
+	switch (ctrl->id) {
+	case V4L2_CID_VBLANK:
+		/* Update max exposure while meeting expected vblanking */
+		max = ov13858->cur_mode->height + ctrl->val - 8;
+		__v4l2_ctrl_modify_range(ov13858->exposure,
+					 ov13858->exposure->minimum,
+					 max, ov13858->exposure->step, max);
+		break;
+	}
+
+	/*
+	 * Applying V4L2 control value only happens
+	 * when power is up for streaming
+	 */
+	if (!pm_runtime_get_if_in_use(&client->dev))
+		return 0;
+
+	ret = 0;
+	switch (ctrl->id) {
+	case V4L2_CID_ANALOGUE_GAIN:
+		ret = ov13858_write_reg(ov13858, OV13858_REG_ANALOG_GAIN,
+					OV13858_REG_VALUE_16BIT, ctrl->val);
+		break;
+	case V4L2_CID_DIGITAL_GAIN:
+		ret = ov13858_update_digital_gain(ov13858, ctrl->val);
+		break;
+	case V4L2_CID_EXPOSURE:
+		ret = ov13858_write_reg(ov13858, OV13858_REG_EXPOSURE,
+					OV13858_REG_VALUE_24BIT,
+					ctrl->val << 4);
+		break;
+	case V4L2_CID_VBLANK:
+		/* Update VTS that meets expected vertical blanking */
+		ret = ov13858_write_reg(ov13858, OV13858_REG_VTS,
+					OV13858_REG_VALUE_16BIT,
+					ov13858->cur_mode->height
+					  + ctrl->val);
+		break;
+	case V4L2_CID_TEST_PATTERN:
+		ret = ov13858_enable_test_pattern(ov13858, ctrl->val);
+		break;
+	case V4L2_CID_HFLIP:
+		ov13858->fmt1.bits.hflip = !ctrl->val;
+		ret = ov13858_write_reg(ov13858, OV13858_REG_FORMAT1,
+					OV13858_REG_VALUE_08BIT, ov13858->fmt1.val);
+		break;
+	case V4L2_CID_VFLIP:
+		ov13858->fmt1.bits.vflip = ctrl->val;
+		ret = ov13858_write_reg(ov13858, OV13858_REG_FORMAT1,
+					OV13858_REG_VALUE_08BIT, ov13858->fmt1.val);
+		break;
+	default:
+		dev_info(&client->dev,
+			 "ctrl(id:0x%x,val:0x%x) is not handled\n",
+			 ctrl->id, ctrl->val);
+		break;
+	}
+
+	pm_runtime_put(&client->dev);
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops ov13858_ctrl_ops = {
+	.s_ctrl = ov13858_set_ctrl,
+};
+
+static int ov13858_enum_mbus_code(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_pad_config *cfg,
+				  struct v4l2_subdev_mbus_code_enum *code)
+{
+	/* Only one bayer order(GRBG) is supported */
+	if (code->index > 0)
+		return -EINVAL;
+
+	code->code = MEDIA_BUS_FMT_SGRBG10_1X10;
+
+	return 0;
+}
+
+static int ov13858_enum_frame_size(struct v4l2_subdev *sd,
+				   struct v4l2_subdev_pad_config *cfg,
+				   struct v4l2_subdev_frame_size_enum *fse)
+{
+	if (fse->index >= ARRAY_SIZE(supported_modes))
+		return -EINVAL;
+
+	if (fse->code != MEDIA_BUS_FMT_SGRBG10_1X10)
+		return -EINVAL;
+
+	fse->min_width = supported_modes[fse->index].width;
+	fse->max_width = fse->min_width;
+	fse->min_height = supported_modes[fse->index].height;
+	fse->max_height = fse->min_height;
+
+	return 0;
+}
+
+static void ov13858_update_pad_format(const struct ov13858_mode *mode,
+				      struct v4l2_subdev_format *fmt)
+{
+	fmt->format.width = mode->width;
+	fmt->format.height = mode->height;
+	fmt->format.code = MEDIA_BUS_FMT_SGRBG10_1X10;
+	fmt->format.field = V4L2_FIELD_NONE;
+}
+
+static int ov13858_do_get_pad_format(struct ov13858 *ov13858,
+				     struct v4l2_subdev_pad_config *cfg,
+				     struct v4l2_subdev_format *fmt)
+{
+	struct v4l2_mbus_framefmt *framefmt;
+	struct v4l2_subdev *sd = &ov13858->sd;
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {
+		framefmt = v4l2_subdev_get_try_format(sd, cfg, fmt->pad);
+		fmt->format = *framefmt;
+	} else {
+		ov13858_update_pad_format(ov13858->cur_mode, fmt);
+	}
+
+	return 0;
+}
+
+static int ov13858_get_pad_format(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_pad_config *cfg,
+				  struct v4l2_subdev_format *fmt)
+{
+	struct ov13858 *ov13858 = to_ov13858(sd);
+	int ret;
+
+	mutex_lock(&ov13858->mutex);
+	ret = ov13858_do_get_pad_format(ov13858, cfg, fmt);
+	mutex_unlock(&ov13858->mutex);
+
+	return ret;
+}
+
+static int
+ov13858_set_pad_format(struct v4l2_subdev *sd,
+		       struct v4l2_subdev_pad_config *cfg,
+		       struct v4l2_subdev_format *fmt)
+{
+	struct ov13858 *ov13858 = to_ov13858(sd);
+	const struct ov13858_mode *mode;
+	struct v4l2_mbus_framefmt *framefmt;
+	s32 vblank_def;
+	s32 vblank_min;
+	s64 h_blank;
+	s64 pixel_rate;
+	s64 link_freq;
+
+	mutex_lock(&ov13858->mutex);
+
+	/* Only one raw bayer(GRBG) order is supported */
+	if (fmt->format.code != MEDIA_BUS_FMT_SGRBG10_1X10)
+		fmt->format.code = MEDIA_BUS_FMT_SGRBG10_1X10;
+
+	mode = v4l2_find_nearest_size(supported_modes,
+				      ARRAY_SIZE(supported_modes),
+				      width, height,
+				      fmt->format.width, fmt->format.height);
+	ov13858_update_pad_format(mode, fmt);
+	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {
+		framefmt = v4l2_subdev_get_try_format(sd, cfg, fmt->pad);
+		*framefmt = fmt->format;
+	} else {
+		ov13858->cur_mode = mode;
+		__v4l2_ctrl_s_ctrl(ov13858->link_freq, mode->link_freq_index);
+		link_freq = link_freq_menu_items[mode->link_freq_index];
+		pixel_rate = link_freq_to_pixel_rate(link_freq);
+		__v4l2_ctrl_s_ctrl_int64(ov13858->pixel_rate, pixel_rate);
+
+		/* Update limits and set FPS to default */
+		vblank_def = ov13858->cur_mode->vts_def -
+			     ov13858->cur_mode->height;
+		vblank_min = ov13858->cur_mode->vts_min -
+			     ov13858->cur_mode->height;
+		__v4l2_ctrl_modify_range(
+			ov13858->vblank, vblank_min,
+			OV13858_VTS_MAX - ov13858->cur_mode->height, 1,
+			vblank_def);
+		__v4l2_ctrl_s_ctrl(ov13858->vblank, vblank_def);
+		h_blank =
+			link_freq_configs[mode->link_freq_index].pixels_per_line
+			 - ov13858->cur_mode->width;
+		__v4l2_ctrl_modify_range(ov13858->hblank, h_blank,
+					 h_blank, 1, h_blank);
+	}
+
+	mutex_unlock(&ov13858->mutex);
+
+	return 0;
+}
+
+static int ov13858_get_skip_frames(struct v4l2_subdev *sd, u32 *frames)
+{
+	*frames = OV13858_NUM_OF_SKIP_FRAMES;
+
+	return 0;
+}
+
+/* Start streaming */
+static int ov13858_start_streaming(struct ov13858 *ov13858)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&ov13858->sd);
+	const struct ov13858_reg_list *reg_list;
+	int ret, link_freq_index;
+
+	/* Get out of from software reset */
+	ret = ov13858_write_reg(ov13858, OV13858_REG_SOFTWARE_RST,
+				OV13858_REG_VALUE_08BIT, OV13858_SOFTWARE_RST);
+	if (ret) {
+		dev_err(&client->dev, "%s failed to set powerup registers\n",
+			__func__);
+		return ret;
+	}
+
+	/* Setup PLL */
+	link_freq_index = ov13858->cur_mode->link_freq_index;
+	reg_list = &link_freq_configs[link_freq_index].reg_list;
+	ret = ov13858_write_reg_list(ov13858, reg_list);
+	if (ret) {
+		dev_err(&client->dev, "%s failed to set plls\n", __func__);
+		return ret;
+	}
+
+	/* Apply default values of current mode */
+	reg_list = &ov13858->cur_mode->reg_list;
+	ret = ov13858_write_reg_list(ov13858, reg_list);
+	if (ret) {
+		dev_err(&client->dev, "%s failed to set mode\n", __func__);
+		return ret;
+	}
+
+	/* Apply customized values from user */
+	ret =  __v4l2_ctrl_handler_setup(ov13858->sd.ctrl_handler);
+	if (ret)
+		return ret;
+
+	return ov13858_write_reg(ov13858, OV13858_REG_MODE_SELECT,
+				 OV13858_REG_VALUE_08BIT,
+				 OV13858_MODE_STREAMING);
+}
+
+/* Stop streaming */
+static int ov13858_stop_streaming(struct ov13858 *ov13858)
+{
+	return ov13858_write_reg(ov13858, OV13858_REG_MODE_SELECT,
+				 OV13858_REG_VALUE_08BIT, OV13858_MODE_STANDBY);
+}
+
+static int ov13858_set_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct ov13858 *ov13858 = to_ov13858(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = 0;
+
+	mutex_lock(&ov13858->mutex);
+	if (ov13858->streaming == enable) {
+		mutex_unlock(&ov13858->mutex);
+		return 0;
+	}
+
+	if (enable) {
+		ret = pm_runtime_get_sync(&client->dev);
+		if (ret < 0) {
+			pm_runtime_put_noidle(&client->dev);
+			goto err_unlock;
+		}
+
+		/*
+		 * Apply default & customized values
+		 * and then start streaming.
+		 */
+		ret = ov13858_start_streaming(ov13858);
+		if (ret)
+			goto err_rpm_put;
+	} else {
+		ov13858_stop_streaming(ov13858);
+		pm_runtime_put(&client->dev);
+	}
+
+	ov13858->streaming = enable;
+	mutex_unlock(&ov13858->mutex);
+
+	return ret;
+
+err_rpm_put:
+	pm_runtime_put(&client->dev);
+err_unlock:
+	mutex_unlock(&ov13858->mutex);
+
+	return ret;
+}
+
+static int __maybe_unused ov13858_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov13858 *ov13858 = to_ov13858(sd);
+
+	if (ov13858->streaming)
+		ov13858_stop_streaming(ov13858);
+
+	return 0;
+}
+
+static int __maybe_unused ov13858_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov13858 *ov13858 = to_ov13858(sd);
+	int ret;
+
+	if (ov13858->streaming) {
+		ret = ov13858_start_streaming(ov13858);
+		if (ret)
+			goto error;
+	}
+
+	return 0;
+
+error:
+	ov13858_stop_streaming(ov13858);
+	ov13858->streaming = false;
+	return ret;
+}
+
+/* Verify chip ID */
+static int ov13858_identify_module(struct ov13858 *ov13858)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&ov13858->sd);
+	int ret;
+	u32 val;
+
+	ret = ov13858_read_reg(ov13858, OV13858_REG_CHIP_ID,
+			       OV13858_REG_VALUE_24BIT, &val);
+	if (ret)
+		return ret;
+
+	if (val != OV13858_CHIP_ID) {
+		dev_err(&client->dev, "chip id mismatch: %x!=%x\n",
+			OV13858_CHIP_ID, val);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static const struct v4l2_subdev_video_ops ov13858_video_ops = {
+	.s_stream = ov13858_set_stream,
+};
+
+static const struct v4l2_subdev_pad_ops ov13858_pad_ops = {
+	.enum_mbus_code = ov13858_enum_mbus_code,
+	.get_fmt = ov13858_get_pad_format,
+	.set_fmt = ov13858_set_pad_format,
+	.enum_frame_size = ov13858_enum_frame_size,
+};
+
+static const struct v4l2_subdev_sensor_ops ov13858_sensor_ops = {
+	.g_skip_frames = ov13858_get_skip_frames,
+};
+
+static const struct v4l2_subdev_ops ov13858_subdev_ops = {
+	.video = &ov13858_video_ops,
+	.pad = &ov13858_pad_ops,
+	.sensor = &ov13858_sensor_ops,
+};
+
+static const struct media_entity_operations ov13858_subdev_entity_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+static const struct v4l2_subdev_internal_ops ov13858_internal_ops = {
+	.open = ov13858_open,
+};
+
+/* Initialize control handlers */
+static int ov13858_init_controls(struct ov13858 *ov13858)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&ov13858->sd);
+	struct v4l2_fwnode_device_properties props;
+	struct v4l2_ctrl_handler *ctrl_hdlr;
+	s64 exposure_max;
+	s64 vblank_def;
+	s64 vblank_min;
+	s64 hblank;
+	s64 pixel_rate_min;
+	s64 pixel_rate_max;
+	const struct ov13858_mode *mode;
+	int ret;
+
+	ctrl_hdlr = &ov13858->ctrl_handler;
+	ret = v4l2_ctrl_handler_init(ctrl_hdlr, 10);
+	if (ret)
+		return ret;
+
+	mutex_init(&ov13858->mutex);
+	ctrl_hdlr->lock = &ov13858->mutex;
+	ov13858->link_freq = v4l2_ctrl_new_int_menu(ctrl_hdlr,
+				&ov13858_ctrl_ops,
+				V4L2_CID_LINK_FREQ,
+				OV13858_NUM_OF_LINK_FREQS - 1,
+				0,
+				link_freq_menu_items);
+	if (ov13858->link_freq)
+		ov13858->link_freq->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	pixel_rate_max = link_freq_to_pixel_rate(link_freq_menu_items[0]);
+	pixel_rate_min = link_freq_to_pixel_rate(link_freq_menu_items[1]);
+	/* By default, PIXEL_RATE is read only */
+	ov13858->pixel_rate = v4l2_ctrl_new_std(ctrl_hdlr, &ov13858_ctrl_ops,
+						V4L2_CID_PIXEL_RATE,
+						pixel_rate_min, pixel_rate_max,
+						1, pixel_rate_max);
+
+	mode = ov13858->cur_mode;
+	vblank_def = mode->vts_def - mode->height;
+	vblank_min = mode->vts_min - mode->height;
+	ov13858->vblank = v4l2_ctrl_new_std(
+				ctrl_hdlr, &ov13858_ctrl_ops, V4L2_CID_VBLANK,
+				vblank_min, OV13858_VTS_MAX - mode->height, 1,
+				vblank_def);
+
+	hblank = link_freq_configs[mode->link_freq_index].pixels_per_line -
+		 mode->width;
+	ov13858->hblank = v4l2_ctrl_new_std(
+				ctrl_hdlr, &ov13858_ctrl_ops, V4L2_CID_HBLANK,
+				hblank, hblank, 1, hblank);
+	if (ov13858->hblank)
+		ov13858->hblank->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	exposure_max = mode->vts_def - 8;
+	ov13858->exposure = v4l2_ctrl_new_std(
+				ctrl_hdlr, &ov13858_ctrl_ops,
+				V4L2_CID_EXPOSURE, OV13858_EXPOSURE_MIN,
+				exposure_max, OV13858_EXPOSURE_STEP,
+				OV13858_EXPOSURE_DEFAULT);
+
+	ov13858->hflip = v4l2_ctrl_new_std(
+				ctrl_hdlr, &ov13858_ctrl_ops,
+				V4L2_CID_HFLIP, 0, 1, 1, 0);
+
+	ov13858->vflip = v4l2_ctrl_new_std(
+				ctrl_hdlr, &ov13858_ctrl_ops,
+				V4L2_CID_VFLIP, 0, 1, 1, 0);
+	ov13858->fmt1.val =  OV13858_FORMAT1_DFT;
+
+	v4l2_ctrl_new_std(ctrl_hdlr, &ov13858_ctrl_ops, V4L2_CID_ANALOGUE_GAIN,
+			  OV13858_ANA_GAIN_MIN, OV13858_ANA_GAIN_MAX,
+			  OV13858_ANA_GAIN_STEP, OV13858_ANA_GAIN_DEFAULT);
+
+	/* Digital gain */
+	v4l2_ctrl_new_std(ctrl_hdlr, &ov13858_ctrl_ops, V4L2_CID_DIGITAL_GAIN,
+			  OV13858_DGTL_GAIN_MIN, OV13858_DGTL_GAIN_MAX,
+			  OV13858_DGTL_GAIN_STEP, OV13858_DGTL_GAIN_DEFAULT);
+
+	v4l2_ctrl_new_std_menu_items(ctrl_hdlr, &ov13858_ctrl_ops,
+				     V4L2_CID_TEST_PATTERN,
+				     ARRAY_SIZE(ov13858_test_pattern_menu) - 1,
+				     0, 0, ov13858_test_pattern_menu);
+	if (ctrl_hdlr->error) {
+		ret = ctrl_hdlr->error;
+		dev_err(&client->dev, "%s control init failed (%d)\n",
+			__func__, ret);
+		goto error;
+	}
+
+	ret = v4l2_fwnode_device_parse(&client->dev, &props);
+	if (ret)
+		goto error;
+
+	ret = v4l2_ctrl_new_fwnode_properties(ctrl_hdlr, &ov13858_ctrl_ops,
+					      &props);
+	if (ret)
+		goto error;
+
+	ov13858->sd.ctrl_handler = ctrl_hdlr;
+
+	return 0;
+
+error:
+	v4l2_ctrl_handler_free(ctrl_hdlr);
+	mutex_destroy(&ov13858->mutex);
+
+	return ret;
+}
+
+static void ov13858_free_controls(struct ov13858 *ov13858)
+{
+	v4l2_ctrl_handler_free(ov13858->sd.ctrl_handler);
+	mutex_destroy(&ov13858->mutex);
+}
+
+static int ov13858_probe(struct i2c_client *client,
+			 const struct i2c_device_id *devid)
+{
+	struct ov13858 *ov13858;
+	int ret;
+	u32 val = 0;
+
+	device_property_read_u32(&client->dev, "clock-frequency", &val);
+	if (val != 19200000)
+		return -EINVAL;
+
+	ov13858 = devm_kzalloc(&client->dev, sizeof(*ov13858), GFP_KERNEL);
+	if (!ov13858)
+		return -ENOMEM;
+
+	/* Initialize subdev */
+	v4l2_i2c_subdev_init(&ov13858->sd, client, &ov13858_subdev_ops);
+
+	/* Check module identity */
+	ret = ov13858_identify_module(ov13858);
+	if (ret) {
+		dev_err(&client->dev, "failed to find sensor: %d\n", ret);
+		return ret;
+	}
+
+	/* Set default mode to max resolution */
+	ov13858->cur_mode = &supported_modes[0];
+
+	ret = ov13858_init_controls(ov13858);
+	if (ret)
+		return ret;
+
+	/* Initialize subdev */
+	ov13858->sd.internal_ops = &ov13858_internal_ops;
+	ov13858->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	ov13858->sd.entity.ops = &ov13858_subdev_entity_ops;
+	ov13858->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;
+
+	/* Initialize source pad */
+	ov13858->pad.flags = MEDIA_PAD_FL_SOURCE;
+	ret = media_entity_pads_init(&ov13858->sd.entity, 1, &ov13858->pad);
+	if (ret) {
+		dev_err(&client->dev, "%s failed:%d\n", __func__, ret);
+		goto error_handler_free;
+	}
+
+	ret = v4l2_async_register_subdev_sensor_common(&ov13858->sd);
+	if (ret < 0)
+		goto error_media_entity;
+
+	/*
+	 * Device is already turned on by i2c-core with ACPI domain PM.
+	 * Enable runtime PM and turn off the device.
+	 */
+	pm_runtime_set_active(&client->dev);
+	pm_runtime_enable(&client->dev);
+	pm_runtime_idle(&client->dev);
+
+	return 0;
+
+error_media_entity:
+	media_entity_cleanup(&ov13858->sd.entity);
+
+error_handler_free:
+	ov13858_free_controls(ov13858);
+	dev_err(&client->dev, "%s failed:%d\n", __func__, ret);
+
+	return ret;
+}
+
+static void ov13858_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov13858 *ov13858 = to_ov13858(sd);
+
+	v4l2_async_unregister_subdev(sd);
+	media_entity_cleanup(&sd->entity);
+	ov13858_free_controls(ov13858);
+
+	pm_runtime_disable(&client->dev);
+
+}
+
+static const struct i2c_device_id ov13858_id_table[] = {
+	{"ov13858", 0},
+	{},
+};
+
+MODULE_DEVICE_TABLE(i2c, ov13858_id_table);
+
+static const struct dev_pm_ops ov13858_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(ov13858_suspend, ov13858_resume)
+};
+
+#ifdef CONFIG_ACPI
+static const struct acpi_device_id ov13858_acpi_ids[] = {
+	{"OVTID858"},
+	{ /* sentinel */ }
+};
+
+MODULE_DEVICE_TABLE(acpi, ov13858_acpi_ids);
+#endif
+
+static struct i2c_driver ov13858_i2c_driver = {
+	.driver = {
+		.name = "ov13858",
+		.pm = &ov13858_pm_ops,
+		.acpi_match_table = ACPI_PTR(ov13858_acpi_ids),
+	},
+	.probe = ov13858_probe,
+	.remove = ov13858_remove,
+	.id_table = ov13858_id_table,
+};
+
+module_i2c_driver(ov13858_i2c_driver);
+
+MODULE_AUTHOR("Kan, Chris <chris.kan@intel.com>");
+MODULE_AUTHOR("Rapolu, Chiranjeevi <chiranjeevi.rapolu@intel.com>");
+MODULE_AUTHOR("Yang, Hyungwoo <hyungwoo.yang@intel.com>");
+MODULE_DESCRIPTION("Omnivision ov13858 sensor driver");
+MODULE_LICENSE("GPL v2");
Index: b/drivers/media/i2c/ov8856.c
===================================================================
--- a/drivers/media/i2c/ov8856.c
+++ b/drivers/media/i2c/ov8856.c
@@ -1,15 +1,13 @@
 // SPDX-License-Identifier: GPL-2.0
-// Copyright (c) 2019 Intel Corporation.
+// Copyright (c) 2021-2022 Intel Corporation.
 
 #include <asm/unaligned.h>
 #include <linux/acpi.h>
-#include <linux/clk.h>
 #include <linux/delay.h>
-#include <linux/gpio/consumer.h>
 #include <linux/i2c.h>
 #include <linux/module.h>
 #include <linux/pm_runtime.h>
-#include <linux/regulator/consumer.h>
+#include <linux/version.h>
 #include <media/v4l2-ctrls.h>
 #include <media/v4l2-device.h>
 #include <media/v4l2-fwnode.h>
@@ -18,8 +16,10 @@
 #define OV8856_REG_VALUE_16BIT		2
 #define OV8856_REG_VALUE_24BIT		3
 
+#define OV8856_LINK_FREQ_360MHZ		360000000ULL
+#define OV8856_LINK_FREQ_264MHZ		264000000ULL
 #define OV8856_SCLK			144000000ULL
-#define OV8856_XVCLK_19_2		19200000
+#define OV8856_MCLK			19200000
 #define OV8856_DATA_LANES		4
 #define OV8856_RGB_DEPTH		10
 
@@ -30,19 +30,6 @@
 #define OV8856_MODE_STANDBY		0x00
 #define OV8856_MODE_STREAMING		0x01
 
-/* module revisions */
-#define OV8856_2A_MODULE		0x01
-#define OV8856_1B_MODULE		0x02
-
-/* the OTP read-out buffer is at 0x7000 and 0xf is the offset
- * of the byte in the OTP that means the module revision
- */
-#define OV8856_MODULE_REVISION		0x700f
-#define OV8856_OTP_MODE_CTRL		0x3d84
-#define OV8856_OTP_LOAD_CTRL		0x3d81
-#define OV8856_OTP_MODE_AUTO		0x00
-#define OV8856_OTP_LOAD_CTRL_ENABLE	BIT(0)
-
 /* vertical-timings from sensor */
 #define OV8856_REG_VTS			0x380e
 #define OV8856_VTS_MAX			0x7fff
@@ -63,7 +50,6 @@
 #define	OV8856_ANAL_GAIN_STEP		1
 
 /* Digital gain controls from sensor */
-#define OV8856_REG_DIGITAL_GAIN		0x350a
 #define OV8856_REG_MWB_R_GAIN		0x5019
 #define OV8856_REG_MWB_G_GAIN		0x501b
 #define OV8856_REG_MWB_B_GAIN		0x501d
@@ -77,40 +63,24 @@
 #define OV8856_TEST_PATTERN_ENABLE	BIT(7)
 #define OV8856_TEST_PATTERN_BAR_SHIFT	2
 
-#define NUM_REGS				7
-#define NUM_MODE_REGS				187
-#define NUM_MODE_REGS_2				200
-
 /* Flip Mirror Controls from sensor */
 #define OV8856_REG_FORMAT1			0x3820
 #define OV8856_REG_FORMAT2			0x3821
-#define OV8856_REG_FORMAT1_OP_1			BIT(1)
-#define OV8856_REG_FORMAT1_OP_2			BIT(2)
-#define OV8856_REG_FORMAT1_OP_3			BIT(6)
-#define OV8856_REG_FORMAT2_OP_1			BIT(1)
-#define OV8856_REG_FORMAT2_OP_2			BIT(2)
-#define OV8856_REG_FORMAT2_OP_3			BIT(6)
-#define OV8856_REG_FLIP_OPT_1			0x376b
-#define OV8856_REG_FLIP_OPT_2			0x5001
-#define OV8856_REG_FLIP_OPT_3			0x502e
-#define OV8856_REG_MIRROR_OPT_1			0x5004
-#define OV8856_REG_FLIP_OP_0			BIT(0)
-#define OV8856_REG_FLIP_OP_1			BIT(1)
-#define OV8856_REG_FLIP_OP_2			BIT(2)
-#define OV8856_REG_MIRROR_OP_1			BIT(1)
-#define OV8856_REG_MIRROR_OP_2			BIT(2)
+#define OV8856_REG_FORMAT1_A_VFLIP		BIT(1)
+#define OV8856_REG_FORMAT1_D_VFLIP		BIT(2)
+#define OV8856_REG_FORMAT1_VFLIP_BLC		BIT(6)
+#define OV8856_REG_FORMAT2_A_HFLIP		BIT(1)
+#define OV8856_REG_FORMAT2_D_HFLIP		BIT(2)
+#define OV8856_REG_ISP_CTRL_1			0x376b
+#define OV8856_REG_ISP_CTRL_2			0x5001
+#define OV8856_REG_ISP_CTRL_3			0x5004
+#define OV8856_REG_ISP_CTRL_4			0x502e
 
 #define to_ov8856(_sd)			container_of(_sd, struct ov8856, sd)
 
-static const char * const ov8856_supply_names[] = {
-	"dovdd",	/* Digital I/O power */
-	"avdd",		/* Analog power */
-	"dvdd",		/* Digital core power */
-};
-
 enum {
-	OV8856_MEDIA_BUS_FMT_SBGGR10_1X10,
-	OV8856_MEDIA_BUS_FMT_SGRBG10_1X10,
+	OV8856_LINK_FREQ_720MBPS,
+	OV8856_LINK_FREQ_528MBPS,
 };
 
 struct ov8856_reg {
@@ -148,1250 +118,462 @@ struct ov8856_mode {
 
 	/* Sensor register settings for this resolution */
 	const struct ov8856_reg_list reg_list;
-
-	/* Number of data lanes */
-	u8 data_lanes;
-
-	/* Default MEDIA_BUS_FMT for this mode */
-	u32 default_mbus_index;
-};
-
-struct ov8856_mipi_data_rates {
-	const struct ov8856_reg regs_0[NUM_REGS];
-	const struct ov8856_reg regs_1[NUM_REGS];
-};
-
-static const struct ov8856_mipi_data_rates mipi_data_rate_lane_2 = {
-	//mipi_data_rate_1440mbps
-	{
-		{0x0103, 0x01},
-		{0x0100, 0x00},
-		{0x0302, 0x43},
-		{0x0303, 0x00},
-		{0x030b, 0x02},
-		{0x030d, 0x4b},
-		{0x031e, 0x0c}
-	},
-	//mipi_data_rate_720mbps
-	{
-		{0x0103, 0x01},
-		{0x0100, 0x00},
-		{0x0302, 0x4b},
-		{0x0303, 0x01},
-		{0x030b, 0x02},
-		{0x030d, 0x4b},
-		{0x031e, 0x0c}
-	}
-};
-
-static const struct ov8856_mipi_data_rates mipi_data_rate_lane_4 = {
-	//mipi_data_rate_720mbps
-	{
-		{0x0103, 0x01},
-		{0x0100, 0x00},
-		{0x0302, 0x4b},
-		{0x0303, 0x01},
-		{0x030b, 0x02},
-		{0x030d, 0x4b},
-		{0x031e, 0x0c}
-	},
-	//mipi_data_rate_360mbps
-	{
-		{0x0103, 0x01},
-		{0x0100, 0x00},
-		{0x0302, 0x4b},
-		{0x0303, 0x03},
-		{0x030b, 0x02},
-		{0x030d, 0x4b},
-		{0x031e, 0x0c}
-	}
 };
 
-static const struct ov8856_reg lane_2_mode_3280x2464[] = {
-	/* 3280x2464 resolution */
-		{0x3000, 0x20},
-		{0x3003, 0x08},
-		{0x300e, 0x20},
-		{0x3010, 0x00},
-		{0x3015, 0x84},
-		{0x3018, 0x32},
-		{0x3021, 0x23},
-		{0x3033, 0x24},
-		{0x3500, 0x00},
-		{0x3501, 0x9a},
-		{0x3502, 0x20},
-		{0x3503, 0x08},
-		{0x3505, 0x83},
-		{0x3508, 0x01},
-		{0x3509, 0x80},
-		{0x350c, 0x00},
-		{0x350d, 0x80},
-		{0x350e, 0x04},
-		{0x350f, 0x00},
-		{0x3510, 0x00},
-		{0x3511, 0x02},
-		{0x3512, 0x00},
-		{0x3600, 0x72},
-		{0x3601, 0x40},
-		{0x3602, 0x30},
-		{0x3610, 0xc5},
-		{0x3611, 0x58},
-		{0x3612, 0x5c},
-		{0x3613, 0xca},
-		{0x3614, 0x50},
-		{0x3628, 0xff},
-		{0x3629, 0xff},
-		{0x362a, 0xff},
-		{0x3633, 0x10},
-		{0x3634, 0x10},
-		{0x3635, 0x10},
-		{0x3636, 0x10},
-		{0x3663, 0x08},
-		{0x3669, 0x34},
-		{0x366e, 0x10},
-		{0x3706, 0x86},
-		{0x370b, 0x7e},
-		{0x3714, 0x23},
-		{0x3730, 0x12},
-		{0x3733, 0x10},
-		{0x3764, 0x00},
-		{0x3765, 0x00},
-		{0x3769, 0x62},
-		{0x376a, 0x2a},
-		{0x376b, 0x30},
-		{0x3780, 0x00},
-		{0x3781, 0x24},
-		{0x3782, 0x00},
-		{0x3783, 0x23},
-		{0x3798, 0x2f},
-		{0x37a1, 0x60},
-		{0x37a8, 0x6a},
-		{0x37ab, 0x3f},
-		{0x37c2, 0x04},
-		{0x37c3, 0xf1},
-		{0x37c9, 0x80},
-		{0x37cb, 0x16},
-		{0x37cc, 0x16},
-		{0x37cd, 0x16},
-		{0x37ce, 0x16},
-		{0x3800, 0x00},
-		{0x3801, 0x00},
-		{0x3802, 0x00},
-		{0x3803, 0x06},
-		{0x3804, 0x0c},
-		{0x3805, 0xdf},
-		{0x3806, 0x09},
-		{0x3807, 0xa7},
-		{0x3808, 0x0c},
-		{0x3809, 0xd0},
-		{0x380a, 0x09},
-		{0x380b, 0xa0},
-		{0x380c, 0x07},
-		{0x380d, 0x88},
-		{0x380e, 0x09},
-		{0x380f, 0xb8},
-		{0x3810, 0x00},
-		{0x3811, 0x00},
-		{0x3812, 0x00},
-		{0x3813, 0x01},
-		{0x3814, 0x01},
-		{0x3815, 0x01},
-		{0x3816, 0x00},
-		{0x3817, 0x00},
-		{0x3818, 0x00},
-		{0x3819, 0x00},
-		{0x3820, 0x80},
-		{0x3821, 0x46},
-		{0x382a, 0x01},
-		{0x382b, 0x01},
-		{0x3830, 0x06},
-		{0x3836, 0x02},
-		{0x3837, 0x10},
-		{0x3862, 0x04},
-		{0x3863, 0x08},
-		{0x3cc0, 0x33},
-		{0x3d85, 0x14},
-		{0x3d8c, 0x73},
-		{0x3d8d, 0xde},
-		{0x4001, 0xe0},
-		{0x4003, 0x40},
-		{0x4008, 0x00},
-		{0x4009, 0x0b},
-		{0x400a, 0x00},
-		{0x400b, 0x84},
-		{0x400f, 0x80},
-		{0x4010, 0xf0},
-		{0x4011, 0xff},
-		{0x4012, 0x02},
-		{0x4013, 0x01},
-		{0x4014, 0x01},
-		{0x4015, 0x01},
-		{0x4042, 0x00},
-		{0x4043, 0x80},
-		{0x4044, 0x00},
-		{0x4045, 0x80},
-		{0x4046, 0x00},
-		{0x4047, 0x80},
-		{0x4048, 0x00},
-		{0x4049, 0x80},
-		{0x4041, 0x03},
-		{0x404c, 0x20},
-		{0x404d, 0x00},
-		{0x404e, 0x20},
-		{0x4203, 0x80},
-		{0x4307, 0x30},
-		{0x4317, 0x00},
-		{0x4503, 0x08},
-		{0x4601, 0x80},
-		{0x4800, 0x44},
-		{0x4816, 0x53},
-		{0x481b, 0x58},
-		{0x481f, 0x27},
-		{0x4837, 0x0c},
-		{0x483c, 0x0f},
-		{0x484b, 0x05},
-		{0x5000, 0x57},
-		{0x5001, 0x0a},
-		{0x5004, 0x06},
-		{0x502e, 0x03},
-		{0x5030, 0x41},
-		{0x5795, 0x02},
-		{0x5796, 0x20},
-		{0x5797, 0x20},
-		{0x5798, 0xd5},
-		{0x5799, 0xd5},
-		{0x579a, 0x00},
-		{0x579b, 0x50},
-		{0x579c, 0x00},
-		{0x579d, 0x2c},
-		{0x579e, 0x0c},
-		{0x579f, 0x40},
-		{0x57a0, 0x09},
-		{0x57a1, 0x40},
-		{0x5780, 0x14},
-		{0x5781, 0x0f},
-		{0x5782, 0x44},
-		{0x5783, 0x02},
-		{0x5784, 0x01},
-		{0x5785, 0x01},
-		{0x5786, 0x00},
-		{0x5787, 0x04},
-		{0x5788, 0x02},
-		{0x5789, 0x0f},
-		{0x578a, 0xfd},
-		{0x578b, 0xf5},
-		{0x578c, 0xf5},
-		{0x578d, 0x03},
-		{0x578e, 0x08},
-		{0x578f, 0x0c},
-		{0x5790, 0x08},
-		{0x5791, 0x04},
-		{0x5792, 0x00},
-		{0x5793, 0x52},
-		{0x5794, 0xa3},
-		{0x59f8, 0x3d},
-		{0x5a08, 0x02},
-		{0x5b00, 0x02},
-		{0x5b01, 0x10},
-		{0x5b02, 0x03},
-		{0x5b03, 0xcf},
-		{0x5b05, 0x6c},
-		{0x5e00, 0x00}
-};
-
-static const struct ov8856_reg lane_2_mode_1640x1232[] = {
-	/* 1640x1232 resolution */
-		{0x3000, 0x20},
-		{0x3003, 0x08},
-		{0x300e, 0x20},
-		{0x3010, 0x00},
-		{0x3015, 0x84},
-		{0x3018, 0x32},
-		{0x3021, 0x23},
-		{0x3033, 0x24},
-		{0x3500, 0x00},
-		{0x3501, 0x4c},
-		{0x3502, 0xe0},
-		{0x3503, 0x08},
-		{0x3505, 0x83},
-		{0x3508, 0x01},
-		{0x3509, 0x80},
-		{0x350c, 0x00},
-		{0x350d, 0x80},
-		{0x350e, 0x04},
-		{0x350f, 0x00},
-		{0x3510, 0x00},
-		{0x3511, 0x02},
-		{0x3512, 0x00},
-		{0x3600, 0x72},
-		{0x3601, 0x40},
-		{0x3602, 0x30},
-		{0x3610, 0xc5},
-		{0x3611, 0x58},
-		{0x3612, 0x5c},
-		{0x3613, 0xca},
-		{0x3614, 0x50},
-		{0x3628, 0xff},
-		{0x3629, 0xff},
-		{0x362a, 0xff},
-		{0x3633, 0x10},
-		{0x3634, 0x10},
-		{0x3635, 0x10},
-		{0x3636, 0x10},
-		{0x3663, 0x08},
-		{0x3669, 0x34},
-		{0x366e, 0x08},
-		{0x3706, 0x86},
-		{0x370b, 0x7e},
-		{0x3714, 0x27},
-		{0x3730, 0x12},
-		{0x3733, 0x10},
-		{0x3764, 0x00},
-		{0x3765, 0x00},
-		{0x3769, 0x62},
-		{0x376a, 0x2a},
-		{0x376b, 0x30},
-		{0x3780, 0x00},
-		{0x3781, 0x24},
-		{0x3782, 0x00},
-		{0x3783, 0x23},
-		{0x3798, 0x2f},
-		{0x37a1, 0x60},
-		{0x37a8, 0x6a},
-		{0x37ab, 0x3f},
-		{0x37c2, 0x14},
-		{0x37c3, 0xf1},
-		{0x37c9, 0x80},
-		{0x37cb, 0x16},
-		{0x37cc, 0x16},
-		{0x37cd, 0x16},
-		{0x37ce, 0x16},
-		{0x3800, 0x00},
-		{0x3801, 0x00},
-		{0x3802, 0x00},
-		{0x3803, 0x00},
-		{0x3804, 0x0c},
-		{0x3805, 0xdf},
-		{0x3806, 0x09},
-		{0x3807, 0xaf},
-		{0x3808, 0x06},
-		{0x3809, 0x68},
-		{0x380a, 0x04},
-		{0x380b, 0xd0},
-		{0x380c, 0x0c},
-		{0x380d, 0x60},
-		{0x380e, 0x05},
-		{0x380f, 0xea},
-		{0x3810, 0x00},
-		{0x3811, 0x04},
-		{0x3812, 0x00},
-		{0x3813, 0x05},
-		{0x3814, 0x03},
-		{0x3815, 0x01},
-		{0x3816, 0x00},
-		{0x3817, 0x00},
-		{0x3818, 0x00},
-		{0x3819, 0x00},
-		{0x3820, 0x90},
-		{0x3821, 0x67},
-		{0x382a, 0x03},
-		{0x382b, 0x01},
-		{0x3830, 0x06},
-		{0x3836, 0x02},
-		{0x3837, 0x10},
-		{0x3862, 0x04},
-		{0x3863, 0x08},
-		{0x3cc0, 0x33},
-		{0x3d85, 0x14},
-		{0x3d8c, 0x73},
-		{0x3d8d, 0xde},
-		{0x4001, 0xe0},
-		{0x4003, 0x40},
-		{0x4008, 0x00},
-		{0x4009, 0x05},
-		{0x400a, 0x00},
-		{0x400b, 0x84},
-		{0x400f, 0x80},
-		{0x4010, 0xf0},
-		{0x4011, 0xff},
-		{0x4012, 0x02},
-		{0x4013, 0x01},
-		{0x4014, 0x01},
-		{0x4015, 0x01},
-		{0x4042, 0x00},
-		{0x4043, 0x80},
-		{0x4044, 0x00},
-		{0x4045, 0x80},
-		{0x4046, 0x00},
-		{0x4047, 0x80},
-		{0x4048, 0x00},
-		{0x4049, 0x80},
-		{0x4041, 0x03},
-		{0x404c, 0x20},
-		{0x404d, 0x00},
-		{0x404e, 0x20},
-		{0x4203, 0x80},
-		{0x4307, 0x30},
-		{0x4317, 0x00},
-		{0x4503, 0x08},
-		{0x4601, 0x80},
-		{0x4800, 0x44},
-		{0x4816, 0x53},
-		{0x481b, 0x58},
-		{0x481f, 0x27},
-		{0x4837, 0x16},
-		{0x483c, 0x0f},
-		{0x484b, 0x05},
-		{0x5000, 0x57},
-		{0x5001, 0x0a},
-		{0x5004, 0x06},
-		{0x502e, 0x03},
-		{0x5030, 0x41},
-		{0x5795, 0x00},
-		{0x5796, 0x10},
-		{0x5797, 0x10},
-		{0x5798, 0x73},
-		{0x5799, 0x73},
-		{0x579a, 0x00},
-		{0x579b, 0x28},
-		{0x579c, 0x00},
-		{0x579d, 0x16},
-		{0x579e, 0x06},
-		{0x579f, 0x20},
-		{0x57a0, 0x04},
-		{0x57a1, 0xa0},
-		{0x5780, 0x14},
-		{0x5781, 0x0f},
-		{0x5782, 0x44},
-		{0x5783, 0x02},
-		{0x5784, 0x01},
-		{0x5785, 0x01},
-		{0x5786, 0x00},
-		{0x5787, 0x04},
-		{0x5788, 0x02},
-		{0x5789, 0x0f},
-		{0x578a, 0xfd},
-		{0x578b, 0xf5},
-		{0x578c, 0xf5},
-		{0x578d, 0x03},
-		{0x578e, 0x08},
-		{0x578f, 0x0c},
-		{0x5790, 0x08},
-		{0x5791, 0x04},
-		{0x5792, 0x00},
-		{0x5793, 0x52},
-		{0x5794, 0xa3},
-		{0x59f8, 0x3d},
-		{0x5a08, 0x02},
-		{0x5b00, 0x02},
-		{0x5b01, 0x10},
-		{0x5b02, 0x03},
-		{0x5b03, 0xcf},
-		{0x5b05, 0x6c},
-		{0x5e00, 0x00}
-};
-
-static const struct ov8856_reg lane_4_mode_3280x2464[] = {
-	/* 3280x2464 resolution */
-		{0x3000, 0x20},
-		{0x3003, 0x08},
-		{0x300e, 0x20},
-		{0x3010, 0x00},
-		{0x3015, 0x84},
-		{0x3018, 0x72},
-		{0x3021, 0x23},
-		{0x3033, 0x24},
-		{0x3500, 0x00},
-		{0x3501, 0x9a},
-		{0x3502, 0x20},
-		{0x3503, 0x08},
-		{0x3505, 0x83},
-		{0x3508, 0x01},
-		{0x3509, 0x80},
-		{0x350c, 0x00},
-		{0x350d, 0x80},
-		{0x350e, 0x04},
-		{0x350f, 0x00},
-		{0x3510, 0x00},
-		{0x3511, 0x02},
-		{0x3512, 0x00},
-		{0x3600, 0x72},
-		{0x3601, 0x40},
-		{0x3602, 0x30},
-		{0x3610, 0xc5},
-		{0x3611, 0x58},
-		{0x3612, 0x5c},
-		{0x3613, 0xca},
-		{0x3614, 0x20},
-		{0x3628, 0xff},
-		{0x3629, 0xff},
-		{0x362a, 0xff},
-		{0x3633, 0x10},
-		{0x3634, 0x10},
-		{0x3635, 0x10},
-		{0x3636, 0x10},
-		{0x3663, 0x08},
-		{0x3669, 0x34},
-		{0x366e, 0x10},
-		{0x3706, 0x86},
-		{0x370b, 0x7e},
-		{0x3714, 0x23},
-		{0x3730, 0x12},
-		{0x3733, 0x10},
-		{0x3764, 0x00},
-		{0x3765, 0x00},
-		{0x3769, 0x62},
-		{0x376a, 0x2a},
-		{0x376b, 0x30},
-		{0x3780, 0x00},
-		{0x3781, 0x24},
-		{0x3782, 0x00},
-		{0x3783, 0x23},
-		{0x3798, 0x2f},
-		{0x37a1, 0x60},
-		{0x37a8, 0x6a},
-		{0x37ab, 0x3f},
-		{0x37c2, 0x04},
-		{0x37c3, 0xf1},
-		{0x37c9, 0x80},
-		{0x37cb, 0x16},
-		{0x37cc, 0x16},
-		{0x37cd, 0x16},
-		{0x37ce, 0x16},
-		{0x3800, 0x00},
-		{0x3801, 0x00},
-		{0x3802, 0x00},
-		{0x3803, 0x06},
-		{0x3804, 0x0c},
-		{0x3805, 0xdf},
-		{0x3806, 0x09},
-		{0x3807, 0xa7},
-		{0x3808, 0x0c},
-		{0x3809, 0xd0},
-		{0x380a, 0x09},
-		{0x380b, 0xa0},
-		{0x380c, 0x07},
-		{0x380d, 0x88},
-		{0x380e, 0x09},
-		{0x380f, 0xb8},
-		{0x3810, 0x00},
-		{0x3811, 0x00},
-		{0x3812, 0x00},
-		{0x3813, 0x01},
-		{0x3814, 0x01},
-		{0x3815, 0x01},
-		{0x3816, 0x00},
-		{0x3817, 0x00},
-		{0x3818, 0x00},
-		{0x3819, 0x10},
-		{0x3820, 0x80},
-		{0x3821, 0x46},
-		{0x382a, 0x01},
-		{0x382b, 0x01},
-		{0x3830, 0x06},
-		{0x3836, 0x02},
-		{0x3862, 0x04},
-		{0x3863, 0x08},
-		{0x3cc0, 0x33},
-		{0x3d85, 0x17},
-		{0x3d8c, 0x73},
-		{0x3d8d, 0xde},
-		{0x4001, 0xe0},
-		{0x4003, 0x40},
-		{0x4008, 0x00},
-		{0x4009, 0x0b},
-		{0x400a, 0x00},
-		{0x400b, 0x84},
-		{0x400f, 0x80},
-		{0x4010, 0xf0},
-		{0x4011, 0xff},
-		{0x4012, 0x02},
-		{0x4013, 0x01},
-		{0x4014, 0x01},
-		{0x4015, 0x01},
-		{0x4042, 0x00},
-		{0x4043, 0x80},
-		{0x4044, 0x00},
-		{0x4045, 0x80},
-		{0x4046, 0x00},
-		{0x4047, 0x80},
-		{0x4048, 0x00},
-		{0x4049, 0x80},
-		{0x4041, 0x03},
-		{0x404c, 0x20},
-		{0x404d, 0x00},
-		{0x404e, 0x20},
-		{0x4203, 0x80},
-		{0x4307, 0x30},
-		{0x4317, 0x00},
-		{0x4503, 0x08},
-		{0x4601, 0x80},
-		{0x4800, 0x44},
-		{0x4816, 0x53},
-		{0x481b, 0x58},
-		{0x481f, 0x27},
-		{0x4837, 0x16},
-		{0x483c, 0x0f},
-		{0x484b, 0x05},
-		{0x5000, 0x57},
-		{0x5001, 0x0a},
-		{0x5004, 0x06},
-		{0x502e, 0x03},
-		{0x5030, 0x41},
-		{0x5780, 0x14},
-		{0x5781, 0x0f},
-		{0x5782, 0x44},
-		{0x5783, 0x02},
-		{0x5784, 0x01},
-		{0x5785, 0x01},
-		{0x5786, 0x00},
-		{0x5787, 0x04},
-		{0x5788, 0x02},
-		{0x5789, 0x0f},
-		{0x578a, 0xfd},
-		{0x578b, 0xf5},
-		{0x578c, 0xf5},
-		{0x578d, 0x03},
-		{0x578e, 0x08},
-		{0x578f, 0x0c},
-		{0x5790, 0x08},
-		{0x5791, 0x04},
-		{0x5792, 0x00},
-		{0x5793, 0x52},
-		{0x5794, 0xa3},
-		{0x5795, 0x02},
-		{0x5796, 0x20},
-		{0x5797, 0x20},
-		{0x5798, 0xd5},
-		{0x5799, 0xd5},
-		{0x579a, 0x00},
-		{0x579b, 0x50},
-		{0x579c, 0x00},
-		{0x579d, 0x2c},
-		{0x579e, 0x0c},
-		{0x579f, 0x40},
-		{0x57a0, 0x09},
-		{0x57a1, 0x40},
-		{0x59f8, 0x3d},
-		{0x5a08, 0x02},
-		{0x5b00, 0x02},
-		{0x5b01, 0x10},
-		{0x5b02, 0x03},
-		{0x5b03, 0xcf},
-		{0x5b05, 0x6c},
-		{0x5e00, 0x00}
-};
-
-static const struct ov8856_reg lane_4_mode_1640x1232[] = {
-	/* 1640x1232 resolution */
-		{0x3000, 0x20},
-		{0x3003, 0x08},
-		{0x300e, 0x20},
-		{0x3010, 0x00},
-		{0x3015, 0x84},
-		{0x3018, 0x72},
-		{0x3021, 0x23},
-		{0x3033, 0x24},
-		{0x3500, 0x00},
-		{0x3501, 0x4c},
-		{0x3502, 0xe0},
-		{0x3503, 0x08},
-		{0x3505, 0x83},
-		{0x3508, 0x01},
-		{0x3509, 0x80},
-		{0x350c, 0x00},
-		{0x350d, 0x80},
-		{0x350e, 0x04},
-		{0x350f, 0x00},
-		{0x3510, 0x00},
-		{0x3511, 0x02},
-		{0x3512, 0x00},
-		{0x3600, 0x72},
-		{0x3601, 0x40},
-		{0x3602, 0x30},
-		{0x3610, 0xc5},
-		{0x3611, 0x58},
-		{0x3612, 0x5c},
-		{0x3613, 0xca},
-		{0x3614, 0x20},
-		{0x3628, 0xff},
-		{0x3629, 0xff},
-		{0x362a, 0xff},
-		{0x3633, 0x10},
-		{0x3634, 0x10},
-		{0x3635, 0x10},
-		{0x3636, 0x10},
-		{0x3663, 0x08},
-		{0x3669, 0x34},
-		{0x366e, 0x08},
-		{0x3706, 0x86},
-		{0x370b, 0x7e},
-		{0x3714, 0x27},
-		{0x3730, 0x12},
-		{0x3733, 0x10},
-		{0x3764, 0x00},
-		{0x3765, 0x00},
-		{0x3769, 0x62},
-		{0x376a, 0x2a},
-		{0x376b, 0x30},
-		{0x3780, 0x00},
-		{0x3781, 0x24},
-		{0x3782, 0x00},
-		{0x3783, 0x23},
-		{0x3798, 0x2f},
-		{0x37a1, 0x60},
-		{0x37a8, 0x6a},
-		{0x37ab, 0x3f},
-		{0x37c2, 0x14},
-		{0x37c3, 0xf1},
-		{0x37c9, 0x80},
-		{0x37cb, 0x16},
-		{0x37cc, 0x16},
-		{0x37cd, 0x16},
-		{0x37ce, 0x16},
-		{0x3800, 0x00},
-		{0x3801, 0x00},
-		{0x3802, 0x00},
-		{0x3803, 0x00},
-		{0x3804, 0x0c},
-		{0x3805, 0xdf},
-		{0x3806, 0x09},
-		{0x3807, 0xaf},
-		{0x3808, 0x06},
-		{0x3809, 0x68},
-		{0x380a, 0x04},
-		{0x380b, 0xd0},
-		{0x380c, 0x0e},
-		{0x380d, 0xec},
-		{0x380e, 0x04},
-		{0x380f, 0xe8},
-		{0x3810, 0x00},
-		{0x3811, 0x04},
-		{0x3812, 0x00},
-		{0x3813, 0x05},
-		{0x3814, 0x03},
-		{0x3815, 0x01},
-		{0x3816, 0x00},
-		{0x3817, 0x00},
-		{0x3818, 0x00},
-		{0x3819, 0x10},
-		{0x3820, 0x90},
-		{0x3821, 0x67},
-		{0x382a, 0x03},
-		{0x382b, 0x01},
-		{0x3830, 0x06},
-		{0x3836, 0x02},
-		{0x3862, 0x04},
-		{0x3863, 0x08},
-		{0x3cc0, 0x33},
-		{0x3d85, 0x17},
-		{0x3d8c, 0x73},
-		{0x3d8d, 0xde},
-		{0x4001, 0xe0},
-		{0x4003, 0x40},
-		{0x4008, 0x00},
-		{0x4009, 0x05},
-		{0x400a, 0x00},
-		{0x400b, 0x84},
-		{0x400f, 0x80},
-		{0x4010, 0xf0},
-		{0x4011, 0xff},
-		{0x4012, 0x02},
-		{0x4013, 0x01},
-		{0x4014, 0x01},
-		{0x4015, 0x01},
-		{0x4042, 0x00},
-		{0x4043, 0x80},
-		{0x4044, 0x00},
-		{0x4045, 0x80},
-		{0x4046, 0x00},
-		{0x4047, 0x80},
-		{0x4048, 0x00},
-		{0x4049, 0x80},
-		{0x4041, 0x03},
-		{0x404c, 0x20},
-		{0x404d, 0x00},
-		{0x404e, 0x20},
-		{0x4203, 0x80},
-		{0x4307, 0x30},
-		{0x4317, 0x00},
-		{0x4503, 0x08},
-		{0x4601, 0x80},
-		{0x4800, 0x44},
-		{0x4816, 0x53},
-		{0x481b, 0x58},
-		{0x481f, 0x27},
-		{0x4837, 0x16},
-		{0x483c, 0x0f},
-		{0x484b, 0x05},
-		{0x5000, 0x57},
-		{0x5001, 0x0a},
-		{0x5004, 0x06},
-		{0x502e, 0x03},
-		{0x5030, 0x41},
-		{0x5780, 0x14},
-		{0x5781, 0x0f},
-		{0x5782, 0x44},
-		{0x5783, 0x02},
-		{0x5784, 0x01},
-		{0x5785, 0x01},
-		{0x5786, 0x00},
-		{0x5787, 0x04},
-		{0x5788, 0x02},
-		{0x5789, 0x0f},
-		{0x578a, 0xfd},
-		{0x578b, 0xf5},
-		{0x578c, 0xf5},
-		{0x578d, 0x03},
-		{0x578e, 0x08},
-		{0x578f, 0x0c},
-		{0x5790, 0x08},
-		{0x5791, 0x04},
-		{0x5792, 0x00},
-		{0x5793, 0x52},
-		{0x5794, 0xa3},
-		{0x5795, 0x00},
-		{0x5796, 0x10},
-		{0x5797, 0x10},
-		{0x5798, 0x73},
-		{0x5799, 0x73},
-		{0x579a, 0x00},
-		{0x579b, 0x28},
-		{0x579c, 0x00},
-		{0x579d, 0x16},
-		{0x579e, 0x06},
-		{0x579f, 0x20},
-		{0x57a0, 0x04},
-		{0x57a1, 0xa0},
-		{0x59f8, 0x3d},
-		{0x5a08, 0x02},
-		{0x5b00, 0x02},
-		{0x5b01, 0x10},
-		{0x5b02, 0x03},
-		{0x5b03, 0xcf},
-		{0x5b05, 0x6c},
-		{0x5e00, 0x00}
-};
-
-static const struct ov8856_reg lane_4_mode_3264x2448[] = {
-	/* 3264x2448 resolution */
-		{0x0103, 0x01},
-		{0x0302, 0x3c},
-		{0x0303, 0x01},
-		{0x031e, 0x0c},
-		{0x3000, 0x20},
-		{0x3003, 0x08},
-		{0x300e, 0x20},
-		{0x3010, 0x00},
-		{0x3015, 0x84},
-		{0x3018, 0x72},
-		{0x3021, 0x23},
-		{0x3033, 0x24},
-		{0x3500, 0x00},
-		{0x3501, 0x9a},
-		{0x3502, 0x20},
-		{0x3503, 0x08},
-		{0x3505, 0x83},
-		{0x3508, 0x01},
-		{0x3509, 0x80},
-		{0x350c, 0x00},
-		{0x350d, 0x80},
-		{0x350e, 0x04},
-		{0x350f, 0x00},
-		{0x3510, 0x00},
-		{0x3511, 0x02},
-		{0x3512, 0x00},
-		{0x3600, 0x72},
-		{0x3601, 0x40},
-		{0x3602, 0x30},
-		{0x3610, 0xc5},
-		{0x3611, 0x58},
-		{0x3612, 0x5c},
-		{0x3613, 0xca},
-		{0x3614, 0x60},
-		{0x3628, 0xff},
-		{0x3629, 0xff},
-		{0x362a, 0xff},
-		{0x3633, 0x10},
-		{0x3634, 0x10},
-		{0x3635, 0x10},
-		{0x3636, 0x10},
-		{0x3663, 0x08},
-		{0x3669, 0x34},
-		{0x366d, 0x00},
-		{0x366e, 0x10},
-		{0x3706, 0x86},
-		{0x370b, 0x7e},
-		{0x3714, 0x23},
-		{0x3730, 0x12},
-		{0x3733, 0x10},
-		{0x3764, 0x00},
-		{0x3765, 0x00},
-		{0x3769, 0x62},
-		{0x376a, 0x2a},
-		{0x376b, 0x30},
-		{0x3780, 0x00},
-		{0x3781, 0x24},
-		{0x3782, 0x00},
-		{0x3783, 0x23},
-		{0x3798, 0x2f},
-		{0x37a1, 0x60},
-		{0x37a8, 0x6a},
-		{0x37ab, 0x3f},
-		{0x37c2, 0x04},
-		{0x37c3, 0xf1},
-		{0x37c9, 0x80},
-		{0x37cb, 0x16},
-		{0x37cc, 0x16},
-		{0x37cd, 0x16},
-		{0x37ce, 0x16},
-		{0x3800, 0x00},
-		{0x3801, 0x00},
-		{0x3802, 0x00},
-		{0x3803, 0x0c},
-		{0x3804, 0x0c},
-		{0x3805, 0xdf},
-		{0x3806, 0x09},
-		{0x3807, 0xa3},
-		{0x3808, 0x0c},
-		{0x3809, 0xc0},
-		{0x380a, 0x09},
-		{0x380b, 0x90},
-		{0x380c, 0x07},
-		{0x380d, 0x8c},
-		{0x380e, 0x09},
-		{0x380f, 0xb2},
-		{0x3810, 0x00},
-		{0x3811, 0x04},
-		{0x3812, 0x00},
-		{0x3813, 0x02},
-		{0x3814, 0x01},
-		{0x3815, 0x01},
-		{0x3816, 0x00},
-		{0x3817, 0x00},
-		{0x3818, 0x00},
-		{0x3819, 0x10},
-		{0x3820, 0x80},
-		{0x3821, 0x46},
-		{0x382a, 0x01},
-		{0x382b, 0x01},
-		{0x3830, 0x06},
-		{0x3836, 0x02},
-		{0x3862, 0x04},
-		{0x3863, 0x08},
-		{0x3cc0, 0x33},
-		{0x3d85, 0x17},
-		{0x3d8c, 0x73},
-		{0x3d8d, 0xde},
-		{0x4001, 0xe0},
-		{0x4003, 0x40},
-		{0x4008, 0x00},
-		{0x4009, 0x0b},
-		{0x400a, 0x00},
-		{0x400b, 0x84},
-		{0x400f, 0x80},
-		{0x4010, 0xf0},
-		{0x4011, 0xff},
-		{0x4012, 0x02},
-		{0x4013, 0x01},
-		{0x4014, 0x01},
-		{0x4015, 0x01},
-		{0x4042, 0x00},
-		{0x4043, 0x80},
-		{0x4044, 0x00},
-		{0x4045, 0x80},
-		{0x4046, 0x00},
-		{0x4047, 0x80},
-		{0x4048, 0x00},
-		{0x4049, 0x80},
-		{0x4041, 0x03},
-		{0x404c, 0x20},
-		{0x404d, 0x00},
-		{0x404e, 0x20},
-		{0x4203, 0x80},
-		{0x4307, 0x30},
-		{0x4317, 0x00},
-		{0x4502, 0x50},
-		{0x4503, 0x08},
-		{0x4601, 0x80},
-		{0x4800, 0x44},
-		{0x4816, 0x53},
-		{0x481b, 0x50},
-		{0x481f, 0x27},
-		{0x4823, 0x3c},
-		{0x482b, 0x00},
-		{0x4831, 0x66},
-		{0x4837, 0x16},
-		{0x483c, 0x0f},
-		{0x484b, 0x05},
-		{0x5000, 0x77},
-		{0x5001, 0x0a},
-		{0x5003, 0xc8},
-		{0x5004, 0x04},
-		{0x5006, 0x00},
-		{0x5007, 0x00},
-		{0x502e, 0x03},
-		{0x5030, 0x41},
-		{0x5780, 0x14},
-		{0x5781, 0x0f},
-		{0x5782, 0x44},
-		{0x5783, 0x02},
-		{0x5784, 0x01},
-		{0x5785, 0x01},
-		{0x5786, 0x00},
-		{0x5787, 0x04},
-		{0x5788, 0x02},
-		{0x5789, 0x0f},
-		{0x578a, 0xfd},
-		{0x578b, 0xf5},
-		{0x578c, 0xf5},
-		{0x578d, 0x03},
-		{0x578e, 0x08},
-		{0x578f, 0x0c},
-		{0x5790, 0x08},
-		{0x5791, 0x04},
-		{0x5792, 0x00},
-		{0x5793, 0x52},
-		{0x5794, 0xa3},
-		{0x5795, 0x02},
-		{0x5796, 0x20},
-		{0x5797, 0x20},
-		{0x5798, 0xd5},
-		{0x5799, 0xd5},
-		{0x579a, 0x00},
-		{0x579b, 0x50},
-		{0x579c, 0x00},
-		{0x579d, 0x2c},
-		{0x579e, 0x0c},
-		{0x579f, 0x40},
-		{0x57a0, 0x09},
-		{0x57a1, 0x40},
-		{0x59f8, 0x3d},
-		{0x5a08, 0x02},
-		{0x5b00, 0x02},
-		{0x5b01, 0x10},
-		{0x5b02, 0x03},
-		{0x5b03, 0xcf},
-		{0x5b05, 0x6c},
-		{0x5e00, 0x00},
-		{0x5e10, 0xfc}
-};
-
-static const struct ov8856_reg lane_4_mode_1632x1224[] = {
-	/* 1632x1224 resolution */
-		{0x0103, 0x01},
-		{0x0302, 0x3c},
-		{0x0303, 0x01},
-		{0x031e, 0x0c},
-		{0x3000, 0x20},
-		{0x3003, 0x08},
-		{0x300e, 0x20},
-		{0x3010, 0x00},
-		{0x3015, 0x84},
-		{0x3018, 0x72},
-		{0x3021, 0x23},
-		{0x3033, 0x24},
-		{0x3500, 0x00},
-		{0x3501, 0x4c},
-		{0x3502, 0xe0},
-		{0x3503, 0x08},
-		{0x3505, 0x83},
-		{0x3508, 0x01},
-		{0x3509, 0x80},
-		{0x350c, 0x00},
-		{0x350d, 0x80},
-		{0x350e, 0x04},
-		{0x350f, 0x00},
-		{0x3510, 0x00},
-		{0x3511, 0x02},
-		{0x3512, 0x00},
-		{0x3600, 0x72},
-		{0x3601, 0x40},
-		{0x3602, 0x30},
-		{0x3610, 0xc5},
-		{0x3611, 0x58},
-		{0x3612, 0x5c},
-		{0x3613, 0xca},
-		{0x3614, 0x60},
-		{0x3628, 0xff},
-		{0x3629, 0xff},
-		{0x362a, 0xff},
-		{0x3633, 0x10},
-		{0x3634, 0x10},
-		{0x3635, 0x10},
-		{0x3636, 0x10},
-		{0x3663, 0x08},
-		{0x3669, 0x34},
-		{0x366d, 0x00},
-		{0x366e, 0x08},
-		{0x3706, 0x86},
-		{0x370b, 0x7e},
-		{0x3714, 0x27},
-		{0x3730, 0x12},
-		{0x3733, 0x10},
-		{0x3764, 0x00},
-		{0x3765, 0x00},
-		{0x3769, 0x62},
-		{0x376a, 0x2a},
-		{0x376b, 0x30},
-		{0x3780, 0x00},
-		{0x3781, 0x24},
-		{0x3782, 0x00},
-		{0x3783, 0x23},
-		{0x3798, 0x2f},
-		{0x37a1, 0x60},
-		{0x37a8, 0x6a},
-		{0x37ab, 0x3f},
-		{0x37c2, 0x14},
-		{0x37c3, 0xf1},
-		{0x37c9, 0x80},
-		{0x37cb, 0x16},
-		{0x37cc, 0x16},
-		{0x37cd, 0x16},
-		{0x37ce, 0x16},
-		{0x3800, 0x00},
-		{0x3801, 0x00},
-		{0x3802, 0x00},
-		{0x3803, 0x0c},
-		{0x3804, 0x0c},
-		{0x3805, 0xdf},
-		{0x3806, 0x09},
-		{0x3807, 0xa3},
-		{0x3808, 0x06},
-		{0x3809, 0x60},
-		{0x380a, 0x04},
-		{0x380b, 0xc8},
-		{0x380c, 0x07},
-		{0x380d, 0x8c},
-		{0x380e, 0x09},
-		{0x380f, 0xb2},
-		{0x3810, 0x00},
-		{0x3811, 0x02},
-		{0x3812, 0x00},
-		{0x3813, 0x02},
-		{0x3814, 0x03},
-		{0x3815, 0x01},
-		{0x3816, 0x00},
-		{0x3817, 0x00},
-		{0x3818, 0x00},
-		{0x3819, 0x10},
-		{0x3820, 0x80},
-		{0x3821, 0x47},
-		{0x382a, 0x03},
-		{0x382b, 0x01},
-		{0x3830, 0x06},
-		{0x3836, 0x02},
-		{0x3862, 0x04},
-		{0x3863, 0x08},
-		{0x3cc0, 0x33},
-		{0x3d85, 0x17},
-		{0x3d8c, 0x73},
-		{0x3d8d, 0xde},
-		{0x4001, 0xe0},
-		{0x4003, 0x40},
-		{0x4008, 0x00},
-		{0x4009, 0x05},
-		{0x400a, 0x00},
-		{0x400b, 0x84},
-		{0x400f, 0x80},
-		{0x4010, 0xf0},
-		{0x4011, 0xff},
-		{0x4012, 0x02},
-		{0x4013, 0x01},
-		{0x4014, 0x01},
-		{0x4015, 0x01},
-		{0x4042, 0x00},
-		{0x4043, 0x80},
-		{0x4044, 0x00},
-		{0x4045, 0x80},
-		{0x4046, 0x00},
-		{0x4047, 0x80},
-		{0x4048, 0x00},
-		{0x4049, 0x80},
-		{0x4041, 0x03},
-		{0x404c, 0x20},
-		{0x404d, 0x00},
-		{0x404e, 0x20},
-		{0x4203, 0x80},
-		{0x4307, 0x30},
-		{0x4317, 0x00},
-		{0x4502, 0x50},
-		{0x4503, 0x08},
-		{0x4601, 0x80},
-		{0x4800, 0x44},
-		{0x4816, 0x53},
-		{0x481b, 0x50},
-		{0x481f, 0x27},
-		{0x4823, 0x3c},
-		{0x482b, 0x00},
-		{0x4831, 0x66},
-		{0x4837, 0x16},
-		{0x483c, 0x0f},
-		{0x484b, 0x05},
-		{0x5000, 0x77},
-		{0x5001, 0x0a},
-		{0x5003, 0xc8},
-		{0x5004, 0x04},
-		{0x5006, 0x00},
-		{0x5007, 0x00},
-		{0x502e, 0x03},
-		{0x5030, 0x41},
-		{0x5795, 0x00},
-		{0x5796, 0x10},
-		{0x5797, 0x10},
-		{0x5798, 0x73},
-		{0x5799, 0x73},
-		{0x579a, 0x00},
-		{0x579b, 0x28},
-		{0x579c, 0x00},
-		{0x579d, 0x16},
-		{0x579e, 0x06},
-		{0x579f, 0x20},
-		{0x57a0, 0x04},
-		{0x57a1, 0xa0},
-		{0x5780, 0x14},
-		{0x5781, 0x0f},
-		{0x5782, 0x44},
-		{0x5783, 0x02},
-		{0x5784, 0x01},
-		{0x5785, 0x01},
-		{0x5786, 0x00},
-		{0x5787, 0x04},
-		{0x5788, 0x02},
-		{0x5789, 0x0f},
-		{0x578a, 0xfd},
-		{0x578b, 0xf5},
-		{0x578c, 0xf5},
-		{0x578d, 0x03},
-		{0x578e, 0x08},
-		{0x578f, 0x0c},
-		{0x5790, 0x08},
-		{0x5791, 0x04},
-		{0x5792, 0x00},
-		{0x5793, 0x52},
-		{0x5794, 0xa3},
-		{0x59f8, 0x3d},
-		{0x5a08, 0x02},
-		{0x5b00, 0x02},
-		{0x5b01, 0x10},
-		{0x5b02, 0x03},
-		{0x5b03, 0xcf},
-		{0x5b05, 0x6c},
-		{0x5e00, 0x00},
-		{0x5e10, 0xfc}
-};
-
-static const struct ov8856_reg mipi_data_mbus_sbggr10_1x10[] = {
+static const struct ov8856_reg mipi_data_rate_720mbps[] = {
+	{0x0103, 0x01},
+	{0x0100, 0x00},
+	{0x0302, 0x4b},
+	{0x0303, 0x01},
+	{0x030b, 0x02},
+	{0x030d, 0x4b},
+	{0x031e, 0x0c}
+};
+
+static const struct ov8856_reg mipi_data_rate_528mbps[] = {
+	{0x0103, 0x01},
+	{0x0100, 0x00},
+	{0x0302, 0x37},
+	{0x0303, 0x01},
+	{0x030b, 0x02},
+	{0x030d, 0x4b},
+	{0x031e, 0x0c}
+};
+
+static const struct ov8856_reg mode_3280x2464_regs[] = {
+	{0x0303, 0x01},
+	{0x031e, 0x0c},
+	{0x3000, 0x00},
+	{0x300e, 0x00},
+	{0x3010, 0x00},
+	{0x3015, 0x84},
+	{0x3018, 0x72},
+	{0x3021, 0x23},
+	{0x3033, 0x24},
+	{0x3500, 0x00},
+	{0x3501, 0x9c},
+	{0x3502, 0x80},
+	{0x3503, 0x08},
+	{0x3505, 0x83},
+	{0x3508, 0x01},
+	{0x3509, 0x80},
+	{0x350c, 0x00},
+	{0x350d, 0x80},
+	{0x350e, 0x04},
+	{0x350f, 0x00},
+	{0x3510, 0x00},
+	{0x3511, 0x02},
+	{0x3512, 0x00},
+	{0x3600, 0x72},
+	{0x3601, 0x40},
+	{0x3602, 0x30},
+	{0x3610, 0xc5},
+	{0x3611, 0x58},
+	{0x3612, 0x5c},
+	{0x3613, 0xca},
+	{0x3614, 0x20},
+	{0x3628, 0xff},
+	{0x3629, 0xff},
+	{0x362a, 0xff},
+	{0x3633, 0x10},
+	{0x3634, 0x10},
+	{0x3635, 0x10},
+	{0x3636, 0x10},
+	{0x3663, 0x08},
+	{0x3669, 0x34},
+	{0x366e, 0x10},
+	{0x3706, 0x86},
+	{0x370b, 0x7e},
+	{0x3714, 0x23},
+	{0x3730, 0x12},
+	{0x3733, 0x10},
+	{0x3764, 0x00},
+	{0x3765, 0x00},
+	{0x3769, 0x62},
+	{0x376a, 0x2a},
+	{0x376b, 0x30},
+	{0x3780, 0x00},
+	{0x3781, 0x24},
+	{0x3782, 0x00},
+	{0x3783, 0x23},
+	{0x3798, 0x2f},
+	{0x37a1, 0x60},
+	{0x37a8, 0x6a},
+	{0x37ab, 0x3f},
+	{0x37c2, 0x04},
+	{0x37c3, 0xf1},
+	{0x37c9, 0x80},
+	{0x37cb, 0x16},
+	{0x37cc, 0x16},
+	{0x37cd, 0x16},
+	{0x37ce, 0x16},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0x00},
+	{0x3804, 0x0c},
+	{0x3805, 0xdf},
+	{0x3806, 0x09},
+	{0x3807, 0xaf},
+	{0x3808, 0x0c},
+	{0x3809, 0xe0},
+	{0x380a, 0x09},
+	{0x380b, 0xb0},
+	{0x380c, 0x07},
+	{0x380d, 0x90},
+	{0x380e, 0x09},
+	{0x380f, 0xd8},
+	{0x3810, 0x00},
+	{0x3811, 0x00},
+	{0x3812, 0x00},
+	{0x3813, 0x00},
+	{0x3814, 0x01},
+	{0x3815, 0x01},
+	{0x3816, 0x00},
+	{0x3817, 0x00},
+	{0x3818, 0x00},
+	{0x3819, 0x00},
+	{0x3820, 0x80},
+	{0x3821, 0x46},
+	{0x382a, 0x01},
+	{0x382b, 0x01},
+	{0x3830, 0x06},
+	{0x3836, 0x02},
+	{0x3837, 0x10},
+	{0x3862, 0x04},
+	{0x3863, 0x08},
+	{0x3cc0, 0x33},
+	{0x3d85, 0x17},
+	{0x3d8c, 0x73},
+	{0x3d8d, 0xde},
+	{0x4001, 0xe0},
+	{0x4003, 0x40},
+	{0x4008, 0x00},
+	{0x4009, 0x0b},
+	{0x400a, 0x00},
+	{0x400b, 0x84},
+	{0x400f, 0x80},
+	{0x4010, 0xf0},
+	{0x4011, 0xff},
+	{0x4012, 0x02},
+	{0x4013, 0x01},
+	{0x4014, 0x01},
+	{0x4015, 0x01},
+	{0x4042, 0x00},
+	{0x4043, 0x80},
+	{0x4044, 0x00},
+	{0x4045, 0x80},
+	{0x4046, 0x00},
+	{0x4047, 0x80},
+	{0x4048, 0x00},
+	{0x4049, 0x80},
+	{0x4041, 0x03},
+	{0x404c, 0x20},
+	{0x404d, 0x00},
+	{0x404e, 0x20},
+	{0x4203, 0x80},
+	{0x4307, 0x30},
+	{0x4317, 0x00},
+	{0x4503, 0x08},
+	{0x4601, 0x80},
+	{0x4800, 0x44},
+	{0x4816, 0x53},
+	{0x481b, 0x58},
+	{0x481f, 0x27},
+	{0x4837, 0x16},
+	{0x483c, 0x0f},
+	{0x484b, 0x05},
+	{0x5000, 0x57},
+	{0x5001, 0x0a},
+	{0x5004, 0x00},
+	{0x502e, 0x03},
+	{0x5030, 0x41},
+	{0x5795, 0x02},
+	{0x5796, 0x20},
+	{0x5797, 0x20},
+	{0x5798, 0x2a},
+	{0x5799, 0x2a},
+	{0x579a, 0x00},
+	{0x579b, 0x50},
+	{0x579c, 0x00},
+	{0x579d, 0x38},
+	{0x579e, 0x0c},
+	{0x579f, 0x40},
+	{0x57a0, 0x09},
+	{0x57a1, 0x40},
+	{0x5780, 0x14},
+	{0x5781, 0x0f},
+	{0x5782, 0x44},
+	{0x5783, 0x02},
+	{0x5784, 0x01},
+	{0x5785, 0x01},
+	{0x5786, 0x00},
+	{0x5787, 0x04},
+	{0x5788, 0x02},
+	{0x5789, 0x0f},
+	{0x578a, 0xfd},
+	{0x578b, 0xf5},
+	{0x578c, 0xf5},
+	{0x578d, 0x03},
+	{0x578e, 0x08},
+	{0x578f, 0x0c},
+	{0x5790, 0x08},
+	{0x5791, 0x04},
+	{0x5792, 0x00},
+	{0x5793, 0x52},
+	{0x5794, 0xa3},
+	{0x59f8, 0x3d},
+	{0x5a08, 0x02},
+	{0x5b00, 0x02},
+	{0x5b01, 0x10},
+	{0x5b02, 0x03},
+	{0x5b03, 0xcf},
+	{0x5b05, 0x6c},
+	{0x5e00, 0x00},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0x06},
+	{0x3804, 0x0c},
+	{0x3805, 0xdf},
+	{0x3806, 0x09},
+	{0x3807, 0xa7},
+	{0x3808, 0x0c},
+	{0x3809, 0xd0},
+	{0x380a, 0x09},
+	{0x380b, 0xa0},
+	{0x380c, 0x07},
+	{0x380d, 0x8c},
+	{0x380e, 0x09},
+	{0x380f, 0xca},
+	{0x3810, 0x00},
+	{0x3811, 0x08},
+	{0x3812, 0x00},
+	{0x3813, 0x01}
+};
+
+static const struct ov8856_reg mode_1640x1232_regs[] = {
+	{0x3000, 0x00},
+	{0x300e, 0x00},
+	{0x3010, 0x00},
+	{0x3015, 0x84},
+	{0x3018, 0x72},
+	{0x3021, 0x23},
+	{0x3033, 0x24},
+	{0x3500, 0x00},
+	{0x3501, 0x4c},
+	{0x3502, 0xe0},
+	{0x3503, 0x08},
+	{0x3505, 0x83},
+	{0x3508, 0x01},
+	{0x3509, 0x80},
+	{0x350c, 0x00},
+	{0x350d, 0x80},
+	{0x350e, 0x04},
+	{0x350f, 0x00},
+	{0x3510, 0x00},
+	{0x3511, 0x02},
+	{0x3512, 0x00},
+	{0x3600, 0x72},
+	{0x3601, 0x40},
+	{0x3602, 0x30},
+	{0x3610, 0xc5},
+	{0x3611, 0x58},
+	{0x3612, 0x5c},
+	{0x3613, 0xca},
+	{0x3614, 0x20},
+	{0x3628, 0xff},
+	{0x3629, 0xff},
+	{0x362a, 0xff},
+	{0x3633, 0x10},
+	{0x3634, 0x10},
+	{0x3635, 0x10},
+	{0x3636, 0x10},
+	{0x3663, 0x08},
+	{0x3669, 0x34},
+	{0x366e, 0x08},
+	{0x3706, 0x86},
+	{0x370b, 0x7e},
+	{0x3714, 0x27},
+	{0x3730, 0x12},
+	{0x3733, 0x10},
+	{0x3764, 0x00},
+	{0x3765, 0x00},
+	{0x3769, 0x62},
+	{0x376a, 0x2a},
+	{0x376b, 0x30},
+	{0x3780, 0x00},
+	{0x3781, 0x24},
+	{0x3782, 0x00},
+	{0x3783, 0x23},
+	{0x3798, 0x2f},
+	{0x37a1, 0x60},
+	{0x37a8, 0x6a},
+	{0x37ab, 0x3f},
+	{0x37c2, 0x14},
+	{0x37c3, 0xf1},
+	{0x37c9, 0x80},
+	{0x37cb, 0x16},
+	{0x37cc, 0x16},
+	{0x37cd, 0x16},
+	{0x37ce, 0x16},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0x0c},
+	{0x3804, 0x0c},
+	{0x3805, 0xdf},
+	{0x3806, 0x09},
+	{0x3807, 0xa3},
+	{0x3808, 0x06},
+	{0x3809, 0x60},
+	{0x380a, 0x04},
+	{0x380b, 0xc8},
+	{0x380c, 0x07},
+	{0x380d, 0x8c},
+	{0x380e, 0x04},
+	{0x380f, 0xde},
+	{0x3810, 0x00},
+	{0x3811, 0x08},
+	{0x3812, 0x00},
 	{0x3813, 0x02},
-};
-
-static const struct ov8856_reg mipi_data_mbus_sgrbg10_1x10[] = {
-	{0x3813, 0x01},
-};
-
-static const u32 ov8856_mbus_codes[] = {
-	MEDIA_BUS_FMT_SBGGR10_1X10,
-	MEDIA_BUS_FMT_SGRBG10_1X10
+	{0x3814, 0x03},
+	{0x3815, 0x01},
+	{0x3816, 0x00},
+	{0x3817, 0x00},
+	{0x3818, 0x00},
+	{0x3819, 0x00},
+	{0x3820, 0x90},
+	{0x3821, 0x67},
+	{0x382a, 0x03},
+	{0x382b, 0x01},
+	{0x3830, 0x06},
+	{0x3836, 0x02},
+	{0x3837, 0x10},
+	{0x3862, 0x04},
+	{0x3863, 0x08},
+	{0x3cc0, 0x33},
+	{0x3d85, 0x17},
+	{0x3d8c, 0x73},
+	{0x3d8d, 0xde},
+	{0x4001, 0xe0},
+	{0x4003, 0x40},
+	{0x4008, 0x00},
+	{0x4009, 0x05},
+	{0x400a, 0x00},
+	{0x400b, 0x84},
+	{0x400f, 0x80},
+	{0x4010, 0xf0},
+	{0x4011, 0xff},
+	{0x4012, 0x02},
+	{0x4013, 0x01},
+	{0x4014, 0x01},
+	{0x4015, 0x01},
+	{0x4042, 0x00},
+	{0x4043, 0x80},
+	{0x4044, 0x00},
+	{0x4045, 0x80},
+	{0x4046, 0x00},
+	{0x4047, 0x80},
+	{0x4048, 0x00},
+	{0x4049, 0x80},
+	{0x4041, 0x03},
+	{0x404c, 0x20},
+	{0x404d, 0x00},
+	{0x404e, 0x20},
+	{0x4203, 0x80},
+	{0x4307, 0x30},
+	{0x4317, 0x00},
+	{0x4503, 0x08},
+	{0x4601, 0x80},
+	{0x4800, 0x44},
+	{0x4816, 0x53},
+	{0x481b, 0x58},
+	{0x481f, 0x27},
+	{0x4837, 0x16},
+	{0x483c, 0x0f},
+	{0x484b, 0x05},
+	{0x5000, 0x57},
+	{0x5001, 0x0a},
+	{0x5004, 0x04},
+	{0x502e, 0x03},
+	{0x5030, 0x41},
+	{0x5795, 0x00},
+	{0x5796, 0x10},
+	{0x5797, 0x10},
+	{0x5798, 0x73},
+	{0x5799, 0x73},
+	{0x579a, 0x00},
+	{0x579b, 0x28},
+	{0x579c, 0x00},
+	{0x579d, 0x16},
+	{0x579e, 0x06},
+	{0x579f, 0x20},
+	{0x57a0, 0x04},
+	{0x57a1, 0xa0},
+	{0x5780, 0x14},
+	{0x5781, 0x0f},
+	{0x5782, 0x44},
+	{0x5783, 0x02},
+	{0x5784, 0x01},
+	{0x5785, 0x01},
+	{0x5786, 0x00},
+	{0x5787, 0x04},
+	{0x5788, 0x02},
+	{0x5789, 0x0f},
+	{0x578a, 0xfd},
+	{0x578b, 0xf5},
+	{0x578c, 0xf5},
+	{0x578d, 0x03},
+	{0x578e, 0x08},
+	{0x578f, 0x0c},
+	{0x5790, 0x08},
+	{0x5791, 0x04},
+	{0x5792, 0x00},
+	{0x5793, 0x52},
+	{0x5794, 0xa3},
+	{0x59f8, 0x3d},
+	{0x5a08, 0x02},
+	{0x5b00, 0x02},
+	{0x5b01, 0x10},
+	{0x5b02, 0x03},
+	{0x5b03, 0xcf},
+	{0x5b05, 0x6c},
+	{0x5e00, 0x00},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0x00},
+	{0x3804, 0x0c},
+	{0x3805, 0xdf},
+	{0x3806, 0x09},
+	{0x3807, 0xaf},
+	{0x3808, 0x06},
+	{0x3809, 0x68},
+	{0x380a, 0x04},
+	{0x380b, 0xd0},
+	{0x380e, 0x04},
+	{0x380f, 0xee},
+	{0x3810, 0x00},
+	{0x3811, 0x04},
+	{0x3812, 0x00},
+	{0x3813, 0x05},
+	{0x3500, 0x00},
+	{0x3501, 0x4e},
+	{0x3502, 0x80},
+	{0x3820, 0x90},
+	{0x3821, 0x67},
+	{0x502e, 0x03},
+	{0x5001, 0x0a},
+	{0x5004, 0x04},
+	{0x376b, 0x30},
+	{0x030d, 0x4b},
+	{0x030b, 0x02},
+	{0x4837, 0x1e},
+	{0x380c, 0x0c},
+	{0x380d, 0x60},
+	{0x380e, 0x05},
+	{0x380f, 0xea}
 };
 
 static const char * const ov8856_test_pattern_menu[] = {
@@ -1402,14 +584,50 @@ static const char * const ov8856_test_pa
 	"Bottom-Top Darker Color Bar"
 };
 
-static const struct ov8856_reg_list bayer_offset_configs[] = {
-	[OV8856_MEDIA_BUS_FMT_SBGGR10_1X10] = {
-		.num_of_regs = ARRAY_SIZE(mipi_data_mbus_sbggr10_1x10),
-		.regs = mipi_data_mbus_sbggr10_1x10,
+static const s64 link_freq_menu_items[] = {
+	OV8856_LINK_FREQ_360MHZ,
+	OV8856_LINK_FREQ_264MHZ
+};
+
+static const struct ov8856_link_freq_config link_freq_configs[] = {
+	[OV8856_LINK_FREQ_720MBPS] = {
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(mipi_data_rate_720mbps),
+			.regs = mipi_data_rate_720mbps,
+		}
 	},
-	[OV8856_MEDIA_BUS_FMT_SGRBG10_1X10] = {
-		.num_of_regs = ARRAY_SIZE(mipi_data_mbus_sgrbg10_1x10),
-		.regs = mipi_data_mbus_sgrbg10_1x10,
+	[OV8856_LINK_FREQ_528MBPS] = {
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(mipi_data_rate_528mbps),
+			.regs = mipi_data_rate_528mbps,
+		}
+	}
+};
+
+static const struct ov8856_mode supported_modes[] = {
+	{
+		.width = 3280,
+		.height = 2464,
+		.hts = 1928,
+		.vts_def = 2488,
+		.vts_min = 2488,
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(mode_3280x2464_regs),
+			.regs = mode_3280x2464_regs,
+		},
+		.link_freq_index = OV8856_LINK_FREQ_720MBPS,
+	},
+	{
+		.width = 1640,
+		.height = 1232,
+		.hts = 3820,
+		.vts_def = 1256,
+		.vts_min = 1256,
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(mode_1640x1232_regs),
+			.regs = mode_1640x1232_regs,
+		},
+		.link_freq_index = OV8856_LINK_FREQ_528MBPS,
 	}
 };
 
@@ -1418,10 +636,6 @@ struct ov8856 {
 	struct media_pad pad;
 	struct v4l2_ctrl_handler ctrl_handler;
 
-	struct clk		*xvclk;
-	struct gpio_desc	*reset_gpio;
-	struct regulator_bulk_data supplies[ARRAY_SIZE(ov8856_supply_names)];
-
 	/* V4L2 Controls */
 	struct v4l2_ctrl *link_freq;
 	struct v4l2_ctrl *pixel_rate;
@@ -1432,190 +646,25 @@ struct ov8856 {
 	/* Current mode */
 	const struct ov8856_mode *cur_mode;
 
-	/* Application specified mbus format */
-	u32 cur_mbus_index;
-
 	/* To serialize asynchronus callbacks */
 	struct mutex mutex;
 
 	/* Streaming on/off */
 	bool streaming;
-
-	/* lanes index */
-	u8 nlanes;
-
-	const struct ov8856_lane_cfg *priv_lane;
-	u8 modes_size;
-
-	/* True if the device has been identified */
-	bool identified;
-};
-
-struct ov8856_lane_cfg {
-	const s64 link_freq_menu_items[2];
-	const struct ov8856_link_freq_config link_freq_configs[2];
-	const struct ov8856_mode supported_modes[4];
-};
-
-static const struct ov8856_lane_cfg lane_cfg_2 = {
-	{
-		720000000,
-		360000000,
-	},
-	{{
-		.reg_list = {
-			.num_of_regs =
-			ARRAY_SIZE(mipi_data_rate_lane_2.regs_0),
-			.regs = mipi_data_rate_lane_2.regs_0,
-		}
-	},
-	{
-		.reg_list = {
-			.num_of_regs =
-			ARRAY_SIZE(mipi_data_rate_lane_2.regs_1),
-			.regs = mipi_data_rate_lane_2.regs_1,
-		}
-	}},
-	{{
-		.width = 3280,
-		.height = 2464,
-		.hts = 1928,
-		.vts_def = 2488,
-		.vts_min = 2488,
-		.reg_list = {
-			.num_of_regs =
-			ARRAY_SIZE(lane_2_mode_3280x2464),
-			.regs = lane_2_mode_3280x2464,
-		},
-		.link_freq_index = 0,
-		.data_lanes = 2,
-		.default_mbus_index = OV8856_MEDIA_BUS_FMT_SGRBG10_1X10,
-	},
-	{
-		.width = 1640,
-		.height = 1232,
-		.hts = 3168,
-		.vts_def = 1514,
-		.vts_min = 1514,
-		.reg_list = {
-			.num_of_regs =
-			ARRAY_SIZE(lane_2_mode_1640x1232),
-			.regs = lane_2_mode_1640x1232,
-		},
-		.link_freq_index = 1,
-		.data_lanes = 2,
-		.default_mbus_index = OV8856_MEDIA_BUS_FMT_SGRBG10_1X10,
-	}}
 };
 
-static const struct ov8856_lane_cfg lane_cfg_4 = {
-		{
-			360000000,
-			180000000,
-		},
-		{{
-			.reg_list = {
-				.num_of_regs =
-				 ARRAY_SIZE(mipi_data_rate_lane_4.regs_0),
-				.regs = mipi_data_rate_lane_4.regs_0,
-			}
-		},
-		{
-			.reg_list = {
-				.num_of_regs =
-				 ARRAY_SIZE(mipi_data_rate_lane_4.regs_1),
-				.regs = mipi_data_rate_lane_4.regs_1,
-			}
-		}},
-		{{
-			.width = 3280,
-			.height = 2464,
-			.hts = 1928,
-			.vts_def = 2488,
-			.vts_min = 2488,
-			.reg_list = {
-				.num_of_regs =
-				 ARRAY_SIZE(lane_4_mode_3280x2464),
-				.regs = lane_4_mode_3280x2464,
-			},
-			.link_freq_index = 0,
-			.data_lanes = 4,
-			.default_mbus_index = OV8856_MEDIA_BUS_FMT_SGRBG10_1X10,
-		},
-		{
-			.width = 1640,
-			.height = 1232,
-			.hts = 3820,
-			.vts_def = 1256,
-			.vts_min = 1256,
-			.reg_list = {
-				.num_of_regs =
-				 ARRAY_SIZE(lane_4_mode_1640x1232),
-				.regs = lane_4_mode_1640x1232,
-			},
-			.link_freq_index = 1,
-			.data_lanes = 4,
-			.default_mbus_index = OV8856_MEDIA_BUS_FMT_SGRBG10_1X10,
-		},
-		{
-			.width = 3264,
-			.height = 2448,
-			.hts = 1932,
-			.vts_def = 2482,
-			.vts_min = 2482,
-			.reg_list = {
-				.num_of_regs =
-				 ARRAY_SIZE(lane_4_mode_3264x2448),
-				.regs = lane_4_mode_3264x2448,
-			},
-			.link_freq_index = 0,
-			.data_lanes = 4,
-			.default_mbus_index = OV8856_MEDIA_BUS_FMT_SBGGR10_1X10,
-		},
-		{
-			.width = 1632,
-			.height = 1224,
-			.hts = 1932,
-			.vts_def = 2482,
-			.vts_min = 2482,
-			.reg_list = {
-				.num_of_regs =
-				 ARRAY_SIZE(lane_4_mode_1632x1224),
-				.regs = lane_4_mode_1632x1224,
-			},
-			.link_freq_index = 1,
-			.data_lanes = 4,
-			.default_mbus_index = OV8856_MEDIA_BUS_FMT_SBGGR10_1X10,
-		}}
-};
-
-static unsigned int ov8856_modes_num(const struct ov8856 *ov8856)
-{
-	unsigned int i, count = 0;
-
-	for (i = 0; i < ARRAY_SIZE(ov8856->priv_lane->supported_modes); i++) {
-		if (ov8856->priv_lane->supported_modes[i].width == 0)
-			break;
-		count++;
-	}
-
-	return count;
-}
-
-static u64 to_rate(const s64 *link_freq_menu_items,
-		   u32 f_index, u8 nlanes)
+static u64 to_pixel_rate(u32 f_index)
 {
-	u64 pixel_rate = link_freq_menu_items[f_index] * 2 * nlanes;
+	u64 pixel_rate = link_freq_menu_items[f_index] * 2 * OV8856_DATA_LANES;
 
 	do_div(pixel_rate, OV8856_RGB_DEPTH);
 
 	return pixel_rate;
 }
 
-static u64 to_pixels_per_line(const s64 *link_freq_menu_items, u32 hts,
-			      u32 f_index, u8 nlanes)
+static u64 to_pixels_per_line(u32 hts, u32 f_index)
 {
-	u64 ppl = hts * to_rate(link_freq_menu_items, f_index, nlanes);
+	u64 ppl = hts * to_pixel_rate(f_index);
 
 	do_div(ppl, OV8856_SCLK);
 
@@ -1680,8 +729,8 @@ static int ov8856_write_reg_list(struct
 				       r_list->regs[i].val);
 		if (ret) {
 			dev_err_ratelimited(&client->dev,
-				    "failed to write reg 0x%4.4x. error = %d",
-				    r_list->regs[i].address, ret);
+					    "failed to W reg 0x%4.4x err %d",
+					    r_list->regs[i].address, ret);
 			return ret;
 		}
 	}
@@ -1689,34 +738,21 @@ static int ov8856_write_reg_list(struct
 	return 0;
 }
 
-static int ov8856_identify_module(struct ov8856 *ov8856)
+static int ov8856_update_digital_gain(struct ov8856 *ov8856, u32 d_gain)
 {
-	struct i2c_client *client = v4l2_get_subdevdata(&ov8856->sd);
 	int ret;
-	u32 val;
-
-	if (ov8856->identified)
-		return 0;
 
-	ret = ov8856_read_reg(ov8856, OV8856_REG_CHIP_ID,
-			      OV8856_REG_VALUE_24BIT, &val);
+	ret = ov8856_write_reg(ov8856, OV8856_REG_MWB_R_GAIN,
+			       OV8856_REG_VALUE_16BIT, d_gain);
 	if (ret)
 		return ret;
 
-	if (val != OV8856_CHIP_ID) {
-		dev_err(&client->dev, "chip id mismatch: %x!=%x",
-			OV8856_CHIP_ID, val);
-		return -ENXIO;
-	}
-
-	ov8856->identified = true;
-
-	return 0;
-}
+	ret = ov8856_write_reg(ov8856, OV8856_REG_MWB_G_GAIN,
+			       OV8856_REG_VALUE_16BIT, d_gain);
+	if (ret)
+		return ret;
 
-static int ov8856_update_digital_gain(struct ov8856 *ov8856, u32 d_gain)
-{
-	return ov8856_write_reg(ov8856, OV8856_REG_DIGITAL_GAIN,
+	return ov8856_write_reg(ov8856, OV8856_REG_MWB_B_GAIN,
 				OV8856_REG_VALUE_16BIT, d_gain);
 }
 
@@ -1730,93 +766,6 @@ static int ov8856_test_pattern(struct ov
 				OV8856_REG_VALUE_08BIT, pattern);
 }
 
-static int ov8856_set_ctrl_hflip(struct ov8856 *ov8856, u32 ctrl_val)
-{
-	int ret;
-	u32 val;
-
-	ret = ov8856_read_reg(ov8856, OV8856_REG_MIRROR_OPT_1,
-			      OV8856_REG_VALUE_08BIT, &val);
-	if (ret)
-		return ret;
-
-	ret = ov8856_write_reg(ov8856, OV8856_REG_MIRROR_OPT_1,
-			       OV8856_REG_VALUE_08BIT,
-			       ctrl_val ? val & ~OV8856_REG_MIRROR_OP_2 :
-			       val | OV8856_REG_MIRROR_OP_2);
-
-	if (ret)
-		return ret;
-
-	ret = ov8856_read_reg(ov8856, OV8856_REG_FORMAT2,
-			      OV8856_REG_VALUE_08BIT, &val);
-	if (ret)
-		return ret;
-
-	return ov8856_write_reg(ov8856, OV8856_REG_FORMAT2,
-				OV8856_REG_VALUE_08BIT,
-				ctrl_val ? val & ~OV8856_REG_FORMAT2_OP_1 &
-				~OV8856_REG_FORMAT2_OP_2 &
-				~OV8856_REG_FORMAT2_OP_3 :
-				val | OV8856_REG_FORMAT2_OP_1 |
-				OV8856_REG_FORMAT2_OP_2 |
-				OV8856_REG_FORMAT2_OP_3);
-}
-
-static int ov8856_set_ctrl_vflip(struct ov8856 *ov8856, u8 ctrl_val)
-{
-	int ret;
-	u32 val;
-
-	ret = ov8856_read_reg(ov8856, OV8856_REG_FLIP_OPT_1,
-			      OV8856_REG_VALUE_08BIT, &val);
-	if (ret)
-		return ret;
-
-	ret = ov8856_write_reg(ov8856, OV8856_REG_FLIP_OPT_1,
-			       OV8856_REG_VALUE_08BIT,
-			       ctrl_val ? val | OV8856_REG_FLIP_OP_1 |
-			       OV8856_REG_FLIP_OP_2 :
-			       val & ~OV8856_REG_FLIP_OP_1 &
-			       ~OV8856_REG_FLIP_OP_2);
-
-	ret = ov8856_read_reg(ov8856, OV8856_REG_FLIP_OPT_2,
-			      OV8856_REG_VALUE_08BIT, &val);
-	if (ret)
-		return ret;
-
-	ret = ov8856_write_reg(ov8856, OV8856_REG_FLIP_OPT_2,
-			       OV8856_REG_VALUE_08BIT,
-			       ctrl_val ? val | OV8856_REG_FLIP_OP_2 :
-			       val & ~OV8856_REG_FLIP_OP_2);
-
-	ret = ov8856_read_reg(ov8856, OV8856_REG_FLIP_OPT_3,
-			      OV8856_REG_VALUE_08BIT, &val);
-	if (ret)
-		return ret;
-
-	ret = ov8856_write_reg(ov8856, OV8856_REG_FLIP_OPT_3,
-			       OV8856_REG_VALUE_08BIT,
-			       ctrl_val ? val & ~OV8856_REG_FLIP_OP_0 &
-			       ~OV8856_REG_FLIP_OP_1 :
-			       val | OV8856_REG_FLIP_OP_0 |
-			       OV8856_REG_FLIP_OP_1);
-
-	ret = ov8856_read_reg(ov8856, OV8856_REG_FORMAT1,
-			      OV8856_REG_VALUE_08BIT, &val);
-	if (ret)
-		return ret;
-
-	return ov8856_write_reg(ov8856, OV8856_REG_FORMAT1,
-			       OV8856_REG_VALUE_08BIT,
-			       ctrl_val ? val | OV8856_REG_FORMAT1_OP_1 |
-			       OV8856_REG_FORMAT1_OP_3 |
-			       OV8856_REG_FORMAT1_OP_2 :
-			       val & ~OV8856_REG_FORMAT1_OP_1 &
-			       ~OV8856_REG_FORMAT1_OP_3 &
-			       ~OV8856_REG_FORMAT1_OP_2);
-}
-
 static int ov8856_set_ctrl(struct v4l2_ctrl *ctrl)
 {
 	struct ov8856 *ov8856 = container_of(ctrl->handler,
@@ -1866,14 +815,6 @@ static int ov8856_set_ctrl(struct v4l2_c
 		ret = ov8856_test_pattern(ov8856, ctrl->val);
 		break;
 
-	case V4L2_CID_HFLIP:
-		ret = ov8856_set_ctrl_hflip(ov8856, ctrl->val);
-		break;
-
-	case V4L2_CID_VFLIP:
-		ret = ov8856_set_ctrl_vflip(ov8856, ctrl->val);
-		break;
-
 	default:
 		ret = -EINVAL;
 		break;
@@ -1892,6 +833,7 @@ static int ov8856_init_controls(struct o
 {
 	struct v4l2_ctrl_handler *ctrl_hdlr;
 	s64 exposure_max, h_blank;
+	const struct ov8856_mode *cur_mode = ov8856->cur_mode;
 	int ret;
 
 	ctrl_hdlr = &ov8856->ctrl_handler;
@@ -1900,34 +842,29 @@ static int ov8856_init_controls(struct o
 		return ret;
 
 	ctrl_hdlr->lock = &ov8856->mutex;
-	ov8856->link_freq = v4l2_ctrl_new_int_menu(ctrl_hdlr, &ov8856_ctrl_ops,
-					   V4L2_CID_LINK_FREQ,
-					   ARRAY_SIZE
-					   (ov8856->priv_lane->link_freq_menu_items)
-					   - 1,
-					   0, ov8856->priv_lane->link_freq_menu_items);
+	ov8856->link_freq =
+	    v4l2_ctrl_new_int_menu(ctrl_hdlr, &ov8856_ctrl_ops,
+				   V4L2_CID_LINK_FREQ,
+				   ARRAY_SIZE(link_freq_menu_items) - 1,
+				   0, link_freq_menu_items);
 	if (ov8856->link_freq)
 		ov8856->link_freq->flags |= V4L2_CTRL_FLAG_READ_ONLY;
 
-	ov8856->pixel_rate = v4l2_ctrl_new_std(ctrl_hdlr, &ov8856_ctrl_ops,
-				       V4L2_CID_PIXEL_RATE, 0,
-				       to_rate(ov8856->priv_lane->link_freq_menu_items,
-					       0,
-					       ov8856->cur_mode->data_lanes), 1,
-				       to_rate(ov8856->priv_lane->link_freq_menu_items,
-					       0,
-					       ov8856->cur_mode->data_lanes));
-	ov8856->vblank = v4l2_ctrl_new_std(ctrl_hdlr, &ov8856_ctrl_ops,
-			  V4L2_CID_VBLANK,
-			  ov8856->cur_mode->vts_min - ov8856->cur_mode->height,
-			  OV8856_VTS_MAX - ov8856->cur_mode->height, 1,
-			  ov8856->cur_mode->vts_def -
-			  ov8856->cur_mode->height);
-	h_blank = to_pixels_per_line(ov8856->priv_lane->link_freq_menu_items,
-				     ov8856->cur_mode->hts,
-				     ov8856->cur_mode->link_freq_index,
-				     ov8856->cur_mode->data_lanes) -
-				     ov8856->cur_mode->width;
+	ov8856->pixel_rate =
+	    v4l2_ctrl_new_std(ctrl_hdlr, &ov8856_ctrl_ops,
+			      V4L2_CID_PIXEL_RATE, 0,
+			      to_pixel_rate(OV8856_LINK_FREQ_720MBPS),
+			      1, to_pixel_rate(OV8856_LINK_FREQ_720MBPS));
+	ov8856->vblank =
+	    v4l2_ctrl_new_std(ctrl_hdlr, &ov8856_ctrl_ops,
+			      V4L2_CID_VBLANK,
+			      cur_mode->vts_min - cur_mode->height,
+			      OV8856_VTS_MAX - cur_mode->height, 1,
+			      cur_mode->vts_def - cur_mode->height);
+	h_blank = to_pixels_per_line(cur_mode->hts,
+				     cur_mode->link_freq_index) -
+					cur_mode->width;
+
 	ov8856->hblank = v4l2_ctrl_new_std(ctrl_hdlr, &ov8856_ctrl_ops,
 					   V4L2_CID_HBLANK, h_blank, h_blank, 1,
 					   h_blank);
@@ -1940,7 +877,7 @@ static int ov8856_init_controls(struct o
 	v4l2_ctrl_new_std(ctrl_hdlr, &ov8856_ctrl_ops, V4L2_CID_DIGITAL_GAIN,
 			  OV8856_DGTL_GAIN_MIN, OV8856_DGTL_GAIN_MAX,
 			  OV8856_DGTL_GAIN_STEP, OV8856_DGTL_GAIN_DEFAULT);
-	exposure_max = ov8856->cur_mode->vts_def - OV8856_EXPOSURE_MAX_MARGIN;
+	exposure_max = cur_mode->vts_def - OV8856_EXPOSURE_MAX_MARGIN;
 	ov8856->exposure = v4l2_ctrl_new_std(ctrl_hdlr, &ov8856_ctrl_ops,
 					     V4L2_CID_EXPOSURE,
 					     OV8856_EXPOSURE_MIN, exposure_max,
@@ -1950,10 +887,6 @@ static int ov8856_init_controls(struct o
 				     V4L2_CID_TEST_PATTERN,
 				     ARRAY_SIZE(ov8856_test_pattern_menu) - 1,
 				     0, 0, ov8856_test_pattern_menu);
-	v4l2_ctrl_new_std(ctrl_hdlr, &ov8856_ctrl_ops,
-			  V4L2_CID_HFLIP, 0, 1, 1, 0);
-	v4l2_ctrl_new_std(ctrl_hdlr, &ov8856_ctrl_ops,
-			  V4L2_CID_VFLIP, 0, 1, 1, 0);
 	if (ctrl_hdlr->error)
 		return ctrl_hdlr->error;
 
@@ -1962,21 +895,12 @@ static int ov8856_init_controls(struct o
 	return 0;
 }
 
-static void ov8856_update_pad_format(struct ov8856 *ov8856,
-				     const struct ov8856_mode *mode,
+static void ov8856_update_pad_format(const struct ov8856_mode *mode,
 				     struct v4l2_mbus_framefmt *fmt)
 {
-	int index;
-
 	fmt->width = mode->width;
 	fmt->height = mode->height;
-	for (index = 0; index < ARRAY_SIZE(ov8856_mbus_codes); ++index)
-		if (ov8856_mbus_codes[index] == fmt->code)
-			break;
-	if (index == ARRAY_SIZE(ov8856_mbus_codes))
-		index = mode->default_mbus_index;
-	fmt->code = ov8856_mbus_codes[index];
-	ov8856->cur_mbus_index = index;
+	fmt->code = MEDIA_BUS_FMT_SGRBG10_1X10;
 	fmt->field = V4L2_FIELD_NONE;
 }
 
@@ -1986,13 +910,8 @@ static int ov8856_start_streaming(struct
 	const struct ov8856_reg_list *reg_list;
 	int link_freq_index, ret;
 
-	ret = ov8856_identify_module(ov8856);
-	if (ret)
-		return ret;
-
 	link_freq_index = ov8856->cur_mode->link_freq_index;
-	reg_list = &ov8856->priv_lane->link_freq_configs[link_freq_index].reg_list;
-
+	reg_list = &link_freq_configs[link_freq_index].reg_list;
 	ret = ov8856_write_reg_list(ov8856, reg_list);
 	if (ret) {
 		dev_err(&client->dev, "failed to set plls");
@@ -2006,13 +925,6 @@ static int ov8856_start_streaming(struct
 		return ret;
 	}
 
-	reg_list = &bayer_offset_configs[ov8856->cur_mbus_index];
-	ret = ov8856_write_reg_list(ov8856, reg_list);
-	if (ret) {
-		dev_err(&client->dev, "failed to set mbus format");
-		return ret;
-	}
-
 	ret = __v4l2_ctrl_handler_setup(ov8856->sd.ctrl_handler);
 	if (ret)
 		return ret;
@@ -2047,8 +959,9 @@ static int ov8856_set_stream(struct v4l2
 
 	mutex_lock(&ov8856->mutex);
 	if (enable) {
-		ret = pm_runtime_resume_and_get(&client->dev);
+		ret = pm_runtime_get_sync(&client->dev);
 		if (ret < 0) {
+			pm_runtime_put_noidle(&client->dev);
 			mutex_unlock(&ov8856->mutex);
 			return ret;
 		}
@@ -2070,67 +983,16 @@ static int ov8856_set_stream(struct v4l2
 	return ret;
 }
 
-static int __ov8856_power_on(struct ov8856 *ov8856)
-{
-	struct i2c_client *client = v4l2_get_subdevdata(&ov8856->sd);
-	int ret;
-
-	if (is_acpi_node(dev_fwnode(&client->dev)))
-		return 0;
-
-	ret = clk_prepare_enable(ov8856->xvclk);
-	if (ret < 0) {
-		dev_err(&client->dev, "failed to enable xvclk\n");
-		return ret;
-	}
-
-	if (ov8856->reset_gpio) {
-		gpiod_set_value_cansleep(ov8856->reset_gpio, 1);
-		usleep_range(1000, 2000);
-	}
-
-	ret = regulator_bulk_enable(ARRAY_SIZE(ov8856_supply_names),
-				    ov8856->supplies);
-	if (ret < 0) {
-		dev_err(&client->dev, "failed to enable regulators\n");
-		goto disable_clk;
-	}
-
-	gpiod_set_value_cansleep(ov8856->reset_gpio, 0);
-	usleep_range(1500, 1800);
-
-	return 0;
-
-disable_clk:
-	gpiod_set_value_cansleep(ov8856->reset_gpio, 1);
-	clk_disable_unprepare(ov8856->xvclk);
-
-	return ret;
-}
-
-static void __ov8856_power_off(struct ov8856 *ov8856)
-{
-	struct i2c_client *client = v4l2_get_subdevdata(&ov8856->sd);
-
-	if (is_acpi_node(dev_fwnode(&client->dev)))
-		return;
-
-	gpiod_set_value_cansleep(ov8856->reset_gpio, 1);
-	regulator_bulk_disable(ARRAY_SIZE(ov8856_supply_names),
-			       ov8856->supplies);
-	clk_disable_unprepare(ov8856->xvclk);
-}
-
 static int __maybe_unused ov8856_suspend(struct device *dev)
 {
-	struct v4l2_subdev *sd = dev_get_drvdata(dev);
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
 	struct ov8856 *ov8856 = to_ov8856(sd);
 
 	mutex_lock(&ov8856->mutex);
 	if (ov8856->streaming)
 		ov8856_stop_streaming(ov8856);
 
-	__ov8856_power_off(ov8856);
 	mutex_unlock(&ov8856->mutex);
 
 	return 0;
@@ -2138,13 +1000,12 @@ static int __maybe_unused ov8856_suspend
 
 static int __maybe_unused ov8856_resume(struct device *dev)
 {
-	struct v4l2_subdev *sd = dev_get_drvdata(dev);
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
 	struct ov8856 *ov8856 = to_ov8856(sd);
 	int ret;
 
 	mutex_lock(&ov8856->mutex);
-
-	__ov8856_power_on(ov8856);
 	if (ov8856->streaming) {
 		ret = ov8856_start_streaming(ov8856);
 		if (ret) {
@@ -2168,22 +1029,20 @@ static int ov8856_set_format(struct v4l2
 	const struct ov8856_mode *mode;
 	s32 vblank_def, h_blank;
 
-	mode = v4l2_find_nearest_size(ov8856->priv_lane->supported_modes,
-				      ov8856->modes_size,
-				      width, height, fmt->format.width,
+	mode = v4l2_find_nearest_size(supported_modes,
+				      ARRAY_SIZE(supported_modes), width,
+				      height, fmt->format.width,
 				      fmt->format.height);
 
 	mutex_lock(&ov8856->mutex);
-	ov8856_update_pad_format(ov8856, mode, &fmt->format);
+	ov8856_update_pad_format(mode, &fmt->format);
 	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {
 		*v4l2_subdev_get_try_format(sd, sd_state, fmt->pad) = fmt->format;
 	} else {
 		ov8856->cur_mode = mode;
 		__v4l2_ctrl_s_ctrl(ov8856->link_freq, mode->link_freq_index);
 		__v4l2_ctrl_s_ctrl_int64(ov8856->pixel_rate,
-					 to_rate(ov8856->priv_lane->link_freq_menu_items,
-						 mode->link_freq_index,
-						 ov8856->cur_mode->data_lanes));
+					 to_pixel_rate(mode->link_freq_index));
 
 		/* Update limits and set FPS to default */
 		vblank_def = mode->vts_def - mode->height;
@@ -2192,11 +1051,8 @@ static int ov8856_set_format(struct v4l2
 					 OV8856_VTS_MAX - mode->height, 1,
 					 vblank_def);
 		__v4l2_ctrl_s_ctrl(ov8856->vblank, vblank_def);
-		h_blank = to_pixels_per_line(ov8856->priv_lane->link_freq_menu_items,
-					     mode->hts,
-					     mode->link_freq_index,
-					     ov8856->cur_mode->data_lanes)
-					     - mode->width;
+		h_blank = to_pixels_per_line(mode->hts, mode->link_freq_index) -
+			  mode->width;
 		__v4l2_ctrl_modify_range(ov8856->hblank, h_blank, h_blank, 1,
 					 h_blank);
 	}
@@ -2215,10 +1071,9 @@ static int ov8856_get_format(struct v4l2
 	mutex_lock(&ov8856->mutex);
 	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY)
 		fmt->format = *v4l2_subdev_get_try_format(&ov8856->sd,
-							  sd_state,
-							  fmt->pad);
+							  sd_state, fmt->pad);
 	else
-		ov8856_update_pad_format(ov8856, ov8856->cur_mode, &fmt->format);
+		ov8856_update_pad_format(ov8856->cur_mode, &fmt->format);
 
 	mutex_unlock(&ov8856->mutex);
 
@@ -2229,10 +1084,11 @@ static int ov8856_enum_mbus_code(struct
 				 struct v4l2_subdev_state *sd_state,
 				 struct v4l2_subdev_mbus_code_enum *code)
 {
-	if (code->index >= ARRAY_SIZE(ov8856_mbus_codes))
+	/* Only one bayer order GRBG is supported */
+	if (code->index > 0)
 		return -EINVAL;
 
-	code->code = ov8856_mbus_codes[code->index];
+	code->code = MEDIA_BUS_FMT_SGRBG10_1X10;
 
 	return 0;
 }
@@ -2241,21 +1097,15 @@ static int ov8856_enum_frame_size(struct
 				  struct v4l2_subdev_state *sd_state,
 				  struct v4l2_subdev_frame_size_enum *fse)
 {
-	struct ov8856 *ov8856 = to_ov8856(sd);
-	int index;
-
-	if (fse->index >= ov8856->modes_size)
+	if (fse->index >= ARRAY_SIZE(supported_modes))
 		return -EINVAL;
 
-	for (index = 0; index < ARRAY_SIZE(ov8856_mbus_codes); ++index)
-		if (fse->code == ov8856_mbus_codes[index])
-			break;
-	if (index == ARRAY_SIZE(ov8856_mbus_codes))
+	if (fse->code != MEDIA_BUS_FMT_SGRBG10_1X10)
 		return -EINVAL;
 
-	fse->min_width = ov8856->priv_lane->supported_modes[fse->index].width;
+	fse->min_width = supported_modes[fse->index].width;
 	fse->max_width = fse->min_width;
-	fse->min_height = ov8856->priv_lane->supported_modes[fse->index].height;
+	fse->min_height = supported_modes[fse->index].height;
 	fse->max_height = fse->min_height;
 
 	return 0;
@@ -2266,7 +1116,7 @@ static int ov8856_open(struct v4l2_subde
 	struct ov8856 *ov8856 = to_ov8856(sd);
 
 	mutex_lock(&ov8856->mutex);
-	ov8856_update_pad_format(ov8856, &ov8856->priv_lane->supported_modes[0],
+	ov8856_update_pad_format(&supported_modes[0],
 				 v4l2_subdev_get_try_format(sd, fh->state, 0));
 	mutex_unlock(&ov8856->mutex);
 
@@ -2297,107 +1147,24 @@ static const struct v4l2_subdev_internal
 	.open = ov8856_open,
 };
 
-
-static int ov8856_get_hwcfg(struct ov8856 *ov8856, struct device *dev)
+static int ov8856_identify_module(struct ov8856 *ov8856)
 {
-	struct fwnode_handle *ep;
-	struct fwnode_handle *fwnode = dev_fwnode(dev);
-	struct v4l2_fwnode_endpoint bus_cfg = {
-		.bus_type = V4L2_MBUS_CSI2_DPHY
-	};
-	u32 xvclk_rate;
+	struct i2c_client *client = v4l2_get_subdevdata(&ov8856->sd);
 	int ret;
-	unsigned int i, j;
-
-	if (!fwnode)
-		return -ENXIO;
+	u32 val;
 
-	ret = fwnode_property_read_u32(fwnode, "clock-frequency", &xvclk_rate);
+	ret = ov8856_read_reg(ov8856, OV8856_REG_CHIP_ID,
+			      OV8856_REG_VALUE_24BIT, &val);
 	if (ret)
 		return ret;
 
-	if (!is_acpi_node(fwnode)) {
-		ov8856->xvclk = devm_clk_get(dev, "xvclk");
-		if (IS_ERR(ov8856->xvclk)) {
-			dev_err(dev, "could not get xvclk clock (%pe)\n",
-				ov8856->xvclk);
-			return PTR_ERR(ov8856->xvclk);
-		}
-
-		clk_set_rate(ov8856->xvclk, xvclk_rate);
-		xvclk_rate = clk_get_rate(ov8856->xvclk);
-
-		ov8856->reset_gpio = devm_gpiod_get_optional(dev, "reset",
-							     GPIOD_OUT_LOW);
-		if (IS_ERR(ov8856->reset_gpio))
-			return PTR_ERR(ov8856->reset_gpio);
-
-		for (i = 0; i < ARRAY_SIZE(ov8856_supply_names); i++)
-			ov8856->supplies[i].supply = ov8856_supply_names[i];
-
-		ret = devm_regulator_bulk_get(dev,
-					      ARRAY_SIZE(ov8856_supply_names),
-					      ov8856->supplies);
-		if (ret)
-			return ret;
-	}
-
-	if (xvclk_rate != OV8856_XVCLK_19_2)
-		dev_warn(dev, "external clock rate %u is unsupported",
-			 xvclk_rate);
-
-	ep = fwnode_graph_get_next_endpoint(fwnode, NULL);
-	if (!ep)
+	if (val != OV8856_CHIP_ID) {
+		dev_err(&client->dev, "chip id mismatch: %x!=%x",
+			OV8856_CHIP_ID, val);
 		return -ENXIO;
-
-	ret = v4l2_fwnode_endpoint_alloc_parse(ep, &bus_cfg);
-	fwnode_handle_put(ep);
-	if (ret)
-		return ret;
-
-	/* Get number of data lanes */
-	if (bus_cfg.bus.mipi_csi2.num_data_lanes != 2 &&
-	    bus_cfg.bus.mipi_csi2.num_data_lanes != 4) {
-		dev_err(dev, "number of CSI2 data lanes %d is not supported",
-			bus_cfg.bus.mipi_csi2.num_data_lanes);
-		ret = -EINVAL;
-		goto check_hwcfg_error;
-	}
-
-	dev_dbg(dev, "Using %u data lanes\n", ov8856->cur_mode->data_lanes);
-
-	if (bus_cfg.bus.mipi_csi2.num_data_lanes == 2)
-		ov8856->priv_lane = &lane_cfg_2;
-	else
-		ov8856->priv_lane = &lane_cfg_4;
-
-	ov8856->modes_size = ov8856_modes_num(ov8856);
-
-	if (!bus_cfg.nr_of_link_frequencies) {
-		dev_err(dev, "no link frequencies defined");
-		ret = -EINVAL;
-		goto check_hwcfg_error;
-	}
-
-	for (i = 0; i < ARRAY_SIZE(ov8856->priv_lane->link_freq_menu_items); i++) {
-		for (j = 0; j < bus_cfg.nr_of_link_frequencies; j++) {
-			if (ov8856->priv_lane->link_freq_menu_items[i] ==
-			    bus_cfg.link_frequencies[j])
-				break;
-		}
-
-		if (j == bus_cfg.nr_of_link_frequencies) {
-			dev_err(dev, "no link frequency %lld supported",
-				ov8856->priv_lane->link_freq_menu_items[i]);
-			ret = -EINVAL;
-			goto check_hwcfg_error;
-		}
 	}
 
-check_hwcfg_error:
-	v4l2_fwnode_endpoint_free(&bus_cfg);
-
-	return ret;
+	return 0;
 }
 
 static void ov8856_remove(struct i2c_client *client)
@@ -2411,46 +1178,26 @@ static void ov8856_remove(struct i2c_cli
 	pm_runtime_disable(&client->dev);
 	mutex_destroy(&ov8856->mutex);
 
-	__ov8856_power_off(ov8856);
 }
 
 static int ov8856_probe(struct i2c_client *client)
 {
 	struct ov8856 *ov8856;
 	int ret;
-	bool full_power;
 
 	ov8856 = devm_kzalloc(&client->dev, sizeof(*ov8856), GFP_KERNEL);
 	if (!ov8856)
 		return -ENOMEM;
 
-	ret = ov8856_get_hwcfg(ov8856, &client->dev);
+	v4l2_i2c_subdev_init(&ov8856->sd, client, &ov8856_subdev_ops);
+	ret = ov8856_identify_module(ov8856);
 	if (ret) {
-		dev_err(&client->dev, "failed to get HW configuration: %d",
-			ret);
+		dev_err(&client->dev, "failed to find sensor: %d", ret);
 		return ret;
 	}
 
-	v4l2_i2c_subdev_init(&ov8856->sd, client, &ov8856_subdev_ops);
-
-	full_power = acpi_dev_state_d0(&client->dev);
-	if (full_power) {
-		ret = __ov8856_power_on(ov8856);
-		if (ret) {
-			dev_err(&client->dev, "failed to power on\n");
-			return ret;
-		}
-
-		ret = ov8856_identify_module(ov8856);
-		if (ret) {
-			dev_err(&client->dev, "failed to find sensor: %d", ret);
-			goto probe_power_off;
-		}
-	}
-
 	mutex_init(&ov8856->mutex);
-	ov8856->cur_mode = &ov8856->priv_lane->supported_modes[0];
-	ov8856->cur_mbus_index = ov8856->cur_mode->default_mbus_index;
+	ov8856->cur_mode = &supported_modes[0];
 	ret = ov8856_init_controls(ov8856);
 	if (ret) {
 		dev_err(&client->dev, "failed to init controls: %d", ret);
@@ -2475,9 +1222,11 @@ static int ov8856_probe(struct i2c_clien
 		goto probe_error_media_entity_cleanup;
 	}
 
-	/* Set the device's state to active if it's in D0 state. */
-	if (full_power)
-		pm_runtime_set_active(&client->dev);
+	/*
+	 * Device is already turned on by i2c-core with ACPI domain PM.
+	 * Enable runtime PM and turn off the device.
+	 */
+	pm_runtime_set_active(&client->dev);
 	pm_runtime_enable(&client->dev);
 	pm_runtime_idle(&client->dev);
 
@@ -2490,9 +1239,6 @@ probe_error_v4l2_ctrl_handler_free:
 	v4l2_ctrl_handler_free(ov8856->sd.ctrl_handler);
 	mutex_destroy(&ov8856->mutex);
 
-probe_power_off:
-	__ov8856_power_off(ov8856);
-
 	return ret;
 }
 
@@ -2500,6 +1246,12 @@ static const struct dev_pm_ops ov8856_pm
 	SET_SYSTEM_SLEEP_PM_OPS(ov8856_suspend, ov8856_resume)
 };
 
+static const struct i2c_device_id ov8856_id_table[] = {
+	{ "ov8856", 0 },
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(i2c, ov8856_id_table);
+
 #ifdef CONFIG_ACPI
 static const struct acpi_device_id ov8856_acpi_ids[] = {
 	{"OVTI8856"},
@@ -2509,26 +1261,20 @@ static const struct acpi_device_id ov885
 MODULE_DEVICE_TABLE(acpi, ov8856_acpi_ids);
 #endif
 
-static const struct of_device_id ov8856_of_match[] = {
-	{ .compatible = "ovti,ov8856" },
-	{ /* sentinel */ }
-};
-MODULE_DEVICE_TABLE(of, ov8856_of_match);
-
 static struct i2c_driver ov8856_i2c_driver = {
 	.driver = {
 		.name = "ov8856",
 		.pm = &ov8856_pm_ops,
 		.acpi_match_table = ACPI_PTR(ov8856_acpi_ids),
-		.of_match_table = ov8856_of_match,
 	},
 	.probe_new = ov8856_probe,
 	.remove = ov8856_remove,
-	.flags = I2C_DRV_ACPI_WAIVE_D0_PROBE,
+	.id_table = ov8856_id_table,
 };
 
 module_i2c_driver(ov8856_i2c_driver);
 
 MODULE_AUTHOR("Ben Kao <ben.kao@intel.com>");
+MODULE_AUTHOR("Qiu, Tianshu <tian.shu.qiu@intel.com>");
 MODULE_DESCRIPTION("OmniVision OV8856 sensor driver");
 MODULE_LICENSE("GPL v2");
Index: b/drivers/media/i2c/power_ctrl_logic.c
===================================================================
--- /dev/null
+++ b/drivers/media/i2c/power_ctrl_logic.c
@@ -0,0 +1,149 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (c) 2020-2021 Intel Corporation.
+
+#include <linux/acpi.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/mutex.h>
+#include <linux/gpio/consumer.h>
+#include <linux/version.h>
+
+#define PCL_DRV_NAME "power_ctrl_logic"
+
+struct power_ctrl_logic {
+	/* gpio resource*/
+	struct gpio_desc *reset_gpio;
+	struct gpio_desc *powerdn_gpio;
+	struct gpio_desc *clocken_gpio;
+	struct gpio_desc *indled_gpio;
+	/* status */
+	struct mutex status_lock;
+	bool power_on;
+	bool gpio_ready;
+};
+
+struct power_ctrl_gpio {
+	const char *name;
+	struct gpio_desc **pin;
+};
+
+/* mcu gpio resources*/
+static const struct acpi_gpio_params camreset_gpio  = { 0, 0, false };
+static const struct acpi_gpio_params campwdn_gpio   = { 1, 0, false };
+static const struct acpi_gpio_params midmclken_gpio = { 2, 0, false };
+static const struct acpi_gpio_params led_gpio       = { 3, 0, false };
+static const struct acpi_gpio_mapping dsc1_acpi_gpios[] = {
+	{ "camreset-gpios", &camreset_gpio, 1 },
+	{ "campwdn-gpios", &campwdn_gpio, 1 },
+	{ "midmclken-gpios", &midmclken_gpio, 1 },
+	{ "indled-gpios", &led_gpio, 1 },
+	{ }
+};
+
+static struct power_ctrl_logic pcl = {
+	.reset_gpio = NULL,
+	.powerdn_gpio = NULL,
+	.clocken_gpio = NULL,
+	.indled_gpio = NULL,
+	.power_on = false,
+	.gpio_ready = false,
+};
+
+static struct power_ctrl_gpio pcl_gpios[] = {
+	{ "camreset", &pcl.reset_gpio },
+	{ "campwdn", &pcl.powerdn_gpio },
+	{ "midmclken", &pcl.clocken_gpio},
+	{ "indled", &pcl.indled_gpio},
+};
+
+static int power_ctrl_logic_add(struct acpi_device *adev)
+{
+	int i, ret;
+
+	dev_dbg(&adev->dev, "@%s, enter\n", __func__);
+	set_primary_fwnode(&adev->dev, &adev->fwnode);
+
+	ret = acpi_dev_add_driver_gpios(adev, dsc1_acpi_gpios);
+	if (ret) {
+		dev_err(&adev->dev, "@%s: --111---fail to add gpio. ret %d\n", __func__, ret);
+		return -EBUSY;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(pcl_gpios); i++) {
+		*pcl_gpios[i].pin = gpiod_get(&adev->dev, pcl_gpios[i].name, GPIOD_OUT_LOW);
+		if (IS_ERR(*pcl_gpios[i].pin)) {
+			dev_dbg(&adev->dev, "failed to get gpio %s\n", pcl_gpios[i].name);
+			return -EPROBE_DEFER;
+		}
+	}
+
+	mutex_lock(&pcl.status_lock);
+	pcl.gpio_ready = true;
+	mutex_unlock(&pcl.status_lock);
+	acpi_dev_clear_dependencies(adev);
+
+	dev_dbg(&adev->dev, "@%s, exit\n", __func__);
+	return ret;
+}
+
+static int power_ctrl_logic_remove(struct acpi_device *adev)
+{
+	dev_dbg(&adev->dev, "@%s, enter\n", __func__);
+	mutex_lock(&pcl.status_lock);
+	pcl.gpio_ready = false;
+	gpiod_set_value_cansleep(pcl.reset_gpio, 0);
+	gpiod_put(pcl.reset_gpio);
+	gpiod_set_value_cansleep(pcl.powerdn_gpio, 0);
+	gpiod_put(pcl.powerdn_gpio);
+	gpiod_set_value_cansleep(pcl.clocken_gpio, 0);
+	gpiod_put(pcl.clocken_gpio);
+	gpiod_set_value_cansleep(pcl.indled_gpio, 0);
+	gpiod_put(pcl.indled_gpio);
+	mutex_unlock(&pcl.status_lock);
+	dev_dbg(&adev->dev, "@%s, exit\n", __func__);
+	return 0;
+}
+
+static struct acpi_device_id acpi_ids[] = {
+	{ "INT3472", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(acpi, acpi_ids);
+
+static struct acpi_driver _driver = {
+	.name = PCL_DRV_NAME,
+	.class = PCL_DRV_NAME,
+	.ids = acpi_ids,
+	.ops = {
+		.add = power_ctrl_logic_add,
+		.remove = power_ctrl_logic_remove,
+	},
+};
+module_acpi_driver(_driver);
+
+int power_ctrl_logic_set_power(int on)
+{
+	mutex_lock(&pcl.status_lock);
+	if (!pcl.gpio_ready) {
+		pr_debug("@%s,failed to set power, gpio_ready=%d, on=%d\n",
+			 __func__, pcl.gpio_ready, on);
+		mutex_unlock(&pcl.status_lock);
+		return -EPROBE_DEFER;
+	}
+	if (pcl.power_on != on) {
+		gpiod_set_value_cansleep(pcl.reset_gpio, on);
+		gpiod_set_value_cansleep(pcl.powerdn_gpio, on);
+		gpiod_set_value_cansleep(pcl.clocken_gpio, on);
+		gpiod_set_value_cansleep(pcl.indled_gpio, on);
+		pcl.power_on = on;
+	}
+	mutex_unlock(&pcl.status_lock);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(power_ctrl_logic_set_power);
+
+MODULE_AUTHOR("Bingbu Cao <bingbu.cao@intel.com>");
+MODULE_AUTHOR("Qiu, Tianshu <tian.shu.qiu@intel.com>");
+MODULE_AUTHOR("Xu, Chongyang <chongyang.xu@intel.com>");
+MODULE_DESCRIPTION("Power Control Logic Driver");
+MODULE_LICENSE("GPL v2");
Index: b/drivers/media/i2c/power_ctrl_logic.h
===================================================================
--- /dev/null
+++ b/drivers/media/i2c/power_ctrl_logic.h
@@ -0,0 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (c) 2020-2021 Intel Corporation. */
+
+#ifndef _POWER_CTRL_LOGIC_H_
+#define _POWER_CTRL_LOGIC_H_
+
+/* exported function for extern module */
+int power_ctrl_logic_set_power(int on);
+#endif
Index: b/drivers/media/i2c/ti953-ser.c
===================================================================
--- /dev/null
+++ b/drivers/media/i2c/ti953-ser.c
@@ -0,0 +1,139 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) 2020 Intel Corporation
+
+#include <linux/device.h>
+#include <linux/gpio.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/wait.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/version.h>
+
+#include <media/media-device.h>
+#include <media/media-entity.h>
+#include <media/ti960.h>
+#include <media/v4l2-device.h>
+#include <media/videobuf2-core.h>
+
+#include "ti960-reg.h"
+#include "ti953.h"
+
+int ti953_reg_write(struct v4l2_subdev *sd, unsigned short rx_port,
+	unsigned short ser_alias, unsigned char reg, unsigned char val)
+{
+	int ret;
+	int retry, timeout = 10;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	unsigned short addr_backup;
+
+	dev_dbg(sd->dev, "%s port %d, ser_alias %x, reg %x, val %x",
+		__func__, rx_port, ser_alias, reg, val);
+	addr_backup = client->addr;
+	client->addr = ser_alias;
+	for (retry = 0; retry < timeout; retry++) {
+		ret = i2c_smbus_write_byte_data(client, reg, val);
+		if (ret < 0)
+			usleep_range(5000, 6000);
+		else
+			break;
+	}
+
+	client->addr = addr_backup;
+	if (retry >= timeout) {
+		dev_err(sd->dev,
+			"%s:write reg failed: port=%2x, addr=%2x, reg=%2x\n",
+			__func__, rx_port, ser_alias, reg);
+		return -EREMOTEIO;
+	}
+
+	return 0;
+}
+
+int ti953_reg_read(struct v4l2_subdev *sd, unsigned short rx_port,
+	unsigned short ser_alias, unsigned char reg, unsigned char *val)
+{
+	int retry, timeout = 10;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	unsigned short addr_backup;
+
+	addr_backup = client->addr;
+	client->addr = ser_alias;
+	for (retry = 0; retry < timeout; retry++) {
+		*val = i2c_smbus_read_byte_data(client, reg);
+		if (*val < 0)
+			usleep_range(5000, 6000);
+		else
+			break;
+	}
+
+	client->addr = addr_backup;
+	if (retry >= timeout) {
+		dev_err(sd->dev,
+			"%s:read reg failed: port=%2x, addr=%2x, reg=%2x\n",
+			__func__, rx_port, ser_alias, reg);
+		return -EREMOTEIO;
+	}
+
+	return 0;
+}
+
+bool ti953_detect(struct v4l2_subdev *sd, unsigned short rx_port, unsigned short ser_alias)
+{
+	bool ret = false;
+	int i;
+	int rval;
+	unsigned char val;
+
+	for (i = 0; i < ARRAY_SIZE(ti953_FPD3_RX_ID); i++) {
+		rval = ti953_reg_read(sd, rx_port, ser_alias,
+			ti953_FPD3_RX_ID[i].reg, &val);
+		if (rval) {
+			dev_err(sd->dev, "port %d, ti953 write timeout %d\n", rx_port, rval);
+			break;
+		}
+		if (val != ti953_FPD3_RX_ID[i].val_expected)
+			break;
+	}
+
+	if (i == ARRAY_SIZE(ti953_FPD3_RX_ID))
+		ret = true;
+
+	return ret;
+}
+
+int ti953_init(struct v4l2_subdev *sd, unsigned short rx_port, unsigned short ser_alias)
+{
+	int i, rval;
+
+	for (i = 0; i < ARRAY_SIZE(ti953_init_settings); i++) {
+		rval = ti953_reg_write(sd, rx_port, ser_alias,
+			ti953_init_settings[i].reg,
+			ti953_init_settings[i].val);
+		if (rval) {
+			dev_err(sd->dev, "port %d, ti953 write timeout %d\n", 0, rval);
+			break;
+		}
+	}
+
+	ti953_init_clk(sd, rx_port, ser_alias);
+
+	return 0;
+}
+
+int ti953_init_clk(struct v4l2_subdev *sd, unsigned short rx_port, unsigned short ser_alias)
+{
+	int i, rval;
+
+	for (i = 0; i < ARRAY_SIZE(ti953_init_settings_clk); i++) {
+		rval = ti953_reg_write(sd, rx_port, ser_alias,
+			ti953_init_settings_clk[i].reg,
+			ti953_init_settings_clk[i].val);
+		if (rval) {
+			dev_err(sd->dev, "port %d, ti953 write timeout %d\n", 0, rval);
+			break;
+		}
+	}
+
+	return 0;
+}
Index: b/drivers/media/i2c/ti953.h
===================================================================
--- /dev/null
+++ b/drivers/media/i2c/ti953.h
@@ -0,0 +1,122 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2020 Intel Corporation */
+
+#ifndef TI953_H
+#define TI953_H
+
+struct ti953_register_write {
+	u8 reg;
+	u8 val;
+};
+
+struct ti953_register_devid {
+	u8 reg;
+	u8 val_expected;
+};
+
+/* register definition */
+#define TI953_RESET_CTL		0x1
+#define TI953_LOCAL_GPIO_DATA	0xd
+#define TI953_GPIO_INPUT_CTRL	0xe
+
+/* register value definition */
+#define TI953_DIGITAL_RESET_1	0x2
+#define TI953_GPIO0_RMTEN	0x10
+#define TI953_GPIO0_OUT		0x1
+#define TI953_GPIO1_OUT		(0x1 << 1)
+#define TI953_GPIO_OUT_EN	0xf0
+
+static const struct ti953_register_write ti953_init_settings[] = {
+	{0x4c, 0x01}, /* ox03a10 init sequence */
+	{0xb0, 0x04},
+	{0xb1, 0x03},
+	{0xb2, 0x25},
+	{0xb1, 0x13},
+	{0xb2, 0x25},
+	{0xb0, 0x04},
+	{0xb1, 0x04},
+	{0xb2, 0x30},
+	{0xb1, 0x14},
+	{0xb2, 0x30},
+	{0xb0, 0x04},
+	{0xb1, 0x06},
+	{0xb2, 0x40},
+	{0x42, 0x01},
+	{0x41, 0x93},
+	{0x4c, 0x12},
+	{0xb0, 0x08},
+	{0xb1, 0x03},
+	{0xb2, 0x25},
+	{0xb1, 0x13},
+	{0xb2, 0x25},
+	{0xb0, 0x08},
+	{0xb1, 0x04},
+	{0xb2, 0x30},
+	{0xb1, 0x14},
+	{0xb2, 0x30},
+	{0xb0, 0x08},
+	{0xb1, 0x06},
+	{0xb2, 0x40},
+	{0x42, 0x01},
+	{0x41, 0x93},
+	{0x4c, 0x24},
+	{0xb0, 0x0c},
+	{0xb1, 0x03},
+	{0xb2, 0x25},
+	{0xb1, 0x13},
+	{0xb2, 0x25},
+	{0xb0, 0x0c},
+	{0xb1, 0x04},
+	{0xb2, 0x30},
+	{0xb1, 0x14},
+	{0xb2, 0x30},
+	{0xb0, 0x0c},
+	{0xb1, 0x06},
+	{0xb2, 0x40},
+	{0x42, 0x01},
+	{0x41, 0x93},
+	{0x4c, 0x38},
+	{0xb0, 0x10},
+	{0xb1, 0x03},
+	{0xb2, 0x25},
+	{0xb1, 0x13},
+	{0xb2, 0x25},
+	{0xb0, 0x10},
+	{0xb1, 0x04},
+	{0xb2, 0x30},
+	{0xb1, 0x14},
+	{0xb2, 0x30},
+	{0xb0, 0x10},
+	{0xb1, 0x06},
+	{0xb2, 0x40},
+	{0x42, 0x01},
+	{0x41, 0x93},
+};
+
+static const struct ti953_register_write ti953_init_settings_clk[] = {
+	{0x06, 0x41},
+	/* WA: set N to 0x25 for 30 fps */
+	{0x07, 0x25},
+};
+
+static const struct ti953_register_devid ti953_FPD3_RX_ID[] = {
+	{0xf0, 0x5f},
+	{0xf1, 0x55},
+	{0xf2, 0x42},
+	{0xf3, 0x39},
+	{0xf4, 0x35},
+	{0xf5, 0x33},
+};
+
+int ti953_reg_write(struct v4l2_subdev *sd, unsigned short rx_port,
+		unsigned short ser_alias, unsigned char reg, unsigned char val);
+
+int ti953_reg_read(struct v4l2_subdev *sd, unsigned short rx_port,
+		unsigned short ser_alias, unsigned char reg, unsigned char *val);
+
+bool ti953_detect(struct v4l2_subdev *sd, unsigned short rx_port, unsigned short ser_alias);
+
+int ti953_init(struct v4l2_subdev *sd, unsigned short rx_port, unsigned short ser_alias);
+int ti953_init_clk(struct v4l2_subdev *sd, unsigned short rx_port, unsigned short ser_alias);
+
+#endif
Index: b/drivers/media/i2c/ti960-des.c
===================================================================
--- /dev/null
+++ b/drivers/media/i2c/ti960-des.c
@@ -0,0 +1,1616 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) 2022 Intel Corporation
+
+#include <linux/device.h>
+#include <linux/gpio.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/wait.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/ipu-isys.h>
+#include <linux/version.h>
+
+#include <media/media-device.h>
+#include <media/media-entity.h>
+#include <media/ti960.h>
+#include <media/v4l2-device.h>
+#include <media/videobuf2-core.h>
+
+#include "ti960-reg.h"
+#include "ti953.h"
+
+#define MIPI_CSI2_TYPE_RAW12   0x2c
+#define MIPI_CSI2_TYPE_YUV422_8	0x1e
+
+struct ti960_subdev {
+	struct v4l2_subdev *sd;
+	unsigned short rx_port;
+	unsigned short fsin_gpio;
+	unsigned short phy_i2c_addr;
+	unsigned short alias_i2c_addr;
+	unsigned short ser_i2c_addr;
+	char sd_name[16];
+};
+
+struct ti960 {
+	struct v4l2_subdev sd;
+	struct media_pad pad[NR_OF_TI960_PADS];
+	struct v4l2_ctrl_handler ctrl_handler;
+	struct ti960_pdata *pdata;
+	struct ti960_subdev sub_devs[NR_OF_TI960_SINK_PADS];
+	struct ti960_subdev_pdata subdev_pdata[NR_OF_TI960_SINK_PADS];
+	const char *name;
+
+	struct mutex mutex;
+
+	struct regmap *regmap8;
+	struct regmap *regmap16;
+
+	struct v4l2_mbus_framefmt *ffmts[NR_OF_TI960_PADS];
+	struct rect *crop;
+	struct rect *compose;
+
+	unsigned int nsinks;
+	unsigned int nsources;
+	unsigned int nstreams;
+	unsigned int npads;
+
+	struct gpio_chip gc;
+
+	struct v4l2_ctrl *link_freq;
+	struct v4l2_ctrl *test_pattern;
+};
+
+#define to_ti960(_sd) container_of(_sd, struct ti960, sd)
+
+static const s64 ti960_op_sys_clock[] =  {200000000,
+					  400000000,
+					  600000000,
+					  800000000};
+
+static const u8 ti960_op_sys_clock_reg_val[] = {
+	TI960_MIPI_400MBPS,
+	TI960_MIPI_800MBPS,
+	TI960_MIPI_1200MBPS,
+	TI960_MIPI_1600MBPS
+};
+
+/*
+ * Order matters.
+ *
+ * 1. Bits-per-pixel, descending.
+ * 2. Bits-per-pixel compressed, descending.
+ * 3. Pixel order, same as in pixel_order_str. Formats for all four pixel
+ *    orders must be defined.
+ */
+static const struct ti960_csi_data_format va_csi_data_formats[] = {
+	{ MEDIA_BUS_FMT_YUYV8_1X16, 16, 16, PIXEL_ORDER_GBRG, 0x1e },
+	{ MEDIA_BUS_FMT_UYVY8_1X16, 16, 16, PIXEL_ORDER_GBRG, 0x1e },
+	{ MEDIA_BUS_FMT_SGRBG16_1X16, 16, 16, PIXEL_ORDER_GRBG, 0x2e },
+	{ MEDIA_BUS_FMT_SRGGB16_1X16, 16, 16, PIXEL_ORDER_RGGB, 0x2e },
+	{ MEDIA_BUS_FMT_SBGGR16_1X16, 16, 16, PIXEL_ORDER_BGGR, 0x2e },
+	{ MEDIA_BUS_FMT_SGBRG16_1X16, 16, 16, PIXEL_ORDER_GBRG, 0x2e },
+	{ MEDIA_BUS_FMT_SGRBG12_1X12, 12, 12, PIXEL_ORDER_GRBG, 0x2c },
+	{ MEDIA_BUS_FMT_SRGGB12_1X12, 12, 12, PIXEL_ORDER_RGGB, 0x2c },
+	{ MEDIA_BUS_FMT_SBGGR12_1X12, 12, 12, PIXEL_ORDER_BGGR, 0x2c },
+	{ MEDIA_BUS_FMT_SGBRG12_1X12, 12, 12, PIXEL_ORDER_GBRG, 0x2c },
+	{ MEDIA_BUS_FMT_SGRBG10_1X10, 10, 10, PIXEL_ORDER_GRBG, 0x2b },
+	{ MEDIA_BUS_FMT_SRGGB10_1X10, 10, 10, PIXEL_ORDER_RGGB, 0x2b },
+	{ MEDIA_BUS_FMT_SBGGR10_1X10, 10, 10, PIXEL_ORDER_BGGR, 0x2b },
+	{ MEDIA_BUS_FMT_SGBRG10_1X10, 10, 10, PIXEL_ORDER_GBRG, 0x2b },
+};
+
+static const uint32_t ti960_supported_codes_pad[] = {
+	MEDIA_BUS_FMT_YUYV8_1X16,
+	MEDIA_BUS_FMT_UYVY8_1X16,
+	MEDIA_BUS_FMT_SBGGR16_1X16,
+	MEDIA_BUS_FMT_SGBRG16_1X16,
+	MEDIA_BUS_FMT_SGRBG16_1X16,
+	MEDIA_BUS_FMT_SRGGB16_1X16,
+	MEDIA_BUS_FMT_SBGGR12_1X12,
+	MEDIA_BUS_FMT_SGBRG12_1X12,
+	MEDIA_BUS_FMT_SGRBG12_1X12,
+	MEDIA_BUS_FMT_SRGGB12_1X12,
+	MEDIA_BUS_FMT_SBGGR10_1X10,
+	MEDIA_BUS_FMT_SGBRG10_1X10,
+	MEDIA_BUS_FMT_SGRBG10_1X10,
+	MEDIA_BUS_FMT_SRGGB10_1X10,
+	0,
+};
+
+static const uint32_t *ti960_supported_codes[] = {
+	ti960_supported_codes_pad,
+};
+
+static struct regmap_config ti960_reg_config8 = {
+	.reg_bits = 8,
+	.val_bits = 8,
+};
+
+static struct regmap_config ti960_reg_config16 = {
+	.reg_bits = 16,
+	.val_bits = 8,
+	.reg_format_endian = REGMAP_ENDIAN_BIG,
+};
+
+static s64 ti960_query_sub_stream[NR_OF_TI960_SINK_PADS] = {
+	0, 0, 0, 0
+};
+
+static void set_sub_stream_fmt(int index, u32 code)
+{
+	ti960_query_sub_stream[index] &= 0xFFFFFFFFFFFF0000;
+	ti960_query_sub_stream[index] |= code;
+}
+
+static void set_sub_stream_h(int index, u32 height)
+{
+	s64 val = height & 0xFFFF;
+
+	ti960_query_sub_stream[index] &= 0xFFFFFFFF0000FFFF;
+	ti960_query_sub_stream[index] |= val << 16;
+}
+
+static void set_sub_stream_w(int index, u32 width)
+{
+	s64 val = width & 0xFFFF;
+
+	ti960_query_sub_stream[index] &= 0xFFFF0000FFFFFFFF;
+	ti960_query_sub_stream[index] |= val << 32;
+}
+
+static void set_sub_stream_dt(int index, u32 dt)
+{
+	s64 val = dt & 0xFF;
+
+	ti960_query_sub_stream[index] &= 0xFF00FFFFFFFFFFFF;
+	ti960_query_sub_stream[index] |= val << 48;
+}
+
+static void set_sub_stream_vc_id(int index, u32 vc_id)
+{
+	s64 val = vc_id & 0xFF;
+
+	ti960_query_sub_stream[index] &= 0x00FFFFFFFFFFFFFF;
+	ti960_query_sub_stream[index] |= val << 56;
+}
+
+static u8 ti960_set_sub_stream[] = {
+	0, 0, 0, 0
+};
+
+int bus_switch(struct ti960 *va)
+{
+	int ret;
+	int retry, timeout = 10;
+	struct i2c_client *client = v4l2_get_subdevdata(&va->sd);
+	unsigned short addr_backup;
+
+	dev_dbg(&client->dev, "try to set bus switch\n");
+	addr_backup = client->addr;
+	client->addr = 0x70;
+	for (retry = 0; retry < timeout; retry++) {
+		ret = i2c_smbus_write_byte(client, 0x01);
+		if (ret < 0)
+			usleep_range(5000, 6000);
+		else
+			break;
+	}
+
+	client->addr = addr_backup;
+	if (retry >= timeout) {
+		dev_err(&client->dev, "bus switch failed, maybe no bus switch\n");
+	}
+
+	return 0;
+}
+
+static int ti960_reg_read(struct ti960 *va, unsigned char reg, unsigned int *val)
+{
+	int ret, retry, timeout = 10;
+
+	for (retry = 0; retry < timeout; retry++) {
+		ret = regmap_read(va->regmap8, reg, val);
+		if (ret < 0) {
+			dev_err(va->sd.dev, "960 reg read ret=%x", ret);
+			usleep_range(5000, 6000);
+		} else {
+			break;
+		}
+	}
+
+	if (retry >= timeout) {
+		dev_err(va->sd.dev,
+			"%s:devid read failed: reg=%2x, ret=%d\n",
+			__func__, reg, ret);
+		return -EREMOTEIO;
+	}
+
+	return 0;
+}
+
+static int ti960_reg_write(struct ti960 *va, unsigned char reg, unsigned int val)
+{
+	int ret, retry, timeout = 10;
+
+	for (retry = 0; retry < timeout; retry++) {
+		dev_dbg(va->sd.dev, "write reg %x = %x", reg, val);
+		ret = regmap_write(va->regmap8, reg, val);
+		if (ret < 0) {
+			dev_err(va->sd.dev, "960 reg write ret=%x", ret);
+			usleep_range(5000, 6000);
+		} else {
+			break;
+		}
+	}
+
+	if (retry >= timeout) {
+		dev_err(va->sd.dev,
+			"%s:devid write failed: reg=%2x, ret=%d\n",
+			__func__, reg, ret);
+		return -EREMOTEIO;
+	}
+
+	return 0;
+}
+
+static int ti960_reg_set_bit(struct ti960 *va, unsigned char reg,
+	unsigned char bit, unsigned char val)
+{
+	int ret;
+	unsigned int reg_val;
+
+	ret = regmap_read(va->regmap8, reg, &reg_val);
+	if (ret)
+		return ret;
+	if (val)
+		reg_val |= 1 << bit;
+	else
+		reg_val &= ~(1 << bit);
+
+	return ti960_reg_write(va, reg, reg_val);
+}
+
+static int ti960_map_phy_i2c_addr(struct ti960 *va, unsigned short rx_port,
+			      unsigned short addr)
+{
+	int rval;
+
+	rval = ti960_reg_write(va, TI960_RX_PORT_SEL,
+		(rx_port << 4) + (1 << rx_port));
+	if (rval)
+		return rval;
+
+	return ti960_reg_write(va, TI960_SLAVE_ID0, addr);
+}
+
+static int ti960_map_alias_i2c_addr(struct ti960 *va, unsigned short rx_port,
+			      unsigned short addr)
+{
+	int rval;
+
+	rval = ti960_reg_write(va, TI960_RX_PORT_SEL,
+		(rx_port << 4) + (1 << rx_port));
+	if (rval)
+		return rval;
+
+	return ti960_reg_write(va, TI960_SLAVE_ALIAS_ID0, addr);
+}
+
+static int ti960_map_ser_alias_addr(struct ti960 *va, unsigned short rx_port,
+			      unsigned short ser_alias)
+{
+	int rval;
+
+	dev_dbg(va->sd.dev, "%s port %d, ser_alias %x\n", __func__, rx_port, ser_alias);
+	rval = ti960_reg_write(va, TI960_RX_PORT_SEL,
+		(rx_port << 4) + (1 << rx_port));
+	if (rval)
+		return rval;
+
+	return ti960_reg_write(va, TI960_SER_ALIAS_ID, ser_alias);
+}
+
+static int ti960_fsin_gpio_init(struct ti960 *va, unsigned short rx_port,
+		unsigned short ser_alias, unsigned short fsin_gpio)
+{
+	unsigned char gpio_data;
+	int rval;
+	int reg_val;
+
+	dev_dbg(va->sd.dev, "%s\n", __func__);
+	rval = regmap_read(va->regmap8, TI960_FS_CTL, &reg_val);
+	if (rval) {
+		dev_dbg(va->sd.dev, "Failed to read gpio status.\n");
+		return rval;
+	}
+
+	if (!reg_val & TI960_FSIN_ENABLE) {
+		dev_dbg(va->sd.dev, "FSIN not enabled, skip config FSIN GPIO.\n");
+		return 0;
+	}
+
+	rval = ti960_reg_write(va, TI960_RX_PORT_SEL,
+		(rx_port << 4) + (1 << rx_port));
+	if (rval)
+		return rval;
+
+	switch (fsin_gpio) {
+	case 0:
+	case 1:
+		rval = regmap_read(va->regmap8, TI960_BC_GPIO_CTL0, &reg_val);
+		if (rval) {
+			dev_dbg(va->sd.dev, "Failed to read gpio status.\n");
+			return rval;
+		}
+
+		if (fsin_gpio == 0) {
+			reg_val &= ~TI960_GPIO0_MASK;
+			reg_val |= TI960_GPIO0_FSIN;
+		} else {
+			reg_val &= ~TI960_GPIO1_MASK;
+			reg_val |= TI960_GPIO1_FSIN;
+		}
+
+		rval = ti960_reg_write(va, TI960_BC_GPIO_CTL0, reg_val);
+		if (rval)
+			dev_dbg(va->sd.dev, "Failed to set gpio.\n");
+		break;
+	case 2:
+	case 3:
+		rval = regmap_read(va->regmap8, TI960_BC_GPIO_CTL1, &reg_val);
+		if (rval) {
+			dev_dbg(va->sd.dev, "Failed to read gpio status.\n");
+			return rval;
+		}
+
+		if (fsin_gpio == 2) {
+			reg_val &= ~TI960_GPIO2_MASK;
+			reg_val |= TI960_GPIO2_FSIN;
+		} else {
+			reg_val &= ~TI960_GPIO3_MASK;
+			reg_val |= TI960_GPIO3_FSIN;
+		}
+
+		rval = ti960_reg_write(va, TI960_BC_GPIO_CTL1, reg_val);
+		if (rval)
+			dev_dbg(va->sd.dev, "Failed to set gpio.\n");
+		break;
+	}
+
+	/* enable output and remote control */
+	ti953_reg_write(&va->sd, rx_port, ser_alias, TI953_GPIO_INPUT_CTRL, TI953_GPIO_OUT_EN);
+	rval = ti953_reg_read(&va->sd, rx_port, ser_alias, TI953_LOCAL_GPIO_DATA,
+			&gpio_data);
+	if (rval)
+		return rval;
+	ti953_reg_write(&va->sd, rx_port, ser_alias, TI953_LOCAL_GPIO_DATA,
+			gpio_data | TI953_GPIO0_RMTEN << fsin_gpio);
+
+	return rval;
+}
+
+static int ti960_enum_mbus_code(struct v4l2_subdev *sd,
+				struct v4l2_subdev_state *sd_state,
+				struct v4l2_subdev_mbus_code_enum *code)
+{
+	struct ti960 *va = to_ti960(sd);
+	const uint32_t *supported_code =
+		ti960_supported_codes[code->pad];
+	bool next_stream = false;
+	int i;
+
+	for (i = 0; supported_code[i]; i++) {
+		if (i == code->index) {
+			code->code = supported_code[i];
+			return 0;
+		}
+	}
+
+	return -EINVAL;
+}
+
+static const struct ti960_csi_data_format
+		*ti960_validate_csi_data_format(u32 code)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(va_csi_data_formats); i++) {
+		if (va_csi_data_formats[i].code == code)
+			return &va_csi_data_formats[i];
+	}
+
+	return &va_csi_data_formats[0];
+}
+
+static int ti960_get_frame_desc(struct v4l2_subdev *sd,
+	unsigned int pad, struct v4l2_mbus_frame_desc *desc)
+{
+	struct ti960 *va = to_ti960(sd);
+	int sink_pad = pad;
+
+	if (sink_pad >= 0) {
+		struct media_pad *remote_pad =
+			media_entity_remote_pad(&sd->entity.pads[sink_pad]);
+		if (remote_pad) {
+			struct v4l2_subdev *rsd = media_entity_to_v4l2_subdev(remote_pad->entity);
+
+			dev_dbg(sd->dev, "%s remote sd: %s\n", __func__, rsd->name);
+			v4l2_subdev_call(rsd, pad, get_frame_desc, 0, desc);
+		}
+	} else
+		dev_err(sd->dev, "can't find the frame desc\n");
+
+	return 0;
+}
+
+static struct v4l2_mbus_framefmt *
+__ti960_get_ffmt(struct v4l2_subdev *subdev,
+		 struct v4l2_subdev_state *sd_state,
+		 unsigned int pad, unsigned int which,
+		 unsigned int stream)
+{
+	struct ti960 *va = to_ti960(subdev);
+
+	if (pad < 0 || pad >= NR_OF_TI960_PADS ||
+	    stream < 0 || stream >= va->nstreams) {
+		dev_err(subdev->dev, "%s invalid pad %d, or stream %d\n", __func__, pad, stream);
+		return NULL;
+	}
+
+	if (which == V4L2_SUBDEV_FORMAT_TRY)
+		return v4l2_subdev_get_try_format(subdev, sd_state, pad);
+	else
+		return &va->ffmts[pad][stream];
+}
+
+static int ti960_get_format(struct v4l2_subdev *subdev,
+			    struct v4l2_subdev_state *sd_state,
+			    struct v4l2_subdev_format *fmt)
+{
+	struct ti960 *va = to_ti960(subdev);
+	struct v4l2_mbus_framefmt *ffmt;
+
+	mutex_lock(&va->mutex);
+	ffmt = __ti960_get_ffmt(subdev, sd_state, fmt->pad, fmt->which, 0);
+	if (!ffmt) {
+		mutex_unlock(&va->mutex);
+		return -EINVAL;
+	}
+	fmt->format = *ffmt;
+	mutex_unlock(&va->mutex);
+
+	dev_dbg(subdev->dev, "subdev_format: which: %s, pad: %d.\n",
+		 fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE ?
+		 "V4L2_SUBDEV_FORMAT_ACTIVE" : "V4L2_SUBDEV_FORMAT_TRY",
+		 fmt->pad);
+
+	dev_dbg(subdev->dev, "framefmt: width: %d, height: %d, code: 0x%x.\n",
+	       fmt->format.width, fmt->format.height, fmt->format.code);
+
+	return 0;
+}
+
+static int ti960_set_format(struct v4l2_subdev *subdev,
+			    struct v4l2_subdev_state *sd_state,
+			    struct v4l2_subdev_format *fmt)
+{
+	struct ti960 *va = to_ti960(subdev);
+	const struct ti960_csi_data_format *csi_format;
+	struct v4l2_mbus_framefmt *ffmt;
+
+	csi_format = ti960_validate_csi_data_format(
+		fmt->format.code);
+
+	mutex_lock(&va->mutex);
+	ffmt = __ti960_get_ffmt(subdev, sd_state, fmt->pad, fmt->which, 0);
+
+	if (!ffmt) {
+		mutex_unlock(&va->mutex);
+		return -EINVAL;
+	}
+	if (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+		ffmt->width = fmt->format.width;
+		ffmt->height = fmt->format.height;
+		ffmt->code = csi_format->code;
+	}
+	fmt->format = *ffmt;
+
+	if (fmt->pad < NR_OF_TI960_SINK_PADS) {
+		set_sub_stream_fmt(fmt->pad, ffmt->code);
+		set_sub_stream_h(fmt->pad, ffmt->height);
+		set_sub_stream_w(fmt->pad, ffmt->width);
+
+		/* select correct csi-2 data type id */
+		if (ffmt->code >= MEDIA_BUS_FMT_UYVY8_1X16 &&
+				ffmt->code <= MEDIA_BUS_FMT_YVYU8_1X16)
+			set_sub_stream_dt(fmt->pad, MIPI_CSI2_TYPE_YUV422_8);
+		else
+			set_sub_stream_dt(fmt->pad, MIPI_CSI2_TYPE_RAW12);
+		set_sub_stream_vc_id(fmt->pad, fmt->pad);
+		dev_dbg(subdev->dev,
+			"framefmt: width: %d, height: %d, code: 0x%x.\n",
+			ffmt->width, ffmt->height, ffmt->code);
+	}
+
+	mutex_unlock(&va->mutex);
+	return 0;
+}
+
+static int ti960_open(struct v4l2_subdev *subdev,
+				struct v4l2_subdev_fh *fh)
+{
+	struct v4l2_mbus_framefmt *try_fmt =
+		v4l2_subdev_get_try_format(subdev, fh->state, 0);
+
+	struct v4l2_subdev_format fmt = {
+		.which = V4L2_SUBDEV_FORMAT_TRY,
+		.pad = TI960_PAD_SOURCE,
+		.format = {
+			.width = TI960_MAX_WIDTH,
+			.height = TI960_MAX_HEIGHT,
+			.code = MEDIA_BUS_FMT_SBGGR12_1X12,
+		},
+	};
+
+	*try_fmt = fmt.format;
+
+	return 0;
+}
+
+static int ti960_map_subdevs_addr(struct ti960 *va)
+{
+	unsigned short rx_port, phy_i2c_addr, alias_i2c_addr;
+	int i, rval;
+
+	for (i = 0; i < NR_OF_TI960_SINK_PADS; i++) {
+		rx_port = va->sub_devs[i].rx_port;
+		phy_i2c_addr = va->sub_devs[i].phy_i2c_addr;
+		alias_i2c_addr = va->sub_devs[i].alias_i2c_addr;
+
+		if (!phy_i2c_addr || !alias_i2c_addr)
+			continue;
+
+		rval = ti960_map_phy_i2c_addr(va, rx_port, phy_i2c_addr);
+		if (rval)
+			return rval;
+
+		/* set 7bit alias i2c addr */
+		rval = ti960_map_alias_i2c_addr(va, rx_port,
+						alias_i2c_addr << 1);
+		if (rval)
+			return rval;
+	}
+
+	return 0;
+}
+
+/*
+ * FIXME: workaround, reset to avoid block.
+ */
+static int reset_sensor(struct ti960 *va, unsigned short rx_port,
+		unsigned short ser_alias, int reset)
+{
+	int rval;
+	unsigned char gpio_data;
+
+	rval = ti953_reg_read(&va->sd, rx_port, ser_alias,
+			TI953_LOCAL_GPIO_DATA,
+			&gpio_data);
+	if (rval)
+		return rval;
+
+	ti953_reg_write(&va->sd, rx_port, ser_alias, TI953_GPIO_INPUT_CTRL,
+			TI953_GPIO_OUT_EN);
+	gpio_data &= ~(TI953_GPIO0_RMTEN << reset);
+	gpio_data &= ~(TI953_GPIO0_OUT << reset);
+	ti953_reg_write(&va->sd, rx_port, ser_alias, TI953_LOCAL_GPIO_DATA,
+			gpio_data);
+	msleep(50);
+	gpio_data |= TI953_GPIO0_OUT << reset;
+	ti953_reg_write(&va->sd, rx_port, ser_alias, TI953_LOCAL_GPIO_DATA,
+			gpio_data);
+
+	return 0;
+}
+
+static int ti960_registered(struct v4l2_subdev *subdev)
+{
+	struct ti960 *va = to_ti960(subdev);
+	struct i2c_client *client = v4l2_get_subdevdata(subdev);
+	int i, j, k, l, m, rval;
+	bool port_registered[NR_OF_TI960_SINK_PADS];
+
+	for (i = 0 ; i < NR_OF_TI960_SINK_PADS; i++)
+		port_registered[i] = false;
+
+	for (i = 0, k = 0; i < va->pdata->subdev_num; i++) {
+		struct ti960_subdev_info *info =
+			&va->pdata->subdev_info[i];
+		struct ti960_subdev_pdata *pdata =
+			(struct ti960_subdev_pdata *)
+			info->board_info.platform_data;
+
+		if (k >= va->nsinks)
+			break;
+
+		if (port_registered[info->rx_port]) {
+			dev_err(va->sd.dev,
+				"rx port %d registed already\n",
+				info->rx_port);
+			continue;
+		}
+
+		rval = ti960_map_ser_alias_addr(va, info->rx_port,
+				info->ser_alias << 1);
+		if (rval)
+			return rval;
+
+		if (!ti953_detect(&va->sd, info->rx_port, info->ser_alias))
+			continue;
+
+		/*
+		 * The sensors should not share the same pdata structure.
+		 * Clone the pdata for each sensor.
+		 */
+		memcpy(&va->subdev_pdata[k], pdata, sizeof(*pdata));
+
+		va->sub_devs[k].fsin_gpio = va->subdev_pdata[k].fsin;
+
+		/* Spin sensor subdev suffix name */
+		va->subdev_pdata[k].suffix = info->suffix;
+
+		/*
+		 * Change the gpio value to have xshutdown
+		 * and rx port included, so in gpio_set those
+		 * can be caculated from it.
+		 */
+		va->subdev_pdata[k].xshutdown += va->gc.base +
+					info->rx_port * NR_OF_GPIOS_PER_PORT;
+		info->board_info.platform_data = &va->subdev_pdata[k];
+
+		if (!info->phy_i2c_addr || !info->board_info.addr) {
+			dev_err(va->sd.dev, "can't find the physical and alias addr.\n");
+			return -EINVAL;
+		}
+
+		ti953_reg_write(&va->sd, info->rx_port, info->ser_alias,
+				TI953_RESET_CTL, TI953_DIGITAL_RESET_1);
+		msleep(50);
+
+		if (va->subdev_pdata[k].module_flags & TI960_FL_INIT_SER) {
+			rval = ti953_init(&va->sd, info->rx_port, info->ser_alias);
+			if (rval)
+				return rval;
+		}
+
+		if (va->subdev_pdata[k].module_flags & TI960_FL_INIT_SER_CLK) {
+			rval = ti953_init_clk(&va->sd, info->rx_port, info->ser_alias);
+			if (rval)
+				return rval;
+		}
+
+		if (va->subdev_pdata[k].module_flags & TI960_FL_POWERUP) {
+			ti953_reg_write(&va->sd, info->rx_port, info->ser_alias,
+					TI953_GPIO_INPUT_CTRL, TI953_GPIO_OUT_EN);
+
+			/* boot sequence */
+			for (m = 0; m < TI960_MAX_GPIO_POWERUP_SEQ; m++) {
+				if (va->subdev_pdata[k].gpio_powerup_seq[m] < 0)
+					break;
+				ti953_reg_write(&va->sd, info->rx_port, info->ser_alias,
+						TI953_LOCAL_GPIO_DATA,
+						va->subdev_pdata[k].gpio_powerup_seq[m]);
+				msleep(50);
+			}
+		}
+
+		/* Map PHY I2C address. */
+		rval = ti960_map_phy_i2c_addr(va, info->rx_port,
+					info->phy_i2c_addr);
+		if (rval)
+			return rval;
+
+		/* Map 7bit ALIAS I2C address. */
+		rval = ti960_map_alias_i2c_addr(va, info->rx_port,
+				info->board_info.addr << 1);
+		if (rval)
+			return rval;
+
+		va->sub_devs[k].sd = v4l2_i2c_new_subdev_board(
+			va->sd.v4l2_dev, client->adapter,
+			&info->board_info, 0);
+		if (!va->sub_devs[k].sd) {
+			dev_err(va->sd.dev,
+				"can't create new i2c subdev %c\n",
+				info->suffix);
+			continue;
+		}
+		va->sub_devs[k].rx_port = info->rx_port;
+		va->sub_devs[k].phy_i2c_addr = info->phy_i2c_addr;
+		va->sub_devs[k].alias_i2c_addr = info->board_info.addr;
+		va->sub_devs[k].ser_i2c_addr = info->ser_alias;
+		snprintf(va->sub_devs[k].sd->name, sizeof(va->sd.name), "%s %c",
+			va->subdev_pdata[k].module_name,
+			va->subdev_pdata[k].suffix);
+		memcpy(va->sub_devs[k].sd_name,
+				va->subdev_pdata[k].module_name,
+				min(sizeof(va->sub_devs[k].sd_name) - 1,
+				sizeof(va->subdev_pdata[k].module_name) - 1));
+
+		for (j = 0; j < va->sub_devs[k].sd->entity.num_pads; j++) {
+			if (va->sub_devs[k].sd->entity.pads[j].flags &
+				MEDIA_PAD_FL_SOURCE)
+				break;
+		}
+
+		if (j == va->sub_devs[k].sd->entity.num_pads) {
+			dev_warn(va->sd.dev,
+				"no source pad in subdev %c\n",
+				info->suffix);
+			return -ENOENT;
+		}
+
+		for (l = 0; l < va->nsinks; l++) {
+			rval = media_create_pad_link(
+				&va->sub_devs[k].sd->entity, j,
+				&va->sd.entity, l, MEDIA_LNK_FL_DYNAMIC);
+			if (rval) {
+				dev_err(va->sd.dev,
+					"can't create link to %c\n",
+					info->suffix);
+				return -EINVAL;
+			}
+		}
+		port_registered[va->sub_devs[k].rx_port] = true;
+		k++;
+	}
+	rval = ti960_map_subdevs_addr(va);
+	if (rval)
+		return rval;
+
+	return 0;
+}
+
+static int ti960_set_power(struct v4l2_subdev *subdev, int on)
+{
+	struct ti960 *va = to_ti960(subdev);
+	int ret;
+	u8 val;
+
+	ret = ti960_reg_write(va, TI960_RESET,
+			   (on) ? TI960_POWER_ON : TI960_POWER_OFF);
+	if (ret || !on)
+		return ret;
+
+	/* Select TX port 0 R/W by default */
+	ret = ti960_reg_write(va, 0x32, 0x01);
+	/* Configure MIPI clock bsaed on control value. */
+	ret = ti960_reg_write(va, TI960_CSI_PLL_CTL,
+			    ti960_op_sys_clock_reg_val[
+			    v4l2_ctrl_g_ctrl(va->link_freq)]);
+	if (ret)
+		return ret;
+	val = TI960_CSI_ENABLE;
+	val |= TI960_CSI_CONTS_CLOCK;
+	/* Enable skew calculation when 1.6Gbps output is enabled. */
+	if (v4l2_ctrl_g_ctrl(va->link_freq) == 3) {
+		val |= TI960_CSI_SKEWCAL;
+		/* Enable periodic CSI-2 Skew-Calibration sequence after EOF */
+		ret = ti960_reg_write(va, TI960_CSI_CTL2, 0x09);
+	} else {
+		ret = ti960_reg_write(va, TI960_CSI_CTL2, 0x08);
+	}
+	if (ret)
+		return ret;
+
+	return ti960_reg_write(va, TI960_CSI_CTL, val);
+}
+
+static bool ti960_broadcast_mode(struct v4l2_subdev *subdev)
+{
+	struct ti960 *va = to_ti960(subdev);
+	struct v4l2_subdev_format fmt = { 0 };
+	struct v4l2_subdev *sd;
+	char *sd_name = NULL;
+	bool first = true;
+	unsigned int h = 0, w = 0, code = 0;
+	bool single_stream = true;
+	int i, rval;
+
+	for (i = 0; i < NR_OF_TI960_SINK_PADS; i++) {
+		struct media_pad *remote_pad =
+			media_entity_remote_pad(&va->pad[i]);
+
+		if (!remote_pad)
+			continue;
+
+		if (!ti960_set_sub_stream[i])
+			continue;
+
+		sd = media_entity_to_v4l2_subdev(remote_pad->entity);
+		fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
+		fmt.pad = remote_pad->index;
+
+		rval = v4l2_subdev_call(sd, pad, get_fmt, NULL, &fmt);
+		if (rval)
+			return false;
+
+		if (first) {
+			sd_name = va->sub_devs[i].sd_name;
+			h = fmt.format.height;
+			w = fmt.format.width;
+			code = fmt.format.code;
+			first = false;
+		} else {
+			if (strncmp(sd_name, va->sub_devs[i].sd_name, 16))
+				return false;
+
+			if (h != fmt.format.height || w != fmt.format.width
+				|| code != fmt.format.code)
+				return false;
+
+			single_stream = false;
+		}
+	}
+
+	if (single_stream)
+		return false;
+
+	return true;
+}
+
+static int ti960_rx_port_config(struct ti960 *va, int sink, int rx_port)
+{
+	int rval;
+	int i;
+	unsigned int csi_vc_map;
+
+	/* Select RX port. */
+	rval = ti960_reg_write(va, TI960_RX_PORT_SEL,
+			(rx_port << 4) + (1 << rx_port));
+	if (rval) {
+		dev_err(va->sd.dev, "Failed to select RX port.\n");
+		return rval;
+	}
+
+	rval = ti960_reg_write(va, TI960_PORT_CONFIG,
+		TI960_FPD3_CSI);
+	if (rval) {
+		dev_err(va->sd.dev, "Failed to set port config.\n");
+		return rval;
+	}
+
+	/*
+	 * CSI VC MAPPING.
+	 */
+	csi_vc_map = sink * 0x55;
+	dev_info(va->sd.dev, "%s sink pad %d, rx_port %d, csi_vc_map %x",
+		 __func__, sink, rx_port, csi_vc_map);
+	rval = ti960_reg_write(va, TI960_CSI_VC_MAP,
+			       csi_vc_map);
+	if (rval) {
+		dev_err(va->sd.dev, "Failed to set port config.\n");
+		return rval;
+	}
+	return 0;
+}
+
+static int ti960_find_subdev_index(struct ti960 *va, struct v4l2_subdev *sd)
+{
+	int i;
+
+	for (i = 0; i < NR_OF_TI960_SINK_PADS; i++) {
+		if (va->sub_devs[i].sd == sd)
+			return i;
+	}
+
+	WARN_ON(1);
+
+	return -EINVAL;
+}
+
+static int ti960_find_subdev_index_by_rx_port(struct ti960 *va, u8 rx_port)
+{
+	int i;
+
+	for (i = 0; i < NR_OF_TI960_SINK_PADS; i++) {
+		if (va->sub_devs[i].rx_port == rx_port)
+			return i;
+	}
+	WARN_ON(1);
+
+	return -EINVAL;
+}
+
+static int ti960_set_frame_sync(struct ti960 *va, int enable)
+{
+	int i, rval;
+	int index = !!enable;
+
+	for (i = 0; i < ARRAY_SIZE(ti960_frame_sync_settings[index]); i++) {
+		rval = ti960_reg_write(va,
+				ti960_frame_sync_settings[index][i].reg,
+				ti960_frame_sync_settings[index][i].val);
+		if (rval) {
+			dev_err(va->sd.dev, "Failed to %s frame sync\n",
+				enable ? "enable" : "disable");
+			return rval;
+		}
+	}
+
+	return 0;
+}
+
+static int ti960_set_stream(struct v4l2_subdev *subdev, int enable)
+{
+	struct ti960 *va = to_ti960(subdev);
+	struct v4l2_subdev *sd;
+	int i, j, rval;
+	bool broadcast;
+	unsigned short rx_port;
+	unsigned short ser_alias;
+	int sd_idx = -1;
+	DECLARE_BITMAP(rx_port_enabled, 32);
+
+	dev_dbg(va->sd.dev, "TI960 set stream, enable %d\n", enable);
+
+	broadcast = ti960_broadcast_mode(subdev);
+	if (enable)
+		dev_info(va->sd.dev, "TI960 in %s mode",
+			broadcast ? "broadcast" : "non broadcast");
+
+	bitmap_zero(rx_port_enabled, 32);
+	for (i = 0; i < NR_OF_TI960_SINK_PADS; i++) {
+		struct media_pad *remote_pad =
+			media_entity_remote_pad(&va->pad[i]);
+
+		if (!remote_pad)
+			continue;
+
+		if (!ti960_set_sub_stream[i])
+			continue;
+
+		/* Find ti960 subdev */
+		sd = media_entity_to_v4l2_subdev(remote_pad->entity);
+		j = ti960_find_subdev_index(va, sd);
+		if (j < 0)
+			return -EINVAL;
+		rx_port = va->sub_devs[j].rx_port;
+		ser_alias = va->sub_devs[j].ser_i2c_addr;
+		rval = ti960_rx_port_config(va, i, rx_port);
+		if (rval < 0)
+			return rval;
+
+		bitmap_set(rx_port_enabled, rx_port, 1);
+
+		if (broadcast && sd_idx == -1) {
+			sd_idx = j;
+		} else if (broadcast) {
+			rval = ti960_map_alias_i2c_addr(va, rx_port,
+				va->sub_devs[sd_idx].alias_i2c_addr << 1);
+			if (rval < 0)
+				return rval;
+		} else {
+			/* Stream on/off sensor */
+			dev_err(va->sd.dev,
+					"set stream for %s, enable  %d\n",
+					sd->name, enable);
+			rval = v4l2_subdev_call(sd, video, s_stream, enable);
+			if (rval) {
+				dev_err(va->sd.dev,
+					"Failed to set stream for %s, enable  %d\n",
+					sd->name, enable);
+				return rval;
+			}
+
+			/* RX port fordward */
+			rval = ti960_reg_set_bit(va, TI960_FWD_CTL1,
+						rx_port + 4, !enable);
+			if (rval) {
+				dev_err(va->sd.dev,
+					"Failed to forward RX port%d. enable %d\n",
+					i, enable);
+				return rval;
+			}
+			if (va->subdev_pdata[j].module_flags & TI960_FL_RESET) {
+				rval = reset_sensor(va, rx_port, ser_alias,
+						va->subdev_pdata[j].reset);
+				if (rval)
+					return rval;
+			}
+		}
+	}
+
+	if (broadcast) {
+		if (sd_idx < 0) {
+			dev_err(va->sd.dev, "No sensor connected!\n");
+			return -ENODEV;
+		}
+		sd = va->sub_devs[sd_idx].sd;
+		rval = v4l2_subdev_call(sd, video, s_stream, enable);
+		if (rval) {
+			dev_err(va->sd.dev,
+				"Failed to set stream for %s. enable  %d\n",
+				sd->name, enable);
+			return rval;
+		}
+
+		rval = ti960_set_frame_sync(va, enable);
+		if (rval) {
+			dev_err(va->sd.dev,
+				"Failed to set frame sync.\n");
+			return rval;
+		}
+
+		for (i = 0; i < NR_OF_TI960_SINK_PADS; i++) {
+			if (enable && test_bit(i, rx_port_enabled)) {
+				rval = ti960_fsin_gpio_init(va,
+						va->sub_devs[i].rx_port,
+						va->sub_devs[i].ser_i2c_addr,
+						va->sub_devs[i].fsin_gpio);
+				if (rval) {
+					dev_err(va->sd.dev,
+						"Failed to enable frame sync gpio init.\n");
+					return rval;
+				}
+
+				if (va->subdev_pdata[i].module_flags & TI960_FL_RESET) {
+					rx_port = va->sub_devs[i].rx_port;
+					ser_alias = va->sub_devs[i].ser_i2c_addr;
+					rval = reset_sensor(va, rx_port, ser_alias,
+							va->subdev_pdata[i].reset);
+					if (rval)
+						return rval;
+				}
+			}
+		}
+
+		for (i = 0; i < NR_OF_TI960_SINK_PADS; i++) {
+			if (!test_bit(i, rx_port_enabled))
+				continue;
+
+			/* RX port fordward */
+			rval = ti960_reg_set_bit(va, TI960_FWD_CTL1,
+						i + 4, !enable);
+			if (rval) {
+				dev_err(va->sd.dev,
+					"Failed to forward RX port%d. enable %d\n",
+					i, enable);
+				return rval;
+			}
+		}
+
+		/*
+		 * Restore each subdev i2c address as we may
+		 * touch it later.
+		 */
+		rval = ti960_map_subdevs_addr(va);
+		if (rval)
+			return rval;
+	}
+
+	return 0;
+}
+
+static int ti960_set_stream_vc(struct ti960 *va, u8 vc_id, u8 state)
+{
+	unsigned short rx_port;
+	unsigned short ser_alias;
+	struct v4l2_subdev *sd;
+	int rval;
+	int i;
+
+	i = ti960_find_subdev_index_by_rx_port(va, vc_id);
+	if (i < 0)
+		return -EINVAL;
+	rx_port = va->sub_devs[i].rx_port;
+	ser_alias = va->sub_devs[i].ser_i2c_addr;
+	sd = va->sub_devs[i].sd;
+
+	rval = ti960_rx_port_config(va, vc_id, rx_port);
+	if (rval < 0)
+		return rval;
+
+	rval = v4l2_subdev_call(sd, video, s_stream, state);
+	if (rval) {
+		dev_err(va->sd.dev,
+				"Failed to set stream for %s, enable %d\n",
+				sd->name, state);
+		return rval;
+	}
+	dev_info(va->sd.dev, "set stream for %s, enable %d\n",
+			sd->name, state);
+
+	/* RX port fordward */
+	rval = ti960_reg_set_bit(va, TI960_FWD_CTL1,
+			rx_port + 4, !state);
+	if (rval) {
+		dev_err(va->sd.dev,
+				"Failed to forward RX port%d. enable %d\n",
+				i, state);
+		return rval;
+	}
+	if (va->subdev_pdata[i].module_flags & TI960_FL_RESET) {
+		rval = reset_sensor(va, rx_port, ser_alias,
+				va->subdev_pdata[i].reset);
+		if (rval)
+			return rval;
+	}
+
+	return 0;
+}
+
+static struct v4l2_subdev_internal_ops ti960_sd_internal_ops = {
+	.open = ti960_open,
+	.registered = ti960_registered,
+};
+
+static const struct v4l2_subdev_video_ops ti960_sd_video_ops = {
+	.s_stream = ti960_set_stream,
+};
+
+static const struct v4l2_subdev_core_ops ti960_core_subdev_ops = {
+	.s_power = ti960_set_power,
+};
+
+static int ti960_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct ti960 *va = container_of(ctrl->handler,
+					     struct ti960, ctrl_handler);
+	struct i2c_client *client = v4l2_get_subdevdata(&va->sd);
+	u32 val;
+	u8 vc_id;
+	u8 state;
+
+	switch (ctrl->id) {
+	case V4L2_CID_IPU_SET_SUB_STREAM:
+		val = (*ctrl->p_new.p_s64 & 0xFFFF);
+		dev_info(va->sd.dev, "V4L2_CID_IPU_SET_SUB_STREAM %x\n", val);
+		vc_id = (val >> 8) & 0x00FF;
+		state = val & 0x00FF;
+		if (vc_id > NR_OF_TI960_SINK_PADS - 1)
+			dev_err(va->sd.dev, "invalid vc %d\n", vc_id);
+		else
+			ti960_set_sub_stream[vc_id] = state;
+
+		ti960_set_stream_vc(va, vc_id, state);
+		break;
+	default:
+		dev_info(va->sd.dev, "unknown control id: 0x%X\n", ctrl->id);
+	}
+
+	return 0;
+}
+
+static const struct v4l2_ctrl_ops ti960_ctrl_ops = {
+	.s_ctrl = ti960_s_ctrl,
+};
+
+static const struct v4l2_ctrl_config ti960_controls[] = {
+	{
+		.ops = &ti960_ctrl_ops,
+		.id = V4L2_CID_LINK_FREQ,
+		.name = "V4L2_CID_LINK_FREQ",
+		.type = V4L2_CTRL_TYPE_INTEGER_MENU,
+		.min = 0,
+		.max = ARRAY_SIZE(ti960_op_sys_clock) - 1,
+		.def = 3,
+		.menu_skip_mask = 0,
+		.qmenu_int = ti960_op_sys_clock,
+	},
+	{
+		.ops = &ti960_ctrl_ops,
+		.id = V4L2_CID_TEST_PATTERN,
+		.name = "V4L2_CID_TEST_PATTERN",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = 0,
+		.max = 1,
+		.step = 1,
+		.def = 0,
+	},
+	{
+		.ops = &ti960_ctrl_ops,
+		.id = V4L2_CID_IPU_QUERY_SUB_STREAM,
+		.name = "query virtual channel",
+		.type = V4L2_CTRL_TYPE_INTEGER_MENU,
+		.max = ARRAY_SIZE(ti960_query_sub_stream) - 1,
+		.min = 0,
+		.def = 0,
+		.menu_skip_mask = 0,
+		.qmenu_int = ti960_query_sub_stream,
+	},
+	{
+		.ops = &ti960_ctrl_ops,
+		.id = V4L2_CID_IPU_SET_SUB_STREAM,
+		.name = "set virtual channel",
+		.type = V4L2_CTRL_TYPE_INTEGER64,
+		.max = 0xFFFF,
+		.min = 0,
+		.def = 0,
+		.step = 1,
+	},
+};
+
+static const struct v4l2_subdev_pad_ops ti960_sd_pad_ops = {
+	.get_fmt = ti960_get_format,
+	.set_fmt = ti960_set_format,
+	.get_frame_desc = ti960_get_frame_desc,
+	.enum_mbus_code = ti960_enum_mbus_code,
+};
+
+static struct v4l2_subdev_ops ti960_sd_ops = {
+	.core = &ti960_core_subdev_ops,
+	.video = &ti960_sd_video_ops,
+	.pad = &ti960_sd_pad_ops,
+};
+
+static int ti960_register_subdev(struct ti960 *va)
+{
+	int i, rval;
+	struct i2c_client *client = v4l2_get_subdevdata(&va->sd);
+
+	v4l2_subdev_init(&va->sd, &ti960_sd_ops);
+	snprintf(va->sd.name, sizeof(va->sd.name), "TI960 %c",
+		va->pdata->suffix);
+
+	va->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	va->sd.internal_ops = &ti960_sd_internal_ops;
+	va->sd.entity.function = MEDIA_ENT_F_VID_MUX;
+
+	v4l2_set_subdevdata(&va->sd, client);
+
+	v4l2_ctrl_handler_init(&va->ctrl_handler,
+				ARRAY_SIZE(ti960_controls));
+
+	if (va->ctrl_handler.error) {
+		dev_err(va->sd.dev,
+			"Failed to init ti960 controls. ERR: %d!\n",
+			va->ctrl_handler.error);
+		return va->ctrl_handler.error;
+	}
+
+	va->sd.ctrl_handler = &va->ctrl_handler;
+
+	for (i = 0; i < ARRAY_SIZE(ti960_controls); i++) {
+		const struct v4l2_ctrl_config *cfg =
+			&ti960_controls[i];
+		struct v4l2_ctrl *ctrl;
+
+		ctrl = v4l2_ctrl_new_custom(&va->ctrl_handler, cfg, NULL);
+		if (!ctrl) {
+			dev_err(va->sd.dev,
+				"Failed to create ctrl %s!\n", cfg->name);
+			rval = va->ctrl_handler.error;
+			goto failed_out;
+		}
+	}
+
+	va->link_freq = v4l2_ctrl_find(&va->ctrl_handler, V4L2_CID_LINK_FREQ);
+	va->test_pattern = v4l2_ctrl_find(&va->ctrl_handler,
+					  V4L2_CID_TEST_PATTERN);
+
+	for (i = 0; i < va->nsinks; i++)
+		va->pad[i].flags = MEDIA_PAD_FL_SINK;
+	va->pad[TI960_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+	rval = media_entity_pads_init(&va->sd.entity,
+				      NR_OF_TI960_PADS, va->pad);
+	if (rval) {
+		dev_err(va->sd.dev,
+			"Failed to init media entity for ti960!\n");
+		goto failed_out;
+	}
+
+	return 0;
+
+failed_out:
+	v4l2_ctrl_handler_free(&va->ctrl_handler);
+	return rval;
+}
+
+static int ti960_init(struct ti960 *va)
+{
+	unsigned int reset_gpio = va->pdata->reset_gpio;
+	int i, rval;
+	unsigned int val;
+
+#ifdef TI960_RESET_NEEDED
+	/* TI960 PDB pulled up to high by HW design in some board */
+	gpio_set_value(reset_gpio, 1);
+	usleep_range(2000, 3000);
+	dev_err(va->sd.dev, "Setting reset gpio %d to 1.\n", reset_gpio);
+#endif
+
+	bus_switch(va);
+	usleep_range(8000, 9000);
+
+	rval = ti960_reg_read(va, TI960_DEVID, &val);
+	if (rval) {
+		dev_err(va->sd.dev, "Failed to read device ID of TI960!\n");
+		return rval;
+	}
+	dev_info(va->sd.dev, "TI960 device ID: 0x%X\n", val);
+	for (i = 0; i < ARRAY_SIZE(ti960_gpio_settings); i++) {
+		rval = ti960_reg_write(va,
+			ti960_gpio_settings[i].reg,
+			ti960_gpio_settings[i].val);
+		if (rval) {
+			dev_err(va->sd.dev,
+				"Failed to write TI960 gpio setting, reg %2x, val %2x\n",
+				ti960_gpio_settings[i].reg, ti960_gpio_settings[i].val);
+			return rval;
+		}
+	}
+	usleep_range(10000, 11000);
+
+	for (i = 0; i < ARRAY_SIZE(ti960_init_settings); i++) {
+		if (ti960_init_settings[i].reg == 0) {
+			usleep_range(ti960_init_settings[i].val * 1000, ti960_init_settings[i].val * 1000);
+			continue;
+		}
+		rval = ti960_reg_write(va,
+			ti960_init_settings[i].reg,
+			ti960_init_settings[i].val);
+		if (rval) {
+			dev_err(va->sd.dev,
+				"Failed to write TI960 init setting, reg %2x, val %2x\n",
+				ti960_init_settings[i].reg, ti960_init_settings[i].val);
+			return rval;
+		}
+	}
+	/* wait for ti953 ready */
+	msleep(200);
+
+	rval = ti960_map_subdevs_addr(va);
+	if (rval)
+		return rval;
+
+	return 0;
+}
+
+static void ti960_gpio_set(struct gpio_chip *chip, unsigned int gpio, int value)
+{
+	struct i2c_client *client = to_i2c_client(chip->parent);
+	struct v4l2_subdev *subdev = i2c_get_clientdata(client);
+	struct ti960 *va = to_ti960(subdev);
+	unsigned int reg_val;
+	int rx_port, gpio_port;
+	int ret;
+
+	if (gpio >= NR_OF_TI960_GPIOS)
+		return;
+
+	rx_port = gpio / NR_OF_GPIOS_PER_PORT;
+	gpio_port = gpio % NR_OF_GPIOS_PER_PORT;
+
+	ret = ti960_reg_write(va, TI960_RX_PORT_SEL,
+			  (rx_port << 4) + (1 << rx_port));
+	if (ret) {
+		dev_dbg(&client->dev, "Failed to select RX port.\n");
+		return;
+	}
+	ret = regmap_read(va->regmap8, TI960_BC_GPIO_CTL0, &reg_val);
+	if (ret) {
+		dev_dbg(&client->dev, "Failed to read gpio status.\n");
+		return;
+	}
+
+	if (gpio_port == 0) {
+		reg_val &= ~TI960_GPIO0_MASK;
+		reg_val |= value ? TI960_GPIO0_HIGH : TI960_GPIO0_LOW;
+	} else {
+		reg_val &= ~TI960_GPIO1_MASK;
+		reg_val |= value ? TI960_GPIO1_HIGH : TI960_GPIO1_LOW;
+	}
+
+	ret = ti960_reg_write(va, TI960_BC_GPIO_CTL0, reg_val);
+	if (ret)
+		dev_dbg(&client->dev, "Failed to set gpio.\n");
+}
+
+static int ti960_gpio_direction_output(struct gpio_chip *chip,
+				       unsigned int gpio, int level)
+{
+	return 0;
+}
+
+static int ti960_probe(struct i2c_client *client,
+			const struct i2c_device_id *devid)
+{
+	struct ti960 *va;
+	int i, j, k, l, rval = 0;
+	int gpio_FPD = 0;
+
+	if (client->dev.platform_data == NULL)
+		return -ENODEV;
+
+	va = devm_kzalloc(&client->dev, sizeof(*va), GFP_KERNEL);
+	if (!va)
+		return -ENOMEM;
+
+	va->pdata = client->dev.platform_data;
+
+	va->nsources = NR_OF_TI960_SOURCE_PADS;
+	va->nsinks = NR_OF_TI960_SINK_PADS;
+	va->npads = NR_OF_TI960_PADS;
+	va->nstreams = NR_OF_TI960_STREAMS;
+
+	va->crop = devm_kcalloc(&client->dev, va->npads,
+				sizeof(struct v4l2_rect), GFP_KERNEL);
+
+	va->compose = devm_kcalloc(&client->dev, va->npads,
+				   sizeof(struct v4l2_rect), GFP_KERNEL);
+
+	if (!va->crop || !va->compose)
+		return -ENOMEM;
+
+	for (i = 0; i < va->npads; i++) {
+		va->ffmts[i] = devm_kcalloc(&client->dev, va->nstreams,
+					    sizeof(struct v4l2_mbus_framefmt),
+					    GFP_KERNEL);
+		if (!va->ffmts[i])
+			return -ENOMEM;
+	}
+
+	va->regmap8 = devm_regmap_init_i2c(client,
+					   &ti960_reg_config8);
+	if (IS_ERR(va->regmap8)) {
+		dev_err(&client->dev, "Failed to init regmap8!\n");
+		return -EIO;
+	}
+
+	va->regmap16 = devm_regmap_init_i2c(client,
+					    &ti960_reg_config16);
+	if (IS_ERR(va->regmap16)) {
+		dev_err(&client->dev, "Failed to init regmap16!\n");
+		return -EIO;
+	}
+
+	mutex_init(&va->mutex);
+	v4l2_i2c_subdev_init(&va->sd, client, &ti960_sd_ops);
+	rval = ti960_register_subdev(va);
+	if (rval) {
+		dev_err(&client->dev, "Failed to register va subdevice!\n");
+		return rval;
+	}
+
+#ifdef TI960_RESET_NEEDED
+	if (devm_gpio_request_one(va->sd.dev, va->pdata->reset_gpio, 0,
+				  "ti960 reset") != 0) {
+		dev_err(va->sd.dev, "Unable to acquire gpio %d\n",
+			va->pdata->reset_gpio);
+		return -ENODEV;
+	}
+#endif
+
+	if (va->pdata->FPD_gpio != -1) {
+		rval = devm_gpio_request_one(&client->dev,
+			va->pdata->FPD_gpio,
+			GPIOF_OUT_INIT_LOW, "Cam");
+		if (rval) {
+			dev_err(&client->dev,
+				"camera power GPIO pin request failed!\n");
+			return rval;
+		}
+
+		/* pull up GPPC_B23 to high for FPD link power */
+		gpio_FPD = gpio_get_value(va->pdata->FPD_gpio);
+		if (gpio_FPD == 0)
+			gpio_set_value(va->pdata->FPD_gpio, 1);
+	}
+
+	rval = ti960_init(va);
+	if (rval) {
+		dev_err(&client->dev, "Failed to init TI960!\n");
+		goto free_gpio;
+	}
+
+	/*
+	 * TI960 has several back channel GPIOs.
+	 * We export GPIO0 and GPIO1 to control reset or fsin.
+	 */
+	va->gc.parent = &client->dev;
+	va->gc.owner = THIS_MODULE;
+	va->gc.label = "TI960 GPIO";
+	va->gc.ngpio = NR_OF_TI960_GPIOS;
+	va->gc.base = -1;
+	va->gc.set = ti960_gpio_set;
+	va->gc.direction_output = ti960_gpio_direction_output;
+	rval = gpiochip_add(&va->gc);
+	if (rval) {
+		dev_err(&client->dev, "Failed to add gpio chip! %d\n", rval);
+		rval = -EIO;
+		goto free_gpio;
+	}
+
+	return 0;
+
+free_gpio:
+	if (va->pdata->FPD_gpio != -1) {
+		dev_err(&client->dev, "restore and free FPD gpio!\n");
+		/* restore GPPC_B23 */
+		if (gpio_FPD == 0)
+			gpio_set_value(va->pdata->FPD_gpio, 0);
+
+		devm_gpio_free(&client->dev,
+			va->pdata->FPD_gpio);
+	}
+
+	return rval;
+}
+
+static int ti960_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *subdev = i2c_get_clientdata(client);
+	struct ti960 *va = to_ti960(subdev);
+	int i;
+
+	if (!va)
+		return 0;
+
+	mutex_destroy(&va->mutex);
+	v4l2_ctrl_handler_free(&va->ctrl_handler);
+	v4l2_device_unregister_subdev(&va->sd);
+	media_entity_cleanup(&va->sd.entity);
+
+	for (i = 0; i < NR_OF_TI960_SINK_PADS; i++) {
+		if (va->sub_devs[i].sd) {
+			struct i2c_client *sub_client =
+				v4l2_get_subdevdata(va->sub_devs[i].sd);
+
+			i2c_unregister_device(sub_client);
+		}
+		va->sub_devs[i].sd = NULL;
+	}
+
+	gpiochip_remove(&va->gc);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int ti960_suspend(struct device *dev)
+{
+	return 0;
+}
+
+static int ti960_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *subdev = i2c_get_clientdata(client);
+	struct ti960 *va = to_ti960(subdev);
+
+	return ti960_init(va);
+}
+#else
+#define ti960_suspend	NULL
+#define ti960_resume	NULL
+#endif /* CONFIG_PM */
+
+static const struct i2c_device_id ti960_id_table[] = {
+	{ TI960_NAME, 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, ti960_id_table);
+
+static const struct dev_pm_ops ti960_pm_ops = {
+	.suspend = ti960_suspend,
+	.resume = ti960_resume,
+};
+
+static struct i2c_driver ti960_i2c_driver = {
+	.driver = {
+		.name = TI960_NAME,
+		.pm = &ti960_pm_ops,
+	},
+	.probe	= ti960_probe,
+	.remove	= ti960_remove,
+	.id_table = ti960_id_table,
+};
+module_i2c_driver(ti960_i2c_driver);
+
+MODULE_AUTHOR("Chen Meng J <meng.j.chen@intel.com>");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("TI960 CSI2-Aggregator driver");
Index: b/drivers/media/i2c/ti960-reg.h
===================================================================
--- /dev/null
+++ b/drivers/media/i2c/ti960-reg.h
@@ -0,0 +1,150 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2022 Intel Corporation */
+
+#ifndef TI960_REG_H
+#define TI960_REG_H
+
+struct ti960_register_write {
+	u8 reg;
+	u8 val;
+};
+
+struct ti960_register_devid {
+	u8 reg;
+	u8 val_expected;
+};
+
+static const struct ti960_register_write ti960_frame_sync_settings[2][5] = {
+	{
+		{0x18, 0x00}, /* Disable frame sync. */
+		{0x19, 0x00},
+		{0x1a, 0x00},
+		{0x1b, 0x00},
+		{0x1c, 0x00},
+	},
+	{
+		{0x19, 0x15}, /* Frame sync high time.*/
+		{0x1a, 0xb3},
+		{0x1b, 0xc3}, /* Frame sync low time. */
+		{0x1c, 0x4f},
+		{0x18, 0x01}, /* Enable frame sync. and use high/low mode */
+	}
+};
+
+static const struct ti960_register_write ti960_gpio_settings[] = {
+	{0x10, 0x81},
+	{0x11, 0x85},
+	{0x12, 0x89},
+	{0x13, 0x8d},
+};
+
+static const struct ti960_register_write ti960_init_settings[] = {
+	{0x0c, 0x0f}, /* RX_PORT_CTL */
+	{0x1f, 0x06}, /* CSI_PLL_CTL */
+	{0x4c, 0x01}, /* FPD3_PORT_SEL */
+	{0x58, 0x5e}, /* BCC_CONFIG */
+	{0x5c, 0xb0}, /* SER_ALIAS_ID */
+	{0x5d, 0x6c}, /* SlaveID[0] */
+	{0x65, 0x60}, /* SlaveAlias[0] */
+	{0x6d, 0x7c}, /* PORT_CONFIG */
+	{0x7c, 0x01}, /* PORT_CONFIG2 */
+	{0x70, 0x2b}, /* RAW10_ID */
+	{0x71, 0x2c}, /* RAW12_ID */
+	{0x72, 0xe4}, /* CSI_VC_MAP */
+	{0x4c, 0x12}, /* FPD3_PORT_SEL */
+	{0x58, 0x5e},
+	{0x5c, 0xb2},
+	{0x5d, 0x6c},
+	{0x65, 0x62},
+	{0x6d, 0x7c},
+	{0x7c, 0x01},
+	{0x70, 0x2b},
+	{0x71, 0x2c},
+	{0x72, 0xee}, /* CSI_VC_MAP */
+	{0x4c, 0x24}, /* FPD3_PORT_SEL */
+	{0x58, 0x5e},
+	{0x5c, 0xb4},
+	{0x5d, 0x6c},
+	{0x65, 0x64},
+	{0x6d, 0x7c},
+	{0x7c, 0x01},
+	{0x70, 0x2b},
+	{0x71, 0x2c},
+	{0x72, 0xe4},
+	{0x4c, 0x38}, /* FPD3_PORT_SEL */
+	{0x58, 0x5e},
+	{0x5c, 0xb6},
+	{0x5d, 0x6c},
+	{0x65, 0x66},
+	{0x6d, 0x7c},
+	{0x7c, 0x01},
+	{0x70, 0x2b},
+	{0x71, 0x2c},
+	{0x72, 0xe4},
+	{0xb0, 0x14}, /* FPD3 RX Shared Reg */
+	{0xb1, 0x03},
+	{0xb2, 0x04},
+	{0xb1, 0x04},
+	{0xb2, 0x04},
+	{0x32, 0x12}, /* select TX1 R/W */
+	{0x33, 0x03}, /* CSI_ENABLE, CONTS_CLOCK */
+	{0x34, 0x08}, /* CSI_PASS_MODE all */
+	{0x32, 0x01}, /* select TX0 R/W */
+	{0x33, 0x03}, /* CSI_ENABLE, CONTS_CLOCK */
+	{0x34, 0x08}, /* CSI_PASS_MODE all */
+	{0x20, 0xf0},
+	{0x21, 0x03},
+};
+
+/* register definition */
+#define TI960_DEVID		0x0
+#define TI960_RESET		0x1
+#define TI960_CSI_PLL_CTL	0x1f
+#define TI960_FS_CTL		0x18
+#define TI960_FWD_CTL1		0x20
+#define TI960_RX_PORT_SEL	0x4c
+#define TI960_SER_ALIAS_ID	0x5c
+#define TI960_SLAVE_ID0		0x5d
+#define TI960_SLAVE_ALIAS_ID0	0x65
+#define TI960_PORT_CONFIG	0x6d
+#define TI960_BC_GPIO_CTL0	0x6e
+#define TI960_BC_GPIO_CTL1	0x6f
+#define TI960_RAW10_ID		0x70
+#define TI960_RAW12_ID		0x71
+#define TI960_CSI_VC_MAP	0x72
+#define TI960_PORT_CONFIG2	0x7c
+#define TI960_CSI_CTL		0x33
+#define TI960_CSI_CTL2		0x34
+
+/* register value definition */
+#define TI960_POWER_ON		0x1
+#define TI960_POWER_OFF		0x20
+#define TI960_FPD3_RAW10_100MHz	0x7f
+#define TI960_FPD3_RAW12_50MHz	0x7d
+#define TI960_FPD3_RAW12_75MHz	0x7e
+#define TI960_FPD3_CSI		0x7c
+#define TI960_RAW12		0x41
+#define TI960_RAW10_NORMAL	0x1
+#define TI960_RAW10_8BIT	0x81
+#define TI960_GPIO0_HIGH	0x09
+#define TI960_GPIO0_LOW		0x08
+#define TI960_GPIO1_HIGH	0x90
+#define TI960_GPIO1_LOW		0x80
+#define TI960_GPIO0_FSIN	0x0a
+#define TI960_GPIO1_FSIN	0xa0
+#define TI960_GPIO0_MASK	0x0f
+#define TI960_GPIO1_MASK	0xf0
+#define TI960_GPIO2_FSIN	0x0a
+#define TI960_GPIO3_FSIN	0xa0
+#define TI960_GPIO2_MASK	0x0f
+#define TI960_GPIO3_MASK	0xf0
+#define TI960_MIPI_400MBPS	0x3
+#define TI960_MIPI_800MBPS	0x2
+#define TI960_MIPI_1200MBPS	0x1
+#define TI960_MIPI_1600MBPS	0x0
+#define TI960_CSI_ENABLE	0x1
+#define TI960_CSI_CONTS_CLOCK	0x2
+#define TI960_CSI_SKEWCAL	0x40
+#define TI960_FSIN_ENABLE	0x1
+
+#endif
Index: b/drivers/media/i2c/ti964-reg.h
===================================================================
--- /dev/null
+++ b/drivers/media/i2c/ti964-reg.h
@@ -0,0 +1,128 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2016 - 2020 Intel Corporation */
+
+#ifndef TI964_REG_H
+#define TI964_REG_H
+
+struct ti964_register_write {
+	u8 reg;
+	u8 val;
+};
+
+static const struct ti964_register_write ti964_frame_sync_settings[2][5] = {
+	{
+		{0x18, 0x00}, /* Disable frame sync. */
+		{0x19, 0x00},
+		{0x1a, 0x02},
+		{0x1b, 0x0a},
+		{0x1c, 0xd3},
+	},
+	{
+		{0x19, 0x01}, /* Frame sync high time.*/
+		{0x1a, 0x15},
+		{0x1b, 0x09}, /* Frame sync low time. */
+		{0x1c, 0xC3},
+		{0x18, 0x01}, /* Enable frame sync. and use high/low mode */
+	}
+};
+
+static const struct ti964_register_write ti964_init_settings[] = {
+	{0x8, 0x1c},
+	{0xa, 0x79},
+	{0xb, 0x79},
+	{0xd, 0xb9},
+	{0x10, 0x91},
+	{0x11, 0x85},
+	{0x12, 0x89},
+	{0x13, 0xc1},
+	{0x17, 0xe1},
+	{0x18, 0x0}, /* Disable frame sync. */
+	{0x19, 0x0}, /* Frame sync high time. */
+	{0x1a, 0x2},
+	{0x1b, 0xa}, /* Frame sync low time. */
+	{0x1c, 0xd3},
+	{0x21, 0x43}, /* Enable best effort mode. */
+	{0xb0, 0x10},
+	{0xb1, 0x14},
+	{0xb2, 0x1f},
+	{0xb3, 0x8},
+	{0x32, 0x1}, /* Select CSI port 0 */
+	{0x4c, 0x1}, /* Select RX port 0 */
+	{0x58, 0x58},
+	{0x5c, 0x18}, /* TI913 alias addr 0xc */
+	{0x6d, 0x7f},
+	{0x70, 0x1e}, /* YUV422_8 */
+	{0x7c, 0x81}, /* Use RAW10 8bit mode */
+	{0xd2, 0x84},
+	{0x4c, 0x12}, /* Select RX port 1 */
+	{0x58, 0x58},
+	{0x5c, 0x1a}, /* TI913 alias addr 0xd */
+	{0x6d, 0x7f},
+	{0x70, 0x5e}, /* YUV422_8 */
+	{0x7c, 0x81}, /* Use RAW10 8bit mode */
+	{0xd2, 0x84},
+	{0x4c, 0x24}, /* Select RX port 2*/
+	{0x58, 0x58},
+	{0x5c, 0x1c}, /* TI913 alias addr 0xe */
+	{0x6d, 0x7f},
+	{0x70, 0x9e}, /* YUV422_8 */
+	{0x7c, 0x81}, /* Use RAW10 8bit mode */
+	{0xd2, 0x84},
+	{0x4c, 0x38}, /* Select RX port3 */
+	{0x58, 0x58},
+	{0x5c, 0x1e}, /* TI913 alias addr 0xf */
+	{0x6d, 0x7f},
+	{0x70, 0xde}, /* YUV422_8 */
+	{0x7c, 0x81}, /* Use RAW10 8bit mode */
+	{0xd2, 0x84},
+	{0xbc, 0x00},
+};
+
+static const struct ti964_register_write ti964_tp_settings[] = {
+	{0xb0, 0x0},
+	{0xb1, 0x02},
+	{0xb2, 0xb3},
+	{0xb1, 0x01},
+};
+/*register definition */
+#define TI964_DEVID		0x0
+#define TI964_RESET		0x1
+#define TI964_CSI_PLL_CTL	0x1f
+#define TI964_FS_CTL		0x18
+#define TI964_FWD_CTL1		0x20
+#define TI964_RX_PORT_SEL	0x4c
+#define TI964_SLAVE_ID0		0x5d
+#define TI964_SLAVE_ALIAS_ID0	0x65
+#define TI964_PORT_CONFIG	0x6d
+#define TI964_BC_GPIO_CTL0	0x6e
+#define TI964_RAW10_ID		0x70
+#define TI964_RAW12_ID		0x71
+#define TI964_PORT_CONFIG2	0x7c
+
+#define TI964_IND_ACC_DATA	0xb2
+#define TI964_CSI_CTL           0x33
+
+/* register value definition */
+#define TI964_POWER_ON		0x1
+#define TI964_POWER_OFF		0x20
+#define TI964_FPD3_RAW10_100MHz	0x7f
+#define TI964_FPD3_RAW12_50MHz	0x7d
+#define TI964_FPD3_RAW12_75MHz	0x7e
+#define TI964_RAW12		0x41
+#define TI964_RAW10_NORMAL	0x1
+#define TI964_RAW10_8BIT	0x81
+#define TI964_GPIO0_HIGH	0x09
+#define TI964_GPIO0_LOW		0x08
+#define TI964_GPIO1_HIGH	0x90
+#define TI964_GPIO1_LOW		0x80
+#define TI964_GPIO0_FSIN	0x0a
+#define TI964_GPIO1_FSIN	0xa0
+#define TI964_GPIO0_MASK	0x0f
+#define TI964_GPIO1_MASK	0xf0
+#define TI964_MIPI_800MBPS	0x2
+#define TI964_MIPI_1600MBPS	0x0
+#define TI964_CSI_ENABLE	0x1
+#define TI964_CSI_CONTS_CLOCK	0x2
+#define TI964_CSI_SKEWCAL	0x40
+#define TI964_FSIN_ENABLE	0x1
+#endif
Index: b/drivers/media/i2c/ti964.c
===================================================================
--- /dev/null
+++ b/drivers/media/i2c/ti964.c
@@ -0,0 +1,1342 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) 2016 - 2022 Intel Corporation
+
+#include <linux/device.h>
+#include <linux/gpio.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/wait.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/version.h>
+
+#include <media/media-device.h>
+#include <media/media-entity.h>
+#include <media/ti964.h>
+#include <media/v4l2-device.h>
+#include <media/videobuf2-core.h>
+
+#include "ti964-reg.h"
+
+struct ti964_subdev {
+	struct v4l2_subdev *sd;
+	unsigned short rx_port;
+	unsigned short fsin_gpio;
+	unsigned short phy_i2c_addr;
+	unsigned short alias_i2c_addr;
+	char sd_name[16];
+};
+
+struct ti964 {
+	struct v4l2_subdev sd;
+	struct media_pad pad[NR_OF_TI964_PADS];
+	struct v4l2_ctrl_handler ctrl_handler;
+	struct ti964_pdata *pdata;
+	struct ti964_subdev sub_devs[NR_OF_TI964_SINK_PADS];
+	struct ti964_platform_data subdev_pdata[NR_OF_TI964_SINK_PADS];
+	const char *name;
+
+	struct mutex mutex;
+
+	struct regmap *regmap8;
+	struct regmap *regmap16;
+
+	struct v4l2_mbus_framefmt *ffmts[NR_OF_TI964_PADS];
+	struct rect *crop;
+	struct rect *compose;
+
+	struct {
+		unsigned int *stream_id;
+	} *stream; /* stream enable/disable status, indexed by pad */
+	struct {
+		unsigned int sink;
+		unsigned int source;
+		int flags;
+	} *route; /* pad level info, indexed by stream */
+
+	unsigned int nsinks;
+	unsigned int nsources;
+	unsigned int nstreams;
+	unsigned int npads;
+
+	struct gpio_chip gc;
+
+	struct v4l2_ctrl *link_freq;
+	struct v4l2_ctrl *test_pattern;
+};
+
+#define to_ti964(_sd) container_of(_sd, struct ti964, sd)
+
+static const s64 ti964_op_sys_clock[] =  {400000000, 800000000};
+static const u8 ti964_op_sys_clock_reg_val[] = {
+	TI964_MIPI_800MBPS,
+	TI964_MIPI_1600MBPS
+};
+
+/*
+ * Order matters.
+ *
+ * 1. Bits-per-pixel, descending.
+ * 2. Bits-per-pixel compressed, descending.
+ * 3. Pixel order, same as in pixel_order_str. Formats for all four pixel
+ *    orders must be defined.
+ */
+static const struct ti964_csi_data_format va_csi_data_formats[] = {
+	{ MEDIA_BUS_FMT_YUYV8_1X16, 16, 16, PIXEL_ORDER_GBRG, 0x1e },
+	{ MEDIA_BUS_FMT_UYVY8_1X16, 16, 16, PIXEL_ORDER_GBRG, 0x1e },
+	{ MEDIA_BUS_FMT_SGRBG12_1X12, 12, 12, PIXEL_ORDER_GRBG, 0x2c },
+	{ MEDIA_BUS_FMT_SRGGB12_1X12, 12, 12, PIXEL_ORDER_RGGB, 0x2c },
+	{ MEDIA_BUS_FMT_SBGGR12_1X12, 12, 12, PIXEL_ORDER_BGGR, 0x2c },
+	{ MEDIA_BUS_FMT_SGBRG12_1X12, 12, 12, PIXEL_ORDER_GBRG, 0x2c },
+	{ MEDIA_BUS_FMT_SGRBG10_1X10, 10, 10, PIXEL_ORDER_GRBG, 0x2b },
+	{ MEDIA_BUS_FMT_SRGGB10_1X10, 10, 10, PIXEL_ORDER_RGGB, 0x2b },
+	{ MEDIA_BUS_FMT_SBGGR10_1X10, 10, 10, PIXEL_ORDER_BGGR, 0x2b },
+	{ MEDIA_BUS_FMT_SGBRG10_1X10, 10, 10, PIXEL_ORDER_GBRG, 0x2b },
+	{ MEDIA_BUS_FMT_SGRBG8_1X8, 8, 8, PIXEL_ORDER_GRBG, 0x2a },
+	{ MEDIA_BUS_FMT_SRGGB8_1X8, 8, 8, PIXEL_ORDER_RGGB, 0x2a },
+	{ MEDIA_BUS_FMT_SBGGR8_1X8, 8, 8, PIXEL_ORDER_BGGR, 0x2a },
+	{ MEDIA_BUS_FMT_SGBRG8_1X8, 8, 8, PIXEL_ORDER_GBRG, 0x2a },
+};
+
+static const uint32_t ti964_supported_codes_pad[] = {
+	MEDIA_BUS_FMT_YUYV8_1X16,
+	MEDIA_BUS_FMT_UYVY8_1X16,
+	MEDIA_BUS_FMT_SBGGR12_1X12,
+	MEDIA_BUS_FMT_SGBRG12_1X12,
+	MEDIA_BUS_FMT_SGRBG12_1X12,
+	MEDIA_BUS_FMT_SRGGB12_1X12,
+	MEDIA_BUS_FMT_SBGGR10_1X10,
+	MEDIA_BUS_FMT_SGBRG10_1X10,
+	MEDIA_BUS_FMT_SGRBG10_1X10,
+	MEDIA_BUS_FMT_SRGGB10_1X10,
+	MEDIA_BUS_FMT_SBGGR8_1X8,
+	MEDIA_BUS_FMT_SGBRG8_1X8,
+	MEDIA_BUS_FMT_SGRBG8_1X8,
+	MEDIA_BUS_FMT_SRGGB8_1X8,
+	0,
+};
+
+static const uint32_t *ti964_supported_codes[] = {
+	ti964_supported_codes_pad,
+};
+
+static struct regmap_config ti964_reg_config8 = {
+	.reg_bits = 8,
+	.val_bits = 8,
+};
+
+static struct regmap_config ti964_reg_config16 = {
+	.reg_bits = 16,
+	.val_bits = 8,
+	.reg_format_endian = REGMAP_ENDIAN_BIG,
+};
+
+static int ti964_reg_set_bit(struct ti964 *va, unsigned char reg,
+	unsigned char bit, unsigned char val)
+{
+	int ret;
+	unsigned int reg_val;
+
+	ret = regmap_read(va->regmap8, reg, &reg_val);
+	if (ret)
+		return ret;
+	if (val)
+		reg_val |= 1 << bit;
+	else
+		reg_val &= ~(1 << bit);
+
+	return regmap_write(va->regmap8, reg, reg_val);
+}
+
+static int ti964_map_phy_i2c_addr(struct ti964 *va, unsigned short rx_port,
+			      unsigned short addr)
+{
+	int rval;
+
+	rval = regmap_write(va->regmap8, TI964_RX_PORT_SEL,
+		(rx_port << 4) + (1 << rx_port));
+	if (rval)
+		return rval;
+
+	return regmap_write(va->regmap8, TI964_SLAVE_ID0, addr);
+}
+
+static int ti964_map_alias_i2c_addr(struct ti964 *va, unsigned short rx_port,
+			      unsigned short addr)
+{
+	int rval;
+
+	rval = regmap_write(va->regmap8, TI964_RX_PORT_SEL,
+		(rx_port << 4) + (1 << rx_port));
+	if (rval)
+		return rval;
+
+	return regmap_write(va->regmap8, TI964_SLAVE_ALIAS_ID0, addr);
+}
+
+static int ti964_fsin_gpio_init(struct ti964 *va, unsigned short rx_port,
+					unsigned short fsin_gpio)
+{
+	int rval;
+	int reg_val;
+
+	rval = regmap_read(va->regmap8, TI964_FS_CTL, &reg_val);
+	if (rval) {
+		dev_dbg(va->sd.dev, "Failed to read gpio status.\n");
+		return rval;
+	}
+
+	if (!reg_val & TI964_FSIN_ENABLE) {
+		dev_dbg(va->sd.dev, "FSIN not enabled, skip config FSIN GPIO.\n");
+		return 0;
+	}
+
+	rval = regmap_write(va->regmap8, TI964_RX_PORT_SEL,
+		(rx_port << 4) + (1 << rx_port));
+	if (rval)
+		return rval;
+
+	rval = regmap_read(va->regmap8, TI964_BC_GPIO_CTL0, &reg_val);
+	if (rval) {
+		dev_dbg(va->sd.dev, "Failed to read gpio status.\n");
+		return rval;
+	}
+
+	if (fsin_gpio == 0) {
+		reg_val &= ~TI964_GPIO0_MASK;
+		reg_val |= TI964_GPIO0_FSIN;
+	} else {
+		reg_val &= ~TI964_GPIO1_MASK;
+		reg_val |= TI964_GPIO1_FSIN;
+	}
+
+	rval = regmap_write(va->regmap8, TI964_BC_GPIO_CTL0, reg_val);
+	if (rval)
+		dev_dbg(va->sd.dev, "Failed to set gpio.\n");
+
+	return rval;
+}
+
+static int ti964_get_routing(struct v4l2_subdev *sd,
+				   struct v4l2_subdev_routing *route)
+{
+	struct ti964 *va = to_ti964(sd);
+	int i;
+
+	for (i = 0; i < min(va->nstreams, route->num_routes); ++i) {
+		unsigned int sink = va->route[i].sink;
+		unsigned int source = va->route[i].source;
+
+		route->routes[i].sink_pad = sink;
+		route->routes[i].sink_stream =
+			va->stream[sink].stream_id[0];
+		route->routes[i].source_pad = source;
+		route->routes[i].source_stream =
+			va->stream[source].stream_id[sink];
+		route->routes[i].flags = va->route[i].flags;
+	}
+
+	route->num_routes = i;
+
+	return 0;
+}
+
+static int ti964_set_routing(struct v4l2_subdev *sd,
+				   struct v4l2_subdev_routing *route)
+{
+	struct ti964 *va = to_ti964(sd);
+	int i, j, ret = 0;
+
+	for (i = 0; i < min(route->num_routes, va->nstreams); ++i) {
+		struct v4l2_subdev_route *t = &route->routes[i];
+		unsigned int sink = t->sink_pad;
+		unsigned int source = t->source_pad;
+
+		if (t->sink_stream > va->nstreams - 1 ||
+		    t->source_stream > va->nstreams - 1)
+			continue;
+
+		if (t->source_pad != TI964_PAD_SOURCE)
+			continue;
+
+		for (j = 0; j < va->nstreams; j++) {
+			if (sink == va->route[j].sink &&
+				source == va->route[j].source)
+				break;
+		}
+
+		if (j == va->nstreams)
+			continue;
+
+		va->stream[sink].stream_id[0] = t->sink_stream;
+		va->stream[source].stream_id[sink] = t->source_stream;
+
+		if (t->flags & V4L2_SUBDEV_ROUTE_FL_ACTIVE)
+			va->route[j].flags |=
+				V4L2_SUBDEV_ROUTE_FL_ACTIVE;
+		else if (!(t->flags & V4L2_SUBDEV_ROUTE_FL_ACTIVE))
+			va->route[j].flags &=
+				(~V4L2_SUBDEV_ROUTE_FL_ACTIVE);
+	}
+
+	return ret;
+}
+
+static int ti964_enum_mbus_code(struct v4l2_subdev *sd,
+				struct v4l2_subdev_state *sd_state,
+				struct v4l2_subdev_mbus_code_enum *code)
+{
+	struct ti964 *va = to_ti964(sd);
+	const uint32_t *supported_code =
+		ti964_supported_codes[code->pad];
+	bool next_stream = false;
+	int i;
+
+	if (code->stream & V4L2_SUBDEV_FLAG_NEXT_STREAM) {
+		next_stream = true;
+		code->stream &= ~V4L2_SUBDEV_FLAG_NEXT_STREAM;
+	}
+
+	if (code->stream > va->nstreams)
+		return -EINVAL;
+
+	if (next_stream) {
+		if (!(va->pad[code->pad].flags & MEDIA_PAD_FL_MULTIPLEX))
+			return -EINVAL;
+		if (code->stream < va->nstreams - 1) {
+			code->stream++;
+			return 0;
+		} else {
+			return -EINVAL;
+		}
+	}
+
+	for (i = 0; supported_code[i]; i++) {
+		if (i == code->index) {
+			code->code = supported_code[i];
+			return 0;
+		}
+	}
+
+	return -EINVAL;
+}
+
+static const struct ti964_csi_data_format
+		*ti964_validate_csi_data_format(u32 code)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(va_csi_data_formats); i++) {
+		if (va_csi_data_formats[i].code == code)
+			return &va_csi_data_formats[i];
+	}
+
+	return &va_csi_data_formats[0];
+}
+
+static int ti964_get_frame_desc(struct v4l2_subdev *sd,
+	unsigned int pad, struct v4l2_mbus_frame_desc *desc)
+{
+	struct ti964 *va = to_ti964(sd);
+	struct v4l2_mbus_frame_desc_entry *entry = desc->entry;
+	u8 vc = 0;
+	int i;
+
+	desc->type = V4L2_MBUS_FRAME_DESC_TYPE_CSI2;
+	desc->num_entries = min_t(int, va->nstreams, V4L2_FRAME_DESC_ENTRY_MAX);
+
+	for (i = 0; i < desc->num_entries; i++) {
+		struct v4l2_mbus_framefmt *ffmt =
+			&va->ffmts[TI964_PAD_SOURCE][i];
+		const struct ti964_csi_data_format *csi_format =
+			ti964_validate_csi_data_format(ffmt->code);
+
+		entry->two_dim.width = ffmt->width;
+		entry->two_dim.height = ffmt->height;
+		entry->pixelcode = ffmt->code;
+		entry->bus.csi2.channel = vc++;
+		entry->bpp = csi_format->compressed;
+		entry++;
+	}
+
+	return 0;
+}
+
+static struct v4l2_mbus_framefmt *
+__ti964_get_ffmt(struct v4l2_subdev *subdev,
+			 struct v4l2_subdev_state *sd_state,
+			 unsigned int pad, unsigned int which,
+			 unsigned int stream)
+{
+	struct ti964 *va = to_ti964(subdev);
+
+	if (which == V4L2_SUBDEV_FORMAT_TRY)
+		return v4l2_subdev_get_try_format(subdev, sd_state, pad);
+	else
+		return &va->ffmts[pad][stream];
+}
+
+static int ti964_get_format(struct v4l2_subdev *subdev,
+			    struct v4l2_subdev_state *sd_state,
+			    struct v4l2_subdev_format *fmt)
+{
+	struct ti964 *va = to_ti964(subdev);
+
+	if (fmt->stream > va->nstreams)
+		return -EINVAL;
+
+	mutex_lock(&va->mutex);
+	fmt->format = *__ti964_get_ffmt(subdev, sd_state, fmt->pad,
+					fmt->which, fmt->stream);
+	mutex_unlock(&va->mutex);
+
+	dev_dbg(subdev->dev, "subdev_format: which: %s, pad: %d, stream: %d.\n",
+		 fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE ?
+		 "V4L2_SUBDEV_FORMAT_ACTIVE" : "V4L2_SUBDEV_FORMAT_TRY",
+		 fmt->pad, fmt->stream);
+
+	dev_dbg(subdev->dev, "framefmt: width: %d, height: %d, code: 0x%x.\n",
+	       fmt->format.width, fmt->format.height, fmt->format.code);
+
+	return 0;
+}
+
+static int ti964_set_format(struct v4l2_subdev *subdev,
+			    struct v4l2_subdev_state *sd_state,
+			    struct v4l2_subdev_format *fmt)
+{
+	struct ti964 *va = to_ti964(subdev);
+	const struct ti964_csi_data_format *csi_format;
+	struct v4l2_mbus_framefmt *ffmt;
+
+	if (fmt->stream > va->nstreams)
+		return -EINVAL;
+
+	csi_format = ti964_validate_csi_data_format(
+		fmt->format.code);
+
+	mutex_lock(&va->mutex);
+	ffmt = __ti964_get_ffmt(subdev, sd_state, fmt->pad, fmt->which,
+				fmt->stream);
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+		ffmt->width = fmt->format.width;
+		ffmt->height = fmt->format.height;
+		ffmt->code = csi_format->code;
+	}
+	fmt->format = *ffmt;
+	mutex_unlock(&va->mutex);
+
+	dev_dbg(subdev->dev, "framefmt: width: %d, height: %d, code: 0x%x.\n",
+	       ffmt->width, ffmt->height, ffmt->code);
+
+	return 0;
+}
+
+static int ti964_open(struct v4l2_subdev *subdev,
+				struct v4l2_subdev_fh *fh)
+{
+	struct v4l2_mbus_framefmt *try_fmt =
+		v4l2_subdev_get_try_format(subdev, fh->state, 0);
+	struct v4l2_subdev_format fmt = {
+		.which = V4L2_SUBDEV_FORMAT_TRY,
+		.pad = TI964_PAD_SOURCE,
+		.format = {
+			.width = TI964_MAX_WIDTH,
+			.height = TI964_MAX_HEIGHT,
+			.code = MEDIA_BUS_FMT_YUYV8_1X16,
+		},
+		.stream = 0,
+	};
+
+	*try_fmt = fmt.format;
+
+	return 0;
+}
+
+static int ti964_registered(struct v4l2_subdev *subdev)
+{
+	struct ti964 *va = to_ti964(subdev);
+	struct i2c_client *client = v4l2_get_subdevdata(subdev);
+	int i, j, k, l, rval;
+
+	for (i = 0, k = 0; i < va->pdata->subdev_num; i++) {
+		struct ti964_subdev_info *info =
+			&va->pdata->subdev_info[i];
+		struct ti964_platform_data *pdata =
+			(struct ti964_platform_data *)
+			info->board_info.platform_data;
+
+		if (k >= va->nsinks)
+			break;
+
+		/*
+		 * The sensors should not share the same pdata structure.
+		 * Clone the pdata for each sensor.
+		 */
+		memcpy(&va->subdev_pdata[k], pdata, sizeof(*pdata));
+		if (va->subdev_pdata[k].xshutdown != 0 &&
+			va->subdev_pdata[k].xshutdown != 1) {
+			dev_err(va->sd.dev, "xshutdown(%d) must be 0 or 1 to connect.\n",
+				va->subdev_pdata[k].xshutdown);
+			return -EINVAL;
+		}
+
+		/* If 0 is xshutdown, then 1 would be FSIN, vice versa. */
+		va->sub_devs[k].fsin_gpio = 1 - va->subdev_pdata[k].xshutdown;
+
+		/* Spin sensor subdev suffix name */
+		va->subdev_pdata[k].suffix = info->suffix;
+
+		/*
+		 * Change the gpio value to have xshutdown
+		 * and rx port included, so in gpio_set those
+		 * can be caculated from it.
+		 */
+		va->subdev_pdata[k].xshutdown += va->gc.base +
+					info->rx_port * NR_OF_GPIOS_PER_PORT;
+		info->board_info.platform_data = &va->subdev_pdata[k];
+
+		if (!info->phy_i2c_addr || !info->board_info.addr) {
+			dev_err(va->sd.dev, "can't find the physical and alias addr.\n");
+			return -EINVAL;
+		}
+
+		/* Map PHY I2C address. */
+		rval = ti964_map_phy_i2c_addr(va, info->rx_port,
+					info->phy_i2c_addr);
+		if (rval)
+			return rval;
+
+		/* Map 7bit ALIAS I2C address. */
+		rval = ti964_map_alias_i2c_addr(va, info->rx_port,
+				info->board_info.addr << 1);
+		if (rval)
+			return rval;
+
+		/* aggre and subdves share the same i2c bus */
+		va->sub_devs[k].sd = v4l2_i2c_new_subdev_board(
+			va->sd.v4l2_dev, client->adapter,
+			&info->board_info, 0);
+		if (!va->sub_devs[k].sd) {
+			dev_err(va->sd.dev,
+				"can't create new i2c subdev %d-%04x\n",
+				info->i2c_adapter_id,
+				info->board_info.addr);
+			continue;
+		}
+		va->sub_devs[k].rx_port = info->rx_port;
+		va->sub_devs[k].phy_i2c_addr = info->phy_i2c_addr;
+		va->sub_devs[k].alias_i2c_addr = info->board_info.addr;
+		memcpy(va->sub_devs[k].sd_name,
+				va->subdev_pdata[k].module_name,
+				min(sizeof(va->sub_devs[k].sd_name) - 1,
+				sizeof(va->subdev_pdata[k].module_name) - 1));
+
+		for (j = 0; j < va->sub_devs[k].sd->entity.num_pads; j++) {
+			if (va->sub_devs[k].sd->entity.pads[j].flags &
+				MEDIA_PAD_FL_SOURCE)
+				break;
+		}
+
+		if (j == va->sub_devs[k].sd->entity.num_pads) {
+			dev_warn(va->sd.dev,
+				"no source pad in subdev %d-%04x\n",
+				info->i2c_adapter_id,
+				info->board_info.addr);
+			return -ENOENT;
+		}
+
+		for (l = 0; l < va->nsinks; l++) {
+			rval = media_create_pad_link(
+				&va->sub_devs[k].sd->entity, j,
+				&va->sd.entity, l, 0);
+			if (rval) {
+				dev_err(va->sd.dev,
+					"can't create link to %d-%04x\n",
+					info->i2c_adapter_id,
+					info->board_info.addr);
+				return -EINVAL;
+			}
+		}
+		k++;
+	}
+
+	return 0;
+}
+
+static int ti964_set_power(struct v4l2_subdev *subdev, int on)
+{
+	struct ti964 *va = to_ti964(subdev);
+	int ret;
+	u8 val;
+
+	ret = regmap_write(va->regmap8, TI964_RESET,
+			   (on) ? TI964_POWER_ON : TI964_POWER_OFF);
+	if (ret || !on)
+		return ret;
+
+	/* Configure MIPI clock bsaed on control value. */
+	ret = regmap_write(va->regmap8, TI964_CSI_PLL_CTL,
+			    ti964_op_sys_clock_reg_val[
+			    v4l2_ctrl_g_ctrl(va->link_freq)]);
+	if (ret)
+		return ret;
+	val = TI964_CSI_ENABLE;
+	val |= TI964_CSI_CONTS_CLOCK;
+	/* Enable skew calculation when 1.6Gbps output is enabled. */
+	if (v4l2_ctrl_g_ctrl(va->link_freq))
+		val |= TI964_CSI_SKEWCAL;
+	return regmap_write(va->regmap8, TI964_CSI_CTL, val);
+}
+
+static bool ti964_broadcast_mode(struct v4l2_subdev *subdev)
+{
+	struct ti964 *va = to_ti964(subdev);
+	struct v4l2_subdev_format fmt = { 0 };
+	struct v4l2_subdev *sd;
+	char *sd_name = NULL;
+	bool first = true;
+	unsigned int h = 0, w = 0, code = 0;
+	bool single_stream = true;
+	int i, rval;
+
+	for (i = 0; i < NR_OF_TI964_SINK_PADS; i++) {
+		struct media_pad *remote_pad =
+			media_entity_remote_pad(&va->pad[i]);
+
+		if (!remote_pad)
+			continue;
+
+		sd = media_entity_to_v4l2_subdev(remote_pad->entity);
+		fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
+		fmt.pad = remote_pad->index;
+		fmt.stream = 0;
+
+		rval = v4l2_subdev_call(sd, pad, get_fmt, NULL, &fmt);
+		if (rval)
+			return false;
+
+		if (first) {
+			sd_name = va->sub_devs[i].sd_name;
+			h = fmt.format.height;
+			w = fmt.format.width;
+			code = fmt.format.code;
+			first = false;
+		} else {
+			if (strncmp(sd_name, va->sub_devs[i].sd_name, 16))
+				return false;
+
+			if (h != fmt.format.height || w != fmt.format.width
+				|| code != fmt.format.code)
+				return false;
+
+			single_stream = false;
+		}
+	}
+
+	if (single_stream)
+		return false;
+
+	return true;
+}
+
+static int ti964_tp_set_stream(struct v4l2_subdev *subdev, int enable)
+{
+	struct ti964 *va = to_ti964(subdev);
+	int i, rval;
+
+	dev_dbg(va->sd.dev, "TI964 starts to stream test pattern.\n");
+	for (i = 0; i < ARRAY_SIZE(ti964_tp_settings); i++) {
+		rval = regmap_write(va->regmap8,
+			ti964_tp_settings[i].reg,
+			ti964_tp_settings[i].val);
+		if (rval) {
+			dev_err(va->sd.dev, "Register write error.\n");
+			return rval;
+		}
+	}
+
+	rval = regmap_write(va->regmap8, TI964_IND_ACC_DATA, enable);
+	if (rval) {
+		dev_err(va->sd.dev, "Register write error.\n");
+		return rval;
+	}
+
+	return 0;
+}
+
+static int ti964_rx_port_config(struct ti964 *va, int sink, int rx_port)
+{
+	int rval;
+	u8 bpp;
+	int port_cfg2_val;
+	int vc_mode_reg_index;
+	int vc_mode_reg_val;
+	int mipi_dt_type;
+	int high_fv_flags = va->subdev_pdata[sink].high_framevalid_flags;
+
+	/* Select RX port. */
+	rval = regmap_write(va->regmap8, TI964_RX_PORT_SEL,
+			(rx_port << 4) + (1 << rx_port));
+	if (rval) {
+		dev_err(va->sd.dev, "Failed to select RX port.\n");
+		return rval;
+	}
+
+	/* Set RX port mode. */
+	bpp = ti964_validate_csi_data_format(
+		va->ffmts[sink][0].code)->width;
+	rval = regmap_write(va->regmap8, TI964_PORT_CONFIG,
+		(bpp == 12) ?
+		TI964_FPD3_RAW12_75MHz : TI964_FPD3_RAW10_100MHz);
+	if (rval) {
+		dev_err(va->sd.dev, "Failed to set port config.\n");
+		return rval;
+	}
+
+	mipi_dt_type = ti964_validate_csi_data_format(
+		va->ffmts[sink][0].code)->mipi_dt_code;
+	/*
+	 * RAW8 and YUV422 need to enable RAW10 bit mode.
+	 * RAW12 need to set the RAW10_8bit to reserved.
+	 */
+	switch (bpp) {
+	case 8:
+	case 16:
+		port_cfg2_val = TI964_RAW10_8BIT & (~high_fv_flags);
+		vc_mode_reg_index = TI964_RAW10_ID;
+		break;
+	case 12:
+		port_cfg2_val = TI964_RAW12;
+		vc_mode_reg_index = TI964_RAW12_ID;
+		break;
+	default:
+		port_cfg2_val = TI964_RAW10_NORMAL & (~high_fv_flags);
+		vc_mode_reg_index = TI964_RAW10_ID;
+		break;
+	}
+
+	vc_mode_reg_val =  mipi_dt_type | sink << 6;
+	rval = regmap_write(va->regmap8, vc_mode_reg_index, vc_mode_reg_val);
+	if (rval) {
+		dev_err(va->sd.dev, "Failed to set virtual channel & data type.\n");
+		return rval;
+	}
+
+	rval = regmap_write(va->regmap8, TI964_PORT_CONFIG2, port_cfg2_val);
+	if (rval) {
+		dev_err(va->sd.dev, "Failed to set port config2.\n");
+		return rval;
+	}
+
+	return 0;
+}
+
+static int ti964_map_subdevs_addr(struct ti964 *va)
+{
+	unsigned short rx_port, phy_i2c_addr, alias_i2c_addr;
+	int i, rval;
+
+	for (i = 0; i < NR_OF_TI964_SINK_PADS; i++) {
+		rx_port = va->sub_devs[i].rx_port;
+		phy_i2c_addr = va->sub_devs[i].phy_i2c_addr;
+		alias_i2c_addr = va->sub_devs[i].alias_i2c_addr;
+
+		if (!phy_i2c_addr || !alias_i2c_addr)
+			continue;
+
+		rval = ti964_map_phy_i2c_addr(va, rx_port, phy_i2c_addr);
+		if (rval)
+			return rval;
+
+		/* set 7bit alias i2c addr */
+		rval = ti964_map_alias_i2c_addr(va, rx_port,
+						alias_i2c_addr << 1);
+		if (rval)
+			return rval;
+	}
+
+	return 0;
+}
+
+static int ti964_find_subdev_index(struct ti964 *va, struct v4l2_subdev *sd)
+{
+	int i;
+
+	for (i = 0; i < NR_OF_TI964_SINK_PADS; i++) {
+		if (va->sub_devs[i].sd == sd)
+			return i;
+	}
+
+	WARN_ON(1);
+
+	return -EINVAL;
+}
+
+static int ti964_set_frame_sync(struct ti964 *va, int enable)
+{
+	int i, rval;
+	int index = !!enable;
+
+	for (i = 0; i < ARRAY_SIZE(ti964_frame_sync_settings[index]); i++) {
+		rval = regmap_write(va->regmap8,
+				ti964_frame_sync_settings[index][i].reg,
+				ti964_frame_sync_settings[index][i].val);
+		if (rval) {
+			dev_err(va->sd.dev, "Failed to %s frame sync\n",
+				enable ? "enable" : "disable");
+			return rval;
+		}
+	}
+
+	return 0;
+}
+
+static int ti964_set_stream(struct v4l2_subdev *subdev, int enable)
+{
+	struct ti964 *va = to_ti964(subdev);
+	struct v4l2_subdev *sd;
+	int i, j, rval;
+	bool broadcast;
+	unsigned int rx_port;
+	int sd_idx = -1;
+	DECLARE_BITMAP(rx_port_enabled, 32);
+
+	dev_dbg(va->sd.dev, "TI964 set stream, enable %d\n", enable);
+
+	if (v4l2_ctrl_g_ctrl(va->test_pattern))
+		return ti964_tp_set_stream(subdev, enable);
+
+	broadcast = ti964_broadcast_mode(subdev);
+	if (enable)
+		dev_info(va->sd.dev, "TI964 in %s mode",
+			broadcast ? "broadcast" : "non broadcast");
+
+	bitmap_zero(rx_port_enabled, 32);
+	for (i = 0; i < NR_OF_TI964_SINK_PADS; i++) {
+		struct media_pad *remote_pad =
+			media_entity_remote_pad(&va->pad[i]);
+
+		if (!remote_pad)
+			continue;
+
+		/* Find ti964 subdev */
+		sd = media_entity_to_v4l2_subdev(remote_pad->entity);
+		j = ti964_find_subdev_index(va, sd);
+		if (j < 0)
+			return -EINVAL;
+		rx_port = va->sub_devs[j].rx_port;
+		rval = ti964_rx_port_config(va, i, rx_port);
+		if (rval < 0)
+			return rval;
+
+		bitmap_set(rx_port_enabled, rx_port, 1);
+
+		if (broadcast && sd_idx == -1) {
+			sd_idx = j;
+		} else if (broadcast) {
+			rval = ti964_map_alias_i2c_addr(va, rx_port,
+				va->sub_devs[sd_idx].alias_i2c_addr << 1);
+			if (rval < 0)
+				return rval;
+		} else {
+			/* Stream on/off sensor */
+			rval = v4l2_subdev_call(sd, video, s_stream, enable);
+			if (rval) {
+				dev_err(va->sd.dev,
+					"Failed to set stream for %s, enable  %d\n",
+					sd->name, enable);
+				return rval;
+			}
+
+			/* RX port fordward */
+			rval = ti964_reg_set_bit(va, TI964_FWD_CTL1,
+						rx_port + 4, !enable);
+			if (rval) {
+				dev_err(va->sd.dev,
+					"Failed to forward RX port%d. enable %d\n",
+					i, enable);
+				return rval;
+			}
+
+		}
+	}
+
+	if (broadcast) {
+		if (sd_idx < 0) {
+			dev_err(va->sd.dev, "No sensor connected!\n");
+			return -ENODEV;
+		}
+		sd = va->sub_devs[sd_idx].sd;
+		rval = v4l2_subdev_call(sd, video, s_stream, enable);
+		if (rval) {
+			dev_err(va->sd.dev,
+				"Failed to set stream for %s. enable  %d\n",
+				sd->name, enable);
+			return rval;
+		}
+
+		rval = ti964_set_frame_sync(va, enable);
+		if (rval) {
+			dev_err(va->sd.dev,
+				"Failed to set frame sync.\n");
+			return rval;
+		}
+
+		for (i = 0; i < NR_OF_TI964_SINK_PADS; i++) {
+			if (enable && test_bit(i, rx_port_enabled)) {
+				rval = ti964_fsin_gpio_init(va,
+						va->sub_devs[i].rx_port,
+						va->sub_devs[i].fsin_gpio);
+				if (rval) {
+					dev_err(va->sd.dev,
+						"Failed to enable frame sync gpio init.\n");
+					return rval;
+				}
+			}
+		}
+
+		for (i = 0; i < NR_OF_TI964_SINK_PADS; i++) {
+			if (!test_bit(i, rx_port_enabled))
+				continue;
+
+			/* RX port fordward */
+			rval = ti964_reg_set_bit(va, TI964_FWD_CTL1,
+						i + 4, !enable);
+			if (rval) {
+				dev_err(va->sd.dev,
+					"Failed to forward RX port%d. enable %d\n",
+					i, enable);
+				return rval;
+			}
+		}
+
+		/*
+		 * Restore each subdev i2c address as we may
+		 * touch it later.
+		*/
+		rval = ti964_map_subdevs_addr(va);
+		if (rval)
+			return rval;
+	}
+
+	return 0;
+}
+
+static struct v4l2_subdev_internal_ops ti964_sd_internal_ops = {
+	.open = ti964_open,
+	.registered = ti964_registered,
+};
+
+static bool ti964_sd_has_route(struct media_entity *entity,
+		unsigned int pad0, unsigned int pad1, int *stream)
+{
+	struct ti964 *va = to_ti964(media_entity_to_v4l2_subdev(entity));
+
+	if (va == NULL || stream == NULL ||
+		*stream >= va->nstreams || *stream < 0)
+		return false;
+
+	if ((va->route[*stream].flags & V4L2_SUBDEV_ROUTE_FL_ACTIVE) &&
+			((va->route[*stream].source == pad0 &&
+			 va->route[*stream].sink == pad1) ||
+			(va->route[*stream].source == pad1 &&
+			 va->route[*stream].sink == pad0)))
+		return true;
+
+	return false;
+}
+
+static const struct media_entity_operations ti964_sd_entity_ops = {
+	.has_route = ti964_sd_has_route,
+};
+
+static const struct v4l2_subdev_video_ops ti964_sd_video_ops = {
+	.s_stream = ti964_set_stream,
+};
+
+static const struct v4l2_subdev_core_ops ti964_core_subdev_ops = {
+	.s_power = ti964_set_power,
+};
+
+static int ti964_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	return 0;
+}
+
+static const struct v4l2_ctrl_ops ti964_ctrl_ops = {
+	.s_ctrl = ti964_s_ctrl,
+};
+
+static const struct v4l2_ctrl_config ti964_controls[] = {
+	{
+		.ops = &ti964_ctrl_ops,
+		.id = V4L2_CID_LINK_FREQ,
+		.name = "V4L2_CID_LINK_FREQ",
+		.type = V4L2_CTRL_TYPE_INTEGER_MENU,
+		.max = ARRAY_SIZE(ti964_op_sys_clock) - 1,
+		.min =  0,
+		.step  = 0,
+		.def = 0,
+		.qmenu_int = ti964_op_sys_clock,
+	},
+	{
+		.ops = &ti964_ctrl_ops,
+		.id = V4L2_CID_TEST_PATTERN,
+		.name = "V4L2_CID_TEST_PATTERN",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.max = 1,
+		.min =	0,
+		.step  = 1,
+		.def = 0,
+	},
+};
+
+static const struct v4l2_subdev_pad_ops ti964_sd_pad_ops = {
+	.get_fmt = ti964_get_format,
+	.set_fmt = ti964_set_format,
+	.get_frame_desc = ti964_get_frame_desc,
+	.enum_mbus_code = ti964_enum_mbus_code,
+	.set_routing = ti964_set_routing,
+	.get_routing = ti964_get_routing,
+};
+
+static struct v4l2_subdev_ops ti964_sd_ops = {
+	.core = &ti964_core_subdev_ops,
+	.video = &ti964_sd_video_ops,
+	.pad = &ti964_sd_pad_ops,
+};
+
+static int ti964_register_subdev(struct ti964 *va)
+{
+	int i, rval;
+	struct i2c_client *client = v4l2_get_subdevdata(&va->sd);
+
+	v4l2_subdev_init(&va->sd, &ti964_sd_ops);
+	snprintf(va->sd.name, sizeof(va->sd.name), "TI964 %c",
+		 va->pdata->suffix);
+
+	va->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE |
+			V4L2_SUBDEV_FL_HAS_SUBSTREAMS;
+
+	va->sd.internal_ops = &ti964_sd_internal_ops;
+	va->sd.entity.ops = &ti964_sd_entity_ops;
+
+	v4l2_set_subdevdata(&va->sd, client);
+
+	v4l2_ctrl_handler_init(&va->ctrl_handler,
+				ARRAY_SIZE(ti964_controls));
+
+	if (va->ctrl_handler.error) {
+		dev_err(va->sd.dev,
+			"Failed to init ti964 controls. ERR: %d!\n",
+			va->ctrl_handler.error);
+		return va->ctrl_handler.error;
+	}
+
+	va->sd.ctrl_handler = &va->ctrl_handler;
+
+	for (i = 0; i < ARRAY_SIZE(ti964_controls); i++) {
+		const struct v4l2_ctrl_config *cfg =
+			&ti964_controls[i];
+		struct v4l2_ctrl *ctrl;
+
+		ctrl = v4l2_ctrl_new_custom(&va->ctrl_handler, cfg, NULL);
+		if (!ctrl) {
+			dev_err(va->sd.dev,
+				"Failed to create ctrl %s!\n", cfg->name);
+			rval = va->ctrl_handler.error;
+			goto failed_out;
+		}
+	}
+
+	va->link_freq = v4l2_ctrl_find(&va->ctrl_handler, V4L2_CID_LINK_FREQ);
+	va->test_pattern = v4l2_ctrl_find(&va->ctrl_handler,
+					  V4L2_CID_TEST_PATTERN);
+
+	for (i = 0; i < va->nsinks; i++)
+		va->pad[i].flags = MEDIA_PAD_FL_SINK;
+	va->pad[TI964_PAD_SOURCE].flags =
+		MEDIA_PAD_FL_SOURCE | MEDIA_PAD_FL_MULTIPLEX;
+	rval = media_entity_pads_init(&va->sd.entity,
+				      NR_OF_TI964_PADS, va->pad);
+	if (rval) {
+		dev_err(va->sd.dev,
+			"Failed to init media entity for ti964!\n");
+		goto failed_out;
+	}
+
+	return 0;
+
+failed_out:
+	v4l2_ctrl_handler_free(&va->ctrl_handler);
+	return rval;
+}
+
+static int ti964_init(struct ti964 *va)
+{
+	unsigned int reset_gpio = va->pdata->reset_gpio;
+	int i, rval;
+	unsigned int val;
+
+	gpio_set_value(reset_gpio, 1);
+	usleep_range(2000, 3000);
+	dev_dbg(va->sd.dev, "Setting reset gpio %d to 1.\n", reset_gpio);
+
+	rval = regmap_read(va->regmap8, TI964_DEVID, &val);
+	if (rval) {
+		dev_err(va->sd.dev, "Failed to read device ID of TI964!\n");
+		return rval;
+	}
+	dev_info(va->sd.dev, "TI964 device ID: 0x%X\n", val);
+
+	for (i = 0; i < ARRAY_SIZE(ti964_init_settings); i++) {
+		rval = regmap_write(va->regmap8,
+			ti964_init_settings[i].reg,
+			ti964_init_settings[i].val);
+		if (rval)
+			return rval;
+	}
+
+	rval = ti964_map_subdevs_addr(va);
+	if (rval)
+		return rval;
+
+	return 0;
+}
+
+static void ti964_gpio_set(struct gpio_chip *chip, unsigned gpio, int value)
+{
+	struct i2c_client *client = to_i2c_client(chip->parent);
+	struct v4l2_subdev *subdev = i2c_get_clientdata(client);
+	struct ti964 *va = to_ti964(subdev);
+	unsigned int reg_val;
+	int rx_port, gpio_port;
+	int ret;
+
+	if (gpio >= NR_OF_TI964_GPIOS)
+		return;
+
+	rx_port = gpio / NR_OF_GPIOS_PER_PORT;
+	gpio_port = gpio % NR_OF_GPIOS_PER_PORT;
+
+	ret = regmap_write(va->regmap8, TI964_RX_PORT_SEL,
+			  (rx_port << 4) + (1 << rx_port));
+	if (ret) {
+		dev_dbg(&client->dev, "Failed to select RX port.\n");
+		return;
+	}
+	ret = regmap_read(va->regmap8, TI964_BC_GPIO_CTL0, &reg_val);
+	if (ret) {
+		dev_dbg(&client->dev, "Failed to read gpio status.\n");
+		return;
+	}
+
+	if (gpio_port == 0) {
+		reg_val &= ~TI964_GPIO0_MASK;
+		reg_val |= value ? TI964_GPIO0_HIGH : TI964_GPIO0_LOW;
+	} else {
+		reg_val &= ~TI964_GPIO1_MASK;
+		reg_val |= value ? TI964_GPIO1_HIGH : TI964_GPIO1_LOW;
+	}
+
+	ret = regmap_write(va->regmap8, TI964_BC_GPIO_CTL0, reg_val);
+	if (ret)
+		dev_dbg(&client->dev, "Failed to set gpio.\n");
+}
+
+static int ti964_gpio_direction_output(struct gpio_chip *chip,
+				       unsigned gpio, int level)
+{
+	return 0;
+}
+
+static int ti964_probe(struct i2c_client *client,
+			const struct i2c_device_id *devid)
+{
+	struct ti964 *va;
+	int i, rval = 0;
+
+	if (client->dev.platform_data == NULL)
+		return -ENODEV;
+
+	va = devm_kzalloc(&client->dev, sizeof(*va), GFP_KERNEL);
+	if (!va)
+		return -ENOMEM;
+
+	va->pdata = client->dev.platform_data;
+
+	va->nsources = NR_OF_TI964_SOURCE_PADS;
+	va->nsinks = NR_OF_TI964_SINK_PADS;
+	va->npads = NR_OF_TI964_PADS;
+	va->nstreams = NR_OF_TI964_STREAMS;
+
+	va->crop = devm_kcalloc(&client->dev, va->npads,
+				sizeof(struct v4l2_rect), GFP_KERNEL);
+
+	va->compose = devm_kcalloc(&client->dev, va->npads,
+				   sizeof(struct v4l2_rect), GFP_KERNEL);
+
+	va->route = devm_kcalloc(&client->dev, va->nstreams,
+				       sizeof(*va->route), GFP_KERNEL);
+
+	va->stream = devm_kcalloc(&client->dev, va->npads,
+				       sizeof(*va->stream), GFP_KERNEL);
+
+	if (!va->crop || !va->compose || !va->route || !va->stream)
+		return -ENOMEM;
+
+	for (i = 0; i < va->npads; i++) {
+		va->ffmts[i] = devm_kcalloc(&client->dev, va->nstreams,
+					    sizeof(struct v4l2_mbus_framefmt),
+					    GFP_KERNEL);
+		if (!va->ffmts[i])
+			return -ENOMEM;
+
+		va->stream[i].stream_id =
+			devm_kcalloc(&client->dev, va->nsinks,
+			sizeof(*va->stream[i].stream_id), GFP_KERNEL);
+		if (!va->stream[i].stream_id)
+			return -ENOMEM;
+	}
+
+	for (i = 0; i < va->nstreams; i++) {
+		va->route[i].sink = i;
+		va->route[i].source = TI964_PAD_SOURCE;
+		va->route[i].flags = 0;
+	}
+
+	for (i = 0; i < va->nsinks; i++) {
+		va->stream[i].stream_id[0] = i;
+		va->stream[TI964_PAD_SOURCE].stream_id[i] = i;
+	}
+
+	va->regmap8 = devm_regmap_init_i2c(client,
+					   &ti964_reg_config8);
+	if (IS_ERR(va->regmap8)) {
+		dev_err(&client->dev, "Failed to init regmap8!\n");
+		return -EIO;
+	}
+
+	va->regmap16 = devm_regmap_init_i2c(client,
+					    &ti964_reg_config16);
+	if (IS_ERR(va->regmap16)) {
+		dev_err(&client->dev, "Failed to init regmap16!\n");
+		return -EIO;
+	}
+
+	mutex_init(&va->mutex);
+	v4l2_i2c_subdev_init(&va->sd, client, &ti964_sd_ops);
+	rval = ti964_register_subdev(va);
+	if (rval) {
+		dev_err(&client->dev, "Failed to register va subdevice!\n");
+		return rval;
+	}
+
+	if (devm_gpio_request_one(va->sd.dev, va->pdata->reset_gpio, 0,
+				  "ti964 reset") != 0) {
+		dev_err(va->sd.dev, "Unable to acquire gpio %d\n",
+			va->pdata->reset_gpio);
+		return -ENODEV;
+	}
+
+	rval = ti964_init(va);
+	if (rval) {
+		dev_err(&client->dev, "Failed to init TI964!\n");
+		return rval;
+	}
+
+	/*
+	 * TI964 has several back channel GPIOs.
+	 * We export GPIO0 and GPIO1 to control reset or fsin.
+	 */
+	va->gc.parent = &client->dev;
+	va->gc.owner = THIS_MODULE;
+	va->gc.label = "TI964 GPIO";
+	va->gc.ngpio = NR_OF_TI964_GPIOS;
+	va->gc.base = -1;
+	va->gc.set = ti964_gpio_set;
+	va->gc.direction_output = ti964_gpio_direction_output;
+	rval = gpiochip_add(&va->gc);
+	if (rval) {
+		dev_err(&client->dev, "Failed to add gpio chip!\n");
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int ti964_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *subdev = i2c_get_clientdata(client);
+	struct ti964 *va = to_ti964(subdev);
+	int i;
+
+	if (!va)
+		return 0;
+
+	mutex_destroy(&va->mutex);
+	v4l2_ctrl_handler_free(&va->ctrl_handler);
+	v4l2_device_unregister_subdev(&va->sd);
+	media_entity_cleanup(&va->sd.entity);
+
+	for (i = 0; i < NR_OF_TI964_SINK_PADS; i++) {
+		if (va->sub_devs[i].sd) {
+			struct i2c_client *sub_client =
+				v4l2_get_subdevdata(va->sub_devs[i].sd);
+
+			i2c_unregister_device(sub_client);
+		}
+		va->sub_devs[i].sd = NULL;
+	}
+
+	gpiochip_remove(&va->gc);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int ti964_suspend(struct device *dev)
+{
+	return 0;
+}
+
+static int ti964_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *subdev = i2c_get_clientdata(client);
+	struct ti964 *va = to_ti964(subdev);
+
+	return ti964_init(va);
+}
+#else
+#define ti964_suspend	NULL
+#define ti964_resume	NULL
+#endif /* CONFIG_PM */
+
+static const struct i2c_device_id ti964_id_table[] = {
+	{ TI964_NAME, 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, ti964_id_table);
+
+static const struct dev_pm_ops ti964_pm_ops = {
+	.suspend = ti964_suspend,
+	.resume = ti964_resume,
+};
+
+static struct i2c_driver ti964_i2c_driver = {
+	.driver = {
+		.name = TI964_NAME,
+		.pm = &ti964_pm_ops,
+	},
+	.probe	= ti964_probe,
+	.remove	= ti964_remove,
+	.id_table = ti964_id_table,
+};
+module_i2c_driver(ti964_i2c_driver);
+
+MODULE_AUTHOR("Tianshu Qiu <tian.shu.qiu@intel.com>");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("TI964 CSI2-Aggregator driver");
Index: b/drivers/media/pci/intel/Makefile
===================================================================
--- a/drivers/media/pci/intel/Makefile
+++ b/drivers/media/pci/intel/Makefile
@@ -1,6 +1,4 @@
-# SPDX-License-Identifier: GPL-2.0-only
-#
-# Makefile for the IPU3 cio2 and ImGU drivers
-#
+# SPDX-License-Identifier: GPL-2.0
+# Copyright (c) 2010 - 2020 Intel Corporation.
 
-obj-y	+= ipu3/
+obj-$(CONFIG_VIDEO_INTEL_IPU6)	+= ipu6/
Index: b/drivers/media/pci/intel/ipu-bus.c
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu-bus.c
@@ -0,0 +1,270 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) 2013 - 2022 Intel Corporation
+
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/interrupt.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/pci.h>
+#include <linux/pm_runtime.h>
+#include <linux/sizes.h>
+
+#include "ipu.h"
+#include "ipu-platform.h"
+#include "ipu-dma.h"
+
+#ifdef CONFIG_PM
+static struct bus_type ipu_bus;
+
+static int bus_pm_runtime_suspend(struct device *dev)
+{
+	struct ipu_bus_device *adev = to_ipu_bus_device(dev);
+	int rval;
+
+	rval = pm_generic_runtime_suspend(dev);
+	if (rval)
+		return rval;
+
+	rval = ipu_buttress_power(dev, adev->ctrl, false);
+	dev_dbg(dev, "%s: buttress power down %d\n", __func__, rval);
+	if (!rval)
+		return 0;
+
+	dev_err(dev, "power down failed!\n");
+
+	/* Powering down failed, attempt to resume device now */
+	rval = pm_generic_runtime_resume(dev);
+	if (!rval)
+		return -EBUSY;
+
+	return -EIO;
+}
+
+static int bus_pm_runtime_resume(struct device *dev)
+{
+	struct ipu_bus_device *adev = to_ipu_bus_device(dev);
+	int rval;
+
+	rval = ipu_buttress_power(dev, adev->ctrl, true);
+	dev_dbg(dev, "%s: buttress power up %d\n", __func__, rval);
+	if (rval)
+		return rval;
+
+	rval = pm_generic_runtime_resume(dev);
+	dev_dbg(dev, "%s: resume %d\n", __func__, rval);
+	if (rval)
+		goto out_err;
+
+	return 0;
+
+out_err:
+	ipu_buttress_power(dev, adev->ctrl, false);
+
+	return -EBUSY;
+}
+
+static const struct dev_pm_ops ipu_bus_pm_ops = {
+	.runtime_suspend = bus_pm_runtime_suspend,
+	.runtime_resume = bus_pm_runtime_resume,
+};
+
+#define IPU_BUS_PM_OPS	(&ipu_bus_pm_ops)
+#else
+#define IPU_BUS_PM_OPS	NULL
+#endif
+
+static int ipu_bus_match(struct device *dev, struct device_driver *drv)
+{
+	struct ipu_bus_driver *adrv = to_ipu_bus_driver(drv);
+
+	dev_dbg(dev, "bus match: \"%s\" --- \"%s\"\n", dev_name(dev),
+		adrv->wanted);
+
+	return !strncmp(dev_name(dev), adrv->wanted, strlen(adrv->wanted));
+}
+
+static int ipu_bus_probe(struct device *dev)
+{
+	struct ipu_bus_device *adev = to_ipu_bus_device(dev);
+	struct ipu_bus_driver *adrv = to_ipu_bus_driver(dev->driver);
+	int rval;
+
+	if (!adev->isp->ipu_bus_ready_to_probe)
+		return -EPROBE_DEFER;
+
+	dev_dbg(dev, "bus probe dev %s\n", dev_name(dev));
+
+	adev->adrv = adrv;
+	if (!adrv->probe) {
+		rval = -ENODEV;
+		goto out_err;
+	}
+	rval = pm_runtime_get_sync(&adev->dev);
+	if (rval < 0) {
+		pm_runtime_put(&adev->dev);
+		dev_err(&adev->dev, "Failed to get runtime PM\n");
+		goto out_err;
+	}
+
+	rval = adrv->probe(adev);
+	pm_runtime_put(&adev->dev);
+
+	if (rval)
+		goto out_err;
+
+	return 0;
+
+out_err:
+	ipu_bus_set_drvdata(adev, NULL);
+	adev->adrv = NULL;
+
+	return rval;
+}
+
+static void ipu_bus_remove(struct device *dev)
+{
+	struct ipu_bus_device *adev = to_ipu_bus_device(dev);
+	struct ipu_bus_driver *adrv = to_ipu_bus_driver(dev->driver);
+
+	if (adrv->remove)
+		adrv->remove(adev);
+}
+
+static struct bus_type ipu_bus = {
+	.name = IPU_BUS_NAME,
+	.match = ipu_bus_match,
+	.probe = ipu_bus_probe,
+	.remove = ipu_bus_remove,
+	.pm = IPU_BUS_PM_OPS,
+};
+
+static struct mutex ipu_bus_mutex;
+
+static void ipu_bus_release(struct device *dev)
+{
+	struct ipu_bus_device *adev = to_ipu_bus_device(dev);
+
+	kfree(adev);
+}
+
+struct ipu_bus_device *ipu_bus_initialize_device(struct pci_dev *pdev,
+						 struct device *parent,
+						 void *pdata,
+						 struct ipu_buttress_ctrl *ctrl,
+						 char *name, unsigned int nr)
+{
+	struct ipu_bus_device *adev;
+	struct ipu_device *isp = pci_get_drvdata(pdev);
+
+	adev = kzalloc(sizeof(*adev), GFP_KERNEL);
+	if (!adev)
+		return ERR_PTR(-ENOMEM);
+
+	adev->dev.parent = parent;
+	adev->dev.bus = &ipu_bus;
+	adev->dev.release = ipu_bus_release;
+	adev->dev.dma_ops = &ipu_dma_ops;
+	adev->dma_mask = DMA_BIT_MASK(isp->secure_mode ?
+				      IPU_MMU_ADDRESS_BITS :
+				      IPU_MMU_ADDRESS_BITS_NON_SECURE);
+	adev->dev.dma_mask = &adev->dma_mask;
+	adev->dev.dma_parms = pdev->dev.dma_parms;
+	adev->dev.coherent_dma_mask = adev->dma_mask;
+	adev->ctrl = ctrl;
+	adev->pdata = pdata;
+	adev->isp = isp;
+	mutex_init(&adev->resume_lock);
+	dev_set_name(&adev->dev, "%s%d", name, nr);
+
+	device_initialize(&adev->dev);
+	pm_runtime_forbid(&adev->dev);
+	pm_runtime_enable(&adev->dev);
+
+	return adev;
+}
+
+int ipu_bus_add_device(struct ipu_bus_device *adev)
+{
+	int rval;
+
+	rval = device_add(&adev->dev);
+	if (rval) {
+		put_device(&adev->dev);
+		return rval;
+	}
+
+	mutex_lock(&ipu_bus_mutex);
+	list_add(&adev->list, &adev->isp->devices);
+	mutex_unlock(&ipu_bus_mutex);
+
+	pm_runtime_allow(&adev->dev);
+	return 0;
+}
+
+void ipu_bus_del_devices(struct pci_dev *pdev)
+{
+	struct ipu_device *isp = pci_get_drvdata(pdev);
+	struct ipu_bus_device *adev, *save;
+
+	mutex_lock(&ipu_bus_mutex);
+
+	list_for_each_entry_safe(adev, save, &isp->devices, list) {
+		pm_runtime_disable(&adev->dev);
+		list_del(&adev->list);
+		device_unregister(&adev->dev);
+	}
+
+	mutex_unlock(&ipu_bus_mutex);
+}
+
+int ipu_bus_register_driver(struct ipu_bus_driver *adrv)
+{
+	adrv->drv.bus = &ipu_bus;
+	return driver_register(&adrv->drv);
+}
+EXPORT_SYMBOL(ipu_bus_register_driver);
+
+int ipu_bus_unregister_driver(struct ipu_bus_driver *adrv)
+{
+	driver_unregister(&adrv->drv);
+	return 0;
+}
+EXPORT_SYMBOL(ipu_bus_unregister_driver);
+
+int ipu_bus_register(void)
+{
+	mutex_init(&ipu_bus_mutex);
+	return bus_register(&ipu_bus);
+}
+
+void ipu_bus_unregister(void)
+{
+	mutex_destroy(&ipu_bus_mutex);
+	return bus_unregister(&ipu_bus);
+}
+
+static int flr_rpm_recovery(struct device *dev, void *p)
+{
+	dev_dbg(dev, "FLR recovery call\n");
+	/*
+	 * We are not necessarily going through device from child to
+	 * parent. runtime PM refuses to change state for parent if the child
+	 * is still active. At FLR (full reset for whole IPU) that doesn't
+	 * matter. Everything has been power gated by HW during the FLR cycle
+	 * and we are just cleaning up SW state. Thus, ignore child during
+	 * set_suspended.
+	 */
+	pm_suspend_ignore_children(dev, true);
+	pm_runtime_set_suspended(dev);
+	pm_suspend_ignore_children(dev, false);
+
+	return 0;
+}
+
+int ipu_bus_flr_recovery(void)
+{
+	bus_for_each_dev(&ipu_bus, NULL, NULL, flr_rpm_recovery);
+	return 0;
+}
Index: b/drivers/media/pci/intel/ipu-bus.h
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu-bus.h
@@ -0,0 +1,69 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2013 - 2022 Intel Corporation */
+
+#ifndef IPU_BUS_H
+#define IPU_BUS_H
+
+#include <linux/device.h>
+#include <linux/irqreturn.h>
+#include <linux/list.h>
+#include <linux/mm.h>
+#include <linux/pci.h>
+
+#define IPU_BUS_NAME	IPU_NAME "-bus"
+
+struct ipu_buttress_ctrl;
+struct ipu_subsystem_trace_config;
+
+struct ipu_bus_device {
+	struct device dev;
+	struct list_head list;
+	void *pdata;
+	struct ipu_bus_driver *adrv;
+	struct ipu_mmu *mmu;
+	struct ipu_device *isp;
+	struct ipu_subsystem_trace_config *trace_cfg;
+	struct ipu_buttress_ctrl *ctrl;
+	u64 dma_mask;
+	/* Protect runtime_resume calls on the dev */
+	struct mutex resume_lock;
+};
+
+#define to_ipu_bus_device(_dev) container_of(_dev, struct ipu_bus_device, dev)
+
+struct ipu_bus_driver {
+	struct device_driver drv;
+	const char *wanted;
+	int (*probe)(struct ipu_bus_device *adev);
+	void (*remove)(struct ipu_bus_device *adev);
+	irqreturn_t (*isr)(struct ipu_bus_device *adev);
+	irqreturn_t (*isr_threaded)(struct ipu_bus_device *adev);
+	bool wake_isr_thread;
+};
+
+#define to_ipu_bus_driver(_drv) container_of(_drv, struct ipu_bus_driver, drv)
+
+struct ipu_bus_device *ipu_bus_initialize_device(struct pci_dev *pdev,
+						 struct device *parent,
+						 void *pdata,
+						 struct ipu_buttress_ctrl *ctrl,
+						 char *name, unsigned int nr);
+int ipu_bus_add_device(struct ipu_bus_device *adev);
+void ipu_bus_del_devices(struct pci_dev *pdev);
+
+int ipu_bus_register_driver(struct ipu_bus_driver *adrv);
+int ipu_bus_unregister_driver(struct ipu_bus_driver *adrv);
+
+int ipu_bus_register(void);
+void ipu_bus_unregister(void);
+
+#define module_ipu_bus_driver(drv)			\
+	module_driver(drv, ipu_bus_register_driver, \
+		ipu_bus_unregister_driver)
+
+#define ipu_bus_set_drvdata(adev, data) dev_set_drvdata(&(adev)->dev, data)
+#define ipu_bus_get_drvdata(adev) dev_get_drvdata(&(adev)->dev)
+
+int ipu_bus_flr_recovery(void);
+
+#endif
Index: b/drivers/media/pci/intel/ipu-buttress.c
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu-buttress.c
@@ -0,0 +1,1452 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) 2013 - 2022 Intel Corporation
+
+#include <linux/clk.h>
+#include <linux/clkdev.h>
+#include <linux/clk-provider.h>
+#include <linux/completion.h>
+#include <linux/debugfs.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/elf.h>
+#include <linux/errno.h>
+#include <linux/firmware.h>
+#include <linux/iopoll.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/pm_runtime.h>
+
+#include <media/ipu-isys.h>
+
+#include "ipu.h"
+#include "ipu-bus.h"
+#include "ipu-buttress.h"
+#include "ipu-platform-buttress-regs.h"
+#include "ipu-cpd.h"
+
+#define BOOTLOADER_STATUS_OFFSET       0x15c
+
+#define BOOTLOADER_MAGIC_KEY		0xb00710ad
+
+#define ENTRY	BUTTRESS_IU2CSECSR_IPC_PEER_COMP_ACTIONS_RST_PHASE1
+#define EXIT	BUTTRESS_IU2CSECSR_IPC_PEER_COMP_ACTIONS_RST_PHASE2
+#define QUERY	BUTTRESS_IU2CSECSR_IPC_PEER_QUERIED_IP_COMP_ACTIONS_RST_PHASE
+
+#define BUTTRESS_TSC_SYNC_RESET_TRIAL_MAX	10
+
+#define BUTTRESS_CSE_BOOTLOAD_TIMEOUT		5000000
+#define BUTTRESS_CSE_AUTHENTICATE_TIMEOUT	10000000
+#define BUTTRESS_CSE_FWRESET_TIMEOUT		100000
+
+#define BUTTRESS_IPC_TX_TIMEOUT			1000
+#define BUTTRESS_IPC_RESET_TIMEOUT		2000
+#define BUTTRESS_IPC_RX_TIMEOUT			1000
+#define BUTTRESS_IPC_VALIDITY_TIMEOUT		1000000
+#define BUTTRESS_TSC_SYNC_TIMEOUT		5000
+
+#define IPU_BUTTRESS_TSC_LIMIT	500	/* 26 us @ 19.2 MHz */
+#define IPU_BUTTRESS_TSC_RETRY	10
+
+#define BUTTRESS_CSE_IPC_RESET_RETRY	4
+
+#define BUTTRESS_IPC_CMD_SEND_RETRY	1
+
+static const u32 ipu_adev_irq_mask[] = {
+	BUTTRESS_ISR_IS_IRQ, BUTTRESS_ISR_PS_IRQ
+};
+
+int ipu_buttress_ipc_reset(struct ipu_device *isp, struct ipu_buttress_ipc *ipc)
+{
+	struct ipu_buttress *b = &isp->buttress;
+	unsigned int retries = BUTTRESS_IPC_RESET_TIMEOUT;
+	u32 val = 0, csr_in_clr;
+
+	if (!isp->secure_mode) {
+		dev_info(&isp->pdev->dev, "Skip ipc reset for non-secure mode");
+		return 0;
+	}
+
+	mutex_lock(&b->ipc_mutex);
+
+	/* Clear-by-1 CSR (all bits), corresponding internal states. */
+	val = readl(isp->base + ipc->csr_in);
+	writel(val, isp->base + ipc->csr_in);
+
+	/* Set peer CSR bit IPC_PEER_COMP_ACTIONS_RST_PHASE1 */
+	writel(ENTRY, isp->base + ipc->csr_out);
+	/*
+	 * Clear-by-1 all CSR bits EXCEPT following
+	 * bits:
+	 * A. IPC_PEER_COMP_ACTIONS_RST_PHASE1.
+	 * B. IPC_PEER_COMP_ACTIONS_RST_PHASE2.
+	 * C. Possibly custom bits, depending on
+	 * their role.
+	 */
+	csr_in_clr = BUTTRESS_IU2CSECSR_IPC_PEER_DEASSERTED_REG_VALID_REQ |
+		BUTTRESS_IU2CSECSR_IPC_PEER_ACKED_REG_VALID |
+		BUTTRESS_IU2CSECSR_IPC_PEER_ASSERTED_REG_VALID_REQ | QUERY;
+
+	while (retries--) {
+		usleep_range(400, 500);
+		val = readl(isp->base + ipc->csr_in);
+		switch (val) {
+		case (ENTRY | EXIT):
+		case (ENTRY | EXIT | QUERY):
+			dev_dbg(&isp->pdev->dev,
+				"%s:%s & %s\n", __func__,
+				"IPC_PEER_COMP_ACTIONS_RST_PHASE1",
+				"IPC_PEER_COMP_ACTIONS_RST_PHASE2");
+			/*
+			 * 1) Clear-by-1 CSR bits
+			 * (IPC_PEER_COMP_ACTIONS_RST_PHASE1,
+			 * IPC_PEER_COMP_ACTIONS_RST_PHASE2).
+			 * 2) Set peer CSR bit
+			 * IPC_PEER_QUERIED_IP_COMP_ACTIONS_RST_PHASE.
+			 */
+			writel(ENTRY | EXIT, isp->base + ipc->csr_in);
+			writel(QUERY, isp->base + ipc->csr_out);
+			break;
+		case ENTRY:
+		case (ENTRY | QUERY):
+			dev_dbg(&isp->pdev->dev,
+				"%s:IPC_PEER_COMP_ACTIONS_RST_PHASE1\n",
+				__func__);
+			/*
+			 * 1) Clear-by-1 CSR bits
+			 * (IPC_PEER_COMP_ACTIONS_RST_PHASE1,
+			 * IPC_PEER_QUERIED_IP_COMP_ACTIONS_RST_PHASE).
+			 * 2) Set peer CSR bit
+			 * IPC_PEER_COMP_ACTIONS_RST_PHASE1.
+			 */
+			writel(ENTRY | QUERY, isp->base + ipc->csr_in);
+			writel(ENTRY, isp->base + ipc->csr_out);
+			break;
+		case EXIT:
+		case (EXIT | QUERY):
+			dev_dbg(&isp->pdev->dev,
+				"%s: IPC_PEER_COMP_ACTIONS_RST_PHASE2\n",
+				__func__);
+			/*
+			 * Clear-by-1 CSR bit
+			 * IPC_PEER_COMP_ACTIONS_RST_PHASE2.
+			 * 1) Clear incoming doorbell.
+			 * 2) Clear-by-1 all CSR bits EXCEPT following
+			 * bits:
+			 * A. IPC_PEER_COMP_ACTIONS_RST_PHASE1.
+			 * B. IPC_PEER_COMP_ACTIONS_RST_PHASE2.
+			 * C. Possibly custom bits, depending on
+			 * their role.
+			 * 3) Set peer CSR bit
+			 * IPC_PEER_COMP_ACTIONS_RST_PHASE2.
+			 */
+			writel(EXIT, isp->base + ipc->csr_in);
+			writel(0, isp->base + ipc->db0_in);
+			writel(csr_in_clr, isp->base + ipc->csr_in);
+			writel(EXIT, isp->base + ipc->csr_out);
+
+			/*
+			 * Read csr_in again to make sure if RST_PHASE2 is done.
+			 * If csr_in is QUERY, it should be handled again.
+			 */
+			usleep_range(200, 300);
+			val = readl(isp->base + ipc->csr_in);
+			if (val & QUERY) {
+				dev_dbg(&isp->pdev->dev,
+					"%s: RST_PHASE2 retry csr_in = %x\n",
+					__func__, val);
+				break;
+			}
+			mutex_unlock(&b->ipc_mutex);
+			return 0;
+		case QUERY:
+			dev_dbg(&isp->pdev->dev,
+				"%s: %s\n", __func__,
+				"IPC_PEER_QUERIED_IP_COMP_ACTIONS_RST_PHASE");
+			/*
+			 * 1) Clear-by-1 CSR bit
+			 * IPC_PEER_QUERIED_IP_COMP_ACTIONS_RST_PHASE.
+			 * 2) Set peer CSR bit
+			 * IPC_PEER_COMP_ACTIONS_RST_PHASE1
+			 */
+			writel(QUERY, isp->base + ipc->csr_in);
+			writel(ENTRY, isp->base + ipc->csr_out);
+			break;
+		default:
+			dev_dbg_ratelimited(&isp->pdev->dev,
+					    "%s: unexpected CSR 0x%x\n",
+					    __func__, val);
+			break;
+		}
+	}
+
+	mutex_unlock(&b->ipc_mutex);
+	dev_err(&isp->pdev->dev, "Timed out while waiting for CSE\n");
+
+	return -ETIMEDOUT;
+}
+
+static void
+ipu_buttress_ipc_validity_close(struct ipu_device *isp,
+				struct ipu_buttress_ipc *ipc)
+{
+	/* Set bit 5 in CSE CSR */
+	writel(BUTTRESS_IU2CSECSR_IPC_PEER_DEASSERTED_REG_VALID_REQ,
+	       isp->base + ipc->csr_out);
+}
+
+static int
+ipu_buttress_ipc_validity_open(struct ipu_device *isp,
+			       struct ipu_buttress_ipc *ipc)
+{
+	unsigned int mask = BUTTRESS_IU2CSECSR_IPC_PEER_ACKED_REG_VALID;
+	unsigned int tout = BUTTRESS_IPC_VALIDITY_TIMEOUT;
+	void __iomem *addr;
+	int ret;
+	u32 val;
+
+	/* Set bit 3 in CSE CSR */
+	writel(BUTTRESS_IU2CSECSR_IPC_PEER_ASSERTED_REG_VALID_REQ,
+	       isp->base + ipc->csr_out);
+
+	addr = isp->base + ipc->csr_in;
+	ret = readl_poll_timeout(addr, val, val & mask, 200, tout);
+	if (ret) {
+		val = readl(addr);
+		dev_err(&isp->pdev->dev, "CSE validity timeout 0x%x\n", val);
+		ipu_buttress_ipc_validity_close(isp, ipc);
+	}
+
+	return ret;
+}
+
+static void ipu_buttress_ipc_recv(struct ipu_device *isp,
+				  struct ipu_buttress_ipc *ipc, u32 *ipc_msg)
+{
+	if (ipc_msg)
+		*ipc_msg = readl(isp->base + ipc->data0_in);
+	writel(0, isp->base + ipc->db0_in);
+}
+
+static int ipu_buttress_ipc_send_bulk(struct ipu_device *isp,
+				      enum ipu_buttress_ipc_domain ipc_domain,
+				      struct ipu_ipc_buttress_bulk_msg *msgs,
+				      u32 size)
+{
+	struct ipu_buttress *b = &isp->buttress;
+	struct ipu_buttress_ipc *ipc;
+	unsigned long tx_timeout_jiffies, rx_timeout_jiffies;
+	u32 val;
+	int ret;
+	int tout;
+	unsigned int i, retry = BUTTRESS_IPC_CMD_SEND_RETRY;
+
+	ipc = ipc_domain == IPU_BUTTRESS_IPC_CSE ? &b->cse : &b->ish;
+
+	mutex_lock(&b->ipc_mutex);
+
+	ret = ipu_buttress_ipc_validity_open(isp, ipc);
+	if (ret) {
+		dev_err(&isp->pdev->dev, "IPC validity open failed\n");
+		goto out;
+	}
+
+	tx_timeout_jiffies = msecs_to_jiffies(BUTTRESS_IPC_TX_TIMEOUT);
+	rx_timeout_jiffies = msecs_to_jiffies(BUTTRESS_IPC_RX_TIMEOUT);
+
+	for (i = 0; i < size; i++) {
+		reinit_completion(&ipc->send_complete);
+		if (msgs[i].require_resp)
+			reinit_completion(&ipc->recv_complete);
+
+		dev_dbg(&isp->pdev->dev, "bulk IPC command: 0x%x\n",
+			msgs[i].cmd);
+		writel(msgs[i].cmd, isp->base + ipc->data0_out);
+
+		val = BUTTRESS_IU2CSEDB0_BUSY | msgs[i].cmd_size;
+
+		writel(val, isp->base + ipc->db0_out);
+
+		tout = wait_for_completion_timeout(&ipc->send_complete,
+						   tx_timeout_jiffies);
+		if (!tout) {
+			dev_err(&isp->pdev->dev, "send IPC response timeout\n");
+			if (!retry--) {
+				ret = -ETIMEDOUT;
+				goto out;
+			}
+
+			/*
+			 * WORKAROUND: Sometimes CSE is not
+			 * responding on first try, try again.
+			 */
+			writel(0, isp->base + ipc->db0_out);
+			i--;
+			continue;
+		}
+
+		retry = BUTTRESS_IPC_CMD_SEND_RETRY;
+
+		if (!msgs[i].require_resp)
+			continue;
+
+		tout = wait_for_completion_timeout(&ipc->recv_complete,
+						   rx_timeout_jiffies);
+		if (!tout) {
+			dev_err(&isp->pdev->dev, "recv IPC response timeout\n");
+			ret = -ETIMEDOUT;
+			goto out;
+		}
+
+		if (ipc->nack_mask &&
+		    (ipc->recv_data & ipc->nack_mask) == ipc->nack) {
+			dev_err(&isp->pdev->dev,
+				"IPC NACK for cmd 0x%x\n", msgs[i].cmd);
+			ret = -ENODEV;
+			goto out;
+		}
+
+		if (ipc->recv_data != msgs[i].expected_resp) {
+			dev_err(&isp->pdev->dev,
+				"expected resp: 0x%x, IPC response: 0x%x ",
+				msgs[i].expected_resp, ipc->recv_data);
+			ret = -EIO;
+			goto out;
+		}
+	}
+
+	dev_dbg(&isp->pdev->dev, "bulk IPC commands done\n");
+
+out:
+	ipu_buttress_ipc_validity_close(isp, ipc);
+	mutex_unlock(&b->ipc_mutex);
+	return ret;
+}
+
+static int
+ipu_buttress_ipc_send(struct ipu_device *isp,
+		      enum ipu_buttress_ipc_domain ipc_domain,
+		      u32 ipc_msg, u32 size, bool require_resp,
+		      u32 expected_resp)
+{
+	struct ipu_ipc_buttress_bulk_msg msg = {
+		.cmd = ipc_msg,
+		.cmd_size = size,
+		.require_resp = require_resp,
+		.expected_resp = expected_resp,
+	};
+
+	return ipu_buttress_ipc_send_bulk(isp, ipc_domain, &msg, 1);
+}
+
+static irqreturn_t ipu_buttress_call_isr(struct ipu_bus_device *adev)
+{
+	irqreturn_t ret = IRQ_WAKE_THREAD;
+
+	if (!adev || !adev->adrv)
+		return IRQ_NONE;
+
+	if (adev->adrv->isr)
+		ret = adev->adrv->isr(adev);
+
+	if (ret == IRQ_WAKE_THREAD && !adev->adrv->isr_threaded)
+		ret = IRQ_NONE;
+
+	adev->adrv->wake_isr_thread = (ret == IRQ_WAKE_THREAD);
+
+	return ret;
+}
+
+irqreturn_t ipu_buttress_isr(int irq, void *isp_ptr)
+{
+	struct ipu_device *isp = isp_ptr;
+	struct ipu_bus_device *adev[] = { isp->isys, isp->psys };
+	struct ipu_buttress *b = &isp->buttress;
+	irqreturn_t ret = IRQ_NONE;
+	u32 disable_irqs = 0;
+	u32 irq_status;
+	u32 reg_irq_sts = BUTTRESS_REG_ISR_STATUS;
+	unsigned int i;
+
+	pm_runtime_get(&isp->pdev->dev);
+
+	if (!pm_runtime_active(&isp->pdev->dev)) {
+		irq_status = readl(isp->base + reg_irq_sts);
+		writel(irq_status, isp->base + BUTTRESS_REG_ISR_CLEAR);
+		pm_runtime_put(&isp->pdev->dev);
+		return IRQ_HANDLED;
+	}
+
+	irq_status = readl(isp->base + reg_irq_sts);
+	if (!irq_status) {
+		pm_runtime_put(&isp->pdev->dev);
+		return IRQ_NONE;
+	}
+
+	do {
+		writel(irq_status, isp->base + BUTTRESS_REG_ISR_CLEAR);
+
+		for (i = 0; i < ARRAY_SIZE(ipu_adev_irq_mask); i++) {
+			if (irq_status & ipu_adev_irq_mask[i]) {
+				irqreturn_t r = ipu_buttress_call_isr(adev[i]);
+
+				if (r == IRQ_WAKE_THREAD) {
+					ret = IRQ_WAKE_THREAD;
+					disable_irqs |= ipu_adev_irq_mask[i];
+				} else if (ret == IRQ_NONE &&
+					   r == IRQ_HANDLED) {
+					ret = IRQ_HANDLED;
+				}
+			}
+		}
+
+		if (irq_status & (BUTTRESS_ISR_IPC_FROM_CSE_IS_WAITING |
+				  BUTTRESS_ISR_IPC_FROM_ISH_IS_WAITING |
+				  BUTTRESS_ISR_IPC_EXEC_DONE_BY_CSE |
+				  BUTTRESS_ISR_IPC_EXEC_DONE_BY_ISH |
+				  BUTTRESS_ISR_SAI_VIOLATION) &&
+		    ret == IRQ_NONE)
+			ret = IRQ_HANDLED;
+
+		if (irq_status & BUTTRESS_ISR_IPC_FROM_CSE_IS_WAITING) {
+			dev_dbg(&isp->pdev->dev,
+				"BUTTRESS_ISR_IPC_FROM_CSE_IS_WAITING\n");
+			ipu_buttress_ipc_recv(isp, &b->cse, &b->cse.recv_data);
+			complete(&b->cse.recv_complete);
+		}
+
+		if (irq_status & BUTTRESS_ISR_IPC_FROM_ISH_IS_WAITING) {
+			dev_dbg(&isp->pdev->dev,
+				"BUTTRESS_ISR_IPC_FROM_ISH_IS_WAITING\n");
+			ipu_buttress_ipc_recv(isp, &b->ish, &b->ish.recv_data);
+			complete(&b->ish.recv_complete);
+		}
+
+		if (irq_status & BUTTRESS_ISR_IPC_EXEC_DONE_BY_CSE) {
+			dev_dbg(&isp->pdev->dev,
+				"BUTTRESS_ISR_IPC_EXEC_DONE_BY_CSE\n");
+			complete(&b->cse.send_complete);
+		}
+
+		if (irq_status & BUTTRESS_ISR_IPC_EXEC_DONE_BY_ISH) {
+			dev_dbg(&isp->pdev->dev,
+				"BUTTRESS_ISR_IPC_EXEC_DONE_BY_CSE\n");
+			complete(&b->ish.send_complete);
+		}
+
+		if (irq_status & BUTTRESS_ISR_SAI_VIOLATION &&
+		    ipu_buttress_get_secure_mode(isp)) {
+			dev_err(&isp->pdev->dev,
+				"BUTTRESS_ISR_SAI_VIOLATION\n");
+			WARN_ON(1);
+		}
+
+		if (irq_status & (BUTTRESS_ISR_IS_FATAL_MEM_ERR |
+				  BUTTRESS_ISR_PS_FATAL_MEM_ERR)) {
+			dev_err(&isp->pdev->dev,
+				"BUTTRESS_ISR_FATAL_MEM_ERR\n");
+		}
+
+		if (irq_status & BUTTRESS_ISR_UFI_ERROR)
+			dev_err(&isp->pdev->dev, "BUTTRESS_ISR_UFI_ERROR\n");
+
+		irq_status = readl(isp->base + reg_irq_sts);
+	} while (irq_status && !isp->flr_done);
+
+	if (disable_irqs)
+		writel(BUTTRESS_IRQS & ~disable_irqs,
+		       isp->base + BUTTRESS_REG_ISR_ENABLE);
+
+	pm_runtime_put(&isp->pdev->dev);
+
+	return ret;
+}
+
+irqreturn_t ipu_buttress_isr_threaded(int irq, void *isp_ptr)
+{
+	struct ipu_device *isp = isp_ptr;
+	struct ipu_bus_device *adev[] = { isp->isys, isp->psys };
+	irqreturn_t ret = IRQ_NONE;
+	unsigned int i;
+
+	dev_dbg(&isp->pdev->dev, "isr: Buttress threaded interrupt handler\n");
+
+	for (i = 0; i < ARRAY_SIZE(ipu_adev_irq_mask); i++) {
+		if (adev[i] && adev[i]->adrv &&
+		    adev[i]->adrv->wake_isr_thread &&
+		    adev[i]->adrv->isr_threaded(adev[i]) == IRQ_HANDLED)
+			ret = IRQ_HANDLED;
+	}
+
+	writel(BUTTRESS_IRQS, isp->base + BUTTRESS_REG_ISR_ENABLE);
+
+	return ret;
+}
+
+int ipu_buttress_power(struct device *dev,
+		       struct ipu_buttress_ctrl *ctrl, bool on)
+{
+	struct ipu_device *isp = to_ipu_bus_device(dev)->isp;
+	u32 pwr_sts, val;
+	int ret = 0;
+
+	if (!ctrl)
+		return 0;
+
+	/* Until FLR completion nothing is expected to work */
+	if (isp->flr_done)
+		return 0;
+
+	mutex_lock(&isp->buttress.power_mutex);
+
+	if (!on) {
+		val = 0;
+		pwr_sts = ctrl->pwr_sts_off << ctrl->pwr_sts_shift;
+	} else {
+		val = BUTTRESS_FREQ_CTL_START |
+			ctrl->divisor << ctrl->divisor_shift |
+			ctrl->qos_floor << BUTTRESS_FREQ_CTL_QOS_FLOOR_SHIFT |
+			BUTTRESS_FREQ_CTL_ICCMAX_LEVEL;
+
+		pwr_sts = ctrl->pwr_sts_on << ctrl->pwr_sts_shift;
+	}
+
+	writel(val, isp->base + ctrl->freq_ctl);
+
+	ret = readl_poll_timeout(isp->base + BUTTRESS_REG_PWR_STATE,
+				 val, ((val & ctrl->pwr_sts_mask) == pwr_sts),
+				 100, BUTTRESS_POWER_TIMEOUT);
+	if (ret)
+		dev_err(&isp->pdev->dev,
+			"Change power status timeout with 0x%x\n", val);
+
+	ctrl->started = !ret && on;
+
+	mutex_unlock(&isp->buttress.power_mutex);
+
+	return ret;
+}
+
+static bool secure_mode_enable = 1;
+module_param(secure_mode_enable, bool, 0660);
+MODULE_PARM_DESC(secure_mode, "IPU secure mode enable");
+
+void ipu_buttress_set_secure_mode(struct ipu_device *isp)
+{
+	u8 retry = 100;
+	u32 val, read;
+
+	/*
+	 * HACK to disable possible secure mode. This can be
+	 * reverted when CSE is disabling the secure mode
+	 */
+	read = readl(isp->base + BUTTRESS_REG_SECURITY_CTL);
+
+	if (secure_mode_enable)
+		val = read |= BUTTRESS_SECURITY_CTL_FW_SECURE_MODE;
+	else
+		val = read & ~BUTTRESS_SECURITY_CTL_FW_SECURE_MODE;
+
+	if (val == read)
+		return;
+
+	writel(val, isp->base + BUTTRESS_REG_SECURITY_CTL);
+
+	/* In B0, for some registers in buttress, because of a hw bug, write
+	 * might not succeed at first attempt. Write twice until the
+	 * write is successful
+	 */
+	writel(val, isp->base + BUTTRESS_REG_SECURITY_CTL);
+
+	while (retry--) {
+		read = readl(isp->base + BUTTRESS_REG_SECURITY_CTL);
+		if (read == val)
+			break;
+
+		writel(val, isp->base + BUTTRESS_REG_SECURITY_CTL);
+
+		if (retry == 0)
+			dev_err(&isp->pdev->dev,
+				"update security control register failed\n");
+	}
+}
+
+bool ipu_buttress_get_secure_mode(struct ipu_device *isp)
+{
+	u32 val;
+
+	val = readl(isp->base + BUTTRESS_REG_SECURITY_CTL);
+
+	return val & BUTTRESS_SECURITY_CTL_FW_SECURE_MODE;
+}
+
+bool ipu_buttress_auth_done(struct ipu_device *isp)
+{
+	u32 val;
+
+	if (!isp->secure_mode)
+		return 1;
+
+	val = readl(isp->base + BUTTRESS_REG_SECURITY_CTL);
+
+	return (val & BUTTRESS_SECURITY_CTL_FW_SETUP_MASK) ==
+	    BUTTRESS_SECURITY_CTL_AUTH_DONE;
+}
+EXPORT_SYMBOL(ipu_buttress_auth_done);
+
+static void ipu_buttress_set_psys_ratio(struct ipu_device *isp,
+					unsigned int psys_divisor,
+					unsigned int psys_qos_floor)
+{
+	struct ipu_buttress_ctrl *ctrl = isp->psys->ctrl;
+
+	mutex_lock(&isp->buttress.power_mutex);
+
+	if (ctrl->divisor == psys_divisor && ctrl->qos_floor == psys_qos_floor)
+		goto out_mutex_unlock;
+
+	ctrl->divisor = psys_divisor;
+	ctrl->qos_floor = psys_qos_floor;
+
+	if (ctrl->started) {
+		/*
+		 * According to documentation driver initiates DVFS
+		 * transition by writing wanted ratio, floor ratio and start
+		 * bit. No need to stop PS first
+		 */
+		writel(BUTTRESS_FREQ_CTL_START |
+		       ctrl->qos_floor << BUTTRESS_FREQ_CTL_QOS_FLOOR_SHIFT |
+		       psys_divisor, isp->base + BUTTRESS_REG_PS_FREQ_CTL);
+	}
+
+out_mutex_unlock:
+	mutex_unlock(&isp->buttress.power_mutex);
+}
+
+static void ipu_buttress_set_isys_ratio(struct ipu_device *isp,
+					unsigned int isys_divisor)
+{
+	struct ipu_buttress_ctrl *ctrl = isp->isys->ctrl;
+
+	mutex_lock(&isp->buttress.power_mutex);
+
+	if (ctrl->divisor == isys_divisor)
+		goto out_mutex_unlock;
+
+	ctrl->divisor = isys_divisor;
+
+	if (ctrl->started) {
+		writel(BUTTRESS_FREQ_CTL_START |
+		       ctrl->qos_floor << BUTTRESS_FREQ_CTL_QOS_FLOOR_SHIFT |
+		       isys_divisor, isp->base + BUTTRESS_REG_IS_FREQ_CTL);
+	}
+
+out_mutex_unlock:
+	mutex_unlock(&isp->buttress.power_mutex);
+}
+
+static void ipu_buttress_set_psys_freq(struct ipu_device *isp,
+				       unsigned int freq)
+{
+	unsigned int psys_ratio = freq / BUTTRESS_PS_FREQ_STEP;
+
+	if (isp->buttress.psys_force_ratio)
+		return;
+
+	ipu_buttress_set_psys_ratio(isp, psys_ratio, psys_ratio);
+}
+
+void
+ipu_buttress_add_psys_constraint(struct ipu_device *isp,
+				 struct ipu_buttress_constraint *constraint)
+{
+	struct ipu_buttress *b = &isp->buttress;
+
+	mutex_lock(&b->cons_mutex);
+	list_add(&constraint->list, &b->constraints);
+
+	if (constraint->min_freq > b->psys_min_freq) {
+		isp->buttress.psys_min_freq = min(constraint->min_freq,
+						  b->psys_fused_freqs.max_freq);
+		ipu_buttress_set_psys_freq(isp, b->psys_min_freq);
+	}
+	mutex_unlock(&b->cons_mutex);
+}
+EXPORT_SYMBOL_GPL(ipu_buttress_add_psys_constraint);
+
+void
+ipu_buttress_remove_psys_constraint(struct ipu_device *isp,
+				    struct ipu_buttress_constraint *constraint)
+{
+	struct ipu_buttress *b = &isp->buttress;
+	struct ipu_buttress_constraint *c;
+	unsigned int min_freq = 0;
+
+	mutex_lock(&b->cons_mutex);
+	list_del(&constraint->list);
+
+	if (constraint->min_freq >= b->psys_min_freq) {
+		list_for_each_entry(c, &b->constraints, list)
+			if (c->min_freq > min_freq)
+				min_freq = c->min_freq;
+
+		b->psys_min_freq = clamp(min_freq,
+					 b->psys_fused_freqs.efficient_freq,
+					 b->psys_fused_freqs.max_freq);
+		ipu_buttress_set_psys_freq(isp, b->psys_min_freq);
+	}
+	mutex_unlock(&b->cons_mutex);
+}
+EXPORT_SYMBOL_GPL(ipu_buttress_remove_psys_constraint);
+
+int ipu_buttress_reset_authentication(struct ipu_device *isp)
+{
+	int ret;
+	u32 val;
+
+	if (!isp->secure_mode) {
+		dev_dbg(&isp->pdev->dev,
+			"Non-secure mode -> skip authentication\n");
+		return 0;
+	}
+
+	writel(BUTTRESS_FW_RESET_CTL_START, isp->base +
+	       BUTTRESS_REG_FW_RESET_CTL);
+
+	ret = readl_poll_timeout(isp->base + BUTTRESS_REG_FW_RESET_CTL, val,
+				 val & BUTTRESS_FW_RESET_CTL_DONE, 500,
+				 BUTTRESS_CSE_FWRESET_TIMEOUT);
+	if (ret) {
+		dev_err(&isp->pdev->dev,
+			"Time out while resetting authentication state\n");
+	} else {
+		dev_info(&isp->pdev->dev,
+			 "FW reset for authentication done\n");
+		writel(0, isp->base + BUTTRESS_REG_FW_RESET_CTL);
+		/* leave some time for HW restore */
+		usleep_range(800, 1000);
+	}
+
+	return ret;
+}
+
+int ipu_buttress_map_fw_image(struct ipu_bus_device *sys,
+			      const struct firmware *fw, struct sg_table *sgt)
+{
+	struct page **pages;
+	const void *addr;
+	unsigned long n_pages;
+	int rval, i;
+
+	n_pages = PAGE_ALIGN(fw->size) >> PAGE_SHIFT;
+
+	pages = kmalloc_array(n_pages, sizeof(*pages), GFP_KERNEL);
+	if (!pages)
+		return -ENOMEM;
+
+	addr = fw->data;
+	for (i = 0; i < n_pages; i++) {
+		struct page *p = vmalloc_to_page(addr);
+
+		if (!p) {
+			rval = -ENODEV;
+			goto out;
+		}
+		pages[i] = p;
+		addr += PAGE_SIZE;
+	}
+
+	rval = sg_alloc_table_from_pages(sgt, pages, n_pages, 0, fw->size,
+					 GFP_KERNEL);
+	if (rval) {
+		rval = -ENOMEM;
+		goto out;
+	}
+
+	rval = dma_map_sgtable(&sys->dev, sgt, DMA_TO_DEVICE, 0);
+	if (rval < 0) {
+		rval = -ENOMEM;
+		sg_free_table(sgt);
+		goto out;
+	}
+
+	dma_sync_sgtable_for_device(&sys->dev, sgt, DMA_TO_DEVICE);
+
+out:
+	kfree(pages);
+
+	return rval;
+}
+EXPORT_SYMBOL_GPL(ipu_buttress_map_fw_image);
+
+int ipu_buttress_unmap_fw_image(struct ipu_bus_device *sys,
+				struct sg_table *sgt)
+{
+	dma_unmap_sg(&sys->dev, sgt->sgl, sgt->nents, DMA_TO_DEVICE);
+	sg_free_table(sgt);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ipu_buttress_unmap_fw_image);
+
+int ipu_buttress_authenticate(struct ipu_device *isp)
+{
+	struct ipu_psys_pdata *psys_pdata;
+	struct ipu_buttress *b = &isp->buttress;
+	u32 data, mask, done, fail;
+	int rval;
+
+	if (!isp->secure_mode) {
+		dev_dbg(&isp->pdev->dev,
+			"Non-secure mode -> skip authentication\n");
+		return 0;
+	}
+
+	psys_pdata = isp->psys->pdata;
+
+	mutex_lock(&b->auth_mutex);
+
+	if (ipu_buttress_auth_done(isp)) {
+		rval = 0;
+		goto iunit_power_off;
+	}
+
+	/*
+	 * Write address of FIT table to FW_SOURCE register
+	 * Let's use fw address. I.e. not using FIT table yet
+	 */
+	data = lower_32_bits(isp->pkg_dir_dma_addr);
+	writel(data, isp->base + BUTTRESS_REG_FW_SOURCE_BASE_LO);
+
+	data = upper_32_bits(isp->pkg_dir_dma_addr);
+	writel(data, isp->base + BUTTRESS_REG_FW_SOURCE_BASE_HI);
+
+	/*
+	 * Write boot_load into IU2CSEDATA0
+	 * Write sizeof(boot_load) | 0x2 << CLIENT_ID to
+	 * IU2CSEDB.IU2CSECMD and set IU2CSEDB.IU2CSEBUSY as
+	 */
+	dev_info(&isp->pdev->dev, "Sending BOOT_LOAD to CSE\n");
+	rval = ipu_buttress_ipc_send(isp, IPU_BUTTRESS_IPC_CSE,
+				     BUTTRESS_IU2CSEDATA0_IPC_BOOT_LOAD,
+				     1, 1,
+				     BUTTRESS_CSE2IUDATA0_IPC_BOOT_LOAD_DONE);
+	if (rval) {
+		dev_err(&isp->pdev->dev, "CSE boot_load failed\n");
+		goto iunit_power_off;
+	}
+
+	mask = BUTTRESS_SECURITY_CTL_FW_SETUP_MASK;
+	done = BUTTRESS_SECURITY_CTL_FW_SETUP_DONE;
+	fail = BUTTRESS_SECURITY_CTL_AUTH_FAILED;
+	rval = readl_poll_timeout(isp->base + BUTTRESS_REG_SECURITY_CTL, data,
+				  ((data & mask) == done ||
+				   (data & mask) == fail), 500,
+				  BUTTRESS_CSE_BOOTLOAD_TIMEOUT);
+	if (rval) {
+		dev_err(&isp->pdev->dev, "CSE boot_load timeout\n");
+		goto iunit_power_off;
+	}
+
+	data = readl(isp->base + BUTTRESS_REG_SECURITY_CTL) & mask;
+	if (data == fail) {
+		dev_err(&isp->pdev->dev, "CSE auth failed\n");
+		rval = -EINVAL;
+		goto iunit_power_off;
+	}
+
+	rval = readl_poll_timeout(psys_pdata->base + BOOTLOADER_STATUS_OFFSET,
+				  data, data == BOOTLOADER_MAGIC_KEY, 500,
+				  BUTTRESS_CSE_BOOTLOAD_TIMEOUT);
+	if (rval) {
+		dev_err(&isp->pdev->dev, "Expect magic number timeout 0x%x\n",
+			data);
+		goto iunit_power_off;
+	}
+
+	/*
+	 * Write authenticate_run into IU2CSEDATA0
+	 * Write sizeof(boot_load) | 0x2 << CLIENT_ID to
+	 * IU2CSEDB.IU2CSECMD and set IU2CSEDB.IU2CSEBUSY as
+	 */
+	dev_info(&isp->pdev->dev, "Sending AUTHENTICATE_RUN to CSE\n");
+	rval = ipu_buttress_ipc_send(isp, IPU_BUTTRESS_IPC_CSE,
+				     BUTTRESS_IU2CSEDATA0_IPC_AUTH_RUN,
+				     1, 1,
+				     BUTTRESS_CSE2IUDATA0_IPC_AUTH_RUN_DONE);
+	if (rval) {
+		dev_err(&isp->pdev->dev, "CSE authenticate_run failed\n");
+		goto iunit_power_off;
+	}
+
+	done = BUTTRESS_SECURITY_CTL_AUTH_DONE;
+	rval = readl_poll_timeout(isp->base + BUTTRESS_REG_SECURITY_CTL, data,
+				  ((data & mask) == done ||
+				   (data & mask) == fail), 500,
+				  BUTTRESS_CSE_AUTHENTICATE_TIMEOUT);
+	if (rval) {
+		dev_err(&isp->pdev->dev, "CSE authenticate timeout\n");
+		goto iunit_power_off;
+	}
+
+	data = readl(isp->base + BUTTRESS_REG_SECURITY_CTL) & mask;
+	if (data == fail) {
+		dev_err(&isp->pdev->dev, "CSE boot_load failed\n");
+		rval = -EINVAL;
+		goto iunit_power_off;
+	}
+
+	dev_info(&isp->pdev->dev, "CSE authenticate_run done\n");
+
+iunit_power_off:
+	mutex_unlock(&b->auth_mutex);
+
+	return rval;
+}
+
+static int ipu_buttress_send_tsc_request(struct ipu_device *isp)
+{
+	u32 val, mask, shift, done;
+	int ret;
+
+	mask = BUTTRESS_PWR_STATE_HH_STATUS_MASK;
+	shift = BUTTRESS_PWR_STATE_HH_STATUS_SHIFT;
+
+	writel(BUTTRESS_FABRIC_CMD_START_TSC_SYNC,
+	       isp->base + BUTTRESS_REG_FABRIC_CMD);
+
+	val = readl(isp->base + BUTTRESS_REG_PWR_STATE);
+	val = (val & mask) >> shift;
+	if (val == BUTTRESS_PWR_STATE_HH_STATE_ERR) {
+		dev_err(&isp->pdev->dev, "Start tsc sync failed\n");
+		return -EINVAL;
+	}
+
+	done = BUTTRESS_PWR_STATE_HH_STATE_DONE;
+	ret = readl_poll_timeout(isp->base + BUTTRESS_REG_PWR_STATE, val,
+				 ((val & mask) >> shift == done), 500,
+				 BUTTRESS_TSC_SYNC_TIMEOUT);
+	if (ret)
+		dev_err(&isp->pdev->dev, "Start tsc sync timeout\n");
+
+	return ret;
+}
+
+int ipu_buttress_start_tsc_sync(struct ipu_device *isp)
+{
+	unsigned int i;
+
+	for (i = 0; i < BUTTRESS_TSC_SYNC_RESET_TRIAL_MAX; i++) {
+		int ret;
+
+		ret = ipu_buttress_send_tsc_request(isp);
+		if (ret == -ETIMEDOUT) {
+			u32 val;
+			/* set tsw soft reset */
+			val = readl(isp->base + BUTTRESS_REG_TSW_CTL);
+			val = val | BUTTRESS_TSW_CTL_SOFT_RESET;
+			writel(val, isp->base + BUTTRESS_REG_TSW_CTL);
+			/* clear tsw soft reset */
+			val = val & (~BUTTRESS_TSW_CTL_SOFT_RESET);
+			writel(val, isp->base + BUTTRESS_REG_TSW_CTL);
+
+			continue;
+		}
+		return ret;
+	}
+
+	dev_err(&isp->pdev->dev, "TSC sync failed(timeout)\n");
+
+	return -ETIMEDOUT;
+}
+EXPORT_SYMBOL(ipu_buttress_start_tsc_sync);
+
+struct clk_ipu_sensor {
+	struct ipu_device *isp;
+	struct clk_hw hw;
+	unsigned int id;
+	unsigned long rate;
+};
+
+#define to_clk_ipu_sensor(_hw) container_of(_hw, struct clk_ipu_sensor, hw)
+/*
+ * The dev_id was hard code in platform data, as i2c bus number
+ * may change dynamiclly, we need to update this bus id
+ * accordingly.
+ *
+ * @adapter_id: hardware i2c adapter id, this was fixed in platform data
+ * return: i2c bus id registered in system
+ */
+int ipu_get_i2c_bus_id(int adapter_id, char *adapter_bdf, int bdf_len)
+{
+	struct i2c_adapter *adapter;
+	char name[32];
+	int i = 0;
+
+	if (adapter_bdf) {
+		while ((adapter = i2c_get_adapter(i)) != NULL) {
+			struct device *parent = adapter->dev.parent;
+			struct device *pp = parent->parent;
+
+			if (pp && !strncmp(adapter_bdf, dev_name(pp), bdf_len))
+				return i;
+			i++;
+		}
+	}
+
+	i = 0;
+	snprintf(name, sizeof(name), "i2c_designware.%d", adapter_id);
+	while ((adapter = i2c_get_adapter(i)) != NULL) {
+		struct device *parent = adapter->dev.parent;
+
+		if (parent && !strncmp(name, dev_name(parent), sizeof(name)))
+			return i;
+		i++;
+	}
+
+	/* Not found, should never happen! */
+	WARN_ON_ONCE(1);
+	return -1;
+}
+EXPORT_SYMBOL_GPL(ipu_get_i2c_bus_id);
+
+int ipu_buttress_tsc_read(struct ipu_device *isp, u64 *val)
+{
+	u32 tsc_hi_1, tsc_hi_2, tsc_lo;
+	unsigned long flags;
+
+	local_irq_save(flags);
+	tsc_hi_1 = readl(isp->base + BUTTRESS_REG_TSC_HI);
+	tsc_lo = readl(isp->base + BUTTRESS_REG_TSC_LO);
+	tsc_hi_2 = readl(isp->base + BUTTRESS_REG_TSC_HI);
+	if (tsc_hi_1 == tsc_hi_2) {
+		*val = (u64)tsc_hi_1 << 32 | tsc_lo;
+	} else {
+		/* Check if TSC has rolled over */
+		if (tsc_lo & BIT(31))
+			*val = (u64)tsc_hi_1 << 32 | tsc_lo;
+		else
+			*val = (u64)tsc_hi_2 << 32 | tsc_lo;
+	}
+	local_irq_restore(flags);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ipu_buttress_tsc_read);
+
+int ipu_buttress_isys_freq_set(void *data, u64 val)
+{
+	struct ipu_device *isp = data;
+	int rval;
+
+	if (val < BUTTRESS_MIN_FORCE_IS_FREQ ||
+	    val > BUTTRESS_MAX_FORCE_IS_FREQ)
+		return -EINVAL;
+
+	rval = pm_runtime_get_sync(&isp->isys->dev);
+	if (rval < 0) {
+		pm_runtime_put(&isp->isys->dev);
+		dev_err(&isp->pdev->dev, "Runtime PM failed (%d)\n", rval);
+		return rval;
+	}
+
+	do_div(val, BUTTRESS_IS_FREQ_STEP);
+	if (val)
+		ipu_buttress_set_isys_ratio(isp, val);
+
+	pm_runtime_put(&isp->isys->dev);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ipu_buttress_isys_freq_set);
+
+#ifdef CONFIG_DEBUG_FS
+
+static int ipu_buttress_reg_open(struct inode *inode, struct file *file)
+{
+	if (!inode->i_private)
+		return -EACCES;
+
+	file->private_data = inode->i_private;
+	return 0;
+}
+
+static ssize_t ipu_buttress_reg_read(struct file *file, char __user *buf,
+				     size_t count, loff_t *ppos)
+{
+	struct debugfs_reg32 *reg = file->private_data;
+	u8 tmp[11];
+	u32 val = readl((void __iomem *)reg->offset);
+	int len = scnprintf(tmp, sizeof(tmp), "0x%08x", val);
+
+	return simple_read_from_buffer(buf, len, ppos, &tmp, len);
+}
+
+static ssize_t ipu_buttress_reg_write(struct file *file,
+				      const char __user *buf,
+				      size_t count, loff_t *ppos)
+{
+	struct debugfs_reg32 *reg = file->private_data;
+	u32 val;
+	int rval;
+
+	rval = kstrtou32_from_user(buf, count, 0, &val);
+	if (rval)
+		return rval;
+
+	writel(val, (void __iomem *)reg->offset);
+
+	return count;
+}
+
+static struct debugfs_reg32 buttress_regs[] = {
+	{"IU2CSEDB0", BUTTRESS_REG_IU2CSEDB0},
+	{"IU2CSEDATA0", BUTTRESS_REG_IU2CSEDATA0},
+	{"CSE2IUDB0", BUTTRESS_REG_CSE2IUDB0},
+	{"CSE2IUDATA0", BUTTRESS_REG_CSE2IUDATA0},
+	{"CSE2IUCSR", BUTTRESS_REG_CSE2IUCSR},
+	{"IU2CSECSR", BUTTRESS_REG_IU2CSECSR},
+};
+
+static const struct file_operations ipu_buttress_reg_fops = {
+	.owner = THIS_MODULE,
+	.open = ipu_buttress_reg_open,
+	.read = ipu_buttress_reg_read,
+	.write = ipu_buttress_reg_write,
+};
+
+static int ipu_buttress_start_tsc_sync_set(void *data, u64 val)
+{
+	struct ipu_device *isp = data;
+
+	return ipu_buttress_start_tsc_sync(isp);
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(ipu_buttress_start_tsc_sync_fops, NULL,
+			ipu_buttress_start_tsc_sync_set, "%llu\n");
+
+static int ipu_buttress_tsc_get(void *data, u64 *val)
+{
+	return ipu_buttress_tsc_read(data, val);
+}
+DEFINE_SIMPLE_ATTRIBUTE(ipu_buttress_tsc_fops, ipu_buttress_tsc_get,
+			NULL, "%llu\n");
+
+static int ipu_buttress_psys_force_freq_get(void *data, u64 *val)
+{
+	struct ipu_device *isp = data;
+
+	*val = isp->buttress.psys_force_ratio * BUTTRESS_PS_FREQ_STEP;
+
+	return 0;
+}
+
+static int ipu_buttress_psys_force_freq_set(void *data, u64 val)
+{
+	struct ipu_device *isp = data;
+
+	if (val && (val < BUTTRESS_MIN_FORCE_PS_FREQ ||
+		    val > BUTTRESS_MAX_FORCE_PS_FREQ))
+		return -EINVAL;
+
+	do_div(val, BUTTRESS_PS_FREQ_STEP);
+	isp->buttress.psys_force_ratio = val;
+
+	if (isp->buttress.psys_force_ratio)
+		ipu_buttress_set_psys_ratio(isp,
+					    isp->buttress.psys_force_ratio,
+					    isp->buttress.psys_force_ratio);
+	else
+		ipu_buttress_set_psys_freq(isp, isp->buttress.psys_min_freq);
+
+	return 0;
+}
+
+static int ipu_buttress_isys_freq_get(void *data, u64 *val)
+{
+	struct ipu_device *isp = data;
+	u32 reg_val;
+	int rval;
+
+	rval = pm_runtime_get_sync(&isp->isys->dev);
+	if (rval < 0) {
+		pm_runtime_put(&isp->isys->dev);
+		dev_err(&isp->pdev->dev, "Runtime PM failed (%d)\n", rval);
+		return rval;
+	}
+
+	reg_val = readl(isp->base + BUTTRESS_REG_IS_FREQ_CTL);
+
+	pm_runtime_put(&isp->isys->dev);
+
+	*val = IPU_IS_FREQ_RATIO_BASE *
+	    (reg_val & IPU_BUTTRESS_IS_FREQ_CTL_DIVISOR_MASK);
+
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(ipu_buttress_psys_force_freq_fops,
+			ipu_buttress_psys_force_freq_get,
+			ipu_buttress_psys_force_freq_set, "%llu\n");
+
+DEFINE_SIMPLE_ATTRIBUTE(ipu_buttress_psys_freq_fops,
+			ipu_buttress_psys_freq_get, NULL, "%llu\n");
+
+DEFINE_SIMPLE_ATTRIBUTE(ipu_buttress_isys_freq_fops,
+			ipu_buttress_isys_freq_get,
+			ipu_buttress_isys_freq_set, "%llu\n");
+
+int ipu_buttress_debugfs_init(struct ipu_device *isp)
+{
+	struct debugfs_reg32 *reg =
+	    devm_kcalloc(&isp->pdev->dev, ARRAY_SIZE(buttress_regs),
+			 sizeof(*reg), GFP_KERNEL);
+	struct dentry *dir, *file;
+	int i;
+
+	if (!reg)
+		return -ENOMEM;
+
+	dir = debugfs_create_dir("buttress", isp->ipu_dir);
+	if (!dir)
+		return -ENOMEM;
+
+	for (i = 0; i < ARRAY_SIZE(buttress_regs); i++, reg++) {
+		reg->offset = (unsigned long)isp->base +
+		    buttress_regs[i].offset;
+		reg->name = buttress_regs[i].name;
+		file = debugfs_create_file(reg->name, 0700,
+					   dir, reg, &ipu_buttress_reg_fops);
+		if (!file)
+			goto err;
+	}
+
+	file = debugfs_create_file("start_tsc_sync", 0200, dir, isp,
+				   &ipu_buttress_start_tsc_sync_fops);
+	if (!file)
+		goto err;
+	file = debugfs_create_file("tsc", 0400, dir, isp,
+				   &ipu_buttress_tsc_fops);
+	if (!file)
+		goto err;
+	file = debugfs_create_file("psys_force_freq", 0700, dir, isp,
+				   &ipu_buttress_psys_force_freq_fops);
+	if (!file)
+		goto err;
+
+	file = debugfs_create_file("psys_freq", 0400, dir, isp,
+				   &ipu_buttress_psys_freq_fops);
+	if (!file)
+		goto err;
+
+	file = debugfs_create_file("isys_freq", 0700, dir, isp,
+				   &ipu_buttress_isys_freq_fops);
+	if (!file)
+		goto err;
+
+	return 0;
+err:
+	debugfs_remove_recursive(dir);
+	return -ENOMEM;
+}
+
+#endif /* CONFIG_DEBUG_FS */
+
+u64 ipu_buttress_tsc_ticks_to_ns(u64 ticks, const struct ipu_device *isp)
+{
+	u64 ns = ticks * 10000;
+
+	/*
+	 * converting TSC tick count to ns is calculated by:
+	 * Example (TSC clock frequency is 19.2MHz):
+	 * ns = ticks * 1000 000 000 / 19.2Mhz
+	 *    = ticks * 1000 000 000 / 19200000Hz
+	 *    = ticks * 10000 / 192 ns
+	 */
+	do_div(ns, isp->buttress.ref_clk);
+
+	return ns;
+}
+EXPORT_SYMBOL_GPL(ipu_buttress_tsc_ticks_to_ns);
+
+static ssize_t psys_fused_min_freq_show(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	struct ipu_device *isp = pci_get_drvdata(to_pci_dev(dev));
+
+	return snprintf(buf, PAGE_SIZE, "%u\n",
+			isp->buttress.psys_fused_freqs.min_freq);
+}
+
+static DEVICE_ATTR_RO(psys_fused_min_freq);
+
+static ssize_t psys_fused_max_freq_show(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	struct ipu_device *isp = pci_get_drvdata(to_pci_dev(dev));
+
+	return snprintf(buf, PAGE_SIZE, "%u\n",
+			isp->buttress.psys_fused_freqs.max_freq);
+}
+
+static DEVICE_ATTR_RO(psys_fused_max_freq);
+
+static ssize_t psys_fused_efficient_freq_show(struct device *dev,
+					      struct device_attribute *attr,
+					      char *buf)
+{
+	struct ipu_device *isp = pci_get_drvdata(to_pci_dev(dev));
+
+	return snprintf(buf, PAGE_SIZE, "%u\n",
+			isp->buttress.psys_fused_freqs.efficient_freq);
+}
+
+static DEVICE_ATTR_RO(psys_fused_efficient_freq);
+
+int ipu_buttress_restore(struct ipu_device *isp)
+{
+	struct ipu_buttress *b = &isp->buttress;
+
+	writel(BUTTRESS_IRQS, isp->base + BUTTRESS_REG_ISR_CLEAR);
+	writel(BUTTRESS_IRQS, isp->base + BUTTRESS_REG_ISR_ENABLE);
+	writel(b->wdt_cached_value, isp->base + BUTTRESS_REG_WDT);
+
+	return 0;
+}
+
+int ipu_buttress_init(struct ipu_device *isp)
+{
+	struct ipu_buttress *b = &isp->buttress;
+	u32 val;
+	int rval, ipc_reset_retry = BUTTRESS_CSE_IPC_RESET_RETRY;
+
+	mutex_init(&b->power_mutex);
+	mutex_init(&b->auth_mutex);
+	mutex_init(&b->cons_mutex);
+	mutex_init(&b->ipc_mutex);
+	init_completion(&b->ish.send_complete);
+	init_completion(&b->cse.send_complete);
+	init_completion(&b->ish.recv_complete);
+	init_completion(&b->cse.recv_complete);
+
+	b->cse.nack = BUTTRESS_CSE2IUDATA0_IPC_NACK;
+	b->cse.nack_mask = BUTTRESS_CSE2IUDATA0_IPC_NACK_MASK;
+	b->cse.csr_in = BUTTRESS_REG_CSE2IUCSR;
+	b->cse.csr_out = BUTTRESS_REG_IU2CSECSR;
+	b->cse.db0_in = BUTTRESS_REG_CSE2IUDB0;
+	b->cse.db0_out = BUTTRESS_REG_IU2CSEDB0;
+	b->cse.data0_in = BUTTRESS_REG_CSE2IUDATA0;
+	b->cse.data0_out = BUTTRESS_REG_IU2CSEDATA0;
+
+	/* no ISH on IPU6 */
+	memset(&b->ish, 0, sizeof(b->ish));
+	INIT_LIST_HEAD(&b->constraints);
+
+	ipu_buttress_set_secure_mode(isp);
+	isp->secure_mode = ipu_buttress_get_secure_mode(isp);
+	if (isp->secure_mode != secure_mode_enable)
+		dev_warn(&isp->pdev->dev, "Unable to set secure mode\n");
+
+	dev_info(&isp->pdev->dev, "IPU in %s mode\n",
+		 isp->secure_mode ? "secure" : "non-secure");
+
+	dev_info(&isp->pdev->dev, "IPU secure touch = 0x%x\n",
+		 readl(isp->base + BUTTRESS_REG_SECURITY_TOUCH));
+
+	dev_info(&isp->pdev->dev, "IPU camera mask = 0x%x\n",
+		 readl(isp->base + BUTTRESS_REG_CAMERA_MASK));
+
+	b->wdt_cached_value = readl(isp->base + BUTTRESS_REG_WDT);
+	writel(BUTTRESS_IRQS, isp->base + BUTTRESS_REG_ISR_CLEAR);
+	writel(BUTTRESS_IRQS, isp->base + BUTTRESS_REG_ISR_ENABLE);
+
+	/* get ref_clk frequency by reading the indication in btrs control */
+	val = readl(isp->base + BUTTRESS_REG_BTRS_CTRL);
+	val &= BUTTRESS_REG_BTRS_CTRL_REF_CLK_IND;
+	val >>= 8;
+
+	switch (val) {
+	case 0x0:
+		b->ref_clk = 240;
+		break;
+	case 0x1:
+		b->ref_clk = 192;
+		break;
+	case 0x2:
+		b->ref_clk = 384;
+		break;
+	default:
+		dev_warn(&isp->pdev->dev,
+			 "Unsupported ref clock, use 19.2Mhz by default.\n");
+		b->ref_clk = 192;
+		break;
+	}
+
+	rval = device_create_file(&isp->pdev->dev,
+				  &dev_attr_psys_fused_min_freq);
+	if (rval) {
+		dev_err(&isp->pdev->dev, "Create min freq file failed\n");
+		goto err_mutex_destroy;
+	}
+
+	rval = device_create_file(&isp->pdev->dev,
+				  &dev_attr_psys_fused_max_freq);
+	if (rval) {
+		dev_err(&isp->pdev->dev, "Create max freq file failed\n");
+		goto err_remove_min_freq_file;
+	}
+
+	rval = device_create_file(&isp->pdev->dev,
+				  &dev_attr_psys_fused_efficient_freq);
+	if (rval) {
+		dev_err(&isp->pdev->dev, "Create efficient freq file failed\n");
+		goto err_remove_max_freq_file;
+	}
+
+	/*
+	 * We want to retry couple of time in case CSE initialization
+	 * is delayed for reason or another.
+	 */
+	do {
+		rval = ipu_buttress_ipc_reset(isp, &b->cse);
+		if (rval) {
+			dev_warn(&isp->pdev->dev,
+				 "IPC reset protocol failed, retrying\n");
+		} else {
+			dev_info(&isp->pdev->dev, "IPC reset done\n");
+			return 0;
+		}
+	} while (ipc_reset_retry--);
+
+	dev_err(&isp->pdev->dev, "IPC reset protocol failed\n");
+
+err_remove_max_freq_file:
+	device_remove_file(&isp->pdev->dev, &dev_attr_psys_fused_max_freq);
+err_remove_min_freq_file:
+	device_remove_file(&isp->pdev->dev, &dev_attr_psys_fused_min_freq);
+err_mutex_destroy:
+	mutex_destroy(&b->power_mutex);
+	mutex_destroy(&b->auth_mutex);
+	mutex_destroy(&b->cons_mutex);
+	mutex_destroy(&b->ipc_mutex);
+
+	return rval;
+}
+
+void ipu_buttress_exit(struct ipu_device *isp)
+{
+	struct ipu_buttress *b = &isp->buttress;
+
+	writel(0, isp->base + BUTTRESS_REG_ISR_ENABLE);
+
+	device_remove_file(&isp->pdev->dev,
+			   &dev_attr_psys_fused_efficient_freq);
+	device_remove_file(&isp->pdev->dev, &dev_attr_psys_fused_max_freq);
+	device_remove_file(&isp->pdev->dev, &dev_attr_psys_fused_min_freq);
+
+	mutex_destroy(&b->power_mutex);
+	mutex_destroy(&b->auth_mutex);
+	mutex_destroy(&b->cons_mutex);
+	mutex_destroy(&b->ipc_mutex);
+}
Index: b/drivers/media/pci/intel/ipu-buttress.h
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu-buttress.h
@@ -0,0 +1,131 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2013 - 2022 Intel Corporation */
+
+#ifndef IPU_BUTTRESS_H
+#define IPU_BUTTRESS_H
+
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include "ipu.h"
+
+#define IPU_BUTTRESS_NUM_OF_SENS_CKS	3
+#define IPU_BUTTRESS_NUM_OF_PLL_CKS	3
+#define IPU_BUTTRESS_TSC_CLK		19200000
+
+#define BUTTRESS_POWER_TIMEOUT			200000
+
+#define BUTTRESS_PS_FREQ_STEP		25U
+#define BUTTRESS_MIN_FORCE_PS_FREQ	(BUTTRESS_PS_FREQ_STEP * 8)
+#define BUTTRESS_MAX_FORCE_PS_FREQ	(BUTTRESS_PS_FREQ_STEP * 32)
+
+#define BUTTRESS_IS_FREQ_STEP		25U
+#define BUTTRESS_MIN_FORCE_IS_FREQ	(BUTTRESS_IS_FREQ_STEP * 8)
+#define BUTTRESS_MAX_FORCE_IS_FREQ	(BUTTRESS_IS_FREQ_STEP * 16)
+
+struct ipu_buttress_ctrl {
+	u32 freq_ctl, pwr_sts_shift, pwr_sts_mask, pwr_sts_on, pwr_sts_off;
+	union {
+		unsigned int divisor;
+		unsigned int ratio;
+	};
+	union {
+		unsigned int divisor_shift;
+		unsigned int ratio_shift;
+	};
+	unsigned int qos_floor;
+	bool started;
+};
+
+struct ipu_buttress_fused_freqs {
+	unsigned int min_freq;
+	unsigned int max_freq;
+	unsigned int efficient_freq;
+};
+
+struct ipu_buttress_ipc {
+	struct completion send_complete;
+	struct completion recv_complete;
+	u32 nack;
+	u32 nack_mask;
+	u32 recv_data;
+	u32 csr_out;
+	u32 csr_in;
+	u32 db0_in;
+	u32 db0_out;
+	u32 data0_out;
+	u32 data0_in;
+};
+
+struct ipu_buttress {
+	struct mutex power_mutex, auth_mutex, cons_mutex, ipc_mutex;
+	struct ipu_buttress_ipc cse;
+	struct ipu_buttress_ipc ish;
+	struct list_head constraints;
+	struct ipu_buttress_fused_freqs psys_fused_freqs;
+	unsigned int psys_min_freq;
+	u32 wdt_cached_value;
+	u8 psys_force_ratio;
+	bool force_suspend;
+	u32 ref_clk;
+};
+
+struct ipu_buttress_sensor_clk_freq {
+	unsigned int rate;
+	unsigned int val;
+};
+
+struct firmware;
+
+enum ipu_buttress_ipc_domain {
+	IPU_BUTTRESS_IPC_CSE,
+	IPU_BUTTRESS_IPC_ISH,
+};
+
+struct ipu_buttress_constraint {
+	struct list_head list;
+	unsigned int min_freq;
+};
+
+struct ipu_ipc_buttress_bulk_msg {
+	u32 cmd;
+	u32 expected_resp;
+	bool require_resp;
+	u8 cmd_size;
+};
+
+int ipu_buttress_ipc_reset(struct ipu_device *isp,
+			   struct ipu_buttress_ipc *ipc);
+int ipu_buttress_map_fw_image(struct ipu_bus_device *sys,
+			      const struct firmware *fw, struct sg_table *sgt);
+int ipu_buttress_unmap_fw_image(struct ipu_bus_device *sys,
+				struct sg_table *sgt);
+int ipu_buttress_power(struct device *dev,
+		       struct ipu_buttress_ctrl *ctrl, bool on);
+void
+ipu_buttress_add_psys_constraint(struct ipu_device *isp,
+				 struct ipu_buttress_constraint *constraint);
+void
+ipu_buttress_remove_psys_constraint(struct ipu_device *isp,
+				    struct ipu_buttress_constraint *constraint);
+void ipu_buttress_set_secure_mode(struct ipu_device *isp);
+bool ipu_buttress_get_secure_mode(struct ipu_device *isp);
+int ipu_buttress_authenticate(struct ipu_device *isp);
+int ipu_buttress_reset_authentication(struct ipu_device *isp);
+bool ipu_buttress_auth_done(struct ipu_device *isp);
+int ipu_buttress_start_tsc_sync(struct ipu_device *isp);
+int ipu_buttress_tsc_read(struct ipu_device *isp, u64 *val);
+u64 ipu_buttress_tsc_ticks_to_ns(u64 ticks, const struct ipu_device *isp);
+
+irqreturn_t ipu_buttress_isr(int irq, void *isp_ptr);
+irqreturn_t ipu_buttress_isr_threaded(int irq, void *isp_ptr);
+int ipu_buttress_debugfs_init(struct ipu_device *isp);
+int ipu_buttress_init(struct ipu_device *isp);
+void ipu_buttress_exit(struct ipu_device *isp);
+void ipu_buttress_csi_port_config(struct ipu_device *isp,
+				  u32 legacy, u32 combo);
+int ipu_buttress_restore(struct ipu_device *isp);
+
+int ipu_buttress_isys_freq_set(void *data, u64 val);
+int ipu_buttress_psys_freq_get(void *data, u64 *val);
+int ipu_get_i2c_bus_id(int adapter_id, char *adapter_bdf, int bdf_len);
+#endif /* IPU_BUTTRESS_H */
Index: b/drivers/media/pci/intel/ipu-cpd.c
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu-cpd.c
@@ -0,0 +1,468 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) 2015 - 2020 Intel Corporation
+
+#include <linux/dma-mapping.h>
+#include <linux/module.h>
+
+#include "ipu.h"
+#include "ipu-cpd.h"
+
+/* 15 entries + header*/
+#define MAX_PKG_DIR_ENT_CNT		16
+/* 2 qword per entry/header */
+#define PKG_DIR_ENT_LEN			2
+/* PKG_DIR size in bytes */
+#define PKG_DIR_SIZE			((MAX_PKG_DIR_ENT_CNT) *	\
+					 (PKG_DIR_ENT_LEN) * sizeof(u64))
+#define PKG_DIR_ID_SHIFT		48
+#define PKG_DIR_ID_MASK			0x7f
+#define PKG_DIR_VERSION_SHIFT		32
+#define PKG_DIR_SIZE_MASK		0xfffff
+/* _IUPKDR_ */
+#define PKG_DIR_HDR_MARK		0x5f4955504b44525f
+
+/* $CPD */
+#define CPD_HDR_MARK			0x44504324
+
+/* Maximum size is 2K DWORDs */
+#define MAX_MANIFEST_SIZE		(2 * 1024 * sizeof(u32))
+
+/* Maximum size is 64k */
+#define MAX_METADATA_SIZE		(64 * 1024)
+
+#define MAX_COMPONENT_ID		127
+#define MAX_COMPONENT_VERSION		0xffff
+
+#define CPD_MANIFEST_IDX	0
+#define CPD_METADATA_IDX	1
+#define CPD_MODULEDATA_IDX	2
+
+static inline struct ipu_cpd_ent *ipu_cpd_get_entries(const void *cpd)
+{
+	const struct ipu_cpd_hdr *cpd_hdr = cpd;
+
+	return (struct ipu_cpd_ent *)((u8 *)cpd + cpd_hdr->hdr_len);
+}
+
+#define ipu_cpd_get_entry(cpd, idx) (&ipu_cpd_get_entries(cpd)[idx])
+#define ipu_cpd_get_manifest(cpd) ipu_cpd_get_entry(cpd, CPD_MANIFEST_IDX)
+#define ipu_cpd_get_metadata(cpd) ipu_cpd_get_entry(cpd, CPD_METADATA_IDX)
+#define ipu_cpd_get_moduledata(cpd) ipu_cpd_get_entry(cpd, CPD_MODULEDATA_IDX)
+
+static const struct ipu_cpd_metadata_cmpnt *
+ipu_cpd_metadata_get_cmpnt(struct ipu_device *isp,
+			   const void *metadata,
+			   unsigned int metadata_size,
+			   u8 idx)
+{
+	const struct ipu_cpd_metadata_extn *extn;
+	const struct ipu_cpd_metadata_cmpnt *cmpnts;
+	int cmpnt_count;
+
+	extn = metadata;
+	cmpnts = metadata + sizeof(*extn);
+	cmpnt_count = (metadata_size - sizeof(*extn)) / sizeof(*cmpnts);
+
+	if (idx > MAX_COMPONENT_ID || idx >= cmpnt_count) {
+		dev_err(&isp->pdev->dev, "Component index out of range (%d)\n",
+			idx);
+		return ERR_PTR(-EINVAL);
+	}
+
+	return &cmpnts[idx];
+}
+
+static u32 ipu_cpd_metadata_cmpnt_version(struct ipu_device *isp,
+					  const void *metadata,
+					  unsigned int metadata_size, u8 idx)
+{
+	const struct ipu_cpd_metadata_cmpnt *cmpnt =
+	    ipu_cpd_metadata_get_cmpnt(isp, metadata,
+				       metadata_size, idx);
+
+	if (IS_ERR(cmpnt))
+		return PTR_ERR(cmpnt);
+
+	return cmpnt->ver;
+}
+
+static int ipu_cpd_metadata_get_cmpnt_id(struct ipu_device *isp,
+					 const void *metadata,
+					 unsigned int metadata_size, u8 idx)
+{
+	const struct ipu_cpd_metadata_cmpnt *cmpnt =
+	    ipu_cpd_metadata_get_cmpnt(isp, metadata,
+				       metadata_size, idx);
+
+	if (IS_ERR(cmpnt))
+		return PTR_ERR(cmpnt);
+
+	return cmpnt->id;
+}
+
+static const struct ipu6_cpd_metadata_cmpnt *
+ipu6_cpd_metadata_get_cmpnt(struct ipu_device *isp,
+			    const void *metadata,
+			    unsigned int metadata_size,
+			    u8 idx)
+{
+	const struct ipu_cpd_metadata_extn *extn = metadata;
+	const struct ipu6_cpd_metadata_cmpnt *cmpnts = metadata + sizeof(*extn);
+	int cmpnt_count;
+
+	cmpnt_count = (metadata_size - sizeof(*extn)) / sizeof(*cmpnts);
+	if (idx > MAX_COMPONENT_ID || idx >= cmpnt_count) {
+		dev_err(&isp->pdev->dev, "Component index out of range (%d)\n",
+			idx);
+		return ERR_PTR(-EINVAL);
+	}
+
+	return &cmpnts[idx];
+}
+
+static u32 ipu6_cpd_metadata_cmpnt_version(struct ipu_device *isp,
+					   const void *metadata,
+					   unsigned int metadata_size, u8 idx)
+{
+	const struct ipu6_cpd_metadata_cmpnt *cmpnt =
+	    ipu6_cpd_metadata_get_cmpnt(isp, metadata,
+					metadata_size, idx);
+
+	if (IS_ERR(cmpnt))
+		return PTR_ERR(cmpnt);
+
+	return cmpnt->ver;
+}
+
+static int ipu6_cpd_metadata_get_cmpnt_id(struct ipu_device *isp,
+					  const void *metadata,
+					  unsigned int metadata_size, u8 idx)
+{
+	const struct ipu6_cpd_metadata_cmpnt *cmpnt =
+	    ipu6_cpd_metadata_get_cmpnt(isp, metadata,
+					metadata_size, idx);
+
+	if (IS_ERR(cmpnt))
+		return PTR_ERR(cmpnt);
+
+	return cmpnt->id;
+}
+
+static int ipu_cpd_parse_module_data(struct ipu_device *isp,
+				     const void *module_data,
+				     unsigned int module_data_size,
+				     dma_addr_t dma_addr_module_data,
+				     u64 *pkg_dir,
+				     const void *metadata,
+				     unsigned int metadata_size)
+{
+	const struct ipu_cpd_module_data_hdr *module_data_hdr;
+	const struct ipu_cpd_hdr *dir_hdr;
+	const struct ipu_cpd_ent *dir_ent;
+	int i;
+	u8 len;
+
+	if (!module_data)
+		return -EINVAL;
+
+	module_data_hdr = module_data;
+	dir_hdr = module_data + module_data_hdr->hdr_len;
+	len = dir_hdr->hdr_len;
+	dir_ent = (struct ipu_cpd_ent *)(((u8 *)dir_hdr) + len);
+
+	pkg_dir[0] = PKG_DIR_HDR_MARK;
+	/* pkg_dir entry count = component count + pkg_dir header */
+	pkg_dir[1] = dir_hdr->ent_cnt + 1;
+
+	for (i = 0; i < dir_hdr->ent_cnt; i++, dir_ent++) {
+		u64 *p = &pkg_dir[PKG_DIR_ENT_LEN + i * PKG_DIR_ENT_LEN];
+		int ver, id;
+
+		*p++ = dma_addr_module_data + dir_ent->offset;
+
+		if (ipu_ver == IPU_VER_6 || ipu_ver == IPU_VER_6EP ||
+		    ipu_ver == IPU_VER_6EP_MTL)
+			id = ipu6_cpd_metadata_get_cmpnt_id(isp, metadata,
+							    metadata_size, i);
+		else
+			id = ipu_cpd_metadata_get_cmpnt_id(isp, metadata,
+							   metadata_size, i);
+
+		if (id < 0 || id > MAX_COMPONENT_ID) {
+			dev_err(&isp->pdev->dev,
+				"Failed to parse component id\n");
+			return -EINVAL;
+		}
+
+		if (ipu_ver == IPU_VER_6 || ipu_ver == IPU_VER_6EP ||
+		    ipu_ver == IPU_VER_6EP_MTL)
+			ver = ipu6_cpd_metadata_cmpnt_version(isp, metadata,
+							      metadata_size, i);
+		else
+			ver = ipu_cpd_metadata_cmpnt_version(isp, metadata,
+							     metadata_size, i);
+
+		if (ver < 0 || ver > MAX_COMPONENT_VERSION) {
+			dev_err(&isp->pdev->dev,
+				"Failed to parse component version\n");
+			return -EINVAL;
+		}
+
+		/*
+		 * PKG_DIR Entry (type == id)
+		 * 63:56        55      54:48   47:32   31:24   23:0
+		 * Rsvd         Rsvd    Type    Version Rsvd    Size
+		 */
+		*p = dir_ent->len | (u64)id << PKG_DIR_ID_SHIFT |
+		    (u64)ver << PKG_DIR_VERSION_SHIFT;
+	}
+
+	return 0;
+}
+
+void *ipu_cpd_create_pkg_dir(struct ipu_bus_device *adev,
+			     const void *src,
+			     dma_addr_t dma_addr_src,
+			     dma_addr_t *dma_addr, unsigned int *pkg_dir_size)
+{
+	struct ipu_device *isp = adev->isp;
+	const struct ipu_cpd_ent *ent, *man_ent, *met_ent;
+	u64 *pkg_dir;
+	unsigned int man_sz, met_sz;
+	void *pkg_dir_pos;
+	int ret;
+
+	man_ent = ipu_cpd_get_manifest(src);
+	man_sz = man_ent->len;
+
+	met_ent = ipu_cpd_get_metadata(src);
+	met_sz = met_ent->len;
+
+	*pkg_dir_size = PKG_DIR_SIZE + man_sz + met_sz;
+	pkg_dir = dma_alloc_attrs(&adev->dev, *pkg_dir_size, dma_addr,
+				  GFP_KERNEL,
+				  0);
+	if (!pkg_dir)
+		return pkg_dir;
+
+	/*
+	 * pkg_dir entry/header:
+	 * qword | 63:56 | 55   | 54:48 | 47:32 | 31:24 | 23:0
+	 * N         Address/Offset/"_IUPKDR_"
+	 * N + 1 | rsvd  | rsvd | type  | ver   | rsvd  | size
+	 *
+	 * We can ignore other fields that size in N + 1 qword as they
+	 * are 0 anyway. Just setting size for now.
+	 */
+
+	ent = ipu_cpd_get_moduledata(src);
+
+	ret = ipu_cpd_parse_module_data(isp, src + ent->offset,
+					ent->len,
+					dma_addr_src + ent->offset,
+					pkg_dir,
+					src + met_ent->offset, met_ent->len);
+	if (ret) {
+		dev_err(&isp->pdev->dev,
+			"Unable to parse module data section!\n");
+		dma_free_attrs(&isp->psys->dev, *pkg_dir_size, pkg_dir,
+			       *dma_addr,
+			       0);
+		return NULL;
+	}
+
+	/* Copy manifest after pkg_dir */
+	pkg_dir_pos = pkg_dir + PKG_DIR_ENT_LEN * MAX_PKG_DIR_ENT_CNT;
+	memcpy(pkg_dir_pos, src + man_ent->offset, man_sz);
+
+	/* Copy metadata after manifest */
+	pkg_dir_pos += man_sz;
+	memcpy(pkg_dir_pos, src + met_ent->offset, met_sz);
+
+	dma_sync_single_range_for_device(&adev->dev, *dma_addr,
+					 0, *pkg_dir_size, DMA_TO_DEVICE);
+
+	return pkg_dir;
+}
+EXPORT_SYMBOL_GPL(ipu_cpd_create_pkg_dir);
+
+void ipu_cpd_free_pkg_dir(struct ipu_bus_device *adev,
+			  u64 *pkg_dir,
+			  dma_addr_t dma_addr, unsigned int pkg_dir_size)
+{
+	dma_free_attrs(&adev->dev, pkg_dir_size, pkg_dir, dma_addr, 0);
+}
+EXPORT_SYMBOL_GPL(ipu_cpd_free_pkg_dir);
+
+static int ipu_cpd_validate_cpd(struct ipu_device *isp,
+				const void *cpd,
+				unsigned long cpd_size, unsigned long data_size)
+{
+	const struct ipu_cpd_hdr *cpd_hdr = cpd;
+	struct ipu_cpd_ent *ent;
+	unsigned int i;
+	u8 len;
+
+	len = cpd_hdr->hdr_len;
+
+	/* Ensure cpd hdr is within moduledata */
+	if (cpd_size < len) {
+		dev_err(&isp->pdev->dev, "Invalid CPD moduledata size\n");
+		return -EINVAL;
+	}
+
+	/* Sanity check for CPD header */
+	if ((cpd_size - len) / sizeof(*ent) < cpd_hdr->ent_cnt) {
+		dev_err(&isp->pdev->dev, "Invalid CPD header\n");
+		return -EINVAL;
+	}
+
+	/* Ensure that all entries are within moduledata */
+	ent = (struct ipu_cpd_ent *)(((u8 *)cpd_hdr) + len);
+	for (i = 0; i < cpd_hdr->ent_cnt; i++, ent++) {
+		if (data_size < ent->offset ||
+		    data_size - ent->offset < ent->len) {
+			dev_err(&isp->pdev->dev, "Invalid CPD entry (%d)\n", i);
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
+static int ipu_cpd_validate_moduledata(struct ipu_device *isp,
+				       const void *moduledata,
+				       u32 moduledata_size)
+{
+	const struct ipu_cpd_module_data_hdr *mod_hdr = moduledata;
+	int rval;
+
+	/* Ensure moduledata hdr is within moduledata */
+	if (moduledata_size < sizeof(*mod_hdr) ||
+	    moduledata_size < mod_hdr->hdr_len) {
+		dev_err(&isp->pdev->dev, "Invalid moduledata size\n");
+		return -EINVAL;
+	}
+
+	dev_info(&isp->pdev->dev, "FW version: %x\n", mod_hdr->fw_pkg_date);
+	rval = ipu_cpd_validate_cpd(isp, moduledata +
+				    mod_hdr->hdr_len,
+				    moduledata_size -
+				    mod_hdr->hdr_len, moduledata_size);
+	if (rval) {
+		dev_err(&isp->pdev->dev, "Invalid CPD in moduledata\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int ipu_cpd_validate_metadata(struct ipu_device *isp,
+				     const void *metadata, u32 meta_size)
+{
+	const struct ipu_cpd_metadata_extn *extn = metadata;
+	unsigned int size;
+
+	/* Sanity check for metadata size */
+	if (meta_size < sizeof(*extn) || meta_size > MAX_METADATA_SIZE) {
+		dev_err(&isp->pdev->dev, "%s: Invalid metadata\n", __func__);
+		return -EINVAL;
+	}
+
+	/* Validate extension and image types */
+	if (extn->extn_type != IPU_CPD_METADATA_EXTN_TYPE_IUNIT ||
+	    extn->img_type != IPU_CPD_METADATA_IMAGE_TYPE_MAIN_FIRMWARE) {
+		dev_err(&isp->pdev->dev,
+			"Invalid metadata descriptor img_type (%d)\n",
+			extn->img_type);
+		return -EINVAL;
+	}
+
+	/* Validate metadata size multiple of metadata components */
+	if (ipu_ver == IPU_VER_6 || ipu_ver == IPU_VER_6EP ||
+	    ipu_ver == IPU_VER_6EP_MTL)
+		size = sizeof(struct ipu6_cpd_metadata_cmpnt);
+	else
+		size = sizeof(struct ipu_cpd_metadata_cmpnt);
+
+	if ((meta_size - sizeof(*extn)) % size) {
+		dev_err(&isp->pdev->dev, "%s: Invalid metadata size\n",
+			__func__);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+int ipu_cpd_validate_cpd_file(struct ipu_device *isp,
+			      const void *cpd_file, unsigned long cpd_file_size)
+{
+	const struct ipu_cpd_hdr *hdr = cpd_file;
+	struct ipu_cpd_ent *ent;
+	int rval;
+
+	rval = ipu_cpd_validate_cpd(isp, cpd_file,
+				    cpd_file_size, cpd_file_size);
+	if (rval) {
+		dev_err(&isp->pdev->dev, "Invalid CPD in file\n");
+		return -EINVAL;
+	}
+
+	/* Check for CPD file marker */
+	if (hdr->hdr_mark != CPD_HDR_MARK) {
+		dev_err(&isp->pdev->dev, "Invalid CPD header\n");
+		return -EINVAL;
+	}
+
+	/* Sanity check for manifest size */
+	ent = ipu_cpd_get_manifest(cpd_file);
+	if (ent->len > MAX_MANIFEST_SIZE) {
+		dev_err(&isp->pdev->dev, "Invalid manifest size\n");
+		return -EINVAL;
+	}
+
+	/* Validate metadata */
+	ent = ipu_cpd_get_metadata(cpd_file);
+	rval = ipu_cpd_validate_metadata(isp, cpd_file + ent->offset, ent->len);
+	if (rval) {
+		dev_err(&isp->pdev->dev, "Invalid metadata\n");
+		return rval;
+	}
+
+	/* Validate moduledata */
+	ent = ipu_cpd_get_moduledata(cpd_file);
+	rval = ipu_cpd_validate_moduledata(isp, cpd_file + ent->offset,
+					   ent->len);
+	if (rval) {
+		dev_err(&isp->pdev->dev, "Invalid moduledata\n");
+		return rval;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ipu_cpd_validate_cpd_file);
+
+unsigned int ipu_cpd_pkg_dir_get_address(const u64 *pkg_dir, int pkg_dir_idx)
+{
+	return pkg_dir[++pkg_dir_idx * PKG_DIR_ENT_LEN];
+}
+EXPORT_SYMBOL_GPL(ipu_cpd_pkg_dir_get_address);
+
+unsigned int ipu_cpd_pkg_dir_get_num_entries(const u64 *pkg_dir)
+{
+	return pkg_dir[1];
+}
+EXPORT_SYMBOL_GPL(ipu_cpd_pkg_dir_get_num_entries);
+
+unsigned int ipu_cpd_pkg_dir_get_size(const u64 *pkg_dir, int pkg_dir_idx)
+{
+	return pkg_dir[++pkg_dir_idx * PKG_DIR_ENT_LEN + 1] & PKG_DIR_SIZE_MASK;
+}
+EXPORT_SYMBOL_GPL(ipu_cpd_pkg_dir_get_size);
+
+unsigned int ipu_cpd_pkg_dir_get_type(const u64 *pkg_dir, int pkg_dir_idx)
+{
+	return pkg_dir[++pkg_dir_idx * PKG_DIR_ENT_LEN + 1] >>
+	    PKG_DIR_ID_SHIFT & PKG_DIR_ID_MASK;
+}
+EXPORT_SYMBOL_GPL(ipu_cpd_pkg_dir_get_type);
Index: b/drivers/media/pci/intel/ipu-cpd.h
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu-cpd.h
@@ -0,0 +1,110 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2015 - 2020 Intel Corporation */
+
+#ifndef IPU_CPD_H
+#define IPU_CPD_H
+
+#define IPU_CPD_SIZE_OF_FW_ARCH_VERSION		7
+#define IPU_CPD_SIZE_OF_SYSTEM_VERSION		11
+#define IPU_CPD_SIZE_OF_COMPONENT_NAME		12
+
+#define IPU_CPD_METADATA_EXTN_TYPE_IUNIT	0x10
+
+#define IPU_CPD_METADATA_IMAGE_TYPE_RESERVED		0
+#define IPU_CPD_METADATA_IMAGE_TYPE_BOOTLOADER		1
+#define IPU_CPD_METADATA_IMAGE_TYPE_MAIN_FIRMWARE	2
+
+#define IPU_CPD_PKG_DIR_PSYS_SERVER_IDX	0
+#define IPU_CPD_PKG_DIR_ISYS_SERVER_IDX	1
+
+#define IPU_CPD_PKG_DIR_CLIENT_PG_TYPE	3
+
+#define IPU6_CPD_METADATA_HASH_KEY_SIZE          48
+#define IPU_CPD_METADATA_HASH_KEY_SIZE           32
+
+struct __packed ipu_cpd_module_data_hdr {
+	u32 hdr_len;
+	u32 endian;
+	u32 fw_pkg_date;
+	u32 hive_sdk_date;
+	u32 compiler_date;
+	u32 target_platform_type;
+	u8 sys_ver[IPU_CPD_SIZE_OF_SYSTEM_VERSION];
+	u8 fw_arch_ver[IPU_CPD_SIZE_OF_FW_ARCH_VERSION];
+	u8 rsvd[2];
+};
+
+/* ipu_cpd_hdr structure updated as the chksum and
+ * sub_partition_name is unused on host side
+ * CSE layout version 1.6 for ipu6se (hdr_len = 0x10)
+ * CSE layout version 1.7 for ipu6 (hdr_len = 0x14)
+ */
+struct __packed ipu_cpd_hdr {
+	u32 hdr_mark;
+	u32 ent_cnt;
+	u8 hdr_ver;
+	u8 ent_ver;
+	u8 hdr_len;
+};
+
+struct __packed ipu_cpd_ent {
+	u8 name[IPU_CPD_SIZE_OF_COMPONENT_NAME];
+	u32 offset;
+	u32 len;
+	u8 rsvd[4];
+};
+
+struct __packed ipu_cpd_metadata_cmpnt {
+	u32 id;
+	u32 size;
+	u32 ver;
+	u8 sha2_hash[IPU_CPD_METADATA_HASH_KEY_SIZE];
+	u32 entry_point;
+	u32 icache_base_offs;
+	u8 attrs[16];
+};
+
+struct __packed ipu6_cpd_metadata_cmpnt {
+	u32 id;
+	u32 size;
+	u32 ver;
+	u8 sha2_hash[IPU6_CPD_METADATA_HASH_KEY_SIZE];
+	u32 entry_point;
+	u32 icache_base_offs;
+	u8 attrs[16];
+};
+
+struct __packed ipu_cpd_metadata_extn {
+	u32 extn_type;
+	u32 len;
+	u32 img_type;
+	u8 rsvd[16];
+};
+
+struct __packed ipu_cpd_client_pkg_hdr {
+	u32 prog_list_offs;
+	u32 prog_list_size;
+	u32 prog_desc_offs;
+	u32 prog_desc_size;
+	u32 pg_manifest_offs;
+	u32 pg_manifest_size;
+	u32 prog_bin_offs;
+	u32 prog_bin_size;
+};
+
+void *ipu_cpd_create_pkg_dir(struct ipu_bus_device *adev,
+			     const void *src,
+			     dma_addr_t dma_addr_src,
+			     dma_addr_t *dma_addr, unsigned int *pkg_dir_size);
+void ipu_cpd_free_pkg_dir(struct ipu_bus_device *adev,
+			  u64 *pkg_dir,
+			  dma_addr_t dma_addr, unsigned int pkg_dir_size);
+int ipu_cpd_validate_cpd_file(struct ipu_device *isp,
+			      const void *cpd_file,
+			      unsigned long cpd_file_size);
+unsigned int ipu_cpd_pkg_dir_get_address(const u64 *pkg_dir, int pkg_dir_idx);
+unsigned int ipu_cpd_pkg_dir_get_num_entries(const u64 *pkg_dir);
+unsigned int ipu_cpd_pkg_dir_get_size(const u64 *pkg_dir, int pkg_dir_idx);
+unsigned int ipu_cpd_pkg_dir_get_type(const u64 *pkg_dir, int pkg_dir_idx);
+
+#endif /* IPU_CPD_H */
Index: b/drivers/media/pci/intel/ipu-dma.c
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu-dma.c
@@ -0,0 +1,500 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) 2013 - 2021 Intel Corporation
+
+#include <asm/cacheflush.h>
+
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+#include <linux/gfp.h>
+#include <linux/highmem.h>
+#include <linux/iova.h>
+#include <linux/module.h>
+#include <linux/scatterlist.h>
+#include <linux/version.h>
+#include <linux/vmalloc.h>
+#include <linux/dma-map-ops.h>
+
+#include "ipu-dma.h"
+#include "ipu-bus.h"
+#include "ipu-mmu.h"
+
+struct vm_info {
+	struct list_head list;
+	struct page **pages;
+	dma_addr_t ipu_iova;
+	void *vaddr;
+	unsigned long size;
+};
+
+static struct vm_info *get_vm_info(struct ipu_mmu *mmu, dma_addr_t iova)
+{
+	struct vm_info *info, *save;
+
+	list_for_each_entry_safe(info, save, &mmu->vma_list, list) {
+		if (iova >= info->ipu_iova &&
+		    iova < (info->ipu_iova + info->size))
+			return info;
+	}
+
+	return NULL;
+}
+
+/* Begin of things adapted from arch/arm/mm/dma-mapping.c */
+static void __dma_clear_buffer(struct page *page, size_t size,
+			       unsigned long attrs)
+{
+	/*
+	 * Ensure that the allocated pages are zeroed, and that any data
+	 * lurking in the kernel direct-mapped region is invalidated.
+	 */
+	void *ptr = page_address(page);
+
+	memset(ptr, 0, size);
+	if ((attrs & DMA_ATTR_SKIP_CPU_SYNC) == 0)
+		clflush_cache_range(ptr, size);
+}
+
+static struct page **__dma_alloc_buffer(struct device *dev, size_t size,
+					gfp_t gfp,
+					unsigned long attrs)
+{
+	struct page **pages;
+	int count = size >> PAGE_SHIFT;
+	int array_size = count * sizeof(struct page *);
+	int i = 0;
+
+	pages = kvzalloc(array_size, GFP_KERNEL);
+	if (!pages)
+		return NULL;
+
+	gfp |= __GFP_NOWARN;
+
+	while (count) {
+		int j, order = __fls(count);
+
+		pages[i] = alloc_pages(gfp, order);
+		while (!pages[i] && order)
+			pages[i] = alloc_pages(gfp, --order);
+		if (!pages[i])
+			goto error;
+
+		if (order) {
+			split_page(pages[i], order);
+			j = 1 << order;
+			while (--j)
+				pages[i + j] = pages[i] + j;
+		}
+
+		__dma_clear_buffer(pages[i], PAGE_SIZE << order, attrs);
+		i += 1 << order;
+		count -= 1 << order;
+	}
+
+	return pages;
+error:
+	while (i--)
+		if (pages[i])
+			__free_pages(pages[i], 0);
+	kvfree(pages);
+	return NULL;
+}
+
+static int __dma_free_buffer(struct device *dev, struct page **pages,
+			     size_t size,
+			     unsigned long attrs)
+{
+	int count = size >> PAGE_SHIFT;
+	int i;
+
+	for (i = 0; i < count; i++) {
+		if (pages[i]) {
+			__free_pages(pages[i], 0);
+		}
+	}
+
+	kvfree(pages);
+	return 0;
+}
+
+/* End of things adapted from arch/arm/mm/dma-mapping.c */
+
+static void ipu_dma_sync_single_for_cpu(struct device *dev,
+					dma_addr_t dma_handle,
+					size_t size,
+					enum dma_data_direction dir)
+{
+	void *vaddr;
+	u32 offset;
+	struct vm_info *info;
+	struct ipu_mmu *mmu = to_ipu_bus_device(dev)->mmu;
+
+	info = get_vm_info(mmu, dma_handle);
+	if (WARN_ON(!info))
+		return;
+
+	offset = dma_handle - info->ipu_iova;
+	if (WARN_ON(size > (info->size - offset)))
+		return;
+
+	vaddr = info->vaddr + offset;
+	clflush_cache_range(vaddr, size);
+}
+
+static void ipu_dma_sync_sg_for_cpu(struct device *dev,
+				    struct scatterlist *sglist,
+				    int nents, enum dma_data_direction dir)
+{
+	struct scatterlist *sg;
+	int i;
+
+	for_each_sg(sglist, sg, nents, i)
+		clflush_cache_range(page_to_virt(sg_page(sg)), sg->length);
+}
+
+static void *ipu_dma_alloc(struct device *dev, size_t size,
+			   dma_addr_t *dma_handle, gfp_t gfp,
+			   unsigned long attrs)
+{
+	struct ipu_mmu *mmu = to_ipu_bus_device(dev)->mmu;
+	struct pci_dev *pdev = to_ipu_bus_device(dev)->isp->pdev;
+	struct page **pages;
+	struct iova *iova;
+	struct vm_info *info;
+	int i;
+	int rval;
+	unsigned long count;
+	dma_addr_t pci_dma_addr, ipu_iova;
+
+	info = kzalloc(sizeof(*info), GFP_KERNEL);
+	if (!info)
+		return NULL;
+
+	size = PAGE_ALIGN(size);
+	count = size >> PAGE_SHIFT;
+
+	iova = alloc_iova(&mmu->dmap->iovad, count,
+			  dma_get_mask(dev) >> PAGE_SHIFT, 0);
+	if (!iova)
+		goto out_kfree;
+
+	pages = __dma_alloc_buffer(dev, size, gfp, attrs);
+	if (!pages)
+		goto out_free_iova;
+
+	dev_dbg(dev, "dma_alloc: iova low pfn %lu, high pfn %lu\n", iova->pfn_lo,
+		iova->pfn_hi);
+	for (i = 0; iova->pfn_lo + i <= iova->pfn_hi; i++) {
+		pci_dma_addr = dma_map_page_attrs(&pdev->dev, pages[i], 0,
+						  PAGE_SIZE, DMA_BIDIRECTIONAL,
+						  attrs);
+		dev_dbg(dev, "dma_alloc: mapped pci_dma_addr %pad\n",
+			&pci_dma_addr);
+		if (dma_mapping_error(&pdev->dev, pci_dma_addr)) {
+			dev_err(dev, "pci_dma_mapping for page[%d] failed", i);
+			goto out_unmap;
+		}
+
+		rval = ipu_mmu_map(mmu->dmap->mmu_info,
+				   (iova->pfn_lo + i) << PAGE_SHIFT,
+				   pci_dma_addr, PAGE_SIZE);
+		if (rval) {
+			dev_err(dev, "ipu_mmu_map for pci_dma[%d] %pad failed",
+				i, &pci_dma_addr);
+			dma_unmap_page_attrs(&pdev->dev, pci_dma_addr,
+					     PAGE_SIZE, DMA_BIDIRECTIONAL,
+					     attrs);
+			goto out_unmap;
+		}
+	}
+
+	info->vaddr = vmap(pages, count, VM_USERMAP, PAGE_KERNEL);
+	if (!info->vaddr)
+		goto out_unmap;
+
+	*dma_handle = iova->pfn_lo << PAGE_SHIFT;
+
+	info->pages = pages;
+	info->ipu_iova = *dma_handle;
+	info->size = size;
+	list_add(&info->list, &mmu->vma_list);
+
+	return info->vaddr;
+
+out_unmap:
+	for (i--; i >= 0; i--) {
+		ipu_iova = (iova->pfn_lo + i) << PAGE_SHIFT;
+		pci_dma_addr = ipu_mmu_iova_to_phys(mmu->dmap->mmu_info,
+						    ipu_iova);
+		dma_unmap_page_attrs(&pdev->dev, pci_dma_addr, PAGE_SIZE,
+				     DMA_BIDIRECTIONAL, attrs);
+
+		ipu_mmu_unmap(mmu->dmap->mmu_info, ipu_iova, PAGE_SIZE);
+	}
+
+	__dma_free_buffer(dev, pages, size, attrs);
+
+out_free_iova:
+	__free_iova(&mmu->dmap->iovad, iova);
+out_kfree:
+	kfree(info);
+
+	return NULL;
+}
+
+static void ipu_dma_free(struct device *dev, size_t size, void *vaddr,
+			 dma_addr_t dma_handle,
+			 unsigned long attrs)
+{
+	struct ipu_mmu *mmu = to_ipu_bus_device(dev)->mmu;
+	struct pci_dev *pdev = to_ipu_bus_device(dev)->isp->pdev;
+	struct page **pages;
+	struct vm_info *info;
+	struct iova *iova = find_iova(&mmu->dmap->iovad,
+				      dma_handle >> PAGE_SHIFT);
+	dma_addr_t pci_dma_addr, ipu_iova;
+	int i;
+
+	if (WARN_ON(!iova))
+		return;
+
+	info = get_vm_info(mmu, dma_handle);
+	if (WARN_ON(!info))
+		return;
+
+	if (WARN_ON(!info->vaddr))
+		return;
+
+	if (WARN_ON(!info->pages))
+		return;
+
+	list_del(&info->list);
+
+	size = PAGE_ALIGN(size);
+
+	pages = info->pages;
+
+	vunmap(vaddr);
+
+	for (i = 0; i < size >> PAGE_SHIFT; i++) {
+		ipu_iova = (iova->pfn_lo + i) << PAGE_SHIFT;
+		pci_dma_addr = ipu_mmu_iova_to_phys(mmu->dmap->mmu_info,
+						    ipu_iova);
+		dma_unmap_page_attrs(&pdev->dev, pci_dma_addr, PAGE_SIZE,
+				     DMA_BIDIRECTIONAL, attrs);
+	}
+
+	ipu_mmu_unmap(mmu->dmap->mmu_info, iova->pfn_lo << PAGE_SHIFT,
+		      iova_size(iova) << PAGE_SHIFT);
+
+	__dma_free_buffer(dev, pages, size, attrs);
+
+	mmu->tlb_invalidate(mmu);
+
+	__free_iova(&mmu->dmap->iovad, iova);
+
+	kfree(info);
+}
+
+static int ipu_dma_mmap(struct device *dev, struct vm_area_struct *vma,
+			void *addr, dma_addr_t iova, size_t size,
+			unsigned long attrs)
+{
+	struct ipu_mmu *mmu = to_ipu_bus_device(dev)->mmu;
+	struct vm_info *info;
+	size_t count = PAGE_ALIGN(size) >> PAGE_SHIFT;
+	size_t i;
+
+	info = get_vm_info(mmu, iova);
+	if (!info)
+		return -EFAULT;
+
+	if (!info->vaddr)
+		return -EFAULT;
+
+	if (vma->vm_start & ~PAGE_MASK)
+		return -EINVAL;
+
+	if (size > info->size)
+		return -EFAULT;
+
+	for (i = 0; i < count; i++)
+		vm_insert_page(vma, vma->vm_start + (i << PAGE_SHIFT),
+			       info->pages[i]);
+
+	return 0;
+}
+
+static void ipu_dma_unmap_sg(struct device *dev,
+			     struct scatterlist *sglist,
+			     int nents, enum dma_data_direction dir,
+			     unsigned long attrs)
+{
+	int i, npages, count;
+	struct scatterlist *sg;
+	dma_addr_t pci_dma_addr;
+	struct ipu_mmu *mmu = to_ipu_bus_device(dev)->mmu;
+	struct pci_dev *pdev = to_ipu_bus_device(dev)->isp->pdev;
+	struct iova *iova = find_iova(&mmu->dmap->iovad,
+				      sg_dma_address(sglist) >> PAGE_SHIFT);
+
+	if (!nents)
+		return;
+
+	if (WARN_ON(!iova))
+		return;
+
+	if ((attrs & DMA_ATTR_SKIP_CPU_SYNC) == 0)
+		ipu_dma_sync_sg_for_cpu(dev, sglist, nents, DMA_BIDIRECTIONAL);
+
+	/* get the nents as orig_nents given by caller */
+	count = 0;
+	npages = iova_size(iova);
+	for_each_sg(sglist, sg, nents, i) {
+		if (sg_dma_len(sg) == 0 ||
+		    sg_dma_address(sg) == DMA_MAPPING_ERROR)
+			break;
+
+		npages -= PAGE_ALIGN(sg_dma_len(sg)) >> PAGE_SHIFT;
+		count++;
+		if (npages <= 0)
+			break;
+	}
+
+	/* before ipu mmu unmap, return the pci dma address back to sg
+	 * assume the nents is less than orig_nents as the least granule
+	 * is 1 SZ_4K page
+	 */
+	dev_dbg(dev, "trying to unmap concatenated %u ents\n", count);
+	for_each_sg(sglist, sg, count, i) {
+		dev_dbg(dev, "ipu_unmap sg[%d] %pad\n", i, &sg_dma_address(sg));
+		pci_dma_addr = ipu_mmu_iova_to_phys(mmu->dmap->mmu_info,
+						    sg_dma_address(sg));
+		dev_dbg(dev, "return pci_dma_addr %pad back to sg[%d]\n",
+			&pci_dma_addr, i);
+		sg_dma_address(sg) = pci_dma_addr;
+	}
+
+	dev_dbg(dev, "ipu_mmu_unmap low pfn %lu high pfn %lu\n",
+		iova->pfn_lo, iova->pfn_hi);
+	ipu_mmu_unmap(mmu->dmap->mmu_info, iova->pfn_lo << PAGE_SHIFT,
+		      iova_size(iova) << PAGE_SHIFT);
+
+	mmu->tlb_invalidate(mmu);
+
+	dma_unmap_sg_attrs(&pdev->dev, sglist, nents, dir, attrs);
+
+	__free_iova(&mmu->dmap->iovad, iova);
+}
+
+static int ipu_dma_map_sg(struct device *dev, struct scatterlist *sglist,
+			  int nents, enum dma_data_direction dir,
+			  unsigned long attrs)
+{
+	struct ipu_mmu *mmu = to_ipu_bus_device(dev)->mmu;
+	struct pci_dev *pdev = to_ipu_bus_device(dev)->isp->pdev;
+	struct scatterlist *sg;
+	struct iova *iova;
+	size_t npages = 0;
+	u32 iova_addr;
+	int i, count;
+
+	dev_dbg(dev, "pci_dma_map_sg trying to map %d ents\n", nents);
+	count  = dma_map_sg_attrs(&pdev->dev, sglist, nents, dir, attrs);
+	if (count <= 0) {
+		dev_err(dev, "pci_dma_map_sg %d ents failed\n", nents);
+		return 0;
+	}
+
+	dev_dbg(dev, "pci_dma_map_sg %d ents mapped\n", count);
+
+	for_each_sg(sglist, sg, count, i)
+		npages += PAGE_ALIGN(sg_dma_len(sg)) >> PAGE_SHIFT;
+
+	iova = alloc_iova(&mmu->dmap->iovad, npages,
+			  dma_get_mask(dev) >> PAGE_SHIFT, 0);
+	if (!iova)
+		return 0;
+
+	dev_dbg(dev, "dmamap: iova low pfn %lu, high pfn %lu\n", iova->pfn_lo,
+		iova->pfn_hi);
+
+	iova_addr = iova->pfn_lo;
+	for_each_sg(sglist, sg, count, i) {
+		int rval;
+
+		dev_dbg(dev, "mapping entry %d: iova 0x%lx phy %pad size %d\n",
+			i, (unsigned long)iova_addr << PAGE_SHIFT,
+			&sg_dma_address(sg), sg_dma_len(sg));
+
+		dev_dbg(dev, "mapping entry %d: sg->length = %d\n", i,
+			sg->length);
+
+		rval = ipu_mmu_map(mmu->dmap->mmu_info, iova_addr << PAGE_SHIFT,
+				   sg_dma_address(sg),
+				   PAGE_ALIGN(sg_dma_len(sg)));
+		if (rval)
+			goto out_fail;
+
+		sg_dma_address(sg) = iova_addr << PAGE_SHIFT;
+
+		iova_addr += PAGE_ALIGN(sg_dma_len(sg)) >> PAGE_SHIFT;
+	}
+
+	if ((attrs & DMA_ATTR_SKIP_CPU_SYNC) == 0)
+		ipu_dma_sync_sg_for_cpu(dev, sglist, nents, DMA_BIDIRECTIONAL);
+
+	mmu->tlb_invalidate(mmu);
+
+	return count;
+
+out_fail:
+	ipu_dma_unmap_sg(dev, sglist, i, dir, attrs);
+
+	return 0;
+}
+
+/*
+ * Create scatter-list for the already allocated DMA buffer
+ */
+static int ipu_dma_get_sgtable(struct device *dev, struct sg_table *sgt,
+			       void *cpu_addr, dma_addr_t handle, size_t size,
+			       unsigned long attrs)
+{
+	struct ipu_mmu *mmu = to_ipu_bus_device(dev)->mmu;
+	struct vm_info *info;
+	int n_pages;
+	int ret = 0;
+
+	info = get_vm_info(mmu, handle);
+	if (!info)
+		return -EFAULT;
+
+	if (!info->vaddr)
+		return -EFAULT;
+
+	if (WARN_ON(!info->pages))
+		return -ENOMEM;
+
+	n_pages = PAGE_ALIGN(size) >> PAGE_SHIFT;
+
+	ret = sg_alloc_table_from_pages(sgt, info->pages, n_pages, 0, size,
+					GFP_KERNEL);
+	if (ret)
+		dev_warn(dev, "IPU get sgt table fail\n");
+
+	return ret;
+}
+
+const struct dma_map_ops ipu_dma_ops = {
+	.alloc = ipu_dma_alloc,
+	.free = ipu_dma_free,
+	.mmap = ipu_dma_mmap,
+	.map_sg = ipu_dma_map_sg,
+	.unmap_sg = ipu_dma_unmap_sg,
+	.sync_single_for_cpu = ipu_dma_sync_single_for_cpu,
+	.sync_single_for_device = ipu_dma_sync_single_for_cpu,
+	.sync_sg_for_cpu = ipu_dma_sync_sg_for_cpu,
+	.sync_sg_for_device = ipu_dma_sync_sg_for_cpu,
+	.get_sgtable = ipu_dma_get_sgtable,
+};
Index: b/drivers/media/pci/intel/ipu-dma.h
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu-dma.h
@@ -0,0 +1,19 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2013 - 2020 Intel Corporation */
+
+#ifndef IPU_DMA_H
+#define IPU_DMA_H
+
+#include <linux/iova.h>
+
+struct ipu_mmu_info;
+
+struct ipu_dma_mapping {
+	struct ipu_mmu_info *mmu_info;
+	struct iova_domain iovad;
+	struct kref ref;
+};
+
+extern const struct dma_map_ops ipu_dma_ops;
+
+#endif /* IPU_DMA_H */
Index: b/drivers/media/pci/intel/ipu-fw-com.c
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu-fw-com.c
@@ -0,0 +1,501 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) 2013 - 2022 Intel Corporation
+
+#include <asm/cacheflush.h>
+
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/dma-mapping.h>
+
+#include "ipu.h"
+#include "ipu-trace.h"
+#include "ipu-fw-com.h"
+#include "ipu-bus.h"
+
+/*
+ * FWCOM layer is a shared resource between FW and driver. It consist
+ * of token queues to both send and receive directions. Queue is simply
+ * an array of structures with read and write indexes to the queue.
+ * There are 1...n queues to both directions. Queues locates in
+ * system ram and are mapped to ISP MMU so that both CPU and ISP can
+ * see the same buffer. Indexes are located in ISP DMEM so that FW code
+ * can poll those with very low latency and cost. CPU access to indexes is
+ * more costly but that happens only at message sending time and
+ * interrupt trigged message handling. CPU doesn't need to poll indexes.
+ * wr_reg / rd_reg are offsets to those dmem location. They are not
+ * the indexes itself.
+ */
+
+/* Shared structure between driver and FW - do not modify */
+struct ipu_fw_sys_queue {
+	u64 host_address;
+	u32 vied_address;
+	u32 size;
+	u32 token_size;
+	u32 wr_reg;	/* reg no in subsystem's regmem */
+	u32 rd_reg;
+	u32 _align;
+};
+
+struct ipu_fw_sys_queue_res {
+	u64 host_address;
+	u32 vied_address;
+	u32 reg;
+};
+
+enum syscom_state {
+	/* Program load or explicit host setting should init to this */
+	SYSCOM_STATE_UNINIT = 0x57A7E000,
+	/* SP Syscom sets this when it is ready for use */
+	SYSCOM_STATE_READY = 0x57A7E001,
+	/* SP Syscom sets this when no more syscom accesses will happen */
+	SYSCOM_STATE_INACTIVE = 0x57A7E002
+};
+
+enum syscom_cmd {
+	/* Program load or explicit host setting should init to this */
+	SYSCOM_COMMAND_UNINIT = 0x57A7F000,
+	/* Host Syscom requests syscom to become inactive */
+	SYSCOM_COMMAND_INACTIVE = 0x57A7F001
+};
+
+/* firmware config: data that sent from the host to SP via DDR */
+/* Cell copies data into a context */
+
+struct ipu_fw_syscom_config {
+	u32 firmware_address;
+
+	u32 num_input_queues;
+	u32 num_output_queues;
+
+	/* ISP pointers to an array of ipu_fw_sys_queue structures */
+	u32 input_queue;
+	u32 output_queue;
+
+	/* ISYS / PSYS private data */
+	u32 specific_addr;
+	u32 specific_size;
+};
+
+/* End of shared structures / data */
+
+struct ipu_fw_com_context {
+	struct ipu_bus_device *adev;
+	void __iomem *dmem_addr;
+	int (*cell_ready)(struct ipu_bus_device *adev);
+	void (*cell_start)(struct ipu_bus_device *adev);
+
+	void *dma_buffer;
+	dma_addr_t dma_addr;
+	unsigned int dma_size;
+	unsigned long attrs;
+
+	unsigned int num_input_queues;
+	unsigned int num_output_queues;
+
+	struct ipu_fw_sys_queue *input_queue;	/* array of host to SP queues */
+	struct ipu_fw_sys_queue *output_queue;	/* array of SP to host */
+
+	void *config_host_addr;
+	void *specific_host_addr;
+	u64 ibuf_host_addr;
+	u64 obuf_host_addr;
+
+	u32 config_vied_addr;
+	u32 input_queue_vied_addr;
+	u32 output_queue_vied_addr;
+	u32 specific_vied_addr;
+	u32 ibuf_vied_addr;
+	u32 obuf_vied_addr;
+
+	unsigned int buttress_boot_offset;
+	void __iomem *base_addr;
+};
+
+#define FW_COM_WR_REG 0
+#define FW_COM_RD_REG 4
+
+#define REGMEM_OFFSET 0
+#define TUNIT_MAGIC_PATTERN 0x5a5a5a5a
+
+enum regmem_id {
+	/* pass pkg_dir address to SPC in non-secure mode */
+	PKG_DIR_ADDR_REG = 0,
+	/* Tunit CFG blob for secure - provided by host.*/
+	TUNIT_CFG_DWR_REG = 1,
+	/* syscom commands - modified by the host */
+	SYSCOM_COMMAND_REG = 2,
+	/* Store interrupt status - updated by SP */
+	SYSCOM_IRQ_REG = 3,
+	/* first syscom queue pointer register */
+	SYSCOM_QPR_BASE_REG = 4
+};
+
+enum message_direction {
+	DIR_RECV = 0,
+	DIR_SEND
+};
+
+#define BUTRESS_FW_BOOT_PARAMS_0 0x4000
+#define BUTTRESS_FW_BOOT_PARAM_REG(base, offset, id) ((base) \
+	+ BUTRESS_FW_BOOT_PARAMS_0 + ((offset) + (id)) * 4)
+
+enum buttress_syscom_id {
+	/* pass syscom configuration to SPC */
+	SYSCOM_CONFIG_ID		= 0,
+	/* syscom state - modified by SP */
+	SYSCOM_STATE_ID			= 1,
+	/* syscom vtl0 addr mask */
+	SYSCOM_VTL0_ADDR_MASK_ID	= 2,
+	SYSCOM_ID_MAX
+};
+
+static unsigned int num_messages(unsigned int wr, unsigned int rd,
+				 unsigned int size)
+{
+	if (wr < rd)
+		wr += size;
+	return wr - rd;
+}
+
+static unsigned int num_free(unsigned int wr, unsigned int rd,
+			     unsigned int size)
+{
+	return size - num_messages(wr, rd, size);
+}
+
+static unsigned int curr_index(void __iomem *q_dmem,
+			       enum message_direction dir)
+{
+	return readl(q_dmem +
+			 (dir == DIR_RECV ? FW_COM_RD_REG : FW_COM_WR_REG));
+}
+
+static unsigned int inc_index(void __iomem *q_dmem, struct ipu_fw_sys_queue *q,
+			      enum message_direction dir)
+{
+	unsigned int index;
+
+	index = curr_index(q_dmem, dir) + 1;
+	return index >= q->size ? 0 : index;
+}
+
+static unsigned int ipu_sys_queue_buf_size(unsigned int size,
+					   unsigned int token_size)
+{
+	return (size + 1) * token_size;
+}
+
+static void ipu_sys_queue_init(struct ipu_fw_sys_queue *q, unsigned int size,
+			       unsigned int token_size,
+			       struct ipu_fw_sys_queue_res *res)
+{
+	unsigned int buf_size;
+
+	q->size = size + 1;
+	q->token_size = token_size;
+	buf_size = ipu_sys_queue_buf_size(size, token_size);
+
+	/* acquire the shared buffer space */
+	q->host_address = res->host_address;
+	res->host_address += buf_size;
+	q->vied_address = res->vied_address;
+	res->vied_address += buf_size;
+
+	/* acquire the shared read and writer pointers */
+	q->wr_reg = res->reg;
+	res->reg++;
+	q->rd_reg = res->reg;
+	res->reg++;
+}
+
+void *ipu_fw_com_prepare(struct ipu_fw_com_cfg *cfg,
+			 struct ipu_bus_device *adev, void __iomem *base)
+{
+	struct ipu_fw_com_context *ctx;
+	struct ipu_fw_syscom_config *fw_cfg;
+	unsigned int i;
+	unsigned int sizeall, offset;
+	unsigned int sizeinput = 0, sizeoutput = 0;
+	unsigned long attrs = 0;
+	struct ipu_fw_sys_queue_res res;
+
+	/* error handling */
+	if (!cfg || !cfg->cell_start || !cfg->cell_ready)
+		return NULL;
+
+	ctx = kzalloc(sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return NULL;
+	ctx->dmem_addr = base + cfg->dmem_addr + REGMEM_OFFSET;
+	ctx->adev = adev;
+	ctx->cell_start = cfg->cell_start;
+	ctx->cell_ready = cfg->cell_ready;
+	ctx->buttress_boot_offset = cfg->buttress_boot_offset;
+	ctx->base_addr  = base;
+
+	ctx->num_input_queues = cfg->num_input_queues;
+	ctx->num_output_queues = cfg->num_output_queues;
+
+	/*
+	 * Allocate DMA mapped memory. Allocate one big chunk.
+	 */
+	sizeall =
+	    /* Base cfg for FW */
+	    roundup(sizeof(struct ipu_fw_syscom_config), 8) +
+	    /* Descriptions of the queues */
+	    cfg->num_input_queues * sizeof(struct ipu_fw_sys_queue) +
+	    cfg->num_output_queues * sizeof(struct ipu_fw_sys_queue) +
+	    /* FW specific information structure */
+	    roundup(cfg->specific_size, 8);
+
+	for (i = 0; i < cfg->num_input_queues; i++)
+		sizeinput += ipu_sys_queue_buf_size(cfg->input[i].queue_size,
+						cfg->input[i].token_size);
+
+	for (i = 0; i < cfg->num_output_queues; i++)
+		sizeoutput += ipu_sys_queue_buf_size(cfg->output[i].queue_size,
+						 cfg->output[i].token_size);
+
+	sizeall += sizeinput + sizeoutput;
+
+	ctx->dma_buffer = dma_alloc_attrs(&ctx->adev->dev, sizeall,
+					  &ctx->dma_addr, GFP_KERNEL,
+					  attrs);
+	ctx->attrs = attrs;
+	if (!ctx->dma_buffer) {
+		dev_err(&ctx->adev->dev, "failed to allocate dma memory\n");
+		kfree(ctx);
+		return NULL;
+	}
+
+	ctx->dma_size = sizeall;
+
+	/* This is the address where FW starts to parse allocations */
+	ctx->config_host_addr = ctx->dma_buffer;
+	ctx->config_vied_addr = ctx->dma_addr;
+	fw_cfg = (struct ipu_fw_syscom_config *)ctx->config_host_addr;
+	offset = roundup(sizeof(struct ipu_fw_syscom_config), 8);
+
+	ctx->input_queue = ctx->dma_buffer + offset;
+	ctx->input_queue_vied_addr = ctx->dma_addr + offset;
+	offset += cfg->num_input_queues * sizeof(struct ipu_fw_sys_queue);
+
+	ctx->output_queue = ctx->dma_buffer + offset;
+	ctx->output_queue_vied_addr = ctx->dma_addr + offset;
+	offset += cfg->num_output_queues * sizeof(struct ipu_fw_sys_queue);
+
+	ctx->specific_host_addr = ctx->dma_buffer + offset;
+	ctx->specific_vied_addr = ctx->dma_addr + offset;
+	offset += roundup(cfg->specific_size, 8);
+
+	ctx->ibuf_host_addr = (uintptr_t)(ctx->dma_buffer + offset);
+	ctx->ibuf_vied_addr = ctx->dma_addr + offset;
+	offset += sizeinput;
+
+	ctx->obuf_host_addr = (uintptr_t)(ctx->dma_buffer + offset);
+	ctx->obuf_vied_addr = ctx->dma_addr + offset;
+	offset += sizeoutput;
+
+	/* initialize input queues */
+	res.reg = SYSCOM_QPR_BASE_REG;
+	res.host_address = ctx->ibuf_host_addr;
+	res.vied_address = ctx->ibuf_vied_addr;
+	for (i = 0; i < cfg->num_input_queues; i++) {
+		ipu_sys_queue_init(ctx->input_queue + i,
+				   cfg->input[i].queue_size,
+				   cfg->input[i].token_size, &res);
+	}
+
+	/* initialize output queues */
+	res.host_address = ctx->obuf_host_addr;
+	res.vied_address = ctx->obuf_vied_addr;
+	for (i = 0; i < cfg->num_output_queues; i++) {
+		ipu_sys_queue_init(ctx->output_queue + i,
+				   cfg->output[i].queue_size,
+				   cfg->output[i].token_size, &res);
+	}
+
+	/* copy firmware specific data */
+	if (cfg->specific_addr && cfg->specific_size) {
+		memcpy((void *)ctx->specific_host_addr,
+		       cfg->specific_addr, cfg->specific_size);
+	}
+
+	fw_cfg->num_input_queues = cfg->num_input_queues;
+	fw_cfg->num_output_queues = cfg->num_output_queues;
+	fw_cfg->input_queue = ctx->input_queue_vied_addr;
+	fw_cfg->output_queue = ctx->output_queue_vied_addr;
+	fw_cfg->specific_addr = ctx->specific_vied_addr;
+	fw_cfg->specific_size = cfg->specific_size;
+	return ctx;
+}
+EXPORT_SYMBOL_GPL(ipu_fw_com_prepare);
+
+int ipu_fw_com_open(struct ipu_fw_com_context *ctx)
+{
+	dma_addr_t trace_buff = TUNIT_MAGIC_PATTERN;
+
+	/*
+	 * Write trace buff start addr to tunit cfg reg.
+	 * This feature is used to enable tunit trace in secure mode.
+	 */
+	ipu_trace_buffer_dma_handle(&ctx->adev->dev, &trace_buff);
+	writel(trace_buff, ctx->dmem_addr + TUNIT_CFG_DWR_REG * 4);
+
+	/* Check if SP is in valid state */
+	if (!ctx->cell_ready(ctx->adev))
+		return -EIO;
+
+	/* store syscom uninitialized command */
+	writel(SYSCOM_COMMAND_UNINIT,
+	       ctx->dmem_addr + SYSCOM_COMMAND_REG * 4);
+
+	/* store syscom uninitialized state */
+	writel(SYSCOM_STATE_UNINIT,
+	       BUTTRESS_FW_BOOT_PARAM_REG(ctx->base_addr,
+					  ctx->buttress_boot_offset,
+					  SYSCOM_STATE_ID));
+
+	/* store firmware configuration address */
+	writel(ctx->config_vied_addr,
+	       BUTTRESS_FW_BOOT_PARAM_REG(ctx->base_addr,
+					  ctx->buttress_boot_offset,
+					  SYSCOM_CONFIG_ID));
+	ctx->cell_start(ctx->adev);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ipu_fw_com_open);
+
+int ipu_fw_com_close(struct ipu_fw_com_context *ctx)
+{
+	int state;
+
+	state = readl(BUTTRESS_FW_BOOT_PARAM_REG(ctx->base_addr,
+						 ctx->buttress_boot_offset,
+						 SYSCOM_STATE_ID));
+	if (state != SYSCOM_STATE_READY)
+		return -EBUSY;
+
+	/* set close request flag */
+	writel(SYSCOM_COMMAND_INACTIVE, ctx->dmem_addr +
+		   SYSCOM_COMMAND_REG * 4);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ipu_fw_com_close);
+
+int ipu_fw_com_release(struct ipu_fw_com_context *ctx, unsigned int force)
+{
+	/* check if release is forced, an verify cell state if it is not */
+	if (!force && !ctx->cell_ready(ctx->adev))
+		return -EBUSY;
+
+	dma_free_attrs(&ctx->adev->dev, ctx->dma_size,
+		       ctx->dma_buffer, ctx->dma_addr,
+		       ctx->attrs);
+	kfree(ctx);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ipu_fw_com_release);
+
+int ipu_fw_com_ready(struct ipu_fw_com_context *ctx)
+{
+	int state;
+
+	state = readl(BUTTRESS_FW_BOOT_PARAM_REG(ctx->base_addr,
+						 ctx->buttress_boot_offset,
+						 SYSCOM_STATE_ID));
+	if (state != SYSCOM_STATE_READY)
+		return -EBUSY;	/* SPC is not ready to handle messages yet */
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ipu_fw_com_ready);
+
+static bool is_index_valid(struct ipu_fw_sys_queue *q, unsigned int index)
+{
+	if (index >= q->size)
+		return false;
+	return true;
+}
+
+void *ipu_send_get_token(struct ipu_fw_com_context *ctx, int q_nbr)
+{
+	struct ipu_fw_sys_queue *q = &ctx->input_queue[q_nbr];
+	void __iomem *q_dmem = ctx->dmem_addr + q->wr_reg * 4;
+	unsigned int wr, rd;
+	unsigned int packets;
+	unsigned int index;
+
+	wr = readl(q_dmem + FW_COM_WR_REG);
+	rd = readl(q_dmem + FW_COM_RD_REG);
+
+	/* Catch indexes in dmem */
+	if (!is_index_valid(q, wr) || !is_index_valid(q, rd))
+		return NULL;
+
+	packets = num_free(wr + 1, rd, q->size);
+	if (!packets)
+		return NULL;
+
+	index = curr_index(q_dmem, DIR_SEND);
+
+	return (void *)(unsigned long)q->host_address + (index * q->token_size);
+}
+EXPORT_SYMBOL_GPL(ipu_send_get_token);
+
+void ipu_send_put_token(struct ipu_fw_com_context *ctx, int q_nbr)
+{
+	struct ipu_fw_sys_queue *q = &ctx->input_queue[q_nbr];
+	void __iomem *q_dmem = ctx->dmem_addr + q->wr_reg * 4;
+	int index = curr_index(q_dmem, DIR_SEND);
+
+	/* Increment index */
+	index = inc_index(q_dmem, q, DIR_SEND);
+
+	writel(index, q_dmem + FW_COM_WR_REG);
+}
+EXPORT_SYMBOL_GPL(ipu_send_put_token);
+
+void *ipu_recv_get_token(struct ipu_fw_com_context *ctx, int q_nbr)
+{
+	struct ipu_fw_sys_queue *q = &ctx->output_queue[q_nbr];
+	void __iomem *q_dmem = ctx->dmem_addr + q->wr_reg * 4;
+	unsigned int wr, rd;
+	unsigned int packets;
+	void *addr;
+
+	wr = readl(q_dmem + FW_COM_WR_REG);
+	rd = readl(q_dmem + FW_COM_RD_REG);
+
+	/* Catch indexes in dmem? */
+	if (!is_index_valid(q, wr) || !is_index_valid(q, rd))
+		return NULL;
+
+	packets = num_messages(wr, rd, q->size);
+	if (!packets)
+		return NULL;
+
+	addr = (void *)(unsigned long)q->host_address + (rd * q->token_size);
+
+	return addr;
+}
+EXPORT_SYMBOL_GPL(ipu_recv_get_token);
+
+void ipu_recv_put_token(struct ipu_fw_com_context *ctx, int q_nbr)
+{
+	struct ipu_fw_sys_queue *q = &ctx->output_queue[q_nbr];
+	void __iomem *q_dmem = ctx->dmem_addr + q->wr_reg * 4;
+	unsigned int rd = inc_index(q_dmem, q, DIR_RECV);
+
+	/* Release index */
+	writel(rd, q_dmem + FW_COM_RD_REG);
+}
+EXPORT_SYMBOL_GPL(ipu_recv_put_token);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Intel ipu fw comm library");
Index: b/drivers/media/pci/intel/ipu-fw-com.h
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu-fw-com.h
@@ -0,0 +1,48 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2013 - 2020 Intel Corporation */
+
+#ifndef IPU_FW_COM_H
+#define IPU_FW_COM_H
+
+struct ipu_fw_com_context;
+struct ipu_bus_device;
+
+struct ipu_fw_syscom_queue_config {
+	unsigned int queue_size;	/* tokens per queue */
+	unsigned int token_size;	/* bytes per token */
+};
+
+#define SYSCOM_BUTTRESS_FW_PARAMS_ISYS_OFFSET	0
+#define SYSCOM_BUTTRESS_FW_PARAMS_PSYS_OFFSET	7
+
+struct ipu_fw_com_cfg {
+	unsigned int num_input_queues;
+	unsigned int num_output_queues;
+	struct ipu_fw_syscom_queue_config *input;
+	struct ipu_fw_syscom_queue_config *output;
+
+	unsigned int dmem_addr;
+
+	/* firmware-specific configuration data */
+	void *specific_addr;
+	unsigned int specific_size;
+	int (*cell_ready)(struct ipu_bus_device *adev);
+	void (*cell_start)(struct ipu_bus_device *adev);
+
+	unsigned int buttress_boot_offset;
+};
+
+void *ipu_fw_com_prepare(struct ipu_fw_com_cfg *cfg,
+			 struct ipu_bus_device *adev, void __iomem *base);
+
+int ipu_fw_com_open(struct ipu_fw_com_context *ctx);
+int ipu_fw_com_ready(struct ipu_fw_com_context *ctx);
+int ipu_fw_com_close(struct ipu_fw_com_context *ctx);
+int ipu_fw_com_release(struct ipu_fw_com_context *ctx, unsigned int force);
+
+void *ipu_recv_get_token(struct ipu_fw_com_context *ctx, int q_nbr);
+void ipu_recv_put_token(struct ipu_fw_com_context *ctx, int q_nbr);
+void *ipu_send_get_token(struct ipu_fw_com_context *ctx, int q_nbr);
+void ipu_send_put_token(struct ipu_fw_com_context *ctx, int q_nbr);
+
+#endif
Index: b/drivers/media/pci/intel/ipu-fw-isys.c
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu-fw-isys.c
@@ -0,0 +1,600 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) 2013 - 2021 Intel Corporation
+
+#include <asm/cacheflush.h>
+
+#include <linux/kernel.h>
+#include <linux/delay.h>
+
+#include "ipu.h"
+#include "ipu-trace.h"
+#include "ipu-platform-regs.h"
+#include "ipu-platform.h"
+#include "ipu-fw-isys.h"
+#include "ipu-fw-com.h"
+#include "ipu-isys.h"
+
+#define IPU_FW_UNSUPPORTED_DATA_TYPE	0
+static const uint32_t
+extracted_bits_per_pixel_per_mipi_data_type[N_IPU_FW_ISYS_MIPI_DATA_TYPE] = {
+	64,	/* [0x00]   IPU_FW_ISYS_MIPI_DATA_TYPE_FRAME_START_CODE */
+	64,	/* [0x01]   IPU_FW_ISYS_MIPI_DATA_TYPE_FRAME_END_CODE */
+	64,	/* [0x02]   IPU_FW_ISYS_MIPI_DATA_TYPE_LINE_START_CODE */
+	64,	/* [0x03]   IPU_FW_ISYS_MIPI_DATA_TYPE_LINE_END_CODE */
+	IPU_FW_UNSUPPORTED_DATA_TYPE,	/* [0x04] */
+	IPU_FW_UNSUPPORTED_DATA_TYPE,	/* [0x05] */
+	IPU_FW_UNSUPPORTED_DATA_TYPE,	/* [0x06] */
+	IPU_FW_UNSUPPORTED_DATA_TYPE,	/* [0x07] */
+	64,	/* [0x08]   IPU_FW_ISYS_MIPI_DATA_TYPE_GENERIC_SHORT1 */
+	64,	/* [0x09]   IPU_FW_ISYS_MIPI_DATA_TYPE_GENERIC_SHORT2 */
+	64,	/* [0x0A]   IPU_FW_ISYS_MIPI_DATA_TYPE_GENERIC_SHORT3 */
+	64,	/* [0x0B]   IPU_FW_ISYS_MIPI_DATA_TYPE_GENERIC_SHORT4 */
+	64,	/* [0x0C]   IPU_FW_ISYS_MIPI_DATA_TYPE_GENERIC_SHORT5 */
+	64,	/* [0x0D]   IPU_FW_ISYS_MIPI_DATA_TYPE_GENERIC_SHORT6 */
+	64,	/* [0x0E]   IPU_FW_ISYS_MIPI_DATA_TYPE_GENERIC_SHORT7 */
+	64,	/* [0x0F]   IPU_FW_ISYS_MIPI_DATA_TYPE_GENERIC_SHORT8 */
+	IPU_FW_UNSUPPORTED_DATA_TYPE,	/* [0x10] */
+	IPU_FW_UNSUPPORTED_DATA_TYPE,	/* [0x11] */
+	8,	/* [0x12]    IPU_FW_ISYS_MIPI_DATA_TYPE_EMBEDDED */
+	IPU_FW_UNSUPPORTED_DATA_TYPE,	/* [0x13] */
+	IPU_FW_UNSUPPORTED_DATA_TYPE,	/* [0x14] */
+	IPU_FW_UNSUPPORTED_DATA_TYPE,	/* [0x15] */
+	IPU_FW_UNSUPPORTED_DATA_TYPE,	/* [0x16] */
+	IPU_FW_UNSUPPORTED_DATA_TYPE,	/* [0x17] */
+	12,	/* [0x18]   IPU_FW_ISYS_MIPI_DATA_TYPE_YUV420_8 */
+	15,	/* [0x19]   IPU_FW_ISYS_MIPI_DATA_TYPE_YUV420_10 */
+	12,	/* [0x1A]   IPU_FW_ISYS_MIPI_DATA_TYPE_YUV420_8_LEGACY */
+	IPU_FW_UNSUPPORTED_DATA_TYPE,	/* [0x1B] */
+	12,	/* [0x1C]   IPU_FW_ISYS_MIPI_DATA_TYPE_YUV420_8_SHIFT */
+	15,	/* [0x1D]   IPU_FW_ISYS_MIPI_DATA_TYPE_YUV420_10_SHIFT */
+	16,	/* [0x1E]   IPU_FW_ISYS_MIPI_DATA_TYPE_YUV422_8 */
+	20,	/* [0x1F]   IPU_FW_ISYS_MIPI_DATA_TYPE_YUV422_10 */
+	16,	/* [0x20]   IPU_FW_ISYS_MIPI_DATA_TYPE_RGB_444 */
+	16,	/* [0x21]   IPU_FW_ISYS_MIPI_DATA_TYPE_RGB_555 */
+	16,	/* [0x22]   IPU_FW_ISYS_MIPI_DATA_TYPE_RGB_565 */
+	18,	/* [0x23]   IPU_FW_ISYS_MIPI_DATA_TYPE_RGB_666 */
+	24,	/* [0x24]   IPU_FW_ISYS_MIPI_DATA_TYPE_RGB_888 */
+	IPU_FW_UNSUPPORTED_DATA_TYPE,	/* [0x25] */
+	IPU_FW_UNSUPPORTED_DATA_TYPE,	/* [0x26] */
+	IPU_FW_UNSUPPORTED_DATA_TYPE,	/* [0x27] */
+	6,	/* [0x28]    IPU_FW_ISYS_MIPI_DATA_TYPE_RAW_6 */
+	7,	/* [0x29]    IPU_FW_ISYS_MIPI_DATA_TYPE_RAW_7 */
+	8,	/* [0x2A]    IPU_FW_ISYS_MIPI_DATA_TYPE_RAW_8 */
+	10,	/* [0x2B]   IPU_FW_ISYS_MIPI_DATA_TYPE_RAW_10 */
+	12,	/* [0x2C]   IPU_FW_ISYS_MIPI_DATA_TYPE_RAW_12 */
+	14,	/* [0x2D]   IPU_FW_ISYS_MIPI_DATA_TYPE_RAW_14 */
+	16,	/* [0x2E]   IPU_FW_ISYS_MIPI_DATA_TYPE_RAW_16 */
+	8,	/* [0x2F]    IPU_FW_ISYS_MIPI_DATA_TYPE_BINARY_8 */
+	8,	/* [0x30]    IPU_FW_ISYS_MIPI_DATA_TYPE_USER_DEF1 */
+	8,	/* [0x31]    IPU_FW_ISYS_MIPI_DATA_TYPE_USER_DEF2 */
+	8,	/* [0x32]    IPU_FW_ISYS_MIPI_DATA_TYPE_USER_DEF3 */
+	8,	/* [0x33]    IPU_FW_ISYS_MIPI_DATA_TYPE_USER_DEF4 */
+	8,	/* [0x34]    IPU_FW_ISYS_MIPI_DATA_TYPE_USER_DEF5 */
+	8,	/* [0x35]    IPU_FW_ISYS_MIPI_DATA_TYPE_USER_DEF6 */
+	8,	/* [0x36]    IPU_FW_ISYS_MIPI_DATA_TYPE_USER_DEF7 */
+	8,	/* [0x37]    IPU_FW_ISYS_MIPI_DATA_TYPE_USER_DEF8 */
+	IPU_FW_UNSUPPORTED_DATA_TYPE,	/* [0x38] */
+	IPU_FW_UNSUPPORTED_DATA_TYPE,	/* [0x39] */
+	IPU_FW_UNSUPPORTED_DATA_TYPE,	/* [0x3A] */
+	IPU_FW_UNSUPPORTED_DATA_TYPE,	/* [0x3B] */
+	IPU_FW_UNSUPPORTED_DATA_TYPE,	/* [0x3C] */
+	IPU_FW_UNSUPPORTED_DATA_TYPE,	/* [0x3D] */
+	IPU_FW_UNSUPPORTED_DATA_TYPE,	/* [0x3E] */
+	IPU_FW_UNSUPPORTED_DATA_TYPE	/* [0x3F] */
+};
+
+static const char send_msg_types[N_IPU_FW_ISYS_SEND_TYPE][32] = {
+	"STREAM_OPEN",
+	"STREAM_START",
+	"STREAM_START_AND_CAPTURE",
+	"STREAM_CAPTURE",
+	"STREAM_STOP",
+	"STREAM_FLUSH",
+	"STREAM_CLOSE"
+};
+
+static int handle_proxy_response(struct ipu_isys *isys, unsigned int req_id)
+{
+	struct ipu_fw_isys_proxy_resp_info_abi *resp;
+	int rval = -EIO;
+
+	resp = (struct ipu_fw_isys_proxy_resp_info_abi *)
+	    ipu_recv_get_token(isys->fwcom, IPU_BASE_PROXY_RECV_QUEUES);
+	if (!resp)
+		return 1;
+
+	dev_dbg(&isys->adev->dev,
+		"Proxy response: id 0x%x, error %d, details %d\n",
+		resp->request_id, resp->error_info.error,
+		resp->error_info.error_details);
+
+	if (req_id == resp->request_id)
+		rval = 0;
+
+	ipu_recv_put_token(isys->fwcom, IPU_BASE_PROXY_RECV_QUEUES);
+	return rval;
+}
+
+/* Simple blocking proxy send function */
+int ipu_fw_isys_send_proxy_token(struct ipu_isys *isys,
+				 unsigned int req_id,
+				 unsigned int index,
+				 unsigned int offset, u32 value)
+{
+	struct ipu_fw_com_context *ctx = isys->fwcom;
+	struct ipu_fw_proxy_send_queue_token *token;
+	unsigned int timeout = 1000;
+	int rval = -EBUSY;
+
+	dev_dbg(&isys->adev->dev,
+		"proxy send token: req_id 0x%x, index %d, offset 0x%x, value 0x%x\n",
+		req_id, index, offset, value);
+
+	token = ipu_send_get_token(ctx, IPU_BASE_PROXY_SEND_QUEUES);
+	if (!token)
+		goto leave;
+
+	token->request_id = req_id;
+	token->region_index = index;
+	token->offset = offset;
+	token->value = value;
+	ipu_send_put_token(ctx, IPU_BASE_PROXY_SEND_QUEUES);
+
+	/* Currently proxy doesn't support irq based service. Poll */
+	do {
+		usleep_range(100, 110);
+		rval = handle_proxy_response(isys, req_id);
+		if (!rval)
+			break;
+		if (rval == -EIO) {
+			dev_err(&isys->adev->dev,
+				"Proxy response received with unexpected id\n");
+			break;
+		}
+		timeout--;
+	} while (rval && timeout);
+
+	if (!timeout)
+		dev_err(&isys->adev->dev, "Proxy response timed out\n");
+leave:
+	return rval;
+}
+
+int
+ipu_fw_isys_complex_cmd(struct ipu_isys *isys,
+			const unsigned int stream_handle,
+			void *cpu_mapped_buf,
+			dma_addr_t dma_mapped_buf,
+			size_t size, enum ipu_fw_isys_send_type send_type)
+{
+	struct ipu_fw_com_context *ctx = isys->fwcom;
+	struct ipu_fw_send_queue_token *token;
+
+	if (send_type >= N_IPU_FW_ISYS_SEND_TYPE)
+		return -EINVAL;
+
+	dev_dbg(&isys->adev->dev, "send_token: %s\n",
+		send_msg_types[send_type]);
+
+	/*
+	 * Time to flush cache in case we have some payload. Not all messages
+	 * have that
+	 */
+	if (cpu_mapped_buf)
+		clflush_cache_range(cpu_mapped_buf, size);
+
+	token = ipu_send_get_token(ctx,
+				   stream_handle + IPU_BASE_MSG_SEND_QUEUES);
+	if (!token)
+		return -EBUSY;
+
+	token->payload = dma_mapped_buf;
+	token->buf_handle = (unsigned long)cpu_mapped_buf;
+	token->send_type = send_type;
+
+	ipu_send_put_token(ctx, stream_handle + IPU_BASE_MSG_SEND_QUEUES);
+
+	return 0;
+}
+
+int ipu_fw_isys_simple_cmd(struct ipu_isys *isys,
+			   const unsigned int stream_handle,
+			   enum ipu_fw_isys_send_type send_type)
+{
+	return ipu_fw_isys_complex_cmd(isys, stream_handle, NULL, 0, 0,
+				       send_type);
+}
+
+int ipu_fw_isys_close(struct ipu_isys *isys)
+{
+	struct device *dev = &isys->adev->dev;
+	int timeout = IPU_ISYS_TURNOFF_TIMEOUT;
+	int rval;
+	unsigned long flags;
+	void *fwcom;
+
+	/*
+	 * Stop the isys fw. Actual close takes
+	 * some time as the FW must stop its actions including code fetch
+	 * to SP icache.
+	 * spinlock to wait the interrupt handler to be finished
+	 */
+	spin_lock_irqsave(&isys->power_lock, flags);
+	rval = ipu_fw_com_close(isys->fwcom);
+	fwcom = isys->fwcom;
+	isys->fwcom = NULL;
+	spin_unlock_irqrestore(&isys->power_lock, flags);
+	if (rval)
+		dev_err(dev, "Device close failure: %d\n", rval);
+
+	/* release probably fails if the close failed. Let's try still */
+	do {
+		usleep_range(IPU_ISYS_TURNOFF_DELAY_US,
+			     2 * IPU_ISYS_TURNOFF_DELAY_US);
+		rval = ipu_fw_com_release(fwcom, 0);
+		timeout--;
+	} while (rval != 0 && timeout);
+
+	if (rval) {
+		dev_err(dev, "Device release time out %d\n", rval);
+		spin_lock_irqsave(&isys->power_lock, flags);
+		isys->fwcom = fwcom;
+		spin_unlock_irqrestore(&isys->power_lock, flags);
+	}
+
+	return rval;
+}
+
+void ipu_fw_isys_cleanup(struct ipu_isys *isys)
+{
+	int ret;
+
+	ret = ipu_fw_com_release(isys->fwcom, 1);
+	if (ret < 0)
+		dev_err(&isys->adev->dev,
+			"Device busy, fw_com release failed.");
+	isys->fwcom = NULL;
+}
+
+static void start_sp(struct ipu_bus_device *adev)
+{
+	struct ipu_isys *isys = ipu_bus_get_drvdata(adev);
+	void __iomem *spc_regs_base = isys->pdata->base +
+	    isys->pdata->ipdata->hw_variant.spc_offset;
+	u32 val = 0;
+
+	val |= IPU_ISYS_SPC_STATUS_START |
+	    IPU_ISYS_SPC_STATUS_RUN |
+	    IPU_ISYS_SPC_STATUS_CTRL_ICACHE_INVALIDATE;
+	val |= isys->icache_prefetch ? IPU_ISYS_SPC_STATUS_ICACHE_PREFETCH : 0;
+
+	writel(val, spc_regs_base + IPU_ISYS_REG_SPC_STATUS_CTRL);
+}
+
+static int query_sp(struct ipu_bus_device *adev)
+{
+	struct ipu_isys *isys = ipu_bus_get_drvdata(adev);
+	void __iomem *spc_regs_base = isys->pdata->base +
+	    isys->pdata->ipdata->hw_variant.spc_offset;
+	u32 val = readl(spc_regs_base + IPU_ISYS_REG_SPC_STATUS_CTRL);
+
+	/* return true when READY == 1, START == 0 */
+	val &= IPU_ISYS_SPC_STATUS_READY | IPU_ISYS_SPC_STATUS_START;
+
+	return val == IPU_ISYS_SPC_STATUS_READY;
+}
+
+static int ipu6_isys_fwcom_cfg_init(struct ipu_isys *isys,
+				    struct ipu_fw_com_cfg *fwcom,
+				    unsigned int num_streams)
+{
+	int i;
+	unsigned int size;
+	struct ipu_fw_syscom_queue_config *input_queue_cfg;
+	struct ipu_fw_syscom_queue_config *output_queue_cfg;
+	struct ipu6_fw_isys_fw_config *isys_fw_cfg;
+	int num_out_message_queues = 1;
+	int type_proxy = IPU_FW_ISYS_QUEUE_TYPE_PROXY;
+	int type_dev = IPU_FW_ISYS_QUEUE_TYPE_DEV;
+	int type_msg = IPU_FW_ISYS_QUEUE_TYPE_MSG;
+	int base_dev_send = IPU_BASE_DEV_SEND_QUEUES;
+	int base_msg_send = IPU_BASE_MSG_SEND_QUEUES;
+	int base_msg_recv = IPU_BASE_MSG_RECV_QUEUES;
+	int num_in_message_queues;
+	unsigned int max_streams;
+	unsigned int max_send_queues, max_sram_blocks, max_devq_size;
+
+	max_streams = IPU6_ISYS_NUM_STREAMS;
+	max_send_queues = IPU6_N_MAX_SEND_QUEUES;
+	max_sram_blocks = IPU6_NOF_SRAM_BLOCKS_MAX;
+	max_devq_size = IPU6_DEV_SEND_QUEUE_SIZE;
+	if (ipu_ver == IPU_VER_6SE) {
+		max_streams = IPU6SE_ISYS_NUM_STREAMS;
+		max_send_queues = IPU6SE_N_MAX_SEND_QUEUES;
+		max_sram_blocks = IPU6SE_NOF_SRAM_BLOCKS_MAX;
+		max_devq_size = IPU6SE_DEV_SEND_QUEUE_SIZE;
+	}
+
+	num_in_message_queues = clamp_t(unsigned int, num_streams, 1,
+					max_streams);
+	isys_fw_cfg = devm_kzalloc(&isys->adev->dev, sizeof(*isys_fw_cfg),
+				   GFP_KERNEL);
+	if (!isys_fw_cfg)
+		return -ENOMEM;
+
+	isys_fw_cfg->num_send_queues[IPU_FW_ISYS_QUEUE_TYPE_PROXY] =
+		IPU_N_MAX_PROXY_SEND_QUEUES;
+	isys_fw_cfg->num_send_queues[IPU_FW_ISYS_QUEUE_TYPE_DEV] =
+		IPU_N_MAX_DEV_SEND_QUEUES;
+	isys_fw_cfg->num_send_queues[IPU_FW_ISYS_QUEUE_TYPE_MSG] =
+		num_in_message_queues;
+	isys_fw_cfg->num_recv_queues[IPU_FW_ISYS_QUEUE_TYPE_PROXY] =
+		IPU_N_MAX_PROXY_RECV_QUEUES;
+	/* Common msg/dev return queue */
+	isys_fw_cfg->num_recv_queues[IPU_FW_ISYS_QUEUE_TYPE_DEV] = 0;
+	isys_fw_cfg->num_recv_queues[IPU_FW_ISYS_QUEUE_TYPE_MSG] =
+		num_out_message_queues;
+
+	size = sizeof(*input_queue_cfg) * max_send_queues;
+	input_queue_cfg = devm_kzalloc(&isys->adev->dev, size, GFP_KERNEL);
+	if (!input_queue_cfg)
+		return -ENOMEM;
+
+	size = sizeof(*output_queue_cfg) * IPU_N_MAX_RECV_QUEUES;
+	output_queue_cfg = devm_kzalloc(&isys->adev->dev, size, GFP_KERNEL);
+	if (!output_queue_cfg)
+		return -ENOMEM;
+
+	fwcom->input = input_queue_cfg;
+	fwcom->output = output_queue_cfg;
+
+	fwcom->num_input_queues =
+		isys_fw_cfg->num_send_queues[type_proxy] +
+		isys_fw_cfg->num_send_queues[type_dev] +
+		isys_fw_cfg->num_send_queues[type_msg];
+
+	fwcom->num_output_queues =
+		isys_fw_cfg->num_recv_queues[type_proxy] +
+		isys_fw_cfg->num_recv_queues[type_dev] +
+		isys_fw_cfg->num_recv_queues[type_msg];
+
+	/* SRAM partitioning. Equal partitioning is set. */
+	for (i = 0; i < max_sram_blocks; i++) {
+		if (i < num_in_message_queues)
+			isys_fw_cfg->buffer_partition.num_gda_pages[i] =
+				(IPU_DEVICE_GDA_NR_PAGES *
+				 IPU_DEVICE_GDA_VIRT_FACTOR) /
+				num_in_message_queues;
+		else
+			isys_fw_cfg->buffer_partition.num_gda_pages[i] = 0;
+	}
+
+	/* FW assumes proxy interface at fwcom queue 0 */
+	for (i = 0; i < isys_fw_cfg->num_send_queues[type_proxy]; i++) {
+		input_queue_cfg[i].token_size =
+			sizeof(struct ipu_fw_proxy_send_queue_token);
+		input_queue_cfg[i].queue_size = IPU_ISYS_SIZE_PROXY_SEND_QUEUE;
+	}
+
+	for (i = 0; i < isys_fw_cfg->num_send_queues[type_dev]; i++) {
+		input_queue_cfg[base_dev_send + i].token_size =
+			sizeof(struct ipu_fw_send_queue_token);
+		input_queue_cfg[base_dev_send + i].queue_size = max_devq_size;
+	}
+
+	for (i = 0; i < isys_fw_cfg->num_send_queues[type_msg]; i++) {
+		input_queue_cfg[base_msg_send + i].token_size =
+			sizeof(struct ipu_fw_send_queue_token);
+		input_queue_cfg[base_msg_send + i].queue_size =
+			IPU_ISYS_SIZE_SEND_QUEUE;
+	}
+
+	for (i = 0; i < isys_fw_cfg->num_recv_queues[type_proxy]; i++) {
+		output_queue_cfg[i].token_size =
+			sizeof(struct ipu_fw_proxy_resp_queue_token);
+		output_queue_cfg[i].queue_size = IPU_ISYS_SIZE_PROXY_RECV_QUEUE;
+	}
+	/* There is no recv DEV queue */
+	for (i = 0; i < isys_fw_cfg->num_recv_queues[type_msg]; i++) {
+		output_queue_cfg[base_msg_recv + i].token_size =
+			sizeof(struct ipu_fw_resp_queue_token);
+		output_queue_cfg[base_msg_recv + i].queue_size =
+			IPU_ISYS_SIZE_RECV_QUEUE;
+	}
+
+	fwcom->dmem_addr = isys->pdata->ipdata->hw_variant.dmem_offset;
+	fwcom->specific_addr = isys_fw_cfg;
+	fwcom->specific_size = sizeof(*isys_fw_cfg);
+
+	return 0;
+}
+
+int ipu_fw_isys_init(struct ipu_isys *isys, unsigned int num_streams)
+{
+	int retry = IPU_ISYS_OPEN_RETRY;
+
+	struct ipu_fw_com_cfg fwcom = {
+		.cell_start = start_sp,
+		.cell_ready = query_sp,
+		.buttress_boot_offset = SYSCOM_BUTTRESS_FW_PARAMS_ISYS_OFFSET,
+	};
+
+	struct device *dev = &isys->adev->dev;
+	int rval;
+
+	ipu6_isys_fwcom_cfg_init(isys, &fwcom, num_streams);
+
+	isys->fwcom = ipu_fw_com_prepare(&fwcom, isys->adev, isys->pdata->base);
+	if (!isys->fwcom) {
+		dev_err(dev, "isys fw com prepare failed\n");
+		return -EIO;
+	}
+
+	rval = ipu_fw_com_open(isys->fwcom);
+	if (rval) {
+		dev_err(dev, "isys fw com open failed %d\n", rval);
+		return rval;
+	}
+
+	do {
+		usleep_range(IPU_ISYS_OPEN_TIMEOUT_US,
+			     IPU_ISYS_OPEN_TIMEOUT_US + 10);
+		rval = ipu_fw_com_ready(isys->fwcom);
+		if (!rval)
+			break;
+		retry--;
+	} while (retry > 0);
+
+	if (!retry && rval) {
+		dev_err(dev, "isys port open ready failed %d\n", rval);
+		ipu_fw_isys_close(isys);
+	}
+
+	return rval;
+}
+
+struct ipu_fw_isys_resp_info_abi *
+ipu_fw_isys_get_resp(void *context, unsigned int queue,
+		     struct ipu_fw_isys_resp_info_abi *response)
+{
+	return (struct ipu_fw_isys_resp_info_abi *)
+	    ipu_recv_get_token(context, queue);
+}
+
+void ipu_fw_isys_put_resp(void *context, unsigned int queue)
+{
+	ipu_recv_put_token(context, queue);
+}
+
+void ipu_fw_isys_set_params(struct ipu_fw_isys_stream_cfg_data_abi *stream_cfg)
+{
+	unsigned int i;
+	unsigned int idx;
+
+	for (i = 0; i < stream_cfg->nof_input_pins; i++) {
+		idx = stream_cfg->input_pins[i].dt;
+		stream_cfg->input_pins[i].bits_per_pix =
+		    extracted_bits_per_pixel_per_mipi_data_type[idx];
+		stream_cfg->input_pins[i].mapped_dt =
+		    N_IPU_FW_ISYS_MIPI_DATA_TYPE;
+		stream_cfg->input_pins[i].mipi_decompression =
+		    IPU_FW_ISYS_MIPI_COMPRESSION_TYPE_NO_COMPRESSION;
+		/*
+		 * CSI BE can be used to crop and change bayer order.
+		 * NOTE: currently it only crops first and last lines in height.
+		 */
+		if (stream_cfg->crop.top_offset & 1)
+			stream_cfg->input_pins[i].crop_first_and_last_lines = 1;
+		stream_cfg->input_pins[i].capture_mode =
+			IPU_FW_ISYS_CAPTURE_MODE_REGULAR;
+	}
+}
+
+void
+ipu_fw_isys_dump_stream_cfg(struct device *dev,
+			    struct ipu_fw_isys_stream_cfg_data_abi *stream_cfg)
+{
+	unsigned int i;
+
+	dev_dbg(dev, "---------------------------\n");
+	dev_dbg(dev, "IPU_FW_ISYS_STREAM_CFG_DATA\n");
+	dev_dbg(dev, "---------------------------\n");
+
+	dev_dbg(dev, "Source %d\n", stream_cfg->src);
+	dev_dbg(dev, "VC %d\n", stream_cfg->vc);
+	dev_dbg(dev, "Nof input pins %d\n", stream_cfg->nof_input_pins);
+	dev_dbg(dev, "Nof output pins %d\n", stream_cfg->nof_output_pins);
+
+	for (i = 0; i < stream_cfg->nof_input_pins; i++) {
+		dev_dbg(dev, "Input pin %d\n", i);
+		dev_dbg(dev, "Mipi data type 0x%0x\n",
+			stream_cfg->input_pins[i].dt);
+		dev_dbg(dev, "Mipi store mode %d\n",
+			stream_cfg->input_pins[i].mipi_store_mode);
+		dev_dbg(dev, "Bits per pixel %d\n",
+			stream_cfg->input_pins[i].bits_per_pix);
+		dev_dbg(dev, "Mapped data type 0x%0x\n",
+			stream_cfg->input_pins[i].mapped_dt);
+		dev_dbg(dev, "Input res width %d\n",
+			stream_cfg->input_pins[i].input_res.width);
+		dev_dbg(dev, "Input res height %d\n",
+			stream_cfg->input_pins[i].input_res.height);
+		dev_dbg(dev, "mipi decompression %d\n",
+			stream_cfg->input_pins[i].mipi_decompression);
+		dev_dbg(dev, "capture_mode %d\n",
+			stream_cfg->input_pins[i].capture_mode);
+	}
+
+	dev_dbg(dev, "Crop info\n");
+	dev_dbg(dev, "Crop.top_offset %d\n", stream_cfg->crop.top_offset);
+	dev_dbg(dev, "Crop.left_offset %d\n", stream_cfg->crop.left_offset);
+	dev_dbg(dev, "Crop.bottom_offset %d\n",
+		stream_cfg->crop.bottom_offset);
+	dev_dbg(dev, "Crop.right_offset %d\n", stream_cfg->crop.right_offset);
+	dev_dbg(dev, "----------------\n");
+
+	for (i = 0; i < stream_cfg->nof_output_pins; i++) {
+		dev_dbg(dev, "Output pin %d\n", i);
+		dev_dbg(dev, "Output input pin id %d\n",
+			stream_cfg->output_pins[i].input_pin_id);
+		dev_dbg(dev, "Output res width %d\n",
+			stream_cfg->output_pins[i].output_res.width);
+		dev_dbg(dev, "Output res height %d\n",
+			stream_cfg->output_pins[i].output_res.height);
+		dev_dbg(dev, "Stride %d\n", stream_cfg->output_pins[i].stride);
+		dev_dbg(dev, "Pin type %d\n", stream_cfg->output_pins[i].pt);
+		dev_dbg(dev, "Payload %d\n",
+			stream_cfg->output_pins[i].payload_buf_size);
+		dev_dbg(dev, "Ft %d\n", stream_cfg->output_pins[i].ft);
+		dev_dbg(dev, "Watermar in lines %d\n",
+			stream_cfg->output_pins[i].watermark_in_lines);
+		dev_dbg(dev, "Send irq %d\n",
+			stream_cfg->output_pins[i].send_irq);
+		dev_dbg(dev, "Reserve compression %d\n",
+			stream_cfg->output_pins[i].reserve_compression);
+		dev_dbg(dev, "snoopable %d\n",
+			stream_cfg->output_pins[i].snoopable);
+		dev_dbg(dev, "error_handling_enable %d\n",
+			stream_cfg->output_pins[i].error_handling_enable);
+		dev_dbg(dev, "sensor type %d\n",
+			stream_cfg->output_pins[i].sensor_type);
+		dev_dbg(dev, "----------------\n");
+	}
+
+	dev_dbg(dev, "Isl_use %d\n", stream_cfg->isl_use);
+	dev_dbg(dev, "stream sensor_type %d\n", stream_cfg->sensor_type);
+
+}
+
+void ipu_fw_isys_dump_frame_buff_set(struct device *dev,
+				     struct ipu_fw_isys_frame_buff_set_abi *buf,
+				     unsigned int outputs)
+{
+	unsigned int i;
+
+	dev_dbg(dev, "--------------------------\n");
+	dev_dbg(dev, "IPU_FW_ISYS_FRAME_BUFF_SET\n");
+	dev_dbg(dev, "--------------------------\n");
+
+	for (i = 0; i < outputs; i++) {
+		dev_dbg(dev, "Output pin %d\n", i);
+		dev_dbg(dev, "out_buf_id %llu\n",
+			buf->output_pins[i].out_buf_id);
+		dev_dbg(dev, "addr 0x%x\n", buf->output_pins[i].addr);
+		dev_dbg(dev, "compress %u\n", buf->output_pins[i].compress);
+
+		dev_dbg(dev, "----------------\n");
+	}
+
+	dev_dbg(dev, "send_irq_sof 0x%x\n", buf->send_irq_sof);
+	dev_dbg(dev, "send_irq_eof 0x%x\n", buf->send_irq_eof);
+	dev_dbg(dev, "send_resp_sof 0x%x\n", buf->send_resp_sof);
+	dev_dbg(dev, "send_resp_eof 0x%x\n", buf->send_resp_eof);
+	dev_dbg(dev, "send_irq_capture_ack 0x%x\n", buf->send_irq_capture_ack);
+	dev_dbg(dev, "send_irq_capture_done 0x%x\n",
+		buf->send_irq_capture_done);
+	dev_dbg(dev, "send_resp_capture_ack 0x%x\n",
+		buf->send_resp_capture_ack);
+	dev_dbg(dev, "send_resp_capture_done 0x%x\n",
+		buf->send_resp_capture_done);
+}
Index: b/drivers/media/pci/intel/ipu-fw-isys.h
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu-fw-isys.h
@@ -0,0 +1,816 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2013 - 2023 Intel Corporation */
+
+#ifndef IPU_FW_ISYS_H
+#define IPU_FW_ISYS_H
+
+#include "ipu-fw-com.h"
+
+/* Max number of Input/Output Pins */
+#define IPU_MAX_IPINS 4
+
+#define IPU_MAX_OPINS ((IPU_MAX_IPINS) + 1)
+
+#define IPU6_STREAM_ID_MAX 16
+#define IPU6_NONSECURE_STREAM_ID_MAX 16
+#define IPU6_DEV_SEND_QUEUE_SIZE (IPU6_STREAM_ID_MAX)
+#define IPU6_NOF_SRAM_BLOCKS_MAX (IPU6_STREAM_ID_MAX)
+#define IPU6_N_MAX_MSG_SEND_QUEUES (IPU6_STREAM_ID_MAX)
+#define IPU6SE_STREAM_ID_MAX 8
+#define IPU6SE_NONSECURE_STREAM_ID_MAX 4
+#define IPU6SE_DEV_SEND_QUEUE_SIZE (IPU6SE_STREAM_ID_MAX)
+#define IPU6SE_NOF_SRAM_BLOCKS_MAX (IPU6SE_STREAM_ID_MAX)
+#define IPU6SE_N_MAX_MSG_SEND_QUEUES (IPU6SE_STREAM_ID_MAX)
+
+/* Single return queue for all streams/commands type */
+#define IPU_N_MAX_MSG_RECV_QUEUES 1
+/* Single device queue for high priority commands (bypass in-order queue) */
+#define IPU_N_MAX_DEV_SEND_QUEUES 1
+/* Single dedicated send queue for proxy interface */
+#define IPU_N_MAX_PROXY_SEND_QUEUES 1
+/* Single dedicated recv queue for proxy interface */
+#define IPU_N_MAX_PROXY_RECV_QUEUES 1
+/* Send queues layout */
+#define IPU_BASE_PROXY_SEND_QUEUES 0
+#define IPU_BASE_DEV_SEND_QUEUES \
+	(IPU_BASE_PROXY_SEND_QUEUES + IPU_N_MAX_PROXY_SEND_QUEUES)
+#define IPU_BASE_MSG_SEND_QUEUES \
+	(IPU_BASE_DEV_SEND_QUEUES + IPU_N_MAX_DEV_SEND_QUEUES)
+/* Recv queues layout */
+#define IPU_BASE_PROXY_RECV_QUEUES 0
+#define IPU_BASE_MSG_RECV_QUEUES \
+	(IPU_BASE_PROXY_RECV_QUEUES + IPU_N_MAX_PROXY_RECV_QUEUES)
+#define IPU_N_MAX_RECV_QUEUES \
+	(IPU_BASE_MSG_RECV_QUEUES + IPU_N_MAX_MSG_RECV_QUEUES)
+
+#define IPU6_N_MAX_SEND_QUEUES \
+	(IPU_BASE_MSG_SEND_QUEUES + IPU6_N_MAX_MSG_SEND_QUEUES)
+#define IPU6SE_N_MAX_SEND_QUEUES \
+	(IPU_BASE_MSG_SEND_QUEUES + IPU6SE_N_MAX_MSG_SEND_QUEUES)
+
+/* Max number of supported input pins routed in ISL */
+#define IPU_MAX_IPINS_IN_ISL 2
+
+/* Max number of planes for frame formats supported by the FW */
+#define IPU_PIN_PLANES_MAX 4
+
+/**
+ * enum ipu_fw_isys_resp_type
+ */
+enum ipu_fw_isys_resp_type {
+	IPU_FW_ISYS_RESP_TYPE_STREAM_OPEN_DONE = 0,
+	IPU_FW_ISYS_RESP_TYPE_STREAM_START_ACK,
+	IPU_FW_ISYS_RESP_TYPE_STREAM_START_AND_CAPTURE_ACK,
+	IPU_FW_ISYS_RESP_TYPE_STREAM_CAPTURE_ACK,
+	IPU_FW_ISYS_RESP_TYPE_STREAM_STOP_ACK,
+	IPU_FW_ISYS_RESP_TYPE_STREAM_FLUSH_ACK,
+	IPU_FW_ISYS_RESP_TYPE_STREAM_CLOSE_ACK,
+	IPU_FW_ISYS_RESP_TYPE_PIN_DATA_READY,
+	IPU_FW_ISYS_RESP_TYPE_PIN_DATA_WATERMARK,
+	IPU_FW_ISYS_RESP_TYPE_FRAME_SOF,
+	IPU_FW_ISYS_RESP_TYPE_FRAME_EOF,
+	IPU_FW_ISYS_RESP_TYPE_STREAM_START_AND_CAPTURE_DONE,
+	IPU_FW_ISYS_RESP_TYPE_STREAM_CAPTURE_DONE,
+	IPU_FW_ISYS_RESP_TYPE_PIN_DATA_SKIPPED,
+	IPU_FW_ISYS_RESP_TYPE_STREAM_CAPTURE_SKIPPED,
+	IPU_FW_ISYS_RESP_TYPE_FRAME_SOF_DISCARDED,
+	IPU_FW_ISYS_RESP_TYPE_FRAME_EOF_DISCARDED,
+	IPU_FW_ISYS_RESP_TYPE_STATS_DATA_READY,
+	N_IPU_FW_ISYS_RESP_TYPE
+};
+
+/**
+ * enum ipu_fw_isys_send_type
+ */
+enum ipu_fw_isys_send_type {
+	IPU_FW_ISYS_SEND_TYPE_STREAM_OPEN = 0,
+	IPU_FW_ISYS_SEND_TYPE_STREAM_START,
+	IPU_FW_ISYS_SEND_TYPE_STREAM_START_AND_CAPTURE,
+	IPU_FW_ISYS_SEND_TYPE_STREAM_CAPTURE,
+	IPU_FW_ISYS_SEND_TYPE_STREAM_STOP,
+	IPU_FW_ISYS_SEND_TYPE_STREAM_FLUSH,
+	IPU_FW_ISYS_SEND_TYPE_STREAM_CLOSE,
+	N_IPU_FW_ISYS_SEND_TYPE
+};
+
+/**
+ * enum ipu_fw_isys_queue_type
+ */
+enum ipu_fw_isys_queue_type {
+	IPU_FW_ISYS_QUEUE_TYPE_PROXY = 0,
+	IPU_FW_ISYS_QUEUE_TYPE_DEV,
+	IPU_FW_ISYS_QUEUE_TYPE_MSG,
+	N_IPU_FW_ISYS_QUEUE_TYPE
+};
+
+/**
+ * enum ipu_fw_isys_stream_source: Specifies a source for a stream
+ */
+enum ipu_fw_isys_stream_source {
+	IPU_FW_ISYS_STREAM_SRC_PORT_0 = 0,
+	IPU_FW_ISYS_STREAM_SRC_PORT_1,
+	IPU_FW_ISYS_STREAM_SRC_PORT_2,
+	IPU_FW_ISYS_STREAM_SRC_PORT_3,
+	IPU_FW_ISYS_STREAM_SRC_PORT_4,
+	IPU_FW_ISYS_STREAM_SRC_PORT_5,
+	IPU_FW_ISYS_STREAM_SRC_PORT_6,
+	IPU_FW_ISYS_STREAM_SRC_PORT_7,
+	IPU_FW_ISYS_STREAM_SRC_PORT_8,
+	IPU_FW_ISYS_STREAM_SRC_PORT_9,
+	IPU_FW_ISYS_STREAM_SRC_PORT_10,
+	IPU_FW_ISYS_STREAM_SRC_PORT_11,
+	IPU_FW_ISYS_STREAM_SRC_PORT_12,
+	IPU_FW_ISYS_STREAM_SRC_PORT_13,
+	IPU_FW_ISYS_STREAM_SRC_PORT_14,
+	IPU_FW_ISYS_STREAM_SRC_PORT_15,
+	IPU_FW_ISYS_STREAM_SRC_MIPIGEN_0,
+	IPU_FW_ISYS_STREAM_SRC_MIPIGEN_1,
+	IPU_FW_ISYS_STREAM_SRC_MIPIGEN_2,
+	IPU_FW_ISYS_STREAM_SRC_MIPIGEN_3,
+	IPU_FW_ISYS_STREAM_SRC_MIPIGEN_4,
+	IPU_FW_ISYS_STREAM_SRC_MIPIGEN_5,
+	IPU_FW_ISYS_STREAM_SRC_MIPIGEN_6,
+	IPU_FW_ISYS_STREAM_SRC_MIPIGEN_7,
+	IPU_FW_ISYS_STREAM_SRC_MIPIGEN_8,
+	IPU_FW_ISYS_STREAM_SRC_MIPIGEN_9,
+	N_IPU_FW_ISYS_STREAM_SRC
+};
+
+enum ipu_fw_isys_sensor_type {
+	/* non-snoopable to PSYS */
+	IPU_FW_ISYS_VC1_SENSOR_DATA	= 0,
+	/* non-snoopable for PDAF */
+	IPU_FW_ISYS_VC1_SENSOR_PDAF,
+	/* snoopable to CPU */
+	IPU_FW_ISYS_VC0_SENSOR_METADATA,
+	/* snoopable to CPU */
+	IPU_FW_ISYS_VC0_SENSOR_DATA,
+	N_IPU_FW_ISYS_SENSOR_TYPE
+};
+
+enum ipu6se_fw_isys_sensor_info {
+	/* VC1 */
+	IPU6SE_FW_ISYS_SENSOR_DATA_1 = 1,
+	IPU6SE_FW_ISYS_SENSOR_DATA_2 = 2,
+	IPU6SE_FW_ISYS_SENSOR_DATA_3 = 3,
+	IPU6SE_FW_ISYS_SENSOR_PDAF_1 = 4,
+	IPU6SE_FW_ISYS_SENSOR_PDAF_2 = 4,
+	/* VC0 */
+	IPU6SE_FW_ISYS_SENSOR_METADATA = 5,
+	IPU6SE_FW_ISYS_SENSOR_DATA_4 = 6,
+	IPU6SE_FW_ISYS_SENSOR_DATA_5 = 7,
+	IPU6SE_FW_ISYS_SENSOR_DATA_6 = 8,
+	IPU6SE_FW_ISYS_SENSOR_DATA_7 = 9,
+	IPU6SE_FW_ISYS_SENSOR_DATA_8 = 10,
+	IPU6SE_FW_ISYS_SENSOR_DATA_9 = 11,
+	N_IPU6SE_FW_ISYS_SENSOR_INFO,
+	IPU6SE_FW_ISYS_VC1_SENSOR_DATA_START = IPU6SE_FW_ISYS_SENSOR_DATA_1,
+	IPU6SE_FW_ISYS_VC1_SENSOR_DATA_END = IPU6SE_FW_ISYS_SENSOR_DATA_3,
+	IPU6SE_FW_ISYS_VC0_SENSOR_DATA_START = IPU6SE_FW_ISYS_SENSOR_DATA_4,
+	IPU6SE_FW_ISYS_VC0_SENSOR_DATA_END = IPU6SE_FW_ISYS_SENSOR_DATA_9,
+	IPU6SE_FW_ISYS_VC1_SENSOR_PDAF_START = IPU6SE_FW_ISYS_SENSOR_PDAF_1,
+	IPU6SE_FW_ISYS_VC1_SENSOR_PDAF_END = IPU6SE_FW_ISYS_SENSOR_PDAF_2,
+};
+
+enum ipu6_fw_isys_sensor_info {
+	/* VC1 */
+	IPU6_FW_ISYS_SENSOR_DATA_1 = 1,
+	IPU6_FW_ISYS_SENSOR_DATA_2 = 2,
+	IPU6_FW_ISYS_SENSOR_DATA_3 = 3,
+	IPU6_FW_ISYS_SENSOR_DATA_4 = 4,
+	IPU6_FW_ISYS_SENSOR_DATA_5 = 5,
+	IPU6_FW_ISYS_SENSOR_DATA_6 = 6,
+	IPU6_FW_ISYS_SENSOR_DATA_7 = 7,
+	IPU6_FW_ISYS_SENSOR_DATA_8 = 8,
+	IPU6_FW_ISYS_SENSOR_DATA_9 = 9,
+	IPU6_FW_ISYS_SENSOR_DATA_10 = 10,
+	IPU6_FW_ISYS_SENSOR_PDAF_1 = 11,
+	IPU6_FW_ISYS_SENSOR_PDAF_2 = 12,
+	/* VC0 */
+	IPU6_FW_ISYS_SENSOR_METADATA = 13,
+	IPU6_FW_ISYS_SENSOR_DATA_11 = 14,
+	IPU6_FW_ISYS_SENSOR_DATA_12 = 15,
+	IPU6_FW_ISYS_SENSOR_DATA_13 = 16,
+	IPU6_FW_ISYS_SENSOR_DATA_14 = 17,
+	IPU6_FW_ISYS_SENSOR_DATA_15 = 18,
+	IPU6_FW_ISYS_SENSOR_DATA_16 = 19,
+	N_IPU6_FW_ISYS_SENSOR_INFO,
+	IPU6_FW_ISYS_VC1_SENSOR_DATA_START = IPU6_FW_ISYS_SENSOR_DATA_1,
+	IPU6_FW_ISYS_VC1_SENSOR_DATA_END = IPU6_FW_ISYS_SENSOR_DATA_10,
+	IPU6_FW_ISYS_VC0_SENSOR_DATA_START = IPU6_FW_ISYS_SENSOR_DATA_11,
+	IPU6_FW_ISYS_VC0_SENSOR_DATA_END = IPU6_FW_ISYS_SENSOR_DATA_16,
+	IPU6_FW_ISYS_VC1_SENSOR_PDAF_START = IPU6_FW_ISYS_SENSOR_PDAF_1,
+	IPU6_FW_ISYS_VC1_SENSOR_PDAF_END = IPU6_FW_ISYS_SENSOR_PDAF_2,
+};
+
+#define IPU_FW_ISYS_STREAM_SRC_CSI2_PORT0 IPU_FW_ISYS_STREAM_SRC_PORT_0
+#define IPU_FW_ISYS_STREAM_SRC_CSI2_PORT1 IPU_FW_ISYS_STREAM_SRC_PORT_1
+#define IPU_FW_ISYS_STREAM_SRC_CSI2_PORT2 IPU_FW_ISYS_STREAM_SRC_PORT_2
+#define IPU_FW_ISYS_STREAM_SRC_CSI2_PORT3 IPU_FW_ISYS_STREAM_SRC_PORT_3
+
+#define IPU_FW_ISYS_STREAM_SRC_CSI2_3PH_PORTA IPU_FW_ISYS_STREAM_SRC_PORT_4
+#define IPU_FW_ISYS_STREAM_SRC_CSI2_3PH_PORTB IPU_FW_ISYS_STREAM_SRC_PORT_5
+#define IPU_FW_ISYS_STREAM_SRC_CSI2_3PH_CPHY_PORT0 IPU_FW_ISYS_STREAM_SRC_PORT_6
+#define IPU_FW_ISYS_STREAM_SRC_CSI2_3PH_CPHY_PORT1 IPU_FW_ISYS_STREAM_SRC_PORT_7
+#define IPU_FW_ISYS_STREAM_SRC_CSI2_3PH_CPHY_PORT2 IPU_FW_ISYS_STREAM_SRC_PORT_8
+#define IPU_FW_ISYS_STREAM_SRC_CSI2_3PH_CPHY_PORT3 IPU_FW_ISYS_STREAM_SRC_PORT_9
+
+#define IPU_FW_ISYS_STREAM_SRC_MIPIGEN_PORT0 IPU_FW_ISYS_STREAM_SRC_MIPIGEN_0
+#define IPU_FW_ISYS_STREAM_SRC_MIPIGEN_PORT1 IPU_FW_ISYS_STREAM_SRC_MIPIGEN_1
+
+/**
+ * enum ipu_fw_isys_mipi_vc: MIPI csi2 spec
+ * supports up to 4 virtual per physical channel
+ */
+enum ipu_fw_isys_mipi_vc {
+	IPU_FW_ISYS_MIPI_VC_0 = 0,
+	IPU_FW_ISYS_MIPI_VC_1,
+	IPU_FW_ISYS_MIPI_VC_2,
+	IPU_FW_ISYS_MIPI_VC_3,
+	N_IPU_FW_ISYS_MIPI_VC
+};
+
+/**
+ *  Supported Pixel Frame formats. Expandable if needed
+ */
+enum ipu_fw_isys_frame_format_type {
+	IPU_FW_ISYS_FRAME_FORMAT_NV11 = 0, /* 12 bit YUV 411, Y, UV plane */
+	IPU_FW_ISYS_FRAME_FORMAT_NV12,	/* 12 bit YUV 420, Y, UV plane */
+	IPU_FW_ISYS_FRAME_FORMAT_NV12_16, /* 16 bit YUV 420, Y, UV plane */
+	IPU_FW_ISYS_FRAME_FORMAT_NV12_TILEY, /* 12 bit YUV 420,
+					      * Intel proprietary tiled format,
+					      * TileY
+					      */
+	IPU_FW_ISYS_FRAME_FORMAT_NV16,	/* 16 bit YUV 422, Y, UV plane */
+	IPU_FW_ISYS_FRAME_FORMAT_NV21,	/* 12 bit YUV 420, Y, VU plane */
+	IPU_FW_ISYS_FRAME_FORMAT_NV61,	/* 16 bit YUV 422, Y, VU plane */
+	IPU_FW_ISYS_FRAME_FORMAT_YV12,	/* 12 bit YUV 420, Y, V, U plane */
+	IPU_FW_ISYS_FRAME_FORMAT_YV16,	/* 16 bit YUV 422, Y, V, U plane */
+	IPU_FW_ISYS_FRAME_FORMAT_YUV420, /* 12 bit YUV 420, Y, U, V plane */
+	IPU_FW_ISYS_FRAME_FORMAT_YUV420_10, /* yuv420, 10 bits per subpixel */
+	IPU_FW_ISYS_FRAME_FORMAT_YUV420_12, /* yuv420, 12 bits per subpixel */
+	IPU_FW_ISYS_FRAME_FORMAT_YUV420_14, /* yuv420, 14 bits per subpixel */
+	IPU_FW_ISYS_FRAME_FORMAT_YUV420_16, /* yuv420, 16 bits per subpixel */
+	IPU_FW_ISYS_FRAME_FORMAT_YUV422, /* 16 bit YUV 422, Y, U, V plane */
+	IPU_FW_ISYS_FRAME_FORMAT_YUV422_16, /* yuv422, 16 bits per subpixel */
+	IPU_FW_ISYS_FRAME_FORMAT_UYVY,	/* 16 bit YUV 422, UYVY interleaved */
+	IPU_FW_ISYS_FRAME_FORMAT_YUYV,	/* 16 bit YUV 422, YUYV interleaved */
+	IPU_FW_ISYS_FRAME_FORMAT_YUV444, /* 24 bit YUV 444, Y, U, V plane */
+	IPU_FW_ISYS_FRAME_FORMAT_YUV_LINE, /* Internal format, 2 y lines
+					    * followed by a uvinterleaved line
+					    */
+	IPU_FW_ISYS_FRAME_FORMAT_RAW8,	/* RAW8, 1 plane */
+	IPU_FW_ISYS_FRAME_FORMAT_RAW10,	/* RAW10, 1 plane */
+	IPU_FW_ISYS_FRAME_FORMAT_RAW12,	/* RAW12, 1 plane */
+	IPU_FW_ISYS_FRAME_FORMAT_RAW14,	/* RAW14, 1 plane */
+	IPU_FW_ISYS_FRAME_FORMAT_RAW16,	/* RAW16, 1 plane */
+	IPU_FW_ISYS_FRAME_FORMAT_RGB565, /* 16 bit RGB, 1 plane. Each 3 sub
+					  * pixels are packed into one 16 bit
+					  * value, 5 bits for R, 6 bits
+					  *   for G and 5 bits for B.
+					  */
+
+	IPU_FW_ISYS_FRAME_FORMAT_PLANAR_RGB888,	/* 24 bit RGB, 3 planes */
+	IPU_FW_ISYS_FRAME_FORMAT_RGBA888,	/* 32 bit RGBA, 1 plane,
+						 * A=Alpha (alpha is unused)
+						 */
+	IPU_FW_ISYS_FRAME_FORMAT_QPLANE6,	/* Internal, for advanced ISP */
+	IPU_FW_ISYS_FRAME_FORMAT_BINARY_8, /* byte stream, used for jpeg. */
+	N_IPU_FW_ISYS_FRAME_FORMAT
+};
+
+/* Temporary for driver compatibility */
+#define IPU_FW_ISYS_FRAME_FORMAT_RAW		(IPU_FW_ISYS_FRAME_FORMAT_RAW16)
+
+enum ipu_fw_isys_mipi_compression_type {
+	IPU_FW_ISYS_MIPI_COMPRESSION_TYPE_NO_COMPRESSION = 0,
+	IPU_FW_ISYS_MIPI_COMPRESSION_TYPE_10_8_10_TYPE1,
+	IPU_FW_ISYS_MIPI_COMPRESSION_TYPE_10_8_10_TYPE2,
+	IPU_FW_ISYS_MIPI_COMPRESSION_TYPE_10_7_10_TYPE1,
+	IPU_FW_ISYS_MIPI_COMPRESSION_TYPE_10_7_10_TYPE2,
+	IPU_FW_ISYS_MIPI_COMPRESSION_TYPE_10_6_10_TYPE1,
+	IPU_FW_ISYS_MIPI_COMPRESSION_TYPE_10_6_10_TYPE2,
+	IPU_FW_ISYS_MIPI_COMPRESSION_TYPE_12_8_12_TYPE1,
+	IPU_FW_ISYS_MIPI_COMPRESSION_TYPE_12_8_12_TYPE2,
+	IPU_FW_ISYS_MIPI_COMPRESSION_TYPE_12_7_12_TYPE1,
+	IPU_FW_ISYS_MIPI_COMPRESSION_TYPE_12_7_12_TYPE2,
+	IPU_FW_ISYS_MIPI_COMPRESSION_TYPE_12_6_12_TYPE1,
+	IPU_FW_ISYS_MIPI_COMPRESSION_TYPE_12_6_12_TYPE2,
+	IPU_FW_ISYS_MIPI_COMPRESSION_TYPE_12_10_12_TYPE1,
+	IPU_FW_ISYS_MIPI_COMPRESSION_TYPE_12_10_12_TYPE2,
+	N_IPU_FW_ISYS_MIPI_COMPRESSION_TYPE,
+};
+
+/**
+ *  Supported MIPI data type. Keep in sync array in ipu_fw_isys_private.c
+ */
+enum ipu_fw_isys_mipi_data_type {
+	/** SYNCHRONIZATION SHORT PACKET DATA TYPES */
+	IPU_FW_ISYS_MIPI_DATA_TYPE_FRAME_START_CODE = 0x00,
+	IPU_FW_ISYS_MIPI_DATA_TYPE_FRAME_END_CODE = 0x01,
+	IPU_FW_ISYS_MIPI_DATA_TYPE_LINE_START_CODE = 0x02,	/* Optional */
+	IPU_FW_ISYS_MIPI_DATA_TYPE_LINE_END_CODE = 0x03,	/* Optional */
+	/** Reserved 0x04-0x07 */
+	IPU_FW_ISYS_MIPI_DATA_TYPE_RESERVED_0x04 = 0x04,
+	IPU_FW_ISYS_MIPI_DATA_TYPE_RESERVED_0x05 = 0x05,
+	IPU_FW_ISYS_MIPI_DATA_TYPE_RESERVED_0x06 = 0x06,
+	IPU_FW_ISYS_MIPI_DATA_TYPE_RESERVED_0x07 = 0x07,
+	/** GENERIC SHORT PACKET DATA TYPES */
+	/** They are used to keep the timing information for
+	 * the opening/closing of shutters,
+	 *  triggering of flashes and etc.
+	 */
+	/* Generic Short Packet Codes 1 - 8 */
+	IPU_FW_ISYS_MIPI_DATA_TYPE_GENERIC_SHORT1 = 0x08,
+	IPU_FW_ISYS_MIPI_DATA_TYPE_GENERIC_SHORT2 = 0x09,
+	IPU_FW_ISYS_MIPI_DATA_TYPE_GENERIC_SHORT3 = 0x0A,
+	IPU_FW_ISYS_MIPI_DATA_TYPE_GENERIC_SHORT4 = 0x0B,
+	IPU_FW_ISYS_MIPI_DATA_TYPE_GENERIC_SHORT5 = 0x0C,
+	IPU_FW_ISYS_MIPI_DATA_TYPE_GENERIC_SHORT6 = 0x0D,
+	IPU_FW_ISYS_MIPI_DATA_TYPE_GENERIC_SHORT7 = 0x0E,
+	IPU_FW_ISYS_MIPI_DATA_TYPE_GENERIC_SHORT8 = 0x0F,
+	/** GENERIC LONG PACKET DATA TYPES */
+	IPU_FW_ISYS_MIPI_DATA_TYPE_NULL = 0x10,
+	IPU_FW_ISYS_MIPI_DATA_TYPE_BLANKING_DATA = 0x11,
+	/* Embedded 8-bit non Image Data */
+	IPU_FW_ISYS_MIPI_DATA_TYPE_EMBEDDED = 0x12,
+	/** Reserved 0x13-0x17 */
+	IPU_FW_ISYS_MIPI_DATA_TYPE_RESERVED_0x13 = 0x13,
+	IPU_FW_ISYS_MIPI_DATA_TYPE_RESERVED_0x14 = 0x14,
+	IPU_FW_ISYS_MIPI_DATA_TYPE_RESERVED_0x15 = 0x15,
+	IPU_FW_ISYS_MIPI_DATA_TYPE_RESERVED_0x16 = 0x16,
+	IPU_FW_ISYS_MIPI_DATA_TYPE_RESERVED_0x17 = 0x17,
+	/** YUV DATA TYPES */
+	/* 8 bits per subpixel */
+	IPU_FW_ISYS_MIPI_DATA_TYPE_YUV420_8 = 0x18,
+	/* 10 bits per subpixel */
+	IPU_FW_ISYS_MIPI_DATA_TYPE_YUV420_10 = 0x19,
+	/* 8 bits per subpixel */
+	IPU_FW_ISYS_MIPI_DATA_TYPE_YUV420_8_LEGACY = 0x1A,
+	/** Reserved 0x1B */
+	IPU_FW_ISYS_MIPI_DATA_TYPE_RESERVED_0x1B = 0x1B,
+	/* YUV420 8-bit Chroma Shifted Pixel Sampling) */
+	IPU_FW_ISYS_MIPI_DATA_TYPE_YUV420_8_SHIFT = 0x1C,
+	/* YUV420 8-bit (Chroma Shifted Pixel Sampling) */
+	IPU_FW_ISYS_MIPI_DATA_TYPE_YUV420_10_SHIFT = 0x1D,
+	/* UYVY..UVYV, 8 bits per subpixel */
+	IPU_FW_ISYS_MIPI_DATA_TYPE_YUV422_8 = 0x1E,
+	/* UYVY..UVYV, 10 bits per subpixel */
+	IPU_FW_ISYS_MIPI_DATA_TYPE_YUV422_10 = 0x1F,
+	/** RGB DATA TYPES */
+	/* BGR..BGR, 4 bits per subpixel */
+	IPU_FW_ISYS_MIPI_DATA_TYPE_RGB_444 = 0x20,
+	/* BGR..BGR, 5 bits per subpixel */
+	IPU_FW_ISYS_MIPI_DATA_TYPE_RGB_555 = 0x21,
+	/* BGR..BGR, 5 bits B and R, 6 bits G */
+	IPU_FW_ISYS_MIPI_DATA_TYPE_RGB_565 = 0x22,
+	/* BGR..BGR, 6 bits per subpixel */
+	IPU_FW_ISYS_MIPI_DATA_TYPE_RGB_666 = 0x23,
+	/* BGR..BGR, 8 bits per subpixel */
+	IPU_FW_ISYS_MIPI_DATA_TYPE_RGB_888 = 0x24,
+	/** Reserved 0x25-0x27 */
+	IPU_FW_ISYS_MIPI_DATA_TYPE_RESERVED_0x25 = 0x25,
+	IPU_FW_ISYS_MIPI_DATA_TYPE_RESERVED_0x26 = 0x26,
+	IPU_FW_ISYS_MIPI_DATA_TYPE_RESERVED_0x27 = 0x27,
+	/** RAW DATA TYPES */
+	/* RAW data, 6 - 14 bits per pixel */
+	IPU_FW_ISYS_MIPI_DATA_TYPE_RAW_6 = 0x28,
+	IPU_FW_ISYS_MIPI_DATA_TYPE_RAW_7 = 0x29,
+	IPU_FW_ISYS_MIPI_DATA_TYPE_RAW_8 = 0x2A,
+	IPU_FW_ISYS_MIPI_DATA_TYPE_RAW_10 = 0x2B,
+	IPU_FW_ISYS_MIPI_DATA_TYPE_RAW_12 = 0x2C,
+	IPU_FW_ISYS_MIPI_DATA_TYPE_RAW_14 = 0x2D,
+	/** Reserved 0x2E-2F are used with assigned meaning */
+	/* RAW data, 16 bits per pixel, not specified in CSI-MIPI standard */
+	IPU_FW_ISYS_MIPI_DATA_TYPE_RAW_16 = 0x2E,
+	/* Binary byte stream, which is target at JPEG,
+	 * not specified in CSI-MIPI standard
+	 */
+	IPU_FW_ISYS_MIPI_DATA_TYPE_BINARY_8 = 0x2F,
+
+	/** USER DEFINED 8-BIT DATA TYPES */
+	/** For example, the data transmitter (e.g. the SoC sensor)
+	 * can keep the JPEG data as
+	 *  the User Defined Data Type 4 and the MPEG data as the
+	 *  User Defined Data Type 7.
+	 */
+	IPU_FW_ISYS_MIPI_DATA_TYPE_USER_DEF1 = 0x30,
+	IPU_FW_ISYS_MIPI_DATA_TYPE_USER_DEF2 = 0x31,
+	IPU_FW_ISYS_MIPI_DATA_TYPE_USER_DEF3 = 0x32,
+	IPU_FW_ISYS_MIPI_DATA_TYPE_USER_DEF4 = 0x33,
+	IPU_FW_ISYS_MIPI_DATA_TYPE_USER_DEF5 = 0x34,
+	IPU_FW_ISYS_MIPI_DATA_TYPE_USER_DEF6 = 0x35,
+	IPU_FW_ISYS_MIPI_DATA_TYPE_USER_DEF7 = 0x36,
+	IPU_FW_ISYS_MIPI_DATA_TYPE_USER_DEF8 = 0x37,
+	/** Reserved 0x38-0x3F */
+	IPU_FW_ISYS_MIPI_DATA_TYPE_RESERVED_0x38 = 0x38,
+	IPU_FW_ISYS_MIPI_DATA_TYPE_RESERVED_0x39 = 0x39,
+	IPU_FW_ISYS_MIPI_DATA_TYPE_RESERVED_0x3A = 0x3A,
+	IPU_FW_ISYS_MIPI_DATA_TYPE_RESERVED_0x3B = 0x3B,
+	IPU_FW_ISYS_MIPI_DATA_TYPE_RESERVED_0x3C = 0x3C,
+	IPU_FW_ISYS_MIPI_DATA_TYPE_RESERVED_0x3D = 0x3D,
+	IPU_FW_ISYS_MIPI_DATA_TYPE_RESERVED_0x3E = 0x3E,
+	IPU_FW_ISYS_MIPI_DATA_TYPE_RESERVED_0x3F = 0x3F,
+
+	/* Keep always last and max value */
+	N_IPU_FW_ISYS_MIPI_DATA_TYPE = 0x40
+};
+
+/** enum ipu_fw_isys_pin_type: output pin buffer types.
+ * Buffers can be queued and de-queued to hand them over between IA and ISYS
+ */
+enum ipu_fw_isys_pin_type {
+	/* Captured as MIPI packets */
+	IPU_FW_ISYS_PIN_TYPE_MIPI = 0,
+	/* Captured through the RAW path */
+	IPU_FW_ISYS_PIN_TYPE_RAW_NS = 1,
+	/* Captured through the SoC path */
+	IPU_FW_ISYS_PIN_TYPE_RAW_SOC = 3,
+	/* Reserved for future use, maybe short packets */
+	IPU_FW_ISYS_PIN_TYPE_METADATA_0 = 4,
+	/* Reserved for future use */
+	IPU_FW_ISYS_PIN_TYPE_METADATA_1 = 5,
+	/* Keep always last and max value */
+	N_IPU_FW_ISYS_PIN_TYPE
+};
+
+/**
+ * enum ipu_fw_isys_mipi_store_mode. Describes if long MIPI packets reach
+ * MIPI SRAM with the long packet header or
+ * if not, then only option is to capture it with pin type MIPI.
+ */
+enum ipu_fw_isys_mipi_store_mode {
+	IPU_FW_ISYS_MIPI_STORE_MODE_NORMAL = 0,
+	IPU_FW_ISYS_MIPI_STORE_MODE_DISCARD_LONG_HEADER,
+	N_IPU_FW_ISYS_MIPI_STORE_MODE
+};
+
+/**
+ * ISYS capture mode and sensor enums
+ * Used for Tobii sensor, if doubt, use default value 0
+ */
+
+enum ipu_fw_isys_capture_mode {
+	IPU_FW_ISYS_CAPTURE_MODE_REGULAR = 0,
+	IPU_FW_ISYS_CAPTURE_MODE_BURST,
+	N_IPU_FW_ISYS_CAPTURE_MODE,
+};
+
+enum ipu_fw_isys_sensor_mode {
+	IPU_FW_ISYS_SENSOR_MODE_NORMAL = 0,
+	IPU_FW_ISYS_SENSOR_MODE_TOBII,
+	N_IPU_FW_ISYS_SENSOR_MODE,
+};
+
+/**
+ * enum ipu_fw_isys_error. Describes the error type detected by the FW
+ */
+enum ipu_fw_isys_error {
+	IPU_FW_ISYS_ERROR_NONE = 0,	/* No details */
+	IPU_FW_ISYS_ERROR_FW_INTERNAL_CONSISTENCY,	/* enum */
+	IPU_FW_ISYS_ERROR_HW_CONSISTENCY,	/* enum */
+	IPU_FW_ISYS_ERROR_DRIVER_INVALID_COMMAND_SEQUENCE,	/* enum */
+	IPU_FW_ISYS_ERROR_DRIVER_INVALID_DEVICE_CONFIGURATION,	/* enum */
+	IPU_FW_ISYS_ERROR_DRIVER_INVALID_STREAM_CONFIGURATION,	/* enum */
+	IPU_FW_ISYS_ERROR_DRIVER_INVALID_FRAME_CONFIGURATION,	/* enum */
+	IPU_FW_ISYS_ERROR_INSUFFICIENT_RESOURCES,	/* enum */
+	IPU_FW_ISYS_ERROR_HW_REPORTED_STR2MMIO,	/* HW code */
+	IPU_FW_ISYS_ERROR_HW_REPORTED_SIG2CIO,	/* HW code */
+	IPU_FW_ISYS_ERROR_SENSOR_FW_SYNC,	/* enum */
+	IPU_FW_ISYS_ERROR_STREAM_IN_SUSPENSION,	/* FW code */
+	IPU_FW_ISYS_ERROR_RESPONSE_QUEUE_FULL,	/* FW code */
+	N_IPU_FW_ISYS_ERROR
+};
+
+/**
+ * enum ipu_fw_proxy_error. Describes the error type for
+ * the proxy detected by the FW
+ */
+enum ipu_fw_proxy_error {
+	IPU_FW_PROXY_ERROR_NONE = 0,
+	IPU_FW_PROXY_ERROR_INVALID_WRITE_REGION,
+	IPU_FW_PROXY_ERROR_INVALID_WRITE_OFFSET,
+	N_IPU_FW_PROXY_ERROR
+};
+
+struct ipu_isys;
+
+struct ipu6_fw_isys_buffer_partition_abi {
+	u32 num_gda_pages[IPU6_STREAM_ID_MAX];
+};
+
+struct ipu6_fw_isys_fw_config {
+	struct ipu6_fw_isys_buffer_partition_abi buffer_partition;
+	u32 num_send_queues[N_IPU_FW_ISYS_QUEUE_TYPE];
+	u32 num_recv_queues[N_IPU_FW_ISYS_QUEUE_TYPE];
+};
+
+/**
+ * struct ipu_fw_isys_resolution_abi: Generic resolution structure.
+ * @Width
+ * @Height
+ */
+struct ipu_fw_isys_resolution_abi {
+	u32 width;
+	u32 height;
+};
+
+/**
+ * struct ipu_fw_isys_output_pin_payload_abi
+ * @out_buf_id: Points to output pin buffer - buffer identifier
+ * @addr: Points to output pin buffer - CSS Virtual Address
+ * @compress: Request frame compression (1), or  not (0)
+ */
+struct ipu_fw_isys_output_pin_payload_abi {
+	u64 out_buf_id;
+	u32 addr;
+	u32 compress;
+};
+
+/**
+ * struct ipu_fw_isys_output_pin_info_abi
+ * @output_res: output pin resolution
+ * @stride: output stride in Bytes (not valid for statistics)
+ * @watermark_in_lines: pin watermark level in lines
+ * @payload_buf_size: minimum size in Bytes of all buffers that will be
+ *			supplied for capture on this pin
+ * @send_irq: assert if pin event should trigger irq
+ * @pt: pin type -real format "enum ipu_fw_isys_pin_type"
+ * @ft: frame format type -real format "enum ipu_fw_isys_frame_format_type"
+ * @input_pin_id: related input pin id
+ * @reserve_compression: reserve compression resources for pin
+ */
+struct ipu_fw_isys_output_pin_info_abi {
+	struct ipu_fw_isys_resolution_abi output_res;
+	u32 stride;
+	u32 watermark_in_lines;
+	u32 payload_buf_size;
+	u32 ts_offsets[IPU_PIN_PLANES_MAX];
+	u32 s2m_pixel_soc_pixel_remapping;
+	u32 csi_be_soc_pixel_remapping;
+	u8 send_irq;
+	u8 input_pin_id;
+	u8 pt;
+	u8 ft;
+	u8 reserved;
+	u8 reserve_compression;
+	u8 snoopable;
+	u8 error_handling_enable;
+	u32 sensor_type;
+};
+
+/**
+ * struct ipu_fw_isys_param_pin_abi
+ * @param_buf_id: Points to param port buffer - buffer identifier
+ * @addr: Points to param pin buffer - CSS Virtual Address
+ */
+struct ipu_fw_isys_param_pin_abi {
+	u64 param_buf_id;
+	u32 addr;
+};
+
+/**
+ * struct ipu_fw_isys_input_pin_info_abi
+ * @input_res: input resolution
+ * @dt: mipi data type ((enum ipu_fw_isys_mipi_data_type)
+ * @mipi_store_mode: defines if legacy long packet header will be stored or
+ *		     discarded if discarded, output pin type for this
+ *		     input pin can only be MIPI
+ *		     (enum ipu_fw_isys_mipi_store_mode)
+ * @bits_per_pix: native bits per pixel
+ * @mapped_dt: actual data type from sensor
+ * @mipi_decompression: defines which compression will be in mipi backend
+
+ * @crop_first_and_last_lines    Control whether to crop the
+ *                              first and last line of the
+ *                              input image. Crop done by HW
+ *                              device.
+ * @capture_mode: mode of capture, regular or burst, default value is regular
+ */
+struct ipu_fw_isys_input_pin_info_abi {
+	struct ipu_fw_isys_resolution_abi input_res;
+	u8 dt;
+	u8 mipi_store_mode;
+	u8 bits_per_pix;
+	u8 mapped_dt;
+	u8 mipi_decompression;
+	u8 crop_first_and_last_lines;
+	u8 capture_mode;
+};
+
+/**
+ * struct ipu_fw_isys_cropping_abi - cropping coordinates
+ */
+struct ipu_fw_isys_cropping_abi {
+	s32 top_offset;
+	s32 left_offset;
+	s32 bottom_offset;
+	s32 right_offset;
+};
+
+/**
+ * struct ipu_fw_isys_stream_cfg_data_abi
+ * ISYS stream configuration data structure
+ * @crop: defines cropping resolution for the
+ * maximum number of input pins which can be cropped,
+ * it is directly mapped to the HW devices
+ * @input_pins: input pin descriptors
+ * @output_pins: output pin descriptors
+ * @compfmt: de-compression setting for User Defined Data
+ * @nof_input_pins: number of input pins
+ * @nof_output_pins: number of output pins
+ * @send_irq_sof_discarded: send irq on discarded frame sof response
+ *		- if '1' it will override the send_resp_sof_discarded
+ *		  and send the response
+ *		- if '0' the send_resp_sof_discarded will determine
+ *		  whether to send the response
+ * @send_irq_eof_discarded: send irq on discarded frame eof response
+ *		- if '1' it will override the send_resp_eof_discarded
+ *		  and send the response
+ *		- if '0' the send_resp_eof_discarded will determine
+ *		  whether to send the response
+ * @send_resp_sof_discarded: send response for discarded frame sof detected,
+ *			     used only when send_irq_sof_discarded is '0'
+ * @send_resp_eof_discarded: send response for discarded frame eof detected,
+ *			     used only when send_irq_eof_discarded is '0'
+ * @src: Stream source index e.g. MIPI_generator_0, CSI2-rx_1
+ * @vc: MIPI Virtual Channel (up to 4 virtual per physical channel)
+ * @isl_use: indicates whether stream requires ISL and how
+ * @sensor_type: type of connected sensor, tobii or others, default is 0
+ */
+struct ipu_fw_isys_stream_cfg_data_abi {
+	struct ipu_fw_isys_cropping_abi crop;
+	struct ipu_fw_isys_input_pin_info_abi input_pins[IPU_MAX_IPINS];
+	struct ipu_fw_isys_output_pin_info_abi output_pins[IPU_MAX_OPINS];
+	u32 compfmt;
+	u8 nof_input_pins;
+	u8 nof_output_pins;
+	u8 send_irq_sof_discarded;
+	u8 send_irq_eof_discarded;
+	u8 send_resp_sof_discarded;
+	u8 send_resp_eof_discarded;
+	u8 src;
+	u8 vc;
+	u8 isl_use;
+	u8 sensor_type;
+};
+
+/**
+ * struct ipu_fw_isys_frame_buff_set - frame buffer set
+ * @output_pins: output pin addresses
+ * @send_irq_sof: send irq on frame sof response
+ *		- if '1' it will override the send_resp_sof and
+ *		  send the response
+ *		- if '0' the send_resp_sof will determine whether to
+ *		  send the response
+ * @send_irq_eof: send irq on frame eof response
+ *		- if '1' it will override the send_resp_eof and
+ *		  send the response
+ *		- if '0' the send_resp_eof will determine whether to
+ *		  send the response
+ * @send_resp_sof: send response for frame sof detected,
+ *		   used only when send_irq_sof is '0'
+ * @send_resp_eof: send response for frame eof detected,
+ *		   used only when send_irq_eof is '0'
+ * @send_resp_capture_ack: send response for capture ack event
+ * @send_resp_capture_done: send response for capture done event
+ */
+struct ipu_fw_isys_frame_buff_set_abi {
+	struct ipu_fw_isys_output_pin_payload_abi output_pins[IPU_MAX_OPINS];
+	u8 send_irq_sof;
+	u8 send_irq_eof;
+	u8 send_irq_capture_ack;
+	u8 send_irq_capture_done;
+	u8 send_resp_sof;
+	u8 send_resp_eof;
+	u8 send_resp_capture_ack;
+	u8 send_resp_capture_done;
+	u8 reserved;
+};
+
+/**
+ * struct ipu_fw_isys_error_info_abi
+ * @error: error code if something went wrong
+ * @error_details: depending on error code, it may contain additional error info
+ */
+struct ipu_fw_isys_error_info_abi {
+	enum ipu_fw_isys_error error;
+	u32 error_details;
+};
+
+/**
+ * struct ipu_fw_isys_resp_info_comm
+ * @pin: this var is only valid for pin event related responses,
+ *     contains pin addresses
+ * @error_info: error information from the FW
+ * @timestamp: Time information for event if available
+ * @stream_handle: stream id the response corresponds to
+ * @type: response type (enum ipu_fw_isys_resp_type)
+ * @pin_id: pin id that the pin payload corresponds to
+ */
+struct ipu_fw_isys_resp_info_abi {
+	u64 buf_id;
+	struct ipu_fw_isys_output_pin_payload_abi pin;
+	struct ipu_fw_isys_error_info_abi error_info;
+	u32 timestamp[2];
+	u8 stream_handle;
+	u8 type;
+	u8 pin_id;
+	u16 reserved;
+};
+
+/**
+ * struct ipu_fw_isys_proxy_error_info_comm
+ * @proxy_error: error code if something went wrong
+ * @proxy_error_details: depending on error code, it may contain additional
+ *			error info
+ */
+struct ipu_fw_isys_proxy_error_info_abi {
+	enum ipu_fw_proxy_error error;
+	u32 error_details;
+};
+
+struct ipu_fw_isys_proxy_resp_info_abi {
+	u32 request_id;
+	struct ipu_fw_isys_proxy_error_info_abi error_info;
+};
+
+/**
+ * struct ipu_fw_proxy_write_queue_token
+ * @request_id: update id for the specific proxy write request
+ * @region_index: Region id for the proxy write request
+ * @offset: Offset of the write request according to the base address
+ *	    of the region
+ * @value: Value that is requested to be written with the proxy write request
+ */
+struct ipu_fw_proxy_write_queue_token {
+	u32 request_id;
+	u32 region_index;
+	u32 offset;
+	u32 value;
+};
+
+/* From here on type defines not coming from the ISYSAPI interface */
+
+/**
+ * struct ipu_fw_resp_queue_token
+ */
+struct ipu_fw_resp_queue_token {
+	struct ipu_fw_isys_resp_info_abi resp_info;
+};
+
+/**
+ * struct ipu_fw_send_queue_token
+ */
+struct ipu_fw_send_queue_token {
+	u64 buf_handle;
+	u32 payload;
+	u16 send_type;
+	u16 stream_id;
+};
+
+/**
+ * struct ipu_fw_proxy_resp_queue_token
+ */
+struct ipu_fw_proxy_resp_queue_token {
+	struct ipu_fw_isys_proxy_resp_info_abi proxy_resp_info;
+};
+
+/**
+ * struct ipu_fw_proxy_send_queue_token
+ */
+struct ipu_fw_proxy_send_queue_token {
+	u32 request_id;
+	u32 region_index;
+	u32 offset;
+	u32 value;
+};
+
+void ipu_fw_isys_set_params(struct ipu_fw_isys_stream_cfg_data_abi *stream_cfg);
+
+void ipu_fw_isys_dump_stream_cfg(struct device *dev,
+				 struct ipu_fw_isys_stream_cfg_data_abi
+				 *stream_cfg);
+void ipu_fw_isys_dump_frame_buff_set(struct device *dev,
+				     struct ipu_fw_isys_frame_buff_set_abi *buf,
+				     unsigned int outputs);
+int ipu_fw_isys_init(struct ipu_isys *isys, unsigned int num_streams);
+int ipu_fw_isys_close(struct ipu_isys *isys);
+int ipu_fw_isys_simple_cmd(struct ipu_isys *isys,
+			   const unsigned int stream_handle,
+			   enum ipu_fw_isys_send_type send_type);
+int ipu_fw_isys_complex_cmd(struct ipu_isys *isys,
+			    const unsigned int stream_handle,
+			    void *cpu_mapped_buf,
+			    dma_addr_t dma_mapped_buf,
+			    size_t size, enum ipu_fw_isys_send_type send_type);
+int ipu_fw_isys_send_proxy_token(struct ipu_isys *isys,
+				 unsigned int req_id,
+				 unsigned int index,
+				 unsigned int offset, u32 value);
+void ipu_fw_isys_cleanup(struct ipu_isys *isys);
+struct ipu_fw_isys_resp_info_abi *
+ipu_fw_isys_get_resp(void *context, unsigned int queue,
+		     struct ipu_fw_isys_resp_info_abi *response);
+void ipu_fw_isys_put_resp(void *context, unsigned int queue);
+#endif
Index: b/drivers/media/pci/intel/ipu-fw-psys.c
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu-fw-psys.c
@@ -0,0 +1,430 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) 2016 - 2020 Intel Corporation
+
+#include <linux/delay.h>
+
+#include <uapi/linux/ipu-psys.h>
+
+#include "ipu-fw-com.h"
+#include "ipu-fw-psys.h"
+#include "ipu-psys.h"
+
+int ipu_fw_psys_pg_start(struct ipu_psys_kcmd *kcmd)
+{
+	kcmd->kpg->pg->state = IPU_FW_PSYS_PROCESS_GROUP_STARTED;
+	return 0;
+}
+
+int ipu_fw_psys_pg_disown(struct ipu_psys_kcmd *kcmd)
+{
+	struct ipu_fw_psys_cmd *psys_cmd;
+	int ret = 0;
+
+	psys_cmd = ipu_send_get_token(kcmd->fh->psys->fwcom, 0);
+	if (!psys_cmd) {
+		dev_err(&kcmd->fh->psys->adev->dev,
+			"%s failed to get token!\n", __func__);
+		kcmd->pg_user = NULL;
+		ret = -ENODATA;
+		goto out;
+	}
+	psys_cmd->command = IPU_FW_PSYS_PROCESS_GROUP_CMD_START;
+	psys_cmd->msg = 0;
+	psys_cmd->context_handle = kcmd->kpg->pg->ipu_virtual_address;
+	ipu_send_put_token(kcmd->fh->psys->fwcom, 0);
+
+out:
+	return ret;
+}
+
+int ipu_fw_psys_ppg_suspend(struct ipu_psys_kcmd *kcmd)
+{
+	struct ipu_fw_psys_cmd *psys_cmd;
+	int ret = 0;
+
+	/* ppg suspend cmd uses QUEUE_DEVICE_ID instead of QUEUE_COMMAND_ID */
+	psys_cmd = ipu_send_get_token(kcmd->fh->psys->fwcom, 1);
+	if (!psys_cmd) {
+		dev_err(&kcmd->fh->psys->adev->dev,
+			"%s failed to get token!\n", __func__);
+		kcmd->pg_user = NULL;
+		ret = -ENODATA;
+		goto out;
+	}
+	psys_cmd->command = IPU_FW_PSYS_PROCESS_GROUP_CMD_SUSPEND;
+	psys_cmd->msg = 0;
+	psys_cmd->context_handle = kcmd->kpg->pg->ipu_virtual_address;
+	ipu_send_put_token(kcmd->fh->psys->fwcom, 1);
+
+out:
+	return ret;
+}
+
+int ipu_fw_psys_ppg_resume(struct ipu_psys_kcmd *kcmd)
+{
+	struct ipu_fw_psys_cmd *psys_cmd;
+	int ret = 0;
+
+	psys_cmd = ipu_send_get_token(kcmd->fh->psys->fwcom, 0);
+	if (!psys_cmd) {
+		dev_err(&kcmd->fh->psys->adev->dev,
+			"%s failed to get token!\n", __func__);
+		kcmd->pg_user = NULL;
+		ret = -ENODATA;
+		goto out;
+	}
+	psys_cmd->command = IPU_FW_PSYS_PROCESS_GROUP_CMD_RESUME;
+	psys_cmd->msg = 0;
+	psys_cmd->context_handle = kcmd->kpg->pg->ipu_virtual_address;
+	ipu_send_put_token(kcmd->fh->psys->fwcom, 0);
+
+out:
+	return ret;
+}
+
+int ipu_fw_psys_pg_abort(struct ipu_psys_kcmd *kcmd)
+{
+	struct ipu_fw_psys_cmd *psys_cmd;
+	int ret = 0;
+
+	psys_cmd = ipu_send_get_token(kcmd->fh->psys->fwcom, 0);
+	if (!psys_cmd) {
+		dev_err(&kcmd->fh->psys->adev->dev,
+			"%s failed to get token!\n", __func__);
+		kcmd->pg_user = NULL;
+		ret = -ENODATA;
+		goto out;
+	}
+	psys_cmd->command = IPU_FW_PSYS_PROCESS_GROUP_CMD_STOP;
+	psys_cmd->msg = 0;
+	psys_cmd->context_handle = kcmd->kpg->pg->ipu_virtual_address;
+	ipu_send_put_token(kcmd->fh->psys->fwcom, 0);
+
+out:
+	return ret;
+}
+
+int ipu_fw_psys_pg_submit(struct ipu_psys_kcmd *kcmd)
+{
+	kcmd->kpg->pg->state = IPU_FW_PSYS_PROCESS_GROUP_BLOCKED;
+	return 0;
+}
+
+int ipu_fw_psys_rcv_event(struct ipu_psys *psys,
+			  struct ipu_fw_psys_event *event)
+{
+	void *rcv;
+
+	rcv = ipu_recv_get_token(psys->fwcom, 0);
+	if (!rcv)
+		return 0;
+
+	memcpy(event, rcv, sizeof(*event));
+	ipu_recv_put_token(psys->fwcom, 0);
+	return 1;
+}
+
+int ipu_fw_psys_terminal_set(struct ipu_fw_psys_terminal *terminal,
+			     int terminal_idx,
+			     struct ipu_psys_kcmd *kcmd,
+			     u32 buffer, unsigned int size)
+{
+	u32 type;
+	u32 buffer_state;
+
+	type = terminal->terminal_type;
+
+	switch (type) {
+	case IPU_FW_PSYS_TERMINAL_TYPE_PARAM_CACHED_IN:
+	case IPU_FW_PSYS_TERMINAL_TYPE_PARAM_CACHED_OUT:
+	case IPU_FW_PSYS_TERMINAL_TYPE_PARAM_SPATIAL_IN:
+	case IPU_FW_PSYS_TERMINAL_TYPE_PARAM_SPATIAL_OUT:
+	case IPU_FW_PSYS_TERMINAL_TYPE_PARAM_SLICED_IN:
+	case IPU_FW_PSYS_TERMINAL_TYPE_PARAM_SLICED_OUT:
+	case IPU_FW_PSYS_TERMINAL_TYPE_PROGRAM:
+	case IPU_FW_PSYS_TERMINAL_TYPE_PROGRAM_CONTROL_INIT:
+		buffer_state = IPU_FW_PSYS_BUFFER_UNDEFINED;
+		break;
+	case IPU_FW_PSYS_TERMINAL_TYPE_PARAM_STREAM:
+	case IPU_FW_PSYS_TERMINAL_TYPE_DATA_IN:
+	case IPU_FW_PSYS_TERMINAL_TYPE_STATE_IN:
+		buffer_state = IPU_FW_PSYS_BUFFER_FULL;
+		break;
+	case IPU_FW_PSYS_TERMINAL_TYPE_DATA_OUT:
+	case IPU_FW_PSYS_TERMINAL_TYPE_STATE_OUT:
+		buffer_state = IPU_FW_PSYS_BUFFER_EMPTY;
+		break;
+	default:
+		dev_err(&kcmd->fh->psys->adev->dev,
+			"unknown terminal type: 0x%x\n", type);
+		return -EAGAIN;
+	}
+
+	if (type == IPU_FW_PSYS_TERMINAL_TYPE_DATA_IN ||
+	    type == IPU_FW_PSYS_TERMINAL_TYPE_DATA_OUT) {
+		struct ipu_fw_psys_data_terminal *dterminal =
+		    (struct ipu_fw_psys_data_terminal *)terminal;
+		dterminal->connection_type = IPU_FW_PSYS_CONNECTION_MEMORY;
+		dterminal->frame.data_bytes = size;
+		if (!ipu_fw_psys_pg_get_protocol(kcmd))
+			dterminal->frame.data = buffer;
+		else
+			dterminal->frame.data_index = terminal_idx;
+		dterminal->frame.buffer_state = buffer_state;
+	} else {
+		struct ipu_fw_psys_param_terminal *pterminal =
+		    (struct ipu_fw_psys_param_terminal *)terminal;
+		if (!ipu_fw_psys_pg_get_protocol(kcmd))
+			pterminal->param_payload.buffer = buffer;
+		else
+			pterminal->param_payload.terminal_index = terminal_idx;
+	}
+	return 0;
+}
+
+void ipu_fw_psys_pg_dump(struct ipu_psys *psys,
+			 struct ipu_psys_kcmd *kcmd, const char *note)
+{
+	ipu6_fw_psys_pg_dump(psys, kcmd, note);
+}
+
+int ipu_fw_psys_pg_get_id(struct ipu_psys_kcmd *kcmd)
+{
+	return kcmd->kpg->pg->ID;
+}
+
+int ipu_fw_psys_pg_get_terminal_count(struct ipu_psys_kcmd *kcmd)
+{
+	return kcmd->kpg->pg->terminal_count;
+}
+
+int ipu_fw_psys_pg_get_size(struct ipu_psys_kcmd *kcmd)
+{
+	return kcmd->kpg->pg->size;
+}
+
+int ipu_fw_psys_pg_set_ipu_vaddress(struct ipu_psys_kcmd *kcmd,
+				    dma_addr_t vaddress)
+{
+	kcmd->kpg->pg->ipu_virtual_address = vaddress;
+	return 0;
+}
+
+struct ipu_fw_psys_terminal *ipu_fw_psys_pg_get_terminal(struct ipu_psys_kcmd
+							 *kcmd, int index)
+{
+	struct ipu_fw_psys_terminal *terminal;
+	u16 *terminal_offset_table;
+
+	terminal_offset_table =
+	    (uint16_t *)((char *)kcmd->kpg->pg +
+			  kcmd->kpg->pg->terminals_offset);
+	terminal = (struct ipu_fw_psys_terminal *)
+	    ((char *)kcmd->kpg->pg + terminal_offset_table[index]);
+	return terminal;
+}
+
+void ipu_fw_psys_pg_set_token(struct ipu_psys_kcmd *kcmd, u64 token)
+{
+	kcmd->kpg->pg->token = (u64)token;
+}
+
+u64 ipu_fw_psys_pg_get_token(struct ipu_psys_kcmd *kcmd)
+{
+	return kcmd->kpg->pg->token;
+}
+
+int ipu_fw_psys_pg_get_protocol(struct ipu_psys_kcmd *kcmd)
+{
+	return kcmd->kpg->pg->protocol_version;
+}
+
+int ipu_fw_psys_ppg_set_buffer_set(struct ipu_psys_kcmd *kcmd,
+				   struct ipu_fw_psys_terminal *terminal,
+				   int terminal_idx, u32 buffer)
+{
+	u32 type;
+	u32 buffer_state;
+	u32 *buffer_ptr;
+	struct ipu_fw_psys_buffer_set *buf_set = kcmd->kbuf_set->buf_set;
+
+	type = terminal->terminal_type;
+
+	switch (type) {
+	case IPU_FW_PSYS_TERMINAL_TYPE_PARAM_CACHED_IN:
+	case IPU_FW_PSYS_TERMINAL_TYPE_PARAM_CACHED_OUT:
+	case IPU_FW_PSYS_TERMINAL_TYPE_PARAM_SPATIAL_IN:
+	case IPU_FW_PSYS_TERMINAL_TYPE_PARAM_SPATIAL_OUT:
+	case IPU_FW_PSYS_TERMINAL_TYPE_PARAM_SLICED_IN:
+	case IPU_FW_PSYS_TERMINAL_TYPE_PARAM_SLICED_OUT:
+	case IPU_FW_PSYS_TERMINAL_TYPE_PROGRAM:
+	case IPU_FW_PSYS_TERMINAL_TYPE_PROGRAM_CONTROL_INIT:
+		buffer_state = IPU_FW_PSYS_BUFFER_UNDEFINED;
+		break;
+	case IPU_FW_PSYS_TERMINAL_TYPE_PARAM_STREAM:
+	case IPU_FW_PSYS_TERMINAL_TYPE_DATA_IN:
+	case IPU_FW_PSYS_TERMINAL_TYPE_STATE_IN:
+		buffer_state = IPU_FW_PSYS_BUFFER_FULL;
+		break;
+	case IPU_FW_PSYS_TERMINAL_TYPE_DATA_OUT:
+	case IPU_FW_PSYS_TERMINAL_TYPE_STATE_OUT:
+		buffer_state = IPU_FW_PSYS_BUFFER_EMPTY;
+		break;
+	default:
+		dev_err(&kcmd->fh->psys->adev->dev,
+			"unknown terminal type: 0x%x\n", type);
+		return -EAGAIN;
+	}
+
+	buffer_ptr = (u32 *)((char *)buf_set + sizeof(*buf_set) +
+			      terminal_idx * sizeof(*buffer_ptr));
+
+	*buffer_ptr = buffer;
+
+	if (type == IPU_FW_PSYS_TERMINAL_TYPE_DATA_IN ||
+	    type == IPU_FW_PSYS_TERMINAL_TYPE_DATA_OUT) {
+		struct ipu_fw_psys_data_terminal *dterminal =
+		    (struct ipu_fw_psys_data_terminal *)terminal;
+		dterminal->frame.buffer_state = buffer_state;
+	}
+
+	return 0;
+}
+
+size_t ipu_fw_psys_ppg_get_buffer_set_size(struct ipu_psys_kcmd *kcmd)
+{
+	return (sizeof(struct ipu_fw_psys_buffer_set) +
+		kcmd->kpg->pg->terminal_count * sizeof(u32));
+}
+
+int
+ipu_fw_psys_ppg_buffer_set_vaddress(struct ipu_fw_psys_buffer_set *buf_set,
+				    u32 vaddress)
+{
+	buf_set->ipu_virtual_address = vaddress;
+	return 0;
+}
+
+int ipu_fw_psys_ppg_buffer_set_set_kernel_enable_bitmap(
+		struct ipu_fw_psys_buffer_set *buf_set,
+		u32 *kernel_enable_bitmap)
+{
+	memcpy(buf_set->kernel_enable_bitmap, (u8 *)kernel_enable_bitmap,
+	       sizeof(buf_set->kernel_enable_bitmap));
+	return 0;
+}
+
+struct ipu_fw_psys_buffer_set *
+ipu_fw_psys_ppg_create_buffer_set(struct ipu_psys_kcmd *kcmd,
+				  void *kaddr, u32 frame_counter)
+{
+	struct ipu_fw_psys_buffer_set *buffer_set = NULL;
+	unsigned int i;
+
+	buffer_set = (struct ipu_fw_psys_buffer_set *)kaddr;
+
+	/*
+	 * Set base struct members
+	 */
+	buffer_set->ipu_virtual_address = 0;
+	buffer_set->process_group_handle = kcmd->kpg->pg->ipu_virtual_address;
+	buffer_set->frame_counter = frame_counter;
+	buffer_set->terminal_count = kcmd->kpg->pg->terminal_count;
+
+	/*
+	 * Initialize adjacent buffer addresses
+	 */
+	for (i = 0; i < buffer_set->terminal_count; i++) {
+		u32 *buffer =
+		    (u32 *)((char *)buffer_set +
+			     sizeof(*buffer_set) + sizeof(u32) * i);
+
+		*buffer = 0;
+	}
+
+	return buffer_set;
+}
+
+int ipu_fw_psys_ppg_enqueue_bufs(struct ipu_psys_kcmd *kcmd)
+{
+	struct ipu_fw_psys_cmd *psys_cmd;
+	unsigned int queue_id;
+	int ret = 0;
+	unsigned int size;
+
+	if (ipu_ver == IPU_VER_6SE)
+		size = IPU6SE_FW_PSYS_N_PSYS_CMD_QUEUE_ID;
+	else
+		size = IPU6_FW_PSYS_N_PSYS_CMD_QUEUE_ID;
+	queue_id = kcmd->kpg->pg->base_queue_id;
+
+	if (queue_id >= size)
+		return -EINVAL;
+
+	psys_cmd = ipu_send_get_token(kcmd->fh->psys->fwcom, queue_id);
+	if (!psys_cmd) {
+		dev_err(&kcmd->fh->psys->adev->dev,
+			"%s failed to get token!\n", __func__);
+		kcmd->pg_user = NULL;
+		return -ENODATA;
+	}
+
+	psys_cmd->command = IPU_FW_PSYS_PROCESS_GROUP_CMD_RUN;
+	psys_cmd->msg = 0;
+	psys_cmd->context_handle = kcmd->kbuf_set->buf_set->ipu_virtual_address;
+
+	ipu_send_put_token(kcmd->fh->psys->fwcom, queue_id);
+
+	return ret;
+}
+
+u8 ipu_fw_psys_ppg_get_base_queue_id(struct ipu_psys_kcmd *kcmd)
+{
+	return kcmd->kpg->pg->base_queue_id;
+}
+
+void ipu_fw_psys_ppg_set_base_queue_id(struct ipu_psys_kcmd *kcmd, u8 queue_id)
+{
+	kcmd->kpg->pg->base_queue_id = queue_id;
+}
+
+int ipu_fw_psys_open(struct ipu_psys *psys)
+{
+	int retry = IPU_PSYS_OPEN_RETRY, retval;
+
+	retval = ipu_fw_com_open(psys->fwcom);
+	if (retval) {
+		dev_err(&psys->adev->dev, "fw com open failed.\n");
+		return retval;
+	}
+
+	do {
+		usleep_range(IPU_PSYS_OPEN_TIMEOUT_US,
+			     IPU_PSYS_OPEN_TIMEOUT_US + 10);
+		retval = ipu_fw_com_ready(psys->fwcom);
+		if (!retval) {
+			dev_dbg(&psys->adev->dev, "psys port open ready!\n");
+			break;
+		}
+	} while (retry-- > 0);
+
+	if (!retry && retval) {
+		dev_err(&psys->adev->dev, "psys port open ready failed %d\n",
+			retval);
+		ipu_fw_com_close(psys->fwcom);
+		return retval;
+	}
+	return 0;
+}
+
+int ipu_fw_psys_close(struct ipu_psys *psys)
+{
+	int retval;
+
+	retval = ipu_fw_com_close(psys->fwcom);
+	if (retval) {
+		dev_err(&psys->adev->dev, "fw com close failed.\n");
+		return retval;
+	}
+	return retval;
+}
Index: b/drivers/media/pci/intel/ipu-fw-psys.h
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu-fw-psys.h
@@ -0,0 +1,382 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2016 - 2020 Intel Corporation */
+
+#ifndef IPU_FW_PSYS_H
+#define IPU_FW_PSYS_H
+
+#include "ipu6-platform-resources.h"
+#include "ipu6se-platform-resources.h"
+#include "ipu6ep-platform-resources.h"
+
+#define IPU_FW_PSYS_CMD_QUEUE_SIZE 0x20
+#define IPU_FW_PSYS_EVENT_QUEUE_SIZE 0x40
+
+#define IPU_FW_PSYS_CMD_BITS 64
+#define IPU_FW_PSYS_EVENT_BITS 128
+
+enum {
+	IPU_FW_PSYS_EVENT_TYPE_SUCCESS = 0,
+	IPU_FW_PSYS_EVENT_TYPE_UNKNOWN_ERROR = 1,
+	IPU_FW_PSYS_EVENT_TYPE_RET_REM_OBJ_NOT_FOUND = 2,
+	IPU_FW_PSYS_EVENT_TYPE_RET_REM_OBJ_TOO_BIG = 3,
+	IPU_FW_PSYS_EVENT_TYPE_RET_REM_OBJ_DDR_TRANS_ERR = 4,
+	IPU_FW_PSYS_EVENT_TYPE_RET_REM_OBJ_NULL_PKG_DIR_ADDR = 5,
+	IPU_FW_PSYS_EVENT_TYPE_PROC_GRP_LOAD_FRAME_ERR = 6,
+	IPU_FW_PSYS_EVENT_TYPE_PROC_GRP_LOAD_FRAGMENT_ERR = 7,
+	IPU_FW_PSYS_EVENT_TYPE_PROC_GRP_PROCESS_COUNT_ZERO = 8,
+	IPU_FW_PSYS_EVENT_TYPE_PROC_GRP_PROCESS_INIT_ERR = 9,
+	IPU_FW_PSYS_EVENT_TYPE_PROC_GRP_ABORT = 10,
+	IPU_FW_PSYS_EVENT_TYPE_PROC_GRP_NULL = 11,
+	IPU_FW_PSYS_EVENT_TYPE_PROC_GRP_VALIDATION_ERR = 12,
+	IPU_FW_PSYS_EVENT_TYPE_PROC_GRP_INVALID_FRAME = 13
+};
+
+enum {
+	IPU_FW_PSYS_EVENT_QUEUE_MAIN_ID,
+	IPU_FW_PSYS_N_PSYS_EVENT_QUEUE_ID
+};
+
+enum {
+	IPU_FW_PSYS_PROCESS_GROUP_ERROR = 0,
+	IPU_FW_PSYS_PROCESS_GROUP_CREATED,
+	IPU_FW_PSYS_PROCESS_GROUP_READY,
+	IPU_FW_PSYS_PROCESS_GROUP_BLOCKED,
+	IPU_FW_PSYS_PROCESS_GROUP_STARTED,
+	IPU_FW_PSYS_PROCESS_GROUP_RUNNING,
+	IPU_FW_PSYS_PROCESS_GROUP_STALLED,
+	IPU_FW_PSYS_PROCESS_GROUP_STOPPED,
+	IPU_FW_PSYS_N_PROCESS_GROUP_STATES
+};
+
+enum {
+	IPU_FW_PSYS_CONNECTION_MEMORY = 0,
+	IPU_FW_PSYS_CONNECTION_MEMORY_STREAM,
+	IPU_FW_PSYS_CONNECTION_STREAM,
+	IPU_FW_PSYS_N_CONNECTION_TYPES
+};
+
+enum {
+	IPU_FW_PSYS_BUFFER_NULL = 0,
+	IPU_FW_PSYS_BUFFER_UNDEFINED,
+	IPU_FW_PSYS_BUFFER_EMPTY,
+	IPU_FW_PSYS_BUFFER_NONEMPTY,
+	IPU_FW_PSYS_BUFFER_FULL,
+	IPU_FW_PSYS_N_BUFFER_STATES
+};
+
+enum {
+	IPU_FW_PSYS_TERMINAL_TYPE_DATA_IN = 0,
+	IPU_FW_PSYS_TERMINAL_TYPE_DATA_OUT,
+	IPU_FW_PSYS_TERMINAL_TYPE_PARAM_STREAM,
+	IPU_FW_PSYS_TERMINAL_TYPE_PARAM_CACHED_IN,
+	IPU_FW_PSYS_TERMINAL_TYPE_PARAM_CACHED_OUT,
+	IPU_FW_PSYS_TERMINAL_TYPE_PARAM_SPATIAL_IN,
+	IPU_FW_PSYS_TERMINAL_TYPE_PARAM_SPATIAL_OUT,
+	IPU_FW_PSYS_TERMINAL_TYPE_PARAM_SLICED_IN,
+	IPU_FW_PSYS_TERMINAL_TYPE_PARAM_SLICED_OUT,
+	IPU_FW_PSYS_TERMINAL_TYPE_STATE_IN,
+	IPU_FW_PSYS_TERMINAL_TYPE_STATE_OUT,
+	IPU_FW_PSYS_TERMINAL_TYPE_PROGRAM,
+	IPU_FW_PSYS_TERMINAL_TYPE_PROGRAM_CONTROL_INIT,
+	IPU_FW_PSYS_N_TERMINAL_TYPES
+};
+
+enum {
+	IPU_FW_PSYS_COL_DIMENSION = 0,
+	IPU_FW_PSYS_ROW_DIMENSION = 1,
+	IPU_FW_PSYS_N_DATA_DIMENSION = 2
+};
+
+enum {
+	IPU_FW_PSYS_PROCESS_GROUP_CMD_NOP = 0,
+	IPU_FW_PSYS_PROCESS_GROUP_CMD_SUBMIT,
+	IPU_FW_PSYS_PROCESS_GROUP_CMD_ATTACH,
+	IPU_FW_PSYS_PROCESS_GROUP_CMD_DETACH,
+	IPU_FW_PSYS_PROCESS_GROUP_CMD_START,
+	IPU_FW_PSYS_PROCESS_GROUP_CMD_DISOWN,
+	IPU_FW_PSYS_PROCESS_GROUP_CMD_RUN,
+	IPU_FW_PSYS_PROCESS_GROUP_CMD_STOP,
+	IPU_FW_PSYS_PROCESS_GROUP_CMD_SUSPEND,
+	IPU_FW_PSYS_PROCESS_GROUP_CMD_RESUME,
+	IPU_FW_PSYS_PROCESS_GROUP_CMD_ABORT,
+	IPU_FW_PSYS_PROCESS_GROUP_CMD_RESET,
+	IPU_FW_PSYS_N_PROCESS_GROUP_CMDS
+};
+
+enum {
+	IPU_FW_PSYS_PROCESS_GROUP_PROTOCOL_LEGACY = 0,
+	IPU_FW_PSYS_PROCESS_GROUP_PROTOCOL_PPG,
+	IPU_FW_PSYS_PROCESS_GROUP_N_PROTOCOLS
+};
+
+struct __packed ipu_fw_psys_process_group {
+	u64 token;
+	u64 private_token;
+	u32 routing_bitmap[IPU_FW_PSYS_RBM_NOF_ELEMS];
+	u32 kernel_bitmap[IPU_FW_PSYS_KBM_NOF_ELEMS];
+	u32 size;
+	u32 psys_server_init_cycles;
+	u32 pg_load_start_ts;
+	u32 pg_load_cycles;
+	u32 pg_init_cycles;
+	u32 pg_processing_cycles;
+	u32 pg_next_frame_init_cycles;
+	u32 pg_complete_cycles;
+	u32 ID;
+	u32 state;
+	u32 ipu_virtual_address;
+	u32 resource_bitmap;
+	u16 fragment_count;
+	u16 fragment_state;
+	u16 fragment_limit;
+	u16 processes_offset;
+	u16 terminals_offset;
+	u8 process_count;
+	u8 terminal_count;
+	u8 subgraph_count;
+	u8 protocol_version;
+	u8 base_queue_id;
+	u8 num_queues;
+	u8 mask_irq;
+	u8 error_handling_enable;
+	u8 padding[IPU_FW_PSYS_N_PADDING_UINT8_IN_PROCESS_GROUP_STRUCT];
+};
+
+struct ipu_fw_psys_srv_init {
+	void *host_ddr_pkg_dir;
+	u32 ddr_pkg_dir_address;
+	u32 pkg_dir_size;
+
+	u32 icache_prefetch_sp;
+	u32 icache_prefetch_isp;
+};
+
+struct __packed ipu_fw_psys_cmd {
+	u16 command;
+	u16 msg;
+	u32 context_handle;
+};
+
+struct __packed ipu_fw_psys_event {
+	u16 status;
+	u16 command;
+	u32 context_handle;
+	u64 token;
+};
+
+struct ipu_fw_psys_terminal {
+	u32 terminal_type;
+	s16 parent_offset;
+	u16 size;
+	u16 tm_index;
+	u8 ID;
+	u8 padding[IPU_FW_PSYS_N_PADDING_UINT8_IN_TERMINAL_STRUCT];
+};
+
+struct ipu_fw_psys_param_payload {
+	u64 host_buffer;
+	u32 buffer;
+	u32 terminal_index;
+};
+
+struct ipu_fw_psys_param_terminal {
+	struct ipu_fw_psys_terminal base;
+	struct ipu_fw_psys_param_payload param_payload;
+	u16 param_section_desc_offset;
+	u8 padding[IPU_FW_PSYS_N_PADDING_UINT8_IN_PARAM_TERMINAL_STRUCT];
+};
+
+struct ipu_fw_psys_frame {
+	u32 buffer_state;
+	u32 access_type;
+	u32 pointer_state;
+	u32 access_scope;
+	u32 data;
+	u32 data_index;
+	u32 data_bytes;
+	u8 padding[IPU_FW_PSYS_N_PADDING_UINT8_IN_FRAME_STRUCT];
+};
+
+struct ipu_fw_psys_frame_descriptor {
+	u32 frame_format_type;
+	u32 plane_count;
+	u32 plane_offsets[IPU_FW_PSYS_N_FRAME_PLANES];
+	u32 stride[1];
+	u32 ts_offsets[IPU_FW_PSYS_N_FRAME_PLANES];
+	u16 dimension[2];
+	u16 size;
+	u8 bpp;
+	u8 bpe;
+	u8 is_compressed;
+	u8 padding[IPU_FW_PSYS_N_PADDING_UINT8_IN_FRAME_DESC_STRUCT];
+};
+
+struct ipu_fw_psys_stream {
+	u64 dummy;
+};
+
+struct ipu_fw_psys_data_terminal {
+	struct ipu_fw_psys_terminal base;
+	struct ipu_fw_psys_frame_descriptor frame_descriptor;
+	struct ipu_fw_psys_frame frame;
+	struct ipu_fw_psys_stream stream;
+	u32 reserved;
+	u32 connection_type;
+	u16 fragment_descriptor_offset;
+	u8 kernel_id;
+	u8 subgraph_id;
+	u8 padding[IPU_FW_PSYS_N_PADDING_UINT8_IN_DATA_TERMINAL_STRUCT];
+};
+
+struct ipu_fw_psys_buffer_set {
+	u64 token;
+	u32 kernel_enable_bitmap[IPU_FW_PSYS_KERNEL_BITMAP_NOF_ELEMS];
+	u32 terminal_enable_bitmap[IPU_FW_PSYS_KERNEL_BITMAP_NOF_ELEMS];
+	u32 routing_enable_bitmap[IPU_FW_PSYS_KERNEL_BITMAP_NOF_ELEMS];
+	u32 rbm[IPU_FW_PSYS_RBM_NOF_ELEMS];
+	u32 ipu_virtual_address;
+	u32 process_group_handle;
+	u16 terminal_count;
+	u8 frame_counter;
+	u8 padding[IPU_FW_PSYS_N_PADDING_UINT8_IN_BUFFER_SET_STRUCT];
+};
+
+struct ipu_fw_psys_program_group_manifest {
+	u32 kernel_bitmap[IPU_FW_PSYS_KERNEL_BITMAP_NOF_ELEMS];
+	u32 ID;
+	u16 program_manifest_offset;
+	u16 terminal_manifest_offset;
+	u16 private_data_offset;
+	u16 rbm_manifest_offset;
+	u16 size;
+	u8 alignment;
+	u8 kernel_count;
+	u8 program_count;
+	u8 terminal_count;
+	u8 subgraph_count;
+	u8 reserved[5];
+};
+
+struct ipu_fw_generic_program_manifest {
+	u16 *dev_chn_size;
+	u16 *dev_chn_offset;
+	u16 *ext_mem_size;
+	u16 *ext_mem_offset;
+	u8 cell_id;
+	u8 cells[IPU_FW_PSYS_PROCESS_MAX_CELLS];
+	u8 cell_type_id;
+	u8 *is_dfm_relocatable;
+	u32 *dfm_port_bitmap;
+	u32 *dfm_active_port_bitmap;
+};
+
+struct ipu_fw_resource_definitions {
+	u32 num_cells;
+	u32 num_cells_type;
+	const u8 *cells;
+	u32 num_dev_channels;
+	const u16 *dev_channels;
+
+	u32 num_ext_mem_types;
+	u32 num_ext_mem_ids;
+	const u16 *ext_mem_ids;
+
+	u32 num_dfm_ids;
+	const u16 *dfms;
+
+	u32 cell_mem_row;
+	const u8 *cell_mem;
+};
+
+struct ipu6_psys_hw_res_variant {
+	unsigned int queue_num;
+	unsigned int cell_num;
+	int (*set_proc_dev_chn)(struct ipu_fw_psys_process *ptr, u16 offset,
+				u16 value);
+	int (*set_proc_dfm_bitmap)(struct ipu_fw_psys_process *ptr,
+				   u16 id, u32 bitmap, u32 active_bitmap);
+	int (*set_proc_ext_mem)(struct ipu_fw_psys_process *ptr,
+				u16 type_id, u16 mem_id, u16 offset);
+	int (*get_pgm_by_proc)(struct ipu_fw_generic_program_manifest *gen_pm,
+			       const struct ipu_fw_psys_program_group_manifest
+			       *pg_manifest,
+			       struct ipu_fw_psys_process *process);
+};
+struct ipu_psys_kcmd;
+struct ipu_psys;
+int ipu_fw_psys_pg_start(struct ipu_psys_kcmd *kcmd);
+int ipu_fw_psys_pg_disown(struct ipu_psys_kcmd *kcmd);
+int ipu_fw_psys_pg_abort(struct ipu_psys_kcmd *kcmd);
+int ipu_fw_psys_pg_submit(struct ipu_psys_kcmd *kcmd);
+int ipu_fw_psys_ppg_suspend(struct ipu_psys_kcmd *kcmd);
+int ipu_fw_psys_ppg_resume(struct ipu_psys_kcmd *kcmd);
+int ipu_fw_psys_pg_load_cycles(struct ipu_psys_kcmd *kcmd);
+int ipu_fw_psys_pg_init_cycles(struct ipu_psys_kcmd *kcmd);
+int ipu_fw_psys_pg_processing_cycles(struct ipu_psys_kcmd *kcmd);
+int ipu_fw_psys_pg_server_init_cycles(struct ipu_psys_kcmd *kcmd);
+int ipu_fw_psys_pg_next_frame_init_cycles(struct ipu_psys_kcmd *kcmd);
+int ipu_fw_psys_pg_complete_cycles(struct ipu_psys_kcmd *kcmd);
+int ipu_fw_psys_rcv_event(struct ipu_psys *psys,
+			  struct ipu_fw_psys_event *event);
+int ipu_fw_psys_terminal_set(struct ipu_fw_psys_terminal *terminal,
+			     int terminal_idx,
+			     struct ipu_psys_kcmd *kcmd,
+			     u32 buffer, unsigned int size);
+void ipu_fw_psys_pg_dump(struct ipu_psys *psys,
+			 struct ipu_psys_kcmd *kcmd, const char *note);
+int ipu_fw_psys_pg_get_id(struct ipu_psys_kcmd *kcmd);
+int ipu_fw_psys_pg_get_terminal_count(struct ipu_psys_kcmd *kcmd);
+int ipu_fw_psys_pg_get_size(struct ipu_psys_kcmd *kcmd);
+int ipu_fw_psys_pg_set_ipu_vaddress(struct ipu_psys_kcmd *kcmd,
+				    dma_addr_t vaddress);
+struct ipu_fw_psys_terminal *ipu_fw_psys_pg_get_terminal(struct ipu_psys_kcmd
+							 *kcmd, int index);
+void ipu_fw_psys_pg_set_token(struct ipu_psys_kcmd *kcmd, u64 token);
+u64 ipu_fw_psys_pg_get_token(struct ipu_psys_kcmd *kcmd);
+int ipu_fw_psys_ppg_set_buffer_set(struct ipu_psys_kcmd *kcmd,
+				   struct ipu_fw_psys_terminal *terminal,
+				   int terminal_idx, u32 buffer);
+size_t ipu_fw_psys_ppg_get_buffer_set_size(struct ipu_psys_kcmd *kcmd);
+int
+ipu_fw_psys_ppg_buffer_set_vaddress(struct ipu_fw_psys_buffer_set *buf_set,
+				    u32 vaddress);
+int ipu_fw_psys_ppg_buffer_set_set_kernel_enable_bitmap(
+	struct ipu_fw_psys_buffer_set *buf_set, u32 *kernel_enable_bitmap);
+struct ipu_fw_psys_buffer_set *
+ipu_fw_psys_ppg_create_buffer_set(struct ipu_psys_kcmd *kcmd,
+				  void *kaddr, u32 frame_counter);
+int ipu_fw_psys_ppg_enqueue_bufs(struct ipu_psys_kcmd *kcmd);
+u8 ipu_fw_psys_ppg_get_base_queue_id(struct ipu_psys_kcmd *kcmd);
+void ipu_fw_psys_ppg_set_base_queue_id(struct ipu_psys_kcmd *kcmd, u8 queue_id);
+int ipu_fw_psys_pg_get_protocol(struct ipu_psys_kcmd *kcmd);
+int ipu_fw_psys_open(struct ipu_psys *psys);
+int ipu_fw_psys_close(struct ipu_psys *psys);
+
+/* common resource interface for both abi and api mode */
+int ipu_fw_psys_set_process_cell_id(struct ipu_fw_psys_process *ptr, u8 index,
+				    u8 value);
+u8 ipu_fw_psys_get_process_cell_id(struct ipu_fw_psys_process *ptr, u8 index);
+int ipu_fw_psys_clear_process_cell(struct ipu_fw_psys_process *ptr);
+int ipu_fw_psys_set_proc_dev_chn(struct ipu_fw_psys_process *ptr, u16 offset,
+				 u16 value);
+int ipu_fw_psys_set_process_ext_mem(struct ipu_fw_psys_process *ptr,
+				    u16 type_id, u16 mem_id, u16 offset);
+int ipu_fw_psys_get_program_manifest_by_process(
+	struct ipu_fw_generic_program_manifest *gen_pm,
+	const struct ipu_fw_psys_program_group_manifest *pg_manifest,
+	struct ipu_fw_psys_process *process);
+int ipu6_fw_psys_set_proc_dev_chn(struct ipu_fw_psys_process *ptr, u16 offset,
+				  u16 value);
+int ipu6_fw_psys_set_proc_dfm_bitmap(struct ipu_fw_psys_process *ptr,
+				     u16 id, u32 bitmap,
+				     u32 active_bitmap);
+int ipu6_fw_psys_set_process_ext_mem(struct ipu_fw_psys_process *ptr,
+				     u16 type_id, u16 mem_id, u16 offset);
+int ipu6_fw_psys_get_program_manifest_by_process(
+	struct ipu_fw_generic_program_manifest *gen_pm,
+	const struct ipu_fw_psys_program_group_manifest *pg_manifest,
+	struct ipu_fw_psys_process *process);
+void ipu6_fw_psys_pg_dump(struct ipu_psys *psys,
+			  struct ipu_psys_kcmd *kcmd, const char *note);
+void ipu6_psys_hw_res_variant_init(void);
+#endif /* IPU_FW_PSYS_H */
Index: b/drivers/media/pci/intel/ipu-isys-csi2-be-soc.c
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu-isys-csi2-be-soc.c
@@ -0,0 +1,360 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) 2014 - 2022 Intel Corporation
+
+#include <linux/device.h>
+#include <linux/module.h>
+
+#include <media/ipu-isys.h>
+#include <media/media-entity.h>
+#include <media/v4l2-device.h>
+
+#include "ipu.h"
+#include "ipu-bus.h"
+#include "ipu-isys.h"
+#include "ipu-isys-csi2-be.h"
+#include "ipu-isys-subdev.h"
+#include "ipu-isys-video.h"
+
+/*
+ * Raw bayer format pixel order MUST BE MAINTAINED in groups of four codes.
+ * Otherwise pixel order calculation below WILL BREAK!
+ */
+static const u32 csi2_be_soc_supported_codes_pad[] = {
+	MEDIA_BUS_FMT_Y10_1X10,
+	MEDIA_BUS_FMT_RGB565_1X16,
+	MEDIA_BUS_FMT_RGB888_1X24,
+	MEDIA_BUS_FMT_UYVY8_1X16,
+	MEDIA_BUS_FMT_YUYV8_1X16,
+	MEDIA_BUS_FMT_VYUY8_1X16,
+	MEDIA_BUS_FMT_SBGGR12_1X12,
+	MEDIA_BUS_FMT_SGBRG12_1X12,
+	MEDIA_BUS_FMT_SGRBG12_1X12,
+	MEDIA_BUS_FMT_SRGGB12_1X12,
+	MEDIA_BUS_FMT_SBGGR10_1X10,
+	MEDIA_BUS_FMT_SGBRG10_1X10,
+	MEDIA_BUS_FMT_SGRBG10_1X10,
+	MEDIA_BUS_FMT_SRGGB10_1X10,
+	MEDIA_BUS_FMT_SBGGR8_1X8,
+	MEDIA_BUS_FMT_SGBRG8_1X8,
+	MEDIA_BUS_FMT_SGRBG8_1X8,
+	MEDIA_BUS_FMT_SRGGB8_1X8,
+	MEDIA_BUS_FMT_Y8_1X8,
+	0,
+};
+
+/*
+ * Raw bayer format pixel order MUST BE MAINTAINED in groups of four codes.
+ * Otherwise pixel order calculation below WILL BREAK!
+ */
+static const u32 csi2_be_soc_supported_raw_bayer_codes_pad[] = {
+	MEDIA_BUS_FMT_SBGGR12_1X12,
+	MEDIA_BUS_FMT_SGBRG12_1X12,
+	MEDIA_BUS_FMT_SGRBG12_1X12,
+	MEDIA_BUS_FMT_SRGGB12_1X12,
+	MEDIA_BUS_FMT_SBGGR10_1X10,
+	MEDIA_BUS_FMT_SGBRG10_1X10,
+	MEDIA_BUS_FMT_SGRBG10_1X10,
+	MEDIA_BUS_FMT_SRGGB10_1X10,
+	MEDIA_BUS_FMT_SBGGR8_1X8,
+	MEDIA_BUS_FMT_SGBRG8_1X8,
+	MEDIA_BUS_FMT_SGRBG8_1X8,
+	MEDIA_BUS_FMT_SRGGB8_1X8,
+	MEDIA_BUS_FMT_Y8_1X8,
+	0,
+};
+
+static int get_supported_code_index(u32 code)
+{
+	int i;
+
+	for (i = 0; csi2_be_soc_supported_raw_bayer_codes_pad[i]; i++) {
+		if (csi2_be_soc_supported_raw_bayer_codes_pad[i] == code)
+			return i;
+	}
+	return -EINVAL;
+}
+
+static const u32 *csi2_be_soc_supported_codes[NR_OF_CSI2_BE_SOC_PADS];
+
+static struct v4l2_subdev_internal_ops csi2_be_soc_sd_internal_ops = {
+	.open = ipu_isys_subdev_open,
+	.close = ipu_isys_subdev_close,
+};
+
+static const struct v4l2_subdev_core_ops csi2_be_soc_sd_core_ops = {
+};
+
+static const struct v4l2_ctrl_config compression_ctrl_cfg = {
+	.ops = NULL,
+	.id = V4L2_CID_IPU_ISYS_COMPRESSION,
+	.name = "ISYS BE-SOC compression",
+	.type = V4L2_CTRL_TYPE_BOOLEAN,
+	.min = 0,
+	.max = 1,
+	.step = 1,
+	.def = 0,
+};
+
+static int set_stream(struct v4l2_subdev *sd, int enable)
+{
+	return 0;
+}
+
+static const struct v4l2_subdev_video_ops csi2_be_soc_sd_video_ops = {
+	.s_stream = set_stream,
+};
+
+static int
+__subdev_link_validate(struct v4l2_subdev *sd, struct media_link *link,
+		       struct v4l2_subdev_format *source_fmt,
+		       struct v4l2_subdev_format *sink_fmt)
+{
+	struct ipu_isys_pipeline *ip =
+		container_of(media_entity_pipeline(&sd->entity),
+			     struct ipu_isys_pipeline, pipe);
+
+	ip->csi2_be_soc = to_ipu_isys_csi2_be_soc(sd);
+	return ipu_isys_subdev_link_validate(sd, link, source_fmt, sink_fmt);
+}
+
+static int
+ipu_isys_csi2_be_soc_set_sel(struct v4l2_subdev *sd,
+			     struct v4l2_subdev_state *state,
+			     struct v4l2_subdev_selection *sel)
+{
+	struct ipu_isys_subdev *asd = to_ipu_isys_subdev(sd);
+	struct media_pad *pad = &asd->sd.entity.pads[sel->pad];
+
+	if (sel->target == V4L2_SEL_TGT_CROP &&
+	    pad->flags & MEDIA_PAD_FL_SOURCE &&
+	    asd->valid_tgts[sel->pad].crop) {
+		enum isys_subdev_prop_tgt tgt =
+		    IPU_ISYS_SUBDEV_PROP_TGT_SOURCE_CROP;
+		struct v4l2_mbus_framefmt *ffmt =
+			__ipu_isys_get_ffmt(sd, state, sel->pad, sel->which);
+
+		if (get_supported_code_index(ffmt->code) < 0) {
+			/* Non-bayer formats can't be odd lines cropped */
+			sel->r.left &= ~1;
+			sel->r.top &= ~1;
+		}
+
+		sel->r.width = clamp(sel->r.width, IPU_ISYS_MIN_WIDTH,
+				     IPU_ISYS_MAX_WIDTH);
+
+		sel->r.height = clamp(sel->r.height, IPU_ISYS_MIN_HEIGHT,
+				      IPU_ISYS_MAX_HEIGHT);
+
+		*__ipu_isys_get_selection(sd, state, sel->target, sel->pad,
+					  sel->which) = sel->r;
+		ipu_isys_subdev_fmt_propagate(sd, state, NULL, &sel->r,
+					      tgt, sel->pad, sel->which);
+		return 0;
+	}
+	return -EINVAL;
+}
+
+static const struct v4l2_subdev_pad_ops csi2_be_soc_sd_pad_ops = {
+	.link_validate = __subdev_link_validate,
+	.get_fmt = ipu_isys_subdev_get_ffmt,
+	.set_fmt = ipu_isys_subdev_set_ffmt,
+	.get_selection = ipu_isys_subdev_get_sel,
+	.set_selection = ipu_isys_csi2_be_soc_set_sel,
+	.enum_mbus_code = ipu_isys_subdev_enum_mbus_code,
+};
+
+static struct v4l2_subdev_ops csi2_be_soc_sd_ops = {
+	.core = &csi2_be_soc_sd_core_ops,
+	.video = &csi2_be_soc_sd_video_ops,
+	.pad = &csi2_be_soc_sd_pad_ops,
+};
+
+static struct media_entity_operations csi2_be_soc_entity_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+static void csi2_be_soc_set_ffmt(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_state *state,
+				 struct v4l2_subdev_format *fmt)
+{
+	struct v4l2_mbus_framefmt *ffmt =
+		__ipu_isys_get_ffmt(sd, state, fmt->pad,
+				    fmt->which);
+
+	if (sd->entity.pads[fmt->pad].flags & MEDIA_PAD_FL_SINK) {
+		if (fmt->format.field != V4L2_FIELD_ALTERNATE)
+			fmt->format.field = V4L2_FIELD_NONE;
+		*ffmt = fmt->format;
+
+		ipu_isys_subdev_fmt_propagate(sd, state, &fmt->format,
+					      NULL,
+					      IPU_ISYS_SUBDEV_PROP_TGT_SINK_FMT,
+					      fmt->pad, fmt->which);
+	} else if (sd->entity.pads[fmt->pad].flags & MEDIA_PAD_FL_SOURCE) {
+		struct v4l2_mbus_framefmt *sink_ffmt;
+		struct v4l2_rect *r = __ipu_isys_get_selection(sd, state,
+			V4L2_SEL_TGT_CROP, fmt->pad, fmt->which);
+		struct ipu_isys_subdev *asd = to_ipu_isys_subdev(sd);
+		u32 code;
+		int idx;
+
+		sink_ffmt = __ipu_isys_get_ffmt(sd, state, 0, fmt->which);
+		code = sink_ffmt->code;
+		idx = get_supported_code_index(code);
+
+		if (asd->valid_tgts[fmt->pad].crop && idx >= 0) {
+			int crop_info = 0;
+
+			/* Only croping odd line at top side. */
+			if (r->top & 1)
+				crop_info |= CSI2_BE_CROP_VER;
+
+			code = csi2_be_soc_supported_raw_bayer_codes_pad
+				[((idx & CSI2_BE_CROP_MASK) ^ crop_info)
+				+ (idx & ~CSI2_BE_CROP_MASK)];
+
+		}
+		ffmt->code = fmt->format.code;
+		ffmt->width = r->width;
+		ffmt->height = r->height;
+		ffmt->field = sink_ffmt->field;
+
+	}
+}
+
+void ipu_isys_csi2_be_soc_cleanup(struct ipu_isys_csi2_be_soc *csi2_be_soc)
+{
+	int i;
+
+	v4l2_device_unregister_subdev(&csi2_be_soc->asd.sd);
+	ipu_isys_subdev_cleanup(&csi2_be_soc->asd);
+	for (i = 0; i < NR_OF_CSI2_BE_SOC_STREAMS; i++) {
+		v4l2_ctrl_handler_free(&csi2_be_soc->av[i].ctrl_handler);
+		ipu_isys_video_cleanup(&csi2_be_soc->av[i]);
+	}
+}
+
+int ipu_isys_csi2_be_soc_init(struct ipu_isys_csi2_be_soc *csi2_be_soc,
+			      struct ipu_isys *isys, int index)
+{
+	struct v4l2_subdev_format fmt = {
+		.which = V4L2_SUBDEV_FORMAT_ACTIVE,
+		.pad = CSI2_BE_SOC_PAD_SINK,
+		.format = {
+			   .width = 4096,
+			   .height = 3072,
+			   },
+	};
+	int rval, i;
+
+	csi2_be_soc->asd.sd.entity.ops = &csi2_be_soc_entity_ops;
+	csi2_be_soc->asd.isys = isys;
+
+	rval = ipu_isys_subdev_init(&csi2_be_soc->asd,
+				    &csi2_be_soc_sd_ops, 0,
+				    NR_OF_CSI2_BE_SOC_PADS,
+				    NR_OF_CSI2_BE_SOC_SOURCE_PADS,
+				    NR_OF_CSI2_BE_SOC_SINK_PADS, 0);
+	if (rval)
+		goto fail;
+
+	csi2_be_soc->asd.pad[CSI2_BE_SOC_PAD_SINK].flags = MEDIA_PAD_FL_SINK;
+	for (i = CSI2_BE_SOC_PAD_SOURCE(0);
+	     i < NR_OF_CSI2_BE_SOC_SOURCE_PADS + CSI2_BE_SOC_PAD_SOURCE(0);
+	     i++) {
+		csi2_be_soc->asd.pad[i].flags = MEDIA_PAD_FL_SOURCE;
+		csi2_be_soc->asd.valid_tgts[i].crop = true;
+	}
+
+	for (i = 0; i < NR_OF_CSI2_BE_SOC_PADS; i++)
+		csi2_be_soc_supported_codes[i] =
+			csi2_be_soc_supported_codes_pad;
+	csi2_be_soc->asd.supported_codes = csi2_be_soc_supported_codes;
+	csi2_be_soc->asd.be_mode = IPU_BE_SOC;
+	csi2_be_soc->asd.isl_mode = IPU_ISL_OFF;
+	csi2_be_soc->asd.set_ffmt = csi2_be_soc_set_ffmt;
+
+	fmt.pad = CSI2_BE_SOC_PAD_SINK;
+	ipu_isys_subdev_set_ffmt(&csi2_be_soc->asd.sd, NULL, &fmt);
+	csi2_be_soc->asd.sd.internal_ops = &csi2_be_soc_sd_internal_ops;
+
+	snprintf(csi2_be_soc->asd.sd.name, sizeof(csi2_be_soc->asd.sd.name),
+		 IPU_ISYS_ENTITY_PREFIX " CSI2 BE SOC %d", index);
+	v4l2_set_subdevdata(&csi2_be_soc->asd.sd, &csi2_be_soc->asd);
+
+	rval = v4l2_device_register_subdev(&isys->v4l2_dev,
+					   &csi2_be_soc->asd.sd);
+	if (rval) {
+		dev_info(&isys->adev->dev, "can't register v4l2 subdev\n");
+		goto fail;
+	}
+
+	for (i = 0; i < NR_OF_CSI2_BE_SOC_SOURCE_PADS; i++) {
+		if (!index)
+			snprintf(csi2_be_soc->av[i].vdev.name,
+				 sizeof(csi2_be_soc->av[i].vdev.name),
+				 IPU_ISYS_ENTITY_PREFIX " BE SOC capture %d", i);
+		else
+			snprintf(csi2_be_soc->av[i].vdev.name,
+				 sizeof(csi2_be_soc->av[i].vdev.name),
+				 IPU_ISYS_ENTITY_PREFIX " BE SOC %d capture %d", index, i);
+		/*
+		 * Pin type could be overwritten for YUV422 to I420 case, at
+		 * set_format phase
+		 */
+		csi2_be_soc->av[i].aq.css_pin_type =
+		    IPU_FW_ISYS_PIN_TYPE_RAW_SOC;
+		csi2_be_soc->av[i].isys = isys;
+		csi2_be_soc->av[i].pfmts = ipu_isys_pfmts_be_soc;
+
+		csi2_be_soc->av[i].try_fmt_vid_mplane =
+		    ipu_isys_video_try_fmt_vid_mplane_default;
+		csi2_be_soc->av[i].prepare_fw_stream =
+		    ipu_isys_prepare_fw_cfg_default;
+		csi2_be_soc->av[i].aq.buf_prepare = ipu_isys_buf_prepare;
+		csi2_be_soc->av[i].aq.fill_frame_buff_set_pin =
+		    ipu_isys_buffer_to_fw_frame_buff_pin;
+		csi2_be_soc->av[i].aq.link_fmt_validate =
+		    ipu_isys_link_fmt_validate;
+		csi2_be_soc->av[i].aq.vbq.buf_struct_size =
+		    sizeof(struct ipu_isys_video_buffer);
+
+		/* create v4l2 ctrl for be-soc video node */
+		rval =
+		  v4l2_ctrl_handler_init(&csi2_be_soc->av[i].ctrl_handler, 0);
+		if (rval) {
+			dev_err(&isys->adev->dev,
+				"failed to init v4l2 ctrl hdl for be_soc\n");
+			goto fail;
+		}
+
+		csi2_be_soc->av[i].compression_ctrl =
+			v4l2_ctrl_new_custom(&csi2_be_soc->av[i].ctrl_handler,
+					     &compression_ctrl_cfg, NULL);
+		if (!csi2_be_soc->av[i].compression_ctrl) {
+			dev_err(&isys->adev->dev,
+				"failed to create BE-SOC cmprs ctrl\n");
+			goto fail;
+		}
+		csi2_be_soc->av[i].compression = 0;
+		csi2_be_soc->av[i].vdev.ctrl_handler =
+			&csi2_be_soc->av[i].ctrl_handler;
+
+		rval = ipu_isys_video_init(&csi2_be_soc->av[i],
+					   &csi2_be_soc->asd.sd.entity,
+					   CSI2_BE_SOC_PAD_SOURCE(i),
+					   MEDIA_PAD_FL_SINK,
+					   MEDIA_LNK_FL_DYNAMIC);
+		if (rval) {
+			dev_info(&isys->adev->dev, "can't init video node\n");
+			goto fail;
+		}
+	}
+
+	return 0;
+
+fail:
+	ipu_isys_csi2_be_soc_cleanup(csi2_be_soc);
+
+	return rval;
+}
Index: b/drivers/media/pci/intel/ipu-isys-csi2-be.c
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu-isys-csi2-be.c
@@ -0,0 +1,325 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) 2014 - 2020 Intel Corporation
+
+#include <linux/device.h>
+#include <linux/module.h>
+
+#include <media/ipu-isys.h>
+#include <media/media-entity.h>
+#include <media/v4l2-device.h>
+
+#include "ipu.h"
+#include "ipu-bus.h"
+#include "ipu-isys.h"
+#include "ipu-isys-csi2-be.h"
+#include "ipu-isys-subdev.h"
+#include "ipu-isys-video.h"
+
+/*
+ * Raw bayer format pixel order MUST BE MAINTAINED in groups of four codes.
+ * Otherwise pixel order calculation below WILL BREAK!
+ */
+static const u32 csi2_be_supported_codes_pad[] = {
+	MEDIA_BUS_FMT_SBGGR12_1X12,
+	MEDIA_BUS_FMT_SGBRG12_1X12,
+	MEDIA_BUS_FMT_SGRBG12_1X12,
+	MEDIA_BUS_FMT_SRGGB12_1X12,
+	MEDIA_BUS_FMT_SBGGR10_1X10,
+	MEDIA_BUS_FMT_SGBRG10_1X10,
+	MEDIA_BUS_FMT_SGRBG10_1X10,
+	MEDIA_BUS_FMT_SRGGB10_1X10,
+	MEDIA_BUS_FMT_SBGGR8_1X8,
+	MEDIA_BUS_FMT_SGBRG8_1X8,
+	MEDIA_BUS_FMT_SGRBG8_1X8,
+	MEDIA_BUS_FMT_SRGGB8_1X8,
+	0,
+};
+
+static const u32 *csi2_be_supported_codes[] = {
+	csi2_be_supported_codes_pad,
+	csi2_be_supported_codes_pad,
+};
+
+static struct v4l2_subdev_internal_ops csi2_be_sd_internal_ops = {
+	.open = ipu_isys_subdev_open,
+	.close = ipu_isys_subdev_close,
+};
+
+static const struct v4l2_subdev_core_ops csi2_be_sd_core_ops = {
+};
+
+static const struct v4l2_ctrl_config compression_ctrl_cfg = {
+	.ops = NULL,
+	.id = V4L2_CID_IPU_ISYS_COMPRESSION,
+	.name = "ISYS CSI-BE compression",
+	.type = V4L2_CTRL_TYPE_BOOLEAN,
+	.min = 0,
+	.max = 1,
+	.step = 1,
+	.def = 0,
+};
+
+static int set_stream(struct v4l2_subdev *sd, int enable)
+{
+	return 0;
+}
+
+static const struct v4l2_subdev_video_ops csi2_be_sd_video_ops = {
+	.s_stream = set_stream,
+};
+
+static int __subdev_link_validate(struct v4l2_subdev *sd,
+				  struct media_link *link,
+				  struct v4l2_subdev_format *source_fmt,
+				  struct v4l2_subdev_format *sink_fmt)
+{
+	struct ipu_isys_pipeline *ip =
+		container_of(media_entity_pipeline(&sd->entity),
+			     struct ipu_isys_pipeline, pipe);
+
+	ip->csi2_be = to_ipu_isys_csi2_be(sd);
+	return ipu_isys_subdev_link_validate(sd, link, source_fmt, sink_fmt);
+}
+
+static int get_supported_code_index(u32 code)
+{
+	int i;
+
+	for (i = 0; csi2_be_supported_codes_pad[i]; i++) {
+		if (csi2_be_supported_codes_pad[i] == code)
+			return i;
+	}
+	return -EINVAL;
+}
+
+static int ipu_isys_csi2_be_set_sel(struct v4l2_subdev *sd,
+				    struct v4l2_subdev_state *state,
+				    struct v4l2_subdev_selection *sel)
+{
+	struct ipu_isys_subdev *asd = to_ipu_isys_subdev(sd);
+	struct media_pad *pad = &asd->sd.entity.pads[sel->pad];
+
+	if (sel->target == V4L2_SEL_TGT_CROP &&
+	    pad->flags & MEDIA_PAD_FL_SOURCE &&
+	    asd->valid_tgts[CSI2_BE_PAD_SOURCE].crop) {
+		struct v4l2_mbus_framefmt *ffmt =
+			__ipu_isys_get_ffmt(sd, state, sel->pad, sel->which);
+		struct v4l2_rect *r = __ipu_isys_get_selection
+		    (sd, state, sel->target, CSI2_BE_PAD_SINK, sel->which);
+
+		if (get_supported_code_index(ffmt->code) < 0) {
+			/* Non-bayer formats can't be single line cropped */
+			sel->r.left &= ~1;
+			sel->r.top &= ~1;
+
+			/* Non-bayer formats can't pe padded at all */
+			sel->r.width = clamp(sel->r.width,
+					     IPU_ISYS_MIN_WIDTH, r->width);
+		} else {
+			sel->r.width = clamp(sel->r.width,
+					     IPU_ISYS_MIN_WIDTH,
+					     IPU_ISYS_MAX_WIDTH);
+		}
+
+		/*
+		 * Vertical padding is not supported, height is
+		 * restricted by sink pad resolution.
+		 */
+		sel->r.height = clamp(sel->r.height, IPU_ISYS_MIN_HEIGHT,
+				      r->height);
+		*__ipu_isys_get_selection(sd, state, sel->target, sel->pad,
+					  sel->which) = sel->r;
+		ipu_isys_subdev_fmt_propagate
+		    (sd, state, NULL, &sel->r,
+		     IPU_ISYS_SUBDEV_PROP_TGT_SOURCE_CROP,
+		     sel->pad, sel->which);
+		return 0;
+	}
+	return ipu_isys_subdev_set_sel(sd, state, sel);
+}
+
+static const struct v4l2_subdev_pad_ops csi2_be_sd_pad_ops = {
+	.link_validate = __subdev_link_validate,
+	.get_fmt = ipu_isys_subdev_get_ffmt,
+	.set_fmt = ipu_isys_subdev_set_ffmt,
+	.get_selection = ipu_isys_subdev_get_sel,
+	.set_selection = ipu_isys_csi2_be_set_sel,
+	.enum_mbus_code = ipu_isys_subdev_enum_mbus_code,
+};
+
+static struct v4l2_subdev_ops csi2_be_sd_ops = {
+	.core = &csi2_be_sd_core_ops,
+	.video = &csi2_be_sd_video_ops,
+	.pad = &csi2_be_sd_pad_ops,
+};
+
+static struct media_entity_operations csi2_be_entity_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+static void csi2_be_set_ffmt(struct v4l2_subdev *sd,
+			     struct v4l2_subdev_state *state,
+			     struct v4l2_subdev_format *fmt)
+{
+	struct ipu_isys_csi2 *csi2 = to_ipu_isys_csi2(sd);
+	struct v4l2_mbus_framefmt *ffmt =
+		__ipu_isys_get_ffmt(sd, state, fmt->pad, fmt->which);
+
+	switch (fmt->pad) {
+	case CSI2_BE_PAD_SINK:
+		if (fmt->format.field != V4L2_FIELD_ALTERNATE)
+			fmt->format.field = V4L2_FIELD_NONE;
+		*ffmt = fmt->format;
+
+		ipu_isys_subdev_fmt_propagate
+		    (sd, state, &fmt->format, NULL,
+		     IPU_ISYS_SUBDEV_PROP_TGT_SINK_FMT, fmt->pad, fmt->which);
+		return;
+	case CSI2_BE_PAD_SOURCE: {
+		struct v4l2_mbus_framefmt *sink_ffmt =
+			__ipu_isys_get_ffmt(sd, state, CSI2_BE_PAD_SINK,
+					    fmt->which);
+		struct v4l2_rect *r =
+			__ipu_isys_get_selection(sd, state, V4L2_SEL_TGT_CROP,
+						 CSI2_BE_PAD_SOURCE,
+						 fmt->which);
+		struct ipu_isys_subdev *asd = to_ipu_isys_subdev(sd);
+		u32 code = sink_ffmt->code;
+		int idx = get_supported_code_index(code);
+
+		if (asd->valid_tgts[CSI2_BE_PAD_SOURCE].crop && idx >= 0) {
+			int crop_info = 0;
+
+			if (r->top & 1)
+				crop_info |= CSI2_BE_CROP_VER;
+			if (r->left & 1)
+				crop_info |= CSI2_BE_CROP_HOR;
+			code = csi2_be_supported_codes_pad
+				[((idx & CSI2_BE_CROP_MASK) ^ crop_info)
+				+ (idx & ~CSI2_BE_CROP_MASK)];
+		}
+		ffmt->width = r->width;
+		ffmt->height = r->height;
+		ffmt->code = code;
+		ffmt->field = sink_ffmt->field;
+		return;
+	}
+	default:
+		dev_err(&csi2->isys->adev->dev, "Unknown pad type\n");
+		WARN_ON(1);
+	}
+}
+
+void ipu_isys_csi2_be_cleanup(struct ipu_isys_csi2_be *csi2_be)
+{
+	v4l2_ctrl_handler_free(&csi2_be->av.ctrl_handler);
+	v4l2_device_unregister_subdev(&csi2_be->asd.sd);
+	ipu_isys_subdev_cleanup(&csi2_be->asd);
+	ipu_isys_video_cleanup(&csi2_be->av);
+}
+
+int ipu_isys_csi2_be_init(struct ipu_isys_csi2_be *csi2_be,
+			  struct ipu_isys *isys)
+{
+	struct v4l2_subdev_format fmt = {
+		.which = V4L2_SUBDEV_FORMAT_ACTIVE,
+		.pad = CSI2_BE_PAD_SINK,
+		.format = {
+			   .width = 4096,
+			   .height = 3072,
+			  },
+	};
+	struct v4l2_subdev_selection sel = {
+		.which = V4L2_SUBDEV_FORMAT_ACTIVE,
+		.pad = CSI2_BE_PAD_SOURCE,
+		.target = V4L2_SEL_TGT_CROP,
+		.r = {
+		      .width = fmt.format.width,
+		      .height = fmt.format.height,
+		     },
+	};
+	int rval;
+
+	csi2_be->asd.sd.entity.ops = &csi2_be_entity_ops;
+	csi2_be->asd.isys = isys;
+
+	rval = ipu_isys_subdev_init(&csi2_be->asd, &csi2_be_sd_ops, 0,
+				    NR_OF_CSI2_BE_PADS,
+				    NR_OF_CSI2_BE_SOURCE_PADS,
+				    NR_OF_CSI2_BE_SINK_PADS, 0);
+	if (rval)
+		goto fail;
+
+	csi2_be->asd.pad[CSI2_BE_PAD_SINK].flags = MEDIA_PAD_FL_SINK
+	    | MEDIA_PAD_FL_MUST_CONNECT;
+	csi2_be->asd.pad[CSI2_BE_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+	csi2_be->asd.valid_tgts[CSI2_BE_PAD_SOURCE].crop = true;
+	csi2_be->asd.set_ffmt = csi2_be_set_ffmt;
+
+	BUILD_BUG_ON(ARRAY_SIZE(csi2_be_supported_codes) != NR_OF_CSI2_BE_PADS);
+	csi2_be->asd.supported_codes = csi2_be_supported_codes;
+	csi2_be->asd.be_mode = IPU_BE_RAW;
+	csi2_be->asd.isl_mode = IPU_ISL_CSI2_BE;
+
+	ipu_isys_subdev_set_ffmt(&csi2_be->asd.sd, NULL, &fmt);
+	ipu_isys_csi2_be_set_sel(&csi2_be->asd.sd, NULL, &sel);
+
+	csi2_be->asd.sd.internal_ops = &csi2_be_sd_internal_ops;
+	snprintf(csi2_be->asd.sd.name, sizeof(csi2_be->asd.sd.name),
+		 IPU_ISYS_ENTITY_PREFIX " CSI2 BE");
+	snprintf(csi2_be->av.vdev.name, sizeof(csi2_be->av.vdev.name),
+		 IPU_ISYS_ENTITY_PREFIX " CSI2 BE capture");
+	csi2_be->av.aq.css_pin_type = IPU_FW_ISYS_PIN_TYPE_RAW_NS;
+	v4l2_set_subdevdata(&csi2_be->asd.sd, &csi2_be->asd);
+	rval = v4l2_device_register_subdev(&isys->v4l2_dev, &csi2_be->asd.sd);
+	if (rval) {
+		dev_info(&isys->adev->dev, "can't register v4l2 subdev\n");
+		goto fail;
+	}
+
+	csi2_be->av.isys = isys;
+	csi2_be->av.pfmts = ipu_isys_pfmts;
+	csi2_be->av.try_fmt_vid_mplane =
+	    ipu_isys_video_try_fmt_vid_mplane_default;
+	csi2_be->av.prepare_fw_stream =
+	    ipu_isys_prepare_fw_cfg_default;
+	csi2_be->av.aq.buf_prepare = ipu_isys_buf_prepare;
+	csi2_be->av.aq.fill_frame_buff_set_pin =
+	    ipu_isys_buffer_to_fw_frame_buff_pin;
+	csi2_be->av.aq.link_fmt_validate = ipu_isys_link_fmt_validate;
+	csi2_be->av.aq.vbq.buf_struct_size =
+	    sizeof(struct ipu_isys_video_buffer);
+
+	/* create v4l2 ctrl for csi-be video node */
+	rval = v4l2_ctrl_handler_init(&csi2_be->av.ctrl_handler, 0);
+	if (rval) {
+		dev_err(&isys->adev->dev,
+			"failed to init v4l2 ctrl handler for csi2_be\n");
+		goto fail;
+	}
+
+	csi2_be->av.compression_ctrl =
+		v4l2_ctrl_new_custom(&csi2_be->av.ctrl_handler,
+				     &compression_ctrl_cfg, NULL);
+	if (!csi2_be->av.compression_ctrl) {
+		dev_err(&isys->adev->dev,
+			"failed to create CSI-BE cmprs ctrl\n");
+		goto fail;
+	}
+	csi2_be->av.compression = 0;
+	csi2_be->av.vdev.ctrl_handler = &csi2_be->av.ctrl_handler;
+
+	rval = ipu_isys_video_init(&csi2_be->av, &csi2_be->asd.sd.entity,
+				   CSI2_BE_PAD_SOURCE, MEDIA_PAD_FL_SINK, 0);
+	if (rval) {
+		dev_info(&isys->adev->dev, "can't init video node\n");
+		goto fail;
+	}
+
+	return 0;
+
+fail:
+	ipu_isys_csi2_be_cleanup(csi2_be);
+
+	return rval;
+}
Index: b/drivers/media/pci/intel/ipu-isys-csi2-be.h
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu-isys-csi2-be.h
@@ -0,0 +1,71 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2014 - 2022 Intel Corporation */
+
+#ifndef IPU_ISYS_CSI2_BE_H
+#define IPU_ISYS_CSI2_BE_H
+
+#include <media/media-entity.h>
+#include <media/v4l2-device.h>
+
+#include "ipu-isys-queue.h"
+#include "ipu-isys-subdev.h"
+#include "ipu-isys-video.h"
+#include "ipu-platform-isys.h"
+
+struct ipu_isys_csi2_be_pdata;
+struct ipu_isys;
+
+#define CSI2_BE_PAD_SINK		0
+#define CSI2_BE_PAD_SOURCE		1
+
+#define NR_OF_CSI2_BE_PADS		2
+#define NR_OF_CSI2_BE_SOURCE_PADS	1
+#define NR_OF_CSI2_BE_SINK_PADS		1
+
+#define INVALIA_VC_ID -1
+#define NR_OF_CSI2_BE_SOC_SOURCE_PADS	NR_OF_CSI2_BE_SOC_STREAMS
+#define NR_OF_CSI2_BE_SOC_SINK_PADS	1
+#define CSI2_BE_SOC_PAD_SINK 0
+#define CSI2_BE_SOC_PAD_SOURCE(n)	\
+	({ typeof(n) __n = (n);  \
+	   (__n) >= NR_OF_CSI2_BE_SOC_SOURCE_PADS ? \
+		(NR_OF_CSI2_BE_SOC_SOURCE_PADS - 1) : \
+		((__n) + NR_OF_CSI2_BE_SOC_SINK_PADS); })
+#define NR_OF_CSI2_BE_SOC_PADS \
+	(NR_OF_CSI2_BE_SOC_SOURCE_PADS + NR_OF_CSI2_BE_SOC_SINK_PADS)
+
+#define CSI2_BE_CROP_HOR	BIT(0)
+#define CSI2_BE_CROP_VER	BIT(1)
+#define CSI2_BE_CROP_MASK	(CSI2_BE_CROP_VER | CSI2_BE_CROP_HOR)
+
+/*
+ * struct ipu_isys_csi2_be
+ */
+struct ipu_isys_csi2_be {
+	struct ipu_isys_csi2_be_pdata *pdata;
+	struct ipu_isys_subdev asd;
+	struct ipu_isys_video av;
+};
+
+struct ipu_isys_csi2_be_soc {
+	struct ipu_isys_csi2_be_pdata *pdata;
+	struct ipu_isys_subdev asd;
+	struct ipu_isys_video av[NR_OF_CSI2_BE_SOC_SOURCE_PADS];
+};
+
+#define to_ipu_isys_csi2_be(sd)	\
+	container_of(to_ipu_isys_subdev(sd), \
+	struct ipu_isys_csi2_be, asd)
+
+#define to_ipu_isys_csi2_be_soc(sd)	\
+	container_of(to_ipu_isys_subdev(sd), \
+	struct ipu_isys_csi2_be_soc, asd)
+
+int ipu_isys_csi2_be_init(struct ipu_isys_csi2_be *csi2_be,
+			  struct ipu_isys *isys);
+void ipu_isys_csi2_be_cleanup(struct ipu_isys_csi2_be *csi2_be);
+int ipu_isys_csi2_be_soc_init(struct ipu_isys_csi2_be_soc *csi2_be_soc,
+			      struct ipu_isys *isys, int index);
+void ipu_isys_csi2_be_soc_cleanup(struct ipu_isys_csi2_be_soc *csi2_be);
+
+#endif /* IPU_ISYS_CSI2_BE_H */
Index: b/drivers/media/pci/intel/ipu-isys-csi2.c
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu-isys-csi2.c
@@ -0,0 +1,669 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) 2013 - 2022 Intel Corporation
+
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/version.h>
+
+#include <media/ipu-isys.h>
+#include <media/media-entity.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-event.h>
+
+#include "ipu.h"
+#include "ipu-bus.h"
+#include "ipu-buttress.h"
+#include "ipu-isys.h"
+#include "ipu-isys-subdev.h"
+#include "ipu-isys-video.h"
+#include "ipu-platform-regs.h"
+
+static const u32 csi2_supported_codes_pad_sink[] = {
+	MEDIA_BUS_FMT_Y8_1X8,
+	MEDIA_BUS_FMT_Y10_1X10,
+	MEDIA_BUS_FMT_RGB565_1X16,
+	MEDIA_BUS_FMT_RGB888_1X24,
+	MEDIA_BUS_FMT_UYVY8_1X16,
+	MEDIA_BUS_FMT_YUYV8_1X16,
+	MEDIA_BUS_FMT_VYUY8_1X16,
+	MEDIA_BUS_FMT_YUYV10_1X20,
+	MEDIA_BUS_FMT_SBGGR10_1X10,
+	MEDIA_BUS_FMT_SGBRG10_1X10,
+	MEDIA_BUS_FMT_SGRBG10_1X10,
+	MEDIA_BUS_FMT_SRGGB10_1X10,
+	MEDIA_BUS_FMT_SBGGR10_DPCM8_1X8,
+	MEDIA_BUS_FMT_SGBRG10_DPCM8_1X8,
+	MEDIA_BUS_FMT_SGRBG10_DPCM8_1X8,
+	MEDIA_BUS_FMT_SRGGB10_DPCM8_1X8,
+	MEDIA_BUS_FMT_SBGGR12_1X12,
+	MEDIA_BUS_FMT_SGBRG12_1X12,
+	MEDIA_BUS_FMT_SGRBG12_1X12,
+	MEDIA_BUS_FMT_SRGGB12_1X12,
+	MEDIA_BUS_FMT_SBGGR8_1X8,
+	MEDIA_BUS_FMT_SGBRG8_1X8,
+	MEDIA_BUS_FMT_SGRBG8_1X8,
+	MEDIA_BUS_FMT_SRGGB8_1X8,
+	0,
+};
+
+static const u32 csi2_supported_codes_pad_source[] = {
+	MEDIA_BUS_FMT_Y8_1X8,
+	MEDIA_BUS_FMT_Y10_1X10,
+	MEDIA_BUS_FMT_RGB565_1X16,
+	MEDIA_BUS_FMT_RGB888_1X24,
+	MEDIA_BUS_FMT_UYVY8_1X16,
+	MEDIA_BUS_FMT_YUYV8_1X16,
+	MEDIA_BUS_FMT_VYUY8_1X16,
+	MEDIA_BUS_FMT_YUYV10_1X20,
+	MEDIA_BUS_FMT_SBGGR10_1X10,
+	MEDIA_BUS_FMT_SGBRG10_1X10,
+	MEDIA_BUS_FMT_SGRBG10_1X10,
+	MEDIA_BUS_FMT_SRGGB10_1X10,
+	MEDIA_BUS_FMT_SBGGR12_1X12,
+	MEDIA_BUS_FMT_SGBRG12_1X12,
+	MEDIA_BUS_FMT_SGRBG12_1X12,
+	MEDIA_BUS_FMT_SRGGB12_1X12,
+	MEDIA_BUS_FMT_SBGGR8_1X8,
+	MEDIA_BUS_FMT_SGBRG8_1X8,
+	MEDIA_BUS_FMT_SGRBG8_1X8,
+	MEDIA_BUS_FMT_SRGGB8_1X8,
+	0,
+};
+
+static const u32 *csi2_supported_codes[NR_OF_CSI2_PADS];
+
+static struct v4l2_subdev_internal_ops csi2_sd_internal_ops = {
+	.open = ipu_isys_subdev_open,
+	.close = ipu_isys_subdev_close,
+};
+
+int ipu_isys_csi2_get_link_freq(struct ipu_isys_csi2 *csi2, s64 *link_freq)
+{
+	struct ipu_isys_pipeline *pipe =
+		container_of(media_entity_pipeline(&csi2->asd.sd.entity),
+			     struct ipu_isys_pipeline, pipe);
+	struct v4l2_subdev *ext_sd =
+		media_entity_to_v4l2_subdev(pipe->external->entity);
+	struct device *dev = &csi2->isys->adev->dev;
+	unsigned int bpp, lanes;
+	s64 ret;
+
+	if (!ext_sd) {
+		WARN_ON(1);
+		return -ENODEV;
+	}
+
+	bpp = ipu_isys_mbus_code_to_bpp(csi2->asd.ffmt->code);
+	lanes = csi2->nlanes;
+
+	ret = v4l2_get_link_freq(ext_sd->ctrl_handler, bpp, lanes * 2);
+	if (ret < 0) {
+		dev_err(dev, "can't get link frequency (%lld)\n", ret);
+		return ret;
+	}
+
+	dev_dbg(dev, "link freq of %s is %lld\n", ext_sd->name, ret);
+	*link_freq = ret;
+
+	return 0;
+}
+
+static int subscribe_event(struct v4l2_subdev *sd, struct v4l2_fh *fh,
+			   struct v4l2_event_subscription *sub)
+{
+	struct ipu_isys_csi2 *csi2 = to_ipu_isys_csi2(sd);
+
+	dev_dbg(&csi2->isys->adev->dev, "subscribe event(type %u id %u)\n",
+		sub->type, sub->id);
+
+	switch (sub->type) {
+	case V4L2_EVENT_FRAME_SYNC:
+		return v4l2_event_subscribe(fh, sub, 10, NULL);
+	case V4L2_EVENT_CTRL:
+		return v4l2_ctrl_subscribe_event(fh, sub);
+	default:
+		return -EINVAL;
+	}
+}
+
+static const struct v4l2_subdev_core_ops csi2_sd_core_ops = {
+	.subscribe_event = subscribe_event,
+	.unsubscribe_event = v4l2_event_subdev_unsubscribe,
+};
+
+/*
+ * The input system CSI2+ receiver has several
+ * parameters affecting the receiver timings. These depend
+ * on the MIPI bus frequency F in Hz (sensor transmitter rate)
+ * as follows:
+ *	register value = (A/1e9 + B * UI) / COUNT_ACC
+ * where
+ *	UI = 1 / (2 * F) in seconds
+ *	COUNT_ACC = counter accuracy in seconds
+ *	For legacy IPU,  COUNT_ACC = 0.125 ns
+ *
+ * A and B are coefficients from the table below,
+ * depending whether the register minimum or maximum value is
+ * calculated.
+ *				       Minimum     Maximum
+ * Clock lane			       A     B     A     B
+ * reg_rx_csi_dly_cnt_termen_clane     0     0    38     0
+ * reg_rx_csi_dly_cnt_settle_clane    95    -8   300   -16
+ * Data lanes
+ * reg_rx_csi_dly_cnt_termen_dlane0    0     0    35     4
+ * reg_rx_csi_dly_cnt_settle_dlane0   85    -2   145    -6
+ * reg_rx_csi_dly_cnt_termen_dlane1    0     0    35     4
+ * reg_rx_csi_dly_cnt_settle_dlane1   85    -2   145    -6
+ * reg_rx_csi_dly_cnt_termen_dlane2    0     0    35     4
+ * reg_rx_csi_dly_cnt_settle_dlane2   85    -2   145    -6
+ * reg_rx_csi_dly_cnt_termen_dlane3    0     0    35     4
+ * reg_rx_csi_dly_cnt_settle_dlane3   85    -2   145    -6
+ *
+ * We use the minimum values of both A and B.
+ */
+
+#define DIV_SHIFT	8
+
+static uint32_t calc_timing(s32 a, int32_t b, int64_t link_freq, int32_t accinv)
+{
+	return accinv * a + (accinv * b * (500000000 >> DIV_SHIFT)
+			     / (int32_t)(link_freq >> DIV_SHIFT));
+}
+
+static int
+ipu_isys_csi2_calc_timing(struct ipu_isys_csi2 *csi2,
+			  struct ipu_isys_csi2_timing *timing, uint32_t accinv)
+{
+	__s64 link_freq;
+	int rval;
+
+	rval = ipu_isys_csi2_get_link_freq(csi2, &link_freq);
+	if (rval)
+		return rval;
+
+	timing->ctermen = calc_timing(CSI2_CSI_RX_DLY_CNT_TERMEN_CLANE_A,
+				      CSI2_CSI_RX_DLY_CNT_TERMEN_CLANE_B,
+				      link_freq, accinv);
+	timing->csettle = calc_timing(CSI2_CSI_RX_DLY_CNT_SETTLE_CLANE_A,
+				      CSI2_CSI_RX_DLY_CNT_SETTLE_CLANE_B,
+				      link_freq, accinv);
+	dev_dbg(&csi2->isys->adev->dev, "ctermen %u\n", timing->ctermen);
+	dev_dbg(&csi2->isys->adev->dev, "csettle %u\n", timing->csettle);
+
+	timing->dtermen = calc_timing(CSI2_CSI_RX_DLY_CNT_TERMEN_DLANE_A,
+				      CSI2_CSI_RX_DLY_CNT_TERMEN_DLANE_B,
+				      link_freq, accinv);
+	timing->dsettle = calc_timing(CSI2_CSI_RX_DLY_CNT_SETTLE_DLANE_A,
+				      CSI2_CSI_RX_DLY_CNT_SETTLE_DLANE_B,
+				      link_freq, accinv);
+	dev_dbg(&csi2->isys->adev->dev, "dtermen %u\n", timing->dtermen);
+	dev_dbg(&csi2->isys->adev->dev, "dsettle %u\n", timing->dsettle);
+
+	return 0;
+}
+
+#define CSI2_ACCINV	8
+
+static int set_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct ipu_isys_csi2 *csi2 = to_ipu_isys_csi2(sd);
+	struct ipu_isys_pipeline *ip =
+		to_ipu_isys_pipeline(media_entity_pipeline(&sd->entity));
+	struct ipu_isys_csi2_config *cfg;
+	struct v4l2_subdev *ext_sd;
+	struct ipu_isys_csi2_timing timing = {0};
+	unsigned int nlanes;
+	int rval;
+
+	dev_dbg(&csi2->isys->adev->dev, "csi2 s_stream %d\n", enable);
+
+	if (!ip->external->entity) {
+		WARN_ON(1);
+		return -ENODEV;
+	}
+	ext_sd = media_entity_to_v4l2_subdev(ip->external->entity);
+	cfg = v4l2_get_subdev_hostdata(ext_sd);
+
+	if (!enable) {
+		csi2->stream_count--;
+		if (csi2->stream_count)
+			return 0;
+
+		ipu_isys_csi2_set_stream(sd, timing, 0, enable);
+		return 0;
+	}
+
+	ip->has_sof = true;
+
+	if (csi2->stream_count) {
+		csi2->stream_count++;
+		return 0;
+	}
+
+	nlanes = cfg->nlanes;
+
+	dev_dbg(&csi2->isys->adev->dev, "lane nr %d.\n", nlanes);
+
+	rval = ipu_isys_csi2_calc_timing(csi2, &timing, CSI2_ACCINV);
+	if (rval)
+		return rval;
+
+	rval = ipu_isys_csi2_set_stream(sd, timing, nlanes, enable);
+	csi2->stream_count++;
+
+	return rval;
+}
+
+static void csi2_capture_done(struct ipu_isys_pipeline *ip,
+			      struct ipu_fw_isys_resp_info_abi *info)
+{
+	if (ip->interlaced && ip->isys->short_packet_source ==
+	    IPU_ISYS_SHORT_PACKET_FROM_RECEIVER) {
+		struct ipu_isys_buffer *ib;
+		unsigned long flags;
+
+		spin_lock_irqsave(&ip->short_packet_queue_lock, flags);
+		if (!list_empty(&ip->short_packet_active)) {
+			ib = list_last_entry(&ip->short_packet_active,
+					     struct ipu_isys_buffer, head);
+			list_move(&ib->head, &ip->short_packet_incoming);
+		}
+		spin_unlock_irqrestore(&ip->short_packet_queue_lock, flags);
+	}
+}
+
+static int csi2_link_validate(struct media_link *link)
+{
+	struct media_pipeline *media_pipe;
+	struct ipu_isys_csi2 *csi2;
+	struct ipu_isys_pipeline *ip;
+	int rval;
+
+	if (!link->sink->entity || !link->source->entity)
+		return -EINVAL;
+	media_pipe = media_entity_pipeline(link->sink->entity);
+	if (!media_pipe)
+		return -EINVAL;
+	csi2 =
+	    to_ipu_isys_csi2(media_entity_to_v4l2_subdev(link->sink->entity));
+
+	ip = to_ipu_isys_pipeline(media_pipe);
+	csi2->receiver_errors = 0;
+	ip->csi2 = csi2;
+	ipu_isys_video_add_capture_done(ip, csi2_capture_done);
+
+	rval = v4l2_subdev_link_validate(link);
+	if (rval)
+		return rval;
+
+	if (!v4l2_ctrl_g_ctrl(csi2->store_csi2_header)) {
+		struct media_pad *remote_pad =
+		    media_pad_remote_pad_first(&csi2->asd.pad[CSI2_PAD_SOURCE]);
+
+		if (remote_pad &&
+		    is_media_entity_v4l2_subdev(remote_pad->entity)) {
+			dev_err(&csi2->isys->adev->dev,
+				"CSI2 BE requires CSI2 headers.\n");
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
+static const struct v4l2_subdev_video_ops csi2_sd_video_ops = {
+	.s_stream = set_stream,
+};
+
+static int ipu_isys_csi2_get_fmt(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_state *state,
+				 struct v4l2_subdev_format *fmt)
+{
+	return ipu_isys_subdev_get_ffmt(sd, state, fmt);
+}
+
+static int ipu_isys_csi2_set_fmt(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_state *state,
+				 struct v4l2_subdev_format *fmt)
+{
+	return ipu_isys_subdev_set_ffmt(sd, state, fmt);
+}
+
+static int __subdev_link_validate(struct v4l2_subdev *sd,
+				  struct media_link *link,
+				  struct v4l2_subdev_format *source_fmt,
+				  struct v4l2_subdev_format *sink_fmt)
+{
+	struct ipu_isys_pipeline *ip =
+		to_ipu_isys_pipeline(media_entity_pipeline(&sd->entity));
+
+	if (source_fmt->format.field == V4L2_FIELD_ALTERNATE)
+		ip->interlaced = true;
+
+	return ipu_isys_subdev_link_validate(sd, link, source_fmt, sink_fmt);
+}
+
+static const struct v4l2_subdev_pad_ops csi2_sd_pad_ops = {
+	.link_validate = __subdev_link_validate,
+	.get_fmt = ipu_isys_csi2_get_fmt,
+	.set_fmt = ipu_isys_csi2_set_fmt,
+	.enum_mbus_code = ipu_isys_subdev_enum_mbus_code,
+};
+
+static struct v4l2_subdev_ops csi2_sd_ops = {
+	.core = &csi2_sd_core_ops,
+	.video = &csi2_sd_video_ops,
+	.pad = &csi2_sd_pad_ops,
+};
+
+static struct media_entity_operations csi2_entity_ops = {
+	.link_validate = csi2_link_validate,
+};
+
+static void csi2_set_ffmt(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_state *state,
+			  struct v4l2_subdev_format *fmt)
+{
+	enum isys_subdev_prop_tgt tgt = IPU_ISYS_SUBDEV_PROP_TGT_SINK_FMT;
+	struct v4l2_mbus_framefmt *ffmt =
+		__ipu_isys_get_ffmt(sd, state, fmt->pad,
+				    fmt->which);
+
+	if (fmt->format.field != V4L2_FIELD_ALTERNATE)
+		fmt->format.field = V4L2_FIELD_NONE;
+
+	if (fmt->pad == CSI2_PAD_SINK) {
+		*ffmt = fmt->format;
+		ipu_isys_subdev_fmt_propagate(sd, state, &fmt->format, NULL,
+					      tgt, fmt->pad, fmt->which);
+		return;
+	}
+
+	if (sd->entity.pads[fmt->pad].flags & MEDIA_PAD_FL_SOURCE) {
+		ffmt->width = fmt->format.width;
+		ffmt->height = fmt->format.height;
+		ffmt->field = fmt->format.field;
+		ffmt->code =
+		    ipu_isys_subdev_code_to_uncompressed(fmt->format.code);
+		return;
+	}
+
+	WARN_ON(1);
+}
+
+static const struct ipu_isys_pixelformat *
+csi2_try_fmt(struct ipu_isys_video *av,
+	     struct v4l2_pix_format_mplane *mpix)
+{
+	struct media_link *link = list_first_entry(&av->vdev.entity.links,
+						   struct media_link, list);
+	struct v4l2_subdev *sd =
+	    media_entity_to_v4l2_subdev(link->source->entity);
+	struct ipu_isys_csi2 *csi2;
+
+	if (!sd)
+		return NULL;
+
+	csi2 = to_ipu_isys_csi2(sd);
+
+	return ipu_isys_video_try_fmt_vid_mplane(av, mpix,
+				v4l2_ctrl_g_ctrl(csi2->store_csi2_header));
+}
+
+void ipu_isys_csi2_cleanup(struct ipu_isys_csi2 *csi2)
+{
+	if (!csi2->isys)
+		return;
+
+	v4l2_device_unregister_subdev(&csi2->asd.sd);
+	ipu_isys_subdev_cleanup(&csi2->asd);
+	ipu_isys_video_cleanup(&csi2->av);
+	csi2->isys = NULL;
+}
+
+static void csi_ctrl_init(struct v4l2_subdev *sd)
+{
+	struct ipu_isys_csi2 *csi2 = to_ipu_isys_csi2(sd);
+
+	static const struct v4l2_ctrl_config cfg = {
+		.id = V4L2_CID_IPU_STORE_CSI2_HEADER,
+		.name = "Store CSI-2 Headers",
+		.type = V4L2_CTRL_TYPE_BOOLEAN,
+		.min = 0,
+		.max = 1,
+		.step = 1,
+		.def = 1,
+	};
+
+	csi2->store_csi2_header = v4l2_ctrl_new_custom(&csi2->asd.ctrl_handler,
+						       &cfg, NULL);
+}
+
+int ipu_isys_csi2_init(struct ipu_isys_csi2 *csi2,
+		       struct ipu_isys *isys,
+		       void __iomem *base, unsigned int index)
+{
+	struct v4l2_subdev_format fmt = {
+		.which = V4L2_SUBDEV_FORMAT_ACTIVE,
+		.pad = CSI2_PAD_SINK,
+		.format = {
+			   .width = 4096,
+			   .height = 3072,
+			  },
+	};
+	int i, rval, src;
+
+	dev_dbg(&isys->adev->dev, "csi-%d base = 0x%lx\n", index,
+		(unsigned long)base);
+	csi2->isys = isys;
+	csi2->base = base;
+	csi2->index = index;
+
+	csi2->asd.sd.entity.ops = &csi2_entity_ops;
+	csi2->asd.ctrl_init = csi_ctrl_init;
+	csi2->asd.isys = isys;
+	init_completion(&csi2->eof_completion);
+	csi2->stream_count = 0;
+	rval = ipu_isys_subdev_init(&csi2->asd, &csi2_sd_ops, 0,
+				    NR_OF_CSI2_PADS,
+				    NR_OF_CSI2_SOURCE_PADS,
+				    NR_OF_CSI2_SINK_PADS,
+				    0);
+	if (rval)
+		goto fail;
+
+	csi2->asd.pad[CSI2_PAD_SINK].flags = MEDIA_PAD_FL_SINK
+		| MEDIA_PAD_FL_MUST_CONNECT;
+	csi2->asd.pad[CSI2_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+
+	src = index;
+	csi2->asd.source = IPU_FW_ISYS_STREAM_SRC_CSI2_PORT0 + src;
+	csi2_supported_codes[CSI2_PAD_SINK] = csi2_supported_codes_pad_sink;
+
+	for (i = 0; i < NR_OF_CSI2_SOURCE_PADS; i++)
+		csi2_supported_codes[i + 1] = csi2_supported_codes_pad_source;
+	csi2->asd.supported_codes = csi2_supported_codes;
+	csi2->asd.set_ffmt = csi2_set_ffmt;
+
+	csi2->asd.sd.flags |= V4L2_SUBDEV_FL_HAS_EVENTS;
+	csi2->asd.sd.internal_ops = &csi2_sd_internal_ops;
+	snprintf(csi2->asd.sd.name, sizeof(csi2->asd.sd.name),
+		 IPU_ISYS_ENTITY_PREFIX " CSI-2 %u", index);
+	v4l2_set_subdevdata(&csi2->asd.sd, &csi2->asd);
+
+	rval = v4l2_device_register_subdev(&isys->v4l2_dev, &csi2->asd.sd);
+	if (rval) {
+		dev_info(&isys->adev->dev, "can't register v4l2 subdev\n");
+		goto fail;
+	}
+
+	mutex_lock(&csi2->asd.mutex);
+	__ipu_isys_subdev_set_ffmt(&csi2->asd.sd, NULL, &fmt);
+	mutex_unlock(&csi2->asd.mutex);
+
+	snprintf(csi2->av.vdev.name, sizeof(csi2->av.vdev.name),
+		 IPU_ISYS_ENTITY_PREFIX " CSI-2 %u capture", index);
+	csi2->av.isys = isys;
+	csi2->av.aq.css_pin_type = IPU_FW_ISYS_PIN_TYPE_MIPI;
+	csi2->av.pfmts = ipu_isys_pfmts_packed;
+	csi2->av.try_fmt_vid_mplane = csi2_try_fmt;
+	csi2->av.prepare_fw_stream =
+		ipu_isys_prepare_fw_cfg_default;
+	csi2->av.packed = true;
+	csi2->av.line_header_length =
+		IPU_ISYS_CSI2_LONG_PACKET_HEADER_SIZE;
+	csi2->av.line_footer_length =
+		IPU_ISYS_CSI2_LONG_PACKET_FOOTER_SIZE;
+	csi2->av.aq.buf_prepare = ipu_isys_buf_prepare;
+	csi2->av.aq.fill_frame_buff_set_pin =
+	ipu_isys_buffer_to_fw_frame_buff_pin;
+	csi2->av.aq.link_fmt_validate =
+		ipu_isys_link_fmt_validate;
+	csi2->av.aq.vbq.buf_struct_size =
+		sizeof(struct ipu_isys_video_buffer);
+
+	rval = ipu_isys_video_init(&csi2->av,
+				   &csi2->asd.sd.entity,
+				   CSI2_PAD_SOURCE,
+				   MEDIA_PAD_FL_SINK, 0);
+	if (rval) {
+		dev_info(&isys->adev->dev, "can't init video node\n");
+		goto fail;
+	}
+
+	return 0;
+
+fail:
+	ipu_isys_csi2_cleanup(csi2);
+
+	return rval;
+}
+
+void ipu_isys_csi2_sof_event(struct ipu_isys_csi2 *csi2, unsigned int vc)
+{
+	struct ipu_isys_pipeline *ip = NULL;
+	struct v4l2_event ev = {
+		.type = V4L2_EVENT_FRAME_SYNC,
+	};
+	struct video_device *vdev = csi2->asd.sd.devnode;
+	unsigned long flags;
+	unsigned int i;
+
+	spin_lock_irqsave(&csi2->isys->lock, flags);
+	csi2->in_frame[vc] = true;
+
+	for (i = 0; i < IPU_ISYS_MAX_STREAMS; i++) {
+		if (csi2->isys->pipes[i] &&
+		    csi2->isys->pipes[i]->vc == vc &&
+		    csi2->isys->pipes[i]->csi2 == csi2) {
+			ip = csi2->isys->pipes[i];
+			break;
+		}
+	}
+
+	/* Pipe already vanished */
+	if (!ip) {
+		spin_unlock_irqrestore(&csi2->isys->lock, flags);
+		return;
+	}
+
+	ev.u.frame_sync.frame_sequence = atomic_inc_return(&ip->sequence) - 1;
+	spin_unlock_irqrestore(&csi2->isys->lock, flags);
+
+	v4l2_event_queue(vdev, &ev);
+	dev_dbg(&csi2->isys->adev->dev,
+		"sof_event::csi2-%i CPU-timestamp:%lld, sequence:%i, vc:%d\n",
+		csi2->index, ktime_get_ns(), ev.u.frame_sync.frame_sequence, vc);
+}
+
+void ipu_isys_csi2_eof_event(struct ipu_isys_csi2 *csi2, unsigned int vc)
+{
+	struct ipu_isys_pipeline *ip = NULL;
+	unsigned long flags;
+	unsigned int i;
+	u32 frame_sequence;
+
+	spin_lock_irqsave(&csi2->isys->lock, flags);
+	csi2->in_frame[vc] = false;
+	if (csi2->wait_for_sync[vc])
+		complete(&csi2->eof_completion);
+
+	for (i = 0; i < IPU_ISYS_MAX_STREAMS; i++) {
+		if (csi2->isys->pipes[i] &&
+		    csi2->isys->pipes[i]->vc == vc &&
+		    csi2->isys->pipes[i]->csi2 == csi2) {
+			ip = csi2->isys->pipes[i];
+			break;
+		}
+	}
+
+	if (ip) {
+		frame_sequence = atomic_read(&ip->sequence);
+		spin_unlock_irqrestore(&csi2->isys->lock, flags);
+
+		dev_dbg(&csi2->isys->adev->dev,
+			"eof_event: csi2-%i sequence: %i, vc: %d\n",
+			csi2->index, frame_sequence, vc);
+		return;
+	}
+
+	spin_unlock_irqrestore(&csi2->isys->lock, flags);
+}
+
+/* Call this function only _after_ the sensor has been stopped */
+void ipu_isys_csi2_wait_last_eof(struct ipu_isys_csi2 *csi2)
+{
+	unsigned long flags, tout;
+	unsigned int i;
+
+	for (i = 0; i < NR_OF_CSI2_VC; i++) {
+		spin_lock_irqsave(&csi2->isys->lock, flags);
+
+		if (!csi2->in_frame[i]) {
+			spin_unlock_irqrestore(&csi2->isys->lock, flags);
+			continue;
+		}
+
+		reinit_completion(&csi2->eof_completion);
+		csi2->wait_for_sync[i] = true;
+		spin_unlock_irqrestore(&csi2->isys->lock, flags);
+		tout = wait_for_completion_timeout(&csi2->eof_completion,
+						   IPU_EOF_TIMEOUT_JIFFIES);
+		if (!tout)
+			dev_err(&csi2->isys->adev->dev,
+				"csi2-%d: timeout at sync to eof of vc %d\n",
+				csi2->index, i);
+		csi2->wait_for_sync[i] = false;
+	}
+}
+
+struct ipu_isys_buffer *
+ipu_isys_csi2_get_short_packet_buffer(struct ipu_isys_pipeline *ip,
+				      struct ipu_isys_buffer_list *bl)
+{
+	struct ipu_isys_buffer *ib;
+	struct ipu_isys_private_buffer *pb;
+	struct ipu_isys_mipi_packet_header *ph;
+	unsigned long flags;
+
+	spin_lock_irqsave(&ip->short_packet_queue_lock, flags);
+	if (list_empty(&ip->short_packet_incoming)) {
+		spin_unlock_irqrestore(&ip->short_packet_queue_lock, flags);
+		return NULL;
+	}
+	ib = list_last_entry(&ip->short_packet_incoming,
+			     struct ipu_isys_buffer, head);
+	pb = ipu_isys_buffer_to_private_buffer(ib);
+	ph = (struct ipu_isys_mipi_packet_header *)pb->buffer;
+
+	/* Fill the packet header with magic number. */
+	ph->word_count = 0xffff;
+	ph->dtype = 0xff;
+
+	dma_sync_single_for_cpu(&ip->isys->adev->dev, pb->dma_addr,
+				sizeof(*ph), DMA_BIDIRECTIONAL);
+	spin_unlock_irqrestore(&ip->short_packet_queue_lock, flags);
+	list_move(&ib->head, &bl->head);
+
+	return ib;
+}
Index: b/drivers/media/pci/intel/ipu-isys-csi2.h
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu-isys-csi2.h
@@ -0,0 +1,166 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2013 - 2022 Intel Corporation */
+
+#ifndef IPU_ISYS_CSI2_H
+#define IPU_ISYS_CSI2_H
+
+#include <media/media-entity.h>
+#include <media/v4l2-device.h>
+
+#include "ipu-isys-queue.h"
+#include "ipu-isys-subdev.h"
+#include "ipu-isys-video.h"
+#include "ipu-platform-isys.h"
+
+struct ipu_isys_csi2_timing;
+struct ipu_isys_csi2_pdata;
+struct ipu_isys;
+
+#define NR_OF_CSI2_SINK_PADS		1
+#define CSI2_PAD_SINK			0
+#define NR_OF_CSI2_SOURCE_PADS		1
+#define CSI2_PAD_SOURCE			1
+#define NR_OF_CSI2_PADS	(NR_OF_CSI2_SINK_PADS + NR_OF_CSI2_SOURCE_PADS)
+
+#define IPU_ISYS_SHORT_PACKET_BUFFER_NUM	VIDEO_MAX_FRAME
+#define IPU_ISYS_SHORT_PACKET_WIDTH	32
+#define IPU_ISYS_SHORT_PACKET_FRAME_PACKETS	2
+#define IPU_ISYS_SHORT_PACKET_EXTRA_PACKETS	64
+#define IPU_ISYS_SHORT_PACKET_UNITSIZE	8
+#define IPU_ISYS_SHORT_PACKET_GENERAL_DT	0
+#define IPU_ISYS_SHORT_PACKET_PT		0
+#define IPU_ISYS_SHORT_PACKET_FT		0
+
+#define IPU_ISYS_SHORT_PACKET_STRIDE \
+	(IPU_ISYS_SHORT_PACKET_WIDTH * \
+	IPU_ISYS_SHORT_PACKET_UNITSIZE)
+#define IPU_ISYS_SHORT_PACKET_NUM(num_lines) \
+	((num_lines) * 2 + IPU_ISYS_SHORT_PACKET_FRAME_PACKETS + \
+	IPU_ISYS_SHORT_PACKET_EXTRA_PACKETS)
+#define IPU_ISYS_SHORT_PACKET_PKT_LINES(num_lines) \
+	DIV_ROUND_UP(IPU_ISYS_SHORT_PACKET_NUM(num_lines) * \
+	IPU_ISYS_SHORT_PACKET_UNITSIZE, \
+	IPU_ISYS_SHORT_PACKET_STRIDE)
+#define IPU_ISYS_SHORT_PACKET_BUF_SIZE(num_lines) \
+	(IPU_ISYS_SHORT_PACKET_WIDTH * \
+	IPU_ISYS_SHORT_PACKET_PKT_LINES(num_lines) * \
+	IPU_ISYS_SHORT_PACKET_UNITSIZE)
+
+#define IPU_ISYS_SHORT_PACKET_TRACE_MSG_NUMBER	256
+#define IPU_ISYS_SHORT_PACKET_TRACE_MSG_SIZE	16
+#define IPU_ISYS_SHORT_PACKET_TRACE_BUFFER_SIZE \
+	(IPU_ISYS_SHORT_PACKET_TRACE_MSG_NUMBER * \
+	IPU_ISYS_SHORT_PACKET_TRACE_MSG_SIZE)
+
+#define IPU_ISYS_SHORT_PACKET_FROM_RECEIVER	0
+#define IPU_ISYS_SHORT_PACKET_FROM_TUNIT		1
+
+#define IPU_ISYS_SHORT_PACKET_TRACE_MAX_TIMESHIFT 100
+#define IPU_ISYS_SHORT_PACKET_TRACE_EVENT_MASK	0x2082
+#define IPU_SKEW_CAL_LIMIT_HZ (1500000000ul / 2)
+
+#define CSI2_CSI_RX_DLY_CNT_TERMEN_CLANE_A		0
+#define CSI2_CSI_RX_DLY_CNT_TERMEN_CLANE_B		0
+#define CSI2_CSI_RX_DLY_CNT_SETTLE_CLANE_A		95
+#define CSI2_CSI_RX_DLY_CNT_SETTLE_CLANE_B		-8
+
+#define CSI2_CSI_RX_DLY_CNT_TERMEN_DLANE_A		0
+#define CSI2_CSI_RX_DLY_CNT_TERMEN_DLANE_B		0
+#define CSI2_CSI_RX_DLY_CNT_SETTLE_DLANE_A		85
+#define CSI2_CSI_RX_DLY_CNT_SETTLE_DLANE_B		-2
+
+#define IPU_EOF_TIMEOUT 300
+#define IPU_EOF_TIMEOUT_JIFFIES msecs_to_jiffies(IPU_EOF_TIMEOUT)
+
+/*
+ * struct ipu_isys_csi2
+ *
+ * @nlanes: number of lanes in the receiver
+ */
+struct ipu_isys_csi2 {
+	struct ipu_isys_csi2_pdata *pdata;
+	struct ipu_isys *isys;
+	struct ipu_isys_subdev asd;
+	struct ipu_isys_video av;
+	struct completion eof_completion;
+
+	void __iomem *base;
+	u32 receiver_errors;
+	unsigned int nlanes;
+	unsigned int index;
+	atomic_t sof_sequence;
+	bool in_frame[NR_OF_CSI2_VC];
+	bool wait_for_sync[NR_OF_CSI2_VC];
+
+	unsigned int stream_count;
+
+	struct v4l2_ctrl *store_csi2_header;
+};
+
+struct ipu_isys_csi2_timing {
+	u32 ctermen;
+	u32 csettle;
+	u32 dtermen;
+	u32 dsettle;
+};
+
+/*
+ * This structure defines the MIPI packet header output
+ * from IPU MIPI receiver. Due to hardware conversion,
+ * this structure is not the same as defined in CSI-2 spec.
+ */
+struct ipu_isys_mipi_packet_header {
+	u32 word_count:16, dtype:13, sync:2, stype:1;
+	u32 sid:4, port_id:4, reserved:23, odd_even:1;
+} __packed;
+
+/*
+ * This structure defines the trace message content
+ * for CSI2 receiver monitor messages.
+ */
+struct ipu_isys_csi2_monitor_message {
+	u64 fe:1,
+	    fs:1,
+	    pe:1,
+	    ps:1,
+	    le:1,
+	    ls:1,
+	    reserved1:2,
+	    sequence:2,
+	    reserved2:2,
+	    flash_shutter:4,
+	    error_cause:12,
+	    fifo_overrun:1,
+	    crc_error:2,
+	    reserved3:1,
+	    timestamp_l:16,
+	    port:4, vc:2, reserved4:2, frame_sync:4, reserved5:4;
+	u64 reserved6:3,
+	    cmd:2, reserved7:1, monitor_id:7, reserved8:1, timestamp_h:50;
+} __packed;
+
+#define to_ipu_isys_csi2(sd) container_of(to_ipu_isys_subdev(sd), \
+					struct ipu_isys_csi2, asd)
+
+int ipu_isys_csi2_get_link_freq(struct ipu_isys_csi2 *csi2, __s64 *link_freq);
+int ipu_isys_csi2_init(struct ipu_isys_csi2 *csi2,
+		       struct ipu_isys *isys,
+		       void __iomem *base, unsigned int index);
+void ipu_isys_csi2_cleanup(struct ipu_isys_csi2 *csi2);
+struct ipu_isys_buffer *
+ipu_isys_csi2_get_short_packet_buffer(struct ipu_isys_pipeline *ip,
+				      struct ipu_isys_buffer_list *bl);
+void ipu_isys_csi2_sof_event(struct ipu_isys_csi2 *csi2, unsigned int vc);
+void ipu_isys_csi2_eof_event(struct ipu_isys_csi2 *csi2, unsigned int vc);
+void ipu_isys_csi2_wait_last_eof(struct ipu_isys_csi2 *csi2);
+
+/* interface for platform specific */
+int ipu_isys_csi2_set_stream(struct v4l2_subdev *sd,
+			     struct ipu_isys_csi2_timing timing,
+			     unsigned int nlanes, int enable);
+unsigned int ipu_isys_csi2_get_current_field(struct ipu_isys_pipeline *ip,
+					     unsigned int *timestamp);
+void ipu_isys_csi2_isr(struct ipu_isys_csi2 *csi2);
+void ipu_isys_csi2_error(struct ipu_isys_csi2 *csi2);
+
+#endif /* IPU_ISYS_CSI2_H */
Index: b/drivers/media/pci/intel/ipu-isys-media.h
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu-isys-media.h
@@ -0,0 +1,77 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2016 - 2020 Intel Corporation */
+
+#ifndef IPU_ISYS_MEDIA_H
+#define IPU_ISYS_MEDIA_H
+
+#include <linux/slab.h>
+#include <media/media-entity.h>
+
+struct __packed media_request_cmd {
+	__u32 cmd;
+	__u32 request;
+	__u32 flags;
+};
+
+struct __packed media_event_request_complete {
+	__u32 id;
+};
+
+#define MEDIA_EVENT_TYPE_REQUEST_COMPLETE	1
+
+struct __packed media_event {
+	__u32 type;
+	__u32 sequence;
+	__u32 reserved[4];
+
+	union {
+		struct media_event_request_complete req_complete;
+	};
+};
+
+enum media_device_request_state {
+	MEDIA_DEVICE_REQUEST_STATE_IDLE,
+	MEDIA_DEVICE_REQUEST_STATE_QUEUED,
+	MEDIA_DEVICE_REQUEST_STATE_DELETED,
+	MEDIA_DEVICE_REQUEST_STATE_COMPLETE,
+};
+
+struct media_kevent {
+	struct list_head list;
+	struct media_event ev;
+};
+
+struct media_device_request {
+	u32 id;
+	struct media_device *mdev;
+	struct file *filp;
+	struct media_kevent *kev;
+	struct kref kref;
+	struct list_head list;
+	struct list_head fh_list;
+	enum media_device_request_state state;
+	struct list_head data;
+	u32 flags;
+};
+
+static inline struct media_device_request *
+media_device_request_find(struct media_device *mdev, u16 reqid)
+{
+	return NULL;
+}
+
+static inline void media_device_request_get(struct media_device_request *req)
+{
+}
+
+static inline void media_device_request_put(struct media_device_request *req)
+{
+}
+
+static inline void
+media_device_request_complete(struct media_device *mdev,
+			      struct media_device_request *req)
+{
+}
+
+#endif /* IPU_ISYS_MEDIA_H */
Index: b/drivers/media/pci/intel/ipu-isys-queue.c
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu-isys-queue.c
@@ -0,0 +1,1358 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) 2013 - 2020 Intel Corporation
+
+#include <linux/completion.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/delay.h>
+
+#include <media/media-entity.h>
+#include <media/videobuf2-dma-contig.h>
+#include <media/v4l2-ioctl.h>
+
+#include "ipu.h"
+#include "ipu-bus.h"
+#include "ipu-cpd.h"
+#include "ipu-buttress.h"
+#include "ipu-isys.h"
+#include "ipu-isys-csi2.h"
+#include "ipu-isys-video.h"
+
+static bool wall_clock_ts_on;
+module_param(wall_clock_ts_on, bool, 0660);
+MODULE_PARM_DESC(wall_clock_ts_on, "Timestamp based on REALTIME clock");
+
+static int queue_setup(struct vb2_queue *q,
+		       unsigned int *num_buffers, unsigned int *num_planes,
+		       unsigned int sizes[],
+		       struct device *alloc_devs[])
+{
+	struct ipu_isys_queue *aq = vb2_queue_to_ipu_isys_queue(q);
+	struct ipu_isys_video *av = ipu_isys_queue_to_video(aq);
+	bool use_fmt = false;
+	unsigned int i;
+
+	/* num_planes == 0: we're being called through VIDIOC_REQBUFS */
+	if (!*num_planes) {
+		use_fmt = true;
+		*num_planes = av->mpix.num_planes;
+	}
+
+	for (i = 0; i < *num_planes; i++) {
+		if (use_fmt)
+			sizes[i] = av->mpix.plane_fmt[i].sizeimage;
+		alloc_devs[i] = aq->dev;
+		dev_dbg(&av->isys->adev->dev,
+			"%s: queue setup: plane %d size %u\n",
+			av->vdev.name, i, sizes[i]);
+	}
+
+	return 0;
+}
+
+static void ipu_isys_queue_lock(struct vb2_queue *q)
+{
+	struct ipu_isys_queue *aq = vb2_queue_to_ipu_isys_queue(q);
+	struct ipu_isys_video *av = ipu_isys_queue_to_video(aq);
+
+	dev_dbg(&av->isys->adev->dev, "%s: queue lock\n", av->vdev.name);
+	mutex_lock(&av->mutex);
+}
+
+static void ipu_isys_queue_unlock(struct vb2_queue *q)
+{
+	struct ipu_isys_queue *aq = vb2_queue_to_ipu_isys_queue(q);
+	struct ipu_isys_video *av = ipu_isys_queue_to_video(aq);
+
+	dev_dbg(&av->isys->adev->dev, "%s: queue unlock\n", av->vdev.name);
+	mutex_unlock(&av->mutex);
+}
+
+static int buf_init(struct vb2_buffer *vb)
+{
+	struct ipu_isys_queue *aq = vb2_queue_to_ipu_isys_queue(vb->vb2_queue);
+	struct ipu_isys_video *av = ipu_isys_queue_to_video(aq);
+
+	dev_dbg(&av->isys->adev->dev, "buffer: %s: %s\n", av->vdev.name,
+		__func__);
+
+	if (aq->buf_init)
+		return aq->buf_init(vb);
+
+	return 0;
+}
+
+int ipu_isys_buf_prepare(struct vb2_buffer *vb)
+{
+	struct ipu_isys_queue *aq = vb2_queue_to_ipu_isys_queue(vb->vb2_queue);
+	struct ipu_isys_video *av = ipu_isys_queue_to_video(aq);
+
+	dev_dbg(&av->isys->adev->dev,
+		"buffer: %s: configured size %u, buffer size %lu\n",
+		av->vdev.name,
+		av->mpix.plane_fmt[0].sizeimage, vb2_plane_size(vb, 0));
+
+	if (av->mpix.plane_fmt[0].sizeimage > vb2_plane_size(vb, 0))
+		return -EINVAL;
+
+	vb2_set_plane_payload(vb, 0, av->mpix.plane_fmt[0].bytesperline *
+			      av->mpix.height);
+	vb->planes[0].data_offset = av->line_header_length / BITS_PER_BYTE;
+
+	return 0;
+}
+
+static int buf_prepare(struct vb2_buffer *vb)
+{
+	struct ipu_isys_queue *aq = vb2_queue_to_ipu_isys_queue(vb->vb2_queue);
+	struct ipu_isys_video *av = ipu_isys_queue_to_video(aq);
+	int rval;
+
+	if (av->isys->adev->isp->flr_done)
+		return -EIO;
+
+	rval = aq->buf_prepare(vb);
+	return rval;
+}
+
+static void buf_finish(struct vb2_buffer *vb)
+{
+	struct ipu_isys_queue *aq = vb2_queue_to_ipu_isys_queue(vb->vb2_queue);
+	struct ipu_isys_video *av = ipu_isys_queue_to_video(aq);
+
+	dev_dbg(&av->isys->adev->dev, "buffer: %s: %s\n", av->vdev.name,
+		__func__);
+
+}
+
+static void buf_cleanup(struct vb2_buffer *vb)
+{
+	struct ipu_isys_queue *aq = vb2_queue_to_ipu_isys_queue(vb->vb2_queue);
+	struct ipu_isys_video *av = ipu_isys_queue_to_video(aq);
+
+	dev_dbg(&av->isys->adev->dev, "buffer: %s: %s\n", av->vdev.name,
+		__func__);
+
+	if (aq->buf_cleanup)
+		aq->buf_cleanup(vb);
+}
+
+/*
+ * Queue a buffer list back to incoming or active queues. The buffers
+ * are removed from the buffer list.
+ */
+void ipu_isys_buffer_list_queue(struct ipu_isys_buffer_list *bl,
+				unsigned long op_flags,
+				enum vb2_buffer_state state)
+{
+	struct ipu_isys_buffer *ib, *ib_safe;
+	unsigned long flags;
+	bool first = true;
+
+	if (!bl)
+		return;
+
+	WARN_ON(!bl->nbufs);
+	WARN_ON(op_flags & IPU_ISYS_BUFFER_LIST_FL_ACTIVE &&
+		op_flags & IPU_ISYS_BUFFER_LIST_FL_INCOMING);
+
+	list_for_each_entry_safe(ib, ib_safe, &bl->head, head) {
+		struct ipu_isys_video *av;
+
+		if (ib->type == IPU_ISYS_VIDEO_BUFFER) {
+			struct vb2_buffer *vb =
+			    ipu_isys_buffer_to_vb2_buffer(ib);
+			struct ipu_isys_queue *aq =
+			    vb2_queue_to_ipu_isys_queue(vb->vb2_queue);
+
+			av = ipu_isys_queue_to_video(aq);
+			spin_lock_irqsave(&aq->lock, flags);
+			list_del(&ib->head);
+			if (op_flags & IPU_ISYS_BUFFER_LIST_FL_ACTIVE)
+				list_add(&ib->head, &aq->active);
+			else if (op_flags & IPU_ISYS_BUFFER_LIST_FL_INCOMING)
+				list_add_tail(&ib->head, &aq->incoming);
+			spin_unlock_irqrestore(&aq->lock, flags);
+
+			if (op_flags & IPU_ISYS_BUFFER_LIST_FL_SET_STATE)
+				vb2_buffer_done(vb, state);
+		} else if (ib->type == IPU_ISYS_SHORT_PACKET_BUFFER) {
+			struct ipu_isys_private_buffer *pb =
+			    ipu_isys_buffer_to_private_buffer(ib);
+			struct ipu_isys_pipeline *ip = pb->ip;
+
+			av = container_of(ip, struct ipu_isys_video, ip);
+			spin_lock_irqsave(&ip->short_packet_queue_lock, flags);
+			list_del(&ib->head);
+			if (op_flags & IPU_ISYS_BUFFER_LIST_FL_ACTIVE)
+				list_add(&ib->head, &ip->short_packet_active);
+			else if (op_flags & IPU_ISYS_BUFFER_LIST_FL_INCOMING)
+				list_add(&ib->head, &ip->short_packet_incoming);
+			spin_unlock_irqrestore(&ip->short_packet_queue_lock,
+					       flags);
+		} else {
+			WARN_ON(1);
+			return;
+		}
+
+		if (first) {
+			dev_dbg(&av->isys->adev->dev,
+				"queue buf list %p flags %lx, s %d, %d bufs\n",
+				bl, op_flags, state, bl->nbufs);
+			first = false;
+		}
+
+		bl->nbufs--;
+	}
+
+	WARN_ON(bl->nbufs);
+}
+
+/*
+ * flush_firmware_streamon_fail() - Flush in cases where requests may
+ * have been queued to firmware and the *firmware streamon fails for a
+ * reason or another.
+ */
+static void flush_firmware_streamon_fail(struct ipu_isys_pipeline *ip)
+{
+	struct ipu_isys_video *pipe_av =
+	    container_of(ip, struct ipu_isys_video, ip);
+	struct ipu_isys_queue *aq;
+	unsigned long flags;
+
+	lockdep_assert_held(&pipe_av->mutex);
+
+	list_for_each_entry(aq, &ip->queues, node) {
+		struct ipu_isys_video *av = ipu_isys_queue_to_video(aq);
+		struct ipu_isys_buffer *ib, *ib_safe;
+
+		spin_lock_irqsave(&aq->lock, flags);
+		list_for_each_entry_safe(ib, ib_safe, &aq->active, head) {
+			struct vb2_buffer *vb =
+			    ipu_isys_buffer_to_vb2_buffer(ib);
+
+			list_del(&ib->head);
+			if (av->streaming) {
+				dev_dbg(&av->isys->adev->dev,
+					"%s: queue buffer %u back to incoming\n",
+					av->vdev.name,
+					vb->index);
+				/* Queue already streaming, return to driver. */
+				list_add(&ib->head, &aq->incoming);
+				continue;
+			}
+			/* Queue not yet streaming, return to user. */
+			dev_dbg(&av->isys->adev->dev,
+				"%s: return %u back to videobuf2\n",
+				av->vdev.name,
+				vb->index);
+			vb2_buffer_done(ipu_isys_buffer_to_vb2_buffer(ib),
+					VB2_BUF_STATE_QUEUED);
+		}
+		spin_unlock_irqrestore(&aq->lock, flags);
+	}
+}
+
+/*
+ * Attempt obtaining a buffer list from the incoming queues, a list of
+ * buffers that contains one entry from each video buffer queue. If
+ * all queues have no buffers, the buffers that were already dequeued
+ * are returned to their queues.
+ */
+static int buffer_list_get(struct ipu_isys_pipeline *ip,
+			   struct ipu_isys_buffer_list *bl)
+{
+	struct ipu_isys_queue *aq;
+	struct ipu_isys_buffer *ib;
+	unsigned long flags;
+	int ret = 0;
+
+	bl->nbufs = 0;
+	INIT_LIST_HEAD(&bl->head);
+
+	list_for_each_entry(aq, &ip->queues, node) {
+		struct ipu_isys_buffer *ib;
+
+		spin_lock_irqsave(&aq->lock, flags);
+		if (list_empty(&aq->incoming)) {
+			spin_unlock_irqrestore(&aq->lock, flags);
+			ret = -ENODATA;
+			goto error;
+		}
+
+		ib = list_last_entry(&aq->incoming,
+				     struct ipu_isys_buffer, head);
+		if (ib->req) {
+			spin_unlock_irqrestore(&aq->lock, flags);
+			ret = -ENODATA;
+			goto error;
+		}
+
+		dev_dbg(&ip->isys->adev->dev, "buffer: %s: buffer %u\n",
+			ipu_isys_queue_to_video(aq)->vdev.name,
+			ipu_isys_buffer_to_vb2_buffer(ib)->index
+		    );
+		list_del(&ib->head);
+		list_add(&ib->head, &bl->head);
+		spin_unlock_irqrestore(&aq->lock, flags);
+
+		bl->nbufs++;
+	}
+
+	list_for_each_entry(ib, &bl->head, head) {
+		struct vb2_buffer *vb = ipu_isys_buffer_to_vb2_buffer(ib);
+
+		aq = vb2_queue_to_ipu_isys_queue(vb->vb2_queue);
+		if (aq->prepare_frame_buff_set)
+			aq->prepare_frame_buff_set(vb);
+	}
+
+	/* Get short packet buffer. */
+	if (ip->interlaced && ip->isys->short_packet_source ==
+	    IPU_ISYS_SHORT_PACKET_FROM_RECEIVER) {
+		ib = ipu_isys_csi2_get_short_packet_buffer(ip, bl);
+		if (!ib) {
+			ret = -ENODATA;
+			dev_err(&ip->isys->adev->dev,
+				"No more short packet buffers. Driver bug?");
+			WARN_ON(1);
+			goto error;
+		}
+		bl->nbufs++;
+	}
+
+	dev_dbg(&ip->isys->adev->dev, "get buffer list %p, %u buffers\n", bl,
+		bl->nbufs);
+	return ret;
+
+error:
+	if (!list_empty(&bl->head))
+		ipu_isys_buffer_list_queue(bl,
+					   IPU_ISYS_BUFFER_LIST_FL_INCOMING, 0);
+	return ret;
+}
+
+void
+ipu_isys_buffer_to_fw_frame_buff_pin(struct vb2_buffer *vb,
+				     struct ipu_fw_isys_frame_buff_set_abi *set)
+{
+	struct ipu_isys_queue *aq = vb2_queue_to_ipu_isys_queue(vb->vb2_queue);
+	struct ipu_isys_video *av = container_of(aq, struct ipu_isys_video, aq);
+
+	if (av->compression)
+		set->output_pins[aq->fw_output].compress = 1;
+
+	set->output_pins[aq->fw_output].addr =
+	    vb2_dma_contig_plane_dma_addr(vb, 0);
+	set->output_pins[aq->fw_output].out_buf_id =
+	    vb->index + 1;
+}
+
+/*
+ * Convert a buffer list to a isys fw ABI framebuffer set. The
+ * buffer list is not modified.
+ */
+#define IPU_ISYS_FRAME_NUM_THRESHOLD  (30)
+void
+ipu_isys_buffer_to_fw_frame_buff(struct ipu_fw_isys_frame_buff_set_abi *set,
+				 struct ipu_isys_pipeline *ip,
+				 struct ipu_isys_buffer_list *bl)
+{
+	struct ipu_isys_buffer *ib;
+
+	WARN_ON(!bl->nbufs);
+
+	set->send_irq_sof = 1;
+	set->send_resp_sof = 1;
+	set->send_irq_eof = 0;
+	set->send_resp_eof = 0;
+
+	if (ip->streaming)
+		set->send_irq_capture_ack = 0;
+	else
+		set->send_irq_capture_ack = 1;
+	set->send_irq_capture_done = 0;
+
+	set->send_resp_capture_ack = 1;
+	set->send_resp_capture_done = 1;
+	if (!ip->interlaced &&
+	    atomic_read(&ip->sequence) >= IPU_ISYS_FRAME_NUM_THRESHOLD) {
+		set->send_resp_capture_ack = 0;
+		set->send_resp_capture_done = 0;
+	}
+
+	list_for_each_entry(ib, &bl->head, head) {
+		if (ib->type == IPU_ISYS_VIDEO_BUFFER) {
+			struct vb2_buffer *vb =
+			    ipu_isys_buffer_to_vb2_buffer(ib);
+			struct ipu_isys_queue *aq =
+			    vb2_queue_to_ipu_isys_queue(vb->vb2_queue);
+
+			if (aq->fill_frame_buff_set_pin)
+				aq->fill_frame_buff_set_pin(vb, set);
+		} else if (ib->type == IPU_ISYS_SHORT_PACKET_BUFFER) {
+			struct ipu_isys_private_buffer *pb =
+			    ipu_isys_buffer_to_private_buffer(ib);
+			struct ipu_fw_isys_output_pin_payload_abi *output_pin =
+			    &set->output_pins[ip->short_packet_output_pin];
+
+			output_pin->addr = pb->dma_addr;
+			output_pin->out_buf_id = pb->index + 1;
+		} else {
+			WARN_ON(1);
+		}
+	}
+}
+
+/* Start streaming for real. The buffer list must be available. */
+static int ipu_isys_stream_start(struct ipu_isys_pipeline *ip,
+				 struct ipu_isys_buffer_list *bl, bool error)
+{
+	struct ipu_isys_video *pipe_av =
+	    container_of(ip, struct ipu_isys_video, ip);
+	struct ipu_isys_buffer_list __bl;
+	int rval;
+
+	mutex_lock(&pipe_av->isys->stream_mutex);
+
+	rval = ipu_isys_video_set_streaming(pipe_av, 1, bl);
+	if (rval) {
+		mutex_unlock(&pipe_av->isys->stream_mutex);
+		goto out_requeue;
+	}
+
+	ip->streaming = 1;
+
+	mutex_unlock(&pipe_av->isys->stream_mutex);
+
+	bl = &__bl;
+
+	do {
+		struct ipu_fw_isys_frame_buff_set_abi *buf = NULL;
+		struct isys_fw_msgs *msg;
+		enum ipu_fw_isys_send_type send_type =
+		    IPU_FW_ISYS_SEND_TYPE_STREAM_CAPTURE;
+
+		rval = buffer_list_get(ip, bl);
+		if (rval == -EINVAL)
+			goto out_requeue;
+		else if (rval < 0)
+			break;
+
+		msg = ipu_get_fw_msg_buf(ip);
+		if (!msg)
+			return -ENOMEM;
+
+		buf = to_frame_msg_buf(msg);
+
+		ipu_isys_buffer_to_fw_frame_buff(buf, ip, bl);
+
+		ipu_fw_isys_dump_frame_buff_set(&pipe_av->isys->adev->dev, buf,
+						ip->nr_output_pins);
+
+		ipu_isys_buffer_list_queue(bl,
+					   IPU_ISYS_BUFFER_LIST_FL_ACTIVE, 0);
+
+		rval = ipu_fw_isys_complex_cmd(pipe_av->isys,
+					       ip->stream_handle,
+					       buf, to_dma_addr(msg),
+					       sizeof(*buf),
+					       send_type);
+	} while (!WARN_ON(rval));
+
+	return 0;
+
+out_requeue:
+	if (bl && bl->nbufs)
+		ipu_isys_buffer_list_queue(bl,
+					   IPU_ISYS_BUFFER_LIST_FL_INCOMING |
+					   (error ?
+					    IPU_ISYS_BUFFER_LIST_FL_SET_STATE :
+					    0),
+					   error ? VB2_BUF_STATE_ERROR :
+					   VB2_BUF_STATE_QUEUED);
+	flush_firmware_streamon_fail(ip);
+
+	return rval;
+}
+
+static void buf_queue(struct vb2_buffer *vb)
+{
+	struct ipu_isys_queue *aq = vb2_queue_to_ipu_isys_queue(vb->vb2_queue);
+	struct ipu_isys_video *av = ipu_isys_queue_to_video(aq);
+	struct ipu_isys_buffer *ib = vb2_buffer_to_ipu_isys_buffer(vb);
+	struct media_pipeline *media_pipe =
+		media_entity_pipeline(&av->vdev.entity);
+	struct ipu_isys_pipeline *ip = to_ipu_isys_pipeline(media_pipe);
+	struct ipu_isys_buffer_list bl;
+
+	struct ipu_fw_isys_frame_buff_set_abi *buf = NULL;
+	struct isys_fw_msgs *msg;
+
+	struct ipu_isys_video *pipe_av =
+	    container_of(ip, struct ipu_isys_video, ip);
+	unsigned long flags;
+	unsigned int i;
+	int rval;
+
+	dev_dbg(&av->isys->adev->dev, "buffer: %s: buf_queue %u\n",
+		av->vdev.name,
+		vb->index
+	    );
+
+	for (i = 0; i < vb->num_planes; i++)
+		dev_dbg(&av->isys->adev->dev, "iova: plane %u iova 0x%x\n", i,
+			(u32)vb2_dma_contig_plane_dma_addr(vb, i));
+
+	spin_lock_irqsave(&aq->lock, flags);
+	list_add(&ib->head, &aq->incoming);
+	spin_unlock_irqrestore(&aq->lock, flags);
+
+	mutex_unlock(&av->mutex);
+	mutex_lock(&av->isys->reset_mutex);
+	while (av->isys->in_reset) {
+		mutex_unlock(&av->isys->reset_mutex);
+		dev_dbg(&av->isys->adev->dev, "buffer: %s: wait for reset\n",
+			av->vdev.name
+		);
+		usleep_range(10000, 11000);
+		mutex_lock(&av->isys->reset_mutex);
+	}
+	mutex_unlock(&av->isys->reset_mutex);
+	mutex_lock(&av->mutex);
+
+	/* ip may be cleared in ipu reset */
+	ip = to_ipu_isys_pipeline(media_entity_pipeline(&av->vdev.entity));
+	pipe_av = container_of(ip, struct ipu_isys_video, ip);
+	if (ib->req)
+		return;
+
+	if (!pipe_av || !media_pipe || !vb->vb2_queue->start_streaming_called) {
+		dev_info(&av->isys->adev->dev,
+			"no pipe or streaming, adding to incoming\n");
+		return;
+	}
+
+	mutex_unlock(&av->mutex);
+	mutex_lock(&pipe_av->mutex);
+
+	if (ip->nr_streaming != ip->nr_queues) {
+		dev_info(&av->isys->adev->dev,
+			"not streaming yet, adding to incoming\n");
+		goto out;
+	}
+
+	/*
+	 * We just put one buffer to the incoming list of this queue
+	 * (above). Let's see whether all queues in the pipeline would
+	 * have a buffer.
+	 */
+	rval = buffer_list_get(ip, &bl);
+	if (rval < 0) {
+		if (rval == -EINVAL) {
+			dev_err(&av->isys->adev->dev,
+				"error: buffer list get failed\n");
+			WARN_ON(1);
+		} else {
+			dev_info(&av->isys->adev->dev,
+				"not enough buffers available\n");
+		}
+		goto out;
+	}
+
+	msg = ipu_get_fw_msg_buf(ip);
+	if (!msg) {
+		rval = -ENOMEM;
+		dev_err(&av->isys->adev->dev,
+			"failed to get fw msg buf\n");
+		goto out;
+	}
+	buf = to_frame_msg_buf(msg);
+
+	ipu_isys_buffer_to_fw_frame_buff(buf, ip, &bl);
+
+	ipu_fw_isys_dump_frame_buff_set(&pipe_av->isys->adev->dev, buf,
+					ip->nr_output_pins);
+
+	if (!ip->streaming) {
+		dev_info(&av->isys->adev->dev,
+			"got a buffer to start streaming!\n");
+		rval = ipu_isys_stream_start(ip, &bl, true);
+		if (rval)
+			dev_err(&av->isys->adev->dev,
+				"stream start failed.\n");
+		goto out;
+	}
+
+	/*
+	 * We must queue the buffers in the buffer list to the
+	 * appropriate video buffer queues BEFORE passing them to the
+	 * firmware since we could get a buffer event back before we
+	 * have queued them ourselves to the active queue.
+	 */
+	ipu_isys_buffer_list_queue(&bl, IPU_ISYS_BUFFER_LIST_FL_ACTIVE, 0);
+
+	rval = ipu_fw_isys_complex_cmd(pipe_av->isys,
+				       ip->stream_handle,
+				       buf, to_dma_addr(msg),
+				       sizeof(*buf),
+				       IPU_FW_ISYS_SEND_TYPE_STREAM_CAPTURE);
+	if (!WARN_ON(rval < 0))
+		dev_dbg(&av->isys->adev->dev, "queued buffer\n");
+
+out:
+	mutex_unlock(&pipe_av->mutex);
+	mutex_lock(&av->mutex);
+}
+
+int ipu_isys_link_fmt_validate(struct ipu_isys_queue *aq)
+{
+	struct ipu_isys_video *av = ipu_isys_queue_to_video(aq);
+	struct v4l2_subdev_format fmt = { 0 };
+	struct media_pad *pad =
+		media_pad_remote_pad_first(av->vdev.entity.pads);
+	struct v4l2_subdev *sd;
+	int rval;
+
+	if (!pad) {
+		dev_dbg(&av->isys->adev->dev,
+			"video node %s pad not connected\n", av->vdev.name);
+		return -ENOTCONN;
+	}
+
+	sd = media_entity_to_v4l2_subdev(pad->entity);
+
+	fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
+	fmt.pad = pad->index;
+	rval = v4l2_subdev_call(sd, pad, get_fmt, NULL, &fmt);
+	if (rval)
+		return rval;
+
+	if (fmt.format.width != av->mpix.width ||
+	    fmt.format.height != av->mpix.height) {
+		dev_dbg(&av->isys->adev->dev,
+			"wrong width or height %ux%u (%ux%u expected)\n",
+			av->mpix.width, av->mpix.height,
+			fmt.format.width, fmt.format.height);
+		return -EINVAL;
+	}
+
+	if (fmt.format.field != av->mpix.field) {
+		dev_dbg(&av->isys->adev->dev,
+			"wrong field value 0x%8.8x (0x%8.8x expected)\n",
+			av->mpix.field, fmt.format.field);
+		return -EINVAL;
+	}
+
+	if (fmt.format.code != av->pfmt->code) {
+		dev_dbg(&av->isys->adev->dev,
+			"wrong media bus code 0x%8.8x (0x%8.8x expected)\n",
+			av->pfmt->code, fmt.format.code);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/* Return buffers back to videobuf2. */
+static void return_buffers(struct ipu_isys_queue *aq,
+			   enum vb2_buffer_state state)
+{
+	struct ipu_isys_video *av = ipu_isys_queue_to_video(aq);
+	int reset_needed = 0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&aq->lock, flags);
+	while (!list_empty(&aq->incoming)) {
+		struct ipu_isys_buffer *ib = list_first_entry(&aq->incoming,
+							      struct
+							      ipu_isys_buffer,
+							      head);
+		struct vb2_buffer *vb = ipu_isys_buffer_to_vb2_buffer(ib);
+
+		list_del(&ib->head);
+		spin_unlock_irqrestore(&aq->lock, flags);
+
+		vb2_buffer_done(vb, state);
+
+		dev_dbg(&av->isys->adev->dev,
+			"%s: stop_streaming incoming %u\n",
+			ipu_isys_queue_to_video(vb2_queue_to_ipu_isys_queue
+						(vb->vb2_queue))->vdev.name,
+			vb->index);
+
+		spin_lock_irqsave(&aq->lock, flags);
+	}
+
+	/*
+	 * Something went wrong (FW crash / HW hang / not all buffers
+	 * returned from isys) if there are still buffers queued in active
+	 * queue. We have to clean up places a bit.
+	 */
+	while (!list_empty(&aq->active)) {
+		struct ipu_isys_buffer *ib = list_first_entry(&aq->active,
+							      struct
+							      ipu_isys_buffer,
+							      head);
+		struct vb2_buffer *vb = ipu_isys_buffer_to_vb2_buffer(ib);
+
+		list_del(&ib->head);
+		spin_unlock_irqrestore(&aq->lock, flags);
+
+		vb2_buffer_done(vb, state);
+
+		dev_warn(&av->isys->adev->dev, "%s: cleaning active queue %u\n",
+			 ipu_isys_queue_to_video(vb2_queue_to_ipu_isys_queue
+						 (vb->vb2_queue))->vdev.name,
+			 vb->index);
+
+		spin_lock_irqsave(&aq->lock, flags);
+		reset_needed = 1;
+	}
+
+	spin_unlock_irqrestore(&aq->lock, flags);
+
+	if (reset_needed) {
+		mutex_lock(&av->isys->mutex);
+		av->isys->reset_needed = true;
+		mutex_unlock(&av->isys->mutex);
+	}
+}
+
+static int __start_streaming(struct vb2_queue *q, unsigned int count)
+{
+	struct ipu_isys_queue *aq = vb2_queue_to_ipu_isys_queue(q);
+	struct ipu_isys_video *av = ipu_isys_queue_to_video(aq);
+	struct ipu_isys_video *pipe_av;
+	struct ipu_isys_pipeline *ip;
+	struct ipu_isys_buffer_list __bl, *bl = NULL;
+	bool first;
+	int rval;
+
+	dev_dbg(&av->isys->adev->dev,
+		"stream: %s: width %u, height %u, css pixelformat %u\n",
+		av->vdev.name, av->mpix.width, av->mpix.height,
+		av->pfmt->css_pixelformat);
+
+	mutex_lock(&av->isys->stream_mutex);
+
+	first = !media_entity_pipeline(&av->vdev.entity);
+
+	if (first) {
+		rval = ipu_isys_video_prepare_streaming(av, 1);
+		if (rval) {
+			dev_err(&av->isys->adev->dev,
+				"%s: prepare stream: failed (%d)\n",
+				av->vdev.name, rval);
+			goto out_return_buffers;
+		}
+	}
+
+	mutex_unlock(&av->isys->stream_mutex);
+
+	rval = aq->link_fmt_validate(aq);
+	if (rval) {
+		dev_err(&av->isys->adev->dev,
+			"%s: link format validation failed (%d)\n",
+			av->vdev.name, rval);
+		goto out_unprepare_streaming;
+	}
+
+	ip = to_ipu_isys_pipeline(media_entity_pipeline(&av->vdev.entity));
+	pipe_av = container_of(ip, struct ipu_isys_video, ip);
+	if (pipe_av != av) {
+		mutex_unlock(&av->mutex);
+		mutex_lock(&pipe_av->mutex);
+	}
+
+	ip->nr_streaming++;
+	dev_dbg(&av->isys->adev->dev, "queue %u of %u\n", ip->nr_streaming,
+		ip->nr_queues);
+	list_add(&aq->node, &ip->queues);
+	if (ip->nr_streaming != ip->nr_queues) {
+		dev_err(&av->isys->adev->dev,
+			"%s: streaming queue not match (%d)(%d)\n",
+			av->vdev.name, ip->nr_streaming, ip->nr_queues);
+		goto out;
+	}
+
+	if (list_empty(&av->isys->requests)) {
+		bl = &__bl;
+		rval = buffer_list_get(ip, bl);
+		if (rval == -EINVAL) {
+			dev_err(&av->isys->adev->dev,
+				"buffer list invalid\n");
+			goto out_stream_start;
+		} else if (rval < 0) {
+			dev_err(&av->isys->adev->dev,
+				"no request available, postponing streamon\n");
+			goto out;
+		}
+	}
+
+	rval = ipu_isys_stream_start(ip, bl, false);
+	if (rval) {
+		dev_err(&av->isys->adev->dev,
+			"isys stream start failed\n");
+		goto out_stream_start;
+	}
+
+out:
+	if (pipe_av != av) {
+		mutex_unlock(&pipe_av->mutex);
+		mutex_lock(&av->mutex);
+	}
+
+	return 0;
+
+out_stream_start:
+	list_del(&aq->node);
+	ip->nr_streaming--;
+	if (pipe_av != av) {
+		mutex_unlock(&pipe_av->mutex);
+		mutex_lock(&av->mutex);
+	}
+
+out_unprepare_streaming:
+	mutex_lock(&av->isys->stream_mutex);
+	if (first)
+		ipu_isys_video_prepare_streaming(av, 0);
+
+out_return_buffers:
+	mutex_unlock(&av->isys->stream_mutex);
+	return_buffers(aq, VB2_BUF_STATE_QUEUED);
+
+	return rval;
+}
+
+static int start_streaming(struct vb2_queue *q, unsigned int count)
+{
+	struct ipu_isys_queue *aq = vb2_queue_to_ipu_isys_queue(q);
+	struct ipu_isys_video *av = ipu_isys_queue_to_video(aq);
+	int rval;
+
+	mutex_unlock(&av->mutex);
+	mutex_lock(&av->isys->reset_mutex);
+	while (av->isys->in_stop_streaming) {
+		mutex_unlock(&av->isys->reset_mutex);
+		dev_dbg(&av->isys->adev->dev, "buffer: %s: wait for stop streaming\n",
+			av->vdev.name
+		);
+		usleep_range(10000, 11000);
+		mutex_lock(&av->isys->reset_mutex);
+	}
+	mutex_unlock(&av->isys->reset_mutex);
+	mutex_lock(&av->mutex);
+
+	rval = __start_streaming(q, count);
+
+	return rval;
+}
+
+static void reset_stop_streaming(struct ipu_isys_video *av)
+{
+	struct ipu_isys_pipeline *ip = &av->ip;
+	struct ipu_isys_queue *aq = &av->aq;
+
+	dev_dbg(&av->isys->adev->dev, "%s: stop streaming\n", av->vdev.name);
+
+	mutex_lock(&av->isys->stream_mutex);
+	if (ip->nr_streaming == ip->nr_queues && ip->streaming)
+		ipu_isys_video_set_streaming(av, 0, NULL);
+	if (ip->nr_streaming == 1)
+		ipu_isys_video_prepare_streaming(av, 0);
+	mutex_unlock(&av->isys->stream_mutex);
+
+	ip->nr_streaming--;
+	list_del(&aq->node);
+	ip->streaming = 0;
+}
+
+static int reset_start_streaming(struct ipu_isys_video *av)
+{
+	struct ipu_isys_queue *aq = &av->aq;
+	unsigned long flags;
+	int rval;
+
+	dev_dbg(&av->isys->adev->dev, "%s: start streaming\n", av->vdev.name);
+
+	spin_lock_irqsave(&aq->lock, flags);
+	while (!list_empty(&aq->active)) {
+		struct ipu_isys_buffer *ib = list_first_entry(&aq->active,
+				struct
+				ipu_isys_buffer,
+				head);
+
+		list_del(&ib->head);
+		list_add_tail(&ib->head, &aq->incoming);
+	}
+	spin_unlock_irqrestore(&aq->lock, flags);
+
+	av->skipframe = 1;
+	rval = __start_streaming(&aq->vbq, 0);
+	if (rval) {
+		dev_dbg(&av->isys->adev->dev,
+			"%s: start streaming failed in reset\n",
+			av->vdev.name);
+	}
+
+	return rval;
+}
+
+static int ipu_isys_reset(struct ipu_isys_video *self_av)
+{
+	struct ipu_isys *isys = self_av->isys;
+	struct ipu_bus_device *adev = isys->adev;
+	struct ipu_device *isp = isys->adev->isp;
+	struct ipu_isys_video *av = NULL;
+	struct ipu_isys_pipeline *ip = NULL;
+	struct ipu_isys_csi2_be_soc *csi2_be_soc = NULL;
+	int rval, i, j;
+	int has_streaming = 0;
+
+	dev_dbg(&isys->adev->dev, "%s\n", __func__);
+
+	mutex_lock(&isys->reset_mutex);
+	if (isys->in_reset) {
+		mutex_unlock(&isys->reset_mutex);
+		return 0;
+	}
+	isys->in_reset = true;
+	mutex_unlock(&isys->reset_mutex);
+
+	av = &isys->csi2->av;
+
+	if (av != self_av) {
+		ip = &av->ip;
+		mutex_lock(&av->mutex);
+		if (ip->streaming) {
+			av->reset = true;
+			has_streaming = true;
+			reset_stop_streaming(av);
+		}
+		mutex_unlock(&av->mutex);
+	}
+
+	av = &isys->csi2_be.av;
+
+	if (av != self_av) {
+		ip = &av->ip;
+		mutex_lock(&av->mutex);
+		if (ip->streaming) {
+			av->reset = true;
+			has_streaming = true;
+			reset_stop_streaming(av);
+		}
+		mutex_unlock(&av->mutex);
+	}
+
+	for (i = 0; i < NR_OF_CSI2_BE_SOC_DEV; i++) {
+		csi2_be_soc = &isys->csi2_be_soc[i];
+		for (j = 0; j < NR_OF_CSI2_BE_SOC_SOURCE_PADS; j++) {
+			av = &csi2_be_soc->av[j];
+		if (av == self_av)
+			continue;
+
+		ip = &av->ip;
+		mutex_lock(&av->mutex);
+		if (!ip->streaming) {
+			mutex_unlock(&av->mutex);
+			continue;
+		}
+		av->reset = true;
+		has_streaming = true;
+		reset_stop_streaming(av);
+		mutex_unlock(&av->mutex);
+		}
+	}
+
+	if (!has_streaming)
+		goto end_of_reset;
+
+	dev_dbg(&isys->adev->dev, "ipu reset, close fw\n");
+	ipu_fw_isys_close(isys);
+
+	dev_dbg(&isys->adev->dev, "ipu reset, power cycle\n");
+
+	/* bus_pm_runtime_suspend() */
+	/* isys_runtime_pm_suspend() */
+	adev->dev.bus->pm->runtime_suspend(&adev->dev);
+
+	/* ipu_suspend */
+	isp->pdev->driver->driver.pm->runtime_suspend(&isp->pdev->dev);
+
+	/* ipu_runtime_resume */
+	isp->pdev->driver->driver.pm->runtime_resume(&isp->pdev->dev);
+
+	/* bus_pm_runtime_resume() */
+	/* isys_runtime_pm_resume() */
+	adev->dev.bus->pm->runtime_resume(&adev->dev);
+
+	ipu_configure_spc(isys->adev->isp,
+			  &isys->pdata->ipdata->hw_variant,
+			  IPU_CPD_PKG_DIR_ISYS_SERVER_IDX,
+			  isys->pdata->base, isys->pkg_dir,
+			  isys->pkg_dir_dma_addr);
+
+	ipu_cleanup_fw_msg_bufs(isys);
+	if (isys->fwcom) {
+		dev_err(&isys->adev->dev, "Clearing old context\n");
+		ipu_fw_isys_cleanup(isys);
+	}
+
+	rval = ipu_fw_isys_init(av->isys,
+			  isys->pdata->ipdata->num_parallel_streams);
+	if (rval < 0)
+		dev_err(&isys->adev->dev, "ipu fw isys init failed\n");
+
+	dev_dbg(&isys->adev->dev, "restart streams\n");
+
+	av = &isys->csi2->av;
+	if (av->reset) {
+		av->reset = false;
+		mutex_lock(&av->mutex);
+		reset_start_streaming(av);
+		mutex_unlock(&av->mutex);
+	}
+
+	av = &isys->csi2_be.av;
+	if (av->reset) {
+		av->reset = false;
+		mutex_lock(&av->mutex);
+		reset_start_streaming(av);
+		mutex_unlock(&av->mutex);
+	}
+
+	for (i = 0; i < NR_OF_CSI2_BE_SOC_DEV; i++) {
+		csi2_be_soc = &isys->csi2_be_soc[i];
+		for (j = 0; j < NR_OF_CSI2_BE_SOC_SOURCE_PADS; j++) {
+			av = &csi2_be_soc->av[j];
+		if (!av->reset)
+			continue;
+
+		av->reset = false;
+		mutex_lock(&av->mutex);
+		reset_start_streaming(av);
+		mutex_unlock(&av->mutex);
+		}
+	}
+
+end_of_reset:
+	mutex_lock(&isys->reset_mutex);
+	isys->in_reset = false;
+	mutex_unlock(&isys->reset_mutex);
+	dev_dbg(&isys->adev->dev, "reset done\n");
+
+	return 0;
+}
+
+static void stop_streaming(struct vb2_queue *q)
+{
+	struct ipu_isys_queue *aq = vb2_queue_to_ipu_isys_queue(q);
+	struct ipu_isys_video *av = ipu_isys_queue_to_video(aq);
+	struct ipu_isys_pipeline *ip =
+		to_ipu_isys_pipeline(media_entity_pipeline(&av->vdev.entity));
+	struct ipu_isys_video *pipe_av =
+	    container_of(ip, struct ipu_isys_video, ip);
+
+	dev_dbg(&av->isys->adev->dev, "stop: %s: enter\n",
+		av->vdev.name);
+
+	mutex_unlock(&av->mutex);
+	mutex_lock(&av->isys->reset_mutex);
+	while (av->isys->in_reset) {
+		mutex_unlock(&av->isys->reset_mutex);
+		dev_dbg(&av->isys->adev->dev, "stop: %s: wait for reset\n",
+			av->vdev.name
+		);
+		usleep_range(10000, 11000);
+		mutex_lock(&av->isys->reset_mutex);
+	}
+	mutex_unlock(&av->isys->reset_mutex);
+	mutex_lock(&av->mutex);
+
+	if (!ip) {
+		dev_err(&av->isys->adev->dev, "stop: %s: ip cleard!\n",
+			av->vdev.name);
+		return_buffers(aq, VB2_BUF_STATE_ERROR);
+		return;
+	}
+
+	mutex_lock(&av->isys->reset_mutex);
+	av->isys->in_stop_streaming = true;
+	mutex_unlock(&av->isys->reset_mutex);
+
+	if (pipe_av != av) {
+		mutex_unlock(&av->mutex);
+		mutex_lock(&pipe_av->mutex);
+	}
+
+	mutex_lock(&av->isys->stream_mutex);
+	if (ip->nr_streaming == ip->nr_queues && ip->streaming)
+		ipu_isys_video_set_streaming(av, 0, NULL);
+	if (ip->nr_streaming == 1)
+		ipu_isys_video_prepare_streaming(av, 0);
+	mutex_unlock(&av->isys->stream_mutex);
+
+	ip->nr_streaming--;
+	list_del(&aq->node);
+	ip->streaming = 0;
+
+	if (pipe_av != av) {
+		mutex_unlock(&pipe_av->mutex);
+		mutex_lock(&av->mutex);
+	}
+
+	return_buffers(aq, VB2_BUF_STATE_ERROR);
+	if (av->isys->reset_needed)
+		ipu_isys_reset(av);
+
+	dev_dbg(&av->isys->adev->dev, "stop: %s: exit\n",
+		av->vdev.name);
+
+	mutex_lock(&av->isys->reset_mutex);
+	av->isys->in_stop_streaming = false;
+	mutex_unlock(&av->isys->reset_mutex);
+
+}
+
+static unsigned int
+get_sof_sequence_by_timestamp(struct ipu_isys_pipeline *ip,
+			      struct ipu_fw_isys_resp_info_abi *info)
+{
+	struct ipu_isys *isys =
+	    container_of(ip, struct ipu_isys_video, ip)->isys;
+	u64 time = (u64)info->timestamp[1] << 32 | info->timestamp[0];
+	unsigned int i;
+
+	/*
+	 * The timestamp is invalid as no TSC in some FPGA platform,
+	 * so get the sequence from pipeline directly in this case.
+	 */
+	if (time == 0)
+		return atomic_read(&ip->sequence) - 1;
+
+	for (i = 0; i < IPU_ISYS_MAX_PARALLEL_SOF; i++)
+		if (time == ip->seq[i].timestamp) {
+			dev_dbg(&isys->adev->dev,
+				"sof: using seq nr %u for ts 0x%16.16llx\n",
+				ip->seq[i].sequence, time);
+			return ip->seq[i].sequence;
+		}
+
+	dev_dbg(&isys->adev->dev, "SOF: looking for 0x%16.16llx\n", time);
+	for (i = 0; i < IPU_ISYS_MAX_PARALLEL_SOF; i++)
+		dev_dbg(&isys->adev->dev,
+			"SOF: sequence %u, timestamp value 0x%16.16llx\n",
+			ip->seq[i].sequence, ip->seq[i].timestamp);
+	dev_dbg(&isys->adev->dev, "SOF sequence number not found\n");
+
+	return 0;
+}
+
+static u64 get_sof_ns_delta(struct ipu_isys_video *av,
+			    struct ipu_fw_isys_resp_info_abi *info)
+{
+	struct ipu_bus_device *adev = to_ipu_bus_device(&av->isys->adev->dev);
+	struct ipu_device *isp = adev->isp;
+	u64 delta, tsc_now;
+
+	if (!ipu_buttress_tsc_read(isp, &tsc_now))
+		delta = tsc_now -
+		    ((u64)info->timestamp[1] << 32 | info->timestamp[0]);
+	else
+		delta = 0;
+
+	return ipu_buttress_tsc_ticks_to_ns(delta, isp);
+}
+
+void
+ipu_isys_buf_calc_sequence_time(struct ipu_isys_buffer *ib,
+				struct ipu_fw_isys_resp_info_abi *info)
+{
+	struct vb2_buffer *vb = ipu_isys_buffer_to_vb2_buffer(ib);
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
+	struct ipu_isys_queue *aq = vb2_queue_to_ipu_isys_queue(vb->vb2_queue);
+	struct ipu_isys_video *av = ipu_isys_queue_to_video(aq);
+	struct device *dev = &av->isys->adev->dev;
+	struct ipu_isys_pipeline *ip =
+		to_ipu_isys_pipeline(media_entity_pipeline(&av->vdev.entity));
+	u64 ns;
+	u32 sequence;
+
+	if (ip->has_sof) {
+		ns = (wall_clock_ts_on) ? ktime_get_real_ns() : ktime_get_ns();
+		ns -= get_sof_ns_delta(av, info);
+		sequence = get_sof_sequence_by_timestamp(ip, info);
+	} else {
+		ns = ((wall_clock_ts_on) ? ktime_get_real_ns() :
+		      ktime_get_ns());
+		sequence = (atomic_inc_return(&ip->sequence) - 1)
+		    / ip->nr_queues;
+	}
+
+	vbuf->vb2_buf.timestamp = ns;
+	vbuf->sequence = sequence;
+
+	dev_dbg(dev, "buf: %s: buffer done, CPU-timestamp:%lld, sequence:%d\n",
+		av->vdev.name, ktime_get_ns(), sequence);
+	dev_dbg(dev, "index:%d, vbuf timestamp:%lld, endl\n",
+		vb->index, vbuf->vb2_buf.timestamp);
+}
+
+void ipu_isys_queue_buf_done(struct ipu_isys_buffer *ib)
+{
+	struct vb2_buffer *vb = ipu_isys_buffer_to_vb2_buffer(ib);
+
+	if (atomic_read(&ib->str2mmio_flag)) {
+		vb2_buffer_done(vb, VB2_BUF_STATE_ERROR);
+		/*
+		 * Operation on buffer is ended with error and will be reported
+		 * to the userspace when it is de-queued
+		 */
+		atomic_set(&ib->str2mmio_flag, 0);
+	} else if (atomic_read(&ib->skipframe_flag)) {
+		vb2_buffer_done(vb, VB2_BUF_STATE_ERROR);
+		atomic_set(&ib->skipframe_flag, 0);
+	} else {
+		vb2_buffer_done(vb, VB2_BUF_STATE_DONE);
+	}
+}
+
+void ipu_isys_queue_buf_ready(struct ipu_isys_pipeline *ip,
+			      struct ipu_fw_isys_resp_info_abi *info)
+{
+	struct ipu_isys *isys =
+	    container_of(ip, struct ipu_isys_video, ip)->isys;
+	struct ipu_isys_queue *aq = ip->output_pins[info->pin_id].aq;
+	struct ipu_isys_buffer *ib;
+	struct vb2_buffer *vb;
+	unsigned long flags;
+	bool first = true;
+	struct vb2_v4l2_buffer *buf;
+
+	dev_dbg(&isys->adev->dev, "buffer: %s: received buffer %8.8x\n",
+		ipu_isys_queue_to_video(aq)->vdev.name, info->pin.addr);
+
+	spin_lock_irqsave(&aq->lock, flags);
+	if (list_empty(&aq->active)) {
+		spin_unlock_irqrestore(&aq->lock, flags);
+		dev_err(&isys->adev->dev, "active queue empty\n");
+		return;
+	}
+
+	list_for_each_entry_reverse(ib, &aq->active, head) {
+		dma_addr_t addr;
+
+		vb = ipu_isys_buffer_to_vb2_buffer(ib);
+		addr = vb2_dma_contig_plane_dma_addr(vb, 0);
+
+		if (info->pin.addr != addr) {
+			if (first)
+				dev_err(&isys->adev->dev,
+					"WARN: buffer address %pad expected!\n",
+					&addr);
+			first = false;
+			continue;
+		}
+
+		if (info->error_info.error ==
+		    IPU_FW_ISYS_ERROR_HW_REPORTED_STR2MMIO) {
+			/*
+			 * Check for error message:
+			 * 'IPU_FW_ISYS_ERROR_HW_REPORTED_STR2MMIO'
+			 */
+			atomic_set(&ib->str2mmio_flag, 1);
+		}
+		dev_dbg(&isys->adev->dev, "buffer: found buffer %pad\n", &addr);
+
+		buf = to_vb2_v4l2_buffer(vb);
+		buf->field = V4L2_FIELD_NONE;
+
+		list_del(&ib->head);
+		spin_unlock_irqrestore(&aq->lock, flags);
+
+		ipu_isys_buf_calc_sequence_time(ib, info);
+
+		/*
+		 * For interlaced buffers, the notification to user space
+		 * is postponed to capture_done event since the field
+		 * information is available only at that time.
+		 */
+		if (ip->interlaced) {
+			spin_lock_irqsave(&ip->short_packet_queue_lock, flags);
+			list_add(&ib->head, &ip->pending_interlaced_bufs);
+			spin_unlock_irqrestore(&ip->short_packet_queue_lock,
+					       flags);
+		} else {
+			ipu_isys_queue_buf_done(ib);
+		}
+
+		return;
+	}
+
+	dev_err(&isys->adev->dev,
+		"WARNING: cannot find a matching video buffer!\n");
+
+	spin_unlock_irqrestore(&aq->lock, flags);
+}
+
+void
+ipu_isys_queue_short_packet_ready(struct ipu_isys_pipeline *ip,
+				  struct ipu_fw_isys_resp_info_abi *info)
+{
+	struct ipu_isys *isys =
+	    container_of(ip, struct ipu_isys_video, ip)->isys;
+	unsigned long flags;
+
+	dev_dbg(&isys->adev->dev, "receive short packet buffer %8.8x\n",
+		info->pin.addr);
+	spin_lock_irqsave(&ip->short_packet_queue_lock, flags);
+	ip->cur_field = ipu_isys_csi2_get_current_field(ip, info->timestamp);
+	spin_unlock_irqrestore(&ip->short_packet_queue_lock, flags);
+}
+
+struct vb2_ops ipu_isys_queue_ops = {
+	.queue_setup = queue_setup,
+	.wait_prepare = ipu_isys_queue_unlock,
+	.wait_finish = ipu_isys_queue_lock,
+	.buf_init = buf_init,
+	.buf_prepare = buf_prepare,
+	.buf_finish = buf_finish,
+	.buf_cleanup = buf_cleanup,
+	.start_streaming = start_streaming,
+	.stop_streaming = stop_streaming,
+	.buf_queue = buf_queue,
+};
+
+int ipu_isys_queue_init(struct ipu_isys_queue *aq)
+{
+	struct ipu_isys *isys = ipu_isys_queue_to_video(aq)->isys;
+	int rval;
+
+	if (!aq->vbq.io_modes)
+		aq->vbq.io_modes = VB2_USERPTR | VB2_MMAP | VB2_DMABUF;
+	aq->vbq.drv_priv = aq;
+	aq->vbq.ops = &ipu_isys_queue_ops;
+	aq->vbq.mem_ops = &vb2_dma_contig_memops;
+	aq->vbq.timestamp_flags = (wall_clock_ts_on) ?
+	    V4L2_BUF_FLAG_TIMESTAMP_UNKNOWN : V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;
+
+	rval = vb2_queue_init(&aq->vbq);
+	if (rval)
+		return rval;
+
+	aq->dev = &isys->adev->dev;
+	aq->vbq.dev = &isys->adev->dev;
+	spin_lock_init(&aq->lock);
+	INIT_LIST_HEAD(&aq->active);
+	INIT_LIST_HEAD(&aq->incoming);
+
+	return 0;
+}
+
+void ipu_isys_queue_cleanup(struct ipu_isys_queue *aq)
+{
+	vb2_queue_release(&aq->vbq);
+}
Index: b/drivers/media/pci/intel/ipu-isys-queue.h
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu-isys-queue.h
@@ -0,0 +1,143 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2013 - 2020 Intel Corporation */
+
+#ifndef IPU_ISYS_QUEUE_H
+#define IPU_ISYS_QUEUE_H
+
+#include <linux/list.h>
+#include <linux/spinlock.h>
+
+#include <media/videobuf2-v4l2.h>
+
+#include "ipu-isys-media.h"
+
+struct ipu_isys_video;
+struct ipu_isys_pipeline;
+struct ipu_fw_isys_resp_info_abi;
+struct ipu_fw_isys_frame_buff_set_abi;
+
+enum ipu_isys_buffer_type {
+	IPU_ISYS_VIDEO_BUFFER,
+	IPU_ISYS_SHORT_PACKET_BUFFER,
+};
+
+struct ipu_isys_queue {
+	struct list_head node;	/* struct ipu_isys_pipeline.queues */
+	struct vb2_queue vbq;
+	struct device *dev;
+	/*
+	 * @lock: serialise access to queued and pre_streamon_queued
+	 */
+	spinlock_t lock;
+	struct list_head active;
+	struct list_head incoming;
+	u32 css_pin_type;
+	unsigned int fw_output;
+	int (*buf_init)(struct vb2_buffer *vb);
+	void (*buf_cleanup)(struct vb2_buffer *vb);
+	int (*buf_prepare)(struct vb2_buffer *vb);
+	void (*prepare_frame_buff_set)(struct vb2_buffer *vb);
+	void (*fill_frame_buff_set_pin)(struct vb2_buffer *vb,
+					struct ipu_fw_isys_frame_buff_set_abi *
+					set);
+	int (*link_fmt_validate)(struct ipu_isys_queue *aq);
+};
+
+struct ipu_isys_buffer {
+	struct list_head head;
+	enum ipu_isys_buffer_type type;
+	struct list_head req_head;
+	struct media_device_request *req;
+	atomic_t str2mmio_flag;
+	atomic_t skipframe_flag;
+};
+
+struct ipu_isys_video_buffer {
+	struct vb2_v4l2_buffer vb_v4l2;
+	struct ipu_isys_buffer ib;
+};
+
+struct ipu_isys_private_buffer {
+	struct ipu_isys_buffer ib;
+	struct ipu_isys_pipeline *ip;
+	unsigned int index;
+	unsigned int bytesused;
+	dma_addr_t dma_addr;
+	void *buffer;
+};
+
+#define IPU_ISYS_BUFFER_LIST_FL_INCOMING	BIT(0)
+#define IPU_ISYS_BUFFER_LIST_FL_ACTIVE	BIT(1)
+#define IPU_ISYS_BUFFER_LIST_FL_SET_STATE	BIT(2)
+
+struct ipu_isys_buffer_list {
+	struct list_head head;
+	unsigned int nbufs;
+};
+
+#define vb2_queue_to_ipu_isys_queue(__vb2) \
+	container_of(__vb2, struct ipu_isys_queue, vbq)
+
+#define ipu_isys_to_isys_video_buffer(__ib) \
+	container_of(__ib, struct ipu_isys_video_buffer, ib)
+
+#define vb2_buffer_to_ipu_isys_video_buffer(__vb) \
+	container_of(to_vb2_v4l2_buffer(__vb), \
+	struct ipu_isys_video_buffer, vb_v4l2)
+
+#define ipu_isys_buffer_to_vb2_buffer(__ib) \
+	(&ipu_isys_to_isys_video_buffer(__ib)->vb_v4l2.vb2_buf)
+
+#define vb2_buffer_to_ipu_isys_buffer(__vb) \
+	(&vb2_buffer_to_ipu_isys_video_buffer(__vb)->ib)
+
+#define ipu_isys_buffer_to_private_buffer(__ib) \
+	container_of(__ib, struct ipu_isys_private_buffer, ib)
+
+struct ipu_isys_request {
+	struct media_device_request req;
+	/* serialise access to buffers */
+	spinlock_t lock;
+	struct list_head buffers;	/* struct ipu_isys_buffer.head */
+	bool dispatched;
+	/*
+	 * struct ipu_isys.requests;
+	 * struct ipu_isys_pipeline.struct.*
+	 */
+	struct list_head head;
+};
+
+#define to_ipu_isys_request(__req) \
+	container_of(__req, struct ipu_isys_request, req)
+
+int ipu_isys_buf_prepare(struct vb2_buffer *vb);
+
+void ipu_isys_buffer_list_queue(struct ipu_isys_buffer_list *bl,
+				unsigned long op_flags,
+				enum vb2_buffer_state state);
+struct ipu_isys_request *
+ipu_isys_next_queued_request(struct ipu_isys_pipeline *ip);
+void
+ipu_isys_buffer_to_fw_frame_buff_pin(struct vb2_buffer *vb,
+				     struct ipu_fw_isys_frame_buff_set_abi *
+				     set);
+void
+ipu_isys_buffer_to_fw_frame_buff(struct ipu_fw_isys_frame_buff_set_abi *set,
+				 struct ipu_isys_pipeline *ip,
+				 struct ipu_isys_buffer_list *bl);
+int ipu_isys_link_fmt_validate(struct ipu_isys_queue *aq);
+
+void
+ipu_isys_buf_calc_sequence_time(struct ipu_isys_buffer *ib,
+				struct ipu_fw_isys_resp_info_abi *info);
+void ipu_isys_queue_buf_done(struct ipu_isys_buffer *ib);
+void ipu_isys_queue_buf_ready(struct ipu_isys_pipeline *ip,
+			      struct ipu_fw_isys_resp_info_abi *info);
+void
+ipu_isys_queue_short_packet_ready(struct ipu_isys_pipeline *ip,
+				  struct ipu_fw_isys_resp_info_abi *inf);
+
+int ipu_isys_queue_init(struct ipu_isys_queue *aq);
+void ipu_isys_queue_cleanup(struct ipu_isys_queue *aq);
+
+#endif /* IPU_ISYS_QUEUE_H */
Index: b/drivers/media/pci/intel/ipu-isys-subdev.c
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu-isys-subdev.c
@@ -0,0 +1,662 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) 2013 - 2020 Intel Corporation
+
+#include <linux/types.h>
+#include <linux/videodev2.h>
+
+#include <media/media-entity.h>
+
+#include <uapi/linux/media-bus-format.h>
+
+#include "ipu-isys.h"
+#include "ipu-isys-video.h"
+#include "ipu-isys-subdev.h"
+
+unsigned int ipu_isys_mbus_code_to_bpp(u32 code)
+{
+	switch (code) {
+	case MEDIA_BUS_FMT_RGB888_1X24:
+		return 24;
+	case MEDIA_BUS_FMT_YUYV10_1X20:
+		return 20;
+	case MEDIA_BUS_FMT_Y10_1X10:
+	case MEDIA_BUS_FMT_RGB565_1X16:
+	case MEDIA_BUS_FMT_UYVY8_1X16:
+	case MEDIA_BUS_FMT_YUYV8_1X16:
+	case MEDIA_BUS_FMT_VYUY8_1X16:
+		return 16;
+	case MEDIA_BUS_FMT_SBGGR12_1X12:
+	case MEDIA_BUS_FMT_SGBRG12_1X12:
+	case MEDIA_BUS_FMT_SGRBG12_1X12:
+	case MEDIA_BUS_FMT_SRGGB12_1X12:
+		return 12;
+	case MEDIA_BUS_FMT_SBGGR10_1X10:
+	case MEDIA_BUS_FMT_SGBRG10_1X10:
+	case MEDIA_BUS_FMT_SGRBG10_1X10:
+	case MEDIA_BUS_FMT_SRGGB10_1X10:
+		return 10;
+	case MEDIA_BUS_FMT_SBGGR8_1X8:
+	case MEDIA_BUS_FMT_SGBRG8_1X8:
+	case MEDIA_BUS_FMT_SGRBG8_1X8:
+	case MEDIA_BUS_FMT_SRGGB8_1X8:
+	case MEDIA_BUS_FMT_SBGGR10_DPCM8_1X8:
+	case MEDIA_BUS_FMT_SGBRG10_DPCM8_1X8:
+	case MEDIA_BUS_FMT_SGRBG10_DPCM8_1X8:
+	case MEDIA_BUS_FMT_SRGGB10_DPCM8_1X8:
+		return 8;
+	default:
+		WARN_ON(1);
+		return -EINVAL;
+	}
+}
+
+unsigned int ipu_isys_mbus_code_to_mipi(u32 code)
+{
+	switch (code) {
+	case MEDIA_BUS_FMT_RGB565_1X16:
+		return IPU_ISYS_MIPI_CSI2_TYPE_RGB565;
+	case MEDIA_BUS_FMT_RGB888_1X24:
+		return IPU_ISYS_MIPI_CSI2_TYPE_RGB888;
+	case MEDIA_BUS_FMT_YUYV10_1X20:
+		return IPU_ISYS_MIPI_CSI2_TYPE_YUV422_10;
+	case MEDIA_BUS_FMT_UYVY8_1X16:
+	case MEDIA_BUS_FMT_YUYV8_1X16:
+	case MEDIA_BUS_FMT_VYUY8_1X16:
+		return IPU_ISYS_MIPI_CSI2_TYPE_YUV422_8;
+	case MEDIA_BUS_FMT_SBGGR12_1X12:
+	case MEDIA_BUS_FMT_SGBRG12_1X12:
+	case MEDIA_BUS_FMT_SGRBG12_1X12:
+	case MEDIA_BUS_FMT_SRGGB12_1X12:
+		return IPU_ISYS_MIPI_CSI2_TYPE_RAW12;
+	case MEDIA_BUS_FMT_Y10_1X10:
+	case MEDIA_BUS_FMT_SBGGR10_1X10:
+	case MEDIA_BUS_FMT_SGBRG10_1X10:
+	case MEDIA_BUS_FMT_SGRBG10_1X10:
+	case MEDIA_BUS_FMT_SRGGB10_1X10:
+		return IPU_ISYS_MIPI_CSI2_TYPE_RAW10;
+	case MEDIA_BUS_FMT_SBGGR8_1X8:
+	case MEDIA_BUS_FMT_SGBRG8_1X8:
+	case MEDIA_BUS_FMT_SGRBG8_1X8:
+	case MEDIA_BUS_FMT_SRGGB8_1X8:
+		return IPU_ISYS_MIPI_CSI2_TYPE_RAW8;
+	case MEDIA_BUS_FMT_SBGGR10_DPCM8_1X8:
+	case MEDIA_BUS_FMT_SGBRG10_DPCM8_1X8:
+	case MEDIA_BUS_FMT_SGRBG10_DPCM8_1X8:
+	case MEDIA_BUS_FMT_SRGGB10_DPCM8_1X8:
+		return IPU_ISYS_MIPI_CSI2_TYPE_USER_DEF(1);
+	default:
+		WARN_ON(1);
+		return -EINVAL;
+	}
+}
+
+enum ipu_isys_subdev_pixelorder ipu_isys_subdev_get_pixelorder(u32 code)
+{
+	switch (code) {
+	case MEDIA_BUS_FMT_SBGGR12_1X12:
+	case MEDIA_BUS_FMT_SBGGR10_1X10:
+	case MEDIA_BUS_FMT_SBGGR8_1X8:
+	case MEDIA_BUS_FMT_SBGGR10_DPCM8_1X8:
+		return IPU_ISYS_SUBDEV_PIXELORDER_BGGR;
+	case MEDIA_BUS_FMT_SGBRG12_1X12:
+	case MEDIA_BUS_FMT_SGBRG10_1X10:
+	case MEDIA_BUS_FMT_SGBRG8_1X8:
+	case MEDIA_BUS_FMT_SGBRG10_DPCM8_1X8:
+		return IPU_ISYS_SUBDEV_PIXELORDER_GBRG;
+	case MEDIA_BUS_FMT_SGRBG12_1X12:
+	case MEDIA_BUS_FMT_SGRBG10_1X10:
+	case MEDIA_BUS_FMT_SGRBG8_1X8:
+	case MEDIA_BUS_FMT_SGRBG10_DPCM8_1X8:
+		return IPU_ISYS_SUBDEV_PIXELORDER_GRBG;
+	case MEDIA_BUS_FMT_SRGGB12_1X12:
+	case MEDIA_BUS_FMT_SRGGB10_1X10:
+	case MEDIA_BUS_FMT_SRGGB8_1X8:
+	case MEDIA_BUS_FMT_SRGGB10_DPCM8_1X8:
+		return IPU_ISYS_SUBDEV_PIXELORDER_RGGB;
+	default:
+		WARN_ON(1);
+		return -EINVAL;
+	}
+}
+
+u32 ipu_isys_subdev_code_to_uncompressed(u32 sink_code)
+{
+	switch (sink_code) {
+	case MEDIA_BUS_FMT_SBGGR10_DPCM8_1X8:
+		return MEDIA_BUS_FMT_SBGGR10_1X10;
+	case MEDIA_BUS_FMT_SGBRG10_DPCM8_1X8:
+		return MEDIA_BUS_FMT_SGBRG10_1X10;
+	case MEDIA_BUS_FMT_SGRBG10_DPCM8_1X8:
+		return MEDIA_BUS_FMT_SGRBG10_1X10;
+	case MEDIA_BUS_FMT_SRGGB10_DPCM8_1X8:
+		return MEDIA_BUS_FMT_SRGGB10_1X10;
+	default:
+		return sink_code;
+	}
+}
+
+struct v4l2_mbus_framefmt *__ipu_isys_get_ffmt(struct v4l2_subdev *sd,
+					       struct v4l2_subdev_state *state,
+					       unsigned int pad,
+					       unsigned int which)
+{
+	struct ipu_isys_subdev *asd = to_ipu_isys_subdev(sd);
+
+	if (which == V4L2_SUBDEV_FORMAT_ACTIVE)
+		return &asd->ffmt[pad];
+	else
+		return v4l2_subdev_get_try_format(sd, state, pad);
+}
+
+struct v4l2_rect *__ipu_isys_get_selection(struct v4l2_subdev *sd,
+					   struct v4l2_subdev_state *state,
+					   unsigned int target,
+					   unsigned int pad, unsigned int which)
+{
+	struct ipu_isys_subdev *asd = to_ipu_isys_subdev(sd);
+
+	if (which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+		switch (target) {
+		case V4L2_SEL_TGT_CROP:
+			return &asd->crop[pad];
+		case V4L2_SEL_TGT_COMPOSE:
+			return &asd->compose[pad];
+		}
+	} else {
+		switch (target) {
+		case V4L2_SEL_TGT_CROP:
+			return v4l2_subdev_get_try_crop(sd, state, pad);
+		case V4L2_SEL_TGT_COMPOSE:
+			return v4l2_subdev_get_try_compose(sd, state, pad);
+		}
+	}
+	WARN_ON(1);
+	return NULL;
+}
+
+static int target_valid(struct v4l2_subdev *sd, unsigned int target,
+			unsigned int pad)
+{
+	struct ipu_isys_subdev *asd = to_ipu_isys_subdev(sd);
+
+	switch (target) {
+	case V4L2_SEL_TGT_CROP:
+		return asd->valid_tgts[pad].crop;
+	case V4L2_SEL_TGT_COMPOSE:
+		return asd->valid_tgts[pad].compose;
+	default:
+		return 0;
+	}
+}
+
+int ipu_isys_subdev_fmt_propagate(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_state *state,
+				  struct v4l2_mbus_framefmt *ffmt,
+				  struct v4l2_rect *r,
+				  enum isys_subdev_prop_tgt tgt,
+				  unsigned int pad, unsigned int which)
+{
+	struct ipu_isys_subdev *asd = to_ipu_isys_subdev(sd);
+	struct v4l2_mbus_framefmt **ffmts = NULL;
+	struct v4l2_rect **crops = NULL;
+	struct v4l2_rect **compose = NULL;
+	unsigned int i;
+	int rval = 0;
+
+	if (tgt == IPU_ISYS_SUBDEV_PROP_TGT_NR_OF)
+		return 0;
+
+	if (WARN_ON(pad >= sd->entity.num_pads))
+		return -EINVAL;
+
+	ffmts = kcalloc(sd->entity.num_pads,
+			sizeof(*ffmts), GFP_KERNEL);
+	if (!ffmts) {
+		rval = -ENOMEM;
+		goto out_subdev_fmt_propagate;
+	}
+	crops = kcalloc(sd->entity.num_pads,
+			sizeof(*crops), GFP_KERNEL);
+	if (!crops) {
+		rval = -ENOMEM;
+		goto out_subdev_fmt_propagate;
+	}
+	compose = kcalloc(sd->entity.num_pads,
+			  sizeof(*compose), GFP_KERNEL);
+	if (!compose) {
+		rval = -ENOMEM;
+		goto out_subdev_fmt_propagate;
+	}
+
+	for (i = 0; i < sd->entity.num_pads; i++) {
+		ffmts[i] = __ipu_isys_get_ffmt(sd, state, i, which);
+		crops[i] = __ipu_isys_get_selection(sd, state, V4L2_SEL_TGT_CROP,
+						    i, which);
+		compose[i] = __ipu_isys_get_selection(sd, state,
+						      V4L2_SEL_TGT_COMPOSE,
+						      i, which);
+	}
+
+	switch (tgt) {
+	case IPU_ISYS_SUBDEV_PROP_TGT_SINK_FMT:
+		crops[pad]->left = 0;
+		crops[pad]->top = 0;
+		crops[pad]->width = ffmt->width;
+		crops[pad]->height = ffmt->height;
+		rval = ipu_isys_subdev_fmt_propagate(sd, state, ffmt, crops[pad],
+						     tgt + 1, pad, which);
+		goto out_subdev_fmt_propagate;
+	case IPU_ISYS_SUBDEV_PROP_TGT_SINK_CROP:
+		if (WARN_ON(sd->entity.pads[pad].flags & MEDIA_PAD_FL_SOURCE))
+			goto out_subdev_fmt_propagate;
+
+		compose[pad]->left = 0;
+		compose[pad]->top = 0;
+		compose[pad]->width = r->width;
+		compose[pad]->height = r->height;
+		rval = ipu_isys_subdev_fmt_propagate(sd, state, ffmt,
+						     compose[pad], tgt + 1,
+						     pad, which);
+		goto out_subdev_fmt_propagate;
+	case IPU_ISYS_SUBDEV_PROP_TGT_SINK_COMPOSE:
+		if (WARN_ON(sd->entity.pads[pad].flags & MEDIA_PAD_FL_SOURCE)) {
+			rval = -EINVAL;
+			goto out_subdev_fmt_propagate;
+		}
+
+		for (i = 1; i < sd->entity.num_pads; i++) {
+			if (!(sd->entity.pads[i].flags &
+					MEDIA_PAD_FL_SOURCE))
+				continue;
+
+			compose[i]->left = 0;
+			compose[i]->top = 0;
+			compose[i]->width = r->width;
+			compose[i]->height = r->height;
+			rval = ipu_isys_subdev_fmt_propagate(sd, state,
+							     ffmt,
+							     compose[i],
+							     tgt + 1, i,
+							     which);
+			if (rval)
+				goto out_subdev_fmt_propagate;
+		}
+		goto out_subdev_fmt_propagate;
+	case IPU_ISYS_SUBDEV_PROP_TGT_SOURCE_COMPOSE:
+		if (WARN_ON(sd->entity.pads[pad].flags & MEDIA_PAD_FL_SINK)) {
+			rval = -EINVAL;
+			goto out_subdev_fmt_propagate;
+		}
+
+		crops[pad]->left = 0;
+		crops[pad]->top = 0;
+		crops[pad]->width = r->width;
+		crops[pad]->height = r->height;
+		rval = ipu_isys_subdev_fmt_propagate(sd, state, ffmt,
+						     crops[pad], tgt + 1,
+						     pad, which);
+		goto out_subdev_fmt_propagate;
+	case IPU_ISYS_SUBDEV_PROP_TGT_SOURCE_CROP:{
+			struct v4l2_subdev_format fmt = {
+				.which = which,
+				.pad = pad,
+				.format = {
+					.width = r->width,
+					.height = r->height,
+					/*
+					 * Either use the code from sink pad
+					 * or the current one.
+					 */
+					.code = ffmt ? ffmt->code :
+						       ffmts[pad]->code,
+					.field = ffmt ? ffmt->field :
+							ffmts[pad]->field,
+				},
+			};
+
+			asd->set_ffmt(sd, state, &fmt);
+			goto out_subdev_fmt_propagate;
+		}
+	}
+
+out_subdev_fmt_propagate:
+	kfree(ffmts);
+	kfree(crops);
+	kfree(compose);
+	return rval;
+}
+
+int ipu_isys_subdev_set_ffmt_default(struct v4l2_subdev *sd,
+				     struct v4l2_subdev_state *state,
+				     struct v4l2_subdev_format *fmt)
+{
+	struct v4l2_mbus_framefmt *ffmt =
+		__ipu_isys_get_ffmt(sd, state, fmt->pad, fmt->which);
+
+	/* No propagation for non-zero pads. */
+	if (fmt->pad) {
+		struct v4l2_mbus_framefmt *sink_ffmt =
+			__ipu_isys_get_ffmt(sd, state, 0, fmt->which);
+
+		ffmt->width = sink_ffmt->width;
+		ffmt->height = sink_ffmt->height;
+		ffmt->code = sink_ffmt->code;
+		ffmt->field = sink_ffmt->field;
+
+		return 0;
+	}
+
+	ffmt->width = fmt->format.width;
+	ffmt->height = fmt->format.height;
+	ffmt->code = fmt->format.code;
+	ffmt->field = fmt->format.field;
+
+	return ipu_isys_subdev_fmt_propagate(sd, state, &fmt->format, NULL,
+					     IPU_ISYS_SUBDEV_PROP_TGT_SINK_FMT,
+					     fmt->pad, fmt->which);
+}
+
+int __ipu_isys_subdev_set_ffmt(struct v4l2_subdev *sd,
+			       struct v4l2_subdev_state *state,
+			       struct v4l2_subdev_format *fmt)
+{
+	struct ipu_isys_subdev *asd = to_ipu_isys_subdev(sd);
+	struct v4l2_mbus_framefmt *ffmt =
+		__ipu_isys_get_ffmt(sd, state, fmt->pad, fmt->which);
+	u32 code = asd->supported_codes[fmt->pad][0];
+	unsigned int i;
+
+	WARN_ON(!mutex_is_locked(&asd->mutex));
+
+	fmt->format.width = clamp(fmt->format.width, IPU_ISYS_MIN_WIDTH,
+				  IPU_ISYS_MAX_WIDTH);
+	fmt->format.height = clamp(fmt->format.height,
+				   IPU_ISYS_MIN_HEIGHT, IPU_ISYS_MAX_HEIGHT);
+
+	for (i = 0; asd->supported_codes[fmt->pad][i]; i++) {
+		if (asd->supported_codes[fmt->pad][i] == fmt->format.code) {
+			code = asd->supported_codes[fmt->pad][i];
+			break;
+		}
+	}
+
+	fmt->format.code = code;
+
+	asd->set_ffmt(sd, state, fmt);
+
+	fmt->format = *ffmt;
+
+	return 0;
+}
+
+int ipu_isys_subdev_set_ffmt(struct v4l2_subdev *sd,
+			     struct v4l2_subdev_state *state,
+			     struct v4l2_subdev_format *fmt)
+{
+	struct ipu_isys_subdev *asd = to_ipu_isys_subdev(sd);
+	int rval;
+
+	mutex_lock(&asd->mutex);
+	rval = __ipu_isys_subdev_set_ffmt(sd, state, fmt);
+	mutex_unlock(&asd->mutex);
+
+	return rval;
+}
+
+int ipu_isys_subdev_get_ffmt(struct v4l2_subdev *sd,
+			     struct v4l2_subdev_state *state,
+			     struct v4l2_subdev_format *fmt)
+{
+	struct ipu_isys_subdev *asd = to_ipu_isys_subdev(sd);
+
+	mutex_lock(&asd->mutex);
+	fmt->format = *__ipu_isys_get_ffmt(sd, state, fmt->pad,
+					   fmt->which);
+	mutex_unlock(&asd->mutex);
+
+	return 0;
+}
+
+int ipu_isys_subdev_set_sel(struct v4l2_subdev *sd,
+			    struct v4l2_subdev_state *state,
+			    struct v4l2_subdev_selection *sel)
+{
+	struct ipu_isys_subdev *asd = to_ipu_isys_subdev(sd);
+	struct media_pad *pad = &asd->sd.entity.pads[sel->pad];
+	struct v4l2_rect *r, __r = { 0 };
+	unsigned int tgt;
+
+	if (!target_valid(sd, sel->target, sel->pad))
+		return -EINVAL;
+
+	switch (sel->target) {
+	case V4L2_SEL_TGT_CROP:
+		if (pad->flags & MEDIA_PAD_FL_SINK) {
+			struct v4l2_mbus_framefmt *ffmt =
+				__ipu_isys_get_ffmt(sd, state, sel->pad,
+						    sel->which);
+
+			__r.width = ffmt->width;
+			__r.height = ffmt->height;
+			r = &__r;
+			tgt = IPU_ISYS_SUBDEV_PROP_TGT_SINK_CROP;
+		} else {
+			/* 0 is the sink pad. */
+			r = __ipu_isys_get_selection(sd, state, sel->target, 0,
+						     sel->which);
+			tgt = IPU_ISYS_SUBDEV_PROP_TGT_SOURCE_CROP;
+		}
+
+		break;
+	case V4L2_SEL_TGT_COMPOSE:
+		if (pad->flags & MEDIA_PAD_FL_SINK) {
+			r = __ipu_isys_get_selection(sd, state, V4L2_SEL_TGT_CROP,
+						     sel->pad, sel->which);
+			tgt = IPU_ISYS_SUBDEV_PROP_TGT_SINK_COMPOSE;
+		} else {
+			r = __ipu_isys_get_selection(sd, state,
+						     V4L2_SEL_TGT_COMPOSE, 0,
+						     sel->which);
+			tgt = IPU_ISYS_SUBDEV_PROP_TGT_SOURCE_COMPOSE;
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	sel->r.width = clamp(sel->r.width, IPU_ISYS_MIN_WIDTH, r->width);
+	sel->r.height = clamp(sel->r.height, IPU_ISYS_MIN_HEIGHT, r->height);
+	*__ipu_isys_get_selection(sd, state, sel->target, sel->pad,
+				  sel->which) = sel->r;
+	return ipu_isys_subdev_fmt_propagate(sd, state, NULL, &sel->r, tgt,
+					     sel->pad, sel->which);
+}
+
+int ipu_isys_subdev_get_sel(struct v4l2_subdev *sd,
+			    struct v4l2_subdev_state *state,
+			    struct v4l2_subdev_selection *sel)
+{
+	if (!target_valid(sd, sel->target, sel->pad))
+		return -EINVAL;
+
+	sel->r = *__ipu_isys_get_selection(sd, state, sel->target,
+					   sel->pad, sel->which);
+
+	return 0;
+}
+
+int ipu_isys_subdev_enum_mbus_code(struct v4l2_subdev *sd,
+				   struct v4l2_subdev_state *state,
+				   struct v4l2_subdev_mbus_code_enum *code)
+{
+	struct ipu_isys_subdev *asd = to_ipu_isys_subdev(sd);
+	const u32 *supported_codes = asd->supported_codes[code->pad];
+	u32 index;
+
+	for (index = 0; supported_codes[index]; index++) {
+		if (index == code->index) {
+			code->code = supported_codes[index];
+			return 0;
+		}
+	}
+
+	return -EINVAL;
+}
+
+/*
+ * Besides validating the link, figure out the external pad and the
+ * ISYS FW ABI source.
+ */
+int ipu_isys_subdev_link_validate(struct v4l2_subdev *sd,
+				  struct media_link *link,
+				  struct v4l2_subdev_format *source_fmt,
+				  struct v4l2_subdev_format *sink_fmt)
+{
+	struct v4l2_subdev *source_sd =
+	    media_entity_to_v4l2_subdev(link->source->entity);
+	struct ipu_isys_pipeline *ip =
+		to_ipu_isys_pipeline(media_entity_pipeline(&sd->entity));
+	struct ipu_isys_subdev *asd = to_ipu_isys_subdev(sd);
+
+	if (!source_sd)
+		return -ENODEV;
+	if (strncmp(source_sd->name, IPU_ISYS_ENTITY_PREFIX,
+		    strlen(IPU_ISYS_ENTITY_PREFIX)) != 0) {
+		/*
+		 * source_sd isn't ours --- sd must be the external
+		 * sub-device.
+		 */
+		ip->external = link->source;
+		ip->source = to_ipu_isys_subdev(sd)->source;
+		dev_dbg(&asd->isys->adev->dev, "%s: using source %d\n",
+			sd->entity.name, ip->source);
+		/*
+		 * multi streams with different format/resolusion from external,
+		 * without route info, ignore link validate here.
+		 */
+		return 0;
+	} else if (source_sd->entity.num_pads == 1) {
+		/* All internal sources have a single pad. */
+		ip->external = link->source;
+		ip->source = to_ipu_isys_subdev(source_sd)->source;
+
+		dev_dbg(&asd->isys->adev->dev, "%s: using source %d\n",
+			sd->entity.name, ip->source);
+	}
+
+	if (asd->isl_mode != IPU_ISL_OFF)
+		ip->isl_mode = asd->isl_mode;
+
+	return v4l2_subdev_link_validate_default(sd, link, source_fmt,
+						 sink_fmt);
+}
+
+int ipu_isys_subdev_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct ipu_isys_subdev *asd = to_ipu_isys_subdev(sd);
+	unsigned int i;
+
+	mutex_lock(&asd->mutex);
+
+	for (i = 0; i < asd->sd.entity.num_pads; i++) {
+		struct v4l2_mbus_framefmt *try_fmt =
+			v4l2_subdev_get_try_format(sd, fh->state, i);
+		struct v4l2_rect *try_crop =
+			v4l2_subdev_get_try_crop(sd, fh->state, i);
+		struct v4l2_rect *try_compose =
+			v4l2_subdev_get_try_compose(sd, fh->state, i);
+
+		*try_fmt = asd->ffmt[i];
+		*try_crop = asd->crop[i];
+		*try_compose = asd->compose[i];
+	}
+
+	mutex_unlock(&asd->mutex);
+
+	return 0;
+}
+
+int ipu_isys_subdev_close(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	return 0;
+}
+
+int ipu_isys_subdev_init(struct ipu_isys_subdev *asd,
+			 struct v4l2_subdev_ops *ops,
+			 unsigned int nr_ctrls,
+			 unsigned int num_pads,
+			 unsigned int num_source,
+			 unsigned int num_sink,
+			 unsigned int sd_flags)
+{
+	int rval = -EINVAL;
+
+	mutex_init(&asd->mutex);
+
+	v4l2_subdev_init(&asd->sd, ops);
+
+	asd->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE | sd_flags;
+	asd->sd.owner = THIS_MODULE;
+	asd->sd.entity.function = MEDIA_ENT_F_VID_IF_BRIDGE;
+
+	asd->nsources = num_source;
+	asd->nsinks = num_sink;
+
+	asd->pad = devm_kcalloc(&asd->isys->adev->dev, num_pads,
+				sizeof(*asd->pad), GFP_KERNEL);
+
+	asd->ffmt = devm_kcalloc(&asd->isys->adev->dev, num_pads,
+				 sizeof(*asd->ffmt), GFP_KERNEL);
+
+	asd->crop = devm_kcalloc(&asd->isys->adev->dev, num_pads,
+				 sizeof(*asd->crop), GFP_KERNEL);
+
+	asd->compose = devm_kcalloc(&asd->isys->adev->dev, num_pads,
+				    sizeof(*asd->compose), GFP_KERNEL);
+
+	asd->valid_tgts = devm_kcalloc(&asd->isys->adev->dev, num_pads,
+				       sizeof(*asd->valid_tgts), GFP_KERNEL);
+	if (!asd->pad || !asd->ffmt || !asd->crop || !asd->compose ||
+	    !asd->valid_tgts)
+		return -ENOMEM;
+
+	rval = media_entity_pads_init(&asd->sd.entity, num_pads, asd->pad);
+	if (rval)
+		goto out_mutex_destroy;
+
+	if (asd->ctrl_init) {
+		rval = v4l2_ctrl_handler_init(&asd->ctrl_handler, nr_ctrls);
+		if (rval)
+			goto out_media_entity_cleanup;
+
+		asd->ctrl_init(&asd->sd);
+		if (asd->ctrl_handler.error) {
+			rval = asd->ctrl_handler.error;
+			goto out_v4l2_ctrl_handler_free;
+		}
+
+		asd->sd.ctrl_handler = &asd->ctrl_handler;
+	}
+
+	asd->source = -1;
+
+	return 0;
+
+out_v4l2_ctrl_handler_free:
+	v4l2_ctrl_handler_free(&asd->ctrl_handler);
+
+out_media_entity_cleanup:
+	media_entity_cleanup(&asd->sd.entity);
+
+out_mutex_destroy:
+	mutex_destroy(&asd->mutex);
+
+	return rval;
+}
+
+void ipu_isys_subdev_cleanup(struct ipu_isys_subdev *asd)
+{
+	media_entity_cleanup(&asd->sd.entity);
+	v4l2_ctrl_handler_free(&asd->ctrl_handler);
+	mutex_destroy(&asd->mutex);
+}
Index: b/drivers/media/pci/intel/ipu-isys-subdev.h
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu-isys-subdev.h
@@ -0,0 +1,152 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2013 - 2020 Intel Corporation */
+
+#ifndef IPU_ISYS_SUBDEV_H
+#define IPU_ISYS_SUBDEV_H
+
+#include <linux/mutex.h>
+
+#include <media/media-entity.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-ctrls.h>
+
+#include "ipu-isys-queue.h"
+
+#define IPU_ISYS_MIPI_CSI2_TYPE_NULL	0x10
+#define IPU_ISYS_MIPI_CSI2_TYPE_BLANKING	0x11
+#define IPU_ISYS_MIPI_CSI2_TYPE_EMBEDDED8	0x12
+#define IPU_ISYS_MIPI_CSI2_TYPE_YUV422_8	0x1e
+#define IPU_ISYS_MIPI_CSI2_TYPE_YUV422_10	0x1f
+#define IPU_ISYS_MIPI_CSI2_TYPE_RGB565	0x22
+#define IPU_ISYS_MIPI_CSI2_TYPE_RGB888	0x24
+#define IPU_ISYS_MIPI_CSI2_TYPE_RAW6	0x28
+#define IPU_ISYS_MIPI_CSI2_TYPE_RAW7	0x29
+#define IPU_ISYS_MIPI_CSI2_TYPE_RAW8	0x2a
+#define IPU_ISYS_MIPI_CSI2_TYPE_RAW10	0x2b
+#define IPU_ISYS_MIPI_CSI2_TYPE_RAW12	0x2c
+#define IPU_ISYS_MIPI_CSI2_TYPE_RAW14	0x2d
+/* 1-8 */
+#define IPU_ISYS_MIPI_CSI2_TYPE_USER_DEF(i)	(0x30 + (i) - 1)
+
+#define FMT_ENTRY (struct ipu_isys_fmt_entry [])
+
+enum isys_subdev_prop_tgt {
+	IPU_ISYS_SUBDEV_PROP_TGT_SINK_FMT,
+	IPU_ISYS_SUBDEV_PROP_TGT_SINK_CROP,
+	IPU_ISYS_SUBDEV_PROP_TGT_SINK_COMPOSE,
+	IPU_ISYS_SUBDEV_PROP_TGT_SOURCE_COMPOSE,
+	IPU_ISYS_SUBDEV_PROP_TGT_SOURCE_CROP,
+};
+
+#define	IPU_ISYS_SUBDEV_PROP_TGT_NR_OF \
+	(IPU_ISYS_SUBDEV_PROP_TGT_SOURCE_CROP + 1)
+
+enum ipu_isl_mode {
+	IPU_ISL_OFF = 0,	/* SOC BE */
+	IPU_ISL_CSI2_BE,	/* RAW BE */
+};
+
+enum ipu_be_mode {
+	IPU_BE_RAW = 0,
+	IPU_BE_SOC
+};
+
+enum ipu_isys_subdev_pixelorder {
+	IPU_ISYS_SUBDEV_PIXELORDER_BGGR = 0,
+	IPU_ISYS_SUBDEV_PIXELORDER_GBRG,
+	IPU_ISYS_SUBDEV_PIXELORDER_GRBG,
+	IPU_ISYS_SUBDEV_PIXELORDER_RGGB,
+};
+
+struct ipu_isys;
+
+struct ipu_isys_subdev {
+	/* Serialise access to any other field in the struct */
+	struct mutex mutex;
+	struct v4l2_subdev sd;
+	struct ipu_isys *isys;
+	u32 const *const *supported_codes;
+	struct media_pad *pad;
+	struct v4l2_mbus_framefmt *ffmt;
+	struct v4l2_rect *crop;
+	struct v4l2_rect *compose;
+	unsigned int nsinks;
+	unsigned int nsources;
+	struct v4l2_ctrl_handler ctrl_handler;
+	void (*ctrl_init)(struct v4l2_subdev *sd);
+	void (*set_ffmt)(struct v4l2_subdev *sd,
+			 struct v4l2_subdev_state *state,
+			 struct v4l2_subdev_format *fmt);
+	struct {
+		bool crop;
+		bool compose;
+	} *valid_tgts;
+	enum ipu_isl_mode isl_mode;
+	enum ipu_be_mode be_mode;
+	int source;	/* SSI stream source; -1 if unset */
+};
+
+#define to_ipu_isys_subdev(__sd) \
+	container_of(__sd, struct ipu_isys_subdev, sd)
+
+struct v4l2_mbus_framefmt *__ipu_isys_get_ffmt(struct v4l2_subdev *sd,
+					       struct v4l2_subdev_state *state,
+					       unsigned int pad,
+					       unsigned int which);
+
+unsigned int ipu_isys_mbus_code_to_bpp(u32 code);
+unsigned int ipu_isys_mbus_code_to_mipi(u32 code);
+u32 ipu_isys_subdev_code_to_uncompressed(u32 sink_code);
+
+enum ipu_isys_subdev_pixelorder ipu_isys_subdev_get_pixelorder(u32 code);
+
+int ipu_isys_subdev_fmt_propagate(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_state *state,
+				  struct v4l2_mbus_framefmt *ffmt,
+				  struct v4l2_rect *r,
+				  enum isys_subdev_prop_tgt tgt,
+				  unsigned int pad, unsigned int which);
+
+int ipu_isys_subdev_set_ffmt_default(struct v4l2_subdev *sd,
+				     struct v4l2_subdev_state *state,
+				     struct v4l2_subdev_format *fmt);
+int __ipu_isys_subdev_set_ffmt(struct v4l2_subdev *sd,
+			       struct v4l2_subdev_state *state,
+			       struct v4l2_subdev_format *fmt);
+struct v4l2_rect *__ipu_isys_get_selection(struct v4l2_subdev *sd,
+					   struct v4l2_subdev_state *state,
+					   unsigned int target,
+					   unsigned int pad,
+					   unsigned int which);
+int ipu_isys_subdev_set_ffmt(struct v4l2_subdev *sd,
+			     struct v4l2_subdev_state *state,
+			     struct v4l2_subdev_format *fmt);
+int ipu_isys_subdev_get_ffmt(struct v4l2_subdev *sd,
+			     struct v4l2_subdev_state *state,
+			     struct v4l2_subdev_format *fmt);
+int ipu_isys_subdev_get_sel(struct v4l2_subdev *sd,
+			    struct v4l2_subdev_state *state,
+			    struct v4l2_subdev_selection *sel);
+int ipu_isys_subdev_set_sel(struct v4l2_subdev *sd,
+			    struct v4l2_subdev_state *state,
+			    struct v4l2_subdev_selection *sel);
+int ipu_isys_subdev_enum_mbus_code(struct v4l2_subdev *sd,
+				   struct v4l2_subdev_state *state,
+				   struct v4l2_subdev_mbus_code_enum
+				   *code);
+int ipu_isys_subdev_link_validate(struct v4l2_subdev *sd,
+				  struct media_link *link,
+				  struct v4l2_subdev_format *source_fmt,
+				  struct v4l2_subdev_format *sink_fmt);
+
+int ipu_isys_subdev_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh);
+int ipu_isys_subdev_close(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh);
+int ipu_isys_subdev_init(struct ipu_isys_subdev *asd,
+			 struct v4l2_subdev_ops *ops,
+			 unsigned int nr_ctrls,
+			 unsigned int num_pads,
+			 unsigned int num_source,
+			 unsigned int num_sink,
+			 unsigned int sd_flags);
+void ipu_isys_subdev_cleanup(struct ipu_isys_subdev *asd);
+#endif /* IPU_ISYS_SUBDEV_H */
Index: b/drivers/media/pci/intel/ipu-isys-tpg.c
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu-isys-tpg.c
@@ -0,0 +1,311 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) 2013 - 2020 Intel Corporation
+
+#include <linux/device.h>
+#include <linux/module.h>
+
+#include <media/media-entity.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-event.h>
+
+#include "ipu.h"
+#include "ipu-bus.h"
+#include "ipu-isys.h"
+#include "ipu-isys-subdev.h"
+#include "ipu-isys-tpg.h"
+#include "ipu-isys-video.h"
+#include "ipu-platform-isys-csi2-reg.h"
+
+static const u32 tpg_supported_codes_pad[] = {
+	MEDIA_BUS_FMT_SBGGR8_1X8,
+	MEDIA_BUS_FMT_SGBRG8_1X8,
+	MEDIA_BUS_FMT_SGRBG8_1X8,
+	MEDIA_BUS_FMT_SRGGB8_1X8,
+	MEDIA_BUS_FMT_SBGGR10_1X10,
+	MEDIA_BUS_FMT_SGBRG10_1X10,
+	MEDIA_BUS_FMT_SGRBG10_1X10,
+	MEDIA_BUS_FMT_SRGGB10_1X10,
+	0,
+};
+
+static const u32 *tpg_supported_codes[] = {
+	tpg_supported_codes_pad,
+};
+
+static struct v4l2_subdev_internal_ops tpg_sd_internal_ops = {
+	.open = ipu_isys_subdev_open,
+	.close = ipu_isys_subdev_close,
+};
+
+static const struct v4l2_subdev_video_ops tpg_sd_video_ops = {
+	.s_stream = tpg_set_stream,
+};
+
+static int ipu_isys_tpg_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct ipu_isys_tpg *tpg = container_of(container_of(ctrl->handler,
+							     struct
+							     ipu_isys_subdev,
+							     ctrl_handler),
+						struct ipu_isys_tpg, asd);
+
+	switch (ctrl->id) {
+	case V4L2_CID_HBLANK:
+		writel(ctrl->val, tpg->base + MIPI_GEN_REG_SYNG_HBLANK_CYC);
+		break;
+	case V4L2_CID_VBLANK:
+		writel(ctrl->val, tpg->base + MIPI_GEN_REG_SYNG_VBLANK_CYC);
+		break;
+	case V4L2_CID_TEST_PATTERN:
+		writel(ctrl->val, tpg->base + MIPI_GEN_REG_TPG_MODE);
+		break;
+	}
+
+	return 0;
+}
+
+static const struct v4l2_ctrl_ops ipu_isys_tpg_ctrl_ops = {
+	.s_ctrl = ipu_isys_tpg_s_ctrl,
+};
+
+static s64 ipu_isys_tpg_rate(struct ipu_isys_tpg *tpg, unsigned int bpp)
+{
+	return MIPI_GEN_PPC * IPU_ISYS_FREQ / bpp;
+}
+
+static const char *const tpg_mode_items[] = {
+	"Ramp",
+	"Checkerboard",	/* Does not work, disabled. */
+	"Frame Based Colour",
+};
+
+static struct v4l2_ctrl_config tpg_mode = {
+	.ops = &ipu_isys_tpg_ctrl_ops,
+	.id = V4L2_CID_TEST_PATTERN,
+	.name = "Test Pattern",
+	.type = V4L2_CTRL_TYPE_MENU,
+	.min = 0,
+	.max = ARRAY_SIZE(tpg_mode_items) - 1,
+	.def = 0,
+	.menu_skip_mask = 0x2,
+	.qmenu = tpg_mode_items,
+};
+
+static const struct v4l2_ctrl_config csi2_header_cfg = {
+	.id = V4L2_CID_IPU_STORE_CSI2_HEADER,
+	.name = "Store CSI-2 Headers",
+	.type = V4L2_CTRL_TYPE_BOOLEAN,
+	.min = 0,
+	.max = 1,
+	.step = 1,
+	.def = 1,
+};
+
+static void ipu_isys_tpg_init_controls(struct v4l2_subdev *sd)
+{
+	struct ipu_isys_tpg *tpg = to_ipu_isys_tpg(sd);
+	int hblank;
+	u64 default_pixel_rate;
+
+	hblank = 1024;
+
+	tpg->hblank = v4l2_ctrl_new_std(&tpg->asd.ctrl_handler,
+					&ipu_isys_tpg_ctrl_ops,
+					V4L2_CID_HBLANK, 8, 65535, 1, hblank);
+
+	tpg->vblank = v4l2_ctrl_new_std(&tpg->asd.ctrl_handler,
+					&ipu_isys_tpg_ctrl_ops,
+					V4L2_CID_VBLANK, 8, 65535, 1, 1024);
+
+	default_pixel_rate = ipu_isys_tpg_rate(tpg, 8);
+	tpg->pixel_rate = v4l2_ctrl_new_std(&tpg->asd.ctrl_handler,
+					    &ipu_isys_tpg_ctrl_ops,
+					    V4L2_CID_PIXEL_RATE,
+					    default_pixel_rate,
+					    default_pixel_rate,
+					    1, default_pixel_rate);
+	if (tpg->pixel_rate) {
+		tpg->pixel_rate->cur.val = default_pixel_rate;
+		tpg->pixel_rate->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+	}
+
+	v4l2_ctrl_new_custom(&tpg->asd.ctrl_handler, &tpg_mode, NULL);
+	tpg->store_csi2_header =
+		v4l2_ctrl_new_custom(&tpg->asd.ctrl_handler,
+				     &csi2_header_cfg, NULL);
+}
+
+static void tpg_set_ffmt(struct v4l2_subdev *sd,
+			 struct v4l2_subdev_state *state,
+			 struct v4l2_subdev_format *fmt)
+{
+	fmt->format.field = V4L2_FIELD_NONE;
+	*__ipu_isys_get_ffmt(sd, state, fmt->pad, fmt->which) = fmt->format;
+}
+
+static int ipu_isys_tpg_set_ffmt(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_state *state,
+				 struct v4l2_subdev_format *fmt)
+{
+	struct ipu_isys_tpg *tpg = to_ipu_isys_tpg(sd);
+	__u32 code = tpg->asd.ffmt[TPG_PAD_SOURCE].code;
+	unsigned int bpp = ipu_isys_mbus_code_to_bpp(code);
+	s64 tpg_rate = ipu_isys_tpg_rate(tpg, bpp);
+	int rval;
+
+	mutex_lock(&tpg->asd.mutex);
+	rval = __ipu_isys_subdev_set_ffmt(sd, state, fmt);
+	mutex_unlock(&tpg->asd.mutex);
+
+	if (rval || fmt->which != V4L2_SUBDEV_FORMAT_ACTIVE)
+		return rval;
+
+	v4l2_ctrl_s_ctrl_int64(tpg->pixel_rate, tpg_rate);
+
+	return 0;
+}
+
+static const struct ipu_isys_pixelformat *
+ipu_isys_tpg_try_fmt(struct ipu_isys_video *av,
+		     struct v4l2_pix_format_mplane *mpix)
+{
+	struct media_link *link = list_first_entry(&av->vdev.entity.links,
+						   struct media_link, list);
+	struct v4l2_subdev *sd =
+		media_entity_to_v4l2_subdev(link->source->entity);
+	struct ipu_isys_tpg *tpg;
+
+	if (!sd)
+		return NULL;
+
+	tpg = to_ipu_isys_tpg(sd);
+
+	return ipu_isys_video_try_fmt_vid_mplane(av, mpix,
+		v4l2_ctrl_g_ctrl(tpg->store_csi2_header));
+}
+
+static const struct v4l2_subdev_pad_ops tpg_sd_pad_ops = {
+	.get_fmt = ipu_isys_subdev_get_ffmt,
+	.set_fmt = ipu_isys_tpg_set_ffmt,
+	.enum_mbus_code = ipu_isys_subdev_enum_mbus_code,
+};
+
+static int subscribe_event(struct v4l2_subdev *sd, struct v4l2_fh *fh,
+			   struct v4l2_event_subscription *sub)
+{
+	switch (sub->type) {
+#ifdef IPU_TPG_FRAME_SYNC
+	case V4L2_EVENT_FRAME_SYNC:
+		return v4l2_event_subscribe(fh, sub, 10, NULL);
+#endif
+	case V4L2_EVENT_CTRL:
+		return v4l2_ctrl_subscribe_event(fh, sub);
+	default:
+		return -EINVAL;
+	}
+};
+
+/* V4L2 subdev core operations */
+static const struct v4l2_subdev_core_ops tpg_sd_core_ops = {
+	.subscribe_event = subscribe_event,
+	.unsubscribe_event = v4l2_event_subdev_unsubscribe,
+};
+
+static struct v4l2_subdev_ops tpg_sd_ops = {
+	.core = &tpg_sd_core_ops,
+	.video = &tpg_sd_video_ops,
+	.pad = &tpg_sd_pad_ops,
+};
+
+static struct media_entity_operations tpg_entity_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+void ipu_isys_tpg_cleanup(struct ipu_isys_tpg *tpg)
+{
+	v4l2_device_unregister_subdev(&tpg->asd.sd);
+	ipu_isys_subdev_cleanup(&tpg->asd);
+	ipu_isys_video_cleanup(&tpg->av);
+}
+
+int ipu_isys_tpg_init(struct ipu_isys_tpg *tpg,
+		      struct ipu_isys *isys,
+		      void __iomem *base, void __iomem *sel,
+		      unsigned int index)
+{
+	struct v4l2_subdev_format fmt = {
+		.which = V4L2_SUBDEV_FORMAT_ACTIVE,
+		.pad = TPG_PAD_SOURCE,
+		.format = {
+			   .width = 4096,
+			   .height = 3072,
+			   },
+	};
+	int rval;
+
+	tpg->isys = isys;
+	tpg->base = base;
+	tpg->sel = sel;
+	tpg->index = index;
+
+	tpg->asd.sd.entity.ops = &tpg_entity_ops;
+	tpg->asd.ctrl_init = ipu_isys_tpg_init_controls;
+	tpg->asd.isys = isys;
+
+	rval = ipu_isys_subdev_init(&tpg->asd, &tpg_sd_ops, 5,
+				    NR_OF_TPG_PADS,
+				    NR_OF_TPG_SOURCE_PADS,
+				    NR_OF_TPG_SINK_PADS,
+				    V4L2_SUBDEV_FL_HAS_EVENTS);
+	if (rval)
+		return rval;
+
+	tpg->asd.sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;
+	tpg->asd.pad[TPG_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+
+	tpg->asd.source = IPU_FW_ISYS_STREAM_SRC_MIPIGEN_PORT0 + index;
+	tpg->asd.supported_codes = tpg_supported_codes;
+	tpg->asd.set_ffmt = tpg_set_ffmt;
+	ipu_isys_subdev_set_ffmt(&tpg->asd.sd, NULL, &fmt);
+
+	tpg->asd.sd.internal_ops = &tpg_sd_internal_ops;
+	snprintf(tpg->asd.sd.name, sizeof(tpg->asd.sd.name),
+		 IPU_ISYS_ENTITY_PREFIX " TPG %u", index);
+	v4l2_set_subdevdata(&tpg->asd.sd, &tpg->asd);
+	rval = v4l2_device_register_subdev(&isys->v4l2_dev, &tpg->asd.sd);
+	if (rval) {
+		dev_info(&isys->adev->dev, "can't register v4l2 subdev\n");
+		goto fail;
+	}
+
+	snprintf(tpg->av.vdev.name, sizeof(tpg->av.vdev.name),
+		 IPU_ISYS_ENTITY_PREFIX " TPG %u capture", index);
+	tpg->av.isys = isys;
+	tpg->av.aq.css_pin_type = IPU_FW_ISYS_PIN_TYPE_MIPI;
+	tpg->av.pfmts = ipu_isys_pfmts_packed;
+	tpg->av.try_fmt_vid_mplane = ipu_isys_tpg_try_fmt;
+	tpg->av.prepare_fw_stream =
+	    ipu_isys_prepare_fw_cfg_default;
+	tpg->av.packed = true;
+	tpg->av.line_header_length = IPU_ISYS_CSI2_LONG_PACKET_HEADER_SIZE;
+	tpg->av.line_footer_length = IPU_ISYS_CSI2_LONG_PACKET_FOOTER_SIZE;
+	tpg->av.aq.buf_prepare = ipu_isys_buf_prepare;
+	tpg->av.aq.fill_frame_buff_set_pin =
+	    ipu_isys_buffer_to_fw_frame_buff_pin;
+	tpg->av.aq.link_fmt_validate = ipu_isys_link_fmt_validate;
+	tpg->av.aq.vbq.buf_struct_size = sizeof(struct ipu_isys_video_buffer);
+
+	rval = ipu_isys_video_init(&tpg->av, &tpg->asd.sd.entity,
+				   TPG_PAD_SOURCE, MEDIA_PAD_FL_SINK, 0);
+	if (rval) {
+		dev_info(&isys->adev->dev, "can't init video node\n");
+		goto fail;
+	}
+
+	return 0;
+
+fail:
+	ipu_isys_tpg_cleanup(tpg);
+
+	return rval;
+}
Index: b/drivers/media/pci/intel/ipu-isys-tpg.h
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu-isys-tpg.h
@@ -0,0 +1,98 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2013 - 2023 Intel Corporation */
+
+#ifndef IPU_ISYS_TPG_H
+#define IPU_ISYS_TPG_H
+
+#include <media/media-entity.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+
+#include "ipu-isys-subdev.h"
+#include "ipu-isys-video.h"
+#include "ipu-isys-queue.h"
+
+struct ipu_isys_tpg_pdata;
+struct ipu_isys;
+
+#define TPG_PAD_SOURCE			0
+#define NR_OF_TPG_PADS			1
+#define NR_OF_TPG_SOURCE_PADS		1
+#define NR_OF_TPG_SINK_PADS		0
+#define NR_OF_TPG_STREAMS		1
+
+/*
+ * PPC is 4 pixels for clock for RAW8, RAW10 and RAW12.
+ * Source: FW validation test code.
+ */
+#define MIPI_GEN_PPC		4
+
+#define MIPI_GEN_REG_COM_ENABLE				0x0
+#define MIPI_GEN_REG_COM_DTYPE				0x4
+/* RAW8, RAW10 or RAW12 */
+#define MIPI_GEN_COM_DTYPE_RAW(n)			(((n) - 8) / 2)
+#define MIPI_GEN_REG_COM_VTYPE				0x8
+#define MIPI_GEN_REG_COM_VCHAN				0xc
+#define MIPI_GEN_REG_COM_WCOUNT				0x10
+#define MIPI_GEN_REG_PRBS_RSTVAL0			0x14
+#define MIPI_GEN_REG_PRBS_RSTVAL1			0x18
+#define MIPI_GEN_REG_SYNG_FREE_RUN			0x1c
+#define MIPI_GEN_REG_SYNG_PAUSE				0x20
+#define MIPI_GEN_REG_SYNG_NOF_FRAMES			0x24
+#define MIPI_GEN_REG_SYNG_NOF_PIXELS			0x28
+#define MIPI_GEN_REG_SYNG_NOF_LINES			0x2c
+#define MIPI_GEN_REG_SYNG_HBLANK_CYC			0x30
+#define MIPI_GEN_REG_SYNG_VBLANK_CYC			0x34
+#define MIPI_GEN_REG_SYNG_STAT_HCNT			0x38
+#define MIPI_GEN_REG_SYNG_STAT_VCNT			0x3c
+#define MIPI_GEN_REG_SYNG_STAT_FCNT			0x40
+#define MIPI_GEN_REG_SYNG_STAT_DONE			0x44
+#define MIPI_GEN_REG_TPG_MODE				0x48
+#define MIPI_GEN_REG_TPG_HCNT_MASK			0x4c
+#define MIPI_GEN_REG_TPG_VCNT_MASK			0x50
+#define MIPI_GEN_REG_TPG_XYCNT_MASK			0x54
+#define MIPI_GEN_REG_TPG_HCNT_DELTA			0x58
+#define MIPI_GEN_REG_TPG_VCNT_DELTA			0x5c
+#define MIPI_GEN_REG_TPG_R1				0x60
+#define MIPI_GEN_REG_TPG_G1				0x64
+#define MIPI_GEN_REG_TPG_B1				0x68
+#define MIPI_GEN_REG_TPG_R2				0x6c
+#define MIPI_GEN_REG_TPG_G2				0x70
+#define MIPI_GEN_REG_TPG_B2				0x74
+
+/*
+ * struct ipu_isys_tpg
+ *
+ * @nlanes: number of lanes in the receiver
+ */
+struct ipu_isys_tpg {
+	struct ipu_isys_tpg_pdata *pdata;
+	struct ipu_isys *isys;
+	struct ipu_isys_subdev asd;
+	struct ipu_isys_video av;
+
+	void __iomem *base;
+	void __iomem *sel;
+	unsigned int index;
+
+	struct v4l2_ctrl *hblank;
+	struct v4l2_ctrl *vblank;
+	struct v4l2_ctrl *pixel_rate;
+	struct v4l2_ctrl *store_csi2_header;
+};
+
+#define to_ipu_isys_tpg(sd)		\
+	container_of(to_ipu_isys_subdev(sd), \
+	struct ipu_isys_tpg, asd)
+#ifdef IPU_TPG_FRAME_SYNC
+void ipu_isys_tpg_sof_event(struct ipu_isys_tpg *tpg);
+void ipu_isys_tpg_eof_event(struct ipu_isys_tpg *tpg);
+#endif
+int ipu_isys_tpg_init(struct ipu_isys_tpg *tpg,
+		      struct ipu_isys *isys,
+		      void __iomem *base, void __iomem *sel,
+		      unsigned int index);
+void ipu_isys_tpg_cleanup(struct ipu_isys_tpg *tpg);
+int tpg_set_stream(struct v4l2_subdev *sd, int enable);
+
+#endif /* IPU_ISYS_TPG_H */
Index: b/drivers/media/pci/intel/ipu-isys-video.c
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu-isys-video.c
@@ -0,0 +1,2090 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) 2013 - 2023 Intel Corporation
+
+#include <linux/delay.h>
+#include <linux/firmware.h>
+#include <linux/init_task.h>
+#include <linux/kthread.h>
+#include <linux/pm_runtime.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/compat.h>
+#include <uapi/linux/ipu-isys.h>
+
+#include <uapi/linux/sched/types.h>
+
+#include <media/media-entity.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-mc.h>
+
+#include "ipu.h"
+#include "ipu-bus.h"
+#include "ipu-cpd.h"
+#include "ipu-isys.h"
+#include "ipu-isys-video.h"
+#include "ipu-platform.h"
+#include "ipu-platform-regs.h"
+#include "ipu-platform-buttress-regs.h"
+#include "ipu-trace.h"
+#include "ipu-fw-isys.h"
+#include "ipu-fw-com.h"
+
+const struct ipu_isys_pixelformat ipu_isys_pfmts_be_soc[] = {
+	{V4L2_PIX_FMT_Y10, 16, 10, 0, MEDIA_BUS_FMT_Y10_1X10,
+	 IPU_FW_ISYS_FRAME_FORMAT_RAW16},
+	{V4L2_PIX_FMT_Y8I, 16, 16, 0, MEDIA_BUS_FMT_UYVY8_1X16,
+	 IPU_FW_ISYS_FRAME_FORMAT_UYVY},
+	{V4L2_PIX_FMT_Z16, 16, 16, 0, MEDIA_BUS_FMT_UYVY8_1X16,
+	 IPU_FW_ISYS_FRAME_FORMAT_UYVY},
+	{V4L2_PIX_FMT_UYVY, 16, 16, 0, MEDIA_BUS_FMT_UYVY8_1X16,
+	 IPU_FW_ISYS_FRAME_FORMAT_UYVY},
+	{V4L2_PIX_FMT_YUYV, 16, 16, 0, MEDIA_BUS_FMT_YUYV8_1X16,
+	 IPU_FW_ISYS_FRAME_FORMAT_YUYV},
+	{V4L2_PIX_FMT_NV16, 16, 16, 8, MEDIA_BUS_FMT_UYVY8_1X16,
+	 IPU_FW_ISYS_FRAME_FORMAT_NV16},
+	{V4L2_PIX_FMT_XRGB32, 32, 32, 0, MEDIA_BUS_FMT_RGB565_1X16,
+	 IPU_FW_ISYS_FRAME_FORMAT_RGBA888},
+	{V4L2_PIX_FMT_Y12I, 24, 24, 0, MEDIA_BUS_FMT_RGB888_1X24,
+	 IPU_FW_ISYS_FRAME_FORMAT_RGBA888},
+	{V4L2_PIX_FMT_XBGR32, 32, 32, 0, MEDIA_BUS_FMT_RGB888_1X24,
+	 IPU_FW_ISYS_FRAME_FORMAT_RGBA888},
+	/* Raw bayer formats. */
+	{V4L2_PIX_FMT_SBGGR12, 16, 12, 0, MEDIA_BUS_FMT_SBGGR12_1X12,
+	 IPU_FW_ISYS_FRAME_FORMAT_RAW16},
+	{V4L2_PIX_FMT_SGBRG12, 16, 12, 0, MEDIA_BUS_FMT_SGBRG12_1X12,
+	 IPU_FW_ISYS_FRAME_FORMAT_RAW16},
+	{V4L2_PIX_FMT_SGRBG12, 16, 12, 0, MEDIA_BUS_FMT_SGRBG12_1X12,
+	 IPU_FW_ISYS_FRAME_FORMAT_RAW16},
+	{V4L2_PIX_FMT_SRGGB12, 16, 12, 0, MEDIA_BUS_FMT_SRGGB12_1X12,
+	 IPU_FW_ISYS_FRAME_FORMAT_RAW16},
+	{V4L2_PIX_FMT_SBGGR10, 16, 10, 0, MEDIA_BUS_FMT_SBGGR10_1X10,
+	 IPU_FW_ISYS_FRAME_FORMAT_RAW16},
+	{V4L2_PIX_FMT_SGBRG10, 16, 10, 0, MEDIA_BUS_FMT_SGBRG10_1X10,
+	 IPU_FW_ISYS_FRAME_FORMAT_RAW16},
+	{V4L2_PIX_FMT_SGRBG10, 16, 10, 0, MEDIA_BUS_FMT_SGRBG10_1X10,
+	 IPU_FW_ISYS_FRAME_FORMAT_RAW16},
+	{V4L2_PIX_FMT_SRGGB10, 16, 10, 0, MEDIA_BUS_FMT_SRGGB10_1X10,
+	 IPU_FW_ISYS_FRAME_FORMAT_RAW16},
+	{V4L2_PIX_FMT_SBGGR8, 8, 8, 0, MEDIA_BUS_FMT_SBGGR8_1X8,
+	 IPU_FW_ISYS_FRAME_FORMAT_RAW8},
+	{V4L2_PIX_FMT_SGBRG8, 8, 8, 0, MEDIA_BUS_FMT_SGBRG8_1X8,
+	 IPU_FW_ISYS_FRAME_FORMAT_RAW8},
+	{V4L2_PIX_FMT_SGRBG8, 8, 8, 0, MEDIA_BUS_FMT_SGRBG8_1X8,
+	 IPU_FW_ISYS_FRAME_FORMAT_RAW8},
+	{V4L2_PIX_FMT_SRGGB8, 8, 8, 0, MEDIA_BUS_FMT_SRGGB8_1X8,
+	 IPU_FW_ISYS_FRAME_FORMAT_RAW8},
+	{V4L2_PIX_FMT_GREY, 8, 8, 0, MEDIA_BUS_FMT_Y8_1X8,
+	 IPU_FW_ISYS_FRAME_FORMAT_RAW8},
+	{}
+};
+
+const struct ipu_isys_pixelformat ipu_isys_pfmts_packed[] = {
+	{V4L2_PIX_FMT_Y10, 10, 10, 0, MEDIA_BUS_FMT_Y10_1X10,
+	 IPU_FW_ISYS_FRAME_FORMAT_RAW10},
+#ifdef V4L2_PIX_FMT_Y210
+	{V4L2_PIX_FMT_Y210, 20, 20, 0, MEDIA_BUS_FMT_YUYV10_1X20,
+	 IPU_FW_ISYS_FRAME_FORMAT_YUYV},
+#endif
+	{V4L2_PIX_FMT_Y8I, 16, 16, 0, MEDIA_BUS_FMT_UYVY8_1X16,
+	 IPU_FW_ISYS_FRAME_FORMAT_UYVY},
+	{V4L2_PIX_FMT_Z16, 16, 16, 0, MEDIA_BUS_FMT_UYVY8_1X16,
+	 IPU_FW_ISYS_FRAME_FORMAT_UYVY},
+	{V4L2_PIX_FMT_UYVY, 16, 16, 0, MEDIA_BUS_FMT_UYVY8_1X16,
+	 IPU_FW_ISYS_FRAME_FORMAT_UYVY},
+	{V4L2_PIX_FMT_YUYV, 16, 16, 0, MEDIA_BUS_FMT_YUYV8_1X16,
+	 IPU_FW_ISYS_FRAME_FORMAT_YUYV},
+	{V4L2_PIX_FMT_RGB565, 16, 16, 0, MEDIA_BUS_FMT_RGB565_1X16,
+	 IPU_FW_ISYS_FRAME_FORMAT_RGB565},
+	{V4L2_PIX_FMT_BGR24, 24, 24, 0, MEDIA_BUS_FMT_RGB888_1X24,
+	 IPU_FW_ISYS_FRAME_FORMAT_RGBA888},
+#ifndef V4L2_PIX_FMT_SBGGR12P
+	{V4L2_PIX_FMT_SBGGR12, 12, 12, 0, MEDIA_BUS_FMT_SBGGR12_1X12,
+	 IPU_FW_ISYS_FRAME_FORMAT_RAW12},
+	{V4L2_PIX_FMT_SGBRG12, 12, 12, 0, MEDIA_BUS_FMT_SGBRG12_1X12,
+	 IPU_FW_ISYS_FRAME_FORMAT_RAW12},
+	{V4L2_PIX_FMT_SGRBG12, 12, 12, 0, MEDIA_BUS_FMT_SGRBG12_1X12,
+	 IPU_FW_ISYS_FRAME_FORMAT_RAW12},
+	{V4L2_PIX_FMT_SRGGB12, 12, 12, 0, MEDIA_BUS_FMT_SRGGB12_1X12,
+	 IPU_FW_ISYS_FRAME_FORMAT_RAW12},
+#else /* V4L2_PIX_FMT_SBGGR12P */
+	{V4L2_PIX_FMT_SBGGR12P, 12, 12, 0, MEDIA_BUS_FMT_SBGGR12_1X12,
+	 IPU_FW_ISYS_FRAME_FORMAT_RAW12},
+	{V4L2_PIX_FMT_SGBRG12P, 12, 12, 0, MEDIA_BUS_FMT_SGBRG12_1X12,
+	 IPU_FW_ISYS_FRAME_FORMAT_RAW12},
+	{V4L2_PIX_FMT_SGRBG12P, 12, 12, 0, MEDIA_BUS_FMT_SGRBG12_1X12,
+	 IPU_FW_ISYS_FRAME_FORMAT_RAW12},
+	{V4L2_PIX_FMT_SRGGB12P, 12, 12, 0, MEDIA_BUS_FMT_SRGGB12_1X12,
+	 IPU_FW_ISYS_FRAME_FORMAT_RAW12},
+#endif /* V4L2_PIX_FMT_SBGGR12P */
+	{V4L2_PIX_FMT_SBGGR10P, 10, 10, 0, MEDIA_BUS_FMT_SBGGR10_1X10,
+	 IPU_FW_ISYS_FRAME_FORMAT_RAW10},
+	{V4L2_PIX_FMT_SGBRG10P, 10, 10, 0, MEDIA_BUS_FMT_SGBRG10_1X10,
+	 IPU_FW_ISYS_FRAME_FORMAT_RAW10},
+	{V4L2_PIX_FMT_SGRBG10P, 10, 10, 0, MEDIA_BUS_FMT_SGRBG10_1X10,
+	 IPU_FW_ISYS_FRAME_FORMAT_RAW10},
+	{V4L2_PIX_FMT_SRGGB10P, 10, 10, 0, MEDIA_BUS_FMT_SRGGB10_1X10,
+	 IPU_FW_ISYS_FRAME_FORMAT_RAW10},
+	{V4L2_PIX_FMT_GREY, 8, 8, 0, MEDIA_BUS_FMT_Y8_1X8,
+	 IPU_FW_ISYS_FRAME_FORMAT_RAW8},
+	{V4L2_PIX_FMT_SBGGR8, 8, 8, 0, MEDIA_BUS_FMT_SBGGR8_1X8,
+	 IPU_FW_ISYS_FRAME_FORMAT_RAW8},
+	{V4L2_PIX_FMT_SGBRG8, 8, 8, 0, MEDIA_BUS_FMT_SGBRG8_1X8,
+	 IPU_FW_ISYS_FRAME_FORMAT_RAW8},
+	{V4L2_PIX_FMT_SGRBG8, 8, 8, 0, MEDIA_BUS_FMT_SGRBG8_1X8,
+	 IPU_FW_ISYS_FRAME_FORMAT_RAW8},
+	{V4L2_PIX_FMT_SRGGB8, 8, 8, 0, MEDIA_BUS_FMT_SRGGB8_1X8,
+	 IPU_FW_ISYS_FRAME_FORMAT_RAW8},
+	{}
+};
+
+static int video_open(struct file *file)
+{
+	struct ipu_isys_video *av = video_drvdata(file);
+	struct ipu_isys *isys = av->isys;
+	struct ipu_bus_device *adev = to_ipu_bus_device(&isys->adev->dev);
+	struct ipu_device *isp = adev->isp;
+	int rval;
+	const struct ipu_isys_internal_pdata *ipdata;
+
+	mutex_lock(&isys->mutex);
+
+	if (isys->reset_needed || isp->flr_done) {
+		mutex_unlock(&isys->mutex);
+		dev_warn(&isys->adev->dev, "isys power cycle required\n");
+		return -EIO;
+	}
+	mutex_unlock(&isys->mutex);
+
+	rval = pm_runtime_get_sync(&isys->adev->dev);
+	if (rval < 0) {
+		pm_runtime_put_noidle(&isys->adev->dev);
+		return rval;
+	}
+
+	rval = v4l2_fh_open(file);
+	if (rval)
+		goto out_power_down;
+
+	rval = v4l2_pipeline_pm_get(&av->vdev.entity);
+	if (rval)
+		goto out_v4l2_fh_release;
+
+	mutex_lock(&isys->mutex);
+
+	if (isys->video_opened++) {
+		/* Already open */
+		mutex_unlock(&isys->mutex);
+		return 0;
+	}
+
+	ipdata = isys->pdata->ipdata;
+	ipu_configure_spc(adev->isp,
+			  &ipdata->hw_variant,
+			  IPU_CPD_PKG_DIR_ISYS_SERVER_IDX,
+			  isys->pdata->base, isys->pkg_dir,
+			  isys->pkg_dir_dma_addr);
+
+	/*
+	 * Buffers could have been left to wrong queue at last closure.
+	 * Move them now back to empty buffer queue.
+	 */
+	ipu_cleanup_fw_msg_bufs(isys);
+
+	if (isys->fwcom) {
+		/*
+		 * Something went wrong in previous shutdown. As we are now
+		 * restarting isys we can safely delete old context.
+		 */
+		dev_err(&isys->adev->dev, "Clearing old context\n");
+		ipu_fw_isys_cleanup(isys);
+	}
+
+	rval = ipu_fw_isys_init(av->isys, ipdata->num_parallel_streams);
+	if (rval < 0)
+		goto out_lib_init;
+
+	mutex_unlock(&isys->mutex);
+
+	return 0;
+
+out_lib_init:
+	isys->video_opened--;
+	mutex_unlock(&isys->mutex);
+	v4l2_pipeline_pm_put(&av->vdev.entity);
+
+out_v4l2_fh_release:
+	v4l2_fh_release(file);
+out_power_down:
+	pm_runtime_put(&isys->adev->dev);
+
+	return rval;
+}
+
+static int video_release(struct file *file)
+{
+	struct ipu_isys_video *av = video_drvdata(file);
+	int ret = 0;
+
+	dev_dbg(&av->isys->adev->dev, "release: %s: enter\n",
+		av->vdev.name);
+	vb2_fop_release(file);
+
+	mutex_lock(&av->isys->reset_mutex);
+	while (av->isys->in_reset) {
+		mutex_unlock(&av->isys->reset_mutex);
+		dev_dbg(&av->isys->adev->dev, "release: %s: wait for reset\n",
+			av->vdev.name
+		);
+		usleep_range(10000, 11000);
+		mutex_lock(&av->isys->reset_mutex);
+	}
+	mutex_unlock(&av->isys->reset_mutex);
+
+	mutex_lock(&av->isys->mutex);
+
+	if (!--av->isys->video_opened) {
+	dev_dbg(&av->isys->adev->dev, "release: %s: close fw\n",
+		av->vdev.name);
+		ipu_fw_isys_close(av->isys);
+		if (av->isys->fwcom) {
+			av->isys->reset_needed = true;
+			ret = -EIO;
+		}
+	}
+
+	mutex_unlock(&av->isys->mutex);
+
+	v4l2_pipeline_pm_put(&av->vdev.entity);
+
+	if (av->isys->reset_needed)
+		pm_runtime_put_sync(&av->isys->adev->dev);
+	else
+		pm_runtime_put(&av->isys->adev->dev);
+
+	dev_dbg(&av->isys->adev->dev, "release: %s: exit\n",
+		av->vdev.name);
+	return ret;
+}
+
+static struct media_pad *other_pad(struct media_pad *pad)
+{
+	struct media_link *link;
+
+	list_for_each_entry(link, &pad->entity->links, list) {
+		if ((link->flags & MEDIA_LNK_FL_LINK_TYPE)
+		    != MEDIA_LNK_FL_DATA_LINK)
+			continue;
+
+		return link->source == pad ? link->sink : link->source;
+	}
+
+	WARN_ON(1);
+	return NULL;
+}
+
+const struct ipu_isys_pixelformat *
+ipu_isys_get_pixelformat(struct ipu_isys_video *av, u32 pixelformat)
+{
+	struct media_pad *pad = other_pad(&av->vdev.entity.pads[0]);
+	struct v4l2_subdev *sd;
+	const u32 *supported_codes;
+	const struct ipu_isys_pixelformat *pfmt;
+
+	if (!pad || !pad->entity) {
+		WARN_ON(1);
+		return NULL;
+	}
+
+	sd = media_entity_to_v4l2_subdev(pad->entity);
+	supported_codes = to_ipu_isys_subdev(sd)->supported_codes[pad->index];
+
+	for (pfmt = av->pfmts; pfmt->bpp; pfmt++) {
+		unsigned int i;
+
+		if (pfmt->pixelformat != pixelformat)
+			continue;
+
+		for (i = 0; supported_codes[i]; i++) {
+			if (pfmt->code == supported_codes[i])
+				return pfmt;
+		}
+	}
+
+	/* Not found. Get the default, i.e. the first defined one. */
+	for (pfmt = av->pfmts; pfmt->bpp; pfmt++) {
+		if (pfmt->code == *supported_codes)
+			return pfmt;
+	}
+
+	WARN_ON(1);
+	return NULL;
+}
+
+int ipu_isys_vidioc_querycap(struct file *file, void *fh,
+			     struct v4l2_capability *cap)
+{
+	struct ipu_isys_video *av = video_drvdata(file);
+
+	strlcpy(cap->driver, IPU_ISYS_NAME, sizeof(cap->driver));
+	strlcpy(cap->card, av->isys->media_dev.model, sizeof(cap->card));
+	snprintf(cap->bus_info, sizeof(cap->bus_info), "PCI:%s",
+		 av->isys->media_dev.bus_info);
+	return 0;
+}
+
+int ipu_isys_vidioc_enum_fmt(struct file *file, void *fh,
+			     struct v4l2_fmtdesc *f)
+{
+	struct ipu_isys_video *av = video_drvdata(file);
+	struct media_pad *pad = other_pad(&av->vdev.entity.pads[0]);
+	struct v4l2_subdev *sd;
+	const u32 *supported_codes;
+	const struct ipu_isys_pixelformat *pfmt;
+	u32 index;
+
+	if (!pad || !pad->entity)
+		return -EINVAL;
+	sd = media_entity_to_v4l2_subdev(pad->entity);
+	supported_codes = to_ipu_isys_subdev(sd)->supported_codes[pad->index];
+
+	/* Walk the 0-terminated array for the f->index-th code. */
+	for (index = f->index; *supported_codes && index;
+	     index--, supported_codes++) {
+	};
+
+	if (!*supported_codes)
+		return -EINVAL;
+
+	f->flags = 0;
+
+	/* Code found */
+	for (pfmt = av->pfmts; pfmt->bpp; pfmt++)
+		if (pfmt->code == *supported_codes)
+			break;
+
+	if (!pfmt->bpp) {
+		dev_warn(&av->isys->adev->dev,
+			 "Format not found in mapping table.");
+		return -EINVAL;
+	}
+
+	f->pixelformat = pfmt->pixelformat;
+
+	return 0;
+}
+
+static int vidioc_g_fmt_vid_cap_mplane(struct file *file, void *fh,
+				       struct v4l2_format *fmt)
+{
+	struct ipu_isys_video *av = video_drvdata(file);
+
+	fmt->fmt.pix_mp = av->mpix;
+
+	return 0;
+}
+
+const struct ipu_isys_pixelformat *
+ipu_isys_video_try_fmt_vid_mplane_default(struct ipu_isys_video *av,
+					  struct v4l2_pix_format_mplane *mpix)
+{
+	return ipu_isys_video_try_fmt_vid_mplane(av, mpix, 0);
+}
+
+const struct ipu_isys_pixelformat *
+ipu_isys_video_try_fmt_vid_mplane(struct ipu_isys_video *av,
+				  struct v4l2_pix_format_mplane *mpix,
+				  int store_csi2_header)
+{
+	const struct ipu_isys_pixelformat *pfmt =
+	    ipu_isys_get_pixelformat(av, mpix->pixelformat);
+
+	if (!pfmt)
+		return NULL;
+	mpix->pixelformat = pfmt->pixelformat;
+	mpix->num_planes = 1;
+
+	mpix->width = clamp(mpix->width, IPU_ISYS_MIN_WIDTH,
+			    IPU_ISYS_MAX_WIDTH);
+	mpix->height = clamp(mpix->height, IPU_ISYS_MIN_HEIGHT,
+			     IPU_ISYS_MAX_HEIGHT);
+
+	if (!av->packed)
+		mpix->plane_fmt[0].bytesperline =
+		    mpix->width * DIV_ROUND_UP(pfmt->bpp_planar ?
+					       pfmt->bpp_planar : pfmt->bpp,
+					       BITS_PER_BYTE);
+	else if (store_csi2_header)
+		mpix->plane_fmt[0].bytesperline =
+		    DIV_ROUND_UP(av->line_header_length +
+				 av->line_footer_length +
+				 (unsigned int)mpix->width * pfmt->bpp,
+				 BITS_PER_BYTE);
+	else
+		mpix->plane_fmt[0].bytesperline =
+		    DIV_ROUND_UP((unsigned int)mpix->width * pfmt->bpp,
+				 BITS_PER_BYTE);
+
+	mpix->plane_fmt[0].bytesperline = ALIGN(mpix->plane_fmt[0].bytesperline,
+						av->isys->line_align);
+
+	if (pfmt->bpp_planar)
+		mpix->plane_fmt[0].bytesperline =
+		    mpix->plane_fmt[0].bytesperline *
+		    pfmt->bpp / pfmt->bpp_planar;
+	/*
+	 * (height + 1) * bytesperline due to a hardware issue: the DMA unit
+	 * is a power of two, and a line should be transferred as few units
+	 * as possible. The result is that up to line length more data than
+	 * the image size may be transferred to memory after the image.
+	 * Another limition is the GDA allocation unit size. For low
+	 * resolution it gives a bigger number. Use larger one to avoid
+	 * memory corruption.
+	 */
+	mpix->plane_fmt[0].sizeimage =
+	    max(max(mpix->plane_fmt[0].sizeimage,
+		    mpix->plane_fmt[0].bytesperline * mpix->height +
+		    max(mpix->plane_fmt[0].bytesperline,
+			av->isys->pdata->ipdata->isys_dma_overshoot)), 1U);
+
+	if (av->compression_ctrl)
+		av->compression = v4l2_ctrl_g_ctrl(av->compression_ctrl);
+
+	/* overwrite bpl/height with compression alignment */
+	if (av->compression) {
+		u32 planar_tile_status_size, tile_status_size;
+
+		mpix->plane_fmt[0].bytesperline =
+		    ALIGN(mpix->plane_fmt[0].bytesperline,
+			  IPU_ISYS_COMPRESSION_LINE_ALIGN);
+		mpix->height = ALIGN(mpix->height,
+				     IPU_ISYS_COMPRESSION_HEIGHT_ALIGN);
+
+		mpix->plane_fmt[0].sizeimage =
+		    ALIGN(mpix->plane_fmt[0].bytesperline * mpix->height,
+			  IPU_ISYS_COMPRESSION_PAGE_ALIGN);
+
+		/* ISYS compression only for RAW and single plannar */
+		planar_tile_status_size =
+		    DIV_ROUND_UP_ULL((mpix->plane_fmt[0].bytesperline *
+				      mpix->height /
+				      IPU_ISYS_COMPRESSION_TILE_SIZE_BYTES) *
+				     IPU_ISYS_COMPRESSION_TILE_STATUS_BITS,
+				     BITS_PER_BYTE);
+		tile_status_size = ALIGN(planar_tile_status_size,
+					 IPU_ISYS_COMPRESSION_PAGE_ALIGN);
+
+		/* tile status buffer offsets relative to buffer base address */
+		av->ts_offsets[0] = mpix->plane_fmt[0].sizeimage;
+		mpix->plane_fmt[0].sizeimage += tile_status_size;
+
+		dev_dbg(&av->isys->adev->dev,
+			"cmprs: bpl:%d, height:%d img size:%d, ts_sz:%d\n",
+			mpix->plane_fmt[0].bytesperline, mpix->height,
+			av->ts_offsets[0], tile_status_size);
+	}
+
+	memset(mpix->plane_fmt[0].reserved, 0,
+	       sizeof(mpix->plane_fmt[0].reserved));
+
+	if (mpix->field == V4L2_FIELD_ANY)
+		mpix->field = V4L2_FIELD_NONE;
+	/* Use defaults */
+	mpix->colorspace = V4L2_COLORSPACE_RAW;
+	mpix->ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;
+	mpix->quantization = V4L2_QUANTIZATION_DEFAULT;
+	mpix->xfer_func = V4L2_XFER_FUNC_DEFAULT;
+
+	return pfmt;
+}
+
+static int vidioc_s_fmt_vid_cap_mplane(struct file *file, void *fh,
+				       struct v4l2_format *f)
+{
+	struct ipu_isys_video *av = video_drvdata(file);
+
+	if (av->aq.vbq.streaming)
+		return -EBUSY;
+
+	av->pfmt = av->try_fmt_vid_mplane(av, &f->fmt.pix_mp);
+	av->mpix = f->fmt.pix_mp;
+
+	return 0;
+}
+
+static int vidioc_try_fmt_vid_cap_mplane(struct file *file, void *fh,
+					 struct v4l2_format *f)
+{
+	struct ipu_isys_video *av = video_drvdata(file);
+
+	av->try_fmt_vid_mplane(av, &f->fmt.pix_mp);
+
+	return 0;
+}
+
+static long ipu_isys_vidioc_private(struct file *file, void *fh,
+				    bool valid_prio, unsigned int cmd,
+				    void *arg)
+{
+	struct ipu_isys_video *av = video_drvdata(file);
+	int ret = 0;
+
+	switch (cmd) {
+	case VIDIOC_IPU_GET_DRIVER_VERSION:
+		*(u32 *)arg = IPU_DRIVER_VERSION;
+		break;
+
+	default:
+		dev_dbg(&av->isys->adev->dev, "unsupported private ioctl %x\n",
+			cmd);
+	}
+
+	return ret;
+}
+
+static int vidioc_enum_input(struct file *file, void *fh,
+			     struct v4l2_input *input)
+{
+	if (input->index > 0)
+		return -EINVAL;
+	strlcpy(input->name, "camera", sizeof(input->name));
+	input->type = V4L2_INPUT_TYPE_CAMERA;
+
+	return 0;
+}
+
+static int vidioc_g_input(struct file *file, void *fh, unsigned int *input)
+{
+	*input = 0;
+
+	return 0;
+}
+
+static int vidioc_s_input(struct file *file, void *fh, unsigned int input)
+{
+	return input == 0 ? 0 : -EINVAL;
+}
+
+/*
+ * Return true if an entity directly connected to an Iunit entity is
+ * an image source for the ISP. This can be any external directly
+ * connected entity or any of the test pattern generators in the
+ * Iunit.
+ */
+static bool is_external(struct ipu_isys_video *av, struct media_entity *entity)
+{
+	struct v4l2_subdev *sd;
+
+	/* All video nodes are ours. */
+	if (!is_media_entity_v4l2_subdev(entity))
+		return false;
+
+	sd = media_entity_to_v4l2_subdev(entity);
+	if (strncmp(sd->name, IPU_ISYS_ENTITY_PREFIX,
+		    strlen(IPU_ISYS_ENTITY_PREFIX)) != 0)
+		return true;
+
+	return false;
+}
+
+static int link_validate(struct media_link *link)
+{
+	struct ipu_isys_video *av =
+		container_of(link->sink, struct ipu_isys_video, pad);
+	/* All sub-devices connected to a video node are ours. */
+	struct ipu_isys_pipeline *ip =
+		to_ipu_isys_pipeline(media_entity_pipeline(&av->vdev.entity));
+	struct v4l2_subdev *sd;
+
+	WARN_ON(!ip);
+	if (!link->source->entity)
+		return -EINVAL;
+
+	sd = media_entity_to_v4l2_subdev(link->source->entity);
+	if (is_external(av, link->source->entity)) {
+		ip->external = media_pad_remote_pad_first(av->vdev.entity.pads);
+		ip->source = to_ipu_isys_subdev(sd)->source;
+	}
+
+	ip->nr_queues++;
+
+	return 0;
+}
+
+static void get_stream_opened(struct ipu_isys_video *av)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&av->isys->lock, flags);
+	av->isys->stream_opened++;
+	spin_unlock_irqrestore(&av->isys->lock, flags);
+
+}
+
+static void put_stream_opened(struct ipu_isys_video *av)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&av->isys->lock, flags);
+	av->isys->stream_opened--;
+	spin_unlock_irqrestore(&av->isys->lock, flags);
+
+}
+
+static int get_stream_handle(struct ipu_isys_video *av)
+{
+	struct ipu_isys_pipeline *ip =
+		to_ipu_isys_pipeline(media_entity_pipeline(&av->vdev.entity));
+	unsigned int stream_handle;
+	unsigned long flags;
+
+	spin_lock_irqsave(&av->isys->lock, flags);
+	for (stream_handle = 0;
+	     stream_handle < IPU_ISYS_MAX_STREAMS; stream_handle++)
+		if (!av->isys->pipes[stream_handle])
+			break;
+	if (stream_handle == IPU_ISYS_MAX_STREAMS) {
+		spin_unlock_irqrestore(&av->isys->lock, flags);
+		return -EBUSY;
+	}
+	av->isys->pipes[stream_handle] = ip;
+	ip->stream_handle = stream_handle;
+	spin_unlock_irqrestore(&av->isys->lock, flags);
+	return 0;
+}
+
+static void put_stream_handle(struct ipu_isys_video *av)
+{
+	struct ipu_isys_pipeline *ip =
+		to_ipu_isys_pipeline(media_entity_pipeline(&av->vdev.entity));
+	unsigned long flags;
+
+	spin_lock_irqsave(&av->isys->lock, flags);
+	av->isys->pipes[ip->stream_handle] = NULL;
+	ip->stream_handle = -1;
+	spin_unlock_irqrestore(&av->isys->lock, flags);
+}
+
+static int get_external_facing_format(struct ipu_isys_pipeline *ip,
+				      struct v4l2_subdev_format *format)
+{
+	struct ipu_isys_video *av = container_of(ip, struct ipu_isys_video, ip);
+	struct v4l2_subdev *sd;
+	struct media_pad *external_facing;
+
+	if (!ip->external->entity) {
+		WARN_ON(1);
+		return -ENODEV;
+	}
+	sd = media_entity_to_v4l2_subdev(ip->external->entity);
+	external_facing = (strncmp(sd->name, IPU_ISYS_ENTITY_PREFIX,
+			   strlen(IPU_ISYS_ENTITY_PREFIX)) == 0) ?
+			   ip->external :
+			   media_pad_remote_pad_first(ip->external);
+	if (WARN_ON(!external_facing)) {
+		dev_warn(&av->isys->adev->dev,
+			 "no external facing pad --- driver bug?\n");
+		return -EINVAL;
+	}
+
+	format->which = V4L2_SUBDEV_FORMAT_ACTIVE;
+	format->pad = 0;
+	sd = media_entity_to_v4l2_subdev(external_facing->entity);
+
+	return v4l2_subdev_call(sd, pad, get_fmt, NULL, format);
+}
+
+static void short_packet_queue_destroy(struct ipu_isys_pipeline *ip)
+{
+	struct ipu_isys_video *av = container_of(ip, struct ipu_isys_video, ip);
+	unsigned int i;
+
+	if (!ip->short_packet_bufs)
+		return;
+	for (i = 0; i < IPU_ISYS_SHORT_PACKET_BUFFER_NUM; i++) {
+		if (ip->short_packet_bufs[i].buffer)
+			dma_free_coherent(&av->isys->adev->dev,
+					  ip->short_packet_buffer_size,
+					  ip->short_packet_bufs[i].buffer,
+					  ip->short_packet_bufs[i].dma_addr);
+	}
+	kfree(ip->short_packet_bufs);
+	ip->short_packet_bufs = NULL;
+}
+
+static int short_packet_queue_setup(struct ipu_isys_pipeline *ip)
+{
+	struct ipu_isys_video *av = container_of(ip, struct ipu_isys_video, ip);
+	struct v4l2_subdev_format source_fmt = { 0 };
+	unsigned int i;
+	int rval;
+	size_t buf_size;
+
+	INIT_LIST_HEAD(&ip->pending_interlaced_bufs);
+	ip->cur_field = V4L2_FIELD_TOP;
+
+	if (ip->isys->short_packet_source == IPU_ISYS_SHORT_PACKET_FROM_TUNIT) {
+		ip->short_packet_trace_index = 0;
+		return 0;
+	}
+
+	rval = get_external_facing_format(ip, &source_fmt);
+	if (rval)
+		return rval;
+	buf_size = IPU_ISYS_SHORT_PACKET_BUF_SIZE(source_fmt.format.height);
+	ip->short_packet_buffer_size = buf_size;
+	ip->num_short_packet_lines =
+	    IPU_ISYS_SHORT_PACKET_PKT_LINES(source_fmt.format.height);
+
+	/* Initialize short packet queue. */
+	INIT_LIST_HEAD(&ip->short_packet_incoming);
+	INIT_LIST_HEAD(&ip->short_packet_active);
+
+	ip->short_packet_bufs =
+	    kzalloc(sizeof(struct ipu_isys_private_buffer) *
+		    IPU_ISYS_SHORT_PACKET_BUFFER_NUM, GFP_KERNEL);
+	if (!ip->short_packet_bufs)
+		return -ENOMEM;
+
+	for (i = 0; i < IPU_ISYS_SHORT_PACKET_BUFFER_NUM; i++) {
+		struct ipu_isys_private_buffer *buf = &ip->short_packet_bufs[i];
+
+		buf->index = (unsigned int)i;
+		buf->ip = ip;
+		buf->ib.type = IPU_ISYS_SHORT_PACKET_BUFFER;
+		buf->bytesused = buf_size;
+		buf->buffer = dma_alloc_coherent(&av->isys->adev->dev, buf_size,
+						 &buf->dma_addr, GFP_KERNEL);
+		if (!buf->buffer) {
+			short_packet_queue_destroy(ip);
+			return -ENOMEM;
+		}
+		list_add(&buf->ib.head, &ip->short_packet_incoming);
+	}
+
+	return 0;
+}
+
+static void
+csi_short_packet_prepare_fw_cfg(struct ipu_isys_pipeline *ip,
+				struct ipu_fw_isys_stream_cfg_data_abi *cfg)
+{
+	int input_pin = cfg->nof_input_pins++;
+	int output_pin = cfg->nof_output_pins++;
+	struct ipu_fw_isys_input_pin_info_abi *input_info =
+	    &cfg->input_pins[input_pin];
+	struct ipu_fw_isys_output_pin_info_abi *output_info =
+	    &cfg->output_pins[output_pin];
+	struct ipu_isys *isys = ip->isys;
+
+	/*
+	 * Setting dt as IPU_ISYS_SHORT_PACKET_GENERAL_DT will cause
+	 * MIPI receiver to receive all MIPI short packets.
+	 */
+	input_info->dt = IPU_ISYS_SHORT_PACKET_GENERAL_DT;
+	input_info->input_res.width = IPU_ISYS_SHORT_PACKET_WIDTH;
+	input_info->input_res.height = ip->num_short_packet_lines;
+
+	ip->output_pins[output_pin].pin_ready =
+	    ipu_isys_queue_short_packet_ready;
+	ip->output_pins[output_pin].aq = NULL;
+	ip->short_packet_output_pin = output_pin;
+
+	output_info->input_pin_id = input_pin;
+	output_info->output_res.width = IPU_ISYS_SHORT_PACKET_WIDTH;
+	output_info->output_res.height = ip->num_short_packet_lines;
+	output_info->stride = IPU_ISYS_SHORT_PACKET_WIDTH *
+	    IPU_ISYS_SHORT_PACKET_UNITSIZE;
+	output_info->pt = IPU_ISYS_SHORT_PACKET_PT;
+	output_info->ft = IPU_ISYS_SHORT_PACKET_FT;
+	output_info->send_irq = 1;
+	memset(output_info->ts_offsets, 0, sizeof(output_info->ts_offsets));
+	output_info->s2m_pixel_soc_pixel_remapping =
+	    S2M_PIXEL_SOC_PIXEL_REMAPPING_FLAG_NO_REMAPPING;
+	output_info->csi_be_soc_pixel_remapping =
+	    CSI_BE_SOC_PIXEL_REMAPPING_FLAG_NO_REMAPPING;
+	output_info->sensor_type = isys->sensor_info.sensor_metadata;
+	output_info->snoopable = true;
+	output_info->error_handling_enable = false;
+}
+
+#define MEDIA_ENTITY_MAX_PADS		512
+
+static bool is_support_vc(struct media_pad *source_pad,
+			  struct ipu_isys_pipeline *ip)
+{
+	struct media_pad *remote_pad = source_pad;
+	struct media_pad *extern_pad = NULL;
+	struct v4l2_subdev *sd = NULL;
+	struct v4l2_query_ext_ctrl qm_ctrl = {
+		.id = V4L2_CID_IPU_QUERY_SUB_STREAM, };
+	int i;
+
+	while ((remote_pad =
+		media_pad_remote_pad_first(&remote_pad->entity->pads[0])
+		)) {
+		/* Non-subdev nodes can be safely ignored here. */
+		if (!is_media_entity_v4l2_subdev(remote_pad->entity))
+			continue;
+
+		/* Don't start truly external devices quite yet. */
+		if (strncmp(remote_pad->entity->name,
+		    IPU_ISYS_CSI2_ENTITY_PREFIX,
+		    strlen(IPU_ISYS_CSI2_ENTITY_PREFIX)) != 0)
+			continue;
+
+		dev_dbg(remote_pad->entity->graph_obj.mdev->dev,
+			"It finds CSI2 %s\n", remote_pad->entity->name);
+		extern_pad =
+			media_pad_remote_pad_first(&remote_pad->entity->pads[0]);
+		if (!extern_pad) {
+			dev_dbg(remote_pad->entity->graph_obj.mdev->dev,
+				"extern_pad is null\n");
+			return false;
+		}
+		sd = media_entity_to_v4l2_subdev(extern_pad->entity);
+		break;
+	}
+
+	if (!sd) {
+		dev_dbg(source_pad->entity->graph_obj.mdev->dev,
+			"It doesn't find extern entity\n");
+		return false;
+	}
+
+	if (v4l2_query_ext_ctrl(sd->ctrl_handler, &qm_ctrl)) {
+		dev_dbg(source_pad->entity->graph_obj.mdev->dev,
+			"%s, No vc\n", __func__);
+		for (i = 0; i < CSI2_BE_SOC_SOURCE_PADS_NUM; i++)
+			ip->asv[i].vc = 0;
+
+		return false;
+	}
+
+	return true;
+}
+
+static int ipu_isys_query_sensor_info(struct media_pad *source_pad,
+				      struct ipu_isys_pipeline *ip)
+{
+	int i;
+	int ret = -ENOLINK;
+	bool flag = false;
+	unsigned int pad_id = source_pad->index;
+	struct media_pad *remote_pad = source_pad;
+	struct media_pad *extern_pad = NULL;
+	struct v4l2_subdev *sd = NULL;
+	struct v4l2_querymenu qm = {.id = V4L2_CID_IPU_QUERY_SUB_STREAM, };
+
+	while ((remote_pad =
+		media_pad_remote_pad_first(&remote_pad->entity->pads[0])
+		)) {
+		/* Non-subdev nodes can be safely ignored here. */
+		if (!is_media_entity_v4l2_subdev(remote_pad->entity))
+			continue;
+
+		/* Don't start truly external devices quite yet. */
+		if (strncmp(remote_pad->entity->name,
+		    IPU_ISYS_CSI2_ENTITY_PREFIX,
+		    strlen(IPU_ISYS_CSI2_ENTITY_PREFIX)) != 0)
+			continue;
+
+		dev_dbg(remote_pad->entity->graph_obj.mdev->dev,
+			"It finds CSI2 %s\n", remote_pad->entity->name);
+		extern_pad =
+			media_pad_remote_pad_first(&remote_pad->entity->pads[0]);
+		if (!extern_pad) {
+			dev_dbg(remote_pad->entity->graph_obj.mdev->dev,
+				"extern_pad is null\n");
+			return -ENOLINK;
+		}
+		sd = media_entity_to_v4l2_subdev(extern_pad->entity);
+		break;
+	}
+
+	if (!sd) {
+		dev_dbg(source_pad->entity->graph_obj.mdev->dev,
+			"It doesn't find extern entity\n");
+		return -ENOLINK;
+	}
+
+	/* Get the sub stream info and set the current pipe's vc id */
+	for (i = 0; i < CSI2_BE_SOC_SOURCE_PADS_NUM; i++) {
+		/*
+		 * index is sub stream id. sub stream id is
+		 * equalto BE SOC source pad id - sink pad count
+		 */
+		qm.index = i;
+		ret = v4l2_querymenu(sd->ctrl_handler, &qm);
+		if (ret)
+			continue;
+
+		/* get sub stream info by sub stream id */
+		ip->asv[qm.index].substream = qm.index;
+		ip->asv[qm.index].code = SUB_STREAM_CODE(qm.value);
+		ip->asv[qm.index].height = SUB_STREAM_H(qm.value);
+		ip->asv[qm.index].width = SUB_STREAM_W(qm.value);
+		ip->asv[qm.index].dt = SUB_STREAM_DT(qm.value);
+		ip->asv[qm.index].vc = SUB_STREAM_VC_ID(qm.value);
+		if (ip->asv[qm.index].substream ==
+			(pad_id - NR_OF_CSI2_BE_SOC_SINK_PADS)) {
+			ip->vc = ip->asv[qm.index].vc;
+			flag = true;
+			pr_info("The current entityvc:id:%d\n", ip->vc);
+		}
+	}
+
+	if (flag)
+		return 0;
+
+	return ret;
+}
+
+static void media_pipeline_stop_for_vc(struct ipu_isys_video *av)
+{
+	struct media_pipeline *pipe = av->pad.pipe;
+	struct media_entity *entity = &av->vdev.entity;
+	struct media_device *mdev = entity->graph_obj.mdev;
+	struct media_graph graph;
+	int ret;
+
+	/*
+	 * If the following check fails, the driver has performed an
+	 * unbalanced call to media_pipeline_stop()
+	 */
+	if (WARN_ON(!pipe))
+		return;
+
+	if (--pipe->start_count)
+		return;
+
+	ret = media_graph_walk_init(&graph, mdev);
+	if (ret)
+		return;
+
+	media_graph_walk_start(&graph, entity);
+	while ((entity = media_graph_walk_next(&graph)))
+		entity->pads[0].pipe = NULL;
+
+	media_graph_walk_cleanup(&graph);
+}
+
+static int media_pipeline_walk_by_vc(struct ipu_isys_video *av,
+				     struct media_pipeline *pipe)
+{
+	int ret = -ENOLINK;
+	int i;
+	int entity_vc = INVALIA_VC_ID;
+	u32 n;
+	struct media_entity *entity = &av->vdev.entity;
+	struct media_device *mdev = entity->graph_obj.mdev;
+	struct media_graph graph;
+	struct media_entity *entity_err = entity;
+	struct media_link *link;
+	struct ipu_isys_pipeline *ip = to_ipu_isys_pipeline(pipe);
+	struct media_pad *source_pad = media_pad_remote_pad_first(&av->pad);
+	unsigned int pad_id;
+	bool is_vc = false;
+
+	if (!source_pad) {
+		dev_err(entity->graph_obj.mdev->dev, "no remote pad found\n");
+		return ret;
+	}
+
+	if (pipe->start_count) {
+		pipe->start_count++;
+		return 0;
+	}
+
+	is_vc = is_support_vc(source_pad, ip);
+	if (is_vc) {
+		ret = ipu_isys_query_sensor_info(source_pad, ip);
+		if (ret) {
+			dev_err(entity->graph_obj.mdev->dev,
+				"query sensor info failed\n");
+			return ret;
+		}
+	}
+
+	ret = media_graph_walk_init(&graph, mdev);
+	if (ret)
+		return ret;
+
+	media_graph_walk_start(&graph, entity);
+	while ((entity = media_graph_walk_next(&graph))) {
+		DECLARE_BITMAP(active, MEDIA_ENTITY_MAX_PADS);
+		DECLARE_BITMAP(has_no_links, MEDIA_ENTITY_MAX_PADS);
+
+		dev_dbg(entity->graph_obj.mdev->dev, "entity name:%s\n",
+			entity->name);
+
+		if (entity->pads[0].pipe && entity->pads[0].pipe == pipe) {
+			pr_err("Pipe active for %s. Can't start for %s\n",
+			       entity->name, entity_err->name);
+			ret = -EBUSY;
+			goto error;
+		}
+		/*
+		 * If entity's pipe is not null and it is video device, it has
+		 * be enabled.
+		 */
+		if (entity->pads[0].pipe &&
+		    is_media_entity_v4l2_video_device(entity))
+			continue;
+
+		/*
+		 * If it is video device and its vc id is not equal to curren
+		 * video device's vc id, it should continue.
+		 */
+		if (is_vc && is_media_entity_v4l2_video_device(entity)) {
+			source_pad =
+				media_pad_remote_pad_first(entity->pads);
+
+			if (!source_pad) {
+				dev_warn(entity->graph_obj.mdev->dev,
+					 "no remote pad found\n");
+				continue;
+			}
+			pad_id = source_pad->index;
+			for (i = 0; i < CSI2_BE_SOC_SOURCE_PADS_NUM; i++) {
+				if (ip->asv[i].substream ==
+				(pad_id - NR_OF_CSI2_BE_SOC_SINK_PADS)) {
+					entity_vc = ip->asv[i].vc;
+					break;
+				}
+			}
+
+			if (entity_vc != ip->vc)
+				continue;
+		}
+
+		entity->pads[0].pipe = pipe;
+
+		if (!entity->ops || !entity->ops->link_validate)
+			continue;
+
+		bitmap_zero(active, entity->num_pads);
+		bitmap_fill(has_no_links, entity->num_pads);
+
+		list_for_each_entry(link, &entity->links, list) {
+			struct media_pad *pad = link->sink->entity == entity
+						? link->sink : link->source;
+
+			/* Mark that a pad is connected by a link. */
+			bitmap_clear(has_no_links, pad->index, 1);
+
+			/*
+			 * Pads that either do not need to connect or
+			 * are connected through an enabled link are
+			 * fine.
+			 */
+			if (!(pad->flags & MEDIA_PAD_FL_MUST_CONNECT) ||
+			    link->flags & MEDIA_LNK_FL_ENABLED)
+				bitmap_set(active, pad->index, 1);
+
+			/*
+			 * Link validation will only take place for
+			 * sink ends of the link that are enabled.
+			 */
+			if (link->sink != pad ||
+			    !(link->flags & MEDIA_LNK_FL_ENABLED))
+				continue;
+
+			ret = entity->ops->link_validate(link);
+			if (ret < 0 && ret != -ENOIOCTLCMD) {
+				dev_dbg(entity->graph_obj.mdev->dev,
+					"link failed for %s:%u->%s:%u,ret:%d\n",
+					link->source->entity->name,
+					link->source->index,
+					entity->name, link->sink->index, ret);
+				goto error;
+			}
+		}
+
+		/* Either no links or validated links are fine. */
+		bitmap_or(active, active, has_no_links, entity->num_pads);
+
+		if (!bitmap_full(active, entity->num_pads)) {
+			ret = -ENOLINK;
+			n = (u32)find_first_zero_bit(active, entity->num_pads);
+			dev_dbg(entity->graph_obj.mdev->dev,
+				"%s:%u must be connected by an enabled link\n",
+				entity->name, n);
+			goto error;
+		}
+	}
+
+	media_graph_walk_cleanup(&graph);
+	pipe->start_count++;
+
+	return 0;
+
+error:
+	/*
+	 * Link validation on graph failed. We revert what we did and
+	 * return the error.
+	 */
+	media_graph_walk_start(&graph, entity_err);
+	while ((entity_err = media_graph_walk_next(&graph))) {
+		entity_err->pads[0].pipe = NULL;
+		if (entity_err == entity)
+			break;
+	}
+
+	media_graph_walk_cleanup(&graph);
+
+	return ret;
+}
+
+static int media_pipeline_start_by_vc(struct ipu_isys_video *av,
+				      struct media_pipeline *pipe)
+{
+	struct media_device *mdev = av->vdev.entity.graph_obj.mdev;
+	int ret;
+
+	mutex_lock(&mdev->graph_mutex);
+	ret = media_pipeline_walk_by_vc(av, pipe);
+	mutex_unlock(&mdev->graph_mutex);
+
+	return ret;
+}
+
+void
+ipu_isys_prepare_fw_cfg_default(struct ipu_isys_video *av,
+				struct ipu_fw_isys_stream_cfg_data_abi *cfg)
+{
+	struct ipu_isys_pipeline *ip =
+		to_ipu_isys_pipeline(media_entity_pipeline(&av->vdev.entity));
+	struct ipu_isys_queue *aq = &av->aq;
+	struct ipu_fw_isys_output_pin_info_abi *pin_info;
+	struct ipu_isys *isys = av->isys;
+	unsigned int type_index, type;
+	int pin = cfg->nof_output_pins++;
+	struct v4l2_subdev_format source_fmt = { 0 };
+	int i, ret;
+	int input_pin = cfg->nof_input_pins++;
+	struct ipu_fw_isys_input_pin_info_abi *input_pin_info =
+		&cfg->input_pins[input_pin];
+	struct ipu_isys_sub_stream_vc *sv = NULL;
+	struct media_pad *source_pad = media_pad_remote_pad_first(&av->pad);
+	unsigned int sub_stream_id;
+
+	if (!source_pad) {
+		dev_err(&av->isys->adev->dev, "no remote pad found\n");
+		return;
+	}
+
+	if (is_support_vc(source_pad, ip)) {
+		sub_stream_id = source_pad->index - NR_OF_CSI2_BE_SOC_SINK_PADS;
+
+		for (i = 0; i < NR_OF_CSI2_BE_SOC_SOURCE_PADS; i++) {
+			if (sub_stream_id == ip->asv[i].substream) {
+				sv = &ip->asv[i];
+				break;
+			}
+		}
+		if (!sv) {
+			dev_err(&av->isys->adev->dev,
+				"Don't find input pin info for vc:%d\n",
+				ip->vc);
+			return;
+		}
+
+		input_pin_info->input_res.width = sv->width;
+		input_pin_info->input_res.height = sv->height;
+		input_pin_info->dt =
+			(sv->dt != 0 ? sv->dt : IPU_ISYS_MIPI_CSI2_TYPE_RAW12);
+	} else {
+		ret = get_external_facing_format(ip, &source_fmt);
+		if (ret)
+			return;
+
+		ip->vc = 0;
+		input_pin_info->input_res.width = source_fmt.format.width;
+		input_pin_info->input_res.height = source_fmt.format.height;
+		input_pin_info->dt =
+			ipu_isys_mbus_code_to_mipi(source_fmt.format.code);
+	}
+
+	input_pin_info->mapped_dt = N_IPU_FW_ISYS_MIPI_DATA_TYPE;
+	input_pin_info->mipi_decompression =
+		IPU_FW_ISYS_MIPI_COMPRESSION_TYPE_NO_COMPRESSION;
+	input_pin_info->capture_mode =
+		IPU_FW_ISYS_CAPTURE_MODE_REGULAR;
+	if (ip->csi2 && !v4l2_ctrl_g_ctrl(ip->csi2->store_csi2_header))
+		input_pin_info->mipi_store_mode =
+			IPU_FW_ISYS_MIPI_STORE_MODE_DISCARD_LONG_HEADER;
+	else if (input_pin_info->dt == IPU_ISYS_MIPI_CSI2_TYPE_EMBEDDED8)
+		input_pin_info->mipi_store_mode =
+			IPU_FW_ISYS_MIPI_STORE_MODE_DISCARD_LONG_HEADER;
+
+	aq->fw_output = pin;
+	ip->output_pins[pin].pin_ready = ipu_isys_queue_buf_ready;
+	ip->output_pins[pin].aq = aq;
+
+	pin_info = &cfg->output_pins[pin];
+	pin_info->input_pin_id = input_pin;
+	pin_info->output_res.width = av->mpix.width;
+	pin_info->output_res.height = av->mpix.height;
+
+	if (!av->pfmt->bpp_planar)
+		pin_info->stride = av->mpix.plane_fmt[0].bytesperline;
+	else
+		pin_info->stride = ALIGN(DIV_ROUND_UP(av->mpix.width *
+						      av->pfmt->bpp_planar,
+						      BITS_PER_BYTE),
+					 av->isys->line_align);
+
+	if (input_pin_info->dt == IPU_ISYS_MIPI_CSI2_TYPE_EMBEDDED8 ||
+	    input_pin_info->dt == IPU_ISYS_MIPI_CSI2_TYPE_RGB888)
+		pin_info->pt = IPU_FW_ISYS_PIN_TYPE_MIPI;
+	else
+		pin_info->pt = aq->css_pin_type;
+	pin_info->ft = av->pfmt->css_pixelformat;
+	pin_info->send_irq = 1;
+	memset(pin_info->ts_offsets, 0, sizeof(pin_info->ts_offsets));
+	pin_info->s2m_pixel_soc_pixel_remapping =
+	    S2M_PIXEL_SOC_PIXEL_REMAPPING_FLAG_NO_REMAPPING;
+	pin_info->csi_be_soc_pixel_remapping =
+	    CSI_BE_SOC_PIXEL_REMAPPING_FLAG_NO_REMAPPING;
+	cfg->vc = ip->vc;
+
+	switch (pin_info->pt) {
+	/* non-snoopable sensor data to PSYS */
+	case IPU_FW_ISYS_PIN_TYPE_RAW_NS:
+		type_index = IPU_FW_ISYS_VC1_SENSOR_DATA;
+		pin_info->sensor_type = isys->sensor_types[type_index]++;
+		pin_info->snoopable = false;
+		pin_info->error_handling_enable = false;
+		type = isys->sensor_types[type_index];
+		if (type > isys->sensor_info.vc1_data_end)
+			isys->sensor_types[type_index] =
+				isys->sensor_info.vc1_data_start;
+
+		break;
+	/* snoopable META/Stats data to CPU */
+	case IPU_FW_ISYS_PIN_TYPE_METADATA_0:
+	case IPU_FW_ISYS_PIN_TYPE_METADATA_1:
+		pin_info->sensor_type = isys->sensor_info.sensor_metadata;
+		pin_info->snoopable = true;
+		pin_info->error_handling_enable = false;
+		break;
+	case IPU_FW_ISYS_PIN_TYPE_RAW_SOC:
+		if (av->compression) {
+			type_index = IPU_FW_ISYS_VC1_SENSOR_DATA;
+			pin_info->sensor_type
+				= isys->sensor_types[type_index]++;
+			pin_info->snoopable = false;
+			pin_info->error_handling_enable = false;
+			type = isys->sensor_types[type_index];
+			if (type > isys->sensor_info.vc1_data_end)
+				isys->sensor_types[type_index] =
+					isys->sensor_info.vc1_data_start;
+		} else {
+			type_index = IPU_FW_ISYS_VC0_SENSOR_DATA;
+			pin_info->sensor_type
+				= isys->sensor_types[type_index]++;
+			pin_info->snoopable = true;
+			pin_info->error_handling_enable = false;
+			type = isys->sensor_types[type_index];
+			if (type > isys->sensor_info.vc0_data_end)
+				isys->sensor_types[type_index] =
+					isys->sensor_info.vc0_data_start;
+		}
+		break;
+	case IPU_FW_ISYS_PIN_TYPE_MIPI:
+		type_index = IPU_FW_ISYS_VC0_SENSOR_DATA;
+		pin_info->sensor_type = isys->sensor_types[type_index]++;
+		pin_info->snoopable = true;
+		pin_info->error_handling_enable = false;
+		type = isys->sensor_types[type_index];
+		if (type > isys->sensor_info.vc0_data_end)
+			isys->sensor_types[type_index] =
+				isys->sensor_info.vc0_data_start;
+
+		break;
+
+	default:
+		dev_err(&av->isys->adev->dev,
+			"Unknown pin type, use metadata type as default\n");
+
+		pin_info->sensor_type = isys->sensor_info.sensor_metadata;
+		pin_info->snoopable = true;
+		pin_info->error_handling_enable = false;
+	}
+	if (av->compression) {
+		pin_info->payload_buf_size = av->mpix.plane_fmt[0].sizeimage;
+		pin_info->reserve_compression = av->compression;
+		pin_info->ts_offsets[0] = av->ts_offsets[0];
+	}
+}
+
+static unsigned int ipu_isys_get_compression_scheme(u32 code)
+{
+	switch (code) {
+	case MEDIA_BUS_FMT_SBGGR10_DPCM8_1X8:
+	case MEDIA_BUS_FMT_SGBRG10_DPCM8_1X8:
+	case MEDIA_BUS_FMT_SGRBG10_DPCM8_1X8:
+	case MEDIA_BUS_FMT_SRGGB10_DPCM8_1X8:
+		return 3;
+	default:
+		return 0;
+	}
+}
+
+static unsigned int get_comp_format(u32 code)
+{
+	unsigned int predictor = 0;	/* currently hard coded */
+	unsigned int udt = ipu_isys_mbus_code_to_mipi(code);
+	unsigned int scheme = ipu_isys_get_compression_scheme(code);
+
+	/* if data type is not user defined return here */
+	if (udt < IPU_ISYS_MIPI_CSI2_TYPE_USER_DEF(1) ||
+	    udt > IPU_ISYS_MIPI_CSI2_TYPE_USER_DEF(8))
+		return 0;
+
+	/*
+	 * For each user defined type (1..8) there is configuration bitfield for
+	 * decompression.
+	 *
+	 * | bit 3     | bits 2:0 |
+	 * | predictor | scheme   |
+	 * compression schemes:
+	 * 000 = no compression
+	 * 001 = 10 - 6 - 10
+	 * 010 = 10 - 7 - 10
+	 * 011 = 10 - 8 - 10
+	 * 100 = 12 - 6 - 12
+	 * 101 = 12 - 7 - 12
+	 * 110 = 12 - 8 - 12
+	 */
+
+	return ((predictor << 3) | scheme) <<
+	    ((udt - IPU_ISYS_MIPI_CSI2_TYPE_USER_DEF(1)) * 4);
+}
+
+/* Create stream and start it using the CSS FW ABI. */
+static int start_stream_firmware(struct ipu_isys_video *av,
+				 struct ipu_isys_buffer_list *bl)
+{
+	struct ipu_isys_pipeline *ip =
+		to_ipu_isys_pipeline(media_entity_pipeline(&av->vdev.entity));
+	struct device *dev = &av->isys->adev->dev;
+	struct v4l2_subdev_selection sel_fmt = {
+		.which = V4L2_SUBDEV_FORMAT_ACTIVE,
+		.target = V4L2_SEL_TGT_CROP,
+		.pad = CSI2_BE_PAD_SOURCE,
+	};
+	struct ipu_fw_isys_stream_cfg_data_abi *stream_cfg;
+	struct isys_fw_msgs *msg = NULL;
+	struct ipu_fw_isys_frame_buff_set_abi *buf = NULL;
+	struct ipu_isys_queue *aq;
+	struct ipu_isys_video *isl_av = NULL;
+	struct v4l2_subdev_format source_fmt = { 0 };
+	struct v4l2_subdev *be_sd = NULL;
+	struct media_pad *source_pad = media_pad_remote_pad_first(&av->pad);
+	struct ipu_fw_isys_cropping_abi *crop;
+	enum ipu_fw_isys_send_type send_type;
+	int rval, rvalout, tout;
+
+	rval = get_external_facing_format(ip, &source_fmt);
+	if (rval)
+		return rval;
+
+	msg = ipu_get_fw_msg_buf(ip);
+	if (!msg)
+		return -ENOMEM;
+
+	stream_cfg = to_stream_cfg_msg_buf(msg);
+	stream_cfg->compfmt = get_comp_format(source_fmt.format.code);
+
+	stream_cfg->src = ip->source;
+	stream_cfg->vc = 0;
+	stream_cfg->isl_use = ip->isl_mode;
+	stream_cfg->sensor_type = IPU_FW_ISYS_SENSOR_MODE_NORMAL;
+
+	/*
+	 * Only CSI2-BE and SOC BE has the capability to do crop,
+	 * so get the crop info from csi2-be or csi2-be-soc.
+	 */
+	if (ip->csi2_be) {
+		be_sd = &ip->csi2_be->asd.sd;
+	} else if (ip->csi2_be_soc) {
+		be_sd = &ip->csi2_be_soc->asd.sd;
+		if (source_pad)
+			sel_fmt.pad = source_pad->index;
+	}
+	crop = &stream_cfg->crop;
+	if (be_sd &&
+	    !v4l2_subdev_call(be_sd, pad, get_selection, NULL, &sel_fmt)) {
+		crop->left_offset = sel_fmt.r.left;
+		crop->top_offset = sel_fmt.r.top;
+		crop->right_offset = sel_fmt.r.left + sel_fmt.r.width;
+		crop->bottom_offset = sel_fmt.r.top + sel_fmt.r.height;
+
+	} else {
+		crop->right_offset = source_fmt.format.width;
+		crop->bottom_offset = source_fmt.format.height;
+	}
+
+	/*
+	 * If the CSI-2 backend's video node is part of the pipeline
+	 * it must be arranged first in the output pin list. This is
+	 * the most probably a firmware requirement.
+	 */
+	if (ip->isl_mode == IPU_ISL_CSI2_BE)
+		isl_av = &ip->csi2_be->av;
+
+	if (isl_av) {
+		struct ipu_isys_queue *safe;
+
+		list_for_each_entry_safe(aq, safe, &ip->queues, node) {
+			struct ipu_isys_video *av = ipu_isys_queue_to_video(aq);
+
+			if (av != isl_av)
+				continue;
+
+			list_del(&aq->node);
+			list_add(&aq->node, &ip->queues);
+			break;
+		}
+	}
+
+	list_for_each_entry(aq, &ip->queues, node) {
+		struct ipu_isys_video *__av = ipu_isys_queue_to_video(aq);
+
+		__av->prepare_fw_stream(__av, stream_cfg);
+	}
+
+	if (ip->interlaced && ip->isys->short_packet_source ==
+	    IPU_ISYS_SHORT_PACKET_FROM_RECEIVER)
+		csi_short_packet_prepare_fw_cfg(ip, stream_cfg);
+
+	ipu_fw_isys_dump_stream_cfg(dev, stream_cfg);
+
+	ip->nr_output_pins = stream_cfg->nof_output_pins;
+
+	rval = get_stream_handle(av);
+	if (rval) {
+		dev_dbg(dev, "Can't get stream_handle\n");
+		return rval;
+	}
+
+	reinit_completion(&ip->stream_open_completion);
+
+	ipu_fw_isys_set_params(stream_cfg);
+
+	rval = ipu_fw_isys_complex_cmd(av->isys,
+				       ip->stream_handle,
+				       stream_cfg,
+				       to_dma_addr(msg),
+				       sizeof(*stream_cfg),
+				       IPU_FW_ISYS_SEND_TYPE_STREAM_OPEN);
+	if (rval < 0) {
+		dev_err(dev, "can't open stream (%d)\n", rval);
+		ipu_put_fw_mgs_buf(av->isys, (uintptr_t)stream_cfg);
+		goto out_put_stream_handle;
+	}
+
+	get_stream_opened(av);
+
+	tout = wait_for_completion_timeout(&ip->stream_open_completion,
+					   IPU_LIB_CALL_TIMEOUT_JIFFIES);
+
+	ipu_put_fw_mgs_buf(av->isys, (uintptr_t)stream_cfg);
+
+	if (!tout) {
+		dev_err(dev, "stream open time out\n");
+		rval = -ETIMEDOUT;
+		goto out_put_stream_opened;
+	}
+	if (ip->error) {
+		dev_err(dev, "stream open error: %d\n", ip->error);
+		rval = -EIO;
+		goto out_put_stream_opened;
+	}
+	dev_dbg(dev, "start stream: open complete\n");
+
+	if (bl) {
+		msg = ipu_get_fw_msg_buf(ip);
+		if (!msg) {
+			rval = -ENOMEM;
+			goto out_put_stream_opened;
+		}
+		buf = to_frame_msg_buf(msg);
+	}
+
+	if (bl) {
+		ipu_isys_buffer_to_fw_frame_buff(buf, ip, bl);
+		ipu_isys_buffer_list_queue(bl,
+					   IPU_ISYS_BUFFER_LIST_FL_ACTIVE, 0);
+	}
+
+	reinit_completion(&ip->stream_start_completion);
+
+	if (bl) {
+		send_type = IPU_FW_ISYS_SEND_TYPE_STREAM_START_AND_CAPTURE;
+		ipu_fw_isys_dump_frame_buff_set(dev, buf,
+						stream_cfg->nof_output_pins);
+		rval = ipu_fw_isys_complex_cmd(av->isys,
+					       ip->stream_handle,
+					       buf, to_dma_addr(msg),
+					       sizeof(*buf),
+					       send_type);
+	} else {
+		send_type = IPU_FW_ISYS_SEND_TYPE_STREAM_START;
+		rval = ipu_fw_isys_simple_cmd(av->isys,
+					      ip->stream_handle,
+					      send_type);
+	}
+
+	if (rval < 0) {
+		dev_err(dev, "can't start streaming (%d)\n", rval);
+		goto out_stream_close;
+	}
+
+	tout = wait_for_completion_timeout(&ip->stream_start_completion,
+					   IPU_LIB_CALL_TIMEOUT_JIFFIES);
+	if (!tout) {
+		dev_err(dev, "stream start time out\n");
+		rval = -ETIMEDOUT;
+		goto out_stream_close;
+	}
+	if (ip->error) {
+		dev_err(dev, "stream start error: %d\n", ip->error);
+		rval = -EIO;
+		goto out_stream_close;
+	}
+	dev_dbg(dev, "start stream: complete\n");
+
+	return 0;
+
+out_stream_close:
+	reinit_completion(&ip->stream_close_completion);
+
+	rvalout = ipu_fw_isys_simple_cmd(av->isys,
+					 ip->stream_handle,
+					 IPU_FW_ISYS_SEND_TYPE_STREAM_CLOSE);
+	if (rvalout < 0) {
+		dev_dbg(dev, "can't close stream (%d)\n", rvalout);
+		goto out_put_stream_opened;
+	}
+
+	tout = wait_for_completion_timeout(&ip->stream_close_completion,
+					   IPU_LIB_CALL_TIMEOUT_JIFFIES);
+	if (!tout)
+		dev_err(dev, "stream close time out\n");
+	else if (ip->error)
+		dev_err(dev, "stream close error: %d\n", ip->error);
+	else
+		dev_dbg(dev, "stream close complete\n");
+
+out_put_stream_opened:
+	put_stream_opened(av);
+
+out_put_stream_handle:
+	put_stream_handle(av);
+	return rval;
+}
+
+static void stop_streaming_firmware(struct ipu_isys_video *av)
+{
+	struct ipu_isys_pipeline *ip =
+		to_ipu_isys_pipeline(media_entity_pipeline(&av->vdev.entity));
+	struct device *dev = &av->isys->adev->dev;
+	int rval, tout;
+	enum ipu_fw_isys_send_type send_type =
+		IPU_FW_ISYS_SEND_TYPE_STREAM_FLUSH;
+
+	reinit_completion(&ip->stream_stop_completion);
+
+	rval = ipu_fw_isys_simple_cmd(av->isys, ip->stream_handle,
+				      send_type);
+
+	if (rval < 0) {
+		dev_err(dev, "can't stop stream (%d)\n", rval);
+		return;
+	}
+
+	tout = wait_for_completion_timeout(&ip->stream_stop_completion,
+					   IPU_LIB_CALL_TIMEOUT_JIFFIES_RESET);
+	if (!tout)
+		dev_err(dev, "stream stop time out\n");
+	else if (ip->error)
+		dev_err(dev, "stream stop error: %d\n", ip->error);
+	else
+		dev_dbg(dev, "stop stream: complete\n");
+}
+
+static void close_streaming_firmware(struct ipu_isys_video *av)
+{
+	struct ipu_isys_pipeline *ip =
+		to_ipu_isys_pipeline(media_entity_pipeline(&av->vdev.entity));
+	struct device *dev = &av->isys->adev->dev;
+	int rval, tout;
+
+	reinit_completion(&ip->stream_close_completion);
+
+	rval = ipu_fw_isys_simple_cmd(av->isys, ip->stream_handle,
+				      IPU_FW_ISYS_SEND_TYPE_STREAM_CLOSE);
+	if (rval < 0) {
+		dev_err(dev, "can't close stream (%d)\n", rval);
+		return;
+	}
+
+	tout = wait_for_completion_timeout(&ip->stream_close_completion,
+					   IPU_LIB_CALL_TIMEOUT_JIFFIES_RESET);
+	if (!tout)
+		dev_err(dev, "stream close time out\n");
+	else if (ip->error)
+		dev_err(dev, "stream close error: %d\n", ip->error);
+	else
+		dev_dbg(dev, "close stream: complete\n");
+
+	put_stream_opened(av);
+	put_stream_handle(av);
+}
+
+void
+ipu_isys_video_add_capture_done(struct ipu_isys_pipeline *ip,
+				void (*capture_done)
+				 (struct ipu_isys_pipeline *ip,
+				  struct ipu_fw_isys_resp_info_abi *resp))
+{
+	unsigned int i;
+
+	/* Different instances may register same function. Add only once */
+	for (i = 0; i < IPU_NUM_CAPTURE_DONE; i++)
+		if (ip->capture_done[i] == capture_done)
+			return;
+
+	for (i = 0; i < IPU_NUM_CAPTURE_DONE; i++) {
+		if (!ip->capture_done[i]) {
+			ip->capture_done[i] = capture_done;
+			return;
+		}
+	}
+	/*
+	 * Too many call backs registered. Change to IPU_NUM_CAPTURE_DONE
+	 * constant probably required.
+	 */
+	WARN_ON(1);
+}
+
+int ipu_isys_video_prepare_streaming(struct ipu_isys_video *av,
+				     unsigned int state)
+{
+	struct ipu_isys *isys = av->isys;
+	struct device *dev = &isys->adev->dev;
+	struct ipu_isys_pipeline *ip;
+	struct media_graph graph;
+	struct media_entity *entity;
+	struct media_pipeline *media_pipe;
+	struct media_device *mdev = &av->isys->media_dev;
+	int rval;
+	unsigned int i;
+
+	dev_dbg(dev, "prepare stream: %d\n", state);
+
+	if (!state) {
+		media_pipe = media_entity_pipeline(&av->vdev.entity);
+		ip = to_ipu_isys_pipeline(media_pipe);
+
+		if (ip->interlaced && isys->short_packet_source ==
+		    IPU_ISYS_SHORT_PACKET_FROM_RECEIVER)
+			short_packet_queue_destroy(ip);
+		media_pipeline_stop_for_vc(av);
+		media_entity_enum_cleanup(&ip->entity_enum);
+		return 0;
+	}
+
+	ip = &av->ip;
+
+	WARN_ON(ip->nr_streaming);
+	ip->has_sof = false;
+	ip->nr_queues = 0;
+	ip->external = NULL;
+	atomic_set(&ip->sequence, 0);
+	ip->isl_mode = IPU_ISL_OFF;
+
+	for (i = 0; i < IPU_NUM_CAPTURE_DONE; i++)
+		ip->capture_done[i] = NULL;
+	ip->csi2_be = NULL;
+	ip->csi2_be_soc = NULL;
+	ip->csi2 = NULL;
+	ip->seq_index = 0;
+	memset(ip->seq, 0, sizeof(ip->seq));
+
+	WARN_ON(!list_empty(&ip->queues));
+	ip->interlaced = false;
+
+	rval = media_entity_enum_init(&ip->entity_enum, mdev);
+	if (rval) {
+		dev_err(dev, "entity enum init failed\n");
+		return rval;
+	}
+
+	rval = media_pipeline_start_by_vc(av, &ip->pipe);
+	if (rval < 0) {
+		dev_err(dev, "pipeline start failed\n");
+		goto out_enum_cleanup;
+	}
+
+	if (!ip->external) {
+		dev_err(dev, "no external entity set! Driver bug?\n");
+		rval = -EINVAL;
+		goto out_pipeline_stop;
+	}
+
+	rval = media_graph_walk_init(&graph, mdev);
+	if (rval) {
+		dev_err(dev, "graph walk init failed\n");
+		goto out_pipeline_stop;
+	}
+
+	/* Gather all entities in the graph. */
+	mutex_lock(&mdev->graph_mutex);
+	media_graph_walk_start(&graph, &av->vdev.entity);
+	while ((entity = media_graph_walk_next(&graph)))
+		media_entity_enum_set(&ip->entity_enum, entity);
+
+	mutex_unlock(&mdev->graph_mutex);
+
+	media_graph_walk_cleanup(&graph);
+
+	if (ip->interlaced) {
+		rval = short_packet_queue_setup(ip);
+		if (rval) {
+			dev_err(&isys->adev->dev,
+				"Failed to setup short packet buffer.\n");
+			goto out_pipeline_stop;
+		}
+	}
+
+	dev_dbg(dev, "prepare stream: external entity %s\n",
+		ip->external->entity->name);
+
+	return 0;
+
+out_pipeline_stop:
+	media_pipeline_stop(av->vdev.entity.pads);
+
+out_enum_cleanup:
+	media_entity_enum_cleanup(&ip->entity_enum);
+
+	return rval;
+}
+
+int ipu_isys_video_set_streaming(struct ipu_isys_video *av,
+				 unsigned int state,
+				 struct ipu_isys_buffer_list *bl)
+{
+	struct device *dev = &av->isys->adev->dev;
+	struct media_device *mdev = av->vdev.entity.graph_obj.mdev;
+	struct media_entity_enum entities;
+
+	struct media_entity *entity, *entity2;
+	struct ipu_isys_pipeline *ip =
+		to_ipu_isys_pipeline(media_entity_pipeline(&av->vdev.entity));
+	struct v4l2_subdev *sd, *esd;
+	int rval = 0;
+	struct v4l2_ext_control c = {.id = V4L2_CID_IPU_SET_SUB_STREAM, };
+	struct v4l2_ext_controls cs = {.count = 1,
+		.controls = &c,
+	};
+	struct v4l2_query_ext_ctrl qm_ctrl = {
+		.id = V4L2_CID_IPU_SET_SUB_STREAM, };
+
+	dev_dbg(dev, "set stream: %d\n", state);
+
+	if (!ip->external->entity) {
+		WARN_ON(1);
+		return -ENODEV;
+	}
+	esd = media_entity_to_v4l2_subdev(ip->external->entity);
+
+	if (state) {
+		rval = media_graph_walk_init(&ip->graph, mdev);
+		if (rval)
+			return rval;
+		rval = media_entity_enum_init(&entities, mdev);
+		if (rval)
+			goto out_media_entity_graph_init;
+	}
+
+	if (!state) {
+		stop_streaming_firmware(av);
+
+		/* stop external sub-device now. */
+		dev_info(dev, "stream off %s\n", ip->external->entity->name);
+
+		if (!v4l2_query_ext_ctrl(esd->ctrl_handler, &qm_ctrl)) {
+			c.value64 = SUB_STREAM_SET_VALUE(ip->vc, state);
+			v4l2_s_ext_ctrls(NULL, esd->ctrl_handler,
+					 esd->devnode,
+					 esd->v4l2_dev->mdev,
+					 &cs);
+		} else {
+			v4l2_subdev_call(esd, video, s_stream, state);
+		}
+	}
+
+	mutex_lock(&mdev->graph_mutex);
+
+	media_graph_walk_start(&ip->graph,
+			       &av->vdev.entity);
+
+	while ((entity = media_graph_walk_next(&ip->graph))) {
+		sd = media_entity_to_v4l2_subdev(entity);
+
+		/* Non-subdev nodes can be safely ignored here. */
+		if (!is_media_entity_v4l2_subdev(entity))
+			continue;
+
+		/* Don't start truly external devices quite yet. */
+		if (strncmp(sd->name, IPU_ISYS_ENTITY_PREFIX,
+			    strlen(IPU_ISYS_ENTITY_PREFIX)) != 0 ||
+		    ip->external->entity == entity)
+			continue;
+
+		dev_dbg(dev, "s_stream %s entity %s\n", state ? "on" : "off",
+			entity->name);
+		rval = v4l2_subdev_call(sd, video, s_stream, state);
+		if (!state)
+			continue;
+		if (rval && rval != -ENOIOCTLCMD) {
+			mutex_unlock(&mdev->graph_mutex);
+			goto out_media_entity_stop_streaming;
+		}
+
+		media_entity_enum_set(&entities, entity);
+	}
+
+	mutex_unlock(&mdev->graph_mutex);
+
+	/* Oh crap */
+	if (state) {
+		rval = start_stream_firmware(av, bl);
+		if (rval)
+			goto out_media_entity_stop_streaming;
+
+		dev_dbg(dev, "set stream: source %d, stream_handle %d\n",
+			ip->source, ip->stream_handle);
+
+		/* Start external sub-device now. */
+		dev_info(dev, "stream on %s\n", ip->external->entity->name);
+
+		if (!v4l2_query_ext_ctrl(esd->ctrl_handler, &qm_ctrl)) {
+			c.value64 = SUB_STREAM_SET_VALUE(ip->vc, state);
+			rval = v4l2_s_ext_ctrls(NULL, esd->ctrl_handler,
+						esd->devnode,
+						esd->v4l2_dev->mdev,
+						&cs);
+		} else {
+			rval = v4l2_subdev_call(esd, video, s_stream, state);
+		}
+		if (rval)
+			goto out_media_entity_stop_streaming_firmware;
+	} else {
+		close_streaming_firmware(av);
+		av->ip.vc = INVALIA_VC_ID;
+	}
+
+	if (state)
+		media_entity_enum_cleanup(&entities);
+	else
+		media_graph_walk_cleanup(&ip->graph);
+	av->streaming = state;
+
+	return 0;
+
+out_media_entity_stop_streaming_firmware:
+	stop_streaming_firmware(av);
+
+out_media_entity_stop_streaming:
+	mutex_lock(&mdev->graph_mutex);
+
+	media_graph_walk_start(&ip->graph,
+			       &av->vdev.entity);
+
+	while (state && (entity2 = media_graph_walk_next(&ip->graph)) &&
+	       entity2 != entity) {
+		sd = media_entity_to_v4l2_subdev(entity2);
+
+		if (!media_entity_enum_test(&entities, entity2))
+			continue;
+
+		v4l2_subdev_call(sd, video, s_stream, 0);
+	}
+
+	mutex_unlock(&mdev->graph_mutex);
+
+	media_entity_enum_cleanup(&entities);
+
+out_media_entity_graph_init:
+	media_graph_walk_cleanup(&ip->graph);
+
+	return rval;
+}
+
+#ifdef CONFIG_COMPAT
+static long ipu_isys_compat_ioctl(struct file *file, unsigned int cmd,
+				  unsigned long arg)
+{
+	long ret = -ENOIOCTLCMD;
+	void __user *up = compat_ptr(arg);
+
+	/*
+	 * at present, there is not any private IOCTL need to compat handle
+	 */
+	if (file->f_op->unlocked_ioctl)
+		ret = file->f_op->unlocked_ioctl(file, cmd, (unsigned long)up);
+
+	return ret;
+}
+#endif
+
+static const struct v4l2_ioctl_ops ioctl_ops_mplane = {
+	.vidioc_querycap = ipu_isys_vidioc_querycap,
+	.vidioc_enum_fmt_vid_cap = ipu_isys_vidioc_enum_fmt,
+	.vidioc_g_fmt_vid_cap_mplane = vidioc_g_fmt_vid_cap_mplane,
+	.vidioc_s_fmt_vid_cap_mplane = vidioc_s_fmt_vid_cap_mplane,
+	.vidioc_try_fmt_vid_cap_mplane = vidioc_try_fmt_vid_cap_mplane,
+	.vidioc_reqbufs = vb2_ioctl_reqbufs,
+	.vidioc_create_bufs = vb2_ioctl_create_bufs,
+	.vidioc_prepare_buf = vb2_ioctl_prepare_buf,
+	.vidioc_querybuf = vb2_ioctl_querybuf,
+	.vidioc_qbuf = vb2_ioctl_qbuf,
+	.vidioc_dqbuf = vb2_ioctl_dqbuf,
+	.vidioc_streamon = vb2_ioctl_streamon,
+	.vidioc_streamoff = vb2_ioctl_streamoff,
+	.vidioc_expbuf = vb2_ioctl_expbuf,
+	.vidioc_default = ipu_isys_vidioc_private,
+	.vidioc_enum_input = vidioc_enum_input,
+	.vidioc_g_input = vidioc_g_input,
+	.vidioc_s_input = vidioc_s_input,
+};
+
+static const struct media_entity_operations entity_ops = {
+	.link_validate = link_validate,
+};
+
+static const struct v4l2_file_operations isys_fops = {
+	.owner = THIS_MODULE,
+	.poll = vb2_fop_poll,
+	.unlocked_ioctl = video_ioctl2,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl32 = ipu_isys_compat_ioctl,
+#endif
+	.mmap = vb2_fop_mmap,
+	.open = video_open,
+	.release = video_release,
+};
+
+/*
+ * Do everything that's needed to initialise things related to video
+ * buffer queue, video node, and the related media entity. The caller
+ * is expected to assign isys field and set the name of the video
+ * device.
+ */
+int ipu_isys_video_init(struct ipu_isys_video *av,
+			struct media_entity *entity,
+			unsigned int pad, unsigned long pad_flags,
+			unsigned int flags)
+{
+	const struct v4l2_ioctl_ops *ioctl_ops = NULL;
+	int rval;
+	int i;
+
+	mutex_init(&av->mutex);
+	init_completion(&av->ip.stream_open_completion);
+	init_completion(&av->ip.stream_close_completion);
+	init_completion(&av->ip.stream_start_completion);
+	init_completion(&av->ip.stream_stop_completion);
+	INIT_LIST_HEAD(&av->ip.queues);
+	spin_lock_init(&av->ip.short_packet_queue_lock);
+	av->ip.isys = av->isys;
+	av->ip.vc = INVALIA_VC_ID;
+	for (i = 0; i < NR_OF_CSI2_BE_SOC_SOURCE_PADS; i++) {
+		memset(&av->ip.asv[i], 0,
+		       sizeof(struct ipu_isys_sub_stream_vc));
+		av->ip.asv[i].vc = INVALIA_VC_ID;
+	}
+	av->reset = false;
+	av->skipframe = 0;
+
+	av->vdev.device_caps = V4L2_CAP_STREAMING;
+	if (pad_flags & MEDIA_PAD_FL_SINK) {
+		av->aq.vbq.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+		ioctl_ops = &ioctl_ops_mplane;
+		av->vdev.device_caps |= V4L2_CAP_VIDEO_CAPTURE_MPLANE;
+		av->vdev.vfl_dir = VFL_DIR_RX;
+	} else {
+		av->aq.vbq.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
+		av->vdev.vfl_dir = VFL_DIR_TX;
+		av->vdev.device_caps |= V4L2_CAP_VIDEO_OUTPUT_MPLANE;
+	}
+	rval = ipu_isys_queue_init(&av->aq);
+	if (rval)
+		goto out_mutex_destroy;
+
+	av->pad.flags = pad_flags | MEDIA_PAD_FL_MUST_CONNECT;
+	rval = media_entity_pads_init(&av->vdev.entity, 1, &av->pad);
+	if (rval)
+		goto out_ipu_isys_queue_cleanup;
+
+	av->vdev.entity.ops = &entity_ops;
+	av->vdev.release = video_device_release_empty;
+	av->vdev.fops = &isys_fops;
+	av->vdev.v4l2_dev = &av->isys->v4l2_dev;
+	if (!av->vdev.ioctl_ops)
+		av->vdev.ioctl_ops = ioctl_ops;
+	av->vdev.queue = &av->aq.vbq;
+	av->vdev.lock = &av->mutex;
+	set_bit(V4L2_FL_USES_V4L2_FH, &av->vdev.flags);
+	video_set_drvdata(&av->vdev, av);
+
+	mutex_lock(&av->mutex);
+
+	rval = video_register_device(&av->vdev, VFL_TYPE_VIDEO, -1);
+	if (rval)
+		goto out_media_entity_cleanup;
+
+	if (pad_flags & MEDIA_PAD_FL_SINK)
+		rval = media_create_pad_link(entity, pad,
+					     &av->vdev.entity, 0, flags);
+	else
+		rval = media_create_pad_link(&av->vdev.entity, 0, entity,
+					     pad, flags);
+	if (rval) {
+		dev_info(&av->isys->adev->dev, "can't create link\n");
+		goto out_media_entity_cleanup;
+	}
+
+	av->pfmt = av->try_fmt_vid_mplane(av, &av->mpix);
+
+	mutex_unlock(&av->mutex);
+
+	return rval;
+
+out_media_entity_cleanup:
+	video_unregister_device(&av->vdev);
+	mutex_unlock(&av->mutex);
+	media_entity_cleanup(&av->vdev.entity);
+
+out_ipu_isys_queue_cleanup:
+	ipu_isys_queue_cleanup(&av->aq);
+
+out_mutex_destroy:
+	mutex_destroy(&av->mutex);
+
+	return rval;
+}
+
+void ipu_isys_video_cleanup(struct ipu_isys_video *av)
+{
+	video_unregister_device(&av->vdev);
+	media_entity_cleanup(&av->vdev.entity);
+	mutex_destroy(&av->mutex);
+	ipu_isys_queue_cleanup(&av->aq);
+}
Index: b/drivers/media/pci/intel/ipu-isys-video.h
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu-isys-video.h
@@ -0,0 +1,192 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2013 - 2022 Intel Corporation */
+
+#ifndef IPU_ISYS_VIDEO_H
+#define IPU_ISYS_VIDEO_H
+
+#include <linux/mutex.h>
+#include <linux/list.h>
+#include <linux/videodev2.h>
+#include <media/media-entity.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-subdev.h>
+
+#include "ipu-isys-queue.h"
+#include "ipu-platform-isys.h"
+
+#define IPU_ISYS_OUTPUT_PINS 11
+#define IPU_NUM_CAPTURE_DONE 2
+#define IPU_ISYS_MAX_PARALLEL_SOF 2
+#define CSI2_BE_SOC_SOURCE_PADS_NUM NR_OF_CSI2_BE_SOC_STREAMS
+
+struct ipu_isys;
+struct ipu_isys_csi2_be_soc;
+struct ipu_fw_isys_stream_cfg_data_abi;
+
+struct ipu_isys_pixelformat {
+	u32 pixelformat;
+	u32 bpp;
+	u32 bpp_packed;
+	u32 bpp_planar;
+	u32 code;
+	u32 css_pixelformat;
+};
+
+struct sequence_info {
+	unsigned int sequence;
+	u64 timestamp;
+};
+
+struct output_pin_data {
+	void (*pin_ready)(struct ipu_isys_pipeline *ip,
+			  struct ipu_fw_isys_resp_info_abi *info);
+	struct ipu_isys_queue *aq;
+};
+
+/*
+ * struct ipu_isys_sub_stream_vc
+ */
+struct ipu_isys_sub_stream_vc {
+	unsigned int substream;	/* sub stream id */
+	int vc;	/* VC number */
+	u32 width;
+	u32 height;
+	unsigned int dt;
+	unsigned int code;
+};
+
+#define SUB_STREAM_CODE(value) ((value) & 0xFFFF)
+#define SUB_STREAM_H(value) (((value) >> 16) & 0xFFFF)
+#define SUB_STREAM_W(value) (((value) >> 32) & 0xFFFF)
+#define SUB_STREAM_DT(value) (((value) >> 48) & 0xFF)
+#define SUB_STREAM_VC_ID(value) ((value) >> 56 & 0xFF)
+#define SUB_STREAM_SET_VALUE(vc_id, stream_state) \
+	((((vc_id) << 8) & 0xFF00) | (stream_state))
+
+struct ipu_isys_pipeline {
+	struct media_pipeline pipe;
+	struct media_pad *external;
+	atomic_t sequence;
+	unsigned int seq_index;
+	struct sequence_info seq[IPU_ISYS_MAX_PARALLEL_SOF];
+	int source;	/* SSI stream source */
+	int stream_handle;	/* stream handle for CSS API */
+	unsigned int nr_output_pins;	/* How many firmware pins? */
+	enum ipu_isl_mode isl_mode;
+	struct ipu_isys_csi2_be *csi2_be;
+	struct ipu_isys_csi2_be_soc *csi2_be_soc;
+	struct ipu_isys_csi2 *csi2;
+
+	/*
+	 * Number of capture queues, write access serialised using struct
+	 * ipu_isys.stream_mutex
+	 */
+	/* If it supports vc, this is number of links for the same vc. */
+	int nr_queues;
+	int nr_streaming;	/* Number of capture queues streaming */
+	int streaming;	/* Has streaming been really started? */
+	struct list_head queues;
+	struct completion stream_open_completion;
+	struct completion stream_close_completion;
+	struct completion stream_start_completion;
+	struct completion stream_stop_completion;
+	struct ipu_isys *isys;
+
+	void (*capture_done[IPU_NUM_CAPTURE_DONE])
+	 (struct ipu_isys_pipeline *ip,
+	  struct ipu_fw_isys_resp_info_abi *resp);
+	struct output_pin_data output_pins[IPU_ISYS_OUTPUT_PINS];
+	bool has_sof;
+	bool interlaced;
+	int error;
+	struct ipu_isys_private_buffer *short_packet_bufs;
+	size_t short_packet_buffer_size;
+	unsigned int num_short_packet_lines;
+	unsigned int short_packet_output_pin;
+	unsigned int cur_field;
+	struct list_head short_packet_incoming;
+	struct list_head short_packet_active;
+	/* Serialize access to short packet active and incoming lists */
+	spinlock_t short_packet_queue_lock;
+	struct list_head pending_interlaced_bufs;
+	unsigned int short_packet_trace_index;
+	struct media_graph graph;
+	struct media_entity_enum entity_enum;
+	unsigned int vc;
+	struct ipu_isys_sub_stream_vc asv[CSI2_BE_SOC_SOURCE_PADS_NUM];
+};
+
+#define to_ipu_isys_pipeline(__pipe)				\
+	container_of((__pipe), struct ipu_isys_pipeline, pipe)
+
+struct ipu_isys_video {
+	/* Serialise access to other fields in the struct. */
+	struct mutex mutex;
+	struct media_pad pad;
+	struct video_device vdev;
+	struct v4l2_pix_format_mplane mpix;
+	const struct ipu_isys_pixelformat *pfmts;
+	const struct ipu_isys_pixelformat *pfmt;
+	struct ipu_isys_queue aq;
+	struct ipu_isys *isys;
+	struct ipu_isys_pipeline ip;
+	unsigned int streaming;
+	unsigned int reset;
+	unsigned int skipframe;
+	bool packed;
+	bool compression;
+	struct v4l2_ctrl_handler ctrl_handler;
+	struct v4l2_ctrl *compression_ctrl;
+	unsigned int ts_offsets[VIDEO_MAX_PLANES];
+	unsigned int line_header_length;	/* bits */
+	unsigned int line_footer_length;	/* bits */
+
+	const struct ipu_isys_pixelformat *
+		(*try_fmt_vid_mplane)(struct ipu_isys_video *av,
+				      struct v4l2_pix_format_mplane *mpix);
+	void (*prepare_fw_stream)(struct ipu_isys_video *av,
+				  struct ipu_fw_isys_stream_cfg_data_abi *cfg);
+};
+
+#define ipu_isys_queue_to_video(__aq) \
+	container_of(__aq, struct ipu_isys_video, aq)
+
+extern const struct ipu_isys_pixelformat ipu_isys_pfmts[];
+extern const struct ipu_isys_pixelformat ipu_isys_pfmts_be_soc[];
+extern const struct ipu_isys_pixelformat ipu_isys_pfmts_packed[];
+
+const struct ipu_isys_pixelformat *
+ipu_isys_get_pixelformat(struct ipu_isys_video *av, u32 pixelformat);
+
+int ipu_isys_vidioc_querycap(struct file *file, void *fh,
+			     struct v4l2_capability *cap);
+
+int ipu_isys_vidioc_enum_fmt(struct file *file, void *fh,
+			     struct v4l2_fmtdesc *f);
+
+const struct ipu_isys_pixelformat *
+ipu_isys_video_try_fmt_vid_mplane_default(struct ipu_isys_video *av,
+					  struct v4l2_pix_format_mplane *mpix);
+
+const struct ipu_isys_pixelformat *
+ipu_isys_video_try_fmt_vid_mplane(struct ipu_isys_video *av,
+				  struct v4l2_pix_format_mplane *mpix,
+				  int store_csi2_header);
+
+void
+ipu_isys_prepare_fw_cfg_default(struct ipu_isys_video *av,
+				struct ipu_fw_isys_stream_cfg_data_abi *cfg);
+int ipu_isys_video_prepare_streaming(struct ipu_isys_video *av,
+				     unsigned int state);
+int ipu_isys_video_set_streaming(struct ipu_isys_video *av, unsigned int state,
+				 struct ipu_isys_buffer_list *bl);
+int ipu_isys_video_init(struct ipu_isys_video *av, struct media_entity *source,
+			unsigned int source_pad, unsigned long pad_flags,
+			unsigned int flags);
+void ipu_isys_video_cleanup(struct ipu_isys_video *av);
+void ipu_isys_video_add_capture_done(struct ipu_isys_pipeline *ip,
+				     void (*capture_done)
+				      (struct ipu_isys_pipeline *ip,
+				       struct ipu_fw_isys_resp_info_abi *resp));
+
+#endif /* IPU_ISYS_VIDEO_H */
Index: b/drivers/media/pci/intel/ipu-isys.c
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu-isys.c
@@ -0,0 +1,1231 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) 2013 - 2023 Intel Corporation
+
+#include <linux/debugfs.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+#include <linux/firmware.h>
+#include <linux/kthread.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/string.h>
+#include <linux/sched.h>
+#include <linux/version.h>
+
+#include <media/ipu-isys.h>
+#include <media/v4l2-mc.h>
+#include <media/v4l2-subdev.h>
+#if !IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA)
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-event.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-async.h>
+#endif
+#include "ipu.h"
+#include "ipu-bus.h"
+#include "ipu-cpd.h"
+#include "ipu-mmu.h"
+#include "ipu-dma.h"
+#include "ipu-isys.h"
+#include "ipu-isys-csi2.h"
+#include "ipu-isys-video.h"
+#include "ipu-platform-regs.h"
+#include "ipu-buttress.h"
+#include "ipu-platform.h"
+#include "ipu-platform-buttress-regs.h"
+
+#define ISYS_PM_QOS_VALUE	300
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA)
+/*
+ * The param was passed from module to indicate if port
+ * could be optimized.
+ */
+static bool csi2_port_optimized = true;
+module_param(csi2_port_optimized, bool, 0660);
+MODULE_PARM_DESC(csi2_port_optimized, "IPU CSI2 port optimization");
+#endif
+
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA)
+struct isys_i2c_test {
+	u8 bus_nr;
+	u16 addr;
+	struct i2c_client *client;
+};
+
+static int isys_i2c_test(struct device *dev, void *priv)
+{
+	struct i2c_client *client = i2c_verify_client(dev);
+	struct isys_i2c_test *test = priv;
+
+	if (!client)
+		return 0;
+
+	if (i2c_adapter_id(client->adapter) != test->bus_nr ||
+	    client->addr != test->addr)
+		return 0;
+
+	test->client = client;
+
+	return 0;
+}
+
+static struct
+i2c_client *isys_find_i2c_subdev(struct i2c_adapter *adapter,
+				 struct ipu_isys_subdev_info *sd_info)
+{
+	struct i2c_board_info *info = &sd_info->i2c.board_info;
+	struct isys_i2c_test test = {
+		.bus_nr = i2c_adapter_id(adapter),
+		.addr = info->addr,
+	};
+	int rval;
+
+	rval = i2c_for_each_dev(&test, isys_i2c_test);
+	if (rval || !test.client)
+		return NULL;
+	return test.client;
+}
+#endif
+static int
+isys_complete_ext_device_registration(struct ipu_isys *isys,
+				      struct v4l2_subdev *sd,
+				      struct ipu_isys_csi2_config *csi2)
+{
+	unsigned int i;
+	int rval;
+
+	v4l2_set_subdev_hostdata(sd, csi2);
+
+	for (i = 0; i < sd->entity.num_pads; i++) {
+		if (sd->entity.pads[i].flags & MEDIA_PAD_FL_SOURCE)
+			break;
+	}
+
+	if (i == sd->entity.num_pads) {
+		dev_warn(&isys->adev->dev,
+			 "no source pad in external entity\n");
+		rval = -ENOENT;
+		goto skip_unregister_subdev;
+	}
+
+	rval = media_create_pad_link(&sd->entity, i,
+				     &isys->csi2[csi2->port].asd.sd.entity,
+				     0, 0);
+	if (rval) {
+		dev_warn(&isys->adev->dev, "can't create link\n");
+		goto skip_unregister_subdev;
+	}
+
+	isys->csi2[csi2->port].nlanes = csi2->nlanes;
+	return 0;
+
+skip_unregister_subdev:
+	v4l2_device_unregister_subdev(sd);
+	return rval;
+}
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA)
+static int isys_register_ext_subdev(struct ipu_isys *isys,
+				    struct ipu_isys_subdev_info *sd_info)
+{
+	struct i2c_adapter *adapter;
+	struct v4l2_subdev *sd;
+	struct i2c_client *client;
+	int rval;
+	int bus;
+
+	bus = ipu_get_i2c_bus_id(sd_info->i2c.i2c_adapter_id,
+			sd_info->i2c.i2c_adapter_bdf,
+			sizeof(sd_info->i2c.i2c_adapter_bdf));
+	if (bus < 0) {
+		dev_err(&isys->adev->dev,
+			"getting i2c bus id for adapter %d (bdf %s) failed",
+			sd_info->i2c.i2c_adapter_id,
+			sd_info->i2c.i2c_adapter_bdf);
+		return -ENOENT;
+	}
+	dev_info(&isys->adev->dev,
+		 "got i2c bus id %d for adapter %d (bdf %s)", bus,
+		 sd_info->i2c.i2c_adapter_id,
+		 sd_info->i2c.i2c_adapter_bdf);
+	adapter = i2c_get_adapter(bus);
+	if (!adapter) {
+		dev_warn(&isys->adev->dev, "can't find adapter\n");
+		return -ENOENT;
+	}
+
+	dev_info(&isys->adev->dev,
+		 "creating new i2c subdev for %s (address %2.2x, bus %d)",
+		 sd_info->i2c.board_info.type, sd_info->i2c.board_info.addr,
+		 bus);
+
+	if (sd_info->csi2) {
+		dev_info(&isys->adev->dev, "sensor device on CSI port: %d\n",
+			 sd_info->csi2->port);
+		if (sd_info->csi2->port >= isys->pdata->ipdata->csi2.nports ||
+		    !isys->csi2[sd_info->csi2->port].isys) {
+			dev_warn(&isys->adev->dev, "invalid csi2 port %u\n",
+				 sd_info->csi2->port);
+			rval = -EINVAL;
+			goto skip_put_adapter;
+		}
+	} else {
+		dev_info(&isys->adev->dev, "non camera subdevice\n");
+	}
+
+	client = isys_find_i2c_subdev(adapter, sd_info);
+	if (client) {
+		dev_dbg(&isys->adev->dev, "Device exists\n");
+		rval = 0;
+		goto skip_put_adapter;
+	}
+
+	sd = v4l2_i2c_new_subdev_board(&isys->v4l2_dev, adapter,
+				       &sd_info->i2c.board_info, NULL);
+	if (!sd) {
+		dev_warn(&isys->adev->dev, "can't create new i2c subdev\n");
+		rval = -EINVAL;
+		goto skip_put_adapter;
+	}
+
+	if (!sd_info->csi2)
+		return 0;
+
+	return isys_complete_ext_device_registration(isys, sd, sd_info->csi2);
+
+skip_put_adapter:
+	i2c_put_adapter(adapter);
+
+	return rval;
+}
+
+static void isys_register_ext_subdevs(struct ipu_isys *isys)
+{
+	struct ipu_isys_subdev_pdata *spdata = isys->pdata->spdata;
+	struct ipu_isys_subdev_info **sd_info;
+
+	if (!spdata) {
+		dev_info(&isys->adev->dev, "no subdevice info provided\n");
+		return;
+	}
+	for (sd_info = spdata->subdevs; *sd_info; sd_info++)
+		isys_register_ext_subdev(isys, *sd_info);
+}
+#endif
+
+static void isys_unregister_subdevices(struct ipu_isys *isys)
+{
+	const struct ipu_isys_internal_csi2_pdata *csi2 =
+	    &isys->pdata->ipdata->csi2;
+	unsigned int i;
+
+	ipu_isys_csi2_be_cleanup(&isys->csi2_be);
+	for (i = 0; i < NR_OF_CSI2_BE_SOC_DEV; i++)
+		ipu_isys_csi2_be_soc_cleanup(&isys->csi2_be_soc[i]);
+
+	for (i = 0; i < csi2->nports; i++)
+		ipu_isys_csi2_cleanup(&isys->csi2[i]);
+}
+
+static int isys_register_subdevices(struct ipu_isys *isys)
+{
+	const struct ipu_isys_internal_csi2_pdata *csi2 =
+	    &isys->pdata->ipdata->csi2;
+	struct ipu_isys_csi2_be_soc *csi2_be_soc;
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA)
+	struct ipu_isys_subdev_pdata *spdata = isys->pdata->spdata;
+	struct ipu_isys_subdev_info **sd_info;
+	DECLARE_BITMAP(csi2_enable, 32);
+#endif
+	unsigned int i, k;
+	int rval;
+
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA)
+	/*
+	 * Here is somewhat a workaround, let each platform decide
+	 * if csi2 port can be optimized, which means only registered
+	 * port from pdata would be enabled.
+	 */
+	if (csi2_port_optimized && spdata) {
+		bitmap_zero(csi2_enable, 32);
+		for (sd_info = spdata->subdevs; *sd_info; sd_info++) {
+			if ((*sd_info)->csi2) {
+				i = (*sd_info)->csi2->port;
+				if (i >= csi2->nports) {
+					dev_warn(&isys->adev->dev,
+						 "invalid csi2 port %u\n", i);
+					continue;
+				}
+				bitmap_set(csi2_enable, i, 1);
+			}
+		}
+	} else {
+		bitmap_fill(csi2_enable, 32);
+	}
+#endif
+	isys->csi2 = devm_kcalloc(&isys->adev->dev, csi2->nports,
+				  sizeof(*isys->csi2), GFP_KERNEL);
+	if (!isys->csi2) {
+		rval = -ENOMEM;
+		goto fail;
+	}
+
+	for (i = 0; i < csi2->nports; i++) {
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA)
+		if (!test_bit(i, csi2_enable))
+			continue;
+#endif
+		rval = ipu_isys_csi2_init(&isys->csi2[i], isys,
+					  isys->pdata->base +
+					  csi2->offsets[i], i);
+		if (rval)
+			goto fail;
+
+		isys->isr_csi2_bits |= IPU_ISYS_UNISPART_IRQ_CSI2(i);
+	}
+
+	for (k = 0; k < NR_OF_CSI2_BE_SOC_DEV; k++) {
+		rval = ipu_isys_csi2_be_soc_init(&isys->csi2_be_soc[k],
+						 isys, k);
+		if (rval) {
+			dev_info(&isys->adev->dev,
+				 "can't register csi2 soc be device %d\n", k);
+			goto fail;
+		}
+	}
+
+	rval = ipu_isys_csi2_be_init(&isys->csi2_be, isys);
+	if (rval) {
+		dev_info(&isys->adev->dev,
+			 "can't register raw csi2 be device\n");
+		goto fail;
+	}
+
+	for (i = 0; i < csi2->nports; i++) {
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA)
+		if (!test_bit(i, csi2_enable))
+			continue;
+#endif
+		rval = media_create_pad_link(&isys->csi2[i].asd.sd.entity,
+					     CSI2_PAD_SOURCE,
+					     &isys->csi2_be.asd.sd.entity,
+					     CSI2_BE_PAD_SINK, 0);
+		if (rval) {
+			dev_info(&isys->adev->dev,
+				 "can't create link csi2 <=> csi2_be\n");
+			goto fail;
+		}
+		for (k = 0; k < NR_OF_CSI2_BE_SOC_DEV; k++) {
+			csi2_be_soc = &isys->csi2_be_soc[k];
+			rval =
+			    media_create_pad_link(&isys->csi2[i].asd.sd.entity,
+						  CSI2_PAD_SOURCE,
+						  &csi2_be_soc->asd.sd.entity,
+						  CSI2_BE_SOC_PAD_SINK, 0);
+			if (rval) {
+				dev_info(&isys->adev->dev,
+					 "can't create link csi2->be_soc\n");
+				goto fail;
+			}
+		}
+	}
+
+	return 0;
+
+fail:
+	isys_unregister_subdevices(isys);
+	return rval;
+}
+
+#if !IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA)
+/* The .bound() notifier callback when a match is found */
+static int isys_notifier_bound(struct v4l2_async_notifier *notifier,
+			       struct v4l2_subdev *sd,
+			       struct v4l2_async_subdev *asd)
+{
+	struct ipu_isys *isys = container_of(notifier,
+					struct ipu_isys, notifier);
+	struct sensor_async_subdev *s_asd = container_of(asd,
+					struct sensor_async_subdev, asd);
+
+	dev_info(&isys->adev->dev, "bind %s nlanes is %d port is %d\n",
+		 sd->name, s_asd->csi2.nlanes, s_asd->csi2.port);
+	isys_complete_ext_device_registration(isys, sd, &s_asd->csi2);
+
+	return v4l2_device_register_subdev_nodes(&isys->v4l2_dev);
+}
+
+static void isys_notifier_unbind(struct v4l2_async_notifier *notifier,
+				 struct v4l2_subdev *sd,
+				 struct v4l2_async_subdev *asd)
+{
+	struct ipu_isys *isys = container_of(notifier,
+					struct ipu_isys, notifier);
+
+	dev_info(&isys->adev->dev, "unbind %s\n", sd->name);
+}
+
+static int isys_notifier_complete(struct v4l2_async_notifier *notifier)
+{
+	struct ipu_isys *isys = container_of(notifier,
+					struct ipu_isys, notifier);
+
+	dev_info(&isys->adev->dev, "All sensor registration completed.\n");
+
+	return v4l2_device_register_subdev_nodes(&isys->v4l2_dev);
+}
+
+static const struct v4l2_async_notifier_operations isys_async_ops = {
+	.bound = isys_notifier_bound,
+	.unbind = isys_notifier_unbind,
+	.complete = isys_notifier_complete,
+};
+
+static int isys_fwnode_parse(struct device *dev,
+			     struct v4l2_fwnode_endpoint *vep,
+			     struct v4l2_async_subdev *asd)
+{
+	struct sensor_async_subdev *s_asd =
+			container_of(asd, struct sensor_async_subdev, asd);
+
+	s_asd->csi2.port = vep->base.port;
+	s_asd->csi2.nlanes = vep->bus.mipi_csi2.num_data_lanes;
+
+	return 0;
+}
+
+static int isys_notifier_init(struct ipu_isys *isys)
+{
+	struct ipu_device *isp = isys->adev->isp;
+	size_t asd_struct_size = sizeof(struct sensor_async_subdev);
+	int ret;
+
+	v4l2_async_nf_init(&isys->notifier);
+	ret = v4l2_async_nf_parse_fwnode_endpoints(&isp->pdev->dev,
+						   &isys->notifier,
+						   asd_struct_size,
+						   isys_fwnode_parse);
+	if (ret < 0) {
+		dev_err(&isys->adev->dev,
+			"v4l2 parse_fwnode_endpoints() failed: %d\n", ret);
+		return ret;
+	}
+	if (list_empty(&isys->notifier.asd_list)) {
+		/* isys probe could continue with async subdevs missing */
+		dev_warn(&isys->adev->dev, "no subdev found in graph\n");
+		return 0;
+	}
+
+	isys->notifier.ops = &isys_async_ops;
+	ret = v4l2_async_nf_register(&isys->v4l2_dev, &isys->notifier);
+	if (ret) {
+		dev_err(&isys->adev->dev,
+			"failed to register async notifier : %d\n", ret);
+		v4l2_async_nf_cleanup(&isys->notifier);
+	}
+
+	return ret;
+}
+
+static void isys_notifier_cleanup(struct ipu_isys *isys)
+{
+	v4l2_async_nf_unregister(&isys->notifier);
+	v4l2_async_nf_cleanup(&isys->notifier);
+}
+#endif
+
+static struct media_device_ops isys_mdev_ops = {
+	.link_notify = v4l2_pipeline_link_notify,
+};
+
+static int isys_register_devices(struct ipu_isys *isys)
+{
+	int rval;
+
+	isys->media_dev.dev = &isys->adev->dev;
+	isys->media_dev.ops = &isys_mdev_ops;
+	strlcpy(isys->media_dev.model,
+		IPU_MEDIA_DEV_MODEL_NAME, sizeof(isys->media_dev.model));
+	snprintf(isys->media_dev.bus_info, sizeof(isys->media_dev.bus_info),
+		 "pci:%s", dev_name(isys->adev->dev.parent->parent));
+	strlcpy(isys->v4l2_dev.name, isys->media_dev.model,
+		sizeof(isys->v4l2_dev.name));
+
+	media_device_init(&isys->media_dev);
+
+	rval = media_device_register(&isys->media_dev);
+	if (rval < 0) {
+		dev_info(&isys->adev->dev, "can't register media device\n");
+		goto out_media_device_unregister;
+	}
+
+	isys->v4l2_dev.mdev = &isys->media_dev;
+
+	rval = v4l2_device_register(&isys->adev->dev, &isys->v4l2_dev);
+	if (rval < 0) {
+		dev_info(&isys->adev->dev, "can't register v4l2 device\n");
+		goto out_media_device_unregister;
+	}
+
+	rval = isys_register_subdevices(isys);
+	if (rval)
+		goto out_v4l2_device_unregister;
+
+#if !IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA)
+	rval = isys_notifier_init(isys);
+	if (rval)
+		goto out_isys_unregister_subdevices;
+#else
+	isys_register_ext_subdevs(isys);
+#endif
+
+	rval = v4l2_device_register_subdev_nodes(&isys->v4l2_dev);
+	if (rval)
+		goto out_isys_notifier_cleanup;
+
+	return 0;
+
+out_isys_notifier_cleanup:
+#if !IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA)
+	isys_notifier_cleanup(isys);
+#endif
+
+#if !IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA)
+out_isys_unregister_subdevices:
+	isys_unregister_subdevices(isys);
+#else
+	isys_unregister_subdevices(isys);
+#endif
+
+out_v4l2_device_unregister:
+	v4l2_device_unregister(&isys->v4l2_dev);
+
+out_media_device_unregister:
+	media_device_unregister(&isys->media_dev);
+	media_device_cleanup(&isys->media_dev);
+
+	return rval;
+}
+
+static void isys_unregister_devices(struct ipu_isys *isys)
+{
+	isys_unregister_subdevices(isys);
+	v4l2_device_unregister(&isys->v4l2_dev);
+	media_device_unregister(&isys->media_dev);
+	media_device_cleanup(&isys->media_dev);
+}
+
+#ifdef CONFIG_PM
+static int isys_runtime_pm_resume(struct device *dev)
+{
+	struct ipu_bus_device *adev = to_ipu_bus_device(dev);
+	struct ipu_device *isp = adev->isp;
+	struct ipu_isys *isys = ipu_bus_get_drvdata(adev);
+	unsigned long flags;
+	int ret;
+
+	if (!isys)
+		return 0;
+
+	ret = ipu_mmu_hw_init(adev->mmu);
+	if (ret)
+		return ret;
+
+	ipu_trace_restore(dev);
+
+	cpu_latency_qos_update_request(&isys->pm_qos, ISYS_PM_QOS_VALUE);
+
+	ret = ipu_buttress_start_tsc_sync(isp);
+	if (ret)
+		return ret;
+
+	spin_lock_irqsave(&isys->power_lock, flags);
+	isys->power = 1;
+	spin_unlock_irqrestore(&isys->power_lock, flags);
+
+	if (isys->short_packet_source == IPU_ISYS_SHORT_PACKET_FROM_TUNIT) {
+		mutex_lock(&isys->short_packet_tracing_mutex);
+		isys->short_packet_tracing_count = 0;
+		mutex_unlock(&isys->short_packet_tracing_mutex);
+	}
+	isys_setup_hw(isys);
+
+	return 0;
+}
+
+static int isys_runtime_pm_suspend(struct device *dev)
+{
+	struct ipu_bus_device *adev = to_ipu_bus_device(dev);
+	struct ipu_isys *isys = ipu_bus_get_drvdata(adev);
+	unsigned long flags;
+
+	if (!isys)
+		return 0;
+
+	spin_lock_irqsave(&isys->power_lock, flags);
+	isys->power = 0;
+	spin_unlock_irqrestore(&isys->power_lock, flags);
+
+	ipu_trace_stop(dev);
+	mutex_lock(&isys->mutex);
+	isys->reset_needed = false;
+	mutex_unlock(&isys->mutex);
+
+	isys->phy_termcal_val = 0;
+	cpu_latency_qos_update_request(&isys->pm_qos, PM_QOS_DEFAULT_VALUE);
+
+	ipu_mmu_hw_cleanup(adev->mmu);
+
+	return 0;
+}
+
+static int isys_suspend(struct device *dev)
+{
+	struct ipu_bus_device *adev = to_ipu_bus_device(dev);
+	struct ipu_isys *isys = ipu_bus_get_drvdata(adev);
+
+	/* If stream is open, refuse to suspend */
+	if (isys->stream_opened)
+		return -EBUSY;
+
+	return 0;
+}
+
+static int isys_resume(struct device *dev)
+{
+	return 0;
+}
+
+static const struct dev_pm_ops isys_pm_ops = {
+	.runtime_suspend = isys_runtime_pm_suspend,
+	.runtime_resume = isys_runtime_pm_resume,
+	.suspend = isys_suspend,
+	.resume = isys_resume,
+};
+
+#define ISYS_PM_OPS (&isys_pm_ops)
+#else
+#define ISYS_PM_OPS NULL
+#endif
+
+static void isys_remove(struct ipu_bus_device *adev)
+{
+	struct ipu_isys *isys = ipu_bus_get_drvdata(adev);
+	struct ipu_device *isp = adev->isp;
+	struct isys_fw_msgs *fwmsg, *safe;
+
+	dev_info(&adev->dev, "removed\n");
+#ifdef CONFIG_DEBUG_FS
+	if (isp->ipu_dir)
+		debugfs_remove_recursive(isys->debugfsdir);
+#endif
+
+	list_for_each_entry_safe(fwmsg, safe, &isys->framebuflist, head) {
+		dma_free_attrs(&adev->dev, sizeof(struct isys_fw_msgs),
+			       fwmsg, fwmsg->dma_addr,
+			       0);
+	}
+
+	list_for_each_entry_safe(fwmsg, safe, &isys->framebuflist_fw, head) {
+		dma_free_attrs(&adev->dev, sizeof(struct isys_fw_msgs),
+			       fwmsg, fwmsg->dma_addr,
+			       0
+		    );
+	}
+
+	ipu_trace_uninit(&adev->dev);
+#if !IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA)
+	isys_notifier_cleanup(isys);
+#endif
+	isys_unregister_devices(isys);
+
+	cpu_latency_qos_remove_request(&isys->pm_qos);
+
+	if (!isp->secure_mode) {
+		ipu_cpd_free_pkg_dir(adev, isys->pkg_dir,
+				     isys->pkg_dir_dma_addr,
+				     isys->pkg_dir_size);
+		ipu_buttress_unmap_fw_image(adev, &isys->fw_sgt);
+		release_firmware(isys->fw);
+	}
+
+	mutex_destroy(&isys->stream_mutex);
+	mutex_destroy(&isys->mutex);
+
+	mutex_destroy(&isys->reset_mutex);
+	if (isys->short_packet_source == IPU_ISYS_SHORT_PACKET_FROM_TUNIT) {
+		u32 trace_size = IPU_ISYS_SHORT_PACKET_TRACE_BUFFER_SIZE;
+
+		dma_free_coherent(&adev->dev, trace_size,
+				  isys->short_packet_trace_buffer,
+				  isys->short_packet_trace_buffer_dma_addr);
+	}
+}
+
+#ifdef CONFIG_DEBUG_FS
+static int ipu_isys_icache_prefetch_get(void *data, u64 *val)
+{
+	struct ipu_isys *isys = data;
+
+	*val = isys->icache_prefetch;
+	return 0;
+}
+
+static int ipu_isys_icache_prefetch_set(void *data, u64 val)
+{
+	struct ipu_isys *isys = data;
+
+	if (val != !!val)
+		return -EINVAL;
+
+	isys->icache_prefetch = val;
+
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(isys_icache_prefetch_fops,
+			ipu_isys_icache_prefetch_get,
+			ipu_isys_icache_prefetch_set, "%llu\n");
+
+static int ipu_isys_init_debugfs(struct ipu_isys *isys)
+{
+	struct dentry *file;
+	struct dentry *dir;
+#ifdef IPU_ISYS_GPC
+	int ret;
+#endif
+
+	dir = debugfs_create_dir("isys", isys->adev->isp->ipu_dir);
+	if (IS_ERR(dir))
+		return -ENOMEM;
+
+	file = debugfs_create_file("icache_prefetch", 0600,
+				   dir, isys, &isys_icache_prefetch_fops);
+	if (IS_ERR(file))
+		goto err;
+
+	isys->debugfsdir = dir;
+
+#ifdef IPU_ISYS_GPC
+	ret = ipu_isys_gpc_init_debugfs(isys);
+	if (ret)
+		return ret;
+#endif
+
+	return 0;
+err:
+	debugfs_remove_recursive(dir);
+	return -ENOMEM;
+}
+#endif
+
+static int alloc_fw_msg_bufs(struct ipu_isys *isys, int amount)
+{
+	dma_addr_t dma_addr;
+	struct isys_fw_msgs *addr;
+	unsigned int i;
+	unsigned long flags;
+
+	for (i = 0; i < amount; i++) {
+		addr = dma_alloc_attrs(&isys->adev->dev,
+				       sizeof(struct isys_fw_msgs),
+				       &dma_addr, GFP_KERNEL,
+				       0);
+		if (!addr)
+			break;
+		addr->dma_addr = dma_addr;
+
+		spin_lock_irqsave(&isys->listlock, flags);
+		list_add(&addr->head, &isys->framebuflist);
+		spin_unlock_irqrestore(&isys->listlock, flags);
+	}
+	if (i == amount)
+		return 0;
+	spin_lock_irqsave(&isys->listlock, flags);
+	while (!list_empty(&isys->framebuflist)) {
+		addr = list_first_entry(&isys->framebuflist,
+					struct isys_fw_msgs, head);
+		list_del(&addr->head);
+		spin_unlock_irqrestore(&isys->listlock, flags);
+		dma_free_attrs(&isys->adev->dev,
+			       sizeof(struct isys_fw_msgs),
+			       addr, addr->dma_addr,
+			       0);
+		spin_lock_irqsave(&isys->listlock, flags);
+	}
+	spin_unlock_irqrestore(&isys->listlock, flags);
+	return -ENOMEM;
+}
+
+struct isys_fw_msgs *ipu_get_fw_msg_buf(struct ipu_isys_pipeline *ip)
+{
+	struct ipu_isys_video *pipe_av =
+	    container_of(ip, struct ipu_isys_video, ip);
+	struct ipu_isys *isys;
+	struct isys_fw_msgs *msg;
+	unsigned long flags;
+
+	isys = pipe_av->isys;
+
+	spin_lock_irqsave(&isys->listlock, flags);
+	if (list_empty(&isys->framebuflist)) {
+		spin_unlock_irqrestore(&isys->listlock, flags);
+		dev_dbg(&isys->adev->dev, "Frame list empty - Allocate more");
+
+		alloc_fw_msg_bufs(isys, 5);
+
+		spin_lock_irqsave(&isys->listlock, flags);
+		if (list_empty(&isys->framebuflist)) {
+			spin_unlock_irqrestore(&isys->listlock, flags);
+			dev_err(&isys->adev->dev, "Frame list empty");
+			return NULL;
+		}
+	}
+	msg = list_last_entry(&isys->framebuflist, struct isys_fw_msgs, head);
+	list_move(&msg->head, &isys->framebuflist_fw);
+	spin_unlock_irqrestore(&isys->listlock, flags);
+	memset(&msg->fw_msg, 0, sizeof(msg->fw_msg));
+
+	return msg;
+}
+
+void ipu_cleanup_fw_msg_bufs(struct ipu_isys *isys)
+{
+	struct isys_fw_msgs *fwmsg, *fwmsg0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&isys->listlock, flags);
+	list_for_each_entry_safe(fwmsg, fwmsg0, &isys->framebuflist_fw, head)
+		list_move(&fwmsg->head, &isys->framebuflist);
+	spin_unlock_irqrestore(&isys->listlock, flags);
+}
+
+void ipu_put_fw_mgs_buf(struct ipu_isys *isys, u64 data)
+{
+	struct isys_fw_msgs *msg;
+	unsigned long flags;
+	u64 *ptr = (u64 *)(unsigned long)data;
+
+	if (!ptr)
+		return;
+
+	spin_lock_irqsave(&isys->listlock, flags);
+	msg = container_of(ptr, struct isys_fw_msgs, fw_msg.dummy);
+	list_move(&msg->head, &isys->framebuflist);
+	spin_unlock_irqrestore(&isys->listlock, flags);
+}
+
+static int isys_probe(struct ipu_bus_device *adev)
+{
+	struct ipu_isys *isys;
+	struct ipu_device *isp = adev->isp;
+	const struct firmware *fw;
+	int rval = 0;
+
+	isys = devm_kzalloc(&adev->dev, sizeof(*isys), GFP_KERNEL);
+	if (!isys)
+		return -ENOMEM;
+
+	rval = ipu_mmu_hw_init(adev->mmu);
+	if (rval)
+		return rval;
+
+	/* By default, short packet is captured from T-Unit. */
+	isys->short_packet_source = IPU_ISYS_SHORT_PACKET_FROM_RECEIVER;
+	isys->adev = adev;
+	isys->pdata = adev->pdata;
+
+	/* initial streamID for different sensor types */
+	if (ipu_ver == IPU_VER_6 || ipu_ver == IPU_VER_6EP ||
+	    ipu_ver == IPU_VER_6EP_MTL) {
+		isys->sensor_info.vc1_data_start =
+			IPU6_FW_ISYS_VC1_SENSOR_DATA_START;
+		isys->sensor_info.vc1_data_end =
+			IPU6_FW_ISYS_VC1_SENSOR_DATA_END;
+		isys->sensor_info.vc0_data_start =
+			IPU6_FW_ISYS_VC0_SENSOR_DATA_START;
+		isys->sensor_info.vc0_data_end =
+			IPU6_FW_ISYS_VC0_SENSOR_DATA_END;
+		isys->sensor_info.vc1_pdaf_start =
+			IPU6_FW_ISYS_VC1_SENSOR_PDAF_START;
+		isys->sensor_info.vc1_pdaf_end =
+			IPU6_FW_ISYS_VC1_SENSOR_PDAF_END;
+		isys->sensor_info.sensor_metadata =
+			IPU6_FW_ISYS_SENSOR_METADATA;
+
+		isys->sensor_types[IPU_FW_ISYS_VC1_SENSOR_DATA] =
+			IPU6_FW_ISYS_VC1_SENSOR_DATA_START;
+		isys->sensor_types[IPU_FW_ISYS_VC1_SENSOR_PDAF] =
+			IPU6_FW_ISYS_VC1_SENSOR_PDAF_START;
+		isys->sensor_types[IPU_FW_ISYS_VC0_SENSOR_DATA] =
+			IPU6_FW_ISYS_VC0_SENSOR_DATA_START;
+	} else if (ipu_ver == IPU_VER_6SE) {
+		isys->sensor_info.vc1_data_start =
+			IPU6SE_FW_ISYS_VC1_SENSOR_DATA_START;
+		isys->sensor_info.vc1_data_end =
+			IPU6SE_FW_ISYS_VC1_SENSOR_DATA_END;
+		isys->sensor_info.vc0_data_start =
+			IPU6SE_FW_ISYS_VC0_SENSOR_DATA_START;
+		isys->sensor_info.vc0_data_end =
+			IPU6SE_FW_ISYS_VC0_SENSOR_DATA_END;
+		isys->sensor_info.vc1_pdaf_start =
+			IPU6SE_FW_ISYS_VC1_SENSOR_PDAF_START;
+		isys->sensor_info.vc1_pdaf_end =
+			IPU6SE_FW_ISYS_VC1_SENSOR_PDAF_END;
+		isys->sensor_info.sensor_metadata =
+			IPU6SE_FW_ISYS_SENSOR_METADATA;
+
+		isys->sensor_types[IPU_FW_ISYS_VC1_SENSOR_DATA] =
+			IPU6SE_FW_ISYS_VC1_SENSOR_DATA_START;
+		isys->sensor_types[IPU_FW_ISYS_VC1_SENSOR_PDAF] =
+			IPU6SE_FW_ISYS_VC1_SENSOR_PDAF_START;
+		isys->sensor_types[IPU_FW_ISYS_VC0_SENSOR_DATA] =
+			IPU6SE_FW_ISYS_VC0_SENSOR_DATA_START;
+	}
+
+	INIT_LIST_HEAD(&isys->requests);
+
+	spin_lock_init(&isys->lock);
+	spin_lock_init(&isys->power_lock);
+	isys->power = 0;
+	isys->phy_termcal_val = 0;
+
+	mutex_init(&isys->mutex);
+	mutex_init(&isys->stream_mutex);
+	mutex_init(&isys->lib_mutex);
+
+	mutex_init(&isys->reset_mutex);
+	isys->in_reset = false;
+
+	spin_lock_init(&isys->listlock);
+	INIT_LIST_HEAD(&isys->framebuflist);
+	INIT_LIST_HEAD(&isys->framebuflist_fw);
+
+	dev_dbg(&adev->dev, "isys probe %p %p\n", adev, &adev->dev);
+	ipu_bus_set_drvdata(adev, isys);
+
+	isys->line_align = IPU_ISYS_2600_MEM_LINE_ALIGN;
+	isys->icache_prefetch = 0;
+
+#ifndef CONFIG_PM
+	isys_setup_hw(isys);
+#endif
+
+	if (!isp->secure_mode) {
+		fw = isp->cpd_fw;
+		rval = ipu_buttress_map_fw_image(adev, fw, &isys->fw_sgt);
+		if (rval)
+			goto release_firmware;
+
+		isys->pkg_dir =
+		    ipu_cpd_create_pkg_dir(adev, isp->cpd_fw->data,
+					   sg_dma_address(isys->fw_sgt.sgl),
+					   &isys->pkg_dir_dma_addr,
+					   &isys->pkg_dir_size);
+		if (!isys->pkg_dir) {
+			rval = -ENOMEM;
+			goto remove_shared_buffer;
+		}
+	}
+
+#ifdef CONFIG_DEBUG_FS
+	/* Debug fs failure is not fatal. */
+	ipu_isys_init_debugfs(isys);
+#endif
+
+	ipu_trace_init(adev->isp, isys->pdata->base, &adev->dev,
+		       isys_trace_blocks);
+
+	cpu_latency_qos_add_request(&isys->pm_qos, PM_QOS_DEFAULT_VALUE);
+	alloc_fw_msg_bufs(isys, 20);
+
+	rval = isys_register_devices(isys);
+	if (rval)
+		goto out_remove_pkg_dir_shared_buffer;
+
+	ipu_mmu_hw_cleanup(adev->mmu);
+
+	return 0;
+
+out_remove_pkg_dir_shared_buffer:
+	if (!isp->secure_mode)
+		ipu_cpd_free_pkg_dir(adev, isys->pkg_dir,
+				     isys->pkg_dir_dma_addr,
+				     isys->pkg_dir_size);
+remove_shared_buffer:
+	if (!isp->secure_mode)
+		ipu_buttress_unmap_fw_image(adev, &isys->fw_sgt);
+release_firmware:
+	if (!isp->secure_mode)
+		release_firmware(isys->fw);
+	ipu_trace_uninit(&adev->dev);
+
+	mutex_destroy(&isys->mutex);
+	mutex_destroy(&isys->stream_mutex);
+
+	mutex_destroy(&isys->reset_mutex);
+
+	if (isys->short_packet_source == IPU_ISYS_SHORT_PACKET_FROM_TUNIT)
+		mutex_destroy(&isys->short_packet_tracing_mutex);
+
+	ipu_mmu_hw_cleanup(adev->mmu);
+
+	return rval;
+}
+
+struct fwmsg {
+	int type;
+	char *msg;
+	bool valid_ts;
+};
+
+static const struct fwmsg fw_msg[] = {
+	{IPU_FW_ISYS_RESP_TYPE_STREAM_OPEN_DONE, "STREAM_OPEN_DONE", 0},
+	{IPU_FW_ISYS_RESP_TYPE_STREAM_CLOSE_ACK, "STREAM_CLOSE_ACK", 0},
+	{IPU_FW_ISYS_RESP_TYPE_STREAM_START_ACK, "STREAM_START_ACK", 0},
+	{IPU_FW_ISYS_RESP_TYPE_STREAM_START_AND_CAPTURE_ACK,
+	 "STREAM_START_AND_CAPTURE_ACK", 0},
+	{IPU_FW_ISYS_RESP_TYPE_STREAM_STOP_ACK, "STREAM_STOP_ACK", 0},
+	{IPU_FW_ISYS_RESP_TYPE_STREAM_FLUSH_ACK, "STREAM_FLUSH_ACK", 0},
+	{IPU_FW_ISYS_RESP_TYPE_PIN_DATA_READY, "PIN_DATA_READY", 1},
+	{IPU_FW_ISYS_RESP_TYPE_STREAM_CAPTURE_ACK, "STREAM_CAPTURE_ACK", 0},
+	{IPU_FW_ISYS_RESP_TYPE_STREAM_START_AND_CAPTURE_DONE,
+	 "STREAM_START_AND_CAPTURE_DONE", 1},
+	{IPU_FW_ISYS_RESP_TYPE_STREAM_CAPTURE_DONE, "STREAM_CAPTURE_DONE", 1},
+	{IPU_FW_ISYS_RESP_TYPE_FRAME_SOF, "FRAME_SOF", 1},
+	{IPU_FW_ISYS_RESP_TYPE_FRAME_EOF, "FRAME_EOF", 1},
+	{IPU_FW_ISYS_RESP_TYPE_STATS_DATA_READY, "STATS_READY", 1},
+	{-1, "UNKNOWN MESSAGE", 0},
+};
+
+static int resp_type_to_index(int type)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(fw_msg); i++)
+		if (fw_msg[i].type == type)
+			return i;
+
+	return i - 1;
+}
+
+int isys_isr_one(struct ipu_bus_device *adev)
+{
+	struct ipu_isys *isys = ipu_bus_get_drvdata(adev);
+	struct ipu_fw_isys_resp_info_abi resp_data;
+	struct ipu_fw_isys_resp_info_abi *resp;
+	struct ipu_isys_pipeline *pipe;
+	u64 ts;
+	unsigned int i;
+
+	if (!isys->fwcom)
+		return 0;
+
+	resp = ipu_fw_isys_get_resp(isys->fwcom, IPU_BASE_MSG_RECV_QUEUES,
+				    &resp_data);
+	if (!resp)
+		return 1;
+
+	ts = (u64)resp->timestamp[1] << 32 | resp->timestamp[0];
+
+	if (resp->error_info.error == IPU_FW_ISYS_ERROR_STREAM_IN_SUSPENSION)
+		/* Suspension is kind of special case: not enough buffers */
+		dev_dbg(&adev->dev,
+			"hostlib: error resp %02d %s, stream %u, error SUSPENSION, details %d, timestamp 0x%16.16llx, pin %d\n",
+			resp->type,
+			fw_msg[resp_type_to_index(resp->type)].msg,
+			resp->stream_handle,
+			resp->error_info.error_details,
+			fw_msg[resp_type_to_index(resp->type)].valid_ts ?
+			ts : 0, resp->pin_id);
+	else if (resp->error_info.error)
+		dev_dbg(&adev->dev,
+			"hostlib: error resp %02d %s, stream %u, error %d, details %d, timestamp 0x%16.16llx, pin %d\n",
+			resp->type,
+			fw_msg[resp_type_to_index(resp->type)].msg,
+			resp->stream_handle,
+			resp->error_info.error, resp->error_info.error_details,
+			fw_msg[resp_type_to_index(resp->type)].valid_ts ?
+			ts : 0, resp->pin_id);
+	else
+		dev_dbg(&adev->dev,
+			"hostlib: resp %02d %s, stream %u, timestamp 0x%16.16llx, pin %d\n",
+			resp->type,
+			fw_msg[resp_type_to_index(resp->type)].msg,
+			resp->stream_handle,
+			fw_msg[resp_type_to_index(resp->type)].valid_ts ?
+			ts : 0, resp->pin_id);
+
+	if (resp->stream_handle >= IPU_ISYS_MAX_STREAMS) {
+		dev_err(&adev->dev, "bad stream handle %u\n",
+			resp->stream_handle);
+		goto leave;
+	}
+
+	pipe = isys->pipes[resp->stream_handle];
+	if (!pipe) {
+		dev_err(&adev->dev, "no pipeline for stream %u\n",
+			resp->stream_handle);
+		goto leave;
+	}
+	pipe->error = resp->error_info.error;
+
+	switch (resp->type) {
+	case IPU_FW_ISYS_RESP_TYPE_STREAM_OPEN_DONE:
+		complete(&pipe->stream_open_completion);
+		break;
+	case IPU_FW_ISYS_RESP_TYPE_STREAM_CLOSE_ACK:
+		complete(&pipe->stream_close_completion);
+		break;
+	case IPU_FW_ISYS_RESP_TYPE_STREAM_START_ACK:
+		complete(&pipe->stream_start_completion);
+		break;
+	case IPU_FW_ISYS_RESP_TYPE_STREAM_START_AND_CAPTURE_ACK:
+		complete(&pipe->stream_start_completion);
+		break;
+	case IPU_FW_ISYS_RESP_TYPE_STREAM_STOP_ACK:
+		complete(&pipe->stream_stop_completion);
+		break;
+	case IPU_FW_ISYS_RESP_TYPE_STREAM_FLUSH_ACK:
+		complete(&pipe->stream_stop_completion);
+		break;
+	case IPU_FW_ISYS_RESP_TYPE_PIN_DATA_READY:
+		/*
+		 * firmware only release the capture msg until software
+		 * get pin_data_ready event
+		 */
+		ipu_put_fw_mgs_buf(ipu_bus_get_drvdata(adev), resp->buf_id);
+		if (resp->pin_id < IPU_ISYS_OUTPUT_PINS &&
+		    pipe->output_pins[resp->pin_id].pin_ready)
+			pipe->output_pins[resp->pin_id].pin_ready(pipe, resp);
+		else
+			dev_err(&adev->dev,
+				"%d:No data pin ready handler for pin id %d\n",
+				resp->stream_handle, resp->pin_id);
+		if (pipe->csi2)
+			ipu_isys_csi2_error(pipe->csi2);
+
+		break;
+	case IPU_FW_ISYS_RESP_TYPE_STREAM_CAPTURE_ACK:
+		break;
+	case IPU_FW_ISYS_RESP_TYPE_STREAM_START_AND_CAPTURE_DONE:
+	case IPU_FW_ISYS_RESP_TYPE_STREAM_CAPTURE_DONE:
+		if (pipe->interlaced) {
+			struct ipu_isys_buffer *ib, *ib_safe;
+			struct list_head list;
+			unsigned long flags;
+			unsigned int *ts = resp->timestamp;
+
+			if (pipe->isys->short_packet_source ==
+			    IPU_ISYS_SHORT_PACKET_FROM_TUNIT)
+				pipe->cur_field =
+				    ipu_isys_csi2_get_current_field(pipe, ts);
+
+			/*
+			 * Move the pending buffers to a local temp list.
+			 * Then we do not need to handle the lock during
+			 * the loop.
+			 */
+			spin_lock_irqsave(&pipe->short_packet_queue_lock,
+					  flags);
+			list_cut_position(&list,
+					  &pipe->pending_interlaced_bufs,
+					  pipe->pending_interlaced_bufs.prev);
+			spin_unlock_irqrestore(&pipe->short_packet_queue_lock,
+					       flags);
+
+			list_for_each_entry_safe(ib, ib_safe, &list, head) {
+				struct vb2_buffer *vb;
+
+				vb = ipu_isys_buffer_to_vb2_buffer(ib);
+				to_vb2_v4l2_buffer(vb)->field = pipe->cur_field;
+				list_del(&ib->head);
+
+				ipu_isys_queue_buf_done(ib);
+			}
+		}
+		for (i = 0; i < IPU_NUM_CAPTURE_DONE; i++)
+			if (pipe->capture_done[i])
+				pipe->capture_done[i] (pipe, resp);
+
+		break;
+	case IPU_FW_ISYS_RESP_TYPE_FRAME_SOF:
+		if (pipe->csi2)
+			ipu_isys_csi2_sof_event(pipe->csi2, pipe->vc);
+
+		pipe->seq[pipe->seq_index].sequence =
+		    atomic_read(&pipe->sequence) - 1;
+		pipe->seq[pipe->seq_index].timestamp = ts;
+		dev_dbg(&adev->dev,
+			"sof: handle %d: (index %u), timestamp 0x%16.16llx\n",
+			resp->stream_handle,
+			pipe->seq[pipe->seq_index].sequence, ts);
+		pipe->seq_index = (pipe->seq_index + 1)
+		    % IPU_ISYS_MAX_PARALLEL_SOF;
+		break;
+	case IPU_FW_ISYS_RESP_TYPE_FRAME_EOF:
+		if (pipe->csi2)
+			ipu_isys_csi2_eof_event(pipe->csi2, pipe->vc);
+
+		dev_dbg(&adev->dev,
+			"eof: handle %d: (index %u), timestamp 0x%16.16llx\n",
+			resp->stream_handle,
+			pipe->seq[pipe->seq_index].sequence, ts);
+		break;
+	case IPU_FW_ISYS_RESP_TYPE_STATS_DATA_READY:
+		break;
+	default:
+		dev_err(&adev->dev, "%d:unknown response type %u\n",
+			resp->stream_handle, resp->type);
+		break;
+	}
+
+leave:
+	ipu_fw_isys_put_resp(isys->fwcom, IPU_BASE_MSG_RECV_QUEUES);
+	return 0;
+}
+
+static struct ipu_bus_driver isys_driver = {
+	.probe = isys_probe,
+	.remove = isys_remove,
+	.isr = isys_isr,
+	.wanted = IPU_ISYS_NAME,
+	.drv = {
+		.name = IPU_ISYS_NAME,
+		.owner = THIS_MODULE,
+		.pm = ISYS_PM_OPS,
+	},
+};
+
+module_ipu_bus_driver(isys_driver);
+
+static const struct pci_device_id ipu_pci_tbl[] = {
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, IPU6_PCI_ID)},
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, IPU6SE_PCI_ID)},
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, IPU6EP_ADL_P_PCI_ID)},
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, IPU6EP_ADL_N_PCI_ID)},
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, IPU6EP_RPL_P_PCI_ID)},
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, IPU6EP_MTL_PCI_ID)},
+	{0,}
+};
+MODULE_DEVICE_TABLE(pci, ipu_pci_tbl);
+
+MODULE_AUTHOR("Sakari Ailus <sakari.ailus@linux.intel.com>");
+MODULE_AUTHOR("Samu Onkalo <samu.onkalo@intel.com>");
+MODULE_AUTHOR("Jouni Hgander <jouni.hogander@intel.com>");
+MODULE_AUTHOR("Jouni Ukkonen <jouni.ukkonen@intel.com>");
+MODULE_AUTHOR("Jianxu Zheng <jian.xu.zheng@intel.com>");
+MODULE_AUTHOR("Tianshu Qiu <tian.shu.qiu@intel.com>");
+MODULE_AUTHOR("Renwei Wu <renwei.wu@intel.com>");
+MODULE_AUTHOR("Bingbu Cao <bingbu.cao@intel.com>");
+MODULE_AUTHOR("Yunliang Ding <yunliang.ding@intel.com>");
+MODULE_AUTHOR("Zaikuo Wang <zaikuo.wang@intel.com>");
+MODULE_AUTHOR("Leifu Zhao <leifu.zhao@intel.com>");
+MODULE_AUTHOR("Xia Wu <xia.wu@intel.com>");
+MODULE_AUTHOR("Kun Jiang <kun.jiang@intel.com>");
+MODULE_AUTHOR("Yu Xia <yu.y.xia@intel.com>");
+MODULE_AUTHOR("Jerry Hu <jerry.w.hu@intel.com>");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Intel ipu input system driver");
Index: b/drivers/media/pci/intel/ipu-isys.h
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu-isys.h
@@ -0,0 +1,195 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2013 - 2020 Intel Corporation */
+
+#ifndef IPU_ISYS_H
+#define IPU_ISYS_H
+
+#include <linux/pm_qos.h>
+#include <linux/spinlock.h>
+
+#include <media/v4l2-device.h>
+#include <media/media-device.h>
+
+#include <uapi/linux/ipu-isys.h>
+
+#include "ipu.h"
+#include "ipu-isys-media.h"
+#include "ipu-isys-csi2.h"
+#include "ipu-isys-csi2-be.h"
+#include "ipu-isys-video.h"
+#include "ipu-pdata.h"
+#include "ipu-fw-isys.h"
+#include "ipu-platform-isys.h"
+
+#define IPU_ISYS_2600_MEM_LINE_ALIGN	64
+
+/* for TPG */
+#define IPU_ISYS_FREQ		533000000UL
+
+/*
+ * Current message queue configuration. These must be big enough
+ * so that they never gets full. Queues are located in system memory
+ */
+#define IPU_ISYS_SIZE_RECV_QUEUE 40
+#define IPU_ISYS_SIZE_SEND_QUEUE 40
+#define IPU_ISYS_SIZE_PROXY_RECV_QUEUE 5
+#define IPU_ISYS_SIZE_PROXY_SEND_QUEUE 5
+#define IPU_ISYS_NUM_RECV_QUEUE 1
+
+/*
+ * Device close takes some time from last ack message to actual stopping
+ * of the SP processor. As long as the SP processor runs we can't proceed with
+ * clean up of resources.
+ */
+#define IPU_ISYS_OPEN_TIMEOUT_US		1000
+#define IPU_ISYS_OPEN_RETRY		1000
+#define IPU_ISYS_TURNOFF_DELAY_US		1000
+#define IPU_ISYS_TURNOFF_TIMEOUT		1000
+#define IPU_LIB_CALL_TIMEOUT_JIFFIES \
+	msecs_to_jiffies(IPU_LIB_CALL_TIMEOUT_MS)
+#define IPU_LIB_CALL_TIMEOUT_JIFFIES_RESET \
+	msecs_to_jiffies(200)
+
+#define IPU_ISYS_CSI2_LONG_PACKET_HEADER_SIZE	32
+#define IPU_ISYS_CSI2_LONG_PACKET_FOOTER_SIZE	32
+
+#define IPU_ISYS_MIN_WIDTH		1U
+#define IPU_ISYS_MIN_HEIGHT		1U
+#define IPU_ISYS_MAX_WIDTH		16384U
+#define IPU_ISYS_MAX_HEIGHT		16384U
+
+#define NR_OF_CSI2_BE_SOC_DEV 8
+
+struct task_struct;
+
+struct ipu_isys_sensor_info {
+	unsigned int vc1_data_start;
+	unsigned int vc1_data_end;
+	unsigned int vc0_data_start;
+	unsigned int vc0_data_end;
+	unsigned int vc1_pdaf_start;
+	unsigned int vc1_pdaf_end;
+	unsigned int sensor_metadata;
+};
+
+/*
+ * struct ipu_isys
+ *
+ * @media_dev: Media device
+ * @v4l2_dev: V4L2 device
+ * @adev: ISYS bus device
+ * @power: Is ISYS powered on or not?
+ * @isr_bits: Which bits does the ISR handle?
+ * @power_lock: Serialise access to power (power state in general)
+ * @csi2_rx_ctrl_cached: cached shared value between all CSI2 receivers
+ * @lock: serialise access to pipes
+ * @pipes: pipelines per stream ID
+ * @fwcom: fw communication layer private pointer
+ *         or optional external library private pointer
+ * @line_align: line alignment in memory
+ * @phy_termcal_val: the termination calibration value, only used for DWC PHY
+ * @reset_needed: Isys requires d0i0->i3 transition
+ * @video_opened: total number of opened file handles on video nodes
+ * @mutex: serialise access isys video open/release related operations
+ * @stream_mutex: serialise stream start and stop, queueing requests
+ * @lib_mutex: optional external library mutex
+ * @pdata: platform data pointer
+ * @csi2: CSI-2 receivers
+ * @csi2_be: CSI-2 back-ends
+ * @fw: ISYS firmware binary (unsecure firmware)
+ * @fw_sgt: fw scatterlist
+ * @pkg_dir: host pointer to pkg_dir
+ * @pkg_dir_dma_addr: I/O virtual address for pkg_dir
+ * @pkg_dir_size: size of pkg_dir in bytes
+ * @short_packet_source: select short packet capture mode
+ */
+struct ipu_isys {
+	struct media_device media_dev;
+	struct v4l2_device v4l2_dev;
+	struct ipu_bus_device *adev;
+
+	int power;
+	spinlock_t power_lock;	/* Serialise access to power */
+	u32 isr_csi2_bits;
+	u32 csi2_rx_ctrl_cached;
+	spinlock_t lock;	/* Serialise access to pipes */
+	struct ipu_isys_pipeline *pipes[IPU_ISYS_MAX_STREAMS];
+	void *fwcom;
+	unsigned int line_align;
+	u32 phy_termcal_val;
+	bool reset_needed;
+	bool icache_prefetch;
+	bool csi2_cse_ipc_not_supported;
+	unsigned int video_opened;
+	unsigned int stream_opened;
+	struct ipu_isys_sensor_info sensor_info;
+	unsigned int sensor_types[N_IPU_FW_ISYS_SENSOR_TYPE];
+
+#ifdef CONFIG_DEBUG_FS
+	struct dentry *debugfsdir;
+#endif
+	struct mutex mutex;	/* Serialise isys video open/release related */
+	struct mutex stream_mutex;	/* Stream start, stop, queueing reqs */
+	struct mutex lib_mutex;	/* Serialise optional external library mutex */
+
+	struct ipu_isys_pdata *pdata;
+
+	struct ipu_isys_csi2 *csi2;
+	struct ipu_isys_csi2_be csi2_be;
+	struct ipu_isys_csi2_be_soc csi2_be_soc[NR_OF_CSI2_BE_SOC_DEV];
+	const struct firmware *fw;
+	struct sg_table fw_sgt;
+
+	u64 *pkg_dir;
+	dma_addr_t pkg_dir_dma_addr;
+	unsigned int pkg_dir_size;
+
+	struct list_head requests;
+	struct pm_qos_request pm_qos;
+	unsigned int short_packet_source;
+	struct ipu_isys_csi2_monitor_message *short_packet_trace_buffer;
+	dma_addr_t short_packet_trace_buffer_dma_addr;
+	unsigned int short_packet_tracing_count;
+	struct mutex short_packet_tracing_mutex;	/* For tracing count */
+	u64 tsc_timer_base;
+	u64 tunit_timer_base;
+	spinlock_t listlock;	/* Protect framebuflist */
+	struct list_head framebuflist;
+	struct list_head framebuflist_fw;
+#if !IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA)
+	struct v4l2_async_notifier notifier;
+#endif
+
+	struct mutex reset_mutex;
+	bool in_reset;
+	bool in_stop_streaming;
+};
+
+struct isys_fw_msgs {
+	union {
+		u64 dummy;
+		struct ipu_fw_isys_frame_buff_set_abi frame;
+		struct ipu_fw_isys_stream_cfg_data_abi stream;
+	} fw_msg;
+	struct list_head head;
+	dma_addr_t dma_addr;
+};
+
+#define to_frame_msg_buf(a) (&(a)->fw_msg.frame)
+#define to_stream_cfg_msg_buf(a) (&(a)->fw_msg.stream)
+#define to_dma_addr(a) ((a)->dma_addr)
+
+struct isys_fw_msgs *ipu_get_fw_msg_buf(struct ipu_isys_pipeline *ip);
+void ipu_put_fw_mgs_buf(struct ipu_isys *isys, u64 data);
+void ipu_cleanup_fw_msg_bufs(struct ipu_isys *isys);
+
+extern const struct v4l2_ioctl_ops ipu_isys_ioctl_ops;
+
+void isys_setup_hw(struct ipu_isys *isys);
+int isys_isr_one(struct ipu_bus_device *adev);
+irqreturn_t isys_isr(struct ipu_bus_device *adev);
+#ifdef IPU_ISYS_GPC
+int ipu_isys_gpc_init_debugfs(struct ipu_isys *isys);
+#endif
+
+#endif /* IPU_ISYS_H */
Index: b/drivers/media/pci/intel/ipu-mmu.c
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu-mmu.c
@@ -0,0 +1,858 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) 2013 - 2021 Intel Corporation
+
+#include <asm/cacheflush.h>
+
+#include <linux/device.h>
+#include <linux/iova.h>
+#include <linux/module.h>
+#include <linux/sizes.h>
+
+#include "ipu.h"
+#include "ipu-platform.h"
+#include "ipu-dma.h"
+#include "ipu-mmu.h"
+#include "ipu-platform-regs.h"
+
+#define ISP_PAGE_SHIFT		12
+#define ISP_PAGE_SIZE		BIT(ISP_PAGE_SHIFT)
+#define ISP_PAGE_MASK		(~(ISP_PAGE_SIZE - 1))
+
+#define ISP_L1PT_SHIFT		22
+#define ISP_L1PT_MASK		(~((1U << ISP_L1PT_SHIFT) - 1))
+
+#define ISP_L2PT_SHIFT		12
+#define ISP_L2PT_MASK		(~(ISP_L1PT_MASK | (~(ISP_PAGE_MASK))))
+
+#define ISP_L1PT_PTES           1024
+#define ISP_L2PT_PTES           1024
+
+#define ISP_PADDR_SHIFT		12
+
+#define REG_TLB_INVALIDATE	0x0000
+
+#define REG_L1_PHYS		0x0004	/* 27-bit pfn */
+#define REG_INFO		0x0008
+
+/* The range of stream ID i in L1 cache is from 0 to 15 */
+#define MMUV2_REG_L1_STREAMID(i)	(0x0c + ((i) * 4))
+
+/* The range of stream ID i in L2 cache is from 0 to 15 */
+#define MMUV2_REG_L2_STREAMID(i)	(0x4c + ((i) * 4))
+
+#define TBL_PHYS_ADDR(a)	((phys_addr_t)(a) << ISP_PADDR_SHIFT)
+
+static void tlb_invalidate(struct ipu_mmu *mmu)
+{
+	unsigned int i;
+	unsigned long flags;
+
+	spin_lock_irqsave(&mmu->ready_lock, flags);
+	if (!mmu->ready) {
+		spin_unlock_irqrestore(&mmu->ready_lock, flags);
+		return;
+	}
+
+	for (i = 0; i < mmu->nr_mmus; i++) {
+		/*
+		 * To avoid the HW bug induced dead lock in some of the IPU
+		 * MMUs on successive invalidate calls, we need to first do a
+		 * read to the page table base before writing the invalidate
+		 * register. MMUs which need to implement this WA, will have
+		 * the insert_read_before_invalidate flags set as true.
+		 * Disregard the return value of the read.
+		 */
+		if (mmu->mmu_hw[i].insert_read_before_invalidate)
+			readl(mmu->mmu_hw[i].base + REG_L1_PHYS);
+
+		writel(0xffffffff, mmu->mmu_hw[i].base +
+		       REG_TLB_INVALIDATE);
+		/*
+		 * The TLB invalidation is a "single cycle" (IOMMU clock cycles)
+		 * When the actual MMIO write reaches the IPU TLB Invalidate
+		 * register, wmb() will force the TLB invalidate out if the CPU
+		 * attempts to update the IOMMU page table (or sooner).
+		 */
+		wmb();
+	}
+	spin_unlock_irqrestore(&mmu->ready_lock, flags);
+}
+
+#ifdef DEBUG
+static void page_table_dump(struct ipu_mmu_info *mmu_info)
+{
+	u32 l1_idx;
+
+	dev_dbg(mmu_info->dev, "begin IOMMU page table dump\n");
+
+	for (l1_idx = 0; l1_idx < ISP_L1PT_PTES; l1_idx++) {
+		u32 l2_idx;
+		u32 iova = (phys_addr_t)l1_idx << ISP_L1PT_SHIFT;
+
+		if (mmu_info->l1_pt[l1_idx] == mmu_info->dummy_l2_pteval)
+			continue;
+		dev_dbg(mmu_info->dev,
+			"l1 entry %u; iovas 0x%8.8x-0x%8.8x, at %p\n",
+			l1_idx, iova, iova + ISP_PAGE_SIZE,
+			(void *)TBL_PHYS_ADDR(mmu_info->l1_pt[l1_idx]));
+
+		for (l2_idx = 0; l2_idx < ISP_L2PT_PTES; l2_idx++) {
+			u32 *l2_pt = mmu_info->l2_pts[l1_idx];
+			u32 iova2 = iova + (l2_idx << ISP_L2PT_SHIFT);
+
+			if (l2_pt[l2_idx] == mmu_info->dummy_page_pteval)
+				continue;
+
+			dev_dbg(mmu_info->dev,
+				"\tl2 entry %u; iova 0x%8.8x, phys %p\n",
+				l2_idx, iova2,
+				(void *)TBL_PHYS_ADDR(l2_pt[l2_idx]));
+		}
+	}
+
+	dev_dbg(mmu_info->dev, "end IOMMU page table dump\n");
+}
+#endif /* DEBUG */
+
+static dma_addr_t map_single(struct ipu_mmu_info *mmu_info, void *ptr)
+{
+	dma_addr_t dma;
+
+	dma = dma_map_single(mmu_info->dev, ptr, PAGE_SIZE, DMA_BIDIRECTIONAL);
+	if (dma_mapping_error(mmu_info->dev, dma))
+		return 0;
+
+	return dma;
+}
+
+static int get_dummy_page(struct ipu_mmu_info *mmu_info)
+{
+	dma_addr_t dma;
+	void *pt = (void *)get_zeroed_page(GFP_ATOMIC | GFP_DMA32);
+
+	if (!pt)
+		return -ENOMEM;
+
+	dev_dbg(mmu_info->dev, "%s get_zeroed_page() == %p\n", __func__, pt);
+
+	dma = map_single(mmu_info, pt);
+	if (!dma) {
+		dev_err(mmu_info->dev, "Failed to map dummy page\n");
+		goto err_free_page;
+	}
+
+	mmu_info->dummy_page = pt;
+	mmu_info->dummy_page_pteval = dma >> ISP_PAGE_SHIFT;
+
+	return 0;
+
+err_free_page:
+	free_page((unsigned long)pt);
+	return -ENOMEM;
+}
+
+static void free_dummy_page(struct ipu_mmu_info *mmu_info)
+{
+	dma_unmap_single(mmu_info->dev,
+			 TBL_PHYS_ADDR(mmu_info->dummy_page_pteval),
+			 PAGE_SIZE, DMA_BIDIRECTIONAL);
+	free_page((unsigned long)mmu_info->dummy_page);
+}
+
+static int alloc_dummy_l2_pt(struct ipu_mmu_info *mmu_info)
+{
+	dma_addr_t dma;
+	u32 *pt = (u32 *)get_zeroed_page(GFP_ATOMIC | GFP_DMA32);
+	int i;
+
+	if (!pt)
+		return -ENOMEM;
+
+	dev_dbg(mmu_info->dev, "%s get_zeroed_page() == %p\n", __func__, pt);
+
+	dma = map_single(mmu_info, pt);
+	if (!dma) {
+		dev_err(mmu_info->dev, "Failed to map l2pt page\n");
+		goto err_free_page;
+	}
+
+	for (i = 0; i < ISP_L2PT_PTES; i++)
+		pt[i] = mmu_info->dummy_page_pteval;
+
+	mmu_info->dummy_l2_pt = pt;
+	mmu_info->dummy_l2_pteval = dma >> ISP_PAGE_SHIFT;
+
+	return 0;
+
+err_free_page:
+	free_page((unsigned long)pt);
+	return -ENOMEM;
+}
+
+static void free_dummy_l2_pt(struct ipu_mmu_info *mmu_info)
+{
+	dma_unmap_single(mmu_info->dev,
+			 TBL_PHYS_ADDR(mmu_info->dummy_l2_pteval),
+			 PAGE_SIZE, DMA_BIDIRECTIONAL);
+	free_page((unsigned long)mmu_info->dummy_l2_pt);
+}
+
+static u32 *alloc_l1_pt(struct ipu_mmu_info *mmu_info)
+{
+	dma_addr_t dma;
+	u32 *pt = (u32 *)get_zeroed_page(GFP_ATOMIC | GFP_DMA32);
+	int i;
+
+	if (!pt)
+		return NULL;
+
+	dev_dbg(mmu_info->dev, "%s get_zeroed_page() == %p\n", __func__, pt);
+
+	for (i = 0; i < ISP_L1PT_PTES; i++)
+		pt[i] = mmu_info->dummy_l2_pteval;
+
+	dma = map_single(mmu_info, pt);
+	if (!dma) {
+		dev_err(mmu_info->dev, "Failed to map l1pt page\n");
+		goto err_free_page;
+	}
+
+	mmu_info->l1_pt_dma = dma >> ISP_PADDR_SHIFT;
+	dev_dbg(mmu_info->dev, "l1 pt %p mapped at %llx\n", pt, dma);
+
+	return pt;
+
+err_free_page:
+	free_page((unsigned long)pt);
+	return NULL;
+}
+
+static u32 *alloc_l2_pt(struct ipu_mmu_info *mmu_info)
+{
+	u32 *pt = (u32 *)get_zeroed_page(GFP_ATOMIC | GFP_DMA32);
+	int i;
+
+	if (!pt)
+		return NULL;
+
+	dev_dbg(mmu_info->dev, "%s get_zeroed_page() == %p\n", __func__, pt);
+
+	for (i = 0; i < ISP_L1PT_PTES; i++)
+		pt[i] = mmu_info->dummy_page_pteval;
+
+	return pt;
+}
+
+static int l2_map(struct ipu_mmu_info *mmu_info, unsigned long iova,
+		  phys_addr_t paddr, size_t size)
+{
+	u32 l1_idx = iova >> ISP_L1PT_SHIFT;
+	u32 l1_entry;
+	u32 *l2_pt, *l2_virt;
+	u32 iova_start = iova;
+	unsigned int l2_idx;
+	unsigned long flags;
+	dma_addr_t dma;
+
+	dev_dbg(mmu_info->dev,
+		"mapping l2 page table for l1 index %u (iova %8.8x)\n",
+		l1_idx, (u32)iova);
+
+	spin_lock_irqsave(&mmu_info->lock, flags);
+	l1_entry = mmu_info->l1_pt[l1_idx];
+	if (l1_entry == mmu_info->dummy_l2_pteval) {
+		l2_virt = mmu_info->l2_pts[l1_idx];
+		if (likely(!l2_virt)) {
+			l2_virt = alloc_l2_pt(mmu_info);
+			if (!l2_virt) {
+				spin_unlock_irqrestore(&mmu_info->lock, flags);
+				return -ENOMEM;
+			}
+		}
+
+		dma = map_single(mmu_info, l2_virt);
+		if (!dma) {
+			dev_err(mmu_info->dev, "Failed to map l2pt page\n");
+			free_page((unsigned long)l2_virt);
+			spin_unlock_irqrestore(&mmu_info->lock, flags);
+			return -EINVAL;
+		}
+
+		l1_entry = dma >> ISP_PADDR_SHIFT;
+
+		dev_dbg(mmu_info->dev, "page for l1_idx %u %p allocated\n",
+			l1_idx, l2_virt);
+		mmu_info->l1_pt[l1_idx] = l1_entry;
+		mmu_info->l2_pts[l1_idx] = l2_virt;
+		clflush_cache_range(&mmu_info->l1_pt[l1_idx],
+				    sizeof(mmu_info->l1_pt[l1_idx]));
+	}
+
+	l2_pt = mmu_info->l2_pts[l1_idx];
+
+	dev_dbg(mmu_info->dev, "l2_pt at %p with dma 0x%x\n", l2_pt, l1_entry);
+
+	paddr = ALIGN(paddr, ISP_PAGE_SIZE);
+
+	l2_idx = (iova_start & ISP_L2PT_MASK) >> ISP_L2PT_SHIFT;
+
+	dev_dbg(mmu_info->dev, "l2_idx %u, phys 0x%8.8x\n", l2_idx,
+		l2_pt[l2_idx]);
+	if (l2_pt[l2_idx] != mmu_info->dummy_page_pteval) {
+		spin_unlock_irqrestore(&mmu_info->lock, flags);
+		return -EINVAL;
+	}
+
+	l2_pt[l2_idx] = paddr >> ISP_PADDR_SHIFT;
+
+	clflush_cache_range(&l2_pt[l2_idx], sizeof(l2_pt[l2_idx]));
+	spin_unlock_irqrestore(&mmu_info->lock, flags);
+
+	dev_dbg(mmu_info->dev, "l2 index %u mapped as 0x%8.8x\n", l2_idx,
+		l2_pt[l2_idx]);
+
+	return 0;
+}
+
+static int __ipu_mmu_map(struct ipu_mmu_info *mmu_info, unsigned long iova,
+			 phys_addr_t paddr, size_t size)
+{
+	u32 iova_start = round_down(iova, ISP_PAGE_SIZE);
+	u32 iova_end = ALIGN(iova + size, ISP_PAGE_SIZE);
+
+	dev_dbg(mmu_info->dev,
+		"mapping iova 0x%8.8x--0x%8.8x, size %zu at paddr 0x%10.10llx\n",
+		iova_start, iova_end, size, paddr);
+
+	return l2_map(mmu_info, iova_start, paddr, size);
+}
+
+static size_t l2_unmap(struct ipu_mmu_info *mmu_info, unsigned long iova,
+		       phys_addr_t dummy, size_t size)
+{
+	u32 l1_idx = iova >> ISP_L1PT_SHIFT;
+	u32 *l2_pt;
+	u32 iova_start = iova;
+	unsigned int l2_idx;
+	size_t unmapped = 0;
+	unsigned long flags;
+
+	dev_dbg(mmu_info->dev, "unmapping l2 page table for l1 index %u (iova 0x%8.8lx)\n",
+		l1_idx, iova);
+
+	spin_lock_irqsave(&mmu_info->lock, flags);
+	if (mmu_info->l1_pt[l1_idx] == mmu_info->dummy_l2_pteval) {
+		spin_unlock_irqrestore(&mmu_info->lock, flags);
+		dev_err(mmu_info->dev,
+			"unmap iova 0x%8.8lx l1 idx %u which was not mapped\n",
+			iova, l1_idx);
+		return 0;
+	}
+
+	for (l2_idx = (iova_start & ISP_L2PT_MASK) >> ISP_L2PT_SHIFT;
+	     (iova_start & ISP_L1PT_MASK) + (l2_idx << ISP_PAGE_SHIFT)
+	     < iova_start + size && l2_idx < ISP_L2PT_PTES; l2_idx++) {
+		l2_pt = mmu_info->l2_pts[l1_idx];
+		dev_dbg(mmu_info->dev,
+			"unmap l2 index %u with pteval 0x%10.10llx\n",
+			l2_idx, TBL_PHYS_ADDR(l2_pt[l2_idx]));
+		l2_pt[l2_idx] = mmu_info->dummy_page_pteval;
+
+		clflush_cache_range(&l2_pt[l2_idx], sizeof(l2_pt[l2_idx]));
+		unmapped++;
+	}
+	spin_unlock_irqrestore(&mmu_info->lock, flags);
+
+	return unmapped << ISP_PAGE_SHIFT;
+}
+
+static size_t __ipu_mmu_unmap(struct ipu_mmu_info *mmu_info,
+			      unsigned long iova, size_t size)
+{
+	return l2_unmap(mmu_info, iova, 0, size);
+}
+
+static int allocate_trash_buffer(struct ipu_mmu *mmu)
+{
+	unsigned int n_pages = PAGE_ALIGN(IPU_MMUV2_TRASH_RANGE) >> PAGE_SHIFT;
+	struct iova *iova;
+	u32 iova_addr;
+	unsigned int i;
+	dma_addr_t dma;
+	int ret;
+
+	/* Allocate 8MB in iova range */
+	iova = alloc_iova(&mmu->dmap->iovad, n_pages,
+			  mmu->dmap->mmu_info->aperture_end >> PAGE_SHIFT, 0);
+	if (!iova) {
+		dev_err(mmu->dev, "cannot allocate iova range for trash\n");
+		return -ENOMEM;
+	}
+
+	dma = dma_map_page(mmu->dmap->mmu_info->dev, mmu->trash_page, 0,
+			   PAGE_SIZE, DMA_BIDIRECTIONAL);
+	if (dma_mapping_error(mmu->dmap->mmu_info->dev, dma)) {
+		dev_err(mmu->dmap->mmu_info->dev, "Failed to map trash page\n");
+		ret = -ENOMEM;
+		goto out_free_iova;
+	}
+
+	mmu->pci_trash_page = dma;
+
+	/*
+	 * Map the 8MB iova address range to the same physical trash page
+	 * mmu->trash_page which is already reserved at the probe
+	 */
+	iova_addr = iova->pfn_lo;
+	for (i = 0; i < n_pages; i++) {
+		ret = ipu_mmu_map(mmu->dmap->mmu_info, iova_addr << PAGE_SHIFT,
+				  mmu->pci_trash_page, PAGE_SIZE);
+		if (ret) {
+			dev_err(mmu->dev,
+				"mapping trash buffer range failed\n");
+			goto out_unmap;
+		}
+
+		iova_addr++;
+	}
+
+	mmu->iova_trash_page = iova->pfn_lo << PAGE_SHIFT;
+	dev_dbg(mmu->dev, "iova trash buffer for MMUID: %d is %u\n",
+		mmu->mmid, (unsigned int)mmu->iova_trash_page);
+	return 0;
+
+out_unmap:
+	ipu_mmu_unmap(mmu->dmap->mmu_info, iova->pfn_lo << PAGE_SHIFT,
+		      (iova->pfn_hi - iova->pfn_lo + 1) << PAGE_SHIFT);
+	dma_unmap_page(mmu->dmap->mmu_info->dev, mmu->pci_trash_page,
+		       PAGE_SIZE, DMA_BIDIRECTIONAL);
+out_free_iova:
+	__free_iova(&mmu->dmap->iovad, iova);
+	return ret;
+}
+
+int ipu_mmu_hw_init(struct ipu_mmu *mmu)
+{
+	unsigned int i;
+	unsigned long flags;
+	struct ipu_mmu_info *mmu_info;
+
+	dev_dbg(mmu->dev, "mmu hw init\n");
+
+	mmu_info = mmu->dmap->mmu_info;
+
+	/* Initialise the each MMU HW block */
+	for (i = 0; i < mmu->nr_mmus; i++) {
+		struct ipu_mmu_hw *mmu_hw = &mmu->mmu_hw[i];
+		unsigned int j;
+		u16 block_addr;
+
+		/* Write page table address per MMU */
+		writel((phys_addr_t)mmu_info->l1_pt_dma,
+		       mmu->mmu_hw[i].base + REG_L1_PHYS);
+
+		/* Set info bits per MMU */
+		writel(mmu->mmu_hw[i].info_bits,
+		       mmu->mmu_hw[i].base + REG_INFO);
+
+		/* Configure MMU TLB stream configuration for L1 */
+		for (j = 0, block_addr = 0; j < mmu_hw->nr_l1streams;
+		     block_addr += mmu->mmu_hw[i].l1_block_sz[j], j++) {
+			if (block_addr > IPU_MAX_LI_BLOCK_ADDR) {
+				dev_err(mmu->dev, "invalid L1 configuration\n");
+				return -EINVAL;
+			}
+
+			/* Write block start address for each streams */
+			writel(block_addr, mmu_hw->base +
+				   mmu_hw->l1_stream_id_reg_offset + 4 * j);
+		}
+
+		/* Configure MMU TLB stream configuration for L2 */
+		for (j = 0, block_addr = 0; j < mmu_hw->nr_l2streams;
+		     block_addr += mmu->mmu_hw[i].l2_block_sz[j], j++) {
+			if (block_addr > IPU_MAX_L2_BLOCK_ADDR) {
+				dev_err(mmu->dev, "invalid L2 configuration\n");
+				return -EINVAL;
+			}
+
+			writel(block_addr, mmu_hw->base +
+				   mmu_hw->l2_stream_id_reg_offset + 4 * j);
+		}
+	}
+
+	if (!mmu->trash_page) {
+		int ret;
+
+		mmu->trash_page = alloc_page(GFP_KERNEL);
+		if (!mmu->trash_page) {
+			dev_err(mmu->dev, "insufficient memory for trash buffer\n");
+			return -ENOMEM;
+		}
+
+		ret = allocate_trash_buffer(mmu);
+		if (ret) {
+			__free_page(mmu->trash_page);
+			mmu->trash_page = NULL;
+			dev_err(mmu->dev, "trash buffer allocation failed\n");
+			return ret;
+		}
+	}
+
+	spin_lock_irqsave(&mmu->ready_lock, flags);
+	mmu->ready = true;
+	spin_unlock_irqrestore(&mmu->ready_lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_mmu_hw_init);
+
+static struct ipu_mmu_info *ipu_mmu_alloc(struct ipu_device *isp)
+{
+	struct ipu_mmu_info *mmu_info;
+	int ret;
+
+	mmu_info = kzalloc(sizeof(*mmu_info), GFP_KERNEL);
+	if (!mmu_info)
+		return NULL;
+
+	mmu_info->aperture_start = 0;
+	mmu_info->aperture_end = DMA_BIT_MASK(isp->secure_mode ?
+					      IPU_MMU_ADDRESS_BITS :
+					      IPU_MMU_ADDRESS_BITS_NON_SECURE);
+	mmu_info->pgsize_bitmap = SZ_4K;
+	mmu_info->dev = &isp->pdev->dev;
+
+	ret = get_dummy_page(mmu_info);
+	if (ret)
+		goto err_free_info;
+
+	ret = alloc_dummy_l2_pt(mmu_info);
+	if (ret)
+		goto err_free_dummy_page;
+
+	mmu_info->l2_pts = vzalloc(ISP_L2PT_PTES * sizeof(*mmu_info->l2_pts));
+	if (!mmu_info->l2_pts)
+		goto err_free_dummy_l2_pt;
+
+	/*
+	 * We always map the L1 page table (a single page as well as
+	 * the L2 page tables).
+	 */
+	mmu_info->l1_pt = alloc_l1_pt(mmu_info);
+	if (!mmu_info->l1_pt)
+		goto err_free_l2_pts;
+
+	spin_lock_init(&mmu_info->lock);
+
+	dev_dbg(mmu_info->dev, "domain initialised\n");
+
+	return mmu_info;
+
+err_free_l2_pts:
+	vfree(mmu_info->l2_pts);
+err_free_dummy_l2_pt:
+	free_dummy_l2_pt(mmu_info);
+err_free_dummy_page:
+	free_dummy_page(mmu_info);
+err_free_info:
+	kfree(mmu_info);
+
+	return NULL;
+}
+
+int ipu_mmu_hw_cleanup(struct ipu_mmu *mmu)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&mmu->ready_lock, flags);
+	mmu->ready = false;
+	spin_unlock_irqrestore(&mmu->ready_lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_mmu_hw_cleanup);
+
+static struct ipu_dma_mapping *alloc_dma_mapping(struct ipu_device *isp)
+{
+	struct ipu_dma_mapping *dmap;
+
+	dmap = kzalloc(sizeof(*dmap), GFP_KERNEL);
+	if (!dmap)
+		return NULL;
+
+	dmap->mmu_info = ipu_mmu_alloc(isp);
+	if (!dmap->mmu_info) {
+		kfree(dmap);
+		return NULL;
+	}
+	init_iova_domain(&dmap->iovad, SZ_4K, 1);
+	dmap->mmu_info->dmap = dmap;
+
+	kref_init(&dmap->ref);
+
+	dev_dbg(&isp->pdev->dev, "alloc mapping\n");
+
+	iova_cache_get();
+
+	return dmap;
+}
+
+phys_addr_t ipu_mmu_iova_to_phys(struct ipu_mmu_info *mmu_info,
+				 dma_addr_t iova)
+{
+	unsigned long flags;
+	u32 *l2_pt;
+	phys_addr_t phy_addr;
+
+	spin_lock_irqsave(&mmu_info->lock, flags);
+	l2_pt = mmu_info->l2_pts[iova >> ISP_L1PT_SHIFT];
+	phy_addr = (phys_addr_t)l2_pt[(iova & ISP_L2PT_MASK) >> ISP_L2PT_SHIFT];
+	phy_addr <<= ISP_PAGE_SHIFT;
+	spin_unlock_irqrestore(&mmu_info->lock, flags);
+
+	return phy_addr;
+}
+
+/*
+ * The following four functions are implemented based on iommu.c
+ * drivers/iommu/iommu.c:iommu_pgsize().
+ */
+static size_t ipu_mmu_pgsize(unsigned long pgsize_bitmap,
+			     unsigned long addr_merge, size_t size)
+{
+	unsigned int pgsize_idx;
+	size_t pgsize;
+
+	/* Max page size that still fits into 'size' */
+	pgsize_idx = __fls(size);
+
+	/* need to consider alignment requirements ? */
+	if (likely(addr_merge)) {
+		/* Max page size allowed by address */
+		unsigned int align_pgsize_idx = __ffs(addr_merge);
+
+		pgsize_idx = min(pgsize_idx, align_pgsize_idx);
+	}
+
+	/* build a mask of acceptable page sizes */
+	pgsize = (1UL << (pgsize_idx + 1)) - 1;
+
+	/* throw away page sizes not supported by the hardware */
+	pgsize &= pgsize_bitmap;
+
+	/* make sure we're still sane */
+	WARN_ON(!pgsize);
+
+	/* pick the biggest page */
+	pgsize_idx = __fls(pgsize);
+	pgsize = 1UL << pgsize_idx;
+
+	return pgsize;
+}
+
+/* drivers/iommu/iommu.c:iommu_unmap() */
+size_t ipu_mmu_unmap(struct ipu_mmu_info *mmu_info, unsigned long iova,
+		     size_t size)
+{
+	size_t unmapped_page, unmapped = 0;
+	unsigned int min_pagesz;
+
+	/* find out the minimum page size supported */
+	min_pagesz = 1 << __ffs(mmu_info->pgsize_bitmap);
+
+	/*
+	 * The virtual address, as well as the size of the mapping, must be
+	 * aligned (at least) to the size of the smallest page supported
+	 * by the hardware
+	 */
+	if (!IS_ALIGNED(iova | size, min_pagesz)) {
+		dev_err(NULL, "unaligned: iova 0x%lx size 0x%zx min_pagesz 0x%x\n",
+			iova, size, min_pagesz);
+		return -EINVAL;
+	}
+
+	/*
+	 * Keep iterating until we either unmap 'size' bytes (or more)
+	 * or we hit an area that isn't mapped.
+	 */
+	while (unmapped < size) {
+		size_t pgsize = ipu_mmu_pgsize(mmu_info->pgsize_bitmap,
+						iova, size - unmapped);
+
+		unmapped_page = __ipu_mmu_unmap(mmu_info, iova, pgsize);
+		if (!unmapped_page)
+			break;
+
+		dev_dbg(mmu_info->dev, "unmapped: iova 0x%lx size 0x%zx\n",
+			iova, unmapped_page);
+
+		iova += unmapped_page;
+		unmapped += unmapped_page;
+	}
+
+	return unmapped;
+}
+
+/* drivers/iommu/iommu.c:iommu_map() */
+int ipu_mmu_map(struct ipu_mmu_info *mmu_info, unsigned long iova,
+		phys_addr_t paddr, size_t size)
+{
+	unsigned long orig_iova = iova;
+	unsigned int min_pagesz;
+	size_t orig_size = size;
+	int ret = 0;
+
+	if (mmu_info->pgsize_bitmap == 0UL)
+		return -ENODEV;
+
+	/* find out the minimum page size supported */
+	min_pagesz = 1 << __ffs(mmu_info->pgsize_bitmap);
+
+	/*
+	 * both the virtual address and the physical one, as well as
+	 * the size of the mapping, must be aligned (at least) to the
+	 * size of the smallest page supported by the hardware
+	 */
+	if (!IS_ALIGNED(iova | paddr | size, min_pagesz)) {
+		dev_err(mmu_info->dev,
+			"unaligned: iova 0x%lx pa %pa size 0x%zx min_pagesz 0x%x\n",
+			iova, &paddr, size, min_pagesz);
+		return -EINVAL;
+	}
+
+	dev_dbg(mmu_info->dev, "map: iova 0x%lx pa %pa size 0x%zx\n",
+		iova, &paddr, size);
+
+	while (size) {
+		size_t pgsize = ipu_mmu_pgsize(mmu_info->pgsize_bitmap,
+					       iova | paddr, size);
+
+		dev_dbg(mmu_info->dev,
+			"mapping: iova 0x%lx pa %pa pgsize 0x%zx\n",
+			iova, &paddr, pgsize);
+
+		ret = __ipu_mmu_map(mmu_info, iova, paddr, pgsize);
+		if (ret)
+			break;
+
+		iova += pgsize;
+		paddr += pgsize;
+		size -= pgsize;
+	}
+
+	/* unroll mapping in case something went wrong */
+	if (ret)
+		ipu_mmu_unmap(mmu_info, orig_iova, orig_size - size);
+
+	return ret;
+}
+
+static void ipu_mmu_destroy(struct ipu_mmu *mmu)
+{
+	struct ipu_dma_mapping *dmap = mmu->dmap;
+	struct ipu_mmu_info *mmu_info = dmap->mmu_info;
+	struct iova *iova;
+	u32 l1_idx;
+
+	if (mmu->iova_trash_page) {
+		iova = find_iova(&dmap->iovad,
+				 mmu->iova_trash_page >> PAGE_SHIFT);
+		if (iova) {
+			/* unmap and free the trash buffer iova */
+			ipu_mmu_unmap(mmu_info, iova->pfn_lo << PAGE_SHIFT,
+				      (iova->pfn_hi - iova->pfn_lo + 1) <<
+				      PAGE_SHIFT);
+			__free_iova(&dmap->iovad, iova);
+		} else {
+			dev_err(mmu->dev, "trash buffer iova not found.\n");
+		}
+
+		mmu->iova_trash_page = 0;
+		dma_unmap_page(mmu_info->dev, mmu->pci_trash_page,
+			       PAGE_SIZE, DMA_BIDIRECTIONAL);
+		mmu->pci_trash_page = 0;
+		__free_page(mmu->trash_page);
+	}
+
+	for (l1_idx = 0; l1_idx < ISP_L1PT_PTES; l1_idx++) {
+		if (mmu_info->l1_pt[l1_idx] != mmu_info->dummy_l2_pteval) {
+			dma_unmap_single(mmu_info->dev,
+					 TBL_PHYS_ADDR(mmu_info->l1_pt[l1_idx]),
+					 PAGE_SIZE, DMA_BIDIRECTIONAL);
+			free_page((unsigned long)mmu_info->l2_pts[l1_idx]);
+		}
+	}
+
+	free_dummy_page(mmu_info);
+	dma_unmap_single(mmu_info->dev, mmu_info->l1_pt_dma << ISP_PADDR_SHIFT,
+			 PAGE_SIZE, DMA_BIDIRECTIONAL);
+	free_page((unsigned long)mmu_info->dummy_l2_pt);
+	free_page((unsigned long)mmu_info->l1_pt);
+	kfree(mmu_info);
+}
+
+struct ipu_mmu *ipu_mmu_init(struct device *dev,
+			     void __iomem *base, int mmid,
+			     const struct ipu_hw_variants *hw)
+{
+	struct ipu_mmu *mmu;
+	struct ipu_mmu_pdata *pdata;
+	struct ipu_device *isp = pci_get_drvdata(to_pci_dev(dev));
+	unsigned int i;
+
+	if (hw->nr_mmus > IPU_MMU_MAX_DEVICES)
+		return ERR_PTR(-EINVAL);
+
+	pdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);
+	if (!pdata)
+		return ERR_PTR(-ENOMEM);
+
+	for (i = 0; i < hw->nr_mmus; i++) {
+		struct ipu_mmu_hw *pdata_mmu = &pdata->mmu_hw[i];
+		const struct ipu_mmu_hw *src_mmu = &hw->mmu_hw[i];
+
+		if (src_mmu->nr_l1streams > IPU_MMU_MAX_TLB_L1_STREAMS ||
+		    src_mmu->nr_l2streams > IPU_MMU_MAX_TLB_L2_STREAMS)
+			return ERR_PTR(-EINVAL);
+
+		*pdata_mmu = *src_mmu;
+		pdata_mmu->base = base + src_mmu->offset;
+	}
+
+	mmu = devm_kzalloc(dev, sizeof(*mmu), GFP_KERNEL);
+	if (!mmu)
+		return ERR_PTR(-ENOMEM);
+
+	mmu->mmid = mmid;
+	mmu->mmu_hw = pdata->mmu_hw;
+	mmu->nr_mmus = hw->nr_mmus;
+	mmu->tlb_invalidate = tlb_invalidate;
+	mmu->ready = false;
+	INIT_LIST_HEAD(&mmu->vma_list);
+	spin_lock_init(&mmu->ready_lock);
+
+	mmu->dmap = alloc_dma_mapping(isp);
+	if (!mmu->dmap) {
+		dev_err(dev, "can't alloc dma mapping\n");
+		return ERR_PTR(-ENOMEM);
+	}
+
+	return mmu;
+}
+
+void ipu_mmu_cleanup(struct ipu_mmu *mmu)
+{
+	struct ipu_dma_mapping *dmap = mmu->dmap;
+
+	ipu_mmu_destroy(mmu);
+	mmu->dmap = NULL;
+	iova_cache_put();
+	put_iova_domain(&dmap->iovad);
+	kfree(dmap);
+}
+
+MODULE_AUTHOR("Sakari Ailus <sakari.ailus@linux.intel.com>");
+MODULE_AUTHOR("Samu Onkalo <samu.onkalo@intel.com>");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Intel ipu mmu driver");
Index: b/drivers/media/pci/intel/ipu-mmu.h
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu-mmu.h
@@ -0,0 +1,76 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2013 - 2021 Intel Corporation */
+
+#ifndef IPU_MMU_H
+#define IPU_MMU_H
+
+#include <linux/dma-mapping.h>
+
+#include "ipu.h"
+#include "ipu-pdata.h"
+
+#define ISYS_MMID 1
+#define PSYS_MMID 0
+
+/*
+ * @pgtbl: virtual address of the l1 page table (one page)
+ */
+struct ipu_mmu_info {
+	struct device *dev;
+
+	u32 __iomem *l1_pt;
+	u32 l1_pt_dma;
+	u32 **l2_pts;
+
+	u32 *dummy_l2_pt;
+	u32 dummy_l2_pteval;
+	void *dummy_page;
+	u32 dummy_page_pteval;
+
+	dma_addr_t aperture_start;
+	dma_addr_t aperture_end;
+	unsigned long pgsize_bitmap;
+
+	spinlock_t lock;	/* Serialize access to users */
+	struct ipu_dma_mapping *dmap;
+};
+
+/*
+ * @pgtbl: physical address of the l1 page table
+ */
+struct ipu_mmu {
+	struct list_head node;
+
+	struct ipu_mmu_hw *mmu_hw;
+	unsigned int nr_mmus;
+	int mmid;
+
+	phys_addr_t pgtbl;
+	struct device *dev;
+
+	struct ipu_dma_mapping *dmap;
+	struct list_head vma_list;
+
+	struct page *trash_page;
+	dma_addr_t pci_trash_page; /* IOVA from PCI DMA services (parent) */
+	dma_addr_t iova_trash_page; /* IOVA for IPU child nodes to use */
+
+	bool ready;
+	spinlock_t ready_lock;	/* Serialize access to bool ready */
+
+	void (*tlb_invalidate)(struct ipu_mmu *mmu);
+};
+
+struct ipu_mmu *ipu_mmu_init(struct device *dev,
+			     void __iomem *base, int mmid,
+			     const struct ipu_hw_variants *hw);
+void ipu_mmu_cleanup(struct ipu_mmu *mmu);
+int ipu_mmu_hw_init(struct ipu_mmu *mmu);
+int ipu_mmu_hw_cleanup(struct ipu_mmu *mmu);
+int ipu_mmu_map(struct ipu_mmu_info *mmu_info, unsigned long iova,
+		phys_addr_t paddr, size_t size);
+size_t ipu_mmu_unmap(struct ipu_mmu_info *mmu_info, unsigned long iova,
+		     size_t size);
+phys_addr_t ipu_mmu_iova_to_phys(struct ipu_mmu_info *mmu_info,
+				 dma_addr_t iova);
+#endif
Index: b/drivers/media/pci/intel/ipu-pdata.h
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu-pdata.h
@@ -0,0 +1,245 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2013 - 2021 Intel Corporation */
+
+#ifndef IPU_PDATA_H
+#define IPU_PDATA_H
+
+#define IPU_MMU_NAME IPU_NAME "-mmu"
+#define IPU_ISYS_CSI2_NAME IPU_NAME "-csi2"
+#define IPU_ISYS_NAME IPU_NAME "-isys"
+#define IPU_PSYS_NAME IPU_NAME "-psys"
+#define IPU_BUTTRESS_NAME IPU_NAME "-buttress"
+
+#define IPU_MMU_MAX_DEVICES		4
+#define IPU_MMU_ADDRESS_BITS		32
+/* The firmware is accessible within the first 2 GiB only in non-secure mode. */
+#define IPU_MMU_ADDRESS_BITS_NON_SECURE	31
+
+#define IPU_MMU_MAX_TLB_L1_STREAMS	32
+#define IPU_MMU_MAX_TLB_L2_STREAMS	32
+#define IPU_MAX_LI_BLOCK_ADDR		128
+#define IPU_MAX_L2_BLOCK_ADDR		64
+
+#define IPU_ISYS_MAX_CSI2_LEGACY_PORTS	4
+#define IPU_ISYS_MAX_CSI2_COMBO_PORTS	2
+
+#define IPU_MAX_FRAME_COUNTER	0xff
+
+/*
+ * To maximize the IOSF utlization, IPU need to send requests in bursts.
+ * At the DMA interface with the buttress, there are CDC FIFOs with burst
+ * collection capability. CDC FIFO burst collectors have a configurable
+ * threshold and is configured based on the outcome of performance measurements.
+ *
+ * isys has 3 ports with IOSF interface for VC0, VC1 and VC2
+ * psys has 4 ports with IOSF interface for VC0, VC1w, VC1r and VC2
+ *
+ * Threshold values are pre-defined and are arrived at after performance
+ * evaluations on a type of IPU
+ */
+#define IPU_MAX_VC_IOSF_PORTS		4
+
+/*
+ * IPU must configure correct arbitration mechanism related to the IOSF VC
+ * requests. There are two options per VC0 and VC1 - > 0 means rearbitrate on
+ * stall and 1 means stall until the request is completed.
+ */
+#define IPU_BTRS_ARB_MODE_TYPE_REARB	0
+#define IPU_BTRS_ARB_MODE_TYPE_STALL	1
+
+/* Currently chosen arbitration mechanism for VC0 */
+#define IPU_BTRS_ARB_STALL_MODE_VC0	\
+			IPU_BTRS_ARB_MODE_TYPE_REARB
+
+/* Currently chosen arbitration mechanism for VC1 */
+#define IPU_BTRS_ARB_STALL_MODE_VC1	\
+			IPU_BTRS_ARB_MODE_TYPE_REARB
+
+struct ipu_isys_subdev_pdata;
+
+/*
+ * MMU Invalidation HW bug workaround by ZLW mechanism
+ *
+ * Old IPU MMUV2 has a bug in the invalidation mechanism which might result in
+ * wrong translation or replication of the translation. This will cause data
+ * corruption. So we cannot directly use the MMU V2 invalidation registers
+ * to invalidate the MMU. Instead, whenever an invalidate is called, we need to
+ * clear the TLB by evicting all the valid translations by filling it with trash
+ * buffer (which is guaranteed not to be used by any other processes). ZLW is
+ * used to fill the L1 and L2 caches with the trash buffer translations. ZLW
+ * or Zero length write, is pre-fetch mechanism to pre-fetch the pages in
+ * advance to the L1 and L2 caches without triggering any memory operations.
+ *
+ * In MMU V2, L1 -> 16 streams and 64 blocks, maximum 16 blocks per stream
+ * One L1 block has 16 entries, hence points to 16 * 4K pages
+ * L2 -> 16 streams and 32 blocks. 2 blocks per streams
+ * One L2 block maps to 1024 L1 entries, hence points to 4MB address range
+ * 2 blocks per L2 stream means, 1 stream points to 8MB range
+ *
+ * As we need to clear the caches and 8MB being the biggest cache size, we need
+ * to have trash buffer which points to 8MB address range. As these trash
+ * buffers are not used for any memory transactions, we need only the least
+ * amount of physical memory. So we reserve 8MB IOVA address range but only
+ * one page is reserved from physical memory. Each of this 8MB IOVA address
+ * range is then mapped to the same physical memory page.
+ */
+/* One L2 entry maps 1024 L1 entries and one L1 entry per page */
+#define IPU_MMUV2_L2_RANGE		(1024 * PAGE_SIZE)
+/* Max L2 blocks per stream */
+#define IPU_MMUV2_MAX_L2_BLOCKS		2
+/* Max L1 blocks per stream */
+#define IPU_MMUV2_MAX_L1_BLOCKS		16
+#define IPU_MMUV2_TRASH_RANGE		(IPU_MMUV2_L2_RANGE * \
+						 IPU_MMUV2_MAX_L2_BLOCKS)
+/* Entries per L1 block */
+#define MMUV2_ENTRIES_PER_L1_BLOCK		16
+#define MMUV2_TRASH_L1_BLOCK_OFFSET		(MMUV2_ENTRIES_PER_L1_BLOCK * \
+						 PAGE_SIZE)
+#define MMUV2_TRASH_L2_BLOCK_OFFSET		IPU_MMUV2_L2_RANGE
+
+/*
+ * In some of the IPU MMUs, there is provision to configure L1 and L2 page
+ * table caches. Both these L1 and L2 caches are divided into multiple sections
+ * called streams. There is maximum 16 streams for both caches. Each of these
+ * sections are subdivided into multiple blocks. When nr_l1streams = 0 and
+ * nr_l2streams = 0, means the MMU is of type MMU_V1 and do not support
+ * L1/L2 page table caches.
+ *
+ * L1 stream per block sizes are configurable and varies per usecase.
+ * L2 has constant block sizes - 2 blocks per stream.
+ *
+ * MMU1 support pre-fetching of the pages to have less cache lookup misses. To
+ * enable the pre-fetching, MMU1 AT (Address Translator) device registers
+ * need to be configured.
+ *
+ * There are four types of memory accesses which requires ZLW configuration.
+ * ZLW(Zero Length Write) is a mechanism to enable VT-d pre-fetching on IOMMU.
+ *
+ * 1. Sequential Access or 1D mode
+ *	Set ZLW_EN -> 1
+ *	set ZLW_PAGE_CROSS_1D -> 1
+ *	Set ZLW_N to "N" pages so that ZLW will be inserte N pages ahead where
+ *		  N is pre-defined and hardcoded in the platform data
+ *	Set ZLW_2D -> 0
+ *
+ * 2. ZLW 2D mode
+ *	Set ZLW_EN -> 1
+ *	set ZLW_PAGE_CROSS_1D -> 1,
+ *	Set ZLW_N -> 0
+ *	Set ZLW_2D -> 1
+ *
+ * 3. ZLW Enable (no 1D or 2D mode)
+ *	Set ZLW_EN -> 1
+ *	set ZLW_PAGE_CROSS_1D -> 0,
+ *	Set ZLW_N -> 0
+ *	Set ZLW_2D -> 0
+ *
+ * 4. ZLW disable
+ *	Set ZLW_EN -> 0
+ *	set ZLW_PAGE_CROSS_1D -> 0,
+ *	Set ZLW_N -> 0
+ *	Set ZLW_2D -> 0
+ *
+ * To configure the ZLW for the above memory access, four registers are
+ * available. Hence to track these four settings, we have the following entries
+ * in the struct ipu_mmu_hw. Each of these entries are per stream and
+ * available only for the L1 streams.
+ *
+ * a. l1_zlw_en -> To track zlw enabled per stream (ZLW_EN)
+ * b. l1_zlw_1d_mode -> Track 1D mode per stream. ZLW inserted at page boundary
+ * c. l1_ins_zlw_ahead_pages -> to track how advance the ZLW need to be inserted
+ *			Insert ZLW request N pages ahead address.
+ * d. l1_zlw_2d_mode -> To track 2D mode per stream (ZLW_2D)
+ *
+ *
+ * Currently L1/L2 streams, blocks, AT ZLW configurations etc. are pre-defined
+ * as per the usecase specific calculations. Any change to this pre-defined
+ * table has to happen in sync with IPU FW.
+ */
+struct ipu_mmu_hw {
+	union {
+		unsigned long offset;
+		void __iomem *base;
+	};
+	unsigned int info_bits;
+	u8 nr_l1streams;
+	/*
+	 * L1 has variable blocks per stream - total of 64 blocks and maximum of
+	 * 16 blocks per stream. Configurable by using the block start address
+	 * per stream. Block start address is calculated from the block size
+	 */
+	u8 l1_block_sz[IPU_MMU_MAX_TLB_L1_STREAMS];
+	/* Is ZLW is enabled in each stream */
+	bool l1_zlw_en[IPU_MMU_MAX_TLB_L1_STREAMS];
+	bool l1_zlw_1d_mode[IPU_MMU_MAX_TLB_L1_STREAMS];
+	u8 l1_ins_zlw_ahead_pages[IPU_MMU_MAX_TLB_L1_STREAMS];
+	bool l1_zlw_2d_mode[IPU_MMU_MAX_TLB_L1_STREAMS];
+
+	u32 l1_stream_id_reg_offset;
+	u32 l2_stream_id_reg_offset;
+
+	u8 nr_l2streams;
+	/*
+	 * L2 has fixed 2 blocks per stream. Block address is calculated
+	 * from the block size
+	 */
+	u8 l2_block_sz[IPU_MMU_MAX_TLB_L2_STREAMS];
+	/* flag to track if WA is needed for successive invalidate HW bug */
+	bool insert_read_before_invalidate;
+};
+
+struct ipu_mmu_pdata {
+	unsigned int nr_mmus;
+	struct ipu_mmu_hw mmu_hw[IPU_MMU_MAX_DEVICES];
+	int mmid;
+};
+
+struct ipu_isys_csi2_pdata {
+	void __iomem *base;
+};
+
+#define IPU_EV_AUTO 0xff
+
+struct ipu_isys_internal_csi2_pdata {
+	unsigned int nports;
+	unsigned int *offsets;
+};
+
+/*
+ * One place to handle all the IPU HW variations
+ */
+struct ipu_hw_variants {
+	unsigned long offset;
+	unsigned int nr_mmus;
+	struct ipu_mmu_hw mmu_hw[IPU_MMU_MAX_DEVICES];
+	u8 cdc_fifos;
+	u8 cdc_fifo_threshold[IPU_MAX_VC_IOSF_PORTS];
+	u32 dmem_offset;
+	u32 spc_offset;	/* SPC offset from psys base */
+};
+
+struct ipu_isys_internal_pdata {
+	struct ipu_isys_internal_csi2_pdata csi2;
+	struct ipu_hw_variants hw_variant;
+	u32 num_parallel_streams;
+	u32 isys_dma_overshoot;
+};
+
+struct ipu_isys_pdata {
+	void __iomem *base;
+	const struct ipu_isys_internal_pdata *ipdata;
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA)
+	struct ipu_isys_subdev_pdata *spdata;
+#endif
+};
+
+struct ipu_psys_internal_pdata {
+	struct ipu_hw_variants hw_variant;
+};
+
+struct ipu_psys_pdata {
+	void __iomem *base;
+	const struct ipu_psys_internal_pdata *ipdata;
+};
+
+#endif
Index: b/drivers/media/pci/intel/ipu-psys-compat32.c
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu-psys-compat32.c
@@ -0,0 +1,222 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) 2013 - 2020 Intel Corporation
+
+#include <linux/compat.h>
+#include <linux/errno.h>
+#include <linux/uaccess.h>
+
+#include <uapi/linux/ipu-psys.h>
+
+#include "ipu-psys.h"
+
+static long native_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	long ret = -ENOTTY;
+
+	if (file->f_op->unlocked_ioctl)
+		ret = file->f_op->unlocked_ioctl(file, cmd, arg);
+
+	return ret;
+}
+
+struct ipu_psys_buffer32 {
+	u64 len;
+	union {
+		int fd;
+		compat_uptr_t userptr;
+		u64 reserved;
+	} base;
+	u32 data_offset;
+	u32 bytes_used;
+	u32 flags;
+	u32 reserved[2];
+} __packed;
+
+struct ipu_psys_command32 {
+	u64 issue_id;
+	u64 user_token;
+	u32 priority;
+	compat_uptr_t pg_manifest;
+	compat_uptr_t buffers;
+	int pg;
+	u32 pg_manifest_size;
+	u32 bufcount;
+	u32 min_psys_freq;
+	u32 frame_counter;
+	u32 reserved[2];
+} __packed;
+
+struct ipu_psys_manifest32 {
+	u32 index;
+	u32 size;
+	compat_uptr_t manifest;
+	u32 reserved[5];
+} __packed;
+
+static int
+get_ipu_psys_command32(struct ipu_psys_command *kp,
+		       struct ipu_psys_command32 __user *up)
+{
+	compat_uptr_t pgm, bufs;
+	bool access_ok;
+
+	access_ok = access_ok(up, sizeof(struct ipu_psys_command32));
+	if (!access_ok || get_user(kp->issue_id, &up->issue_id) ||
+	    get_user(kp->user_token, &up->user_token) ||
+	    get_user(kp->priority, &up->priority) ||
+	    get_user(pgm, &up->pg_manifest) ||
+	    get_user(bufs, &up->buffers) ||
+	    get_user(kp->pg, &up->pg) ||
+	    get_user(kp->pg_manifest_size, &up->pg_manifest_size) ||
+	    get_user(kp->bufcount, &up->bufcount) ||
+	    get_user(kp->min_psys_freq, &up->min_psys_freq) ||
+	    get_user(kp->frame_counter, &up->frame_counter)
+	    )
+		return -EFAULT;
+
+	kp->pg_manifest = compat_ptr(pgm);
+	kp->buffers = compat_ptr(bufs);
+
+	return 0;
+}
+
+static int
+get_ipu_psys_buffer32(struct ipu_psys_buffer *kp,
+		      struct ipu_psys_buffer32 __user *up)
+{
+	compat_uptr_t ptr;
+	bool access_ok;
+
+	access_ok = access_ok(up, sizeof(struct ipu_psys_buffer32));
+	if (!access_ok || get_user(kp->len, &up->len) ||
+	    get_user(ptr, &up->base.userptr) ||
+	    get_user(kp->data_offset, &up->data_offset) ||
+	    get_user(kp->bytes_used, &up->bytes_used) ||
+	    get_user(kp->flags, &up->flags))
+		return -EFAULT;
+
+	kp->base.userptr = compat_ptr(ptr);
+
+	return 0;
+}
+
+static int
+put_ipu_psys_buffer32(struct ipu_psys_buffer *kp,
+		      struct ipu_psys_buffer32 __user *up)
+{
+	bool access_ok;
+
+	access_ok = access_ok(up, sizeof(struct ipu_psys_buffer32));
+	if (!access_ok || put_user(kp->len, &up->len) ||
+	    put_user(kp->base.fd, &up->base.fd) ||
+	    put_user(kp->data_offset, &up->data_offset) ||
+	    put_user(kp->bytes_used, &up->bytes_used) ||
+	    put_user(kp->flags, &up->flags))
+		return -EFAULT;
+
+	return 0;
+}
+
+static int
+get_ipu_psys_manifest32(struct ipu_psys_manifest *kp,
+			struct ipu_psys_manifest32 __user *up)
+{
+	compat_uptr_t ptr;
+	bool access_ok;
+
+	access_ok = access_ok(up, sizeof(struct ipu_psys_manifest32));
+	if (!access_ok || get_user(kp->index, &up->index) ||
+	    get_user(kp->size, &up->size) || get_user(ptr, &up->manifest))
+		return -EFAULT;
+
+	kp->manifest = compat_ptr(ptr);
+
+	return 0;
+}
+
+static int
+put_ipu_psys_manifest32(struct ipu_psys_manifest *kp,
+			struct ipu_psys_manifest32 __user *up)
+{
+	compat_uptr_t ptr = (u32)((unsigned long)kp->manifest);
+	bool access_ok;
+
+	access_ok = access_ok(up, sizeof(struct ipu_psys_manifest32));
+	if (!access_ok || put_user(kp->index, &up->index) ||
+	    put_user(kp->size, &up->size) || put_user(ptr, &up->manifest))
+		return -EFAULT;
+
+	return 0;
+}
+
+#define IPU_IOC_GETBUF32 _IOWR('A', 4, struct ipu_psys_buffer32)
+#define IPU_IOC_PUTBUF32 _IOWR('A', 5, struct ipu_psys_buffer32)
+#define IPU_IOC_QCMD32 _IOWR('A', 6, struct ipu_psys_command32)
+#define IPU_IOC_CMD_CANCEL32 _IOWR('A', 8, struct ipu_psys_command32)
+#define IPU_IOC_GET_MANIFEST32 _IOWR('A', 9, struct ipu_psys_manifest32)
+
+long ipu_psys_compat_ioctl32(struct file *file, unsigned int cmd,
+			     unsigned long arg)
+{
+	union {
+		struct ipu_psys_buffer buf;
+		struct ipu_psys_command cmd;
+		struct ipu_psys_event ev;
+		struct ipu_psys_manifest m;
+	} karg;
+	int compatible_arg = 1;
+	int err = 0;
+	void __user *up = compat_ptr(arg);
+
+	switch (cmd) {
+	case IPU_IOC_GETBUF32:
+		cmd = IPU_IOC_GETBUF;
+		break;
+	case IPU_IOC_PUTBUF32:
+		cmd = IPU_IOC_PUTBUF;
+		break;
+	case IPU_IOC_QCMD32:
+		cmd = IPU_IOC_QCMD;
+		break;
+	case IPU_IOC_GET_MANIFEST32:
+		cmd = IPU_IOC_GET_MANIFEST;
+		break;
+	}
+
+	switch (cmd) {
+	case IPU_IOC_GETBUF:
+	case IPU_IOC_PUTBUF:
+		err = get_ipu_psys_buffer32(&karg.buf, up);
+		compatible_arg = 0;
+		break;
+	case IPU_IOC_QCMD:
+		err = get_ipu_psys_command32(&karg.cmd, up);
+		compatible_arg = 0;
+		break;
+	case IPU_IOC_GET_MANIFEST:
+		err = get_ipu_psys_manifest32(&karg.m, up);
+		compatible_arg = 0;
+		break;
+	}
+	if (err)
+		return err;
+
+	if (compatible_arg) {
+		err = native_ioctl(file, cmd, (unsigned long)up);
+	} else {
+		err = native_ioctl(file, cmd, (unsigned long)&karg);
+	}
+
+	if (err)
+		return err;
+
+	switch (cmd) {
+	case IPU_IOC_GETBUF:
+		err = put_ipu_psys_buffer32(&karg.buf, up);
+		break;
+	case IPU_IOC_GET_MANIFEST:
+		err = put_ipu_psys_manifest32(&karg.m, up);
+		break;
+	}
+	return err;
+}
Index: b/drivers/media/pci/intel/ipu-psys.c
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu-psys.c
@@ -0,0 +1,1622 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) 2013 - 2022 Intel Corporation
+
+#include <linux/debugfs.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/dma-buf.h>
+#include <linux/firmware.h>
+#include <linux/fs.h>
+#include <linux/highmem.h>
+#include <linux/init_task.h>
+#include <linux/kthread.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/version.h>
+#include <linux/poll.h>
+#include <uapi/linux/sched/types.h>
+#include <linux/uaccess.h>
+#include <linux/vmalloc.h>
+#include <linux/dma-mapping.h>
+
+#include <uapi/linux/ipu-psys.h>
+
+#include "ipu.h"
+#include "ipu-mmu.h"
+#include "ipu-bus.h"
+#include "ipu-platform.h"
+#include "ipu-buttress.h"
+#include "ipu-cpd.h"
+#include "ipu-fw-psys.h"
+#include "ipu-psys.h"
+#include "ipu-platform-psys.h"
+#include "ipu-platform-regs.h"
+#include "ipu-fw-com.h"
+
+static bool async_fw_init;
+module_param(async_fw_init, bool, 0664);
+MODULE_PARM_DESC(async_fw_init, "Enable asynchronous firmware initialization");
+
+#define IPU_PSYS_NUM_DEVICES		4
+#define IPU_PSYS_AUTOSUSPEND_DELAY	2000
+
+#ifdef CONFIG_PM
+static int psys_runtime_pm_resume(struct device *dev);
+static int psys_runtime_pm_suspend(struct device *dev);
+#else
+#define pm_runtime_dont_use_autosuspend(d)
+#define pm_runtime_use_autosuspend(d)
+#define pm_runtime_set_autosuspend_delay(d, f)	0
+#define pm_runtime_get_sync(d)			0
+#define pm_runtime_put(d)			0
+#define pm_runtime_put_sync(d)			0
+#define pm_runtime_put_noidle(d)		0
+#define pm_runtime_put_autosuspend(d)		0
+#endif
+
+static dev_t ipu_psys_dev_t;
+static DECLARE_BITMAP(ipu_psys_devices, IPU_PSYS_NUM_DEVICES);
+static DEFINE_MUTEX(ipu_psys_mutex);
+
+static struct fw_init_task {
+	struct delayed_work work;
+	struct ipu_psys *psys;
+} fw_init_task;
+
+static void ipu_psys_remove(struct ipu_bus_device *adev);
+
+static struct bus_type ipu_psys_bus = {
+	.name = IPU_PSYS_NAME,
+};
+
+struct ipu_psys_pg *__get_pg_buf(struct ipu_psys *psys, size_t pg_size)
+{
+	struct ipu_psys_pg *kpg;
+	unsigned long flags;
+
+	spin_lock_irqsave(&psys->pgs_lock, flags);
+	list_for_each_entry(kpg, &psys->pgs, list) {
+		if (!kpg->pg_size && kpg->size >= pg_size) {
+			kpg->pg_size = pg_size;
+			spin_unlock_irqrestore(&psys->pgs_lock, flags);
+			return kpg;
+		}
+	}
+	spin_unlock_irqrestore(&psys->pgs_lock, flags);
+	/* no big enough buffer available, allocate new one */
+	kpg = kzalloc(sizeof(*kpg), GFP_KERNEL);
+	if (!kpg)
+		return NULL;
+
+	kpg->pg = dma_alloc_attrs(&psys->adev->dev, pg_size,
+				  &kpg->pg_dma_addr, GFP_KERNEL, 0);
+	if (!kpg->pg) {
+		kfree(kpg);
+		return NULL;
+	}
+
+	kpg->pg_size = pg_size;
+	kpg->size = pg_size;
+	spin_lock_irqsave(&psys->pgs_lock, flags);
+	list_add(&kpg->list, &psys->pgs);
+	spin_unlock_irqrestore(&psys->pgs_lock, flags);
+
+	return kpg;
+}
+
+static int ipu_psys_unmapbuf_locked(int fd, struct ipu_psys_fh *fh,
+				    struct ipu_psys_kbuffer *kbuf);
+struct ipu_psys_kbuffer *ipu_psys_lookup_kbuffer(struct ipu_psys_fh *fh, int fd)
+{
+	struct ipu_psys_kbuffer *kbuf;
+
+	list_for_each_entry(kbuf, &fh->bufmap, list) {
+		if (kbuf->fd == fd)
+			return kbuf;
+	}
+
+	return NULL;
+}
+
+struct ipu_psys_kbuffer *
+ipu_psys_lookup_kbuffer_by_kaddr(struct ipu_psys_fh *fh, void *kaddr)
+{
+	struct ipu_psys_kbuffer *kbuffer;
+
+	list_for_each_entry(kbuffer, &fh->bufmap, list) {
+		if (kbuffer->kaddr == kaddr)
+			return kbuffer;
+	}
+
+	return NULL;
+}
+
+static int ipu_psys_get_userpages(struct ipu_dma_buf_attach *attach)
+{
+	struct vm_area_struct *vma;
+	unsigned long start, end;
+	int npages, array_size;
+	struct page **pages;
+	struct sg_table *sgt;
+	int nr = 0;
+	int ret = -ENOMEM;
+
+	start = (unsigned long)attach->userptr;
+	end = PAGE_ALIGN(start + attach->len);
+	npages = (end - (start & PAGE_MASK)) >> PAGE_SHIFT;
+	array_size = npages * sizeof(struct page *);
+
+	sgt = kzalloc(sizeof(*sgt), GFP_KERNEL);
+	if (!sgt)
+		return -ENOMEM;
+
+	if (attach->npages != 0) {
+		pages = attach->pages;
+		npages = attach->npages;
+		attach->vma_is_io = 1;
+		goto skip_pages;
+	}
+
+	pages = kvzalloc(array_size, GFP_KERNEL);
+	if (!pages)
+		goto free_sgt;
+
+	mmap_read_lock(current->mm);
+	vma = find_vma(current->mm, start);
+	if (!vma) {
+		ret = -EFAULT;
+		goto error_up_read;
+	}
+
+	/*
+	 * For buffers from Gralloc, VM_PFNMAP is expected,
+	 * but VM_IO is set. Possibly bug in Gralloc.
+	 */
+	attach->vma_is_io = vma->vm_flags & (VM_IO | VM_PFNMAP);
+
+	if (attach->vma_is_io) {
+		unsigned long io_start = start;
+
+		if (vma->vm_end < start + attach->len) {
+			dev_err(attach->dev,
+				"vma at %lu is too small for %llu bytes\n",
+				start, attach->len);
+			ret = -EFAULT;
+			goto error_up_read;
+		}
+
+		for (nr = 0; nr < npages; nr++, io_start += PAGE_SIZE) {
+			unsigned long pfn;
+
+			ret = follow_pfn(vma, io_start, &pfn);
+			if (ret)
+				goto error_up_read;
+			pages[nr] = pfn_to_page(pfn);
+		}
+	} else {
+		nr = get_user_pages(start & PAGE_MASK, npages,
+				    FOLL_WRITE,
+				    pages, NULL);
+		if (nr < npages)
+			goto error_up_read;
+	}
+	mmap_read_unlock(current->mm);
+
+	attach->pages = pages;
+	attach->npages = npages;
+
+skip_pages:
+	ret = sg_alloc_table_from_pages(sgt, pages, npages,
+					start & ~PAGE_MASK, attach->len,
+					GFP_KERNEL);
+	if (ret < 0)
+		goto error;
+
+	attach->sgt = sgt;
+
+	return 0;
+
+error_up_read:
+	mmap_read_unlock(current->mm);
+error:
+	if (!attach->vma_is_io)
+		while (nr > 0)
+			put_page(pages[--nr]);
+
+	if (array_size <= PAGE_SIZE)
+		kfree(pages);
+	else
+		vfree(pages);
+free_sgt:
+	kfree(sgt);
+
+	dev_err(attach->dev, "failed to get userpages:%d\n", ret);
+
+	return ret;
+}
+
+static void ipu_psys_put_userpages(struct ipu_dma_buf_attach *attach)
+{
+	if (!attach || !attach->userptr || !attach->sgt)
+		return;
+
+	if (!attach->vma_is_io) {
+		int i = attach->npages;
+
+		while (--i >= 0) {
+			set_page_dirty_lock(attach->pages[i]);
+			put_page(attach->pages[i]);
+		}
+	}
+
+	kvfree(attach->pages);
+
+	sg_free_table(attach->sgt);
+	kfree(attach->sgt);
+	attach->sgt = NULL;
+}
+
+static int ipu_dma_buf_attach(struct dma_buf *dbuf,
+			      struct dma_buf_attachment *attach)
+{
+	struct ipu_psys_kbuffer *kbuf = dbuf->priv;
+	struct ipu_dma_buf_attach *ipu_attach;
+	int ret;
+
+	ipu_attach = kzalloc(sizeof(*ipu_attach), GFP_KERNEL);
+	if (!ipu_attach)
+		return -ENOMEM;
+
+	ipu_attach->len = kbuf->len;
+	ipu_attach->userptr = kbuf->userptr;
+
+	ret = ipu_psys_get_userpages(ipu_attach);
+	if (ret) {
+		kfree(ipu_attach);
+		return ret;
+	}
+
+	attach->priv = ipu_attach;
+	return 0;
+}
+
+static void ipu_dma_buf_detach(struct dma_buf *dbuf,
+			       struct dma_buf_attachment *attach)
+{
+	struct ipu_dma_buf_attach *ipu_attach = attach->priv;
+
+	ipu_psys_put_userpages(ipu_attach);
+	kfree(ipu_attach);
+	attach->priv = NULL;
+}
+
+static struct sg_table *ipu_dma_buf_map(struct dma_buf_attachment *attach,
+					enum dma_data_direction dir)
+{
+	struct ipu_dma_buf_attach *ipu_attach = attach->priv;
+	unsigned long attrs;
+	int ret;
+
+	attrs = DMA_ATTR_SKIP_CPU_SYNC;
+	ret = dma_map_sgtable(attach->dev, ipu_attach->sgt, dir, attrs);
+	if (ret < 0) {
+		dev_dbg(attach->dev, "buf map failed\n");
+
+		return ERR_PTR(-EIO);
+	}
+
+	/*
+	 * Initial cache flush to avoid writing dirty pages for buffers which
+	 * are later marked as IPU_BUFFER_FLAG_NO_FLUSH.
+	 */
+	dma_sync_sg_for_device(attach->dev, ipu_attach->sgt->sgl,
+			       ipu_attach->sgt->orig_nents, DMA_BIDIRECTIONAL);
+
+	return ipu_attach->sgt;
+}
+
+static void ipu_dma_buf_unmap(struct dma_buf_attachment *attach,
+			      struct sg_table *sgt, enum dma_data_direction dir)
+{
+	dma_unmap_sgtable(attach->dev, sgt, dir, DMA_ATTR_SKIP_CPU_SYNC);
+}
+
+static int ipu_dma_buf_mmap(struct dma_buf *dbuf, struct vm_area_struct *vma)
+{
+	return -ENOTTY;
+}
+
+static void ipu_dma_buf_release(struct dma_buf *buf)
+{
+	struct ipu_psys_kbuffer *kbuf = buf->priv;
+
+	if (!kbuf)
+		return;
+
+	if (kbuf->db_attach) {
+		dev_dbg(kbuf->db_attach->dev,
+			"releasing buffer %d\n", kbuf->fd);
+		ipu_psys_put_userpages(kbuf->db_attach->priv);
+	}
+	kfree(kbuf);
+}
+
+static int ipu_dma_buf_begin_cpu_access(struct dma_buf *dma_buf,
+					enum dma_data_direction dir)
+{
+	return -ENOTTY;
+}
+
+static int ipu_dma_buf_vmap(struct dma_buf *dmabuf, struct iosys_map *map)
+{
+	struct dma_buf_attachment *attach;
+	struct ipu_dma_buf_attach *ipu_attach;
+
+	if (list_empty(&dmabuf->attachments))
+		return -EINVAL;
+
+	attach = list_last_entry(&dmabuf->attachments,
+				 struct dma_buf_attachment, node);
+	ipu_attach = attach->priv;
+
+	if (!ipu_attach || !ipu_attach->pages || !ipu_attach->npages)
+		return -EINVAL;
+
+	map->vaddr = vm_map_ram(ipu_attach->pages, ipu_attach->npages, 0);
+	map->is_iomem = false;
+	if (!map->vaddr)
+		return -EINVAL;
+
+	return 0;
+}
+
+static void ipu_dma_buf_vunmap(struct dma_buf *dmabuf, struct iosys_map *map)
+{
+	struct dma_buf_attachment *attach;
+	struct ipu_dma_buf_attach *ipu_attach;
+
+	if (WARN_ON(list_empty(&dmabuf->attachments)))
+		return;
+
+	attach = list_last_entry(&dmabuf->attachments,
+				 struct dma_buf_attachment, node);
+	ipu_attach = attach->priv;
+
+	if (WARN_ON(!ipu_attach || !ipu_attach->pages || !ipu_attach->npages))
+		return;
+
+	vm_unmap_ram(map->vaddr, ipu_attach->npages);
+}
+
+struct dma_buf_ops ipu_dma_buf_ops = {
+	.attach = ipu_dma_buf_attach,
+	.detach = ipu_dma_buf_detach,
+	.map_dma_buf = ipu_dma_buf_map,
+	.unmap_dma_buf = ipu_dma_buf_unmap,
+	.release = ipu_dma_buf_release,
+	.begin_cpu_access = ipu_dma_buf_begin_cpu_access,
+	.mmap = ipu_dma_buf_mmap,
+	.vmap = ipu_dma_buf_vmap,
+	.vunmap = ipu_dma_buf_vunmap,
+};
+
+static int ipu_psys_open(struct inode *inode, struct file *file)
+{
+	struct ipu_psys *psys = inode_to_ipu_psys(inode);
+	struct ipu_device *isp = psys->adev->isp;
+	struct ipu_psys_fh *fh;
+	int rval;
+
+	if (isp->flr_done)
+		return -EIO;
+
+	fh = kzalloc(sizeof(*fh), GFP_KERNEL);
+	if (!fh)
+		return -ENOMEM;
+
+	fh->psys = psys;
+
+	file->private_data = fh;
+
+	mutex_init(&fh->mutex);
+	INIT_LIST_HEAD(&fh->bufmap);
+	init_waitqueue_head(&fh->wait);
+
+	rval = ipu_psys_fh_init(fh);
+	if (rval)
+		goto open_failed;
+
+	mutex_lock(&psys->mutex);
+	list_add_tail(&fh->list, &psys->fhs);
+	mutex_unlock(&psys->mutex);
+
+	return 0;
+
+open_failed:
+	mutex_destroy(&fh->mutex);
+	kfree(fh);
+	return rval;
+}
+
+static inline void ipu_psys_kbuf_unmap(struct ipu_psys_kbuffer *kbuf)
+{
+	if (!kbuf)
+		return;
+
+	kbuf->valid = false;
+	if (kbuf->kaddr) {
+		struct iosys_map dmap;
+
+		iosys_map_set_vaddr(&dmap, kbuf->kaddr);
+		dma_buf_vunmap(kbuf->dbuf, &dmap);
+	}
+	if (kbuf->sgt) {
+		dma_buf_unmap_attachment(kbuf->db_attach,
+					 kbuf->sgt,
+					 DMA_BIDIRECTIONAL);
+	}
+	if (kbuf->db_attach)
+		dma_buf_detach(kbuf->dbuf, kbuf->db_attach);
+	dma_buf_put(kbuf->dbuf);
+
+	kbuf->db_attach = NULL;
+	kbuf->dbuf = NULL;
+	kbuf->sgt = NULL;
+}
+
+static int ipu_psys_release(struct inode *inode, struct file *file)
+{
+	struct ipu_psys *psys = inode_to_ipu_psys(inode);
+	struct ipu_psys_fh *fh = file->private_data;
+	struct ipu_psys_kbuffer *kbuf, *kbuf0;
+	struct dma_buf_attachment *db_attach;
+
+	mutex_lock(&fh->mutex);
+	/* clean up buffers */
+	if (!list_empty(&fh->bufmap)) {
+		list_for_each_entry_safe(kbuf, kbuf0, &fh->bufmap, list) {
+			list_del(&kbuf->list);
+			db_attach = kbuf->db_attach;
+
+			/* Unmap and release buffers */
+			if (kbuf->dbuf && db_attach) {
+
+				ipu_psys_kbuf_unmap(kbuf);
+			} else {
+				if (db_attach)
+					ipu_psys_put_userpages(db_attach->priv);
+				kfree(kbuf);
+			}
+		}
+	}
+	mutex_unlock(&fh->mutex);
+
+	mutex_lock(&psys->mutex);
+	list_del(&fh->list);
+
+	mutex_unlock(&psys->mutex);
+	ipu_psys_fh_deinit(fh);
+
+	mutex_lock(&psys->mutex);
+	if (list_empty(&psys->fhs))
+		psys->power_gating = 0;
+	mutex_unlock(&psys->mutex);
+	mutex_destroy(&fh->mutex);
+	kfree(fh);
+
+	return 0;
+}
+
+static int ipu_psys_getbuf(struct ipu_psys_buffer *buf, struct ipu_psys_fh *fh)
+{
+	struct ipu_psys_kbuffer *kbuf;
+	struct ipu_psys *psys = fh->psys;
+
+	DEFINE_DMA_BUF_EXPORT_INFO(exp_info);
+	struct dma_buf *dbuf;
+	int ret;
+
+	if (!buf->base.userptr) {
+		dev_err(&psys->adev->dev, "Buffer allocation not supported\n");
+		return -EINVAL;
+	}
+
+	kbuf = kzalloc(sizeof(*kbuf), GFP_KERNEL);
+	if (!kbuf)
+		return -ENOMEM;
+
+	kbuf->len = buf->len;
+	kbuf->userptr = buf->base.userptr;
+	kbuf->flags = buf->flags;
+
+	exp_info.ops = &ipu_dma_buf_ops;
+	exp_info.size = kbuf->len;
+	exp_info.flags = O_RDWR;
+	exp_info.priv = kbuf;
+
+	dbuf = dma_buf_export(&exp_info);
+	if (IS_ERR(dbuf)) {
+		kfree(kbuf);
+		return PTR_ERR(dbuf);
+	}
+
+	ret = dma_buf_fd(dbuf, 0);
+	if (ret < 0) {
+		dma_buf_put(dbuf);
+		return ret;
+	}
+
+	kbuf->fd = ret;
+	buf->base.fd = ret;
+	buf->flags &= ~IPU_BUFFER_FLAG_USERPTR;
+	buf->flags |= IPU_BUFFER_FLAG_DMA_HANDLE;
+	kbuf->flags = buf->flags;
+
+	mutex_lock(&fh->mutex);
+	list_add(&kbuf->list, &fh->bufmap);
+	mutex_unlock(&fh->mutex);
+
+	dev_dbg(&psys->adev->dev, "IOC_GETBUF: userptr %p size %llu to fd %d",
+		buf->base.userptr, buf->len, buf->base.fd);
+
+	return 0;
+}
+
+static int ipu_psys_putbuf(struct ipu_psys_buffer *buf, struct ipu_psys_fh *fh)
+{
+	return 0;
+}
+
+int ipu_psys_mapbuf_locked(int fd, struct ipu_psys_fh *fh,
+			   struct ipu_psys_kbuffer *kbuf)
+{
+	struct ipu_psys *psys = fh->psys;
+	struct dma_buf *dbuf;
+	struct iosys_map dmap;
+	int ret;
+
+	dbuf = dma_buf_get(fd);
+	if (IS_ERR(dbuf))
+		return -EINVAL;
+
+	if (!kbuf) {
+		/* This fd isn't generated by ipu_psys_getbuf, it
+		 * is a new fd. Create a new kbuf item for this fd, and
+		 * add this kbuf to bufmap list.
+		 */
+		kbuf = kzalloc(sizeof(*kbuf), GFP_KERNEL);
+		if (!kbuf) {
+			ret = -ENOMEM;
+			goto mapbuf_fail;
+		}
+
+		list_add(&kbuf->list, &fh->bufmap);
+	}
+
+	/* fd valid and found, need remap */
+	if (kbuf->dbuf && (kbuf->dbuf != dbuf || kbuf->len != dbuf->size)) {
+		dev_dbg(&psys->adev->dev,
+			"dmabuf fd %d with kbuf %p changed, need remap.\n",
+			fd, kbuf);
+		ret = ipu_psys_unmapbuf_locked(fd, fh, kbuf);
+		if (ret)
+			goto mapbuf_fail;
+
+		kbuf = ipu_psys_lookup_kbuffer(fh, fd);
+		/* changed external dmabuf */
+		if (!kbuf) {
+			kbuf = kzalloc(sizeof(*kbuf), GFP_KERNEL);
+			if (!kbuf) {
+				ret = -ENOMEM;
+				goto mapbuf_fail;
+			}
+			list_add(&kbuf->list, &fh->bufmap);
+		}
+	}
+
+	if (kbuf->sgt) {
+		dev_dbg(&psys->adev->dev, "fd %d has been mapped!\n", fd);
+		dma_buf_put(dbuf);
+		goto mapbuf_end;
+	}
+
+	kbuf->dbuf = dbuf;
+
+	if (kbuf->len == 0)
+		kbuf->len = kbuf->dbuf->size;
+
+	kbuf->fd = fd;
+
+	kbuf->db_attach = dma_buf_attach(kbuf->dbuf, &psys->adev->dev);
+	if (IS_ERR(kbuf->db_attach)) {
+		ret = PTR_ERR(kbuf->db_attach);
+		dev_dbg(&psys->adev->dev, "dma buf attach failed\n");
+		goto kbuf_map_fail;
+	}
+
+	kbuf->sgt = dma_buf_map_attachment(kbuf->db_attach, DMA_BIDIRECTIONAL);
+	if (IS_ERR_OR_NULL(kbuf->sgt)) {
+		ret = -EINVAL;
+		kbuf->sgt = NULL;
+		dev_dbg(&psys->adev->dev, "dma buf map attachment failed\n");
+		goto kbuf_map_fail;
+	}
+
+	kbuf->dma_addr = sg_dma_address(kbuf->sgt->sgl);
+
+	ret = dma_buf_vmap(kbuf->dbuf, &dmap);
+	if (ret) {
+		dev_dbg(&psys->adev->dev, "dma buf vmap failed\n");
+		goto kbuf_map_fail;
+	}
+	kbuf->kaddr = dmap.vaddr;
+
+	dev_dbg(&psys->adev->dev, "%s kbuf %p fd %d with len %llu mapped\n",
+		__func__, kbuf, fd, kbuf->len);
+mapbuf_end:
+
+	kbuf->valid = true;
+
+	return 0;
+
+kbuf_map_fail:
+	ipu_psys_kbuf_unmap(kbuf);
+
+	list_del(&kbuf->list);
+	if (!kbuf->userptr)
+		kfree(kbuf);
+
+mapbuf_fail:
+	dma_buf_put(dbuf);
+
+	dev_err(&psys->adev->dev, "%s failed for fd %d\n", __func__, fd);
+	return ret;
+}
+
+static long ipu_psys_mapbuf(int fd, struct ipu_psys_fh *fh)
+{
+	long ret;
+	struct ipu_psys_kbuffer *kbuf;
+
+	mutex_lock(&fh->mutex);
+	kbuf = ipu_psys_lookup_kbuffer(fh, fd);
+	ret = ipu_psys_mapbuf_locked(fd, fh, kbuf);
+	mutex_unlock(&fh->mutex);
+
+	dev_dbg(&fh->psys->adev->dev, "IOC_MAPBUF ret %ld\n", ret);
+
+	return ret;
+}
+
+static int ipu_psys_unmapbuf_locked(int fd, struct ipu_psys_fh *fh,
+				    struct ipu_psys_kbuffer *kbuf)
+{
+	struct ipu_psys *psys = fh->psys;
+
+	if (!kbuf || fd != kbuf->fd) {
+		dev_err(&psys->adev->dev, "invalid kbuffer\n");
+		return -EINVAL;
+	}
+
+	/* From now on it is not safe to use this kbuffer */
+	ipu_psys_kbuf_unmap(kbuf);
+
+	list_del(&kbuf->list);
+
+	if (!kbuf->userptr)
+		kfree(kbuf);
+
+	dev_dbg(&psys->adev->dev, "%s fd %d unmapped\n", __func__, fd);
+
+	return 0;
+}
+
+static long ipu_psys_unmapbuf(int fd, struct ipu_psys_fh *fh)
+{
+	struct ipu_psys_kbuffer *kbuf;
+	long ret;
+
+	mutex_lock(&fh->mutex);
+	kbuf = ipu_psys_lookup_kbuffer(fh, fd);
+	if (!kbuf) {
+		dev_err(&fh->psys->adev->dev,
+			"buffer with fd %d not found\n", fd);
+		mutex_unlock(&fh->mutex);
+		return -EINVAL;
+	}
+	ret = ipu_psys_unmapbuf_locked(fd, fh, kbuf);
+	mutex_unlock(&fh->mutex);
+
+	dev_dbg(&fh->psys->adev->dev, "IOC_UNMAPBUF\n");
+
+	return ret;
+}
+
+static unsigned int ipu_psys_poll(struct file *file,
+				  struct poll_table_struct *wait)
+{
+	struct ipu_psys_fh *fh = file->private_data;
+	struct ipu_psys *psys = fh->psys;
+	unsigned int res = 0;
+
+	dev_dbg(&psys->adev->dev, "ipu psys poll\n");
+
+	poll_wait(file, &fh->wait, wait);
+
+	if (ipu_get_completed_kcmd(fh))
+		res = POLLIN;
+
+	dev_dbg(&psys->adev->dev, "ipu psys poll res %u\n", res);
+
+	return res;
+}
+
+static long ipu_get_manifest(struct ipu_psys_manifest *manifest,
+			     struct ipu_psys_fh *fh)
+{
+	struct ipu_psys *psys = fh->psys;
+	struct ipu_device *isp = psys->adev->isp;
+	struct ipu_cpd_client_pkg_hdr *client_pkg;
+	u32 entries;
+	void *host_fw_data;
+	dma_addr_t dma_fw_data;
+	u32 client_pkg_offset;
+
+	host_fw_data = (void *)isp->cpd_fw->data;
+	dma_fw_data = sg_dma_address(psys->fw_sgt.sgl);
+
+	entries = ipu_cpd_pkg_dir_get_num_entries(psys->pkg_dir);
+	if (!manifest || manifest->index > entries - 1) {
+		dev_err(&psys->adev->dev, "invalid argument\n");
+		return -EINVAL;
+	}
+
+	if (!ipu_cpd_pkg_dir_get_size(psys->pkg_dir, manifest->index) ||
+	    ipu_cpd_pkg_dir_get_type(psys->pkg_dir, manifest->index) <
+	    IPU_CPD_PKG_DIR_CLIENT_PG_TYPE) {
+		dev_dbg(&psys->adev->dev, "invalid pkg dir entry\n");
+		return -ENOENT;
+	}
+
+	client_pkg_offset = ipu_cpd_pkg_dir_get_address(psys->pkg_dir,
+							manifest->index);
+	client_pkg_offset -= dma_fw_data;
+
+	client_pkg = host_fw_data + client_pkg_offset;
+	manifest->size = client_pkg->pg_manifest_size;
+
+	if (!manifest->manifest)
+		return 0;
+
+	if (copy_to_user(manifest->manifest,
+			 (uint8_t *)client_pkg + client_pkg->pg_manifest_offs,
+			 manifest->size)) {
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+static long ipu_psys_ioctl(struct file *file, unsigned int cmd,
+			   unsigned long arg)
+{
+	union {
+		struct ipu_psys_buffer buf;
+		struct ipu_psys_command cmd;
+		struct ipu_psys_event ev;
+		struct ipu_psys_capability caps;
+		struct ipu_psys_manifest m;
+	} karg;
+	struct ipu_psys_fh *fh = file->private_data;
+	long err = 0;
+	void __user *up = (void __user *)arg;
+	bool copy = (cmd != IPU_IOC_MAPBUF && cmd != IPU_IOC_UNMAPBUF);
+
+	if (copy) {
+		if (_IOC_SIZE(cmd) > sizeof(karg))
+			return -ENOTTY;
+
+		if (_IOC_DIR(cmd) & _IOC_WRITE) {
+			err = copy_from_user(&karg, up, _IOC_SIZE(cmd));
+			if (err)
+				return -EFAULT;
+		}
+	}
+
+	switch (cmd) {
+	case IPU_IOC_MAPBUF:
+		err = ipu_psys_mapbuf(arg, fh);
+		break;
+	case IPU_IOC_UNMAPBUF:
+		err = ipu_psys_unmapbuf(arg, fh);
+		break;
+	case IPU_IOC_QUERYCAP:
+		karg.caps = fh->psys->caps;
+		break;
+	case IPU_IOC_GETBUF:
+		err = ipu_psys_getbuf(&karg.buf, fh);
+		break;
+	case IPU_IOC_PUTBUF:
+		err = ipu_psys_putbuf(&karg.buf, fh);
+		break;
+	case IPU_IOC_QCMD:
+		err = ipu_psys_kcmd_new(&karg.cmd, fh);
+		break;
+	case IPU_IOC_DQEVENT:
+		err = ipu_ioctl_dqevent(&karg.ev, fh, file->f_flags);
+		break;
+	case IPU_IOC_GET_MANIFEST:
+		err = ipu_get_manifest(&karg.m, fh);
+		break;
+	default:
+		err = -ENOTTY;
+		break;
+	}
+
+	if (err)
+		return err;
+
+	if (copy && _IOC_DIR(cmd) & _IOC_READ)
+		if (copy_to_user(up, &karg, _IOC_SIZE(cmd)))
+			return -EFAULT;
+
+	return 0;
+}
+
+static const struct file_operations ipu_psys_fops = {
+	.open = ipu_psys_open,
+	.release = ipu_psys_release,
+	.unlocked_ioctl = ipu_psys_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl = ipu_psys_compat_ioctl32,
+#endif
+	.poll = ipu_psys_poll,
+	.owner = THIS_MODULE,
+};
+
+static void ipu_psys_dev_release(struct device *dev)
+{
+}
+
+#ifdef CONFIG_PM
+static int psys_runtime_pm_resume(struct device *dev)
+{
+	struct ipu_bus_device *adev = to_ipu_bus_device(dev);
+	struct ipu_psys *psys = ipu_bus_get_drvdata(adev);
+	unsigned long flags;
+	int retval;
+
+	if (!psys)
+		return 0;
+
+	/*
+	 * In runtime autosuspend mode, if the psys is in power on state, no
+	 * need to resume again.
+	 */
+	spin_lock_irqsave(&psys->ready_lock, flags);
+	if (psys->ready) {
+		spin_unlock_irqrestore(&psys->ready_lock, flags);
+		return 0;
+	}
+	spin_unlock_irqrestore(&psys->ready_lock, flags);
+
+	retval = ipu_mmu_hw_init(adev->mmu);
+	if (retval)
+		return retval;
+
+	if (async_fw_init && !psys->fwcom) {
+		dev_err(dev,
+			"%s: asynchronous firmware init not finished, skipping\n",
+			__func__);
+		return 0;
+	}
+
+	if (!ipu_buttress_auth_done(adev->isp)) {
+		dev_dbg(dev, "%s: not yet authenticated, skipping\n", __func__);
+		return 0;
+	}
+
+	ipu_psys_setup_hw(psys);
+
+	ipu_psys_subdomains_power(psys, 1);
+	ipu_trace_restore(&psys->adev->dev);
+
+	ipu_configure_spc(adev->isp,
+			  &psys->pdata->ipdata->hw_variant,
+			  IPU_CPD_PKG_DIR_PSYS_SERVER_IDX,
+			  psys->pdata->base, psys->pkg_dir,
+			  psys->pkg_dir_dma_addr);
+
+	retval = ipu_fw_psys_open(psys);
+	if (retval) {
+		dev_err(&psys->adev->dev, "Failed to open abi.\n");
+		return retval;
+	}
+
+	spin_lock_irqsave(&psys->ready_lock, flags);
+	psys->ready = 1;
+	spin_unlock_irqrestore(&psys->ready_lock, flags);
+
+	return 0;
+}
+
+static int psys_runtime_pm_suspend(struct device *dev)
+{
+	struct ipu_bus_device *adev = to_ipu_bus_device(dev);
+	struct ipu_psys *psys = ipu_bus_get_drvdata(adev);
+	unsigned long flags;
+	int rval;
+
+	if (!psys)
+		return 0;
+
+	if (!psys->ready)
+		return 0;
+
+	spin_lock_irqsave(&psys->ready_lock, flags);
+	psys->ready = 0;
+	spin_unlock_irqrestore(&psys->ready_lock, flags);
+
+	/*
+	 * We can trace failure but better to not return an error.
+	 * At suspend we are progressing towards psys power gated state.
+	 * Any hang / failure inside psys will be forgotten soon.
+	 */
+	rval = ipu_fw_psys_close(psys);
+	if (rval)
+		dev_err(dev, "Device close failure: %d\n", rval);
+
+	ipu_psys_subdomains_power(psys, 0);
+
+	ipu_mmu_hw_cleanup(adev->mmu);
+
+	return 0;
+}
+
+/* The following PM callbacks are needed to enable runtime PM in IPU PCI
+ * device resume, otherwise, runtime PM can't work in PCI resume from
+ * S3 state.
+ */
+static int psys_resume(struct device *dev)
+{
+	return 0;
+}
+
+static int psys_suspend(struct device *dev)
+{
+	return 0;
+}
+
+static const struct dev_pm_ops psys_pm_ops = {
+	.runtime_suspend = psys_runtime_pm_suspend,
+	.runtime_resume = psys_runtime_pm_resume,
+	.suspend = psys_suspend,
+	.resume = psys_resume,
+};
+
+#define PSYS_PM_OPS (&psys_pm_ops)
+#else
+#define PSYS_PM_OPS NULL
+#endif
+
+static int cpd_fw_reload(struct ipu_device *isp)
+{
+	struct ipu_psys *psys = ipu_bus_get_drvdata(isp->psys);
+	int rval;
+
+	if (!isp->secure_mode) {
+		dev_warn(&isp->pdev->dev,
+			 "CPD firmware reload was only supported for secure mode.\n");
+		return -EINVAL;
+	}
+
+	if (isp->cpd_fw) {
+		ipu_cpd_free_pkg_dir(isp->psys, psys->pkg_dir,
+				     psys->pkg_dir_dma_addr,
+				     psys->pkg_dir_size);
+
+		ipu_buttress_unmap_fw_image(isp->psys, &psys->fw_sgt);
+		release_firmware(isp->cpd_fw);
+		isp->cpd_fw = NULL;
+		dev_info(&isp->pdev->dev, "Old FW removed\n");
+	}
+
+	rval = request_cpd_fw(&isp->cpd_fw, isp->cpd_fw_name,
+			      &isp->pdev->dev);
+	if (rval) {
+		dev_err(&isp->pdev->dev, "Requesting firmware(%s) failed\n",
+			isp->cpd_fw_name);
+		return rval;
+	}
+
+	rval = ipu_cpd_validate_cpd_file(isp, isp->cpd_fw->data,
+					 isp->cpd_fw->size);
+	if (rval) {
+		dev_err(&isp->pdev->dev, "Failed to validate cpd file\n");
+		goto out_release_firmware;
+	}
+
+	rval = ipu_buttress_map_fw_image(isp->psys, isp->cpd_fw, &psys->fw_sgt);
+	if (rval)
+		goto out_release_firmware;
+
+	psys->pkg_dir = ipu_cpd_create_pkg_dir(isp->psys,
+					       isp->cpd_fw->data,
+					       sg_dma_address(psys->fw_sgt.sgl),
+					       &psys->pkg_dir_dma_addr,
+					       &psys->pkg_dir_size);
+
+	if (!psys->pkg_dir) {
+		rval = -EINVAL;
+		goto out_unmap_fw_image;
+	}
+
+	isp->pkg_dir = psys->pkg_dir;
+	isp->pkg_dir_dma_addr = psys->pkg_dir_dma_addr;
+	isp->pkg_dir_size = psys->pkg_dir_size;
+
+	if (!isp->secure_mode)
+		return 0;
+
+	rval = ipu_fw_authenticate(isp, 1);
+	if (rval)
+		goto out_free_pkg_dir;
+
+	return 0;
+
+out_free_pkg_dir:
+	ipu_cpd_free_pkg_dir(isp->psys, psys->pkg_dir,
+			     psys->pkg_dir_dma_addr, psys->pkg_dir_size);
+out_unmap_fw_image:
+	ipu_buttress_unmap_fw_image(isp->psys, &psys->fw_sgt);
+out_release_firmware:
+	release_firmware(isp->cpd_fw);
+	isp->cpd_fw = NULL;
+
+	return rval;
+}
+
+#ifdef CONFIG_DEBUG_FS
+static int ipu_psys_icache_prefetch_sp_get(void *data, u64 *val)
+{
+	struct ipu_psys *psys = data;
+
+	*val = psys->icache_prefetch_sp;
+	return 0;
+}
+
+static int ipu_psys_icache_prefetch_sp_set(void *data, u64 val)
+{
+	struct ipu_psys *psys = data;
+
+	if (val != !!val)
+		return -EINVAL;
+
+	psys->icache_prefetch_sp = val;
+
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(psys_icache_prefetch_sp_fops,
+			ipu_psys_icache_prefetch_sp_get,
+			ipu_psys_icache_prefetch_sp_set, "%llu\n");
+
+static int ipu_psys_icache_prefetch_isp_get(void *data, u64 *val)
+{
+	struct ipu_psys *psys = data;
+
+	*val = psys->icache_prefetch_isp;
+	return 0;
+}
+
+static int ipu_psys_icache_prefetch_isp_set(void *data, u64 val)
+{
+	struct ipu_psys *psys = data;
+
+	if (val != !!val)
+		return -EINVAL;
+
+	psys->icache_prefetch_isp = val;
+
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(psys_icache_prefetch_isp_fops,
+			ipu_psys_icache_prefetch_isp_get,
+			ipu_psys_icache_prefetch_isp_set, "%llu\n");
+
+static int ipu_psys_init_debugfs(struct ipu_psys *psys)
+{
+	struct dentry *file;
+	struct dentry *dir;
+
+	dir = debugfs_create_dir("psys", psys->adev->isp->ipu_dir);
+	if (IS_ERR(dir))
+		return -ENOMEM;
+
+	file = debugfs_create_file("icache_prefetch_sp", 0600,
+				   dir, psys, &psys_icache_prefetch_sp_fops);
+	if (IS_ERR(file))
+		goto err;
+
+	file = debugfs_create_file("icache_prefetch_isp", 0600,
+				   dir, psys, &psys_icache_prefetch_isp_fops);
+	if (IS_ERR(file))
+		goto err;
+
+	psys->debugfsdir = dir;
+
+#ifdef IPU_PSYS_GPC
+	if (ipu_psys_gpc_init_debugfs(psys))
+		return -ENOMEM;
+#endif
+
+	return 0;
+err:
+	debugfs_remove_recursive(dir);
+	return -ENOMEM;
+}
+#endif
+
+static int ipu_psys_sched_cmd(void *ptr)
+{
+	struct ipu_psys *psys = ptr;
+	size_t pending = 0;
+
+	while (1) {
+		wait_event_interruptible(psys->sched_cmd_wq,
+					 (kthread_should_stop() ||
+					  (pending =
+					   atomic_read(&psys->wakeup_count))));
+
+		if (kthread_should_stop())
+			break;
+
+		if (pending == 0)
+			continue;
+
+		mutex_lock(&psys->mutex);
+		atomic_set(&psys->wakeup_count, 0);
+		ipu_psys_run_next(psys);
+		mutex_unlock(&psys->mutex);
+	}
+
+	return 0;
+}
+
+static void start_sp(struct ipu_bus_device *adev)
+{
+	struct ipu_psys *psys = ipu_bus_get_drvdata(adev);
+	void __iomem *spc_regs_base = psys->pdata->base +
+	    psys->pdata->ipdata->hw_variant.spc_offset;
+	u32 val = 0;
+
+	val |= IPU_PSYS_SPC_STATUS_START |
+	    IPU_PSYS_SPC_STATUS_RUN |
+	    IPU_PSYS_SPC_STATUS_CTRL_ICACHE_INVALIDATE;
+	val |= psys->icache_prefetch_sp ?
+	    IPU_PSYS_SPC_STATUS_ICACHE_PREFETCH : 0;
+	writel(val, spc_regs_base + IPU_PSYS_REG_SPC_STATUS_CTRL);
+}
+
+static int query_sp(struct ipu_bus_device *adev)
+{
+	struct ipu_psys *psys = ipu_bus_get_drvdata(adev);
+	void __iomem *spc_regs_base = psys->pdata->base +
+	    psys->pdata->ipdata->hw_variant.spc_offset;
+	u32 val = readl(spc_regs_base + IPU_PSYS_REG_SPC_STATUS_CTRL);
+
+	/* return true when READY == 1, START == 0 */
+	val &= IPU_PSYS_SPC_STATUS_READY | IPU_PSYS_SPC_STATUS_START;
+
+	return val == IPU_PSYS_SPC_STATUS_READY;
+}
+
+static int ipu_psys_fw_init(struct ipu_psys *psys)
+{
+	unsigned int size;
+	struct ipu_fw_syscom_queue_config *queue_cfg;
+	struct ipu_fw_syscom_queue_config fw_psys_event_queue_cfg[] = {
+		{
+			IPU_FW_PSYS_EVENT_QUEUE_SIZE,
+			sizeof(struct ipu_fw_psys_event)
+		}
+	};
+	struct ipu_fw_psys_srv_init server_init = {
+		.ddr_pkg_dir_address = 0,
+		.host_ddr_pkg_dir = NULL,
+		.pkg_dir_size = 0,
+		.icache_prefetch_sp = psys->icache_prefetch_sp,
+		.icache_prefetch_isp = psys->icache_prefetch_isp,
+	};
+	struct ipu_fw_com_cfg fwcom = {
+		.num_output_queues = IPU_FW_PSYS_N_PSYS_EVENT_QUEUE_ID,
+		.output = fw_psys_event_queue_cfg,
+		.specific_addr = &server_init,
+		.specific_size = sizeof(server_init),
+		.cell_start = start_sp,
+		.cell_ready = query_sp,
+		.buttress_boot_offset = SYSCOM_BUTTRESS_FW_PARAMS_PSYS_OFFSET,
+	};
+	int i;
+
+	size = IPU6SE_FW_PSYS_N_PSYS_CMD_QUEUE_ID;
+	if (ipu_ver == IPU_VER_6 || ipu_ver == IPU_VER_6EP || ipu_ver == IPU_VER_6EP_MTL)
+		size = IPU6_FW_PSYS_N_PSYS_CMD_QUEUE_ID;
+
+	queue_cfg = devm_kzalloc(&psys->adev->dev, sizeof(*queue_cfg) * size,
+				 GFP_KERNEL);
+	if (!queue_cfg)
+		return -ENOMEM;
+
+	for (i = 0; i < size; i++) {
+		queue_cfg[i].queue_size = IPU_FW_PSYS_CMD_QUEUE_SIZE;
+		queue_cfg[i].token_size = sizeof(struct ipu_fw_psys_cmd);
+	}
+
+	fwcom.input = queue_cfg;
+	fwcom.num_input_queues = size;
+	fwcom.dmem_addr = psys->pdata->ipdata->hw_variant.dmem_offset;
+
+	psys->fwcom = ipu_fw_com_prepare(&fwcom, psys->adev, psys->pdata->base);
+	if (!psys->fwcom) {
+		dev_err(&psys->adev->dev, "psys fw com prepare failed\n");
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static void run_fw_init_work(struct work_struct *work)
+{
+	struct fw_init_task *task = (struct fw_init_task *)work;
+	struct ipu_psys *psys = task->psys;
+	int rval;
+
+	rval = ipu_psys_fw_init(psys);
+
+	if (rval) {
+		dev_err(&psys->adev->dev, "FW init failed(%d)\n", rval);
+		ipu_psys_remove(psys->adev);
+	} else {
+		dev_info(&psys->adev->dev, "FW init done\n");
+	}
+}
+
+static int ipu_psys_probe(struct ipu_bus_device *adev)
+{
+	struct ipu_device *isp = adev->isp;
+	struct ipu_psys_pg *kpg, *kpg0;
+	struct ipu_psys *psys;
+	unsigned int minor;
+	int i, rval = -E2BIG;
+
+	/* firmware is not ready, so defer the probe */
+	if (!isp->pkg_dir)
+		return -EPROBE_DEFER;
+
+	rval = ipu_mmu_hw_init(adev->mmu);
+	if (rval)
+		return rval;
+
+	mutex_lock(&ipu_psys_mutex);
+
+	minor = find_next_zero_bit(ipu_psys_devices, IPU_PSYS_NUM_DEVICES, 0);
+	if (minor == IPU_PSYS_NUM_DEVICES) {
+		dev_err(&adev->dev, "too many devices\n");
+		goto out_unlock;
+	}
+
+	psys = devm_kzalloc(&adev->dev, sizeof(*psys), GFP_KERNEL);
+	if (!psys) {
+		rval = -ENOMEM;
+		goto out_unlock;
+	}
+
+	psys->adev = adev;
+	psys->pdata = adev->pdata;
+	psys->icache_prefetch_sp = 0;
+
+	psys->power_gating = 0;
+
+	ipu_trace_init(adev->isp, psys->pdata->base, &adev->dev,
+		       psys_trace_blocks);
+
+	cdev_init(&psys->cdev, &ipu_psys_fops);
+	psys->cdev.owner = ipu_psys_fops.owner;
+
+	rval = cdev_add(&psys->cdev, MKDEV(MAJOR(ipu_psys_dev_t), minor), 1);
+	if (rval) {
+		dev_err(&adev->dev, "cdev_add failed (%d)\n", rval);
+		goto out_unlock;
+	}
+
+	set_bit(minor, ipu_psys_devices);
+
+	spin_lock_init(&psys->ready_lock);
+	spin_lock_init(&psys->pgs_lock);
+	psys->ready = 0;
+	psys->timeout = IPU_PSYS_CMD_TIMEOUT_MS;
+
+	mutex_init(&psys->mutex);
+	INIT_LIST_HEAD(&psys->fhs);
+	INIT_LIST_HEAD(&psys->pgs);
+	INIT_LIST_HEAD(&psys->started_kcmds_list);
+
+	init_waitqueue_head(&psys->sched_cmd_wq);
+	atomic_set(&psys->wakeup_count, 0);
+	/*
+	 * Create a thread to schedule commands sent to IPU firmware.
+	 * The thread reduces the coupling between the command scheduler
+	 * and queueing commands from the user to driver.
+	 */
+	psys->sched_cmd_thread = kthread_run(ipu_psys_sched_cmd, psys,
+					     "psys_sched_cmd");
+
+	if (IS_ERR(psys->sched_cmd_thread)) {
+		psys->sched_cmd_thread = NULL;
+		mutex_destroy(&psys->mutex);
+		goto out_unlock;
+	}
+
+	ipu_bus_set_drvdata(adev, psys);
+
+	rval = ipu_psys_resource_pool_init(&psys->resource_pool_running);
+	if (rval < 0) {
+		dev_err(&psys->dev,
+			"unable to alloc process group resources\n");
+		goto out_mutex_destroy;
+	}
+
+	ipu6_psys_hw_res_variant_init();
+	psys->pkg_dir = isp->pkg_dir;
+	psys->pkg_dir_dma_addr = isp->pkg_dir_dma_addr;
+	psys->pkg_dir_size = isp->pkg_dir_size;
+	psys->fw_sgt = isp->fw_sgt;
+
+	/* allocate and map memory for process groups */
+	for (i = 0; i < IPU_PSYS_PG_POOL_SIZE; i++) {
+		kpg = kzalloc(sizeof(*kpg), GFP_KERNEL);
+		if (!kpg)
+			goto out_free_pgs;
+		kpg->pg = dma_alloc_attrs(&adev->dev,
+					  IPU_PSYS_PG_MAX_SIZE,
+					  &kpg->pg_dma_addr,
+					  GFP_KERNEL, 0);
+		if (!kpg->pg) {
+			kfree(kpg);
+			goto out_free_pgs;
+		}
+		kpg->size = IPU_PSYS_PG_MAX_SIZE;
+		list_add(&kpg->list, &psys->pgs);
+	}
+
+	psys->caps.pg_count = ipu_cpd_pkg_dir_get_num_entries(psys->pkg_dir);
+
+	dev_info(&adev->dev, "pkg_dir entry count:%d\n", psys->caps.pg_count);
+	if (async_fw_init) {
+		INIT_DELAYED_WORK((struct delayed_work *)&fw_init_task,
+				  run_fw_init_work);
+		fw_init_task.psys = psys;
+		schedule_delayed_work((struct delayed_work *)&fw_init_task, 0);
+	} else {
+		rval = ipu_psys_fw_init(psys);
+	}
+
+	if (rval) {
+		dev_err(&adev->dev, "FW init failed(%d)\n", rval);
+		goto out_free_pgs;
+	}
+
+	psys->dev.parent = &adev->dev;
+	psys->dev.bus = &ipu_psys_bus;
+	psys->dev.devt = MKDEV(MAJOR(ipu_psys_dev_t), minor);
+	psys->dev.release = ipu_psys_dev_release;
+	dev_set_name(&psys->dev, "ipu-psys%d", minor);
+	rval = device_register(&psys->dev);
+	if (rval < 0) {
+		dev_err(&psys->dev, "psys device_register failed\n");
+		goto out_release_fw_com;
+	}
+
+	/* Add the hw stepping information to caps */
+	strlcpy(psys->caps.dev_model, IPU_MEDIA_DEV_MODEL_NAME,
+		sizeof(psys->caps.dev_model));
+
+	pm_runtime_set_autosuspend_delay(&psys->adev->dev,
+					 IPU_PSYS_AUTOSUSPEND_DELAY);
+	pm_runtime_use_autosuspend(&psys->adev->dev);
+	pm_runtime_mark_last_busy(&psys->adev->dev);
+
+	mutex_unlock(&ipu_psys_mutex);
+
+#ifdef CONFIG_DEBUG_FS
+	/* Debug fs failure is not fatal. */
+	ipu_psys_init_debugfs(psys);
+#endif
+
+	adev->isp->cpd_fw_reload = &cpd_fw_reload;
+
+	dev_info(&adev->dev, "psys probe minor: %d\n", minor);
+
+	ipu_mmu_hw_cleanup(adev->mmu);
+
+	return 0;
+
+out_release_fw_com:
+	ipu_fw_com_release(psys->fwcom, 1);
+out_free_pgs:
+	list_for_each_entry_safe(kpg, kpg0, &psys->pgs, list) {
+		dma_free_attrs(&adev->dev, kpg->size, kpg->pg,
+			       kpg->pg_dma_addr, 0);
+		kfree(kpg);
+	}
+
+	ipu_psys_resource_pool_cleanup(&psys->resource_pool_running);
+out_mutex_destroy:
+	mutex_destroy(&psys->mutex);
+	cdev_del(&psys->cdev);
+	if (psys->sched_cmd_thread) {
+		kthread_stop(psys->sched_cmd_thread);
+		psys->sched_cmd_thread = NULL;
+	}
+out_unlock:
+	/* Safe to call even if the init is not called */
+	ipu_trace_uninit(&adev->dev);
+	mutex_unlock(&ipu_psys_mutex);
+
+	ipu_mmu_hw_cleanup(adev->mmu);
+
+	return rval;
+}
+
+static void ipu_psys_remove(struct ipu_bus_device *adev)
+{
+	struct ipu_device *isp = adev->isp;
+	struct ipu_psys *psys = ipu_bus_get_drvdata(adev);
+	struct ipu_psys_pg *kpg, *kpg0;
+
+#ifdef CONFIG_DEBUG_FS
+	if (isp->ipu_dir)
+		debugfs_remove_recursive(psys->debugfsdir);
+#endif
+
+	if (psys->sched_cmd_thread) {
+		kthread_stop(psys->sched_cmd_thread);
+		psys->sched_cmd_thread = NULL;
+	}
+
+	pm_runtime_dont_use_autosuspend(&psys->adev->dev);
+
+	mutex_lock(&ipu_psys_mutex);
+
+	list_for_each_entry_safe(kpg, kpg0, &psys->pgs, list) {
+		dma_free_attrs(&adev->dev, kpg->size, kpg->pg,
+			       kpg->pg_dma_addr, 0);
+		kfree(kpg);
+	}
+
+	if (psys->fwcom && ipu_fw_com_release(psys->fwcom, 1))
+		dev_err(&adev->dev, "fw com release failed.\n");
+
+	kfree(psys->server_init);
+	kfree(psys->syscom_config);
+
+	ipu_trace_uninit(&adev->dev);
+
+	ipu_psys_resource_pool_cleanup(&psys->resource_pool_running);
+
+	device_unregister(&psys->dev);
+
+	clear_bit(MINOR(psys->cdev.dev), ipu_psys_devices);
+	cdev_del(&psys->cdev);
+
+	mutex_unlock(&ipu_psys_mutex);
+
+	mutex_destroy(&psys->mutex);
+
+	dev_info(&adev->dev, "removed\n");
+}
+
+static irqreturn_t psys_isr_threaded(struct ipu_bus_device *adev)
+{
+	struct ipu_psys *psys = ipu_bus_get_drvdata(adev);
+	void __iomem *base = psys->pdata->base;
+	u32 status;
+	int r;
+
+	mutex_lock(&psys->mutex);
+#ifdef CONFIG_PM
+	r = pm_runtime_get_if_in_use(&psys->adev->dev);
+	if (!r || WARN_ON_ONCE(r < 0)) {
+		mutex_unlock(&psys->mutex);
+		return IRQ_NONE;
+	}
+#endif
+
+	status = readl(base + IPU_REG_PSYS_GPDEV_IRQ_STATUS);
+	writel(status, base + IPU_REG_PSYS_GPDEV_IRQ_CLEAR);
+
+	if (status & IPU_PSYS_GPDEV_IRQ_FWIRQ(IPU_PSYS_GPDEV_FWIRQ0)) {
+		writel(0, base + IPU_REG_PSYS_GPDEV_FWIRQ(0));
+		ipu_psys_handle_events(psys);
+	}
+
+	pm_runtime_mark_last_busy(&psys->adev->dev);
+	pm_runtime_put_autosuspend(&psys->adev->dev);
+	mutex_unlock(&psys->mutex);
+
+	return status ? IRQ_HANDLED : IRQ_NONE;
+}
+
+static struct ipu_bus_driver ipu_psys_driver = {
+	.probe = ipu_psys_probe,
+	.remove = ipu_psys_remove,
+	.isr_threaded = psys_isr_threaded,
+	.wanted = IPU_PSYS_NAME,
+	.drv = {
+		.name = IPU_PSYS_NAME,
+		.owner = THIS_MODULE,
+		.pm = PSYS_PM_OPS,
+		.probe_type = PROBE_PREFER_ASYNCHRONOUS,
+	},
+};
+
+static int __init ipu_psys_init(void)
+{
+	int rval = alloc_chrdev_region(&ipu_psys_dev_t, 0,
+				       IPU_PSYS_NUM_DEVICES, IPU_PSYS_NAME);
+	if (rval) {
+		pr_err("can't alloc psys chrdev region (%d)\n", rval);
+		return rval;
+	}
+
+	rval = bus_register(&ipu_psys_bus);
+	if (rval) {
+		pr_warn("can't register psys bus (%d)\n", rval);
+		goto out_bus_register;
+	}
+
+	ipu_bus_register_driver(&ipu_psys_driver);
+
+	return rval;
+
+out_bus_register:
+	unregister_chrdev_region(ipu_psys_dev_t, IPU_PSYS_NUM_DEVICES);
+
+	return rval;
+}
+
+static void __exit ipu_psys_exit(void)
+{
+	ipu_bus_unregister_driver(&ipu_psys_driver);
+	bus_unregister(&ipu_psys_bus);
+	unregister_chrdev_region(ipu_psys_dev_t, IPU_PSYS_NUM_DEVICES);
+}
+
+static const struct pci_device_id ipu_pci_tbl[] = {
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, IPU6_PCI_ID)},
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, IPU6SE_PCI_ID)},
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, IPU6EP_ADL_P_PCI_ID)},
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, IPU6EP_ADL_N_PCI_ID)},
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, IPU6EP_RPL_P_PCI_ID)},
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, IPU6EP_MTL_PCI_ID)},
+	{0,}
+};
+MODULE_DEVICE_TABLE(pci, ipu_pci_tbl);
+
+module_init(ipu_psys_init);
+module_exit(ipu_psys_exit);
+
+MODULE_AUTHOR("Antti Laakso <antti.laakso@intel.com>");
+MODULE_AUTHOR("Bin Han <bin.b.han@intel.com>");
+MODULE_AUTHOR("Renwei Wu <renwei.wu@intel.com>");
+MODULE_AUTHOR("Jianxu Zheng <jian.xu.zheng@intel.com>");
+MODULE_AUTHOR("Xia Wu <xia.wu@intel.com>");
+MODULE_AUTHOR("Bingbu Cao <bingbu.cao@intel.com>");
+MODULE_AUTHOR("Zaikuo Wang <zaikuo.wang@intel.com>");
+MODULE_AUTHOR("Yunliang Ding <yunliang.ding@intel.com>");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Intel ipu processing system driver");
+MODULE_IMPORT_NS(DMA_BUF);
Index: b/drivers/media/pci/intel/ipu-psys.h
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu-psys.h
@@ -0,0 +1,216 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2013 - 2020 Intel Corporation */
+
+#ifndef IPU_PSYS_H
+#define IPU_PSYS_H
+
+#include <linux/cdev.h>
+#include <linux/workqueue.h>
+
+#include "ipu.h"
+#include "ipu-pdata.h"
+#include "ipu-fw-psys.h"
+#include "ipu-platform-psys.h"
+
+#define IPU_PSYS_PG_POOL_SIZE 16
+#define IPU_PSYS_PG_MAX_SIZE 8192
+#define IPU_MAX_PSYS_CMD_BUFFERS 32
+#define IPU_PSYS_EVENT_CMD_COMPLETE IPU_FW_PSYS_EVENT_TYPE_SUCCESS
+#define IPU_PSYS_EVENT_FRAGMENT_COMPLETE IPU_FW_PSYS_EVENT_TYPE_SUCCESS
+#define IPU_PSYS_CLOSE_TIMEOUT_US   50
+#define IPU_PSYS_CLOSE_TIMEOUT (100000 / IPU_PSYS_CLOSE_TIMEOUT_US)
+#define IPU_MAX_RESOURCES 128
+
+/* Opaque structure. Do not access fields. */
+struct ipu_resource {
+	u32 id;
+	int elements;	/* Number of elements available to allocation */
+	unsigned long *bitmap;	/* Allocation bitmap, a bit for each element */
+};
+
+enum ipu_resource_type {
+	IPU_RESOURCE_DEV_CHN = 0,
+	IPU_RESOURCE_EXT_MEM,
+	IPU_RESOURCE_DFM
+};
+
+/* Allocation of resource(s) */
+/* Opaque structure. Do not access fields. */
+struct ipu_resource_alloc {
+	enum ipu_resource_type type;
+	struct ipu_resource *resource;
+	int elements;
+	int pos;
+};
+
+/*
+ * This struct represents all of the currently allocated
+ * resources from IPU model. It is used also for allocating
+ * resources for the next set of PGs to be run on IPU
+ * (ie. those PGs which are not yet being run and which don't
+ * yet reserve real IPU resources).
+ * Use larger array to cover existing resource quantity
+ */
+
+/* resource size may need expand for new resource model */
+struct ipu_psys_resource_pool {
+	u32 cells;	/* Bitmask of cells allocated */
+	struct ipu_resource dev_channels[16];
+	struct ipu_resource ext_memory[32];
+	struct ipu_resource dfms[16];
+	DECLARE_BITMAP(cmd_queues, 32);
+	/* Protects cmd_queues bitmap */
+	spinlock_t queues_lock;
+};
+
+/*
+ * This struct keeps book of the resources allocated for a specific PG.
+ * It is used for freeing up resources from struct ipu_psys_resources
+ * when the PG is released from IPU (or model of IPU).
+ */
+struct ipu_psys_resource_alloc {
+	u32 cells;	/* Bitmask of cells needed */
+	struct ipu_resource_alloc
+	 resource_alloc[IPU_MAX_RESOURCES];
+	int resources;
+};
+
+struct task_struct;
+struct ipu_psys {
+	struct ipu_psys_capability caps;
+	struct cdev cdev;
+	struct device dev;
+
+	struct mutex mutex;	/* Psys various */
+	int ready; /* psys fw status */
+	bool icache_prefetch_sp;
+	bool icache_prefetch_isp;
+	spinlock_t ready_lock;	/* protect psys firmware state */
+	spinlock_t pgs_lock;	/* Protect pgs list access */
+	struct list_head fhs;
+	struct list_head pgs;
+	struct list_head started_kcmds_list;
+	struct ipu_psys_pdata *pdata;
+	struct ipu_bus_device *adev;
+	struct ia_css_syscom_context *dev_ctx;
+	struct ia_css_syscom_config *syscom_config;
+	struct ia_css_psys_server_init *server_init;
+	struct task_struct *sched_cmd_thread;
+	wait_queue_head_t sched_cmd_wq;
+	atomic_t wakeup_count;  /* Psys schedule thread wakeup count */
+#ifdef CONFIG_DEBUG_FS
+	struct dentry *debugfsdir;
+#endif
+
+	/* Resources needed to be managed for process groups */
+	struct ipu_psys_resource_pool resource_pool_running;
+
+	const struct firmware *fw;
+	struct sg_table fw_sgt;
+	u64 *pkg_dir;
+	dma_addr_t pkg_dir_dma_addr;
+	unsigned int pkg_dir_size;
+	unsigned long timeout;
+
+	int active_kcmds, started_kcmds;
+	void *fwcom;
+
+	int power_gating;
+};
+
+struct ipu_psys_fh {
+	struct ipu_psys *psys;
+	struct mutex mutex;	/* Protects bufmap & kcmds fields */
+	struct list_head list;
+	struct list_head bufmap;
+	wait_queue_head_t wait;
+	struct ipu_psys_scheduler sched;
+};
+
+struct ipu_psys_pg {
+	struct ipu_fw_psys_process_group *pg;
+	size_t size;
+	size_t pg_size;
+	dma_addr_t pg_dma_addr;
+	struct list_head list;
+	struct ipu_psys_resource_alloc resource_alloc;
+};
+
+struct ipu_psys_kcmd {
+	struct ipu_psys_fh *fh;
+	struct list_head list;
+	struct ipu_psys_buffer_set *kbuf_set;
+	enum ipu_psys_cmd_state state;
+	void *pg_manifest;
+	size_t pg_manifest_size;
+	struct ipu_psys_kbuffer **kbufs;
+	struct ipu_psys_buffer *buffers;
+	size_t nbuffers;
+	struct ipu_fw_psys_process_group *pg_user;
+	struct ipu_psys_pg *kpg;
+	u64 user_token;
+	u64 issue_id;
+	u32 priority;
+	u32 kernel_enable_bitmap[4];
+	u32 terminal_enable_bitmap[4];
+	u32 routing_enable_bitmap[4];
+	u32 rbm[5];
+	struct ipu_buttress_constraint constraint;
+	struct ipu_psys_event ev;
+	struct timer_list watchdog;
+};
+
+struct ipu_dma_buf_attach {
+	struct device *dev;
+	u64 len;
+	void *userptr;
+	struct sg_table *sgt;
+	bool vma_is_io;
+	struct page **pages;
+	size_t npages;
+};
+
+struct ipu_psys_kbuffer {
+	u64 len;
+	void *userptr;
+	u32 flags;
+	int fd;
+	void *kaddr;
+	struct list_head list;
+	dma_addr_t dma_addr;
+	struct sg_table *sgt;
+	struct dma_buf_attachment *db_attach;
+	struct dma_buf *dbuf;
+	bool valid;	/* True when buffer is usable */
+};
+
+#define inode_to_ipu_psys(inode) \
+	container_of((inode)->i_cdev, struct ipu_psys, cdev)
+
+#ifdef CONFIG_COMPAT
+long ipu_psys_compat_ioctl32(struct file *file, unsigned int cmd,
+			     unsigned long arg);
+#endif
+
+void ipu_psys_setup_hw(struct ipu_psys *psys);
+void ipu_psys_subdomains_power(struct ipu_psys *psys, bool on);
+void ipu_psys_handle_events(struct ipu_psys *psys);
+int ipu_psys_kcmd_new(struct ipu_psys_command *cmd, struct ipu_psys_fh *fh);
+void ipu_psys_run_next(struct ipu_psys *psys);
+struct ipu_psys_pg *__get_pg_buf(struct ipu_psys *psys, size_t pg_size);
+struct ipu_psys_kbuffer *
+ipu_psys_lookup_kbuffer(struct ipu_psys_fh *fh, int fd);
+int ipu_psys_mapbuf_locked(int fd, struct ipu_psys_fh *fh,
+			   struct ipu_psys_kbuffer *kbuf);
+struct ipu_psys_kbuffer *
+ipu_psys_lookup_kbuffer_by_kaddr(struct ipu_psys_fh *fh, void *kaddr);
+#ifdef IPU_PSYS_GPC
+int ipu_psys_gpc_init_debugfs(struct ipu_psys *psys);
+#endif
+int ipu_psys_resource_pool_init(struct ipu_psys_resource_pool *pool);
+void ipu_psys_resource_pool_cleanup(struct ipu_psys_resource_pool *pool);
+struct ipu_psys_kcmd *ipu_get_completed_kcmd(struct ipu_psys_fh *fh);
+long ipu_ioctl_dqevent(struct ipu_psys_event *event,
+		       struct ipu_psys_fh *fh, unsigned int f_flags);
+
+#endif /* IPU_PSYS_H */
Index: b/drivers/media/pci/intel/ipu-trace.c
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu-trace.c
@@ -0,0 +1,910 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) 2014 - 2021 Intel Corporation
+
+#include <linux/debugfs.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/sizes.h>
+#include <linux/uaccess.h>
+#include <linux/vmalloc.h>
+
+#include "ipu.h"
+#include "ipu-platform-regs.h"
+#include "ipu-trace.h"
+
+/*
+ * enabling ipu trace need a 96 MB buffer.
+ */
+static bool ipu_trace_enable;
+module_param(ipu_trace_enable, bool, 0660);
+MODULE_PARM_DESC(ipu_trace_enable, "IPU trace enable");
+
+struct trace_register_range {
+	u32 start;
+	u32 end;
+};
+
+#define MEMORY_RING_BUFFER_SIZE		(SZ_1M * 96)
+#define TRACE_MESSAGE_SIZE		16
+/*
+ * It looks that the trace unit sometimes writes outside the given buffer.
+ * To avoid memory corruption one extra page is reserved at the end
+ * of the buffer. Read also the extra area since it may contain valid data.
+ */
+#define MEMORY_RING_BUFFER_GUARD	PAGE_SIZE
+#define MEMORY_RING_BUFFER_OVERREAD	MEMORY_RING_BUFFER_GUARD
+#define MAX_TRACE_REGISTERS		200
+#define TRACE_CONF_DUMP_BUFFER_SIZE	(MAX_TRACE_REGISTERS * 2 * 32)
+#define TRACE_CONF_DATA_MAX_LEN		(1024 * 4)
+#define WPT_TRACE_CONF_DATA_MAX_LEN	(1024 * 64)
+
+struct config_value {
+	u32 reg;
+	u32 value;
+};
+
+struct ipu_trace_buffer {
+	dma_addr_t dma_handle;
+	void *memory_buffer;
+};
+
+struct ipu_subsystem_wptrace_config {
+	bool open;
+	char *conf_dump_buffer;
+	int size_conf_dump;
+	unsigned int fill_level;
+	struct config_value config[MAX_TRACE_REGISTERS];
+};
+
+struct ipu_subsystem_trace_config {
+	u32 offset;
+	void __iomem *base;
+	struct ipu_trace_buffer memory;	/* ring buffer */
+	struct device *dev;
+	struct ipu_trace_block *blocks;
+	unsigned int fill_level;	/* Nbr of regs in config table below */
+	bool running;
+	/* Cached register values  */
+	struct config_value config[MAX_TRACE_REGISTERS];
+	/* watchpoint trace info */
+	struct ipu_subsystem_wptrace_config wpt;
+};
+
+struct ipu_trace {
+	struct mutex lock; /* Protect ipu trace operations */
+	bool open;
+	char *conf_dump_buffer;
+	int size_conf_dump;
+
+	struct ipu_subsystem_trace_config isys;
+	struct ipu_subsystem_trace_config psys;
+};
+
+static void __ipu_trace_restore(struct device *dev)
+{
+	struct ipu_bus_device *adev = to_ipu_bus_device(dev);
+	struct ipu_device *isp = adev->isp;
+	struct ipu_trace *trace = isp->trace;
+	struct config_value *config;
+	struct ipu_subsystem_trace_config *sys = adev->trace_cfg;
+	struct ipu_trace_block *blocks;
+	u32 mapped_trace_buffer;
+	void __iomem *addr = NULL;
+	int i;
+
+	if (trace->open) {
+		dev_info(dev, "Trace control file open. Skipping update\n");
+		return;
+	}
+
+	if (!sys)
+		return;
+
+	/* leave if no trace configuration for this subsystem */
+	if (sys->fill_level == 0)
+		return;
+
+	/* Find trace unit base address */
+	blocks = sys->blocks;
+	while (blocks->type != IPU_TRACE_BLOCK_END) {
+		if (blocks->type == IPU_TRACE_BLOCK_TUN) {
+			addr = sys->base + blocks->offset;
+			break;
+		}
+		blocks++;
+	}
+	if (!addr)
+		return;
+
+	if (!sys->memory.memory_buffer) {
+		sys->memory.memory_buffer =
+		    dma_alloc_coherent(dev, MEMORY_RING_BUFFER_SIZE +
+				       MEMORY_RING_BUFFER_GUARD,
+				       &sys->memory.dma_handle,
+				       GFP_KERNEL);
+	}
+
+	if (!sys->memory.memory_buffer) {
+		dev_err(dev, "No memory for tracing. Trace unit disabled\n");
+		return;
+	}
+
+	config = sys->config;
+	mapped_trace_buffer = sys->memory.dma_handle;
+
+	/* ring buffer base */
+	writel(mapped_trace_buffer, addr + TRACE_REG_TUN_DRAM_BASE_ADDR);
+
+	/* ring buffer end */
+	writel(mapped_trace_buffer + MEMORY_RING_BUFFER_SIZE -
+		   TRACE_MESSAGE_SIZE, addr + TRACE_REG_TUN_DRAM_END_ADDR);
+
+	/* Infobits for ddr trace */
+	writel(IPU_INFO_REQUEST_DESTINATION_PRIMARY,
+	       addr + TRACE_REG_TUN_DDR_INFO_VAL);
+
+	/* Find trace timer reset address */
+	addr = NULL;
+	blocks = sys->blocks;
+	while (blocks->type != IPU_TRACE_BLOCK_END) {
+		if (blocks->type == IPU_TRACE_TIMER_RST) {
+			addr = sys->base + blocks->offset;
+			break;
+		}
+		blocks++;
+	}
+	if (!addr) {
+		dev_err(dev, "No trace reset addr\n");
+		return;
+	}
+
+	/* Remove reset from trace timers */
+	writel(TRACE_REG_GPREG_TRACE_TIMER_RST_OFF, addr);
+
+	/* Register config received from userspace */
+	for (i = 0; i < sys->fill_level; i++) {
+		dev_dbg(dev,
+			"Trace restore: reg 0x%08x, value 0x%08x\n",
+			config[i].reg, config[i].value);
+		writel(config[i].value, isp->base + config[i].reg);
+	}
+
+	/* Register wpt config received from userspace, and only psys has wpt */
+	config = sys->wpt.config;
+	for (i = 0; i < sys->wpt.fill_level; i++) {
+		dev_dbg(dev, "Trace restore: reg 0x%08x, value 0x%08x\n",
+			config[i].reg, config[i].value);
+		writel(config[i].value, isp->base + config[i].reg);
+	}
+	sys->running = true;
+}
+
+void ipu_trace_restore(struct device *dev)
+{
+	struct ipu_trace *trace = to_ipu_bus_device(dev)->isp->trace;
+
+	if (!trace)
+		return;
+
+	mutex_lock(&trace->lock);
+	__ipu_trace_restore(dev);
+	mutex_unlock(&trace->lock);
+}
+EXPORT_SYMBOL_GPL(ipu_trace_restore);
+
+static void __ipu_trace_stop(struct device *dev)
+{
+	struct ipu_subsystem_trace_config *sys =
+	    to_ipu_bus_device(dev)->trace_cfg;
+	struct ipu_trace_block *blocks;
+
+	if (!sys)
+		return;
+
+	if (!sys->running)
+		return;
+	sys->running = false;
+
+	/* Turn off all the gpc blocks */
+	blocks = sys->blocks;
+	while (blocks->type != IPU_TRACE_BLOCK_END) {
+		if (blocks->type == IPU_TRACE_BLOCK_GPC) {
+			writel(0, sys->base + blocks->offset +
+				   TRACE_REG_GPC_OVERALL_ENABLE);
+		}
+		blocks++;
+	}
+
+	/* Turn off all the trace monitors */
+	blocks = sys->blocks;
+	while (blocks->type != IPU_TRACE_BLOCK_END) {
+		if (blocks->type == IPU_TRACE_BLOCK_TM) {
+			writel(0, sys->base + blocks->offset +
+				   TRACE_REG_TM_TRACE_ENABLE_NPK);
+
+			writel(0, sys->base + blocks->offset +
+				   TRACE_REG_TM_TRACE_ENABLE_DDR);
+		}
+		blocks++;
+	}
+
+	/* Turn off trace units */
+	blocks = sys->blocks;
+	while (blocks->type != IPU_TRACE_BLOCK_END) {
+		if (blocks->type == IPU_TRACE_BLOCK_TUN) {
+			writel(0, sys->base + blocks->offset +
+				   TRACE_REG_TUN_DDR_ENABLE);
+			writel(0, sys->base + blocks->offset +
+				   TRACE_REG_TUN_NPK_ENABLE);
+		}
+		blocks++;
+	}
+}
+
+void ipu_trace_stop(struct device *dev)
+{
+	struct ipu_trace *trace = to_ipu_bus_device(dev)->isp->trace;
+
+	if (!trace)
+		return;
+
+	mutex_lock(&trace->lock);
+	__ipu_trace_stop(dev);
+	mutex_unlock(&trace->lock);
+}
+EXPORT_SYMBOL_GPL(ipu_trace_stop);
+
+static int update_register_cache(struct ipu_device *isp, u32 reg, u32 value)
+{
+	struct ipu_trace *dctrl = isp->trace;
+	struct ipu_subsystem_trace_config *sys;
+	int rval = -EINVAL;
+
+	if (dctrl->isys.offset == dctrl->psys.offset) {
+		/* For the IPU with uniform address space */
+		if (reg >= IPU_ISYS_OFFSET &&
+		    reg < IPU_ISYS_OFFSET + TRACE_REG_MAX_ISYS_OFFSET)
+			sys = &dctrl->isys;
+		else if (reg >= IPU_PSYS_OFFSET &&
+			 reg < IPU_PSYS_OFFSET + TRACE_REG_MAX_PSYS_OFFSET)
+			sys = &dctrl->psys;
+		else
+			goto error;
+	} else {
+		if (dctrl->isys.offset &&
+		    reg >= dctrl->isys.offset &&
+		    reg < dctrl->isys.offset + TRACE_REG_MAX_ISYS_OFFSET)
+			sys = &dctrl->isys;
+		else if (dctrl->psys.offset &&
+			 reg >= dctrl->psys.offset &&
+			 reg < dctrl->psys.offset + TRACE_REG_MAX_PSYS_OFFSET)
+			sys = &dctrl->psys;
+		else
+			goto error;
+	}
+
+	if (sys->fill_level < MAX_TRACE_REGISTERS) {
+		dev_dbg(sys->dev,
+			"Trace reg addr 0x%08x value 0x%08x\n", reg, value);
+		sys->config[sys->fill_level].reg = reg;
+		sys->config[sys->fill_level].value = value;
+		sys->fill_level++;
+	} else {
+		rval = -ENOMEM;
+		goto error;
+	}
+	return 0;
+error:
+	dev_info(&isp->pdev->dev,
+		 "Trace register address 0x%08x ignored as invalid register\n",
+		 reg);
+	return rval;
+}
+
+static void traceconf_dump(struct ipu_device *isp)
+{
+	struct ipu_subsystem_trace_config *sys[2] = {
+		&isp->trace->isys,
+		&isp->trace->psys
+	};
+	int i, j, rem_size;
+	char *out;
+
+	isp->trace->size_conf_dump = 0;
+	out = isp->trace->conf_dump_buffer;
+	rem_size = TRACE_CONF_DUMP_BUFFER_SIZE;
+
+	for (j = 0; j < ARRAY_SIZE(sys); j++) {
+		for (i = 0; i < sys[j]->fill_level && rem_size > 0; i++) {
+			int bytes_print;
+			int n = snprintf(out, rem_size, "0x%08x = 0x%08x\n",
+					 sys[j]->config[i].reg,
+					 sys[j]->config[i].value);
+
+			bytes_print = min(n, rem_size - 1);
+			rem_size -= bytes_print;
+			out += bytes_print;
+		}
+	}
+	isp->trace->size_conf_dump = out - isp->trace->conf_dump_buffer;
+}
+
+static void clear_trace_buffer(struct ipu_subsystem_trace_config *sys)
+{
+	if (!sys->memory.memory_buffer)
+		return;
+
+	memset(sys->memory.memory_buffer, 0, MEMORY_RING_BUFFER_SIZE +
+	       MEMORY_RING_BUFFER_OVERREAD);
+
+	dma_sync_single_for_device(sys->dev,
+				   sys->memory.dma_handle,
+				   MEMORY_RING_BUFFER_SIZE +
+				   MEMORY_RING_BUFFER_GUARD, DMA_FROM_DEVICE);
+}
+
+static int traceconf_open(struct inode *inode, struct file *file)
+{
+	int ret;
+	struct ipu_device *isp;
+
+	if (!inode->i_private)
+		return -EACCES;
+
+	isp = inode->i_private;
+
+	ret = mutex_trylock(&isp->trace->lock);
+	if (!ret)
+		return -EBUSY;
+
+	if (isp->trace->open) {
+		mutex_unlock(&isp->trace->lock);
+		return -EBUSY;
+	}
+
+	file->private_data = isp;
+	isp->trace->open = 1;
+	if (file->f_mode & FMODE_WRITE) {
+		/* TBD: Allocate temp buffer for processing.
+		 * Push validated buffer to active config
+		 */
+
+		/* Forget old config if opened for write */
+		isp->trace->isys.fill_level = 0;
+		isp->trace->psys.fill_level = 0;
+		isp->trace->psys.wpt.fill_level = 0;
+	}
+
+	if (file->f_mode & FMODE_READ) {
+		isp->trace->conf_dump_buffer =
+		    vzalloc(TRACE_CONF_DUMP_BUFFER_SIZE);
+		if (!isp->trace->conf_dump_buffer) {
+			isp->trace->open = 0;
+			mutex_unlock(&isp->trace->lock);
+			return -ENOMEM;
+		}
+		traceconf_dump(isp);
+	}
+	mutex_unlock(&isp->trace->lock);
+	return 0;
+}
+
+static ssize_t traceconf_read(struct file *file, char __user *buf,
+			      size_t len, loff_t *ppos)
+{
+	struct ipu_device *isp = file->private_data;
+
+	return simple_read_from_buffer(buf, len, ppos,
+				       isp->trace->conf_dump_buffer,
+				       isp->trace->size_conf_dump);
+}
+
+static ssize_t traceconf_write(struct file *file, const char __user *buf,
+			       size_t len, loff_t *ppos)
+{
+	int i;
+	struct ipu_device *isp = file->private_data;
+	ssize_t bytes = 0;
+	char *ipu_trace_buffer = NULL;
+	size_t buffer_size = 0;
+	u32 ipu_trace_number = 0;
+	struct config_value *cfg_buffer = NULL;
+
+	if ((*ppos < 0) || (len > TRACE_CONF_DATA_MAX_LEN) ||
+	    (len < sizeof(ipu_trace_number))) {
+		dev_info(&isp->pdev->dev,
+			"length is error, len:%ld, loff:%lld\n",
+			len, *ppos);
+		return -EINVAL;
+	}
+
+	ipu_trace_buffer = vzalloc(len);
+	if (!ipu_trace_buffer)
+		return -ENOMEM;
+
+	bytes = copy_from_user(ipu_trace_buffer, buf, len);
+	if (bytes != 0) {
+		vfree(ipu_trace_buffer);
+		return -EFAULT;
+	}
+
+	memcpy(&ipu_trace_number, ipu_trace_buffer, sizeof(u32));
+	buffer_size = ipu_trace_number * sizeof(struct config_value);
+	if ((buffer_size + sizeof(ipu_trace_number)) != len) {
+		dev_info(&isp->pdev->dev,
+			"File size is not right, len:%ld, buffer_size:%zu\n",
+			len, buffer_size);
+		vfree(ipu_trace_buffer);
+		return -EFAULT;
+	}
+
+	mutex_lock(&isp->trace->lock);
+	cfg_buffer = (struct config_value *)(ipu_trace_buffer + sizeof(u32));
+	for (i = 0; i < ipu_trace_number; i++) {
+		update_register_cache(isp, cfg_buffer[i].reg,
+			cfg_buffer[i].value);
+	}
+	mutex_unlock(&isp->trace->lock);
+	vfree(ipu_trace_buffer);
+
+	return len;
+}
+
+static int traceconf_release(struct inode *inode, struct file *file)
+{
+	struct ipu_device *isp = file->private_data;
+	struct device *psys_dev = isp->psys ? &isp->psys->dev : NULL;
+	struct device *isys_dev = isp->isys ? &isp->isys->dev : NULL;
+	int pm_rval = -EINVAL;
+
+	/*
+	 * Turn devices on outside trace->lock mutex. PM transition may
+	 * cause call to function which tries to take the same lock.
+	 * Also do this before trace->open is set back to 0 to avoid
+	 * double restore (one here and one in pm transition). We can't
+	 * rely purely on the restore done by pm call backs since trace
+	 * configuration can occur in any phase compared to other activity.
+	 */
+
+	if (file->f_mode & FMODE_WRITE) {
+		if (isys_dev)
+			pm_rval = pm_runtime_get_sync(isys_dev);
+
+		if (pm_rval >= 0) {
+			/* ISYS ok or missing */
+			if (psys_dev)
+				pm_rval = pm_runtime_get_sync(psys_dev);
+
+			if (pm_rval < 0) {
+				pm_runtime_put_noidle(psys_dev);
+				if (isys_dev)
+					pm_runtime_put(isys_dev);
+			}
+		} else {
+			pm_runtime_put_noidle(&isp->isys->dev);
+		}
+	}
+
+	mutex_lock(&isp->trace->lock);
+	isp->trace->open = 0;
+	vfree(isp->trace->conf_dump_buffer);
+	isp->trace->conf_dump_buffer = NULL;
+
+	if (pm_rval >= 0) {
+		/* Update new cfg to HW */
+		if (isys_dev) {
+			__ipu_trace_stop(isys_dev);
+			clear_trace_buffer(isp->isys->trace_cfg);
+			__ipu_trace_restore(isys_dev);
+		}
+
+		if (psys_dev) {
+			__ipu_trace_stop(psys_dev);
+			clear_trace_buffer(isp->psys->trace_cfg);
+			__ipu_trace_restore(psys_dev);
+		}
+	}
+
+	mutex_unlock(&isp->trace->lock);
+
+	if (pm_rval >= 0) {
+		/* Again - this must be done with trace->lock not taken */
+		if (psys_dev)
+			pm_runtime_put(psys_dev);
+		if (isys_dev)
+			pm_runtime_put(isys_dev);
+	}
+	return 0;
+}
+
+static const struct file_operations ipu_traceconf_fops = {
+	.owner = THIS_MODULE,
+	.open = traceconf_open,
+	.release = traceconf_release,
+	.read = traceconf_read,
+	.write = traceconf_write,
+	.llseek = no_llseek,
+};
+
+static void wptraceconf_dump(struct ipu_device *isp)
+{
+	struct ipu_subsystem_wptrace_config *sys = &isp->trace->psys.wpt;
+	int i, rem_size;
+	char *out;
+
+	sys->size_conf_dump = 0;
+	out = sys->conf_dump_buffer;
+	rem_size = TRACE_CONF_DUMP_BUFFER_SIZE;
+
+	for (i = 0; i < sys->fill_level && rem_size > 0; i++) {
+		int bytes_print;
+		int n = snprintf(out, rem_size, "0x%08x = 0x%08x\n",
+				 sys->config[i].reg,
+				 sys->config[i].value);
+
+		bytes_print = min(n, rem_size - 1);
+		rem_size -= bytes_print;
+		out += bytes_print;
+	}
+	sys->size_conf_dump = out - sys->conf_dump_buffer;
+}
+
+static int wptraceconf_open(struct inode *inode, struct file *file)
+{
+	int ret;
+	struct ipu_device *isp;
+
+	if (!inode->i_private)
+		return -EACCES;
+
+	isp = inode->i_private;
+	ret = mutex_trylock(&isp->trace->lock);
+	if (!ret)
+		return -EBUSY;
+
+	if (isp->trace->psys.wpt.open) {
+		mutex_unlock(&isp->trace->lock);
+		return -EBUSY;
+	}
+
+	file->private_data = isp;
+	if (file->f_mode & FMODE_WRITE) {
+		/* TBD: Allocate temp buffer for processing.
+		 * Push validated buffer to active config
+		 */
+		/* Forget old config if opened for write */
+		isp->trace->psys.wpt.fill_level = 0;
+	}
+
+	if (file->f_mode & FMODE_READ) {
+		isp->trace->psys.wpt.conf_dump_buffer =
+		    vzalloc(TRACE_CONF_DUMP_BUFFER_SIZE);
+		if (!isp->trace->psys.wpt.conf_dump_buffer) {
+			mutex_unlock(&isp->trace->lock);
+			return -ENOMEM;
+		}
+		wptraceconf_dump(isp);
+	}
+	mutex_unlock(&isp->trace->lock);
+	return 0;
+}
+
+static ssize_t wptraceconf_read(struct file *file, char __user *buf,
+			      size_t len, loff_t *ppos)
+{
+	struct ipu_device *isp = file->private_data;
+
+	return simple_read_from_buffer(buf, len, ppos,
+				       isp->trace->psys.wpt.conf_dump_buffer,
+				       isp->trace->psys.wpt.size_conf_dump);
+}
+
+static ssize_t wptraceconf_write(struct file *file, const char __user *buf,
+			       size_t len, loff_t *ppos)
+{
+	int i;
+	struct ipu_device *isp = file->private_data;
+	ssize_t bytes = 0;
+	char *wpt_info_buffer = NULL;
+	size_t buffer_size = 0;
+	u32 wp_node_number = 0;
+	struct config_value *wpt_buffer = NULL;
+	struct ipu_subsystem_wptrace_config *wpt = &isp->trace->psys.wpt;
+
+	if ((*ppos < 0) || (len > WPT_TRACE_CONF_DATA_MAX_LEN) ||
+	    (len < sizeof(wp_node_number))) {
+		dev_info(&isp->pdev->dev,
+			"length is error, len:%ld, loff:%lld\n",
+			len, *ppos);
+		return -EINVAL;
+	}
+
+	wpt_info_buffer = vzalloc(len);
+	if (!wpt_info_buffer)
+		return -ENOMEM;
+
+	bytes = copy_from_user(wpt_info_buffer, buf, len);
+	if (bytes != 0) {
+		vfree(wpt_info_buffer);
+		return -EFAULT;
+	}
+
+	memcpy(&wp_node_number, wpt_info_buffer, sizeof(u32));
+	buffer_size = wp_node_number * sizeof(struct config_value);
+	if ((buffer_size + sizeof(wp_node_number)) != len) {
+		dev_info(&isp->pdev->dev,
+			"File size is not right, len:%ld, buffer_size:%zu\n",
+			len, buffer_size);
+		vfree(wpt_info_buffer);
+		return -EFAULT;
+	}
+
+	mutex_lock(&isp->trace->lock);
+	wpt_buffer = (struct config_value *)(wpt_info_buffer + sizeof(u32));
+	for (i = 0; i < wp_node_number; i++) {
+		if (wpt->fill_level < MAX_TRACE_REGISTERS) {
+			wpt->config[wpt->fill_level].reg = wpt_buffer[i].reg;
+			wpt->config[wpt->fill_level].value =
+				wpt_buffer[i].value;
+			wpt->fill_level++;
+		} else {
+			dev_info(&isp->pdev->dev,
+				 "Address 0x%08x ignored as invalid register\n",
+				 wpt_buffer[i].reg);
+			break;
+		}
+	}
+	mutex_unlock(&isp->trace->lock);
+	vfree(wpt_info_buffer);
+
+	return len;
+}
+
+static int wptraceconf_release(struct inode *inode, struct file *file)
+{
+	struct ipu_device *isp = file->private_data;
+
+	mutex_lock(&isp->trace->lock);
+	isp->trace->open = 0;
+	vfree(isp->trace->psys.wpt.conf_dump_buffer);
+	isp->trace->psys.wpt.conf_dump_buffer = NULL;
+	mutex_unlock(&isp->trace->lock);
+
+	return 0;
+}
+
+static const struct file_operations ipu_wptraceconf_fops = {
+	.owner = THIS_MODULE,
+	.open = wptraceconf_open,
+	.release = wptraceconf_release,
+	.read = wptraceconf_read,
+	.write = wptraceconf_write,
+	.llseek = no_llseek,
+};
+
+static int gettrace_open(struct inode *inode, struct file *file)
+{
+	struct ipu_subsystem_trace_config *sys = inode->i_private;
+
+	if (!sys)
+		return -EACCES;
+
+	if (!sys->memory.memory_buffer)
+		return -EACCES;
+
+	dma_sync_single_for_cpu(sys->dev,
+				sys->memory.dma_handle,
+				MEMORY_RING_BUFFER_SIZE +
+				MEMORY_RING_BUFFER_GUARD, DMA_FROM_DEVICE);
+
+	file->private_data = sys;
+	return 0;
+};
+
+static ssize_t gettrace_read(struct file *file, char __user *buf,
+			     size_t len, loff_t *ppos)
+{
+	struct ipu_subsystem_trace_config *sys = file->private_data;
+
+	return simple_read_from_buffer(buf, len, ppos,
+				       sys->memory.memory_buffer,
+				       MEMORY_RING_BUFFER_SIZE +
+				       MEMORY_RING_BUFFER_OVERREAD);
+}
+
+static ssize_t gettrace_write(struct file *file, const char __user *buf,
+			      size_t len, loff_t *ppos)
+{
+	struct ipu_subsystem_trace_config *sys = file->private_data;
+	static const char str[] = "clear";
+	char buffer[sizeof(str)] = { 0 };
+	ssize_t ret;
+
+	ret = simple_write_to_buffer(buffer, sizeof(buffer), ppos, buf, len);
+	if (ret < 0)
+		return ret;
+
+	if (ret < sizeof(str) - 1)
+		return -EINVAL;
+
+	if (!strncmp(str, buffer, sizeof(str) - 1)) {
+		clear_trace_buffer(sys);
+		return len;
+	}
+
+	return -EINVAL;
+}
+
+static int gettrace_release(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static const struct file_operations ipu_gettrace_fops = {
+	.owner = THIS_MODULE,
+	.open = gettrace_open,
+	.release = gettrace_release,
+	.read = gettrace_read,
+	.write = gettrace_write,
+	.llseek = no_llseek,
+};
+
+int ipu_trace_init(struct ipu_device *isp, void __iomem *base,
+		   struct device *dev, struct ipu_trace_block *blocks)
+{
+	struct ipu_bus_device *adev = to_ipu_bus_device(dev);
+	struct ipu_trace *trace = isp->trace;
+	struct ipu_subsystem_trace_config *sys;
+	int ret = 0;
+
+	if (!isp->trace)
+		return 0;
+
+	mutex_lock(&isp->trace->lock);
+
+	if (dev == &isp->isys->dev) {
+		sys = &trace->isys;
+	} else if (dev == &isp->psys->dev) {
+		sys = &trace->psys;
+	} else {
+		ret = -EINVAL;
+		goto leave;
+	}
+
+	adev->trace_cfg = sys;
+	sys->dev = dev;
+	sys->offset = base - isp->base;	/* sub system offset */
+	sys->base = base;
+	sys->blocks = blocks;
+
+	sys->memory.memory_buffer =
+	    dma_alloc_coherent(dev, MEMORY_RING_BUFFER_SIZE +
+			       MEMORY_RING_BUFFER_GUARD,
+			       &sys->memory.dma_handle,
+			       GFP_KERNEL);
+
+	if (!sys->memory.memory_buffer)
+		dev_err(dev, "failed alloc memory for tracing.\n");
+
+leave:
+	mutex_unlock(&isp->trace->lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(ipu_trace_init);
+
+void ipu_trace_uninit(struct device *dev)
+{
+	struct ipu_bus_device *adev = to_ipu_bus_device(dev);
+	struct ipu_device *isp = adev->isp;
+	struct ipu_trace *trace = isp->trace;
+	struct ipu_subsystem_trace_config *sys = adev->trace_cfg;
+
+	if (!trace || !sys)
+		return;
+
+	mutex_lock(&trace->lock);
+
+	if (sys->memory.memory_buffer)
+		dma_free_coherent(sys->dev,
+				  MEMORY_RING_BUFFER_SIZE +
+				  MEMORY_RING_BUFFER_GUARD,
+				  sys->memory.memory_buffer,
+				  sys->memory.dma_handle);
+
+	sys->dev = NULL;
+	sys->memory.memory_buffer = NULL;
+
+	mutex_unlock(&trace->lock);
+}
+EXPORT_SYMBOL_GPL(ipu_trace_uninit);
+
+int ipu_trace_debugfs_add(struct ipu_device *isp, struct dentry *dir)
+{
+	struct dentry *files[4];
+	int i = 0;
+
+	if (!ipu_trace_enable)
+		return 0;
+
+	files[i] = debugfs_create_file("traceconf", 0644,
+				       dir, isp, &ipu_traceconf_fops);
+	if (!files[i])
+		return -ENOMEM;
+	i++;
+
+	files[i] = debugfs_create_file("wptraceconf", 0644,
+				       dir, isp, &ipu_wptraceconf_fops);
+	if (!files[i])
+		goto error;
+	i++;
+
+	files[i] = debugfs_create_file("getisystrace", 0444,
+				       dir,
+				       &isp->trace->isys, &ipu_gettrace_fops);
+
+	if (!files[i])
+		goto error;
+	i++;
+
+	files[i] = debugfs_create_file("getpsystrace", 0444,
+				       dir,
+				       &isp->trace->psys, &ipu_gettrace_fops);
+	if (!files[i])
+		goto error;
+
+	return 0;
+
+error:
+	for (; i > 0; i--)
+		debugfs_remove(files[i - 1]);
+	return -ENOMEM;
+}
+
+int ipu_trace_add(struct ipu_device *isp)
+{
+	if (!ipu_trace_enable)
+		return 0;
+
+	isp->trace = devm_kzalloc(&isp->pdev->dev,
+				  sizeof(struct ipu_trace), GFP_KERNEL);
+	if (!isp->trace)
+		return -ENOMEM;
+
+	mutex_init(&isp->trace->lock);
+
+	dev_dbg(&isp->pdev->dev, "ipu trace enabled!");
+
+	return 0;
+}
+
+void ipu_trace_release(struct ipu_device *isp)
+{
+	if (!isp->trace)
+		return;
+	mutex_destroy(&isp->trace->lock);
+}
+
+int ipu_trace_buffer_dma_handle(struct device *dev, dma_addr_t *dma_handle)
+{
+	struct ipu_bus_device *adev = to_ipu_bus_device(dev);
+	struct ipu_subsystem_trace_config *sys = adev->trace_cfg;
+
+	if (!ipu_trace_enable)
+		return -EACCES;
+
+	if (!sys->memory.memory_buffer)
+		return -EACCES;
+
+	*dma_handle = sys->memory.dma_handle;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ipu_trace_buffer_dma_handle);
+
+MODULE_AUTHOR("Samu Onkalo <samu.onkalo@intel.com>");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Intel ipu trace support");
Index: b/drivers/media/pci/intel/ipu-trace.h
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu-trace.h
@@ -0,0 +1,147 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2014 - 2021 Intel Corporation */
+
+#ifndef IPU_TRACE_H
+#define IPU_TRACE_H
+#include <linux/debugfs.h>
+
+/* Trace unit register offsets */
+#define TRACE_REG_TUN_DDR_ENABLE        0x000
+#define TRACE_REG_TUN_NPK_ENABLE	0x004
+#define TRACE_REG_TUN_DDR_INFO_VAL	0x008
+#define TRACE_REG_TUN_NPK_ADDR		0x00C
+#define TRACE_REG_TUN_DRAM_BASE_ADDR	0x010
+#define TRACE_REG_TUN_DRAM_END_ADDR	0x014
+#define TRACE_REG_TUN_LOCAL_TIMER0	0x018
+#define TRACE_REG_TUN_LOCAL_TIMER1	0x01C
+#define TRACE_REG_TUN_WR_PTR		0x020
+#define TRACE_REG_TUN_RD_PTR		0x024
+
+/*
+ * Following registers are left out on purpose:
+ * TUN_LOCAL_TIMER0, TUN_LOCAL_TIMER1, TUN_DRAM_BASE_ADDR
+ * TUN_DRAM_END_ADDR, TUN_WR_PTR, TUN_RD_PTR
+ */
+
+/* Trace monitor register offsets */
+#define TRACE_REG_TM_TRACE_ADDR_A		0x0900
+#define TRACE_REG_TM_TRACE_ADDR_B		0x0904
+#define TRACE_REG_TM_TRACE_ADDR_C		0x0908
+#define TRACE_REG_TM_TRACE_ADDR_D		0x090c
+#define TRACE_REG_TM_TRACE_ENABLE_NPK		0x0910
+#define TRACE_REG_TM_TRACE_ENABLE_DDR		0x0914
+#define TRACE_REG_TM_TRACE_PER_PC		0x0918
+#define TRACE_REG_TM_TRACE_PER_BRANCH		0x091c
+#define TRACE_REG_TM_TRACE_HEADER		0x0920
+#define TRACE_REG_TM_TRACE_CFG			0x0924
+#define TRACE_REG_TM_TRACE_LOST_PACKETS		0x0928
+#define TRACE_REG_TM_TRACE_LP_CLEAR		0x092c
+#define TRACE_REG_TM_TRACE_LMRUN_MASK		0x0930
+#define TRACE_REG_TM_TRACE_LMRUN_PC_LOW		0x0934
+#define TRACE_REG_TM_TRACE_LMRUN_PC_HIGH	0x0938
+#define TRACE_REG_TM_TRACE_MMIO_SEL		0x093c
+#define TRACE_REG_TM_TRACE_MMIO_WP0_LOW		0x0940
+#define TRACE_REG_TM_TRACE_MMIO_WP1_LOW		0x0944
+#define TRACE_REG_TM_TRACE_MMIO_WP2_LOW		0x0948
+#define TRACE_REG_TM_TRACE_MMIO_WP3_LOW		0x094c
+#define TRACE_REG_TM_TRACE_MMIO_WP0_HIGH	0x0950
+#define TRACE_REG_TM_TRACE_MMIO_WP1_HIGH	0x0954
+#define TRACE_REG_TM_TRACE_MMIO_WP2_HIGH	0x0958
+#define TRACE_REG_TM_TRACE_MMIO_WP3_HIGH	0x095c
+#define TRACE_REG_TM_FWTRACE_FIRST		0x0A00
+#define TRACE_REG_TM_FWTRACE_MIDDLE		0x0A04
+#define TRACE_REG_TM_FWTRACE_LAST		0x0A08
+
+/*
+ * Following exists only in (I)SP address space:
+ * TM_FWTRACE_FIRST, TM_FWTRACE_MIDDLE, TM_FWTRACE_LAST
+ */
+
+#define TRACE_REG_GPC_RESET			0x000
+#define TRACE_REG_GPC_OVERALL_ENABLE		0x004
+#define TRACE_REG_GPC_TRACE_HEADER		0x008
+#define TRACE_REG_GPC_TRACE_ADDRESS		0x00C
+#define TRACE_REG_GPC_TRACE_NPK_EN		0x010
+#define TRACE_REG_GPC_TRACE_DDR_EN		0x014
+#define TRACE_REG_GPC_TRACE_LPKT_CLEAR		0x018
+#define TRACE_REG_GPC_TRACE_LPKT		0x01C
+
+#define TRACE_REG_GPC_ENABLE_ID0		0x020
+#define TRACE_REG_GPC_ENABLE_ID1		0x024
+#define TRACE_REG_GPC_ENABLE_ID2		0x028
+#define TRACE_REG_GPC_ENABLE_ID3		0x02c
+
+#define TRACE_REG_GPC_VALUE_ID0			0x030
+#define TRACE_REG_GPC_VALUE_ID1			0x034
+#define TRACE_REG_GPC_VALUE_ID2			0x038
+#define TRACE_REG_GPC_VALUE_ID3			0x03c
+
+#define TRACE_REG_GPC_CNT_INPUT_SELECT_ID0	0x040
+#define TRACE_REG_GPC_CNT_INPUT_SELECT_ID1	0x044
+#define TRACE_REG_GPC_CNT_INPUT_SELECT_ID2	0x048
+#define TRACE_REG_GPC_CNT_INPUT_SELECT_ID3	0x04c
+
+#define TRACE_REG_GPC_CNT_START_SELECT_ID0	0x050
+#define TRACE_REG_GPC_CNT_START_SELECT_ID1	0x054
+#define TRACE_REG_GPC_CNT_START_SELECT_ID2	0x058
+#define TRACE_REG_GPC_CNT_START_SELECT_ID3	0x05c
+
+#define TRACE_REG_GPC_CNT_STOP_SELECT_ID0	0x060
+#define TRACE_REG_GPC_CNT_STOP_SELECT_ID1	0x064
+#define TRACE_REG_GPC_CNT_STOP_SELECT_ID2	0x068
+#define TRACE_REG_GPC_CNT_STOP_SELECT_ID3	0x06c
+
+#define TRACE_REG_GPC_CNT_MSG_SELECT_ID0	0x070
+#define TRACE_REG_GPC_CNT_MSG_SELECT_ID1	0x074
+#define TRACE_REG_GPC_CNT_MSG_SELECT_ID2	0x078
+#define TRACE_REG_GPC_CNT_MSG_SELECT_ID3	0x07c
+
+#define TRACE_REG_GPC_CNT_MSG_PLOAD_SELECT_ID0	0x080
+#define TRACE_REG_GPC_CNT_MSG_PLOAD_SELECT_ID1	0x084
+#define TRACE_REG_GPC_CNT_MSG_PLOAD_SELECT_ID2	0x088
+#define TRACE_REG_GPC_CNT_MSG_PLOAD_SELECT_ID3	0x08c
+
+#define TRACE_REG_GPC_IRQ_TRIGGER_VALUE_ID0	0x090
+#define TRACE_REG_GPC_IRQ_TRIGGER_VALUE_ID1	0x094
+#define TRACE_REG_GPC_IRQ_TRIGGER_VALUE_ID2	0x098
+#define TRACE_REG_GPC_IRQ_TRIGGER_VALUE_ID3	0x09c
+
+#define TRACE_REG_GPC_IRQ_TIMER_SELECT_ID0	0x0a0
+#define TRACE_REG_GPC_IRQ_TIMER_SELECT_ID1	0x0a4
+#define TRACE_REG_GPC_IRQ_TIMER_SELECT_ID2	0x0a8
+#define TRACE_REG_GPC_IRQ_TIMER_SELECT_ID3	0x0ac
+
+#define TRACE_REG_GPC_IRQ_ENABLE_ID0		0x0b0
+#define TRACE_REG_GPC_IRQ_ENABLE_ID1		0x0b4
+#define TRACE_REG_GPC_IRQ_ENABLE_ID2		0x0b8
+#define TRACE_REG_GPC_IRQ_ENABLE_ID3		0x0bc
+
+struct ipu_trace;
+struct ipu_subsystem_trace_config;
+
+enum ipu_trace_block_type {
+	IPU_TRACE_BLOCK_TUN = 0,	/* Trace unit */
+	IPU_TRACE_BLOCK_TM,	/* Trace monitor */
+	IPU_TRACE_BLOCK_GPC,	/* General purpose control */
+	IPU_TRACE_CSI2,	/* CSI2 legacy receiver */
+	IPU_TRACE_CSI2_3PH,	/* CSI2 combo receiver */
+	IPU_TRACE_SIG2CIOS,
+	IPU_TRACE_TIMER_RST,	/* Trace reset control timer */
+	IPU_TRACE_BLOCK_END	/* End of list */
+};
+
+struct ipu_trace_block {
+	u32 offset;	/* Offset to block inside subsystem */
+	enum ipu_trace_block_type type;
+};
+
+int ipu_trace_add(struct ipu_device *isp);
+int ipu_trace_debugfs_add(struct ipu_device *isp, struct dentry *dir);
+void ipu_trace_release(struct ipu_device *isp);
+int ipu_trace_init(struct ipu_device *isp, void __iomem *base,
+		   struct device *dev, struct ipu_trace_block *blocks);
+void ipu_trace_restore(struct device *dev);
+void ipu_trace_uninit(struct device *dev);
+void ipu_trace_stop(struct device *dev);
+int ipu_trace_buffer_dma_handle(struct device *dev, dma_addr_t *dma_handle);
+#endif
Index: b/drivers/media/pci/intel/ipu.c
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu.c
@@ -0,0 +1,989 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) 2013 - 2022 Intel Corporation
+
+#include <linux/acpi.h>
+#include <linux/debugfs.h>
+#include <linux/device.h>
+#include <linux/interrupt.h>
+#include <linux/firmware.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/pci.h>
+#include <linux/pm_qos.h>
+#include <linux/pm_runtime.h>
+#include <linux/timer.h>
+#include <linux/sched.h>
+
+#include "ipu.h"
+#include "ipu-buttress.h"
+#include "ipu-platform.h"
+#include "ipu-platform-buttress-regs.h"
+#include "ipu-cpd.h"
+#include "ipu-pdata.h"
+#include "ipu-bus.h"
+#include "ipu-mmu.h"
+#include "ipu-platform-regs.h"
+#include "ipu-platform-isys-csi2-reg.h"
+#include "ipu-trace.h"
+
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA)
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_PDATA_DYNAMIC_LOADING)
+#include <media/ipu-isys.h>
+#endif
+#endif
+
+#if IS_ENABLED(CONFIG_INTEL_IPU6_ACPI)
+#include <media/ipu-acpi.h>
+#endif
+
+#define IPU_PCI_BAR		0
+enum ipu_version ipu_ver;
+EXPORT_SYMBOL(ipu_ver);
+
+static int isys_freq_overwrite = -1;
+module_param(isys_freq_overwrite, int, 0660);
+MODULE_PARM_DESC(isys_freq_overwrite, "overwrite isys freq default value");
+
+#if IS_ENABLED(CONFIG_INTEL_IPU6_ACPI)
+static int isys_init_acpi_add_device(struct device *dev, void *priv,
+				struct ipu_isys_csi2_config *csi2,
+				bool reprobe)
+{
+	return 0;
+}
+#endif
+
+static struct ipu_bus_device *ipu_isys_init(struct pci_dev *pdev,
+					    struct device *parent,
+					    struct ipu_buttress_ctrl *ctrl,
+					    void __iomem *base,
+					    const struct ipu_isys_internal_pdata
+					    *ipdata,
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA)
+					    struct ipu_isys_subdev_pdata
+					    *spdata,
+#endif
+					    unsigned int nr)
+{
+	struct ipu_bus_device *isys;
+	struct ipu_isys_pdata *pdata;
+#if IS_ENABLED(CONFIG_INTEL_IPU6_ACPI)
+	struct ipu_isys_subdev_pdata *acpi_pdata;
+#endif
+	int ret;
+
+	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
+	if (!pdata)
+		return ERR_PTR(-ENOMEM);
+
+	pdata->base = base;
+	pdata->ipdata = ipdata;
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA)
+	pdata->spdata = spdata;
+#endif
+
+	/* Use 250MHz for ipu6 se */
+	if (ipu_ver == IPU_VER_6SE)
+		ctrl->ratio = IPU6SE_IS_FREQ_CTL_DEFAULT_RATIO;
+
+	isys = ipu_bus_initialize_device(pdev, parent, pdata, ctrl,
+					 IPU_ISYS_NAME, nr);
+	if (IS_ERR(isys)) {
+		dev_err_probe(&pdev->dev, PTR_ERR(isys),
+			      "ipu_bus_add_device(isys) failed\n");
+		return ERR_CAST(isys);
+	}
+#if IS_ENABLED(CONFIG_INTEL_IPU6_ACPI)
+	if (!spdata) {
+		dev_err(&pdev->dev, "No subdevice info provided");
+		ipu_get_acpi_devices(isys, &isys->dev, &acpi_pdata, NULL,
+				     isys_init_acpi_add_device);
+		pdata->spdata = acpi_pdata;
+	} else {
+		dev_dbg(&pdev->dev, "Subdevice info found");
+		ipu_get_acpi_devices(isys, &isys->dev, &acpi_pdata, &spdata,
+				     isys_init_acpi_add_device);
+	}
+#endif
+	isys->mmu = ipu_mmu_init(&pdev->dev, base, ISYS_MMID,
+				 &ipdata->hw_variant);
+	if (IS_ERR(isys->mmu)) {
+		dev_err_probe(&pdev->dev, PTR_ERR(isys),
+			      "ipu_mmu_init(isys->mmu) failed\n");
+		return ERR_CAST(isys->mmu);
+	}
+
+	isys->mmu->dev = &isys->dev;
+
+	ret = ipu_bus_add_device(isys);
+	if (ret)
+		return ERR_PTR(ret);
+
+	return isys;
+}
+
+static struct ipu_bus_device *ipu_psys_init(struct pci_dev *pdev,
+					    struct device *parent,
+					    struct ipu_buttress_ctrl *ctrl,
+					    void __iomem *base,
+					    const struct ipu_psys_internal_pdata
+					    *ipdata, unsigned int nr)
+{
+	struct ipu_bus_device *psys;
+	struct ipu_psys_pdata *pdata;
+	int ret;
+
+	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
+	if (!pdata)
+		return ERR_PTR(-ENOMEM);
+
+	pdata->base = base;
+	pdata->ipdata = ipdata;
+
+	psys = ipu_bus_initialize_device(pdev, parent, pdata, ctrl,
+					 IPU_PSYS_NAME, nr);
+	if (IS_ERR(psys)) {
+		dev_err_probe(&pdev->dev, PTR_ERR(psys),
+			      "ipu_bus_add_device(psys) failed\n");
+		return ERR_CAST(psys);
+	}
+
+	psys->mmu = ipu_mmu_init(&pdev->dev, base, PSYS_MMID,
+				 &ipdata->hw_variant);
+	if (IS_ERR(psys->mmu)) {
+		dev_err_probe(&pdev->dev, PTR_ERR(psys),
+			      "ipu_mmu_init(psys->mmu) failed\n");
+		return ERR_CAST(psys->mmu);
+	}
+
+	psys->mmu->dev = &psys->dev;
+
+	ret = ipu_bus_add_device(psys);
+	if (ret)
+		return ERR_PTR(ret);
+
+	return psys;
+}
+
+int ipu_fw_authenticate(void *data, u64 val)
+{
+	struct ipu_device *isp = data;
+	int ret;
+
+	if (!isp->secure_mode)
+		return -EINVAL;
+
+	ret = ipu_buttress_reset_authentication(isp);
+	if (ret) {
+		dev_err(&isp->pdev->dev, "Failed to reset authentication!\n");
+		return ret;
+	}
+
+	ret = pm_runtime_get_sync(&isp->psys->dev);
+	if (ret < 0) {
+		dev_err(&isp->pdev->dev, "Runtime PM failed (%d)\n", ret);
+		return ret;
+	}
+
+	ret = ipu_buttress_authenticate(isp);
+	if (ret) {
+		dev_err(&isp->pdev->dev, "FW authentication failed\n");
+		return ret;
+	}
+
+	pm_runtime_put(&isp->psys->dev);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_fw_authenticate);
+DEFINE_SIMPLE_ATTRIBUTE(authenticate_fops, NULL, ipu_fw_authenticate, "%llu\n");
+
+#ifdef CONFIG_DEBUG_FS
+static int resume_ipu_bus_device(struct ipu_bus_device *adev)
+{
+	struct device *dev = &adev->dev;
+	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
+
+	if (!pm || !pm->resume)
+		return -EIO;
+
+	return pm->resume(dev);
+}
+
+static int suspend_ipu_bus_device(struct ipu_bus_device *adev)
+{
+	struct device *dev = &adev->dev;
+	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
+
+	if (!pm || !pm->suspend)
+		return -EIO;
+
+	return pm->suspend(dev);
+}
+
+static int force_suspend_get(void *data, u64 *val)
+{
+	struct ipu_device *isp = data;
+	struct ipu_buttress *b = &isp->buttress;
+
+	*val = b->force_suspend;
+	return 0;
+}
+
+static int force_suspend_set(void *data, u64 val)
+{
+	struct ipu_device *isp = data;
+	struct ipu_buttress *b = &isp->buttress;
+	int ret = 0;
+
+	if (val == b->force_suspend)
+		return 0;
+
+	if (val) {
+		b->force_suspend = 1;
+		ret = suspend_ipu_bus_device(isp->psys);
+		if (ret) {
+			dev_err(&isp->pdev->dev, "Failed to suspend psys\n");
+			return ret;
+		}
+		ret = suspend_ipu_bus_device(isp->isys);
+		if (ret) {
+			dev_err(&isp->pdev->dev, "Failed to suspend isys\n");
+			return ret;
+		}
+		ret = pci_set_power_state(isp->pdev, PCI_D3hot);
+		if (ret) {
+			dev_err(&isp->pdev->dev,
+				"Failed to suspend IUnit PCI device\n");
+			return ret;
+		}
+	} else {
+		ret = pci_set_power_state(isp->pdev, PCI_D0);
+		if (ret) {
+			dev_err(&isp->pdev->dev,
+				"Failed to suspend IUnit PCI device\n");
+			return ret;
+		}
+		ret = resume_ipu_bus_device(isp->isys);
+		if (ret) {
+			dev_err(&isp->pdev->dev, "Failed to resume isys\n");
+			return ret;
+		}
+		ret = resume_ipu_bus_device(isp->psys);
+		if (ret) {
+			dev_err(&isp->pdev->dev, "Failed to resume psys\n");
+			return ret;
+		}
+		b->force_suspend = 0;
+	}
+
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(force_suspend_fops, force_suspend_get,
+			force_suspend_set, "%llu\n");
+/*
+ * The sysfs interface for reloading cpd fw is there only for debug purpose,
+ * and it must not be used when either isys or psys is in use.
+ */
+static int cpd_fw_reload(void *data, u64 val)
+{
+	struct ipu_device *isp = data;
+	int rval = -EINVAL;
+
+	if (isp->cpd_fw_reload)
+		rval = isp->cpd_fw_reload(isp);
+
+	return rval;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(cpd_fw_fops, NULL, cpd_fw_reload, "%llu\n");
+
+static int ipu_init_debugfs(struct ipu_device *isp)
+{
+	struct dentry *file;
+	struct dentry *dir;
+
+	dir = debugfs_create_dir(IPU_NAME, NULL);
+	if (!dir)
+		return -ENOMEM;
+
+	file = debugfs_create_file("force_suspend", 0700, dir, isp,
+				   &force_suspend_fops);
+	if (!file)
+		goto err;
+	file = debugfs_create_file("authenticate", 0700, dir, isp,
+				   &authenticate_fops);
+	if (!file)
+		goto err;
+
+	file = debugfs_create_file("cpd_fw_reload", 0700, dir, isp,
+				   &cpd_fw_fops);
+	if (!file)
+		goto err;
+
+	if (ipu_trace_debugfs_add(isp, dir))
+		goto err;
+
+	isp->ipu_dir = dir;
+
+	if (ipu_buttress_debugfs_init(isp))
+		goto err;
+
+	return 0;
+err:
+	debugfs_remove_recursive(dir);
+	return -ENOMEM;
+}
+
+static void ipu_remove_debugfs(struct ipu_device *isp)
+{
+	/*
+	 * Since isys and psys debugfs dir will be created under ipu root dir,
+	 * mark its dentry to NULL to avoid duplicate removal.
+	 */
+	debugfs_remove_recursive(isp->ipu_dir);
+	isp->ipu_dir = NULL;
+}
+#endif /* CONFIG_DEBUG_FS */
+
+static int ipu_pci_config_setup(struct pci_dev *dev)
+{
+	u16 pci_command;
+	int rval;
+
+	pci_read_config_word(dev, PCI_COMMAND, &pci_command);
+	pci_command |= PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER;
+	pci_write_config_word(dev, PCI_COMMAND, pci_command);
+
+	/* no msi pci capability for IPU6EP */
+	if (ipu_ver == IPU_VER_6EP || ipu_ver == IPU_VER_6EP_MTL) {
+		/* likely do nothing as msi not enabled by default */
+		pci_disable_msi(dev);
+		return 0;
+	}
+
+	rval = pci_enable_msi(dev);
+	if (rval)
+		dev_err(&dev->dev, "Failed to enable msi (%d)\n", rval);
+
+	return rval;
+}
+
+static void ipu_configure_vc_mechanism(struct ipu_device *isp)
+{
+	u32 val = readl(isp->base + BUTTRESS_REG_BTRS_CTRL);
+
+	if (IPU_BTRS_ARB_STALL_MODE_VC0 == IPU_BTRS_ARB_MODE_TYPE_STALL)
+		val |= BUTTRESS_REG_BTRS_CTRL_STALL_MODE_VC0;
+	else
+		val &= ~BUTTRESS_REG_BTRS_CTRL_STALL_MODE_VC0;
+
+	if (IPU_BTRS_ARB_STALL_MODE_VC1 == IPU_BTRS_ARB_MODE_TYPE_STALL)
+		val |= BUTTRESS_REG_BTRS_CTRL_STALL_MODE_VC1;
+	else
+		val &= ~BUTTRESS_REG_BTRS_CTRL_STALL_MODE_VC1;
+
+	writel(val, isp->base + BUTTRESS_REG_BTRS_CTRL);
+}
+
+int request_cpd_fw(const struct firmware **firmware_p, const char *name,
+		   struct device *device)
+{
+	const struct firmware *fw;
+	struct firmware *tmp;
+	int ret;
+
+	ret = request_firmware(&fw, name, device);
+	if (ret)
+		return ret;
+
+	if (is_vmalloc_addr(fw->data)) {
+		*firmware_p = fw;
+	} else {
+		tmp = kzalloc(sizeof(*tmp), GFP_KERNEL);
+		if (!tmp) {
+			release_firmware(fw);
+			return -ENOMEM;
+		}
+		tmp->size = fw->size;
+		tmp->data = vmalloc(fw->size);
+		if (!tmp->data) {
+			kfree(tmp);
+			release_firmware(fw);
+			return -ENOMEM;
+		}
+		memcpy((void *)tmp->data, fw->data, fw->size);
+		*firmware_p = tmp;
+		release_firmware(fw);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(request_cpd_fw);
+
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA)
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_PDATA_DYNAMIC_LOADING)
+static inline int match_spdata(struct ipu_isys_subdev_info *sd,
+			const struct ipu_spdata_rep *rep)
+{
+	if (strcmp(sd->i2c.board_info.type, rep->name))
+		return 0;
+
+	if (strcmp(sd->i2c.i2c_adapter_bdf, rep->i2c_adapter_bdf_o))
+		return 0;
+
+	if (sd->i2c.board_info.addr != rep->slave_addr_o)
+		return 0;
+
+	if (sd->csi2->port != rep->port_o)
+		return 0;
+
+	return 1;
+}
+
+void fixup_spdata(const void *spdata_rep,
+		struct ipu_isys_subdev_pdata *spdata)
+{
+	const struct ipu_spdata_rep *rep = spdata_rep;
+	struct ipu_isys_subdev_info **subdevs, *sd_info;
+
+	if (!spdata)
+		return;
+
+	for (; rep->name[0]; rep++) {
+		for (subdevs = spdata->subdevs; *subdevs; subdevs++) {
+			sd_info = *subdevs;
+
+			if (!sd_info->csi2)
+				continue;
+
+			if (match_spdata(sd_info, rep)) {
+				strcpy(sd_info->i2c.i2c_adapter_bdf,
+						rep->i2c_adapter_bdf_n);
+				sd_info->i2c.board_info.addr =
+					rep->slave_addr_n;
+				sd_info->csi2->port = rep->port_n;
+
+				if (sd_info->fixup_spdata)
+					sd_info->fixup_spdata(rep,
+					sd_info->i2c.board_info.platform_data);
+			}
+		}
+	}
+}
+#endif
+#endif
+
+static int ipu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)
+{
+	struct ipu_device *isp;
+	phys_addr_t phys;
+	void __iomem *const *iomap;
+	void __iomem *isys_base = NULL;
+	void __iomem *psys_base = NULL;
+	struct ipu_buttress_ctrl *isys_ctrl = NULL, *psys_ctrl = NULL;
+	unsigned int dma_mask = IPU_DMA_MASK;
+	struct fwnode_handle *fwnode = dev_fwnode(&pdev->dev);
+	u32 is_es;
+	int rval;
+	u32 val;
+
+	if (!fwnode || fwnode_property_read_u32(fwnode, "is_es", &is_es))
+		is_es = 0;
+
+	isp = devm_kzalloc(&pdev->dev, sizeof(*isp), GFP_KERNEL);
+	if (!isp)
+		return -ENOMEM;
+
+	isp->pdev = pdev;
+	INIT_LIST_HEAD(&isp->devices);
+
+	rval = pcim_enable_device(pdev);
+	if (rval) {
+		dev_err(&pdev->dev, "Failed to enable CI ISP device (%d)\n",
+			rval);
+		return rval;
+	}
+
+	dev_info(&pdev->dev, "Device 0x%x (rev: 0x%x)\n",
+		 pdev->device, pdev->revision);
+
+	phys = pci_resource_start(pdev, IPU_PCI_BAR);
+
+	rval = pcim_iomap_regions(pdev,
+				  1 << IPU_PCI_BAR,
+				  pci_name(pdev));
+	if (rval) {
+		dev_err(&pdev->dev, "Failed to I/O memory remapping (%d)\n",
+			rval);
+		return rval;
+	}
+	dev_info(&pdev->dev, "physical base address 0x%llx\n", phys);
+
+	iomap = pcim_iomap_table(pdev);
+	if (!iomap) {
+		dev_err(&pdev->dev, "Failed to iomap table (%d)\n", rval);
+		return -ENODEV;
+	}
+
+	isp->base = iomap[IPU_PCI_BAR];
+	dev_info(&pdev->dev, "mapped as: 0x%p\n", isp->base);
+
+	pci_set_drvdata(pdev, isp);
+	pci_set_master(pdev);
+
+	switch (id->device) {
+	case IPU6_PCI_ID:
+		ipu_ver = IPU_VER_6;
+		isp->cpd_fw_name = IPU6_FIRMWARE_NAME;
+		break;
+	case IPU6SE_PCI_ID:
+		ipu_ver = IPU_VER_6SE;
+		isp->cpd_fw_name = IPU6SE_FIRMWARE_NAME;
+		break;
+	case IPU6EP_ADL_P_PCI_ID:
+	case IPU6EP_RPL_P_PCI_ID:
+		ipu_ver = IPU_VER_6EP;
+		isp->cpd_fw_name = is_es ? IPU6EPES_FIRMWARE_NAME : IPU6EP_FIRMWARE_NAME;
+		break;
+	case IPU6EP_ADL_N_PCI_ID:
+		ipu_ver = IPU_VER_6EP;
+		isp->cpd_fw_name = IPU6EPADLN_FIRMWARE_NAME;
+		break;
+	case IPU6EP_MTL_PCI_ID:
+		ipu_ver = IPU_VER_6EP_MTL;
+		isp->cpd_fw_name = IPU6EPMTL_FIRMWARE_NAME;
+		break;
+	default:
+		WARN(1, "Unsupported IPU device");
+		return -ENODEV;
+	}
+
+	ipu_internal_pdata_init();
+
+	isys_base = isp->base + isys_ipdata.hw_variant.offset;
+	psys_base = isp->base + psys_ipdata.hw_variant.offset;
+
+	dev_dbg(&pdev->dev, "isys_base: 0x%lx\n", (unsigned long)isys_base);
+	dev_dbg(&pdev->dev, "psys_base: 0x%lx\n", (unsigned long)psys_base);
+
+	rval = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(dma_mask));
+	if (rval) {
+		dev_err(&pdev->dev, "Failed to set DMA mask (%d)\n", rval);
+		return rval;
+	}
+
+	dma_set_max_seg_size(&pdev->dev, UINT_MAX);
+
+	rval = ipu_pci_config_setup(pdev);
+	if (rval)
+		return rval;
+
+	rval = devm_request_threaded_irq(&pdev->dev, pdev->irq,
+					 ipu_buttress_isr,
+					 ipu_buttress_isr_threaded,
+					 IRQF_SHARED, IPU_NAME, isp);
+	if (rval) {
+		dev_err(&pdev->dev, "Requesting irq failed(%d)\n", rval);
+		return rval;
+	}
+
+	rval = ipu_buttress_init(isp);
+	if (rval)
+		return rval;
+
+	dev_info(&pdev->dev, "cpd file name: %s\n", isp->cpd_fw_name);
+
+	rval = request_cpd_fw(&isp->cpd_fw, isp->cpd_fw_name, &pdev->dev);
+	if (rval) {
+		dev_err(&isp->pdev->dev, "Requesting signed firmware failed\n");
+		return rval;
+	}
+
+	rval = ipu_cpd_validate_cpd_file(isp, isp->cpd_fw->data,
+					 isp->cpd_fw->size);
+	if (rval) {
+		dev_err(&isp->pdev->dev, "Failed to validate cpd\n");
+		goto out_ipu_bus_del_devices;
+	}
+
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA)
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_PDATA_DYNAMIC_LOADING)
+	rval = request_firmware(&isp->spdata_fw, IPU_SPDATA_NAME, &pdev->dev);
+	if (rval)
+		dev_warn(&isp->pdev->dev, "no spdata replace, using default\n");
+	else
+		fixup_spdata(isp->spdata_fw->data, pdev->dev.platform_data);
+#endif
+#endif
+	rval = ipu_trace_add(isp);
+	if (rval)
+		dev_err(&pdev->dev, "Trace support not available\n");
+
+	/*
+	 * NOTE Device hierarchy below is important to ensure proper
+	 * runtime suspend and resume order.
+	 * Also registration order is important to ensure proper
+	 * suspend and resume order during system
+	 * suspend. Registration order is as follows:
+	 * isys->psys
+	 */
+	isys_ctrl = devm_kzalloc(&pdev->dev, sizeof(*isys_ctrl), GFP_KERNEL);
+	if (!isys_ctrl) {
+		rval = -ENOMEM;
+		goto out_ipu_bus_del_devices;
+	}
+
+	/* Init butress control with default values based on the HW */
+	memcpy(isys_ctrl, &isys_buttress_ctrl, sizeof(*isys_ctrl));
+
+	isp->isys = ipu_isys_init(pdev, &pdev->dev,
+				  isys_ctrl, isys_base,
+				  &isys_ipdata,
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA)
+				  pdev->dev.platform_data,
+#endif
+				  0);
+	if (IS_ERR(isp->isys)) {
+		rval = PTR_ERR(isp->isys);
+		goto out_ipu_bus_del_devices;
+	}
+
+	if ((isys_freq_overwrite >= IPU_IS_FREQ_MIN) && (isys_freq_overwrite <= IPU_IS_FREQ_MAX)) {
+		u64 val = isys_freq_overwrite;
+
+		do_div(val, BUTTRESS_IS_FREQ_STEP);
+		dev_info(&isp->pdev->dev, "isys freq overwrite to %d\n", isys_freq_overwrite);
+		isys_ctrl->divisor = val;
+	}
+
+	psys_ctrl = devm_kzalloc(&pdev->dev, sizeof(*psys_ctrl), GFP_KERNEL);
+	if (!psys_ctrl) {
+		rval = -ENOMEM;
+		goto out_ipu_bus_del_devices;
+	}
+
+	/* Init butress control with default values based on the HW */
+	memcpy(psys_ctrl, &psys_buttress_ctrl, sizeof(*psys_ctrl));
+
+	isp->psys = ipu_psys_init(pdev, &isp->isys->dev,
+				  psys_ctrl, psys_base,
+				  &psys_ipdata, 0);
+	if (IS_ERR(isp->psys)) {
+		rval = PTR_ERR(isp->psys);
+		goto out_ipu_bus_del_devices;
+	}
+
+	rval = pm_runtime_get_sync(&isp->psys->dev);
+	if (rval < 0) {
+		dev_err(&isp->psys->dev, "Failed to get runtime PM\n");
+		goto out_ipu_bus_del_devices;
+	}
+
+	rval = ipu_mmu_hw_init(isp->psys->mmu);
+	if (rval) {
+		dev_err(&isp->pdev->dev, "Failed to set mmu hw\n");
+		goto out_ipu_bus_del_devices;
+	}
+
+	rval = ipu_buttress_map_fw_image(isp->psys, isp->cpd_fw,
+					 &isp->fw_sgt);
+	if (rval) {
+		dev_err(&isp->pdev->dev, "failed to map fw image\n");
+		goto out_ipu_bus_del_devices;
+	}
+
+	isp->pkg_dir = ipu_cpd_create_pkg_dir(isp->psys,
+					      isp->cpd_fw->data,
+					      sg_dma_address(isp->fw_sgt.sgl),
+					      &isp->pkg_dir_dma_addr,
+					      &isp->pkg_dir_size);
+	if (!isp->pkg_dir) {
+		rval = -ENOMEM;
+		dev_err(&isp->pdev->dev, "failed to create pkg dir\n");
+		goto out_ipu_bus_del_devices;
+	}
+
+	rval = ipu_buttress_authenticate(isp);
+	if (rval) {
+		dev_err(&isp->pdev->dev, "FW authentication failed(%d)\n",
+			rval);
+		goto out_ipu_bus_del_devices;
+	}
+
+	ipu_mmu_hw_cleanup(isp->psys->mmu);
+	pm_runtime_put(&isp->psys->dev);
+
+#ifdef CONFIG_DEBUG_FS
+	rval = ipu_init_debugfs(isp);
+	if (rval) {
+		dev_err(&pdev->dev, "Failed to initialize debugfs");
+		goto out_ipu_bus_del_devices;
+	}
+#endif
+
+	/* Configure the arbitration mechanisms for VC requests */
+	ipu_configure_vc_mechanism(isp);
+
+	val = readl(isp->base + BUTTRESS_REG_SKU);
+	dev_info(&pdev->dev, "IPU%u-v%u driver version %d.%d\n",
+		 val & 0xf, (val >> 4) & 0x7,
+		 IPU_MAJOR_VERSION,
+		 IPU_MINOR_VERSION);
+
+	pm_runtime_put_noidle(&pdev->dev);
+	pm_runtime_allow(&pdev->dev);
+
+	isp->ipu_bus_ready_to_probe = true;
+
+	return 0;
+
+out_ipu_bus_del_devices:
+	if (isp->pkg_dir) {
+		if (isp->psys) {
+			ipu_cpd_free_pkg_dir(isp->psys, isp->pkg_dir,
+					     isp->pkg_dir_dma_addr,
+					     isp->pkg_dir_size);
+			ipu_buttress_unmap_fw_image(isp->psys, &isp->fw_sgt);
+		}
+		isp->pkg_dir = NULL;
+	}
+	if (!IS_ERR_OR_NULL(isp->psys) && !IS_ERR_OR_NULL(isp->psys->mmu))
+		ipu_mmu_cleanup(isp->psys->mmu);
+	if (!IS_ERR_OR_NULL(isp->isys) && !IS_ERR_OR_NULL(isp->isys->mmu))
+		ipu_mmu_cleanup(isp->isys->mmu);
+	if (!IS_ERR_OR_NULL(isp->psys))
+		pm_runtime_put(&isp->psys->dev);
+	ipu_bus_del_devices(pdev);
+	ipu_buttress_exit(isp);
+	release_firmware(isp->cpd_fw);
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA)
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_PDATA_DYNAMIC_LOADING)
+	release_firmware(isp->spdata_fw);
+#endif
+#endif
+
+	return rval;
+}
+
+static void ipu_pci_remove(struct pci_dev *pdev)
+{
+	struct ipu_device *isp = pci_get_drvdata(pdev);
+
+#ifdef CONFIG_DEBUG_FS
+	ipu_remove_debugfs(isp);
+#endif
+	ipu_trace_release(isp);
+
+	ipu_cpd_free_pkg_dir(isp->psys, isp->pkg_dir, isp->pkg_dir_dma_addr,
+			     isp->pkg_dir_size);
+
+	ipu_buttress_unmap_fw_image(isp->psys, &isp->fw_sgt);
+
+	isp->pkg_dir = NULL;
+	isp->pkg_dir_dma_addr = 0;
+	isp->pkg_dir_size = 0;
+
+	ipu_bus_del_devices(pdev);
+
+	pm_runtime_forbid(&pdev->dev);
+	pm_runtime_get_noresume(&pdev->dev);
+
+	pci_release_regions(pdev);
+	pci_disable_device(pdev);
+
+	ipu_buttress_exit(isp);
+
+	release_firmware(isp->cpd_fw);
+
+	ipu_mmu_cleanup(isp->psys->mmu);
+	ipu_mmu_cleanup(isp->isys->mmu);
+}
+
+static void ipu_pci_reset_prepare(struct pci_dev *pdev)
+{
+	struct ipu_device *isp = pci_get_drvdata(pdev);
+
+	dev_warn(&pdev->dev, "FLR prepare\n");
+	pm_runtime_forbid(&isp->pdev->dev);
+	isp->flr_done = true;
+}
+
+static void ipu_pci_reset_done(struct pci_dev *pdev)
+{
+	struct ipu_device *isp = pci_get_drvdata(pdev);
+
+	ipu_buttress_restore(isp);
+	if (isp->secure_mode)
+		ipu_buttress_reset_authentication(isp);
+
+	ipu_bus_flr_recovery();
+	isp->ipc_reinit = true;
+	pm_runtime_allow(&isp->pdev->dev);
+
+	dev_warn(&pdev->dev, "FLR completed\n");
+}
+
+#ifdef CONFIG_PM
+
+/*
+ * PCI base driver code requires driver to provide these to enable
+ * PCI device level PM state transitions (D0<->D3)
+ */
+static int ipu_suspend(struct device *dev)
+{
+	struct pci_dev *pdev = to_pci_dev(dev);
+	struct ipu_device *isp = pci_get_drvdata(pdev);
+
+	isp->flr_done = false;
+
+	return 0;
+}
+
+static int ipu_resume(struct device *dev)
+{
+	struct pci_dev *pdev = to_pci_dev(dev);
+	struct ipu_device *isp = pci_get_drvdata(pdev);
+	struct ipu_buttress *b = &isp->buttress;
+	int rval;
+
+	/* Configure the arbitration mechanisms for VC requests */
+	ipu_configure_vc_mechanism(isp);
+
+	ipu_buttress_set_secure_mode(isp);
+	isp->secure_mode = ipu_buttress_get_secure_mode(isp);
+	dev_info(dev, "IPU in %s mode\n",
+		 isp->secure_mode ? "secure" : "non-secure");
+
+	ipu_buttress_restore(isp);
+
+	rval = ipu_buttress_ipc_reset(isp, &b->cse);
+	if (rval)
+		dev_err(&isp->pdev->dev, "IPC reset protocol failed!\n");
+
+	rval = pm_runtime_get_sync(&isp->psys->dev);
+	if (rval < 0) {
+		dev_err(&isp->psys->dev, "Failed to get runtime PM\n");
+		return 0;
+	}
+
+	rval = ipu_buttress_authenticate(isp);
+	if (rval)
+		dev_err(&isp->pdev->dev, "FW authentication failed(%d)\n",
+			rval);
+
+	pm_runtime_put(&isp->psys->dev);
+
+	return 0;
+}
+
+static int ipu_runtime_resume(struct device *dev)
+{
+	struct pci_dev *pdev = to_pci_dev(dev);
+	struct ipu_device *isp = pci_get_drvdata(pdev);
+	int rval;
+
+	ipu_configure_vc_mechanism(isp);
+	ipu_buttress_restore(isp);
+
+	if (isp->ipc_reinit) {
+		struct ipu_buttress *b = &isp->buttress;
+
+		isp->ipc_reinit = false;
+		rval = ipu_buttress_ipc_reset(isp, &b->cse);
+		if (rval)
+			dev_err(&isp->pdev->dev,
+				"IPC reset protocol failed!\n");
+	}
+
+	return 0;
+}
+
+static const struct dev_pm_ops ipu_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(&ipu_suspend, &ipu_resume)
+	    SET_RUNTIME_PM_OPS(&ipu_suspend,	/* Same as in suspend flow */
+			       &ipu_runtime_resume,
+			       NULL)
+};
+
+#define IPU_PM (&ipu_pm_ops)
+#else
+#define IPU_PM NULL
+#endif
+
+static const struct pci_device_id ipu_pci_tbl[] = {
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, IPU6_PCI_ID)},
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, IPU6SE_PCI_ID)},
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, IPU6EP_ADL_P_PCI_ID)},
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, IPU6EP_ADL_N_PCI_ID)},
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, IPU6EP_RPL_P_PCI_ID)},
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, IPU6EP_MTL_PCI_ID)},
+	{0,}
+};
+MODULE_DEVICE_TABLE(pci, ipu_pci_tbl);
+
+static const struct pci_error_handlers pci_err_handlers = {
+	.reset_prepare = ipu_pci_reset_prepare,
+	.reset_done = ipu_pci_reset_done,
+};
+
+static struct pci_driver ipu_pci_driver = {
+	.name = IPU_NAME,
+	.id_table = ipu_pci_tbl,
+	.probe = ipu_pci_probe,
+	.remove = ipu_pci_remove,
+	.driver = {
+		   .pm = IPU_PM,
+		   },
+	.err_handler = &pci_err_handlers,
+};
+
+static int __init ipu_init(void)
+{
+	int rval = ipu_bus_register();
+
+	if (rval) {
+		pr_warn("can't register ipu bus (%d)\n", rval);
+		return rval;
+	}
+
+	rval = pci_register_driver(&ipu_pci_driver);
+	if (rval) {
+		pr_warn("can't register pci driver (%d)\n", rval);
+		goto out_pci_register_driver;
+	}
+
+	return 0;
+
+out_pci_register_driver:
+	ipu_bus_unregister();
+
+	return rval;
+}
+
+static void __exit ipu_exit(void)
+{
+	pci_unregister_driver(&ipu_pci_driver);
+	ipu_bus_unregister();
+}
+
+module_init(ipu_init);
+module_exit(ipu_exit);
+
+MODULE_AUTHOR("Sakari Ailus <sakari.ailus@linux.intel.com>");
+MODULE_AUTHOR("Jouni Hgander <jouni.hogander@intel.com>");
+MODULE_AUTHOR("Antti Laakso <antti.laakso@intel.com>");
+MODULE_AUTHOR("Samu Onkalo <samu.onkalo@intel.com>");
+MODULE_AUTHOR("Jianxu Zheng <jian.xu.zheng@intel.com>");
+MODULE_AUTHOR("Tianshu Qiu <tian.shu.qiu@intel.com>");
+MODULE_AUTHOR("Renwei Wu <renwei.wu@intel.com>");
+MODULE_AUTHOR("Bingbu Cao <bingbu.cao@intel.com>");
+MODULE_AUTHOR("Yunliang Ding <yunliang.ding@intel.com>");
+MODULE_AUTHOR("Zaikuo Wang <zaikuo.wang@intel.com>");
+MODULE_AUTHOR("Leifu Zhao <leifu.zhao@intel.com>");
+MODULE_AUTHOR("Xia Wu <xia.wu@intel.com>");
+MODULE_AUTHOR("Kun Jiang <kun.jiang@intel.com>");
+MODULE_AUTHOR("Intel");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Intel ipu pci driver");
Index: b/drivers/media/pci/intel/ipu.h
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu.h
@@ -0,0 +1,118 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2013 - 2020 Intel Corporation */
+
+#ifndef IPU_H
+#define IPU_H
+
+#include <linux/ioport.h>
+#include <linux/list.h>
+#include <uapi/linux/media.h>
+#include <linux/version.h>
+
+#include "ipu-pdata.h"
+#include "ipu-bus.h"
+#include "ipu-buttress.h"
+#include "ipu-trace.h"
+
+#define IPU6_PCI_ID	0x9a19
+#define IPU6SE_PCI_ID	0x4e19
+#define IPU6EP_ADL_P_PCI_ID	0x465d
+#define IPU6EP_ADL_N_PCI_ID	0x462e
+#define IPU6EP_RPL_P_PCI_ID	0xa75d
+#define IPU6EP_MTL_PCI_ID	0x7d19
+
+enum ipu_version {
+	IPU_VER_INVALID = 0,
+	IPU_VER_6,
+	IPU_VER_6SE,
+	IPU_VER_6EP,
+	IPU_VER_6EP_MTL,
+};
+
+/*
+ * IPU version definitions to reflect the IPU driver changes.
+ * Both ISYS and PSYS share the same version.
+ */
+#define IPU_MAJOR_VERSION 1
+#define IPU_MINOR_VERSION 0
+#define IPU_DRIVER_VERSION (IPU_MAJOR_VERSION << 16 | IPU_MINOR_VERSION)
+
+/* processing system frequency: 25Mhz x ratio, Legal values [8,32] */
+#define PS_FREQ_CTL_DEFAULT_RATIO	0x12
+
+/* input system frequency: 1600Mhz / divisor. Legal values [2,8] */
+#define IS_FREQ_SOURCE			1600000000
+#define IS_FREQ_CTL_DIVISOR		0x4
+
+/*
+ * ISYS DMA can overshoot. For higher resolutions over allocation is one line
+ * but it must be at minimum 1024 bytes. Value could be different in
+ * different versions / generations thus provide it via platform data.
+ */
+#define IPU_ISYS_OVERALLOC_MIN		1024
+
+/*
+ * Physical pages in GDA is 128, page size is 2K for IPU6, 1K for others.
+ */
+#define IPU_DEVICE_GDA_NR_PAGES		128
+
+/*
+ * Virtualization factor to calculate the available virtual pages.
+ */
+#define IPU_DEVICE_GDA_VIRT_FACTOR	32
+
+struct pci_dev;
+struct list_head;
+struct firmware;
+
+#define NR_OF_MMU_RESOURCES			2
+
+struct ipu_device {
+	struct pci_dev *pdev;
+	struct list_head devices;
+	struct ipu_bus_device *isys;
+	struct ipu_bus_device *psys;
+	struct ipu_buttress buttress;
+
+	const struct firmware *cpd_fw;
+	const char *cpd_fw_name;
+	u64 *pkg_dir;
+	dma_addr_t pkg_dir_dma_addr;
+	unsigned int pkg_dir_size;
+	struct sg_table fw_sgt;
+
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA)
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_PDATA_DYNAMIC_LOADING)
+	const struct firmware *spdata_fw;
+#endif
+#endif
+	void __iomem *base;
+#ifdef CONFIG_DEBUG_FS
+	struct dentry *ipu_dir;
+#endif
+	struct ipu_trace *trace;
+	bool flr_done;
+	bool ipc_reinit;
+	bool secure_mode;
+	bool ipu_bus_ready_to_probe;
+
+	int (*cpd_fw_reload)(struct ipu_device *isp);
+};
+
+#define IPU_DMA_MASK	39
+#define IPU_LIB_CALL_TIMEOUT_MS		2000
+#define IPU_PSYS_CMD_TIMEOUT_MS	2000
+#define IPU_PSYS_OPEN_TIMEOUT_US	   50
+#define IPU_PSYS_OPEN_RETRY (10000 / IPU_PSYS_OPEN_TIMEOUT_US)
+
+int ipu_fw_authenticate(void *data, u64 val);
+void ipu_configure_spc(struct ipu_device *isp,
+		       const struct ipu_hw_variants *hw_variant,
+		       int pkg_dir_idx, void __iomem *base, u64 *pkg_dir,
+		       dma_addr_t pkg_dir_dma_addr);
+int request_cpd_fw(const struct firmware **firmware_p, const char *name,
+		   struct device *device);
+extern enum ipu_version ipu_ver;
+void ipu_internal_pdata_init(void);
+
+#endif /* IPU_H */
Index: b/drivers/media/pci/intel/ipu6/Makefile
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu6/Makefile
@@ -0,0 +1,61 @@
+# SPDX-License-Identifier: GPL-2.0
+# Copyright (c) 2017 - 2020 Intel Corporation.
+
+ifneq ($(EXTERNAL_BUILD), 1)
+srcpath := $(srctree)
+endif
+
+ccflags-y += -DIPU_HAS_S2M -DIPU_TPG_FRAME_SYNC -DIPU_PSYS_GPC \
+		-DIPU_ISYS_GPC -DI2C_DYNAMIC
+ccflags-y += -DIPU_ISYS_RESET
+
+intel-ipu6-objs				+= ../ipu.o \
+					   ../ipu-bus.o \
+					   ../ipu-dma.o \
+					   ../ipu-mmu.o \
+					   ../ipu-buttress.o \
+					   ../ipu-trace.o \
+					   ../ipu-cpd.o \
+					   ipu6.o \
+					   ../ipu-fw-com.o
+
+obj-$(CONFIG_VIDEO_INTEL_IPU6)		+= intel-ipu6.o
+
+intel-ipu6-isys-objs			+= ../ipu-isys.o \
+					   ../ipu-isys-csi2.o \
+					   ipu6-isys.o \
+					   ipu6-isys-phy.o \
+					   ipu6-isys-dwc-phy.o \
+					   ipu6-isys-csi2.o \
+					   ipu6-isys-gpc.o \
+					   ../ipu-isys-csi2-be-soc.o \
+					   ../ipu-fw-isys.o \
+					   ../ipu-isys-video.o \
+					   ../ipu-isys-queue.o \
+					   ../ipu-isys-subdev.o
+intel-ipu6-isys-objs			+= ../ipu-isys-csi2-be.o
+
+obj-$(CONFIG_VIDEO_INTEL_IPU6)		+= intel-ipu6-isys.o
+
+intel-ipu6-psys-objs			+= ../ipu-psys.o \
+					   ipu6-psys.o \
+					   ipu-resources.o \
+					   ipu6-psys-gpc.o \
+					   ipu6-l-scheduler.o \
+					   ipu6-ppg.o
+
+intel-ipu6-psys-objs			+= ipu-fw-resources.o \
+					   ipu6-fw-resources.o \
+					   ipu6se-fw-resources.o \
+					   ipu6ep-fw-resources.o \
+					   ../ipu-fw-psys.o
+
+ifeq ($(CONFIG_COMPAT),y)
+intel-ipu6-psys-objs			+= ../ipu-psys-compat32.o
+endif
+
+obj-$(CONFIG_VIDEO_INTEL_IPU6)		+= intel-ipu6-psys.o
+
+ccflags-y += -I$(srcpath)/$(src)/../../../../../include/
+ccflags-y += -I$(srcpath)/$(src)/../
+ccflags-y += -I$(srcpath)/$(src)/
Index: b/drivers/media/pci/intel/ipu6/ipu-fw-resources.c
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu6/ipu-fw-resources.c
@@ -0,0 +1,103 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) 2015 - 2019 Intel Corporation
+
+#include <linux/err.h>
+#include <linux/string.h>
+
+#include "ipu-psys.h"
+#include "ipu-fw-psys.h"
+#include "ipu6-platform-resources.h"
+#include "ipu6se-platform-resources.h"
+
+/********** Generic resource handling **********/
+
+/*
+ * Extension library gives byte offsets to its internal structures.
+ * use those offsets to update fields. Without extension lib access
+ * structures directly.
+ */
+const struct ipu6_psys_hw_res_variant *var = &hw_var;
+
+int ipu_fw_psys_set_process_cell_id(struct ipu_fw_psys_process *ptr, u8 index,
+				    u8 value)
+{
+	struct ipu_fw_psys_process_group *parent =
+		(struct ipu_fw_psys_process_group *)((char *)ptr +
+						      ptr->parent_offset);
+
+	ptr->cells[index] = value;
+	parent->resource_bitmap |= 1 << value;
+
+	return 0;
+}
+
+u8 ipu_fw_psys_get_process_cell_id(struct ipu_fw_psys_process *ptr, u8 index)
+{
+	return ptr->cells[index];
+}
+
+int ipu_fw_psys_clear_process_cell(struct ipu_fw_psys_process *ptr)
+{
+	struct ipu_fw_psys_process_group *parent;
+	u8 cell_id = ipu_fw_psys_get_process_cell_id(ptr, 0);
+	int retval = -1;
+	u8 value;
+
+	parent = (struct ipu_fw_psys_process_group *)((char *)ptr +
+						       ptr->parent_offset);
+
+	value = var->cell_num;
+	if ((1 << cell_id) != 0 &&
+	    ((1 << cell_id) & parent->resource_bitmap)) {
+		ipu_fw_psys_set_process_cell_id(ptr, 0, value);
+		parent->resource_bitmap &= ~(1 << cell_id);
+		retval = 0;
+	}
+
+	return retval;
+}
+
+int ipu_fw_psys_set_proc_dev_chn(struct ipu_fw_psys_process *ptr, u16 offset,
+				 u16 value)
+{
+	if (var->set_proc_dev_chn)
+		return var->set_proc_dev_chn(ptr, offset, value);
+
+	WARN(1, "ipu6 psys res var is not initialised correctly.");
+	return 0;
+}
+
+int ipu_fw_psys_set_proc_dfm_bitmap(struct ipu_fw_psys_process *ptr,
+				    u16 id, u32 bitmap,
+				    u32 active_bitmap)
+{
+	if (var->set_proc_dfm_bitmap)
+		return var->set_proc_dfm_bitmap(ptr, id, bitmap,
+						active_bitmap);
+
+	WARN(1, "ipu6 psys res var is not initialised correctly.");
+	return 0;
+}
+
+int ipu_fw_psys_set_process_ext_mem(struct ipu_fw_psys_process *ptr,
+				    u16 type_id, u16 mem_id, u16 offset)
+{
+	if (var->set_proc_ext_mem)
+		return var->set_proc_ext_mem(ptr, type_id, mem_id, offset);
+
+	WARN(1, "ipu6 psys res var is not initialised correctly.");
+	return 0;
+}
+
+int ipu_fw_psys_get_program_manifest_by_process(
+	struct ipu_fw_generic_program_manifest *gen_pm,
+	const struct ipu_fw_psys_program_group_manifest *pg_manifest,
+	struct ipu_fw_psys_process *process)
+{
+	if (var->get_pgm_by_proc)
+		return var->get_pgm_by_proc(gen_pm, pg_manifest, process);
+
+	WARN(1, "ipu6 psys res var is not initialised correctly.");
+	return 0;
+}
+
Index: b/drivers/media/pci/intel/ipu6/ipu-platform-buttress-regs.h
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu6/ipu-platform-buttress-regs.h
@@ -0,0 +1,329 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2020 Intel Corporation */
+
+#ifndef IPU_PLATFORM_BUTTRESS_REGS_H
+#define IPU_PLATFORM_BUTTRESS_REGS_H
+
+/* IS_WORKPOINT_REQ */
+#define IPU_BUTTRESS_REG_IS_FREQ_CTL		0x34
+/* PS_WORKPOINT_REQ */
+#define IPU_BUTTRESS_REG_PS_FREQ_CTL		0x38
+
+#define IPU_BUTTRESS_IS_FREQ_RATIO_MASK	0xff
+#define IPU_BUTTRESS_PS_FREQ_RATIO_MASK	0xff
+
+#define IPU_IS_FREQ_MAX		533
+#define IPU_IS_FREQ_MIN		200
+#define IPU_PS_FREQ_MAX		450
+#define IPU_IS_FREQ_RATIO_BASE		25
+#define IPU_PS_FREQ_RATIO_BASE		25
+#define IPU_BUTTRESS_IS_FREQ_CTL_DIVISOR_MASK	0xff
+#define IPU_BUTTRESS_PS_FREQ_CTL_DIVISOR_MASK	0xff
+
+/* should be tuned for real silicon */
+#define IPU_IS_FREQ_CTL_DEFAULT_RATIO		0x08
+#define IPU6SE_IS_FREQ_CTL_DEFAULT_RATIO	0x0a
+#define IPU_PS_FREQ_CTL_DEFAULT_RATIO		0x0d
+
+#define IPU_IS_FREQ_CTL_DEFAULT_QOS_FLOOR_RATIO	0x10
+#define IPU_PS_FREQ_CTL_DEFAULT_QOS_FLOOR_RATIO	0x0708
+
+#define IPU_BUTTRESS_PWR_STATE_IS_PWR_SHIFT	3
+#define IPU_BUTTRESS_PWR_STATE_IS_PWR_MASK	\
+	(0x3 << IPU_BUTTRESS_PWR_STATE_IS_PWR_SHIFT)
+
+#define IPU_BUTTRESS_PWR_STATE_PS_PWR_SHIFT	6
+#define IPU_BUTTRESS_PWR_STATE_PS_PWR_MASK	\
+	(0x3 << IPU_BUTTRESS_PWR_STATE_PS_PWR_SHIFT)
+
+#define IPU_BUTTRESS_PWR_STATE_DN_DONE		0x0
+#define IPU_BUTTRESS_PWR_STATE_UP_PROCESS	0x1
+#define IPU_BUTTRESS_PWR_STATE_DN_PROCESS	0x2
+#define IPU_BUTTRESS_PWR_STATE_UP_DONE		0x3
+
+#define IPU_BUTTRESS_REG_FPGA_SUPPORT_0	0x270
+#define IPU_BUTTRESS_REG_FPGA_SUPPORT_1	0x274
+#define IPU_BUTTRESS_REG_FPGA_SUPPORT_2	0x278
+#define IPU_BUTTRESS_REG_FPGA_SUPPORT_3	0x27c
+#define IPU_BUTTRESS_REG_FPGA_SUPPORT_4	0x280
+#define IPU_BUTTRESS_REG_FPGA_SUPPORT_5	0x284
+#define IPU_BUTTRESS_REG_FPGA_SUPPORT_6	0x288
+#define IPU_BUTTRESS_REG_FPGA_SUPPORT_7	0x28c
+
+#define BUTTRESS_REG_WDT			0x8
+#define BUTTRESS_REG_BTRS_CTRL			0xc
+#define BUTTRESS_REG_BTRS_CTRL_STALL_MODE_VC0	BIT(0)
+#define BUTTRESS_REG_BTRS_CTRL_STALL_MODE_VC1	BIT(1)
+#define BUTTRESS_REG_BTRS_CTRL_REF_CLK_IND	GENMASK(9, 8)
+
+#define BUTTRESS_REG_FW_RESET_CTL	0x30
+#define BUTTRESS_FW_RESET_CTL_START	BIT(0)
+#define BUTTRESS_FW_RESET_CTL_DONE	BIT(1)
+
+#define BUTTRESS_REG_IS_FREQ_CTL	0x34
+
+#define BUTTRESS_IS_FREQ_CTL_DIVISOR_MASK	0xf
+
+#define BUTTRESS_REG_PS_FREQ_CTL	0x38
+
+#define BUTTRESS_PS_FREQ_CTL_RATIO_MASK		0xff
+
+#define BUTTRESS_FREQ_CTL_START		BIT(31)
+#define BUTTRESS_FREQ_CTL_START_SHIFT		31
+#define BUTTRESS_FREQ_CTL_QOS_FLOOR_SHIFT	8
+#define BUTTRESS_FREQ_CTL_ICCMAX_LEVEL		(GENMASK(19, 16))
+#define BUTTRESS_FREQ_CTL_QOS_FLOOR_MASK	(0xff << 8)
+
+#define BUTTRESS_REG_PWR_STATE	0x5c
+
+#define BUTTRESS_PWR_STATE_IS_PWR_SHIFT	3
+#define BUTTRESS_PWR_STATE_IS_PWR_MASK	(0x3 << 3)
+
+#define BUTTRESS_PWR_STATE_PS_PWR_SHIFT	6
+#define BUTTRESS_PWR_STATE_PS_PWR_MASK	(0x3 << 6)
+
+#define BUTTRESS_PWR_STATE_RESET		0x0
+#define BUTTRESS_PWR_STATE_PWR_ON_DONE		0x1
+#define BUTTRESS_PWR_STATE_PWR_RDY		0x3
+#define BUTTRESS_PWR_STATE_PWR_IDLE		0x4
+
+#define BUTTRESS_PWR_STATE_HH_STATUS_SHIFT	11
+#define BUTTRESS_PWR_STATE_HH_STATUS_MASK	(0x3 << 11)
+
+enum {
+	BUTTRESS_PWR_STATE_HH_STATE_IDLE,
+	BUTTRESS_PWR_STATE_HH_STATE_IN_PRGS,
+	BUTTRESS_PWR_STATE_HH_STATE_DONE,
+	BUTTRESS_PWR_STATE_HH_STATE_ERR,
+};
+
+#define BUTTRESS_PWR_STATE_IS_PWR_FSM_SHIFT	19
+#define BUTTRESS_PWR_STATE_IS_PWR_FSM_MASK	(0xf << 19)
+
+#define BUTTRESS_PWR_STATE_IS_PWR_FSM_IDLE			0x0
+#define BUTTRESS_PWR_STATE_IS_PWR_FSM_WAIT_4_PLL_CMP		0x1
+#define BUTTRESS_PWR_STATE_IS_PWR_FSM_WAIT_4_CLKACK		0x2
+#define BUTTRESS_PWR_STATE_IS_PWR_FSM_WAIT_4_PG_ACK		0x3
+#define BUTTRESS_PWR_STATE_IS_PWR_FSM_RST_ASSRT_CYCLES		0x4
+#define BUTTRESS_PWR_STATE_IS_PWR_FSM_STOP_CLK_CYCLES1		0x5
+#define BUTTRESS_PWR_STATE_IS_PWR_FSM_STOP_CLK_CYCLES2		0x6
+#define BUTTRESS_PWR_STATE_IS_PWR_FSM_RST_DEASSRT_CYCLES	0x7
+#define BUTTRESS_PWR_STATE_IS_PWR_FSM_WAIT_4_FUSE_WR_CMP	0x8
+#define BUTTRESS_PWR_STATE_IS_PWR_FSM_BRK_POINT			0x9
+#define BUTTRESS_PWR_STATE_IS_PWR_FSM_IS_RDY			0xa
+#define BUTTRESS_PWR_STATE_IS_PWR_FSM_HALT_HALTED		0xb
+#define BUTTRESS_PWR_STATE_IS_PWR_FSM_RST_DURATION_CNT3		0xc
+#define BUTTRESS_PWR_STATE_IS_PWR_FSM_WAIT_4_CLKACK_PD		0xd
+#define BUTTRESS_PWR_STATE_IS_PWR_FSM_PD_BRK_POINT		0xe
+#define BUTTRESS_PWR_STATE_IS_PWR_FSM_WAIT_4_PD_PG_ACK0		0xf
+
+#define BUTTRESS_PWR_STATE_PS_PWR_FSM_SHIFT	24
+#define BUTTRESS_PWR_STATE_PS_PWR_FSM_MASK	(0x1f << 24)
+
+#define BUTTRESS_PWR_STATE_PS_PWR_FSM_IDLE			0x0
+#define BUTTRESS_PWR_STATE_PS_PWR_FSM_WAIT_PU_PLL_IP_RDY	0x1
+#define BUTTRESS_PWR_STATE_PS_PWR_FSM_WAIT_RO_PRE_CNT_EXH	0x2
+#define BUTTRESS_PWR_STATE_PS_PWR_FSM_WAIT_PU_VGI_PWRGOOD	0x3
+#define BUTTRESS_PWR_STATE_PS_PWR_FSM_WAIT_RO_POST_CNT_EXH	0x4
+#define BUTTRESS_PWR_STATE_PS_PWR_FSM_WR_PLL_RATIO		0x5
+#define BUTTRESS_PWR_STATE_PS_PWR_FSM_WAIT_PU_PLL_CMP		0x6
+#define BUTTRESS_PWR_STATE_PS_PWR_FSM_WAIT_PU_CLKACK		0x7
+#define BUTTRESS_PWR_STATE_PS_PWR_FSM_RST_ASSRT_CYCLES		0x8
+#define BUTTRESS_PWR_STATE_PS_PWR_FSM_STOP_CLK_CYCLES1		0x9
+#define BUTTRESS_PWR_STATE_PS_PWR_FSM_STOP_CLK_CYCLES2		0xa
+#define BUTTRESS_PWR_STATE_PS_PWR_FSM_RST_DEASSRT_CYCLES	0xb
+#define BUTTRESS_PWR_STATE_PS_PWR_FSM_PU_BRK_PNT		0xc
+#define BUTTRESS_PWR_STATE_PS_PWR_FSM_WAIT_FUSE_ACCPT		0xd
+#define BUTTRESS_PWR_STATE_PS_PWR_FSM_PS_PWR_UP			0xf
+#define BUTTRESS_PWR_STATE_PS_PWR_FSM_WAIT_4_HALTED		0x10
+#define BUTTRESS_PWR_STATE_PS_PWR_FSM_RESET_CNT3		0x11
+#define BUTTRESS_PWR_STATE_PS_PWR_FSM_WAIT_PD_CLKACK		0x12
+#define BUTTRESS_PWR_STATE_PS_PWR_FSM_WAIT_PD_OFF_IND		0x13
+#define BUTTRESS_PWR_STATE_PS_PWR_FSM_WAIT_DVFS_PH4		0x14
+#define BUTTRESS_PWR_STATE_PS_PWR_FSM_WAIT_DVFS_PLL_CMP		0x15
+#define BUTTRESS_PWR_STATE_PS_PWR_FSM_WAIT_DVFS_CLKACK		0x16
+
+#define BUTTRESS_REG_SECURITY_CTL	0x300
+#define BUTTRESS_REG_SKU		0x314
+#define BUTTRESS_REG_SECURITY_TOUCH	0x318
+#define BUTTRESS_REG_CAMERA_MASK	0x84
+
+#define BUTTRESS_SECURITY_CTL_FW_SECURE_MODE	BIT(16)
+#define BUTTRESS_SECURITY_CTL_FW_SETUP_SHIFT		0
+#define BUTTRESS_SECURITY_CTL_FW_SETUP_MASK		0x1f
+
+#define BUTTRESS_SECURITY_CTL_FW_SETUP_DONE		0x1
+#define BUTTRESS_SECURITY_CTL_AUTH_DONE			0x2
+#define BUTTRESS_SECURITY_CTL_AUTH_FAILED			0x8
+
+#define BUTTRESS_REG_SENSOR_FREQ_CTL	0x16c
+
+#define BUTTRESS_SENSOR_FREQ_CTL_OSC_OUT_FREQ_DEFAULT(i) \
+					(0x1b << ((i) * 10))
+#define BUTTRESS_SENSOR_FREQ_CTL_OSC_OUT_FREQ_SHIFT(i)	((i) * 10)
+#define BUTTRESS_SENSOR_FREQ_CTL_OSC_OUT_FREQ_MASK(i) \
+					(0x1ff << ((i) * 10))
+
+#define BUTTRESS_SENSOR_CLK_FREQ_6P75MHZ	0x176
+#define BUTTRESS_SENSOR_CLK_FREQ_8MHZ		0x164
+#define BUTTRESS_SENSOR_CLK_FREQ_9P6MHZ		0x2
+#define BUTTRESS_SENSOR_CLK_FREQ_12MHZ		0x1b2
+#define BUTTRESS_SENSOR_CLK_FREQ_13P6MHZ	0x1ac
+#define BUTTRESS_SENSOR_CLK_FREQ_14P4MHZ	0x1cc
+#define BUTTRESS_SENSOR_CLK_FREQ_15P8MHZ	0x1a6
+#define BUTTRESS_SENSOR_CLK_FREQ_16P2MHZ	0xca
+#define BUTTRESS_SENSOR_CLK_FREQ_17P3MHZ	0x12e
+#define BUTTRESS_SENSOR_CLK_FREQ_18P6MHZ	0x1c0
+#define BUTTRESS_SENSOR_CLK_FREQ_19P2MHZ	0x0
+#define BUTTRESS_SENSOR_CLK_FREQ_24MHZ		0xb2
+#define BUTTRESS_SENSOR_CLK_FREQ_26MHZ		0xae
+#define BUTTRESS_SENSOR_CLK_FREQ_27MHZ		0x196
+
+#define BUTTRESS_SENSOR_FREQ_CTL_LJPLL_FB_RATIO_MASK		0xff
+#define BUTTRESS_SENSOR_FREQ_CTL_SEL_MIPICLK_A_SHIFT		8
+#define BUTTRESS_SENSOR_FREQ_CTL_SEL_MIPICLK_A_MASK		(0x2 << 8)
+#define BUTTRESS_SENSOR_FREQ_CTL_SEL_MIPICLK_C_SHIFT		10
+#define BUTTRESS_SENSOR_FREQ_CTL_SEL_MIPICLK_C_MASK		(0x2 << 10)
+#define BUTTRESS_SENSOR_FREQ_CTL_LJPLL_FORCE_OFF_SHIFT		12
+#define BUTTRESS_SENSOR_FREQ_CTL_LJPLL_REF_RATIO_SHIFT		14
+#define BUTTRESS_SENSOR_FREQ_CTL_LJPLL_REF_RATIO_MASK		(0x2 << 14)
+#define BUTTRESS_SENSOR_FREQ_CTL_LJPLL_PVD_RATIO_SHIFT		16
+#define BUTTRESS_SENSOR_FREQ_CTL_LJPLL_PVD_RATIO_MASK		(0x2 << 16)
+#define BUTTRESS_SENSOR_FREQ_CTL_LJPLL_OUTPUT_RATIO_SHIFT	18
+#define BUTTRESS_SENSOR_FREQ_CTL_LJPLL_OUTPUT_RATIO_MASK	(0x2 << 18)
+#define BUTTRESS_SENSOR_FREQ_CTL_START_SHIFT			31
+
+#define BUTTRESS_REG_SENSOR_CLK_CTL	0x170
+
+/* 0 <= i <= 2 */
+#define BUTTRESS_SENSOR_CLK_CTL_OSC_CLK_OUT_EN_SHIFT(i)		((i) * 2)
+#define BUTTRESS_SENSOR_CLK_CTL_OSC_CLK_OUT_SEL_SHIFT(i)	((i) * 2 + 1)
+
+#define BUTTRESS_REG_FW_SOURCE_BASE_LO	0x78
+#define BUTTRESS_REG_FW_SOURCE_BASE_HI	0x7C
+#define BUTTRESS_REG_FW_SOURCE_SIZE	0x80
+
+#define BUTTRESS_REG_ISR_STATUS		0x90
+#define BUTTRESS_REG_ISR_ENABLED_STATUS	0x94
+#define BUTTRESS_REG_ISR_ENABLE		0x98
+#define BUTTRESS_REG_ISR_CLEAR		0x9C
+
+#define BUTTRESS_ISR_IS_IRQ			BIT(0)
+#define BUTTRESS_ISR_PS_IRQ			BIT(1)
+#define BUTTRESS_ISR_IPC_EXEC_DONE_BY_CSE	BIT(2)
+#define BUTTRESS_ISR_IPC_EXEC_DONE_BY_ISH	BIT(3)
+#define BUTTRESS_ISR_IPC_FROM_CSE_IS_WAITING	BIT(4)
+#define BUTTRESS_ISR_IPC_FROM_ISH_IS_WAITING	BIT(5)
+#define BUTTRESS_ISR_CSE_CSR_SET		BIT(6)
+#define BUTTRESS_ISR_ISH_CSR_SET		BIT(7)
+#define BUTTRESS_ISR_SPURIOUS_CMP		BIT(8)
+#define BUTTRESS_ISR_WATCHDOG_EXPIRED		BIT(9)
+#define BUTTRESS_ISR_PUNIT_2_IUNIT_IRQ		BIT(10)
+#define BUTTRESS_ISR_SAI_VIOLATION		BIT(11)
+#define BUTTRESS_ISR_HW_ASSERTION		BIT(12)
+#define BUTTRESS_ISR_IS_CORRECTABLE_MEM_ERR	BIT(13)
+#define BUTTRESS_ISR_IS_FATAL_MEM_ERR		BIT(14)
+#define BUTTRESS_ISR_IS_NON_FATAL_MEM_ERR	BIT(15)
+#define BUTTRESS_ISR_PS_CORRECTABLE_MEM_ERR	BIT(16)
+#define BUTTRESS_ISR_PS_FATAL_MEM_ERR		BIT(17)
+#define BUTTRESS_ISR_PS_NON_FATAL_MEM_ERR	BIT(18)
+#define BUTTRESS_ISR_PS_FAST_THROTTLE		BIT(19)
+#define BUTTRESS_ISR_UFI_ERROR			BIT(20)
+
+#define BUTTRESS_REG_IU2CSEDB0	0x100
+
+#define BUTTRESS_IU2CSEDB0_BUSY		BIT(31)
+#define BUTTRESS_IU2CSEDB0_SHORT_FORMAT_SHIFT	27
+#define BUTTRESS_IU2CSEDB0_CLIENT_ID_SHIFT	10
+#define BUTTRESS_IU2CSEDB0_IPC_CLIENT_ID_VAL	2
+
+#define BUTTRESS_REG_IU2CSEDATA0	0x104
+
+#define BUTTRESS_IU2CSEDATA0_IPC_BOOT_LOAD		1
+#define BUTTRESS_IU2CSEDATA0_IPC_AUTH_RUN		2
+#define BUTTRESS_IU2CSEDATA0_IPC_AUTH_REPLACE		3
+#define BUTTRESS_IU2CSEDATA0_IPC_UPDATE_SECURE_TOUCH	16
+
+#define BUTTRESS_CSE2IUDATA0_IPC_BOOT_LOAD_DONE			1
+#define BUTTRESS_CSE2IUDATA0_IPC_AUTH_RUN_DONE			2
+#define BUTTRESS_CSE2IUDATA0_IPC_AUTH_REPLACE_DONE		4
+#define BUTTRESS_CSE2IUDATA0_IPC_UPDATE_SECURE_TOUCH_DONE	16
+
+#define BUTTRESS_REG_IU2CSECSR		0x108
+
+#define BUTTRESS_IU2CSECSR_IPC_PEER_COMP_ACTIONS_RST_PHASE1		BIT(0)
+#define BUTTRESS_IU2CSECSR_IPC_PEER_COMP_ACTIONS_RST_PHASE2		BIT(1)
+#define BUTTRESS_IU2CSECSR_IPC_PEER_QUERIED_IP_COMP_ACTIONS_RST_PHASE	BIT(2)
+#define BUTTRESS_IU2CSECSR_IPC_PEER_ASSERTED_REG_VALID_REQ		BIT(3)
+#define BUTTRESS_IU2CSECSR_IPC_PEER_ACKED_REG_VALID			BIT(4)
+#define BUTTRESS_IU2CSECSR_IPC_PEER_DEASSERTED_REG_VALID_REQ		BIT(5)
+
+#define BUTTRESS_REG_CSE2IUDB0		0x304
+#define BUTTRESS_REG_CSE2IUCSR		0x30C
+#define BUTTRESS_REG_CSE2IUDATA0	0x308
+
+/* 0x20 == NACK, 0xf == unknown command */
+#define BUTTRESS_CSE2IUDATA0_IPC_NACK      0xf20
+#define BUTTRESS_CSE2IUDATA0_IPC_NACK_MASK 0xffff
+
+#define BUTTRESS_REG_ISH2IUCSR		0x50
+#define BUTTRESS_REG_ISH2IUDB0		0x54
+#define BUTTRESS_REG_ISH2IUDATA0	0x58
+
+#define BUTTRESS_REG_IU2ISHDB0		0x10C
+#define BUTTRESS_REG_IU2ISHDATA0	0x110
+#define BUTTRESS_REG_IU2ISHDATA1	0x114
+#define BUTTRESS_REG_IU2ISHCSR		0x118
+
+#define BUTTRESS_REG_ISH_START_DETECT		0x198
+#define BUTTRESS_REG_ISH_START_DETECT_MASK	0x19C
+
+#define BUTTRESS_REG_FABRIC_CMD	0x88
+
+#define BUTTRESS_FABRIC_CMD_START_TSC_SYNC	BIT(0)
+#define BUTTRESS_FABRIC_CMD_IS_DRAIN		BIT(4)
+
+#define BUTTRESS_REG_TSW_CTL		0x120
+#define BUTTRESS_TSW_CTL_SOFT_RESET	BIT(8)
+
+#define BUTTRESS_REG_TSC_LO	0x164
+#define BUTTRESS_REG_TSC_HI	0x168
+
+#define BUTTRESS_REG_CSI2_PORT_CONFIG_AB		0x200
+#define BUTTRESS_CSI2_PORT_CONFIG_AB_MUX_MASK		0x1f
+#define BUTTRESS_CSI2_PORT_CONFIG_AB_COMBO_SHIFT_B0	16
+
+#define BUTTRESS_REG_PS_FREQ_CAPABILITIES			0xf7498
+
+#define BUTTRESS_PS_FREQ_CAPABILITIES_LAST_RESOLVED_RATIO_SHIFT	24
+#define BUTTRESS_PS_FREQ_CAPABILITIES_LAST_RESOLVED_RATIO_MASK	(0xff << 24)
+#define BUTTRESS_PS_FREQ_CAPABILITIES_MAX_RATIO_SHIFT		16
+#define BUTTRESS_PS_FREQ_CAPABILITIES_MAX_RATIO_MASK		(0xff << 16)
+#define BUTTRESS_PS_FREQ_CAPABILITIES_EFFICIENT_RATIO_SHIFT	8
+#define BUTTRESS_PS_FREQ_CAPABILITIES_EFFICIENT_RATIO_MASK	(0xff << 8)
+#define BUTTRESS_PS_FREQ_CAPABILITIES_MIN_RATIO_SHIFT		0
+#define BUTTRESS_PS_FREQ_CAPABILITIES_MIN_RATIO_MASK		(0xff)
+
+#define BUTTRESS_IRQS		(BUTTRESS_ISR_IPC_FROM_CSE_IS_WAITING |	\
+				 BUTTRESS_ISR_IPC_EXEC_DONE_BY_CSE |	\
+				 BUTTRESS_ISR_IS_IRQ |			\
+				 BUTTRESS_ISR_PS_IRQ)
+
+#define IPU6SE_ISYS_PHY_0_BASE		0x10000
+
+/* only use BB0, BB2, BB4, and BB6 on PHY0 */
+#define IPU6SE_ISYS_PHY_BB_NUM		4
+
+/* offset from PHY base */
+#define PHY_CSI_CFG			0xc0
+#define PHY_CSI_RCOMP_CONTROL		0xc8
+#define PHY_CSI_BSCAN_EXCLUDE		0xd8
+
+#define PHY_CPHY_DLL_OVRD(x)		(0x100 + 0x100 * (x))
+#define PHY_DPHY_DLL_OVRD(x)		(0x14c + 0x100 * (x))
+#define PHY_CPHY_RX_CONTROL1(x)		(0x110 + 0x100 * (x))
+#define PHY_CPHY_RX_CONTROL2(x)		(0x114 + 0x100 * (x))
+#define PHY_DPHY_CFG(x)			(0x148 + 0x100 * (x))
+#define PHY_BB_AFE_CONFIG(x)		(0x174 + 0x100 * (x))
+
+#endif /* IPU_PLATFORM_BUTTRESS_REGS_H */
Index: b/drivers/media/pci/intel/ipu6/ipu-platform-isys-csi2-reg.h
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu6/ipu-platform-isys-csi2-reg.h
@@ -0,0 +1,279 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2020 Intel Corporation */
+
+#ifndef IPU_PLATFORM_ISYS_CSI2_REG_H
+#define IPU_PLATFORM_ISYS_CSI2_REG_H
+
+#define CSI_REG_BASE			0x220000
+#define CSI_REG_BASE_PORT(id)		((id) * 0x1000)
+
+#define IPU_CSI_PORT_A_ADDR_OFFSET	\
+		(CSI_REG_BASE + CSI_REG_BASE_PORT(0))
+#define IPU_CSI_PORT_B_ADDR_OFFSET	\
+		(CSI_REG_BASE + CSI_REG_BASE_PORT(1))
+#define IPU_CSI_PORT_C_ADDR_OFFSET	\
+		(CSI_REG_BASE + CSI_REG_BASE_PORT(2))
+#define IPU_CSI_PORT_D_ADDR_OFFSET	\
+		(CSI_REG_BASE + CSI_REG_BASE_PORT(3))
+#define IPU_CSI_PORT_E_ADDR_OFFSET	\
+		(CSI_REG_BASE + CSI_REG_BASE_PORT(4))
+#define IPU_CSI_PORT_F_ADDR_OFFSET	\
+		(CSI_REG_BASE + CSI_REG_BASE_PORT(5))
+#define IPU_CSI_PORT_G_ADDR_OFFSET	\
+		(CSI_REG_BASE + CSI_REG_BASE_PORT(6))
+#define IPU_CSI_PORT_H_ADDR_OFFSET	\
+		(CSI_REG_BASE + CSI_REG_BASE_PORT(7))
+
+/* CSI Port Genral Purpose Registers */
+#define CSI_REG_PORT_GPREG_SRST                 0x0
+#define CSI_REG_PORT_GPREG_CSI2_SLV_REG_SRST    0x4
+#define CSI_REG_PORT_GPREG_CSI2_PORT_CONTROL    0x8
+
+/*
+ * Port IRQs mapping events:
+ * IRQ0 - CSI_FE event
+ * IRQ1 - CSI_SYNC
+ * IRQ2 - S2M_SIDS0TO7
+ * IRQ3 - S2M_SIDS8TO15
+ */
+#define CSI_PORT_REG_BASE_IRQ_CSI               0x80
+#define CSI_PORT_REG_BASE_IRQ_CSI_SYNC          0xA0
+#define CSI_PORT_REG_BASE_IRQ_S2M_SIDS0TOS7     0xC0
+#define CSI_PORT_REG_BASE_IRQ_S2M_SIDS8TOS15    0xE0
+
+#define CSI_PORT_REG_BASE_IRQ_EDGE_OFFSET	0x0
+#define CSI_PORT_REG_BASE_IRQ_MASK_OFFSET	0x4
+#define CSI_PORT_REG_BASE_IRQ_STATUS_OFFSET	0x8
+#define CSI_PORT_REG_BASE_IRQ_CLEAR_OFFSET	0xc
+#define CSI_PORT_REG_BASE_IRQ_ENABLE_OFFSET	0x10
+#define CSI_PORT_REG_BASE_IRQ_LEVEL_NOT_PULSE_OFFSET	0x14
+
+#define IPU6SE_CSI_RX_ERROR_IRQ_MASK		0x7ffff
+#define IPU6_CSI_RX_ERROR_IRQ_MASK		0xfffff
+
+#define CSI_RX_NUM_ERRORS_IN_IRQ		20
+#define CSI_RX_NUM_IRQ				32
+
+#define IPU_CSI_RX_IRQ_FS_VC(chn)	(1 << ((chn) * 2))
+#define IPU_CSI_RX_IRQ_FE_VC(chn)	(2 << ((chn) * 2))
+
+/* PPI2CSI */
+#define CSI_REG_PPI2CSI_ENABLE                  0x200
+#define CSI_REG_PPI2CSI_CONFIG_PPI_INTF         0x204
+#define PPI_INTF_CONFIG_NOF_ENABLED_DATALANES_SHIFT	3
+#define PPI_INTF_CONFIG_RX_AUTO_CLKGATING_SHIFT		5
+#define CSI_REG_PPI2CSI_CONFIG_CSI_FEATURE      0x208
+
+enum CSI_PPI2CSI_CTRL {
+	CSI_PPI2CSI_DISABLE = 0,
+	CSI_PPI2CSI_ENABLE = 1,
+};
+
+/* CSI_FE */
+#define CSI_REG_CSI_FE_ENABLE                   0x280
+#define CSI_REG_CSI_FE_MODE                     0x284
+#define CSI_REG_CSI_FE_MUX_CTRL                 0x288
+#define CSI_REG_CSI_FE_SYNC_CNTR_SEL            0x290
+
+enum CSI_FE_ENABLE_TYPE {
+	CSI_FE_DISABLE = 0,
+	CSI_FE_ENABLE = 1,
+};
+
+enum CSI_FE_MODE_TYPE {
+	CSI_FE_DPHY_MODE = 0,
+	CSI_FE_CPHY_MODE = 1,
+};
+
+enum CSI_FE_INPUT_SELECTOR {
+	CSI_SENSOR_INPUT = 0,
+	CSI_MIPIGEN_INPUT = 1,
+};
+
+enum CSI_FE_SYNC_CNTR_SEL_TYPE {
+	CSI_CNTR_SENSOR_LINE_ID = (1 << 0),
+	CSI_CNTR_INT_LINE_PKT_ID = ~CSI_CNTR_SENSOR_LINE_ID,
+	CSI_CNTR_SENSOR_FRAME_ID = (1 << 1),
+	CSI_CNTR_INT_FRAME_PKT_ID = ~CSI_CNTR_SENSOR_FRAME_ID,
+};
+
+/* MIPI_PKT_GEN */
+#define CSI_REG_PIXGEN_COM_BASE_OFFSET		0x300
+
+#define IPU_CSI_PORT_A_PIXGEN_ADDR_OFFSET	\
+	(CSI_REG_BASE + CSI_REG_BASE_PORT(0) + CSI_REG_PIXGEN_COM_BASE_OFFSET)
+#define IPU_CSI_PORT_B_PIXGEN_ADDR_OFFSET	\
+	(CSI_REG_BASE + CSI_REG_BASE_PORT(1) + CSI_REG_PIXGEN_COM_BASE_OFFSET)
+#define IPU_CSI_PORT_C_PIXGEN_ADDR_OFFSET	\
+	(CSI_REG_BASE + CSI_REG_BASE_PORT(2) + CSI_REG_PIXGEN_COM_BASE_OFFSET)
+#define IPU_CSI_PORT_D_PIXGEN_ADDR_OFFSET	\
+	(CSI_REG_BASE + CSI_REG_BASE_PORT(3) + CSI_REG_PIXGEN_COM_BASE_OFFSET)
+#define IPU_CSI_PORT_E_PIXGEN_ADDR_OFFSET	\
+	(CSI_REG_BASE + CSI_REG_BASE_PORT(4) + CSI_REG_PIXGEN_COM_BASE_OFFSET)
+#define IPU_CSI_PORT_F_PIXGEN_ADDR_OFFSET	\
+	(CSI_REG_BASE + CSI_REG_BASE_PORT(5) + CSI_REG_PIXGEN_COM_BASE_OFFSET)
+#define IPU_CSI_PORT_G_PIXGEN_ADDR_OFFSET	\
+	(CSI_REG_BASE + CSI_REG_BASE_PORT(6) + CSI_REG_PIXGEN_COM_BASE_OFFSET)
+#define IPU_CSI_PORT_H_PIXGEN_ADDR_OFFSET	\
+	(CSI_REG_BASE + CSI_REG_BASE_PORT(7) + CSI_REG_PIXGEN_COM_BASE_OFFSET)
+
+#define CSI_REG_PIXGEN_COM_ENABLE_REG_IDX(id)	\
+	(CSI_REG_BASE_PORT(id) + 0x300)
+#define CSI_REG_PIXGEN_COM_DTYPE_REG_IDX(id)	\
+	(CSI_REG_BASE_PORT(id) + 0x304)
+#define CSI_REG_PIXGEN_COM_VTYPE_REG_IDX(id)	\
+	(CSI_REG_BASE_PORT(id) + 0x308)
+#define CSI_REG_PIXGEN_COM_VCHAN_REG_IDX(id)	\
+	(CSI_REG_BASE_PORT(id) + 0x30C)
+#define CSI_REG_PIXGEN_COM_WCOUNT_REG_IDX(id)	\
+	(CSI_REG_BASE_PORT(id) + 0x310)
+/* PRBS */
+#define CSI_REG_PIXGEN_PRBS_RSTVAL_REG0_IDX(id)	\
+	(CSI_REG_BASE_PORT(id) + 0x314)
+#define CSI_REG_PIXGEN_PRBS_RSTVAL_REG1_IDX(id)	\
+	(CSI_REG_BASE_PORT(id) + 0x318)
+/* SYNC_GENERATOR_CONFIG */
+#define CSI_REG_PIXGEN_SYNG_FREE_RUN_REG_IDX(id)	\
+	(CSI_REG_BASE_PORT(id) + 0x31C)
+#define CSI_REG_PIXGEN_SYNG_PAUSE_REG_IDX(id)		\
+	(CSI_REG_BASE_PORT(id) + 0x320)
+#define CSI_REG_PIXGEN_SYNG_NOF_FRAME_REG_IDX(id)	\
+	(CSI_REG_BASE_PORT(id) + 0x324)
+#define CSI_REG_PIXGEN_SYNG_NOF_PIXEL_REG_IDX(id)	\
+	(CSI_REG_BASE_PORT(id) + 0x328)
+#define CSI_REG_PIXGEN_SYNG_NOF_LINE_REG_IDX(id)	\
+	(CSI_REG_BASE_PORT(id) + 0x32C)
+#define CSI_REG_PIXGEN_SYNG_HBLANK_CYC_REG_IDX(id)	\
+	(CSI_REG_BASE_PORT(id) + 0x330)
+#define CSI_REG_PIXGEN_SYNG_VBLANK_CYC_REG_IDX(id)	\
+	(CSI_REG_BASE_PORT(id) + 0x334)
+#define CSI_REG_PIXGEN_SYNG_STAT_HCNT_REG_IDX(id)	\
+	(CSI_REG_BASE_PORT(id) + 0x338)
+#define CSI_REG_PIXGEN_SYNG_STAT_VCNT_REG_IDX(id)	\
+	(CSI_REG_BASE_PORT(id) + 0x33C)
+#define CSI_REG_PIXGEN_SYNG_STAT_FCNT_REG_IDX(id)	\
+	(CSI_REG_BASE_PORT(id) + 0x340)
+#define CSI_REG_PIXGEN_SYNG_STAT_DONE_REG_IDX(id)	\
+	(CSI_REG_BASE_PORT(id) + 0x344)
+/* TPG */
+#define CSI_REG_PIXGEN_TPG_MODE_REG_IDX(id)		\
+	(CSI_REG_BASE_PORT(id) + 0x348)
+/* TPG: mask_cfg */
+#define CSI_REG_PIXGEN_TPG_HCNT_MASK_REG_IDX(id)	\
+	(CSI_REG_BASE_PORT(id) + 0x34C)
+#define CSI_REG_PIXGEN_TPG_VCNT_MASK_REG_IDX(id)	\
+	(CSI_REG_BASE_PORT(id) + 0x350)
+#define CSI_REG_PIXGEN_TPG_XYCNT_MASK_REG_IDX(id)	\
+	(CSI_REG_BASE_PORT(id) + 0x354)
+/* TPG: delta_cfg */
+#define CSI_REG_PIXGEN_TPG_HCNT_DELTA_REG_IDX(id)	\
+	(CSI_REG_BASE_PORT(id) + 0x358)
+#define CSI_REG_PIXGEN_TPG_VCNT_DELTA_REG_IDX(id)	\
+	(CSI_REG_BASE_PORT(id) + 0x35C)
+/* TPG: color_cfg */
+#define CSI_REG_PIXGEN_TPG_R1_REG_IDX(id)	(CSI_REG_BASE_PORT(id) + 0x360)
+#define CSI_REG_PIXGEN_TPG_G1_REG_IDX(id)	(CSI_REG_BASE_PORT(id) + 0x364)
+#define CSI_REG_PIXGEN_TPG_B1_REG_IDX(id)	(CSI_REG_BASE_PORT(id) + 0x368)
+#define CSI_REG_PIXGEN_TPG_R2_REG_IDX(id)	(CSI_REG_BASE_PORT(id) + 0x36C)
+#define CSI_REG_PIXGEN_TPG_G2_REG_IDX(id)	(CSI_REG_BASE_PORT(id) + 0x370)
+#define CSI_REG_PIXGEN_TPG_B2_REG_IDX(id)	(CSI_REG_BASE_PORT(id) + 0x374)
+
+#define CSI_REG_PIXGEN_PRBS_RSTVAL_REG0	CSI_REG_PIXGEN_PRBS_RSTVAL_REG0_IDX(0)
+#define CSI_REG_PIXGEN_PRBS_RSTVAL_REG1	CSI_REG_PIXGEN_PRBS_RSTVAL_REG1_IDX(0)
+#define CSI_REG_PIXGEN_COM_ENABLE_REG	CSI_REG_PIXGEN_COM_ENABLE_REG_IDX(0)
+#define CSI_REG_PIXGEN_TPG_MODE_REG	CSI_REG_PIXGEN_TPG_MODE_REG_IDX(0)
+#define CSI_REG_PIXGEN_TPG_R1_REG	CSI_REG_PIXGEN_TPG_R1_REG_IDX(0)
+#define CSI_REG_PIXGEN_TPG_G1_REG	CSI_REG_PIXGEN_TPG_G1_REG_IDX(0)
+#define CSI_REG_PIXGEN_TPG_B1_REG	CSI_REG_PIXGEN_TPG_B1_REG_IDX(0)
+#define CSI_REG_PIXGEN_TPG_R2_REG	CSI_REG_PIXGEN_TPG_R2_REG_IDX(0)
+#define CSI_REG_PIXGEN_TPG_G2_REG	CSI_REG_PIXGEN_TPG_G2_REG_IDX(0)
+#define CSI_REG_PIXGEN_TPG_B2_REG	CSI_REG_PIXGEN_TPG_B2_REG_IDX(0)
+#define CSI_REG_PIXGEN_TPG_HCNT_MASK_REG CSI_REG_PIXGEN_TPG_HCNT_MASK_REG_IDX(0)
+#define CSI_REG_PIXGEN_TPG_VCNT_MASK_REG CSI_REG_PIXGEN_TPG_VCNT_MASK_REG_IDX(0)
+#define CSI_REG_PIXGEN_TPG_XYCNT_MASK_REG	\
+	CSI_REG_PIXGEN_TPG_XYCNT_MASK_REG_IDX(0)
+
+#define CSI_REG_PIXGEN_SYNG_NOF_FRAME_REG	\
+	CSI_REG_PIXGEN_SYNG_NOF_FRAME_REG_IDX(0)
+#define CSI_REG_PIXGEN_SYNG_NOF_LINE_REG	\
+	CSI_REG_PIXGEN_SYNG_NOF_LINE_REG_IDX(0)
+#define CSI_REG_PIXGEN_SYNG_HBLANK_CYC_REG	\
+	CSI_REG_PIXGEN_SYNG_HBLANK_CYC_REG_IDX(0)
+#define CSI_REG_PIXGEN_SYNG_VBLANK_CYC_REG	\
+	CSI_REG_PIXGEN_SYNG_VBLANK_CYC_REG_IDX(0)
+#define CSI_REG_PIXGEN_SYNG_NOF_PIXEL_REG	\
+	CSI_REG_PIXGEN_SYNG_NOF_PIXEL_REG_IDX(0)
+#define CSI_REG_PIXGEN_COM_WCOUNT_REG	CSI_REG_PIXGEN_COM_WCOUNT_REG_IDX(0)
+#define CSI_REG_PIXGEN_COM_DTYPE_REG	CSI_REG_PIXGEN_COM_DTYPE_REG_IDX(0)
+#define CSI_REG_PIXGEN_COM_VTYPE_REG	CSI_REG_PIXGEN_COM_VTYPE_REG_IDX(0)
+#define CSI_REG_PIXGEN_COM_VCHAN_REG	CSI_REG_PIXGEN_COM_VCHAN_REG_IDX(0)
+#define CSI_REG_PIXGEN_TPG_HCNT_DELTA_REG	\
+	CSI_REG_PIXGEN_TPG_HCNT_DELTA_REG_IDX(0)
+#define CSI_REG_PIXGEN_TPG_VCNT_DELTA_REG	\
+	CSI_REG_PIXGEN_TPG_VCNT_DELTA_REG_IDX(0)
+
+/* CSI HUB General Purpose Registers */
+#define CSI_REG_HUB_GPREG_SRST			(CSI_REG_BASE + 0x18000)
+#define CSI_REG_HUB_GPREG_SLV_REG_SRST		(CSI_REG_BASE + 0x18004)
+#define CSI_REG_HUB_GPREG_PHY_CONTROL(id)	\
+	(CSI_REG_BASE + 0x18008 + (id) * 0x8)
+#define CSI_REG_HUB_GPREG_PHY_CONTROL_RESET		BIT(4)
+#define CSI_REG_HUB_GPREG_PHY_CONTROL_PWR_EN		BIT(0)
+#define CSI_REG_HUB_GPREG_PHY_STATUS(id)	\
+	(CSI_REG_BASE + 0x1800c + (id) * 0x8)
+#define CSI_REG_HUB_GPREG_PHY_STATUS_POWER_ACK		BIT(0)
+#define CSI_REG_HUB_GPREG_PHY_STATUS_PHY_READY		BIT(4)
+
+#define CSI_REG_HUB_DRV_ACCESS_PORT(id)	(CSI_REG_BASE + 0x18018 + (id) * 4)
+#define CSI_REG_HUB_FW_ACCESS_PORT(id)	(CSI_REG_BASE + 0x17000 + (id) * 4)
+#define IPU6V6_CSI_REG_HUB_FW_ACCESS_PORT(id)	\
+	(CSI_REG_BASE + 0x16000 + (id) * 4)
+
+enum CSI_PORT_CLK_GATING_SWITCH {
+	CSI_PORT_CLK_GATING_OFF = 0,
+	CSI_PORT_CLK_GATING_ON = 1,
+};
+
+#define CSI_REG_BASE_HUB_IRQ                        0x18200
+
+#define IPU_NUM_OF_DLANE_REG_PORT0      2
+#define IPU_NUM_OF_DLANE_REG_PORT1      4
+#define IPU_NUM_OF_DLANE_REG_PORT2      4
+#define IPU_NUM_OF_DLANE_REG_PORT3      2
+#define IPU_NUM_OF_DLANE_REG_PORT4      2
+#define IPU_NUM_OF_DLANE_REG_PORT5      4
+#define IPU_NUM_OF_DLANE_REG_PORT6      4
+#define IPU_NUM_OF_DLANE_REG_PORT7      2
+
+/* ipu6se support 2 SIPs, 2 port per SIP, 4 ports 0..3
+ * sip0 - 0, 1
+ * sip1 - 2, 3
+ * 0 and 2 support 4 data lanes, 1 and 3 support 2 data lanes
+ * all offset are base from isys base address
+ */
+
+#define CSI2_HUB_GPREG_SIP_SRST(sip)			(0x238038 + (sip) * 4)
+#define CSI2_HUB_GPREG_SIP_FB_PORT_CFG(sip)		(0x238050 + (sip) * 4)
+
+#define CSI2_HUB_GPREG_DPHY_TIMER_INCR			(0x238040)
+#define CSI2_HUB_GPREG_HPLL_FREQ			(0x238044)
+#define CSI2_HUB_GPREG_IS_CLK_RATIO			(0x238048)
+#define CSI2_HUB_GPREG_HPLL_FREQ_ISCLK_RATE_OVERRIDE	(0x23804c)
+#define CSI2_HUB_GPREG_PORT_CLKGATING_DISABLE		(0x238058)
+#define CSI2_HUB_GPREG_SIP0_CSI_RX_A_CONTROL		(0x23805c)
+#define CSI2_HUB_GPREG_SIP0_CSI_RX_B_CONTROL		(0x238088)
+#define CSI2_HUB_GPREG_SIP1_CSI_RX_A_CONTROL		(0x2380a4)
+#define CSI2_HUB_GPREG_SIP1_CSI_RX_B_CONTROL		(0x2380d0)
+
+#define CSI2_SIP_TOP_CSI_RX_BASE(sip)		(0x23805c + (sip) * 0x48)
+#define CSI2_SIP_TOP_CSI_RX_PORT_BASE_0(port)	(0x23805c + ((port) / 2) * 0x48)
+#define CSI2_SIP_TOP_CSI_RX_PORT_BASE_1(port)	(0x238088 + ((port) / 2) * 0x48)
+
+/* offset from port base */
+#define CSI2_SIP_TOP_CSI_RX_PORT_CONTROL		(0x0)
+#define CSI2_SIP_TOP_CSI_RX_DLY_CNT_TERMEN_CLANE	(0x4)
+#define CSI2_SIP_TOP_CSI_RX_DLY_CNT_SETTLE_CLANE	(0x8)
+#define CSI2_SIP_TOP_CSI_RX_DLY_CNT_TERMEN_DLANE(lane)	(0xc + (lane) * 8)
+#define CSI2_SIP_TOP_CSI_RX_DLY_CNT_SETTLE_DLANE(lane)	(0x10 + (lane) * 8)
+
+#endif /* IPU6_ISYS_CSI2_REG_H */
Index: b/drivers/media/pci/intel/ipu6/ipu-platform-isys.h
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu6/ipu-platform-isys.h
@@ -0,0 +1,29 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2022 Intel Corporation */
+
+#ifndef IPU_PLATFORM_ISYS_H
+#define IPU_PLATFORM_ISYS_H
+
+#define IPU_ISYS_ENTITY_PREFIX		"Intel IPU6"
+
+/*
+ * FW support max 16 streams
+ */
+#define IPU_ISYS_MAX_STREAMS		16
+#define NR_OF_CSI2_BE_SOC_STREAMS	16
+#define NR_OF_CSI2_VC			16
+#define IPU_ISYS_CSI2_ENTITY_PREFIX	"Intel IPU6 CSI-2"
+
+#define ISYS_UNISPART_IRQS	(IPU_ISYS_UNISPART_IRQ_SW |	\
+				 IPU_ISYS_UNISPART_IRQ_CSI0 |	\
+				 IPU_ISYS_UNISPART_IRQ_CSI1)
+
+/* IPU6 ISYS compression alignment */
+#define IPU_ISYS_COMPRESSION_LINE_ALIGN		512
+#define IPU_ISYS_COMPRESSION_HEIGHT_ALIGN	1
+#define IPU_ISYS_COMPRESSION_TILE_SIZE_BYTES	512
+#define IPU_ISYS_COMPRESSION_PAGE_ALIGN		0x1000
+#define IPU_ISYS_COMPRESSION_TILE_STATUS_BITS	4
+#define IPU_ISYS_COMPRESSION_MAX		3
+
+#endif
Index: b/drivers/media/pci/intel/ipu6/ipu-platform-psys.h
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu6/ipu-platform-psys.h
@@ -0,0 +1,78 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2020 Intel Corporation */
+
+#ifndef IPU_PLATFORM_PSYS_H
+#define IPU_PLATFORM_PSYS_H
+
+#include "ipu-psys.h"
+#include <uapi/linux/ipu-psys.h>
+
+#define IPU_PSYS_BUF_SET_POOL_SIZE 8
+#define IPU_PSYS_BUF_SET_MAX_SIZE 1024
+
+struct ipu_fw_psys_buffer_set;
+
+enum ipu_psys_cmd_state {
+	KCMD_STATE_PPG_NEW,
+	KCMD_STATE_PPG_START,
+	KCMD_STATE_PPG_ENQUEUE,
+	KCMD_STATE_PPG_STOP,
+	KCMD_STATE_PPG_COMPLETE
+};
+
+struct ipu_psys_scheduler {
+	struct list_head ppgs;
+	struct mutex bs_mutex;  /* Protects buf_set field */
+	struct list_head buf_sets;
+};
+
+enum ipu_psys_ppg_state {
+	PPG_STATE_START = (1 << 0),
+	PPG_STATE_STARTING = (1 << 1),
+	PPG_STATE_STARTED = (1 << 2),
+	PPG_STATE_RUNNING = (1 << 3),
+	PPG_STATE_SUSPEND = (1 << 4),
+	PPG_STATE_SUSPENDING = (1 << 5),
+	PPG_STATE_SUSPENDED = (1 << 6),
+	PPG_STATE_RESUME = (1 << 7),
+	PPG_STATE_RESUMING = (1 << 8),
+	PPG_STATE_RESUMED = (1 << 9),
+	PPG_STATE_STOP = (1 << 10),
+	PPG_STATE_STOPPING = (1 << 11),
+	PPG_STATE_STOPPED = (1 << 12),
+};
+
+struct ipu_psys_ppg {
+	struct ipu_psys_pg *kpg;
+	struct ipu_psys_fh *fh;
+	struct list_head list;
+	struct list_head sched_list;
+	u64 token;
+	void *manifest;
+	struct mutex mutex;     /* Protects kcmd and ppg state field */
+	struct list_head kcmds_new_list;
+	struct list_head kcmds_processing_list;
+	struct list_head kcmds_finished_list;
+	enum ipu_psys_ppg_state state;
+	u32 pri_base;
+	int pri_dynamic;
+};
+
+struct ipu_psys_buffer_set {
+	struct list_head list;
+	struct ipu_fw_psys_buffer_set *buf_set;
+	size_t size;
+	size_t buf_set_size;
+	dma_addr_t dma_addr;
+	void *kaddr;
+	struct ipu_psys_kcmd *kcmd;
+};
+
+int ipu_psys_kcmd_start(struct ipu_psys *psys, struct ipu_psys_kcmd *kcmd);
+void ipu_psys_kcmd_complete(struct ipu_psys_ppg *kppg,
+			    struct ipu_psys_kcmd *kcmd,
+			    int error);
+int ipu_psys_fh_init(struct ipu_psys_fh *fh);
+int ipu_psys_fh_deinit(struct ipu_psys_fh *fh);
+
+#endif /* IPU_PLATFORM_PSYS_H */
Index: b/drivers/media/pci/intel/ipu6/ipu-platform-regs.h
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu6/ipu-platform-regs.h
@@ -0,0 +1,348 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2018 - 2020 Intel Corporation */
+
+#ifndef IPU_PLATFORM_REGS_H
+#define IPU_PLATFORM_REGS_H
+
+/*
+ * IPU6 uses uniform address within IPU, therefore all subsystem registers
+ * locates in one signle space starts from 0 but in different sctions with
+ * different addresses, the subsystem offsets are defined to 0 as the
+ * register definition will have the address offset to 0.
+ */
+#define IPU_UNIFIED_OFFSET			0
+
+#define IPU_ISYS_IOMMU0_OFFSET		0x2E0000
+#define IPU_ISYS_IOMMU1_OFFSET		0x2E0500
+#define IPU_ISYS_IOMMUI_OFFSET		0x2E0A00
+
+#define IPU_PSYS_IOMMU0_OFFSET		0x1B0000
+#define IPU_PSYS_IOMMU1_OFFSET		0x1B0700
+#define IPU_PSYS_IOMMU1R_OFFSET		0x1B0E00
+#define IPU_PSYS_IOMMUI_OFFSET		0x1B1500
+
+/* the offset from IOMMU base register */
+#define IPU_MMU_L1_STREAM_ID_REG_OFFSET	0x0c
+#define IPU_MMU_L2_STREAM_ID_REG_OFFSET	0x4c
+#define IPU_PSYS_MMU1W_L2_STREAM_ID_REG_OFFSET	0x8c
+
+#define IPU_MMU_INFO_OFFSET		0x8
+
+#define IPU_ISYS_SPC_OFFSET		0x210000
+
+#define IPU6SE_PSYS_SPC_OFFSET		0x110000
+#define IPU6_PSYS_SPC_OFFSET		0x118000
+
+#define IPU_ISYS_DMEM_OFFSET		0x200000
+#define IPU_PSYS_DMEM_OFFSET		0x100000
+
+#define IPU_REG_ISYS_CSI_TOP_CTRL0_IRQ_EDGE		0x238200
+#define IPU_REG_ISYS_CSI_TOP_CTRL0_IRQ_MASK		0x238204
+#define IPU_REG_ISYS_CSI_TOP_CTRL0_IRQ_STATUS		0x238208
+#define IPU_REG_ISYS_CSI_TOP_CTRL0_IRQ_CLEAR		0x23820c
+#define IPU_REG_ISYS_CSI_TOP_CTRL0_IRQ_ENABLE		0x238210
+#define IPU_REG_ISYS_CSI_TOP_CTRL0_IRQ_LEVEL_NOT_PULSE	0x238214
+
+#define IPU_REG_ISYS_CSI_TOP_CTRL1_IRQ_EDGE		0x238220
+#define IPU_REG_ISYS_CSI_TOP_CTRL1_IRQ_MASK		0x238224
+#define IPU_REG_ISYS_CSI_TOP_CTRL1_IRQ_STATUS		0x238228
+#define IPU_REG_ISYS_CSI_TOP_CTRL1_IRQ_CLEAR		0x23822c
+#define IPU_REG_ISYS_CSI_TOP_CTRL1_IRQ_ENABLE		0x238230
+#define IPU_REG_ISYS_CSI_TOP_CTRL1_IRQ_LEVEL_NOT_PULSE	0x238234
+
+/* MTL IPU6V6 irq ctrl0 & ctrl1 */
+#define IPU6V6_REG_ISYS_CSI_TOP_CTRL0_IRQ_EDGE			0x238700
+#define IPU6V6_REG_ISYS_CSI_TOP_CTRL0_IRQ_MASK			0x238704
+#define IPU6V6_REG_ISYS_CSI_TOP_CTRL0_IRQ_STATUS		0x238708
+#define IPU6V6_REG_ISYS_CSI_TOP_CTRL0_IRQ_CLEAR			0x23870c
+#define IPU6V6_REG_ISYS_CSI_TOP_CTRL0_IRQ_ENABLE		0x238710
+#define IPU6V6_REG_ISYS_CSI_TOP_CTRL0_IRQ_LEVEL_NOT_PULSE	0x238714
+
+#define IPU6V6_REG_ISYS_CSI_TOP_CTRL1_IRQ_EDGE			0x238720
+#define IPU6V6_REG_ISYS_CSI_TOP_CTRL1_IRQ_MASK			0x238724
+#define IPU6V6_REG_ISYS_CSI_TOP_CTRL1_IRQ_STATUS		0x238728
+#define IPU6V6_REG_ISYS_CSI_TOP_CTRL1_IRQ_CLEAR			0x23872c
+#define IPU6V6_REG_ISYS_CSI_TOP_CTRL1_IRQ_ENABLE		0x238730
+#define IPU6V6_REG_ISYS_CSI_TOP_CTRL1_IRQ_LEVEL_NOT_PULSE	0x238734
+
+#define IPU_REG_ISYS_UNISPART_IRQ_EDGE			0x27c000
+#define IPU_REG_ISYS_UNISPART_IRQ_MASK			0x27c004
+#define IPU_REG_ISYS_UNISPART_IRQ_STATUS		0x27c008
+#define IPU_REG_ISYS_UNISPART_IRQ_CLEAR			0x27c00c
+#define IPU_REG_ISYS_UNISPART_IRQ_ENABLE			0x27c010
+#define IPU_REG_ISYS_UNISPART_IRQ_LEVEL_NOT_PULSE	0x27c014
+#define IPU_REG_ISYS_UNISPART_SW_IRQ_REG			0x27c414
+#define IPU_REG_ISYS_UNISPART_SW_IRQ_MUX_REG		0x27c418
+#define IPU_ISYS_UNISPART_IRQ_CSI0			BIT(2)
+#define IPU_ISYS_UNISPART_IRQ_CSI1			BIT(3)
+#define IPU_ISYS_UNISPART_IRQ_SW			BIT(22)
+
+#define IPU_REG_ISYS_ISL_TOP_IRQ_EDGE			0x2b0200
+#define IPU_REG_ISYS_ISL_TOP_IRQ_MASK			0x2b0204
+#define IPU_REG_ISYS_ISL_TOP_IRQ_STATUS			0x2b0208
+#define IPU_REG_ISYS_ISL_TOP_IRQ_CLEAR			0x2b020c
+#define IPU_REG_ISYS_ISL_TOP_IRQ_ENABLE			0x2b0210
+#define IPU_REG_ISYS_ISL_TOP_IRQ_LEVEL_NOT_PULSE	0x2b0214
+
+#define IPU_REG_ISYS_CMPR_TOP_IRQ_EDGE			0x2d2100
+#define IPU_REG_ISYS_CMPR_TOP_IRQ_MASK			0x2d2104
+#define IPU_REG_ISYS_CMPR_TOP_IRQ_STATUS		0x2d2108
+#define IPU_REG_ISYS_CMPR_TOP_IRQ_CLEAR			0x2d210c
+#define IPU_REG_ISYS_CMPR_TOP_IRQ_ENABLE		0x2d2110
+#define IPU_REG_ISYS_CMPR_TOP_IRQ_LEVEL_NOT_PULSE	0x2d2114
+
+/* CDC Burst collector thresholds for isys - 3 FIFOs i = 0..2 */
+#define IPU_REG_ISYS_CDC_THRESHOLD(i)		(0x27c400 + ((i) * 4))
+
+#define IPU_ISYS_CSI_PHY_NUM				2
+#define IPU_CSI_IRQ_NUM_PER_PIPE			4
+#define IPU6SE_ISYS_CSI_PORT_NUM			4
+#define IPU6_ISYS_CSI_PORT_NUM				8
+
+#define IPU_ISYS_CSI_PORT_IRQ(irq_num)		(1 << (irq_num))
+
+/* PSYS Info bits*/
+#define IPU_REG_PSYS_INFO_SEG_CMEM_MASTER(a)	(0x2C + ((a) * 12))
+#define IPU_REG_PSYS_INFO_SEG_XMEM_MASTER(a)	(0x5C + ((a) * 12))
+
+/* PKG DIR OFFSET in IMR in secure mode */
+#define IPU_PKG_DIR_IMR_OFFSET			0x40
+
+#define IPU_ISYS_REG_SPC_STATUS_CTRL		0x0
+
+#define IPU_ISYS_SPC_STATUS_START			BIT(1)
+#define IPU_ISYS_SPC_STATUS_RUN				BIT(3)
+#define IPU_ISYS_SPC_STATUS_READY			BIT(5)
+#define IPU_ISYS_SPC_STATUS_CTRL_ICACHE_INVALIDATE	BIT(12)
+#define IPU_ISYS_SPC_STATUS_ICACHE_PREFETCH		BIT(13)
+
+#define IPU_PSYS_REG_SPC_STATUS_CTRL		0x0
+#define IPU_PSYS_REG_SPC_START_PC		0x4
+#define IPU_PSYS_REG_SPC_ICACHE_BASE		0x10
+#define IPU_REG_PSYS_INFO_SEG_0_CONFIG_ICACHE_MASTER	0x14
+
+#define IPU_PSYS_SPC_STATUS_START			BIT(1)
+#define IPU_PSYS_SPC_STATUS_RUN				BIT(3)
+#define IPU_PSYS_SPC_STATUS_READY			BIT(5)
+#define IPU_PSYS_SPC_STATUS_CTRL_ICACHE_INVALIDATE	BIT(12)
+#define IPU_PSYS_SPC_STATUS_ICACHE_PREFETCH		BIT(13)
+
+#define IPU_PSYS_REG_SPP0_STATUS_CTRL			0x20000
+
+#define IPU_INFO_ENABLE_SNOOP			BIT(0)
+#define IPU_INFO_DEC_FORCE_FLUSH		BIT(1)
+#define IPU_INFO_DEC_PASS_THRU			BIT(2)
+#define IPU_INFO_ZLW                            BIT(3)
+#define IPU_INFO_STREAM_ID_SET(id)		(((id) & 0x1F) << 4)
+#define IPU_INFO_REQUEST_DESTINATION_IOSF	BIT(9)
+#define IPU_INFO_IMR_BASE			BIT(10)
+#define IPU_INFO_IMR_DESTINED			BIT(11)
+
+#define IPU_INFO_REQUEST_DESTINATION_PRIMARY IPU_INFO_REQUEST_DESTINATION_IOSF
+
+/* Trace unit related register definitions */
+#define TRACE_REG_MAX_ISYS_OFFSET	0xfffff
+#define TRACE_REG_MAX_PSYS_OFFSET	0xfffff
+#define IPU_ISYS_OFFSET			IPU_ISYS_DMEM_OFFSET
+#define IPU_PSYS_OFFSET			IPU_PSYS_DMEM_OFFSET
+/* ISYS trace unit registers */
+/* Trace unit base offset */
+#define IPU_TRACE_REG_IS_TRACE_UNIT_BASE		0x27d000
+/* Trace monitors */
+#define IPU_TRACE_REG_IS_SP_EVQ_BASE		0x211000
+/* GPC blocks */
+#define IPU_TRACE_REG_IS_SP_GPC_BASE		0x210800
+#define IPU_TRACE_REG_IS_ISL_GPC_BASE		0x2b0a00
+#define IPU_TRACE_REG_IS_MMU_GPC_BASE		0x2e0f00
+/* each CSI2 port has a dedicated trace monitor, index 0..7 */
+#define IPU_TRACE_REG_CSI2_TM_BASE(port)	(0x220400 + 0x1000 * (port))
+
+/* Trace timers */
+#define IPU_TRACE_REG_IS_GPREG_TRACE_TIMER_RST_N		0x27c410
+#define TRACE_REG_GPREG_TRACE_TIMER_RST_OFF		BIT(0)
+
+/* SIG2CIO */
+#define IPU_TRACE_REG_CSI2_PORT_SIG2SIO_GR_BASE(port)		\
+			(0x220e00 + (port) * 0x1000)
+
+/* PSYS trace unit registers */
+/* Trace unit base offset */
+#define IPU_TRACE_REG_PS_TRACE_UNIT_BASE		0x1b4000
+/* Trace monitors */
+#define IPU_TRACE_REG_PS_SPC_EVQ_BASE			0x119000
+#define IPU_TRACE_REG_PS_SPP0_EVQ_BASE			0x139000
+
+/* GPC blocks */
+#define IPU_TRACE_REG_PS_SPC_GPC_BASE			0x118800
+#define IPU_TRACE_REG_PS_SPP0_GPC_BASE			0x138800
+#define IPU_TRACE_REG_PS_MMU_GPC_BASE			0x1b1b00
+
+/* Trace timers */
+#define IPU_TRACE_REG_PS_GPREG_TRACE_TIMER_RST_N	0x1aa714
+
+/*
+ * s2m_pixel_soc_pixel_remapping is dedicated for the enableing of the
+ * pixel s2m remp ability.Remap here  means that s2m rearange the order
+ * of the pixels in each 4 pixels group.
+ * For examle, mirroring remping means that if input's 4 first pixels
+ * are 1 2 3 4 then in output we should see 4 3 2 1 in this 4 first pixels.
+ * 0xE4 is from s2m MAS document. It means no remaping.
+ */
+#define S2M_PIXEL_SOC_PIXEL_REMAPPING_FLAG_NO_REMAPPING 0xE4
+/*
+ * csi_be_soc_pixel_remapping is for the enabling of the csi\mipi be pixel
+ * remapping feature. This remapping is exactly like the stream2mmio remapping.
+ */
+#define CSI_BE_SOC_PIXEL_REMAPPING_FLAG_NO_REMAPPING    0xE4
+
+#define IPU_REG_DMA_TOP_AB_GROUP1_BASE_ADDR         0x1AE000
+#define IPU_REG_DMA_TOP_AB_GROUP2_BASE_ADDR         0x1AF000
+#define IPU_REG_DMA_TOP_AB_RING_MIN_OFFSET(n)       (0x4 + (n) * 0xC)
+#define IPU_REG_DMA_TOP_AB_RING_MAX_OFFSET(n)       (0x8 + (n) * 0xC)
+#define IPU_REG_DMA_TOP_AB_RING_ACCESS_OFFSET(n)    (0xC + (n) * 0xC)
+
+enum ipu_device_ab_group1_target_id {
+	IPU_DEVICE_AB_GROUP1_TARGET_ID_R0_SPC_DMEM,
+	IPU_DEVICE_AB_GROUP1_TARGET_ID_R1_SPC_DMEM,
+	IPU_DEVICE_AB_GROUP1_TARGET_ID_R2_SPC_DMEM,
+	IPU_DEVICE_AB_GROUP1_TARGET_ID_R3_SPC_STATUS_REG,
+	IPU_DEVICE_AB_GROUP1_TARGET_ID_R4_SPC_MASTER_BASE_ADDR,
+	IPU_DEVICE_AB_GROUP1_TARGET_ID_R5_SPC_PC_STALL,
+	IPU_DEVICE_AB_GROUP1_TARGET_ID_R6_SPC_EQ,
+	IPU_DEVICE_AB_GROUP1_TARGET_ID_R7_SPC_RESERVED,
+	IPU_DEVICE_AB_GROUP1_TARGET_ID_R8_SPC_RESERVED,
+	IPU_DEVICE_AB_GROUP1_TARGET_ID_R9_SPP0,
+	IPU_DEVICE_AB_GROUP1_TARGET_ID_R10_SPP1,
+	IPU_DEVICE_AB_GROUP1_TARGET_ID_R11_CENTRAL_R1,
+	IPU_DEVICE_AB_GROUP1_TARGET_ID_R12_IRQ,
+	IPU_DEVICE_AB_GROUP1_TARGET_ID_R13_CENTRAL_R2,
+	IPU_DEVICE_AB_GROUP1_TARGET_ID_R14_DMA,
+	IPU_DEVICE_AB_GROUP1_TARGET_ID_R15_DMA,
+	IPU_DEVICE_AB_GROUP1_TARGET_ID_R16_GP,
+	IPU_DEVICE_AB_GROUP1_TARGET_ID_R17_ZLW_INSERTER,
+	IPU_DEVICE_AB_GROUP1_TARGET_ID_R18_AB,
+};
+
+enum nci_ab_access_mode {
+	NCI_AB_ACCESS_MODE_RW,	/* read & write */
+	NCI_AB_ACCESS_MODE_RO,	/* read only */
+	NCI_AB_ACCESS_MODE_WO,	/* write only */
+	NCI_AB_ACCESS_MODE_NA	/* No access at all */
+};
+
+/*
+ * 3:0 CSI_PORT.irq_out[3:0] CSI_PORT_CTRL0 IRQ outputs (4bits)
+ * [0] CSI_PORT.IRQ_CTRL0_csi
+ * [1] CSI_PORT.IRQ_CTRL1_csi_sync
+ * [2] CSI_PORT.IRQ_CTRL2_s2m_sids0to7
+ * [3] CSI_PORT.IRQ_CTRL3_s2m_sids8to15
+ */
+#define IPU_ISYS_UNISPART_IRQ_CSI2(port)		\
+				   (0x3 << ((port) * IPU_CSI_IRQ_NUM_PER_PIPE))
+
+/* IRQ-related registers in PSYS */
+#define IPU_REG_PSYS_GPDEV_IRQ_EDGE		0x1aa200
+#define IPU_REG_PSYS_GPDEV_IRQ_MASK		0x1aa204
+#define IPU_REG_PSYS_GPDEV_IRQ_STATUS		0x1aa208
+#define IPU_REG_PSYS_GPDEV_IRQ_CLEAR		0x1aa20c
+#define IPU_REG_PSYS_GPDEV_IRQ_ENABLE		0x1aa210
+#define IPU_REG_PSYS_GPDEV_IRQ_LEVEL_NOT_PULSE	0x1aa214
+/* There are 8 FW interrupts, n = 0..7 */
+#define IPU_PSYS_GPDEV_FWIRQ0			5
+#define IPU_PSYS_GPDEV_FWIRQ1			6
+#define IPU_PSYS_GPDEV_FWIRQ2			7
+#define IPU_PSYS_GPDEV_FWIRQ3			8
+#define IPU_PSYS_GPDEV_FWIRQ4			9
+#define IPU_PSYS_GPDEV_FWIRQ5			10
+#define IPU_PSYS_GPDEV_FWIRQ6			11
+#define IPU_PSYS_GPDEV_FWIRQ7			12
+#define IPU_PSYS_GPDEV_IRQ_FWIRQ(n)		(1 << (n))
+#define IPU_REG_PSYS_GPDEV_FWIRQ(n)		(4 * (n) + 0x1aa100)
+
+/*
+ * ISYS GPC (Gerneral Performance Counters) Registers
+ */
+#define IPU_ISYS_GPC_BASE			0x2E0000
+#define IPU_ISYS_GPREG_TRACE_TIMER_RST		0x27C410
+enum ipu_isf_cdc_mmu_gpc_registers {
+	IPU_ISF_CDC_MMU_GPC_SOFT_RESET  = 0x0F00,
+	IPU_ISF_CDC_MMU_GPC_OVERALL_ENABLE  = 0x0F04,
+	IPU_ISF_CDC_MMU_GPC_ENABLE0  = 0x0F20,
+	IPU_ISF_CDC_MMU_GPC_VALUE0  = 0x0F60,
+	IPU_ISF_CDC_MMU_GPC_CNT_SEL0 = 0x0FA0,
+};
+
+/*
+ * GPC (Gerneral Performance Counters) Registers
+ */
+#define IPU_GPC_BASE 0x1B0000
+#define IPU_GPREG_TRACE_TIMER_RST	0x1AA714
+enum ipu_cdc_mmu_gpc_registers {
+	IPU_CDC_MMU_GPC_SOFT_RESET  = 0x1B00,
+	IPU_CDC_MMU_GPC_OVERALL_ENABLE  = 0x1B04,
+	IPU_CDC_MMU_GPC_TRACE_HEADER  = 0x1B08,
+	IPU_CDC_MMU_GPC_TRACE_ADDR  = 0x1B0C,
+	IPU_CDC_MMU_GPC_TRACE_ENABLE_NPK  = 0x1B10,
+	IPU_CDC_MMU_GPC_TRACE_ENABLE_DDR  = 0x1B14,
+	IPU_CDC_MMU_GPC_LP_CLEAR  = 0x1B18,
+	IPU_CDC_MMU_GPC_LOST_PACKET  = 0x1B1C,
+	IPU_CDC_MMU_GPC_ENABLE0  = 0x1B20,
+	IPU_CDC_MMU_GPC_VALUE0  = 0x1B60,
+	IPU_CDC_MMU_GPC_CNT_SEL0 = 0x1BA0,
+	IPU_CDC_MMU_GPC_START_SEL0 = 0x1BE0,
+	IPU_CDC_MMU_GPC_STOP_SEL0 = 0x1C20,
+	IPU_CDC_MMU_GPC_MSG_SEL0 = 0x1C60,
+	IPU_CDC_MMU_GPC_PLOAD_SEL0 = 0x1CA0,
+	IPU_CDC_MMU_GPC_IRQ_TRIGGER_VALUE0 = 0x1CE0,
+	IPU_CDC_MMU_GPC_IRQ_TIMER_SEL0 = 0x1D20,
+	IPU_CDC_MMU_GPC_IRQ_ENABLE0 = 0x1D60,
+	IPU_CDC_MMU_GPC_END = 0x1D9C
+};
+
+#define IPU_GPC_SENSE_OFFSET		7
+#define IPU_GPC_ROUTE_OFFSET		5
+#define IPU_GPC_SOURCE_OFFSET		0
+
+/*
+ * Signals monitored by GPC
+ */
+#define IPU_GPC_TRACE_TLB_MISS_MMU_LB_IDX		0
+#define IPU_GPC_TRACE_FULL_WRITE_LB_IDX			1
+#define IPU_GPC_TRACE_NOFULL_WRITE_LB_IDX		2
+#define IPU_GPC_TRACE_FULL_READ_LB_IDX			3
+#define IPU_GPC_TRACE_NOFULL_READ_LB_IDX		4
+#define IPU_GPC_TRACE_STALL_LB_IDX			5
+#define IPU_GPC_TRACE_ZLW_LB_IDX			6
+#define IPU_GPC_TRACE_TLB_MISS_MMU_HBTX_IDX		7
+#define IPU_GPC_TRACE_FULL_WRITE_HBTX_IDX		8
+#define IPU_GPC_TRACE_NOFULL_WRITE_HBTX_IDX		9
+#define IPU_GPC_TRACE_FULL_READ_HBTX_IDX		10
+#define IPU_GPC_TRACE_STALL_HBTX_IDX			11
+#define IPU_GPC_TRACE_ZLW_HBTX_IDX			12
+#define IPU_GPC_TRACE_TLB_MISS_MMU_HBFRX_IDX		13
+#define IPU_GPC_TRACE_FULL_READ_HBFRX_IDX		14
+#define IPU_GPC_TRACE_NOFULL_READ_HBFRX_IDX		15
+#define IPU_GPC_TRACE_STALL_HBFRX_IDX			16
+#define IPU_GPC_TRACE_ZLW_HBFRX_IDX			17
+#define IPU_GPC_TRACE_TLB_MISS_ICACHE_IDX		18
+#define IPU_GPC_TRACE_FULL_READ_ICACHE_IDX		19
+#define IPU_GPC_TRACE_STALL_ICACHE_IDX			20
+/*
+ * psys subdomains power request regs
+ */
+enum ipu_device_buttress_psys_domain_pos {
+	IPU_PSYS_SUBDOMAIN_ISA		= 0,
+	IPU_PSYS_SUBDOMAIN_PSA		= 1,
+	IPU_PSYS_SUBDOMAIN_BB		= 2,
+	IPU_PSYS_SUBDOMAIN_IDSP1	= 3, /* only in IPU6M */
+	IPU_PSYS_SUBDOMAIN_IDSP2	= 4, /* only in IPU6M */
+};
+
+#define IPU_PSYS_SUBDOMAINS_POWER_MASK  (BIT(IPU_PSYS_SUBDOMAIN_ISA) | \
+					 BIT(IPU_PSYS_SUBDOMAIN_PSA) | \
+					 BIT(IPU_PSYS_SUBDOMAIN_BB))
+
+#define IPU_PSYS_SUBDOMAINS_POWER_REQ                   0xa0
+#define IPU_PSYS_SUBDOMAINS_POWER_STATUS                0xa4
+
+#endif /* IPU_PLATFORM_REGS_H */
Index: b/drivers/media/pci/intel/ipu6/ipu-platform-resources.h
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu6/ipu-platform-resources.h
@@ -0,0 +1,103 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2018 - 2020 Intel Corporation */
+
+#ifndef IPU_PLATFORM_RESOURCES_COMMON_H
+#define IPU_PLATFORM_RESOURCES_COMMON_H
+
+#define IPU_FW_PSYS_N_PADDING_UINT8_IN_PROGRAM_MANIFEST                 0
+
+#define	IPU_FW_PSYS_N_PADDING_UINT8_IN_PROCESS_STRUCT			0
+#define	IPU_FW_PSYS_N_PADDING_UINT8_IN_PROCESS_GROUP_STRUCT		2
+#define	IPU_FW_PSYS_N_PADDING_UINT8_IN_PROGRAM_MANIFEST_EXT		2
+
+#define IPU_FW_PSYS_N_PADDING_UINT8_IN_TERMINAL_STRUCT			5
+
+#define IPU_FW_PSYS_N_PADDING_UINT8_IN_PARAM_TERMINAL_STRUCT		6
+
+#define	IPU_FW_PSYS_N_PADDING_UINT8_IN_DATA_TERMINAL_STRUCT		3
+
+#define	IPU_FW_PSYS_N_PADDING_UINT8_IN_FRAME_DESC_STRUCT		3
+#define IPU_FW_PSYS_N_FRAME_PLANES					6
+#define IPU_FW_PSYS_N_PADDING_UINT8_IN_FRAME_STRUCT			4
+
+#define IPU_FW_PSYS_N_PADDING_UINT8_IN_BUFFER_SET_STRUCT		1
+
+#define IPU_FW_PSYS_MAX_INPUT_DEC_RESOURCES		4
+#define IPU_FW_PSYS_MAX_OUTPUT_DEC_RESOURCES		4
+
+#define IPU_FW_PSYS_PROCESS_MAX_CELLS			1
+#define IPU_FW_PSYS_KERNEL_BITMAP_NOF_ELEMS		4
+#define IPU_FW_PSYS_RBM_NOF_ELEMS			5
+#define IPU_FW_PSYS_KBM_NOF_ELEMS			4
+
+struct ipu_fw_psys_process {
+	s16 parent_offset;
+	u8 size;
+	u8 cell_dependencies_offset;
+	u8 terminal_dependencies_offset;
+	u8 process_extension_offset;
+	u8 ID;
+	u8 program_idx;
+	u8 state;
+	u8 cells[IPU_FW_PSYS_PROCESS_MAX_CELLS];
+	u8 cell_dependency_count;
+	u8 terminal_dependency_count;
+};
+
+struct ipu_fw_psys_program_manifest {
+	u32 kernel_bitmap[IPU_FW_PSYS_KERNEL_BITMAP_NOF_ELEMS];
+	s16 parent_offset;
+	u8  program_dependency_offset;
+	u8  terminal_dependency_offset;
+	u8  size;
+	u8  program_extension_offset;
+	u8 program_type;
+	u8 ID;
+	u8 cells[IPU_FW_PSYS_PROCESS_MAX_CELLS];
+	u8 cell_type_id;
+	u8 program_dependency_count;
+	u8 terminal_dependency_count;
+};
+
+/* platform specific resource interface */
+struct ipu_psys_resource_pool;
+struct ipu_psys_resource_alloc;
+struct ipu_fw_psys_process_group;
+int ipu_psys_allocate_resources(const struct device *dev,
+				struct ipu_fw_psys_process_group *pg,
+				void *pg_manifest,
+				struct ipu_psys_resource_alloc *alloc,
+				struct ipu_psys_resource_pool *pool);
+int ipu_psys_move_resources(const struct device *dev,
+			    struct ipu_psys_resource_alloc *alloc,
+			    struct ipu_psys_resource_pool *source_pool,
+			    struct ipu_psys_resource_pool *target_pool);
+
+void ipu_psys_resource_copy(struct ipu_psys_resource_pool *src,
+			    struct ipu_psys_resource_pool *dest);
+
+int ipu_psys_try_allocate_resources(struct device *dev,
+				    struct ipu_fw_psys_process_group *pg,
+				    void *pg_manifest,
+				    struct ipu_psys_resource_pool *pool);
+
+void ipu_psys_reset_process_cell(const struct device *dev,
+				 struct ipu_fw_psys_process_group *pg,
+				 void *pg_manifest,
+				 int process_count);
+void ipu_psys_free_resources(struct ipu_psys_resource_alloc *alloc,
+			     struct ipu_psys_resource_pool *pool);
+
+int ipu_fw_psys_set_proc_dfm_bitmap(struct ipu_fw_psys_process *ptr,
+				    u16 id, u32 bitmap,
+				    u32 active_bitmap);
+
+int ipu_psys_allocate_cmd_queue_resource(struct ipu_psys_resource_pool *pool);
+void ipu_psys_free_cmd_queue_resource(struct ipu_psys_resource_pool *pool,
+				      u8 queue_id);
+
+extern const struct ipu_fw_resource_definitions *ipu6_res_defs;
+extern const struct ipu_fw_resource_definitions *ipu6se_res_defs;
+extern const struct ipu_fw_resource_definitions *ipu6ep_res_defs;
+extern struct ipu6_psys_hw_res_variant hw_var;
+#endif /* IPU_PLATFORM_RESOURCES_COMMON_H */
Index: b/drivers/media/pci/intel/ipu6/ipu-platform.h
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu6/ipu-platform.h
@@ -0,0 +1,43 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2013 - 2020 Intel Corporation */
+
+#ifndef IPU_PLATFORM_H
+#define IPU_PLATFORM_H
+
+#define IPU_NAME			"intel-ipu6"
+
+#define IPU6SE_FIRMWARE_NAME		"intel/ipu6se_fw.bin"
+#define IPU6EP_FIRMWARE_NAME		"intel/ipu6ep_fw.bin"
+#define IPU6EPES_FIRMWARE_NAME		"intel/ipu6epes_fw.bin"
+#define IPU6_FIRMWARE_NAME		"intel/ipu6_fw.bin"
+#define IPU6EPMTL_FIRMWARE_NAME		"intel/ipu6epmtl_fw.bin"
+#define IPU6EPADLN_FIRMWARE_NAME	"intel/ipu6epadln_fw.bin"
+
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA) \
+	&& IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_PDATA_DYNAMIC_LOADING)
+/* array of struct ipu_spdata_rep terminated by NULL */
+#define IPU_SPDATA_NAME		"ipu6v1_spdata.bin"
+#endif
+
+/*
+ * The following definitions are encoded to the media_device's model field so
+ * that the software components which uses IPU driver can get the hw stepping
+ * information.
+ */
+#define IPU_MEDIA_DEV_MODEL_NAME		"ipu6"
+
+#define IPU6SE_ISYS_NUM_STREAMS          IPU6SE_NONSECURE_STREAM_ID_MAX
+#define IPU6_ISYS_NUM_STREAMS            IPU6_NONSECURE_STREAM_ID_MAX
+
+/* declearations, definitions in ipu6.c */
+extern struct ipu_isys_internal_pdata isys_ipdata;
+extern struct ipu_psys_internal_pdata psys_ipdata;
+extern const struct ipu_buttress_ctrl isys_buttress_ctrl;
+extern const struct ipu_buttress_ctrl psys_buttress_ctrl;
+
+/* definitions in ipu6-isys.c */
+extern struct ipu_trace_block isys_trace_blocks[];
+/* definitions in ipu6-psys.c */
+extern struct ipu_trace_block psys_trace_blocks[];
+
+#endif
Index: b/drivers/media/pci/intel/ipu6/ipu-resources.c
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu6/ipu-resources.c
@@ -0,0 +1,868 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) 2015 - 2022 Intel Corporation
+
+#include <linux/bitmap.h>
+#include <linux/errno.h>
+#include <linux/gfp.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+
+#include <uapi/linux/ipu-psys.h>
+
+#include "ipu-fw-psys.h"
+#include "ipu-psys.h"
+
+struct ipu6_psys_hw_res_variant hw_var;
+void ipu6_psys_hw_res_variant_init(void)
+{
+	if (ipu_ver == IPU_VER_6SE) {
+		hw_var.queue_num = IPU6SE_FW_PSYS_N_PSYS_CMD_QUEUE_ID;
+		hw_var.cell_num = IPU6SE_FW_PSYS_N_CELL_ID;
+	} else if (ipu_ver == IPU_VER_6) {
+		hw_var.queue_num = IPU6_FW_PSYS_N_PSYS_CMD_QUEUE_ID;
+		hw_var.cell_num = IPU6_FW_PSYS_N_CELL_ID;
+	} else if (ipu_ver == IPU_VER_6EP || ipu_ver == IPU_VER_6EP_MTL) {
+		hw_var.queue_num = IPU6_FW_PSYS_N_PSYS_CMD_QUEUE_ID;
+		hw_var.cell_num = IPU6EP_FW_PSYS_N_CELL_ID;
+	} else {
+		WARN(1, "ipu6 psys res var is not initialised correctly.");
+	}
+
+	hw_var.set_proc_dev_chn = ipu6_fw_psys_set_proc_dev_chn;
+	hw_var.set_proc_dfm_bitmap = ipu6_fw_psys_set_proc_dfm_bitmap;
+	hw_var.set_proc_ext_mem = ipu6_fw_psys_set_process_ext_mem;
+	hw_var.get_pgm_by_proc =
+		ipu6_fw_psys_get_program_manifest_by_process;
+}
+
+static const struct ipu_fw_resource_definitions *get_res(void)
+{
+	if (ipu_ver == IPU_VER_6SE)
+		return ipu6se_res_defs;
+
+	if (ipu_ver == IPU_VER_6EP || ipu_ver == IPU_VER_6EP_MTL)
+		return ipu6ep_res_defs;
+
+	return ipu6_res_defs;
+}
+
+static int ipu_resource_init(struct ipu_resource *res, u32 id, int elements)
+{
+	if (elements <= 0) {
+		res->bitmap = NULL;
+		return 0;
+	}
+
+	res->bitmap = bitmap_zalloc(elements, GFP_KERNEL);
+	if (!res->bitmap)
+		return -ENOMEM;
+	res->elements = elements;
+	res->id = id;
+	return 0;
+}
+
+static unsigned long
+ipu_resource_alloc_with_pos(struct ipu_resource *res, int n,
+			    int pos,
+			    struct ipu_resource_alloc *alloc,
+			    enum ipu_resource_type type)
+{
+	unsigned long p;
+
+	if (n <= 0) {
+		alloc->elements = 0;
+		return 0;
+	}
+
+	if (!res->bitmap || pos >= res->elements)
+		return (unsigned long)(-ENOSPC);
+
+	p = bitmap_find_next_zero_area(res->bitmap, res->elements, pos, n, 0);
+	alloc->resource = NULL;
+
+	if (p != pos)
+		return (unsigned long)(-ENOSPC);
+	bitmap_set(res->bitmap, p, n);
+	alloc->resource = res;
+	alloc->elements = n;
+	alloc->pos = p;
+	alloc->type = type;
+
+	return pos;
+}
+
+static unsigned long
+ipu_resource_alloc(struct ipu_resource *res, int n,
+		   struct ipu_resource_alloc *alloc,
+		   enum ipu_resource_type type)
+{
+	unsigned long p;
+
+	if (n <= 0) {
+		alloc->elements = 0;
+		return 0;
+	}
+
+	if (!res->bitmap)
+		return (unsigned long)(-ENOSPC);
+
+	p = bitmap_find_next_zero_area(res->bitmap, res->elements, 0, n, 0);
+	alloc->resource = NULL;
+
+	if (p >= res->elements)
+		return (unsigned long)(-ENOSPC);
+	bitmap_set(res->bitmap, p, n);
+	alloc->resource = res;
+	alloc->elements = n;
+	alloc->pos = p;
+	alloc->type = type;
+
+	return p;
+}
+
+static void ipu_resource_free(struct ipu_resource_alloc *alloc)
+{
+	if (alloc->elements <= 0)
+		return;
+
+	if (alloc->type == IPU_RESOURCE_DFM)
+		*alloc->resource->bitmap &= ~(unsigned long)(alloc->elements);
+	else
+		bitmap_clear(alloc->resource->bitmap, alloc->pos,
+			     alloc->elements);
+	alloc->resource = NULL;
+}
+
+static void ipu_resource_cleanup(struct ipu_resource *res)
+{
+	bitmap_free(res->bitmap);
+	res->bitmap = NULL;
+}
+
+/********** IPU PSYS-specific resource handling **********/
+int ipu_psys_resource_pool_init(struct ipu_psys_resource_pool *pool)
+{
+	int i, j, k, ret;
+	const struct ipu_fw_resource_definitions *res_defs;
+
+	res_defs = get_res();
+
+	spin_lock_init(&pool->queues_lock);
+	pool->cells = 0;
+
+	for (i = 0; i < res_defs->num_dev_channels; i++) {
+		ret = ipu_resource_init(&pool->dev_channels[i], i,
+					res_defs->dev_channels[i]);
+		if (ret)
+			goto error;
+	}
+
+	for (j = 0; j < res_defs->num_ext_mem_ids; j++) {
+		ret = ipu_resource_init(&pool->ext_memory[j], j,
+					res_defs->ext_mem_ids[j]);
+		if (ret)
+			goto memory_error;
+	}
+
+	for (k = 0; k < res_defs->num_dfm_ids; k++) {
+		ret = ipu_resource_init(&pool->dfms[k], k, res_defs->dfms[k]);
+		if (ret)
+			goto dfm_error;
+	}
+
+	spin_lock(&pool->queues_lock);
+	if (ipu_ver == IPU_VER_6SE)
+		bitmap_zero(pool->cmd_queues,
+			    IPU6SE_FW_PSYS_N_PSYS_CMD_QUEUE_ID);
+	else
+		bitmap_zero(pool->cmd_queues,
+			    IPU6_FW_PSYS_N_PSYS_CMD_QUEUE_ID);
+	spin_unlock(&pool->queues_lock);
+
+	return 0;
+
+dfm_error:
+	for (k--; k >= 0; k--)
+		ipu_resource_cleanup(&pool->dfms[k]);
+
+memory_error:
+	for (j--; j >= 0; j--)
+		ipu_resource_cleanup(&pool->ext_memory[j]);
+
+error:
+	for (i--; i >= 0; i--)
+		ipu_resource_cleanup(&pool->dev_channels[i]);
+	return ret;
+}
+
+void ipu_psys_resource_copy(struct ipu_psys_resource_pool *src,
+			    struct ipu_psys_resource_pool *dest)
+{
+	int i;
+	const struct ipu_fw_resource_definitions *res_defs;
+
+	res_defs = get_res();
+
+	dest->cells = src->cells;
+	for (i = 0; i < res_defs->num_dev_channels; i++)
+		*dest->dev_channels[i].bitmap = *src->dev_channels[i].bitmap;
+
+	for (i = 0; i < res_defs->num_ext_mem_ids; i++)
+		*dest->ext_memory[i].bitmap = *src->ext_memory[i].bitmap;
+
+	for (i = 0; i < res_defs->num_dfm_ids; i++)
+		*dest->dfms[i].bitmap = *src->dfms[i].bitmap;
+}
+
+void ipu_psys_resource_pool_cleanup(struct ipu_psys_resource_pool
+				    *pool)
+{
+	u32 i;
+	const struct ipu_fw_resource_definitions *res_defs;
+
+	res_defs = get_res();
+	for (i = 0; i < res_defs->num_dev_channels; i++)
+		ipu_resource_cleanup(&pool->dev_channels[i]);
+
+	for (i = 0; i < res_defs->num_ext_mem_ids; i++)
+		ipu_resource_cleanup(&pool->ext_memory[i]);
+
+	for (i = 0; i < res_defs->num_dfm_ids; i++)
+		ipu_resource_cleanup(&pool->dfms[i]);
+}
+
+static int __alloc_one_resrc(const struct device *dev,
+			     struct ipu_fw_psys_process *process,
+			     struct ipu_resource *resource,
+			     struct ipu_fw_generic_program_manifest *pm,
+			     u32 resource_id,
+			     struct ipu_psys_resource_alloc *alloc)
+{
+	const u16 resource_req = pm->dev_chn_size[resource_id];
+	const u16 resource_offset_req = pm->dev_chn_offset[resource_id];
+	unsigned long retl;
+
+	if (!resource_req)
+		return -ENXIO;
+
+	if (alloc->resources >= IPU_MAX_RESOURCES) {
+		dev_err(dev, "out of resource handles\n");
+		return -ENOSPC;
+	}
+	if (resource_offset_req != (u16)(-1))
+		retl = ipu_resource_alloc_with_pos
+		    (resource,
+		     resource_req,
+		     resource_offset_req,
+		     &alloc->resource_alloc[alloc->resources],
+		     IPU_RESOURCE_DEV_CHN);
+	else
+		retl = ipu_resource_alloc
+		    (resource, resource_req,
+		     &alloc->resource_alloc[alloc->resources],
+		     IPU_RESOURCE_DEV_CHN);
+	if (IS_ERR_VALUE(retl)) {
+		dev_dbg(dev, "out of device channel resources\n");
+		return (int)retl;
+	}
+	alloc->resources++;
+
+	return 0;
+}
+
+static int ipu_psys_allocate_one_dfm(const struct device *dev,
+				     struct ipu_fw_psys_process *process,
+				     struct ipu_resource *resource,
+				     struct ipu_fw_generic_program_manifest *pm,
+				     u32 resource_id,
+				     struct ipu_psys_resource_alloc *alloc)
+{
+	u32 dfm_bitmap_req = pm->dfm_port_bitmap[resource_id];
+	u32 active_dfm_bitmap_req = pm->dfm_active_port_bitmap[resource_id];
+	const u8 is_relocatable = pm->is_dfm_relocatable[resource_id];
+	struct ipu_resource_alloc *alloc_resource;
+	unsigned long p = 0;
+
+	if (!dfm_bitmap_req)
+		return -ENXIO;
+
+	if (alloc->resources >= IPU_MAX_RESOURCES) {
+		dev_err(dev, "out of resource handles\n");
+		return -ENOSPC;
+	}
+
+	if (!resource->bitmap)
+		return -ENOSPC;
+
+	if (!is_relocatable) {
+		if (*resource->bitmap & dfm_bitmap_req) {
+			dev_warn(dev,
+				 "out of dfm resources, req 0x%x, get 0x%lx\n",
+				 dfm_bitmap_req, *resource->bitmap);
+			return -ENOSPC;
+		}
+		*resource->bitmap |= dfm_bitmap_req;
+	} else {
+		unsigned int n = hweight32(dfm_bitmap_req);
+
+		p = bitmap_find_next_zero_area(resource->bitmap,
+					       resource->elements, 0, n, 0);
+
+		if (p >= resource->elements)
+			return -ENOSPC;
+
+		bitmap_set(resource->bitmap, p, n);
+		dfm_bitmap_req = dfm_bitmap_req << p;
+		active_dfm_bitmap_req = active_dfm_bitmap_req << p;
+	}
+
+	alloc_resource = &alloc->resource_alloc[alloc->resources];
+	alloc_resource->resource = resource;
+	/* Using elements to indicate the bitmap */
+	alloc_resource->elements = dfm_bitmap_req;
+	alloc_resource->pos = p;
+	alloc_resource->type = IPU_RESOURCE_DFM;
+
+	alloc->resources++;
+
+	return 0;
+}
+
+/*
+ * ext_mem_type_id is a generic type id for memory (like DMEM, VMEM)
+ * ext_mem_bank_id is detailed type id for  memory (like DMEM0, DMEM1 etc.)
+ */
+static int __alloc_mem_resrc(const struct device *dev,
+			     struct ipu_fw_psys_process *process,
+			     struct ipu_resource *resource,
+			     struct ipu_fw_generic_program_manifest *pm,
+			     u32 ext_mem_type_id, u32 ext_mem_bank_id,
+			     struct ipu_psys_resource_alloc *alloc)
+{
+	const u16 memory_resource_req = pm->ext_mem_size[ext_mem_type_id];
+	const u16 memory_offset_req = pm->ext_mem_offset[ext_mem_type_id];
+
+	unsigned long retl;
+
+	if (!memory_resource_req)
+		return -ENXIO;
+
+	if (alloc->resources >= IPU_MAX_RESOURCES) {
+		dev_err(dev, "out of resource handles\n");
+		return -ENOSPC;
+	}
+	if (memory_offset_req != (u16)(-1))
+		retl = ipu_resource_alloc_with_pos
+		    (resource,
+		     memory_resource_req, memory_offset_req,
+		     &alloc->resource_alloc[alloc->resources],
+		     IPU_RESOURCE_EXT_MEM);
+	else
+		retl = ipu_resource_alloc
+		    (resource, memory_resource_req,
+		     &alloc->resource_alloc[alloc->resources],
+		     IPU_RESOURCE_EXT_MEM);
+	if (IS_ERR_VALUE(retl)) {
+		dev_dbg(dev, "out of memory resources\n");
+		return (int)retl;
+	}
+
+	alloc->resources++;
+
+	return 0;
+}
+
+int ipu_psys_allocate_cmd_queue_resource(struct ipu_psys_resource_pool *pool)
+{
+	unsigned long p;
+	int size, start;
+
+	size = IPU6_FW_PSYS_N_PSYS_CMD_QUEUE_ID;
+	start = IPU6_FW_PSYS_CMD_QUEUE_PPG0_COMMAND_ID;
+
+	if (ipu_ver == IPU_VER_6SE) {
+		size = IPU6SE_FW_PSYS_N_PSYS_CMD_QUEUE_ID;
+		start = IPU6SE_FW_PSYS_CMD_QUEUE_PPG0_COMMAND_ID;
+	}
+
+	spin_lock(&pool->queues_lock);
+	/* find available cmd queue from ppg0_cmd_id */
+	p = bitmap_find_next_zero_area(pool->cmd_queues, size, start, 1, 0);
+
+	if (p >= size) {
+		spin_unlock(&pool->queues_lock);
+		return -ENOSPC;
+	}
+
+	bitmap_set(pool->cmd_queues, p, 1);
+	spin_unlock(&pool->queues_lock);
+
+	return p;
+}
+
+void ipu_psys_free_cmd_queue_resource(struct ipu_psys_resource_pool *pool,
+				      u8 queue_id)
+{
+	spin_lock(&pool->queues_lock);
+	bitmap_clear(pool->cmd_queues, queue_id, 1);
+	spin_unlock(&pool->queues_lock);
+}
+
+int ipu_psys_try_allocate_resources(struct device *dev,
+				    struct ipu_fw_psys_process_group *pg,
+				    void *pg_manifest,
+				    struct ipu_psys_resource_pool *pool)
+{
+	u32 id, idx;
+	u32 mem_type_id;
+	int ret, i;
+	u16 *process_offset_table;
+	u8 processes;
+	u32 cells = 0;
+	struct ipu_psys_resource_alloc *alloc;
+	const struct ipu_fw_resource_definitions *res_defs;
+
+	if (!pg)
+		return -EINVAL;
+	process_offset_table = (u16 *)((u8 *)pg + pg->processes_offset);
+	processes = pg->process_count;
+
+	alloc = kzalloc(sizeof(*alloc), GFP_KERNEL);
+	if (!alloc)
+		return -ENOMEM;
+
+	res_defs = get_res();
+	for (i = 0; i < processes; i++) {
+		u32 cell;
+		struct ipu_fw_psys_process *process =
+			(struct ipu_fw_psys_process *)
+			((char *)pg + process_offset_table[i]);
+		struct ipu_fw_generic_program_manifest pm;
+
+		memset(&pm, 0, sizeof(pm));
+
+		if (!process) {
+			dev_err(dev, "can not get process\n");
+			ret = -ENOENT;
+			goto free_out;
+		}
+
+		ret = ipu_fw_psys_get_program_manifest_by_process
+			(&pm, pg_manifest, process);
+		if (ret < 0) {
+			dev_err(dev, "can not get manifest\n");
+			goto free_out;
+		}
+
+		if (pm.cell_id == res_defs->num_cells &&
+		    pm.cell_type_id == res_defs->num_cells_type) {
+			cell = res_defs->num_cells;
+		} else if ((pm.cell_id != res_defs->num_cells &&
+			    pm.cell_type_id == res_defs->num_cells_type)) {
+			cell = pm.cell_id;
+		} else {
+			/* Find a free cell of desired type */
+			u32 type = pm.cell_type_id;
+
+			for (cell = 0; cell < res_defs->num_cells; cell++)
+				if (res_defs->cells[cell] == type &&
+				    ((pool->cells | cells) & (1 << cell)) == 0)
+					break;
+			if (cell >= res_defs->num_cells) {
+				dev_dbg(dev, "no free cells of right type\n");
+				ret = -ENOSPC;
+				goto free_out;
+			}
+		}
+		if (cell < res_defs->num_cells)
+			cells |= 1 << cell;
+		if (pool->cells & cells) {
+			dev_dbg(dev, "out of cell resources\n");
+			ret = -ENOSPC;
+			goto free_out;
+		}
+
+		if (pm.dev_chn_size) {
+			for (id = 0; id < res_defs->num_dev_channels; id++) {
+				ret = __alloc_one_resrc(dev, process,
+							&pool->dev_channels[id],
+							&pm, id, alloc);
+				if (ret == -ENXIO)
+					continue;
+
+				if (ret)
+					goto free_out;
+			}
+		}
+
+		if (pm.dfm_port_bitmap) {
+			for (id = 0; id < res_defs->num_dfm_ids; id++) {
+				ret = ipu_psys_allocate_one_dfm
+					(dev, process,
+					 &pool->dfms[id], &pm, id, alloc);
+				if (ret == -ENXIO)
+					continue;
+
+				if (ret)
+					goto free_out;
+			}
+		}
+
+		if (pm.ext_mem_size) {
+			for (mem_type_id = 0;
+			     mem_type_id < res_defs->num_ext_mem_types;
+			     mem_type_id++) {
+				u32 bank = res_defs->num_ext_mem_ids;
+
+				if (cell != res_defs->num_cells) {
+					idx = res_defs->cell_mem_row * cell +
+						mem_type_id;
+					bank = res_defs->cell_mem[idx];
+				}
+
+				if (bank == res_defs->num_ext_mem_ids)
+					continue;
+
+				ret = __alloc_mem_resrc(dev, process,
+							&pool->ext_memory[bank],
+							&pm, mem_type_id, bank,
+							alloc);
+				if (ret == -ENXIO)
+					continue;
+
+				if (ret)
+					goto free_out;
+			}
+		}
+	}
+
+	pool->cells |= cells;
+
+	kfree(alloc);
+	return 0;
+
+free_out:
+	dev_dbg(dev, "failed to try_allocate resource\n");
+	kfree(alloc);
+	return ret;
+}
+
+/*
+ * Allocate resources for pg from `pool'. Mark the allocated
+ * resources into `alloc'. Returns 0 on success, -ENOSPC
+ * if there are no enough resources, in which cases resources
+ * are not allocated at all, or some other error on other conditions.
+ */
+int ipu_psys_allocate_resources(const struct device *dev,
+				struct ipu_fw_psys_process_group *pg,
+				void *pg_manifest,
+				struct ipu_psys_resource_alloc
+				*alloc, struct ipu_psys_resource_pool
+				*pool)
+{
+	u32 id;
+	u32 mem_type_id;
+	int ret, i;
+	u16 *process_offset_table;
+	u8 processes;
+	u32 cells = 0;
+	int p, idx;
+	u32 bmp, a_bmp;
+	const struct ipu_fw_resource_definitions *res_defs;
+
+	if (!pg)
+		return -EINVAL;
+
+	res_defs = get_res();
+	process_offset_table = (u16 *)((u8 *)pg + pg->processes_offset);
+	processes = pg->process_count;
+
+	for (i = 0; i < processes; i++) {
+		u32 cell;
+		struct ipu_fw_psys_process *process =
+		    (struct ipu_fw_psys_process *)
+		    ((char *)pg + process_offset_table[i]);
+		struct ipu_fw_generic_program_manifest pm;
+
+		memset(&pm, 0, sizeof(pm));
+		if (!process) {
+			dev_err(dev, "can not get process\n");
+			ret = -ENOENT;
+			goto free_out;
+		}
+
+		ret = ipu_fw_psys_get_program_manifest_by_process
+		    (&pm, pg_manifest, process);
+		if (ret < 0) {
+			dev_err(dev, "can not get manifest\n");
+			goto free_out;
+		}
+
+		if (pm.cell_id == res_defs->num_cells &&
+		    pm.cell_type_id == res_defs->num_cells_type) {
+			cell = res_defs->num_cells;
+		} else if ((pm.cell_id != res_defs->num_cells &&
+			    pm.cell_type_id == res_defs->num_cells_type)) {
+			cell = pm.cell_id;
+		} else {
+			/* Find a free cell of desired type */
+			u32 type = pm.cell_type_id;
+
+			for (cell = 0; cell < res_defs->num_cells; cell++)
+				if (res_defs->cells[cell] == type &&
+				    ((pool->cells | cells) & (1 << cell)) == 0)
+					break;
+			if (cell >= res_defs->num_cells) {
+				dev_dbg(dev, "no free cells of right type\n");
+				ret = -ENOSPC;
+				goto free_out;
+			}
+			ret = ipu_fw_psys_set_process_cell_id(process, 0, cell);
+			if (ret)
+				goto free_out;
+		}
+		if (cell < res_defs->num_cells)
+			cells |= 1 << cell;
+		if (pool->cells & cells) {
+			dev_dbg(dev, "out of cell resources\n");
+			ret = -ENOSPC;
+			goto free_out;
+		}
+
+		if (pm.dev_chn_size) {
+			for (id = 0; id < res_defs->num_dev_channels; id++) {
+				ret = __alloc_one_resrc(dev, process,
+							&pool->dev_channels[id],
+							&pm, id, alloc);
+				if (ret == -ENXIO)
+					continue;
+
+				if (ret)
+					goto free_out;
+
+				idx = alloc->resources - 1;
+				p = alloc->resource_alloc[idx].pos;
+				ret = ipu_fw_psys_set_proc_dev_chn(process, id,
+								   p);
+				if (ret)
+					goto free_out;
+			}
+		}
+
+		if (pm.dfm_port_bitmap) {
+			for (id = 0; id < res_defs->num_dfm_ids; id++) {
+				ret = ipu_psys_allocate_one_dfm(dev, process,
+								&pool->dfms[id],
+								&pm, id, alloc);
+				if (ret == -ENXIO)
+					continue;
+
+				if (ret)
+					goto free_out;
+
+				idx = alloc->resources - 1;
+				p = alloc->resource_alloc[idx].pos;
+				bmp = pm.dfm_port_bitmap[id];
+				bmp = bmp << p;
+				a_bmp = pm.dfm_active_port_bitmap[id];
+				a_bmp = a_bmp << p;
+				ret = ipu_fw_psys_set_proc_dfm_bitmap(process,
+								      id, bmp,
+								      a_bmp);
+				if (ret)
+					goto free_out;
+			}
+		}
+
+		if (pm.ext_mem_size) {
+			for (mem_type_id = 0;
+			     mem_type_id < res_defs->num_ext_mem_types;
+			     mem_type_id++) {
+				u32 bank = res_defs->num_ext_mem_ids;
+
+				if (cell != res_defs->num_cells) {
+					idx = res_defs->cell_mem_row * cell +
+						mem_type_id;
+					bank = res_defs->cell_mem[idx];
+				}
+				if (bank == res_defs->num_ext_mem_ids)
+					continue;
+
+				ret = __alloc_mem_resrc(dev, process,
+							&pool->ext_memory[bank],
+							&pm, mem_type_id,
+							bank, alloc);
+				if (ret == -ENXIO)
+					continue;
+
+				if (ret)
+					goto free_out;
+
+				/* no return value check here because fw api
+				 * will do some checks, and would return
+				 * non-zero except mem_type_id == 0.
+				 * This maybe caused by that above flow of
+				 * allocating mem_bank_id is improper.
+				 */
+				idx = alloc->resources - 1;
+				p = alloc->resource_alloc[idx].pos;
+				ipu_fw_psys_set_process_ext_mem(process,
+								mem_type_id,
+								bank, p);
+			}
+		}
+	}
+	alloc->cells |= cells;
+	pool->cells |= cells;
+	return 0;
+
+free_out:
+	dev_err(dev, "failed to allocate resources, ret %d\n", ret);
+	ipu_psys_reset_process_cell(dev, pg, pg_manifest, i + 1);
+	ipu_psys_free_resources(alloc, pool);
+	return ret;
+}
+
+int ipu_psys_move_resources(const struct device *dev,
+			    struct ipu_psys_resource_alloc *alloc,
+			    struct ipu_psys_resource_pool
+			    *source_pool, struct ipu_psys_resource_pool
+			    *target_pool)
+{
+	int i;
+
+	if (target_pool->cells & alloc->cells) {
+		dev_dbg(dev, "out of cell resources\n");
+		return -ENOSPC;
+	}
+
+	for (i = 0; i < alloc->resources; i++) {
+		unsigned long bitmap = 0;
+		unsigned int id = alloc->resource_alloc[i].resource->id;
+		unsigned long fbit, end;
+
+		switch (alloc->resource_alloc[i].type) {
+		case IPU_RESOURCE_DEV_CHN:
+			bitmap_set(&bitmap, alloc->resource_alloc[i].pos,
+				   alloc->resource_alloc[i].elements);
+			if (*target_pool->dev_channels[id].bitmap & bitmap)
+				return -ENOSPC;
+			break;
+		case IPU_RESOURCE_EXT_MEM:
+			end = alloc->resource_alloc[i].elements +
+			    alloc->resource_alloc[i].pos;
+
+			fbit = find_next_bit(target_pool->ext_memory[id].bitmap,
+					     end, alloc->resource_alloc[i].pos);
+			/* if find_next_bit returns "end" it didn't find 1bit */
+			if (end != fbit)
+				return -ENOSPC;
+			break;
+		case IPU_RESOURCE_DFM:
+			bitmap = alloc->resource_alloc[i].elements;
+			if (*target_pool->dfms[id].bitmap & bitmap)
+				return -ENOSPC;
+			break;
+		default:
+			dev_err(dev, "Illegal resource type\n");
+			return -EINVAL;
+		}
+	}
+
+	for (i = 0; i < alloc->resources; i++) {
+		u32 id = alloc->resource_alloc[i].resource->id;
+
+		switch (alloc->resource_alloc[i].type) {
+		case IPU_RESOURCE_DEV_CHN:
+			bitmap_set(target_pool->dev_channels[id].bitmap,
+				   alloc->resource_alloc[i].pos,
+				   alloc->resource_alloc[i].elements);
+			ipu_resource_free(&alloc->resource_alloc[i]);
+			alloc->resource_alloc[i].resource =
+			    &target_pool->dev_channels[id];
+			break;
+		case IPU_RESOURCE_EXT_MEM:
+			bitmap_set(target_pool->ext_memory[id].bitmap,
+				   alloc->resource_alloc[i].pos,
+				   alloc->resource_alloc[i].elements);
+			ipu_resource_free(&alloc->resource_alloc[i]);
+			alloc->resource_alloc[i].resource =
+			    &target_pool->ext_memory[id];
+			break;
+		case IPU_RESOURCE_DFM:
+			*target_pool->dfms[id].bitmap |=
+			    alloc->resource_alloc[i].elements;
+			*alloc->resource_alloc[i].resource->bitmap &=
+			    ~(alloc->resource_alloc[i].elements);
+			alloc->resource_alloc[i].resource =
+			    &target_pool->dfms[id];
+			break;
+		default:
+			/*
+			 * Just keep compiler happy. This case failed already
+			 * in above loop.
+			 */
+			break;
+		}
+	}
+
+	target_pool->cells |= alloc->cells;
+	source_pool->cells &= ~alloc->cells;
+
+	return 0;
+}
+
+void ipu_psys_reset_process_cell(const struct device *dev,
+				 struct ipu_fw_psys_process_group *pg,
+				 void *pg_manifest,
+				 int process_count)
+{
+	int i;
+	u16 *process_offset_table;
+	const struct ipu_fw_resource_definitions *res_defs;
+
+	if (!pg)
+		return;
+
+	res_defs = get_res();
+	process_offset_table = (u16 *)((u8 *)pg + pg->processes_offset);
+	for (i = 0; i < process_count; i++) {
+		struct ipu_fw_psys_process *process =
+		    (struct ipu_fw_psys_process *)
+		    ((char *)pg + process_offset_table[i]);
+		struct ipu_fw_generic_program_manifest pm;
+		int ret;
+
+		if (!process)
+			break;
+
+		ret = ipu_fw_psys_get_program_manifest_by_process(&pm,
+								  pg_manifest,
+								  process);
+		if (ret < 0) {
+			dev_err(dev, "can not get manifest\n");
+			break;
+		}
+		if ((pm.cell_id != res_defs->num_cells &&
+		     pm.cell_type_id == res_defs->num_cells_type))
+			continue;
+		/* no return value check here because if finding free cell
+		 * failed, process cell would not set then calling clear_cell
+		 * will return non-zero.
+		 */
+		ipu_fw_psys_clear_process_cell(process);
+	}
+}
+
+/* Free resources marked in `alloc' from `resources' */
+void ipu_psys_free_resources(struct ipu_psys_resource_alloc
+			     *alloc, struct ipu_psys_resource_pool *pool)
+{
+	unsigned int i;
+
+	pool->cells &= ~alloc->cells;
+	alloc->cells = 0;
+	for (i = 0; i < alloc->resources; i++)
+		ipu_resource_free(&alloc->resource_alloc[i]);
+	alloc->resources = 0;
+}
Index: b/drivers/media/pci/intel/ipu6/ipu6-fw-resources.c
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu6/ipu6-fw-resources.c
@@ -0,0 +1,609 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) 2015 - 2021 Intel Corporation
+
+#include <linux/err.h>
+#include <linux/string.h>
+
+#include "ipu-psys.h"
+#include "ipu-fw-psys.h"
+#include "ipu6-platform-resources.h"
+
+/* resources table */
+
+/*
+ * Cell types by cell IDs
+ */
+static const u8 ipu6_fw_psys_cell_types[IPU6_FW_PSYS_N_CELL_ID] = {
+	IPU6_FW_PSYS_SP_CTRL_TYPE_ID,
+	IPU6_FW_PSYS_VP_TYPE_ID,
+	IPU6_FW_PSYS_ACC_PSA_TYPE_ID,
+	IPU6_FW_PSYS_ACC_PSA_TYPE_ID,
+	IPU6_FW_PSYS_ACC_PSA_TYPE_ID,
+	IPU6_FW_PSYS_ACC_PSA_TYPE_ID,
+	IPU6_FW_PSYS_ACC_OSA_TYPE_ID,
+	IPU6_FW_PSYS_ACC_OSA_TYPE_ID,
+	IPU6_FW_PSYS_ACC_OSA_TYPE_ID,
+	IPU6_FW_PSYS_ACC_PSA_TYPE_ID,
+	IPU6_FW_PSYS_ACC_PSA_TYPE_ID,
+	IPU6_FW_PSYS_ACC_PSA_TYPE_ID,
+	IPU6_FW_PSYS_ACC_PSA_TYPE_ID,
+	IPU6_FW_PSYS_ACC_ISA_TYPE_ID,
+	IPU6_FW_PSYS_ACC_ISA_TYPE_ID,
+	IPU6_FW_PSYS_ACC_ISA_TYPE_ID,
+	IPU6_FW_PSYS_ACC_ISA_TYPE_ID,
+	IPU6_FW_PSYS_ACC_ISA_TYPE_ID,
+	IPU6_FW_PSYS_ACC_ISA_TYPE_ID,
+	IPU6_FW_PSYS_ACC_ISA_TYPE_ID,
+	IPU6_FW_PSYS_ACC_ISA_TYPE_ID,
+	IPU6_FW_PSYS_ACC_ISA_TYPE_ID,
+	IPU6_FW_PSYS_ACC_ISA_TYPE_ID,
+	IPU6_FW_PSYS_ACC_ISA_TYPE_ID,
+	IPU6_FW_PSYS_ACC_ISA_TYPE_ID,
+	IPU6_FW_PSYS_ACC_ISA_TYPE_ID,
+	IPU6_FW_PSYS_ACC_ISA_TYPE_ID, /* X2B_MD */
+	IPU6_FW_PSYS_ACC_ISA_TYPE_ID, /* ICA_MEDIUM */
+	IPU6_FW_PSYS_ACC_ISA_TYPE_ID, /* X2B_SVE_RGBIR */
+	IPU6_FW_PSYS_ACC_ISA_TYPE_ID, /* PAF */
+	IPU6_FW_PSYS_GDC_TYPE_ID,
+	IPU6_FW_PSYS_TNR_TYPE_ID,
+};
+
+static const u16 ipu6_fw_num_dev_channels[IPU6_FW_PSYS_N_DEV_CHN_ID] = {
+	IPU6_FW_PSYS_DEV_CHN_DMA_EXT0_MAX_SIZE,
+	IPU6_FW_PSYS_DEV_CHN_DMA_EXT1_READ_MAX_SIZE,
+	IPU6_FW_PSYS_DEV_CHN_DMA_EXT1_WRITE_MAX_SIZE,
+	IPU6_FW_PSYS_DEV_CHN_DMA_INTERNAL_MAX_SIZE,
+	IPU6_FW_PSYS_DEV_CHN_DMA_ISA_MAX_SIZE,
+};
+
+static const u16 ipu6_fw_psys_mem_size[IPU6_FW_PSYS_N_MEM_ID] = {
+	IPU6_FW_PSYS_VMEM0_MAX_SIZE,
+	IPU6_FW_PSYS_TRANSFER_VMEM0_MAX_SIZE,
+	IPU6_FW_PSYS_TRANSFER_VMEM1_MAX_SIZE,
+	IPU6_FW_PSYS_LB_VMEM_MAX_SIZE,
+	IPU6_FW_PSYS_BAMEM0_MAX_SIZE,
+	IPU6_FW_PSYS_DMEM0_MAX_SIZE,
+	IPU6_FW_PSYS_DMEM1_MAX_SIZE,
+	IPU6_FW_PSYS_DMEM2_MAX_SIZE,
+	IPU6_FW_PSYS_DMEM3_MAX_SIZE,
+	IPU6_FW_PSYS_PMEM0_MAX_SIZE
+};
+
+static const u16 ipu6_fw_psys_dfms[IPU6_FW_PSYS_N_DEV_DFM_ID] = {
+	IPU6_FW_PSYS_DEV_DFM_BB_FULL_PORT_ID_MAX_SIZE,
+	IPU6_FW_PSYS_DEV_DFM_BB_EMPTY_PORT_ID_MAX_SIZE,
+	IPU6_FW_PSYS_DEV_DFM_ISL_FULL_PORT_ID_MAX_SIZE,
+	IPU6_FW_PSYS_DEV_DFM_ISL_EMPTY_PORT_ID_MAX_SIZE,
+	IPU6_FW_PSYS_DEV_DFM_LB_FULL_PORT_ID_MAX_SIZE,
+	IPU6_FW_PSYS_DEV_DFM_LB_EMPTY_PORT_ID_MAX_SIZE,
+};
+
+static const u8
+ipu6_fw_psys_c_mem[IPU6_FW_PSYS_N_CELL_ID][IPU6_FW_PSYS_N_MEM_TYPE_ID] = {
+	{
+		/* IPU6_FW_PSYS_SP0_ID */
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_DMEM0_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+	},
+	{
+		/* IPU6_FW_PSYS_SP1_ID */
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_DMEM1_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+	},
+	{
+		/* IPU6_FW_PSYS_VP0_ID */
+		IPU6_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6_FW_PSYS_TRANSFER_VMEM1_ID,
+		IPU6_FW_PSYS_LB_VMEM_ID,
+		IPU6_FW_PSYS_DMEM3_ID,
+		IPU6_FW_PSYS_VMEM0_ID,
+		IPU6_FW_PSYS_BAMEM0_ID,
+		IPU6_FW_PSYS_PMEM0_ID,
+	},
+	{
+		/* IPU6_FW_PSYS_ACC1_ID BNLM */
+		IPU6_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6_FW_PSYS_TRANSFER_VMEM1_ID,
+		IPU6_FW_PSYS_LB_VMEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+	},
+	{
+		/* IPU6_FW_PSYS_ACC2_ID DM */
+		IPU6_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6_FW_PSYS_TRANSFER_VMEM1_ID,
+		IPU6_FW_PSYS_LB_VMEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+	},
+	{
+		/* IPU6_FW_PSYS_ACC3_ID ACM */
+		IPU6_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6_FW_PSYS_TRANSFER_VMEM1_ID,
+		IPU6_FW_PSYS_LB_VMEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+	},
+	{
+		/* IPU6_FW_PSYS_ACC4_ID GTC YUV1 */
+		IPU6_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6_FW_PSYS_TRANSFER_VMEM1_ID,
+		IPU6_FW_PSYS_LB_VMEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+	},
+	{
+		/* IPU6_FW_PSYS_ACC5_ID OFS pin main */
+		IPU6_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6_FW_PSYS_TRANSFER_VMEM1_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+	},
+	{
+		/* IPU6_FW_PSYS_ACC6_ID OFS pin display */
+		IPU6_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6_FW_PSYS_TRANSFER_VMEM1_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+	},
+	{
+		/* IPU6_FW_PSYS_ACC7_ID OFS pin pp */
+		IPU6_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6_FW_PSYS_TRANSFER_VMEM1_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+	},
+	{
+		/* IPU6_FW_PSYS_ACC8_ID GAMMASTAR */
+		IPU6_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6_FW_PSYS_TRANSFER_VMEM1_ID,
+		IPU6_FW_PSYS_LB_VMEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+	},
+	{
+		/* IPU6_FW_PSYS_ACC9_ID GLTM */
+		IPU6_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6_FW_PSYS_TRANSFER_VMEM1_ID,
+		IPU6_FW_PSYS_LB_VMEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+	},
+	{
+		/* IPU6_FW_PSYS_ACC10_ID XNR */
+		IPU6_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6_FW_PSYS_TRANSFER_VMEM1_ID,
+		IPU6_FW_PSYS_LB_VMEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+	},
+	{
+		/* IPU6_FW_PSYS_ISA_ICA_ID */
+		IPU6_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6_FW_PSYS_TRANSFER_VMEM1_ID,
+		IPU6_FW_PSYS_LB_VMEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+	},
+	{
+		/* IPU6_FW_PSYS_ISA_LSC_ID */
+		IPU6_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6_FW_PSYS_TRANSFER_VMEM1_ID,
+		IPU6_FW_PSYS_LB_VMEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+	},
+	{
+		/* IPU6_FW_PSYS_ISA_DPC_ID */
+		IPU6_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6_FW_PSYS_TRANSFER_VMEM1_ID,
+		IPU6_FW_PSYS_LB_VMEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+	},
+	{
+		/* IPU6_FW_PSYS_ISA_SIS_A_ID */
+		IPU6_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6_FW_PSYS_TRANSFER_VMEM1_ID,
+		IPU6_FW_PSYS_LB_VMEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+	},
+	{
+		/* IPU6_FW_PSYS_ISA_SIS_B_ID */
+		IPU6_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6_FW_PSYS_TRANSFER_VMEM1_ID,
+		IPU6_FW_PSYS_LB_VMEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+	},
+	{
+		/* IPU6_FW_PSYS_ISA_B2B_ID */
+		IPU6_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6_FW_PSYS_TRANSFER_VMEM1_ID,
+		IPU6_FW_PSYS_LB_VMEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+	},
+	{
+		/* IPU6_FW_PSYS_ISA_B2R_ID and ISA_R2I_SIE */
+		IPU6_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6_FW_PSYS_TRANSFER_VMEM1_ID,
+		IPU6_FW_PSYS_LB_VMEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+	},
+	{
+		/* IPU6_FW_PSYS_ISA_R2I_DS_A_ID */
+		IPU6_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6_FW_PSYS_TRANSFER_VMEM1_ID,
+		IPU6_FW_PSYS_LB_VMEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+	},
+	{
+		/* IPU6_FW_PSYS_ISA_R2I_DS_B_ID */
+		IPU6_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6_FW_PSYS_TRANSFER_VMEM1_ID,
+		IPU6_FW_PSYS_LB_VMEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+	},
+	{
+		/* IPU6_FW_PSYS_ISA_AWB_ID */
+		IPU6_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6_FW_PSYS_TRANSFER_VMEM1_ID,
+		IPU6_FW_PSYS_LB_VMEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+	},
+	{
+		/* IPU6_FW_PSYS_ISA_AE_ID */
+		IPU6_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6_FW_PSYS_TRANSFER_VMEM1_ID,
+		IPU6_FW_PSYS_LB_VMEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+	},
+	{
+		/* IPU6_FW_PSYS_ISA_AF_ID */
+		IPU6_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6_FW_PSYS_TRANSFER_VMEM1_ID,
+		IPU6_FW_PSYS_LB_VMEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+	},
+	{
+		/* IPU6_FW_PSYS_ISA_DOL_ID */
+		IPU6_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6_FW_PSYS_TRANSFER_VMEM1_ID,
+		IPU6_FW_PSYS_LB_VMEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+	},
+	{
+		/* IPU6_FW_PSYS_ISA_X2B_MD_ID */
+		IPU6_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6_FW_PSYS_TRANSFER_VMEM1_ID,
+		IPU6_FW_PSYS_LB_VMEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+	},
+	{
+		/* IPU6_FW_PSYS_ISA_ICA_MEDIUM_ID */
+		IPU6_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6_FW_PSYS_TRANSFER_VMEM1_ID,
+		IPU6_FW_PSYS_LB_VMEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+	},
+	{
+		/* IPU6_FW_PSYS_ISA_X2B_SVE_RGBIR_ID */
+		IPU6_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6_FW_PSYS_TRANSFER_VMEM1_ID,
+		IPU6_FW_PSYS_LB_VMEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+	},
+	{
+		/* IPU6_FW_PSYS_ISA_PAF_ID */
+		IPU6_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6_FW_PSYS_TRANSFER_VMEM1_ID,
+		IPU6_FW_PSYS_LB_VMEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+	},
+	{
+		/* IPU6_FW_PSYS_BB_ACC_GDC0_ID */
+		IPU6_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6_FW_PSYS_TRANSFER_VMEM1_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+	},
+	{
+		/* IPU6_FW_PSYS_BB_ACC_TNR_ID */
+		IPU6_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6_FW_PSYS_TRANSFER_VMEM1_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+	}
+};
+
+static const struct ipu_fw_resource_definitions ipu6_defs = {
+	.cells = ipu6_fw_psys_cell_types,
+	.num_cells = IPU6_FW_PSYS_N_CELL_ID,
+	.num_cells_type = IPU6_FW_PSYS_N_CELL_TYPE_ID,
+
+	.dev_channels = ipu6_fw_num_dev_channels,
+	.num_dev_channels = IPU6_FW_PSYS_N_DEV_CHN_ID,
+
+	.num_ext_mem_types = IPU6_FW_PSYS_N_DATA_MEM_TYPE_ID,
+	.num_ext_mem_ids = IPU6_FW_PSYS_N_MEM_ID,
+	.ext_mem_ids = ipu6_fw_psys_mem_size,
+
+	.num_dfm_ids = IPU6_FW_PSYS_N_DEV_DFM_ID,
+
+	.dfms = ipu6_fw_psys_dfms,
+
+	.cell_mem_row = IPU6_FW_PSYS_N_MEM_TYPE_ID,
+	.cell_mem = &ipu6_fw_psys_c_mem[0][0],
+};
+
+const struct ipu_fw_resource_definitions *ipu6_res_defs = &ipu6_defs;
+
+/********** Generic resource handling **********/
+
+int ipu6_fw_psys_set_proc_dev_chn(struct ipu_fw_psys_process *ptr, u16 offset,
+				  u16 value)
+{
+	struct ipu6_fw_psys_process_ext *pm_ext;
+	u8 ps_ext_offset;
+
+	ps_ext_offset = ptr->process_extension_offset;
+	if (!ps_ext_offset)
+		return -EINVAL;
+
+	pm_ext = (struct ipu6_fw_psys_process_ext *)((u8 *)ptr + ps_ext_offset);
+
+	pm_ext->dev_chn_offset[offset] = value;
+
+	return 0;
+}
+
+int ipu6_fw_psys_set_proc_dfm_bitmap(struct ipu_fw_psys_process *ptr,
+				     u16 id, u32 bitmap,
+				     u32 active_bitmap)
+{
+	struct ipu6_fw_psys_process_ext *pm_ext;
+	u8 ps_ext_offset;
+
+	ps_ext_offset = ptr->process_extension_offset;
+	if (!ps_ext_offset)
+		return -EINVAL;
+
+	pm_ext = (struct ipu6_fw_psys_process_ext *)((u8 *)ptr + ps_ext_offset);
+
+	pm_ext->dfm_port_bitmap[id] = bitmap;
+	pm_ext->dfm_active_port_bitmap[id] = active_bitmap;
+
+	return 0;
+}
+
+int ipu6_fw_psys_set_process_ext_mem(struct ipu_fw_psys_process *ptr,
+				     u16 type_id, u16 mem_id, u16 offset)
+{
+	struct ipu6_fw_psys_process_ext *pm_ext;
+	u8 ps_ext_offset;
+
+	ps_ext_offset = ptr->process_extension_offset;
+	if (!ps_ext_offset)
+		return -EINVAL;
+
+	pm_ext = (struct ipu6_fw_psys_process_ext *)((u8 *)ptr + ps_ext_offset);
+
+	pm_ext->ext_mem_offset[type_id] = offset;
+	pm_ext->ext_mem_id[type_id] = mem_id;
+
+	return 0;
+}
+
+static struct ipu_fw_psys_program_manifest *
+get_program_manifest(const struct ipu_fw_psys_program_group_manifest *manifest,
+		     const unsigned int program_index)
+{
+	struct ipu_fw_psys_program_manifest *prg_manifest_base;
+	u8 *program_manifest = NULL;
+	u8 program_count;
+	unsigned int i;
+
+	program_count = manifest->program_count;
+
+	prg_manifest_base = (struct ipu_fw_psys_program_manifest *)
+		((char *)manifest + manifest->program_manifest_offset);
+	if (program_index < program_count) {
+		program_manifest = (u8 *)prg_manifest_base;
+		for (i = 0; i < program_index; i++)
+			program_manifest +=
+				((struct ipu_fw_psys_program_manifest *)
+				 program_manifest)->size;
+	}
+
+	return (struct ipu_fw_psys_program_manifest *)program_manifest;
+}
+
+int ipu6_fw_psys_get_program_manifest_by_process(
+	struct ipu_fw_generic_program_manifest *gen_pm,
+	const struct ipu_fw_psys_program_group_manifest *pg_manifest,
+	struct ipu_fw_psys_process *process)
+{
+	u32 program_id = process->program_idx;
+	struct ipu_fw_psys_program_manifest *pm;
+	struct ipu6_fw_psys_program_manifest_ext *pm_ext;
+
+	pm = get_program_manifest(pg_manifest, program_id);
+
+	if (!pm)
+		return -ENOENT;
+
+	if (pm->program_extension_offset) {
+		pm_ext = (struct ipu6_fw_psys_program_manifest_ext *)
+			((u8 *)pm + pm->program_extension_offset);
+
+		gen_pm->dev_chn_size = pm_ext->dev_chn_size;
+		gen_pm->dev_chn_offset = pm_ext->dev_chn_offset;
+		gen_pm->ext_mem_size = pm_ext->ext_mem_size;
+		gen_pm->ext_mem_offset = (u16 *)pm_ext->ext_mem_offset;
+		gen_pm->is_dfm_relocatable = pm_ext->is_dfm_relocatable;
+		gen_pm->dfm_port_bitmap = pm_ext->dfm_port_bitmap;
+		gen_pm->dfm_active_port_bitmap =
+			pm_ext->dfm_active_port_bitmap;
+	}
+
+	memcpy(gen_pm->cells, pm->cells, sizeof(pm->cells));
+	gen_pm->cell_id = pm->cells[0];
+	gen_pm->cell_type_id = pm->cell_type_id;
+
+	return 0;
+}
+
+#if defined(DEBUG) || defined(CONFIG_DYNAMIC_DEBUG) || \
+	(defined(CONFIG_DYNAMIC_DEBUG_CORE) && defined(DYNAMIC_DEBUG_MODULE))
+void ipu6_fw_psys_pg_dump(struct ipu_psys *psys,
+			  struct ipu_psys_kcmd *kcmd, const char *note)
+{
+	struct ipu_fw_psys_process_group *pg = kcmd->kpg->pg;
+	u32 pgid = pg->ID;
+	u8 processes = pg->process_count;
+	u16 *process_offset_table = (u16 *)((char *)pg + pg->processes_offset);
+	unsigned int p, chn, mem, mem_id;
+	unsigned int mem_type, max_mem_id, dev_chn;
+
+	if (ipu_ver == IPU_VER_6SE) {
+		mem_type = IPU6SE_FW_PSYS_N_DATA_MEM_TYPE_ID;
+		max_mem_id = IPU6SE_FW_PSYS_N_MEM_ID;
+		dev_chn = IPU6SE_FW_PSYS_N_DEV_CHN_ID;
+	} else if (ipu_ver == IPU_VER_6 || ipu_ver == IPU_VER_6EP ||
+		   ipu_ver == IPU_VER_6EP_MTL) {
+		mem_type = IPU6_FW_PSYS_N_DATA_MEM_TYPE_ID;
+		max_mem_id = IPU6_FW_PSYS_N_MEM_ID;
+		dev_chn = IPU6_FW_PSYS_N_DEV_CHN_ID;
+	} else {
+		WARN(1, "%s ipu_ver:[%u] is unsupported!\n", __func__, ipu_ver);
+		return;
+	}
+
+	dev_dbg(&psys->adev->dev, "%s %s pgid %i has %i processes:\n",
+		__func__, note, pgid, processes);
+
+	for (p = 0; p < processes; p++) {
+		struct ipu_fw_psys_process *process =
+		    (struct ipu_fw_psys_process *)
+		    ((char *)pg + process_offset_table[p]);
+		struct ipu6_fw_psys_process_ext *pm_ext =
+		    (struct ipu6_fw_psys_process_ext *)((u8 *)process
+		    + process->process_extension_offset);
+		dev_dbg(&psys->adev->dev, "\t process %i size=%u",
+			p, process->size);
+		if (!process->process_extension_offset)
+			continue;
+
+		for (mem = 0; mem < mem_type; mem++) {
+			mem_id = pm_ext->ext_mem_id[mem];
+			if (mem_id != max_mem_id)
+				dev_dbg(&psys->adev->dev,
+					"\t mem type %u id %d offset=0x%x",
+					mem, mem_id,
+					pm_ext->ext_mem_offset[mem]);
+		}
+		for (chn = 0; chn < dev_chn; chn++) {
+			if (pm_ext->dev_chn_offset[chn] != (u16)(-1))
+				dev_dbg(&psys->adev->dev,
+					"\t dev_chn[%u]=0x%x\n",
+					chn, pm_ext->dev_chn_offset[chn]);
+		}
+	}
+}
+#else
+void ipu6_fw_psys_pg_dump(struct ipu_psys *psys,
+			  struct ipu_psys_kcmd *kcmd, const char *note)
+{
+	if (ipu_ver == IPU_VER_6SE || ipu_ver == IPU_VER_6 ||
+	    ipu_ver == IPU_VER_6EP || ipu_ver == IPU_VER_6EP_MTL)
+		return;
+
+	WARN(1, "%s ipu_ver:[%u] is unsupported!\n", __func__, ipu_ver);
+}
+#endif
Index: b/drivers/media/pci/intel/ipu6/ipu6-isys-csi2.c
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu6/ipu6-isys-csi2.c
@@ -0,0 +1,654 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) 2020 - 2022 Intel Corporation
+
+#include <linux/delay.h>
+#include <linux/spinlock.h>
+#include <media/ipu-isys.h>
+#include "ipu.h"
+#include "ipu-buttress.h"
+#include "ipu-isys.h"
+#include "ipu-platform-buttress-regs.h"
+#include "ipu-platform-regs.h"
+#include "ipu-platform-isys-csi2-reg.h"
+#include "ipu6-isys-csi2.h"
+#include "ipu6-isys-phy.h"
+#include "ipu6-isys-dwc-phy.h"
+#include "ipu-isys-csi2.h"
+
+struct ipu6_csi2_error {
+	const char *error_string;
+	bool is_info_only;
+};
+
+struct ipu6_csi_irq_info_map {
+	u32 irq_error_mask;
+	u32 irq_num;
+	unsigned int irq_base;
+	unsigned int irq_base_ctrl2;
+	struct ipu6_csi2_error *errors;
+};
+
+/*
+ * Strings corresponding to CSI-2 receiver errors are here.
+ * Corresponding macros are defined in the header file.
+ */
+static struct ipu6_csi2_error dphy_rx_errors[] = {
+	{"Single packet header error corrected", true},
+	{"Multiple packet header errors detected", true},
+	{"Payload checksum (CRC) error", true},
+	{"Transfer FIFO overflow", false},
+	{"Reserved short packet data type detected", true},
+	{"Reserved long packet data type detected", true},
+	{"Incomplete long packet detected", false},
+	{"Frame sync error", false},
+	{"Line sync error", false},
+	{"DPHY recoverable synchronization error", true},
+	{"DPHY fatal error", false},
+	{"DPHY elastic FIFO overflow", false},
+	{"Inter-frame short packet discarded", true},
+	{"Inter-frame long packet discarded", true},
+	{"MIPI pktgen overflow", false},
+	{"MIPI pktgen data loss", false},
+	{"FIFO overflow", false},
+	{"Lane deskew", false},
+	{"SOT sync error", false},
+	{"HSIDLE detected", false}
+};
+
+static refcount_t phy_power_ref_count[IPU_ISYS_CSI_PHY_NUM];
+
+static int ipu6_csi2_phy_power_set(struct ipu_isys *isys,
+				   struct ipu_isys_csi2_config *cfg, bool on)
+{
+	int ret = 0;
+	unsigned int port, phy_id;
+	refcount_t *ref;
+	void __iomem *isys_base = isys->pdata->base;
+	unsigned int nr;
+
+	port = cfg->port;
+	phy_id = port / 4;
+	ref = &phy_power_ref_count[phy_id];
+	dev_dbg(&isys->adev->dev, "for phy %d port %d, lanes: %d\n",
+		phy_id, port, cfg->nlanes);
+
+	nr = (ipu_ver == IPU_VER_6 || ipu_ver == IPU_VER_6EP ||
+	      ipu_ver == IPU_VER_6EP_MTL) ?
+		IPU6_ISYS_CSI_PORT_NUM : IPU6SE_ISYS_CSI_PORT_NUM;
+
+	if (!isys_base || port >= nr) {
+		dev_warn(&isys->adev->dev, "invalid port ID %d\n", port);
+		return -EINVAL;
+	}
+
+	if (on) {
+		if (refcount_read(ref)) {
+			/* already up */
+			dev_warn(&isys->adev->dev, "for phy %d is already UP",
+				 phy_id);
+			refcount_inc(ref);
+			return 0;
+		}
+
+		ret = ipu6_isys_phy_powerup_ack(isys, phy_id);
+		if (ret)
+			return ret;
+
+		ipu6_isys_phy_reset(isys, phy_id, 0);
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA)
+		ipu6_isys_phy_common_init(isys, cfg);
+		ret = ipu6_isys_phy_config(isys, cfg);
+#else
+		ipu6_isys_phy_common_init(isys);
+
+		ret = ipu6_isys_phy_config(isys);
+#endif
+		if (ret)
+			return ret;
+
+		ipu6_isys_phy_reset(isys, phy_id, 1);
+		ret = ipu6_isys_phy_ready(isys, phy_id);
+		if (ret)
+			return ret;
+
+		refcount_set(ref, 1);
+		return 0;
+	}
+
+	/* power off process */
+	if (refcount_dec_and_test(ref))
+		ret = ipu6_isys_phy_powerdown_ack(isys, phy_id);
+	if (ret)
+		dev_err(&isys->adev->dev, "phy poweroff failed!");
+
+	return ret;
+}
+
+static int ipu6_csi2_dwc_phy_power_set(struct ipu_isys *isys,
+				       struct ipu_isys_csi2_config *cfg, bool on)
+{
+	int ret = 0;
+	u32 port;
+	u32 phy_id, primary, secondary;
+	u32 nlanes;
+	u32 mbps;
+	void __iomem *isys_base = isys->pdata->base;
+	u32 nr;
+	s64 link_freq;
+
+	port = cfg->port;
+
+	nr = (ipu_ver == IPU_VER_6 || ipu_ver == IPU_VER_6EP ||
+	      ipu_ver == IPU_VER_6EP_MTL) ?
+		IPU6_ISYS_CSI_PORT_NUM : IPU6SE_ISYS_CSI_PORT_NUM;
+
+	if (!isys_base || port >= nr) {
+		dev_warn(&isys->adev->dev, "invalid port ID %d\n", port);
+		return -EINVAL;
+	}
+
+	nlanes = cfg->nlanes;
+	/* only port a/c/e support 4 lanes */
+	if (nlanes == 4 && port % 2) {
+		dev_err(&isys->adev->dev, "invalid csi-port %u with %u lanes\n",
+			port, nlanes);
+		return -EINVAL;
+	}
+
+	ret = ipu_isys_csi2_get_link_freq(&isys->csi2[port], &link_freq);
+	if (ret) {
+		dev_err(&isys->adev->dev,
+			"get link freq failed(%d).\n", ret);
+		return ret;
+	}
+
+	do_div(link_freq, 1000000);
+	mbps = link_freq * 2;
+
+	phy_id = port;
+	primary = port & ~1;
+	secondary = primary + 1;
+	if (on) {
+		if (nlanes == 4) {
+			dev_dbg(&isys->adev->dev,
+				"config phy %u and %u in aggregation mode",
+				primary, secondary);
+
+			ipu6_isys_dwc_phy_reset(isys, primary);
+			ipu6_isys_dwc_phy_reset(isys, secondary);
+			ipu6_isys_dwc_phy_aggr_setup(isys, primary,
+						     secondary, mbps);
+
+			ret = ipu6_isys_dwc_phy_config(isys, primary, mbps);
+			if (ret)
+				return ret;
+			ret = ipu6_isys_dwc_phy_config(isys, secondary, mbps);
+			if (ret)
+				return ret;
+
+			ret = ipu6_isys_dwc_phy_powerup_ack(isys, primary);
+			if (ret)
+				return ret;
+			ret = ipu6_isys_dwc_phy_powerup_ack(isys, secondary);
+			if (ret)
+				return ret;
+
+			return 0;
+		}
+
+		dev_dbg(&isys->adev->dev,
+			"config phy %u with %u lanes in non-aggr mode",
+			phy_id, nlanes);
+
+		ipu6_isys_dwc_phy_reset(isys, phy_id);
+		ret = ipu6_isys_dwc_phy_config(isys, phy_id, mbps);
+		if (ret)
+			return ret;
+
+		ret = ipu6_isys_dwc_phy_powerup_ack(isys, phy_id);
+		if (ret)
+			return ret;
+
+		return 0;
+	}
+
+	if (nlanes == 4) {
+		dev_dbg(&isys->adev->dev,
+			"Powerdown phy %u and phy %u for port %u",
+			primary, secondary, port);
+		ipu6_isys_dwc_phy_reset(isys, secondary);
+		ipu6_isys_dwc_phy_reset(isys, primary);
+
+		return 0;
+	}
+
+	dev_dbg(&isys->adev->dev,
+		"Powerdown phy %u with %u lanes", phy_id, nlanes);
+
+	ipu6_isys_dwc_phy_reset(isys, phy_id);
+
+	return 0;
+}
+
+static void ipu6_isys_register_errors(struct ipu_isys_csi2 *csi2)
+{
+	u32 mask = 0;
+	u32 irq = readl(csi2->base + CSI_PORT_REG_BASE_IRQ_CSI +
+			CSI_PORT_REG_BASE_IRQ_STATUS_OFFSET);
+
+	mask = (ipu_ver == IPU_VER_6 || ipu_ver == IPU_VER_6EP ||
+		ipu_ver == IPU_VER_6EP_MTL) ?
+		IPU6_CSI_RX_ERROR_IRQ_MASK : IPU6SE_CSI_RX_ERROR_IRQ_MASK;
+
+	writel(irq & mask,
+	       csi2->base + CSI_PORT_REG_BASE_IRQ_CSI +
+	       CSI_PORT_REG_BASE_IRQ_CLEAR_OFFSET);
+	csi2->receiver_errors |= irq & mask;
+}
+
+void ipu_isys_csi2_error(struct ipu_isys_csi2 *csi2)
+{
+	struct ipu6_csi2_error *errors;
+	u32 status;
+	unsigned int i;
+
+	/* Register errors once more in case of error interrupts are disabled */
+	ipu6_isys_register_errors(csi2);
+	status = csi2->receiver_errors;
+	csi2->receiver_errors = 0;
+	errors = dphy_rx_errors;
+
+	for (i = 0; i < CSI_RX_NUM_ERRORS_IN_IRQ; i++) {
+		if (status & BIT(i))
+			dev_err_ratelimited(&csi2->isys->adev->dev,
+					    "csi2-%i error: %s\n",
+					    csi2->index,
+					    errors[i].error_string);
+	}
+}
+
+const unsigned int csi2_port_cfg[][3] = {
+	{0, 0, 0x1f}, /* no link */
+	{4, 0, 0x10}, /* x4 + x4 config */
+	{2, 0, 0x12}, /* x2 + x2 config */
+	{1, 0, 0x13}, /* x1 + x1 config */
+	{2, 1, 0x15}, /* x2x1 + x2x1 config */
+	{1, 1, 0x16}, /* x1x1 + x1x1 config */
+	{2, 2, 0x18}, /* x2x2 + x2x2 config */
+	{1, 2, 0x19}, /* x1x2 + x1x2 config */
+};
+
+const unsigned int phy_port_cfg[][4] = {
+	/* port, nlanes, bbindex, portcfg */
+	/* sip0 */
+	{0, 1, 0, 0x15},
+	{0, 2, 0, 0x15},
+	{0, 4, 0, 0x15},
+	{0, 4, 2, 0x22},
+	/* sip1 */
+	{2, 1, 4, 0x15},
+	{2, 2, 4, 0x15},
+	{2, 4, 4, 0x15},
+	{2, 4, 6, 0x22},
+};
+
+static int ipu_isys_csi2_phy_config_by_port(struct ipu_isys *isys,
+					    unsigned int port,
+					    unsigned int nlanes)
+{
+	void __iomem *base = isys->adev->isp->base;
+	u32 val, reg, i;
+	unsigned int bbnum;
+
+	dev_dbg(&isys->adev->dev, "%s port %u with %u lanes", __func__,
+		port, nlanes);
+
+	/* hard code for x2x2 + x2x2 with <1.5Gbps */
+	for (i = 0; i < IPU6SE_ISYS_PHY_BB_NUM; i++) {
+		/* cphy_dll_ovrd.crcdc_fsm_dlane0 = 13 */
+		reg = IPU6SE_ISYS_PHY_0_BASE + PHY_CPHY_DLL_OVRD(i);
+		val = readl(base + reg);
+		val |= 13 << 1;
+		/* val &= ~0x1; */
+		writel(val, base + reg);
+
+		/* cphy_rx_control1.en_crc1 = 1 */
+		reg = IPU6SE_ISYS_PHY_0_BASE + PHY_CPHY_RX_CONTROL1(i);
+		val = readl(base + reg);
+		val |= 0x1 << 31;
+		writel(val, base + reg);
+
+		/* dphy_cfg.reserved = 1
+		 * dphy_cfg.lden_from_dll_ovrd_0 = 1
+		 */
+		reg = IPU6SE_ISYS_PHY_0_BASE + PHY_DPHY_CFG(i);
+		val = readl(base + reg);
+		val |= 0x1 << 25;
+		val |= 0x1 << 26;
+		writel(val, base + reg);
+
+		/* cphy_dll_ovrd.lden_crcdc_fsm_dlane0 = 1 */
+		reg = IPU6SE_ISYS_PHY_0_BASE + PHY_CPHY_DLL_OVRD(i);
+		val = readl(base + reg);
+		val |= 1;
+		writel(val, base + reg);
+	}
+
+	/* bb afe config, use minimal channel loss */
+	for (i = 0; i < ARRAY_SIZE(phy_port_cfg); i++) {
+		if (phy_port_cfg[i][0] == port &&
+		    phy_port_cfg[i][1] == nlanes) {
+			bbnum = phy_port_cfg[i][2] / 2;
+			reg = IPU6SE_ISYS_PHY_0_BASE + PHY_BB_AFE_CONFIG(bbnum);
+			val = readl(base + reg);
+			val |= phy_port_cfg[i][3];
+			writel(val, base + reg);
+		}
+	}
+
+	return 0;
+}
+
+static void ipu_isys_csi2_rx_control(struct ipu_isys *isys)
+{
+	void __iomem *base = isys->adev->isp->base;
+	u32 val, reg;
+
+	/* lp11 release */
+	reg = CSI2_HUB_GPREG_SIP0_CSI_RX_A_CONTROL;
+	val = readl(base + reg);
+	val |= 0x1;
+	writel(0x1, base + CSI2_HUB_GPREG_SIP0_CSI_RX_A_CONTROL);
+
+	reg = CSI2_HUB_GPREG_SIP0_CSI_RX_B_CONTROL;
+	val = readl(base + reg);
+	val |= 0x1;
+	writel(0x1, base + CSI2_HUB_GPREG_SIP0_CSI_RX_B_CONTROL);
+
+	reg = CSI2_HUB_GPREG_SIP1_CSI_RX_A_CONTROL;
+	val = readl(base + reg);
+	val |= 0x1;
+	writel(0x1, base + CSI2_HUB_GPREG_SIP1_CSI_RX_A_CONTROL);
+
+	reg = CSI2_HUB_GPREG_SIP1_CSI_RX_B_CONTROL;
+	val = readl(base + reg);
+	val |= 0x1;
+	writel(0x1, base + CSI2_HUB_GPREG_SIP1_CSI_RX_B_CONTROL);
+}
+
+static int ipu_isys_csi2_set_port_cfg(struct v4l2_subdev *sd, unsigned int port,
+				      unsigned int nlanes)
+{
+	struct ipu_isys_csi2 *csi2 = to_ipu_isys_csi2(sd);
+	struct ipu_isys *isys = csi2->isys;
+	unsigned int sip = port / 2;
+	unsigned int index;
+
+	switch (nlanes) {
+	case 1:
+		index = 5;
+		break;
+	case 2:
+		index = 6;
+		break;
+	case 4:
+		index = 1;
+		break;
+	default:
+		dev_err(&isys->adev->dev, "lanes nr %u is unsupported\n",
+			nlanes);
+		return -EINVAL;
+	}
+
+	dev_dbg(&isys->adev->dev, "port config for port %u with %u lanes\n",
+		port, nlanes);
+	writel(csi2_port_cfg[index][2],
+	       isys->pdata->base + CSI2_HUB_GPREG_SIP_FB_PORT_CFG(sip));
+
+	return 0;
+}
+
+static void ipu_isys_csi2_set_timing(struct v4l2_subdev *sd,
+				     struct ipu_isys_csi2_timing timing,
+				     unsigned int port,
+				     unsigned int nlanes)
+{
+	u32 port_base;
+	void __iomem *reg;
+	struct ipu_isys_csi2 *csi2 = to_ipu_isys_csi2(sd);
+	struct ipu_isys *isys = csi2->isys;
+	unsigned int i;
+
+	port_base = (port % 2) ? CSI2_SIP_TOP_CSI_RX_PORT_BASE_1(port) :
+		CSI2_SIP_TOP_CSI_RX_PORT_BASE_0(port);
+
+	dev_dbg(&isys->adev->dev,
+		"set timing for port %u base 0x%x with %u lanes\n",
+		port, port_base, nlanes);
+
+	reg = isys->pdata->base + port_base;
+	reg += CSI2_SIP_TOP_CSI_RX_DLY_CNT_TERMEN_CLANE;
+
+	writel(timing.ctermen, reg);
+
+	reg = isys->pdata->base + port_base;
+	reg += CSI2_SIP_TOP_CSI_RX_DLY_CNT_SETTLE_CLANE;
+	writel(timing.csettle, reg);
+
+	for (i = 0; i < nlanes; i++) {
+		reg = isys->pdata->base + port_base;
+		reg += CSI2_SIP_TOP_CSI_RX_DLY_CNT_TERMEN_DLANE(i);
+		writel(timing.dtermen, reg);
+
+		reg = isys->pdata->base + port_base;
+		reg += CSI2_SIP_TOP_CSI_RX_DLY_CNT_SETTLE_DLANE(i);
+		writel(timing.dsettle, reg);
+	}
+}
+
+int ipu_isys_csi2_set_stream(struct v4l2_subdev *sd,
+			     struct ipu_isys_csi2_timing timing,
+			     unsigned int nlanes, int enable)
+{
+	struct ipu_isys_csi2 *csi2 = to_ipu_isys_csi2(sd);
+	struct ipu_isys *isys = csi2->isys;
+	struct ipu_isys_pipeline *ip =
+		container_of(media_entity_pipeline(&sd->entity),
+			     struct ipu_isys_pipeline, pipe);
+	struct ipu_isys_csi2_config *cfg =
+		v4l2_get_subdev_hostdata(media_entity_to_v4l2_subdev
+					 (ip->external->entity));
+	unsigned int port, port_max;
+	int ret = 0;
+	u32 mask = 0;
+	unsigned int i;
+
+	port = cfg->port;
+	dev_dbg(&isys->adev->dev, "for port %u with %u lanes\n", port, nlanes);
+
+	mask = (ipu_ver == IPU_VER_6 || ipu_ver == IPU_VER_6EP ||
+		ipu_ver == IPU_VER_6EP_MTL) ?
+		IPU6_CSI_RX_ERROR_IRQ_MASK : IPU6SE_CSI_RX_ERROR_IRQ_MASK;
+
+	if (!enable) {
+		writel(0, csi2->base + CSI_REG_CSI_FE_ENABLE);
+		writel(0, csi2->base + CSI_REG_PPI2CSI_ENABLE);
+
+		/* Disable interrupts */
+		writel(0,
+		       csi2->base + CSI_PORT_REG_BASE_IRQ_CSI +
+		       CSI_PORT_REG_BASE_IRQ_ENABLE_OFFSET);
+		writel(mask,
+		       csi2->base + CSI_PORT_REG_BASE_IRQ_CSI +
+		       CSI_PORT_REG_BASE_IRQ_CLEAR_OFFSET);
+		writel(0,
+		       csi2->base + CSI_PORT_REG_BASE_IRQ_CSI_SYNC +
+		       CSI_PORT_REG_BASE_IRQ_ENABLE_OFFSET);
+		writel(0xffffffff,
+		       csi2->base + CSI_PORT_REG_BASE_IRQ_CSI_SYNC +
+		       CSI_PORT_REG_BASE_IRQ_CLEAR_OFFSET);
+
+		/* power down phy */
+		if (ipu_ver == IPU_VER_6EP_MTL)
+			ret = ipu6_csi2_dwc_phy_power_set(isys, cfg, false);
+
+		if (ipu_ver == IPU_VER_6 || ipu_ver == IPU_VER_6EP)
+			ret = ipu6_csi2_phy_power_set(isys, cfg, false);
+
+		/* Disable clock */
+		writel(0, isys->pdata->base +
+		       CSI_REG_HUB_FW_ACCESS_PORT(port));
+		writel(0, isys->pdata->base +
+		       CSI_REG_HUB_DRV_ACCESS_PORT(port));
+
+		return ret;
+	}
+
+	/* reset port reset */
+	writel(0x1, csi2->base + CSI_REG_PORT_GPREG_SRST);
+	usleep_range(100, 200);
+	writel(0x0, csi2->base + CSI_REG_PORT_GPREG_SRST);
+
+	/* We need enable clock for all ports for MTL */
+	port_max = (ipu_ver == IPU_VER_6 || ipu_ver == IPU_VER_6EP ||
+		    ipu_ver == IPU_VER_6EP_MTL) ?
+		IPU6_ISYS_CSI_PORT_NUM : IPU6SE_ISYS_CSI_PORT_NUM;
+
+	/* Enable port clock */
+	for (i = 0; i < port_max; i++) {
+		writel(1, isys->pdata->base + CSI_REG_HUB_DRV_ACCESS_PORT(i));
+		if (ipu_ver == IPU_VER_6EP_MTL)
+			writel(1, isys->pdata->base +
+			       IPU6V6_CSI_REG_HUB_FW_ACCESS_PORT(i));
+		else
+			writel(1, isys->pdata->base +
+			       CSI_REG_HUB_FW_ACCESS_PORT(i));
+	}
+
+	/* enable all error related irq */
+	writel(mask,
+	       csi2->base + CSI_PORT_REG_BASE_IRQ_CSI +
+	       CSI_PORT_REG_BASE_IRQ_STATUS_OFFSET);
+	writel(mask,
+	       csi2->base + CSI_PORT_REG_BASE_IRQ_CSI +
+	       CSI_PORT_REG_BASE_IRQ_MASK_OFFSET);
+	writel(mask,
+	       csi2->base + CSI_PORT_REG_BASE_IRQ_CSI +
+	       CSI_PORT_REG_BASE_IRQ_CLEAR_OFFSET);
+	writel(mask,
+	       csi2->base + CSI_PORT_REG_BASE_IRQ_CSI +
+	       CSI_PORT_REG_BASE_IRQ_LEVEL_NOT_PULSE_OFFSET);
+	writel(mask,
+	       csi2->base + CSI_PORT_REG_BASE_IRQ_CSI +
+	       CSI_PORT_REG_BASE_IRQ_ENABLE_OFFSET);
+
+	/* To save CPU wakeups, disable CSI SOF/EOF irq */
+	writel(0xffffffff, csi2->base + CSI_PORT_REG_BASE_IRQ_CSI_SYNC +
+	       CSI_PORT_REG_BASE_IRQ_STATUS_OFFSET);
+	writel(0, csi2->base + CSI_PORT_REG_BASE_IRQ_CSI_SYNC +
+	       CSI_PORT_REG_BASE_IRQ_MASK_OFFSET);
+	writel(0xffffffff, csi2->base + CSI_PORT_REG_BASE_IRQ_CSI_SYNC +
+	       CSI_PORT_REG_BASE_IRQ_CLEAR_OFFSET);
+	writel(0, csi2->base + CSI_PORT_REG_BASE_IRQ_CSI_SYNC +
+	       CSI_PORT_REG_BASE_IRQ_LEVEL_NOT_PULSE_OFFSET);
+	writel(0xffffffff, csi2->base + CSI_PORT_REG_BASE_IRQ_CSI_SYNC +
+	       CSI_PORT_REG_BASE_IRQ_ENABLE_OFFSET);
+
+	/* Configure FE/PPI2CSI and enable FE/ PPI2CSI */
+	writel(0, csi2->base + CSI_REG_CSI_FE_MODE);
+	writel(CSI_SENSOR_INPUT, csi2->base + CSI_REG_CSI_FE_MUX_CTRL);
+	writel(CSI_CNTR_SENSOR_LINE_ID | CSI_CNTR_SENSOR_FRAME_ID,
+	       csi2->base + CSI_REG_CSI_FE_SYNC_CNTR_SEL);
+	writel(((nlanes - 1) <<
+		PPI_INTF_CONFIG_NOF_ENABLED_DATALANES_SHIFT) |
+	       (0 << PPI_INTF_CONFIG_RX_AUTO_CLKGATING_SHIFT),
+	       csi2->base + CSI_REG_PPI2CSI_CONFIG_PPI_INTF);
+	writel(0x06, csi2->base + CSI_REG_PPI2CSI_CONFIG_CSI_FEATURE);
+	writel(1, csi2->base + CSI_REG_PPI2CSI_ENABLE);
+	writel(1, csi2->base + CSI_REG_CSI_FE_ENABLE);
+
+	if (ipu_ver == IPU_VER_6 || ipu_ver == IPU_VER_6EP) {
+		/* Enable DPHY power */
+		ret = ipu6_csi2_phy_power_set(isys, cfg, true);
+		if (ret) {
+			dev_err(&isys->adev->dev,
+				"CSI-%d PHY power up failed %d\n",
+				cfg->port, ret);
+			return ret;
+		}
+	} else if (ipu_ver == IPU_VER_6EP_MTL) {
+		/* Enable DWC DPHY power */
+		ret = ipu6_csi2_dwc_phy_power_set(isys, cfg, true);
+		if (ret) {
+			dev_err(&isys->adev->dev,
+				"CSI-%d DWC-PHY power up failed %d\n",
+				cfg->port, ret);
+			return ret;
+		}
+	} else if (ipu_ver == IPU_VER_6SE) {
+		ipu_isys_csi2_phy_config_by_port(isys, port, nlanes);
+
+		/* 9'b00010.1000 for 400Mhz isys freqency */
+		writel(0x28,
+		       isys->pdata->base + CSI2_HUB_GPREG_DPHY_TIMER_INCR);
+		/* set port cfg and rx timing */
+		ipu_isys_csi2_set_timing(sd, timing, port, nlanes);
+
+		ret = ipu_isys_csi2_set_port_cfg(sd, port, nlanes);
+		if (ret)
+			return ret;
+
+		ipu_isys_csi2_rx_control(isys);
+	}
+
+	return 0;
+}
+
+void ipu_isys_csi2_isr(struct ipu_isys_csi2 *csi2)
+{
+	u32 status;
+	unsigned int i;
+
+	ipu6_isys_register_errors(csi2);
+
+	status = readl(csi2->base + CSI_PORT_REG_BASE_IRQ_CSI_SYNC +
+		       CSI_PORT_REG_BASE_IRQ_STATUS_OFFSET);
+
+	writel(status, csi2->base + CSI_PORT_REG_BASE_IRQ_CSI_SYNC +
+	       CSI_PORT_REG_BASE_IRQ_CLEAR_OFFSET);
+
+	for (i = 0; i < NR_OF_CSI2_VC; i++) {
+		if (status & IPU_CSI_RX_IRQ_FS_VC(i))
+			ipu_isys_csi2_sof_event(csi2, i);
+
+		if (status & IPU_CSI_RX_IRQ_FE_VC(i))
+			ipu_isys_csi2_eof_event(csi2, i);
+	}
+}
+
+unsigned int ipu_isys_csi2_get_current_field(struct ipu_isys_pipeline *ip,
+					     unsigned int *timestamp)
+{
+	struct ipu_isys_video *av = container_of(ip, struct ipu_isys_video, ip);
+	struct ipu_isys *isys = av->isys;
+	unsigned int field = V4L2_FIELD_TOP;
+
+	struct ipu_isys_buffer *short_packet_ib =
+		list_last_entry(&ip->short_packet_active,
+				struct ipu_isys_buffer, head);
+	struct ipu_isys_private_buffer *pb =
+		ipu_isys_buffer_to_private_buffer(short_packet_ib);
+	struct ipu_isys_mipi_packet_header *ph =
+		(struct ipu_isys_mipi_packet_header *)
+		pb->buffer;
+
+	/* Check if the first SOF packet is received. */
+	if ((ph->dtype & IPU_ISYS_SHORT_PACKET_DTYPE_MASK) != 0)
+		dev_warn(&isys->adev->dev, "First short packet is not SOF.\n");
+	field = (ph->word_count % 2) ? V4L2_FIELD_TOP : V4L2_FIELD_BOTTOM;
+	dev_dbg(&isys->adev->dev,
+		"Interlaced field ready. frame_num = %d field = %d\n",
+		ph->word_count, field);
+
+	return field;
+}
Index: b/drivers/media/pci/intel/ipu6/ipu6-isys-csi2.h
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu6/ipu6-isys-csi2.h
@@ -0,0 +1,14 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2020 Intel Corporation */
+
+#ifndef IPU6_ISYS_CSI2_H
+#define IPU6_ISYS_CSI2_H
+
+struct ipu_isys_csi2_timing;
+struct ipu_isys_csi2;
+struct ipu_isys_pipeline;
+struct v4l2_subdev;
+
+#define IPU_ISYS_SHORT_PACKET_DTYPE_MASK	0x3f
+
+#endif /* IPU6_ISYS_CSI2_H */
Index: b/drivers/media/pci/intel/ipu6/ipu6-isys-dwc-phy.c
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu6/ipu6-isys-dwc-phy.c
@@ -0,0 +1,465 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2013 - 2020 Intel Corporation
+ */
+
+#include <linux/delay.h>
+#include <linux/iopoll.h>
+#include <media/ipu-isys.h>
+#include <media/v4l2-device.h>
+#include "ipu.h"
+#include "ipu-buttress.h"
+#include "ipu-isys.h"
+#include "ipu-isys-csi2.h"
+#include "ipu-platform-regs.h"
+#include "ipu-platform-isys-csi2-reg.h"
+#include "ipu6-isys-csi2.h"
+#include "ipu6-isys-dwc-phy.h"
+
+#define IPU_DWC_DPHY_MAX_NUM			(6)
+#define IPU_DWC_DPHY_BASE(i)			(0x238038 + 0x34 * (i))
+#define IPU_DWC_DPHY_RSTZ			(0x00)
+#define IPU_DWC_DPHY_SHUTDOWNZ			(0x04)
+#define IPU_DWC_DPHY_HSFREQRANGE		(0x08)
+#define IPU_DWC_DPHY_CFGCLKFREQRANGE		(0x0c)
+#define IPU_DWC_DPHY_TEST_IFC_ACCESS_MODE	(0x10)
+#define IPU_DWC_DPHY_TEST_IFC_REQ		(0x14)
+#define IPU_DWC_DPHY_TEST_IFC_REQ_COMPLETION	(0x18)
+#define IPU_DWC_DPHY_TEST_IFC_CTRL0		(0x1c)
+#define IPU_DWC_DPHY_TEST_IFC_CTRL1		(0x20)
+#define IPU_DWC_DPHY_TEST_IFC_CTRL1_RO		(0x24)
+#define IPU_DWC_DPHY_DFT_CTRL0			(0x28)
+#define IPU_DWC_DPHY_DFT_CTRL1			(0x2c)
+#define IPU_DWC_DPHY_DFT_CTRL2			(0x30)
+
+#define PPI_DATAWIDTH_8BIT		0
+#define PPI_DATAWIDTH_16BIT		1
+
+/*
+ * test IFC request definition:
+ * - req: 0 for read, 1 for write
+ * - 12 bits address
+ * - 8bits data (will ignore for read)
+ * --24----16------4-----0
+ * --|-data-|-addr-|-req-|
+ */
+#define IFC_REQ(req, addr, data) ((data) << 16 | (addr) << 4 | (req))
+
+enum req_type {
+	TEST_IFC_REQ_READ = 0,
+	TEST_IFC_REQ_WRITE = 1,
+	TEST_IFC_REQ_RESET = 2,
+};
+
+enum access_mode {
+	TEST_IFC_ACCESS_MODE_FSM = 0,
+	/* backup mode for DFT/workaround etc */
+	TEST_IFC_ACCESS_MODE_IFC_CTL = 1,
+};
+
+enum phy_fsm_state {
+	PHY_FSM_STATE_POWERON = 0,
+	PHY_FSM_STATE_BGPON = 1,
+	PHY_FSM_STATE_CAL_TYPE = 2,
+	PHY_FSM_STATE_BURNIN_CAL = 3,
+	PHY_FSM_STATE_TERMCAL = 4,
+	PHY_FSM_STATE_OFFSETCAL = 5,
+	PHY_FSM_STATE_OFFSET_LANE = 6,
+	PHY_FSM_STATE_IDLE = 7,
+	PHY_FSM_STATE_ULP = 8,
+	PHY_FSM_STATE_DDLTUNNING = 9,
+	PHY_FSM_STATE_SKEW_BACKWARD = 10,
+	PHY_FSM_STATE_INVALID,
+};
+
+static void dwc_dphy_write(struct ipu_isys *isys, u32 phy_id, u32 addr,
+			   u32 data)
+{
+	void __iomem *isys_base = isys->pdata->base;
+	void __iomem *base = isys_base + IPU_DWC_DPHY_BASE(phy_id);
+
+	dev_dbg(&isys->adev->dev, "write: reg 0x%lx = data 0x%x",
+		base + addr - isys_base, data);
+	writel(data, base + addr);
+}
+
+static u32 dwc_dphy_read(struct ipu_isys *isys, u32 phy_id, u32 addr)
+{
+	u32 data;
+	void __iomem *isys_base = isys->pdata->base;
+	void __iomem *base = isys_base + IPU_DWC_DPHY_BASE(phy_id);
+
+	data = readl(base + addr);
+	dev_dbg(&isys->adev->dev, "read: reg 0x%lx = data 0x%x",
+		base + addr - isys_base, data);
+
+	return data;
+}
+
+static void dwc_dphy_write_mask(struct ipu_isys *isys, u32 phy_id, u32 addr,
+				u32 data, u8 shift, u8 width)
+{
+	u32 temp;
+	u32 mask;
+
+	mask = (1 << width) - 1;
+	temp = dwc_dphy_read(isys, phy_id, addr);
+	temp &= ~(mask << shift);
+	temp |= (data & mask) << shift;
+	dwc_dphy_write(isys, phy_id, addr, temp);
+}
+
+static u32 __maybe_unused dwc_dphy_read_mask(struct ipu_isys *isys, u32 phy_id,
+					     u32 addr, u8 shift,  u8 width)
+{
+	return (dwc_dphy_read(isys, phy_id, addr) >> shift) & ((1 << width) - 1);
+}
+
+#define DWC_DPHY_TIMEOUT (5000000)
+static int dwc_dphy_ifc_read(struct ipu_isys *isys, u32 phy_id, u32 addr, u32 *val)
+{
+	int rval;
+	u32 completion;
+	void __iomem *isys_base = isys->pdata->base;
+	void __iomem *base = isys_base + IPU_DWC_DPHY_BASE(phy_id);
+	void __iomem *reg;
+	u32 timeout = DWC_DPHY_TIMEOUT;
+
+	dwc_dphy_write(isys, phy_id, IPU_DWC_DPHY_TEST_IFC_REQ,
+		       IFC_REQ(TEST_IFC_REQ_READ, addr, 0));
+	reg = base + IPU_DWC_DPHY_TEST_IFC_REQ_COMPLETION;
+	rval = readl_poll_timeout(reg, completion, !(completion & BIT(0)),
+				  10, timeout);
+	if (rval) {
+		dev_err(&isys->adev->dev,
+			"%s: ifc request read timeout!", __func__);
+		return rval;
+	}
+
+	*val = completion >> 8 & 0xff;
+	dev_dbg(&isys->adev->dev, "ifc read 0x%x = 0x%x", addr, *val);
+
+	return 0;
+}
+
+static int dwc_dphy_ifc_write(struct ipu_isys *isys, u32 phy_id, u32 addr, u32 data)
+{
+	int rval;
+	u32 completion;
+	void __iomem *reg;
+	void __iomem *isys_base = isys->pdata->base;
+	void __iomem *base = isys_base + IPU_DWC_DPHY_BASE(phy_id);
+	u32 timeout = DWC_DPHY_TIMEOUT;
+
+	dwc_dphy_write(isys, phy_id, IPU_DWC_DPHY_TEST_IFC_REQ,
+		       IFC_REQ(TEST_IFC_REQ_WRITE, addr, data));
+	completion = readl(base + IPU_DWC_DPHY_TEST_IFC_REQ_COMPLETION);
+	reg = base + IPU_DWC_DPHY_TEST_IFC_REQ_COMPLETION;
+	rval = readl_poll_timeout(reg, completion, !(completion & BIT(0)),
+				  10, timeout);
+	if (rval) {
+		dev_err(&isys->adev->dev,
+			"%s: ifc request write timeout", __func__);
+		return rval;
+	}
+
+	return 0;
+}
+
+static void dwc_dphy_ifc_write_mask(struct ipu_isys *isys, u32 phy_id, u32 addr,
+				    u32 data, u8 shift, u8 width)
+{
+	int rval;
+	u32 temp, mask;
+
+	rval = dwc_dphy_ifc_read(isys, phy_id, addr, &temp);
+	if (rval) {
+		dev_err(&isys->adev->dev,
+			"dphy proxy read failed with %d", rval);
+		return;
+	}
+
+	mask = (1 << width) - 1;
+	temp &= ~(mask << shift);
+	temp |= (data & mask) << shift;
+	rval = dwc_dphy_ifc_write(isys, phy_id, addr, temp);
+	if (rval)
+		dev_err(&isys->adev->dev, "dphy proxy write failed(%d)", rval);
+}
+
+static u32 dwc_dphy_ifc_read_mask(struct ipu_isys *isys, u32 phy_id, u32 addr,
+				  u8 shift, u8 width)
+{
+	int rval;
+	u32 val;
+
+	rval = dwc_dphy_ifc_read(isys, phy_id, addr, &val);
+	if (rval) {
+		dev_err(&isys->adev->dev, "dphy proxy read failed with %d", rval);
+		return 0;
+	}
+
+	return ((val >> shift) & ((1 << width) - 1));
+}
+
+static int dwc_dphy_pwr_up(struct ipu_isys *isys, u32 phy_id)
+{
+	u32 fsm_state;
+	int ret;
+	u32 timeout = DWC_DPHY_TIMEOUT;
+
+	dwc_dphy_write(isys, phy_id, IPU_DWC_DPHY_RSTZ, 1);
+	usleep_range(10, 20);
+	dwc_dphy_write(isys, phy_id, IPU_DWC_DPHY_SHUTDOWNZ, 1);
+
+	ret = read_poll_timeout(dwc_dphy_ifc_read_mask, fsm_state,
+				(fsm_state == PHY_FSM_STATE_IDLE ||
+				 fsm_state == PHY_FSM_STATE_ULP), 100, timeout,
+				false, isys, phy_id, 0x1e, 0, 4);
+
+	if (ret) {
+		dev_err(&isys->adev->dev, "DPHY%d power up failed, state 0x%x",
+			phy_id, fsm_state);
+		return ret;
+	}
+
+	return 0;
+}
+
+struct dwc_dphy_freq_range {
+	u8 hsfreq;
+	u32 min;
+	u32 max;
+	u32 default_mbps;
+	u32 osc_freq_target;
+};
+
+#define DPHY_FREQ_RANGE_NUM		(63)
+#define DPHY_FREQ_RANGE_INVALID_INDEX	(0xff)
+const struct dwc_dphy_freq_range freqranges[DPHY_FREQ_RANGE_NUM] = {
+	{0x00,	80,	97,	80,	448},
+	{0x10,	80,	107,	90,	448},
+	{0x20,	84,	118,	100,	448},
+	{0x30,	93,	128,	110,	448},
+	{0x01,	103,	139,	120,	448},
+	{0x11,	112,	149,	130,	448},
+	{0x21,	122,	160,	140,	448},
+	{0x31,	131,	170,	150,	448},
+	{0x02,	141,	181,	160,	448},
+	{0x12,	150,	191,	170,	448},
+	{0x22,	160,	202,	180,	448},
+	{0x32,	169,	212,	190,	448},
+	{0x03,	183,	228,	205,	448},
+	{0x13,	198,	244,	220,	448},
+	{0x23,	212,	259,	235,	448},
+	{0x33,	226,	275,	250,	448},
+	{0x04,	250,	301,	275,	448},
+	{0x14,	274,	328,	300,	448},
+	{0x25,	297,	354,	325,	448},
+	{0x35,	321,	380,	350,	448},
+	{0x05,	369,	433,	400,	448},
+	{0x16,	416,	485,	450,	448},
+	{0x26,	464,	538,	500,	448},
+	{0x37,	511,	590,	550,	448},
+	{0x07,	559,	643,	600,	448},
+	{0x18,	606,	695,	650,	448},
+	{0x28,	654,	748,	700,	448},
+	{0x39,	701,	800,	750,	448},
+	{0x09,	749,	853,	800,	448},
+	{0x19,	796,	905,	850,	448},
+	{0x29,	844,	958,	900,	448},
+	{0x3a,	891,	1010,	950,	448},
+	{0x0a,	939,	1063,	1000,	448},
+	{0x1a,	986,	1115,	1050,	448},
+	{0x2a,	1034,	1168,	1100,	448},
+	{0x3b,	1081,	1220,	1150,	448},
+	{0x0b,	1129,	1273,	1200,	448},
+	{0x1b,	1176,	1325,	1250,	448},
+	{0x2b,	1224,	1378,	1300,	448},
+	{0x3c,	1271,	1430,	1350,	448},
+	{0x0c,	1319,	1483,	1400,	448},
+	{0x1c,	1366,	1535,	1450,	448},
+	{0x2c,	1414,	1588,	1500,	448},
+	{0x3d,	1461,	1640,	1550,	278},
+	{0x0d,	1509,	1693,	1600,	287},
+	{0x1d,	1556,	1745,	1650,	296},
+	{0x2e,	1604,	1798,	1700,	305},
+	{0x3e,	1651,	1850,	1750,	314},
+	{0x0e,	1699,	1903,	1800,	323},
+	{0x1e,	1746,	1955,	1850,	331},
+	{0x2f,	1794,	2008,	1900,	340},
+	{0x3f,	1841,	2060,	1950,	349},
+	{0x0f,	1889,	2113,	2000,	358},
+	{0x40,	1936,	2165,	2050,	367},
+	{0x41,	1984,	2218,	2100,	376},
+	{0x42,	2031,	2270,	2150,	385},
+	{0x43,	2079,	2323,	2200,	394},
+	{0x44,	2126,	2375,	2250,	403},
+	{0x45,	2174,	2428,	2300,	412},
+	{0x46,	2221,	2480,	2350,	421},
+	{0x47,	2269,	2500,	2400,	430},
+	{0x48,	2316,	2500,	2450,	439},
+	{0x49,	2364,	2500,	2500,	448},
+};
+
+static u32 get_hsfreq_by_mbps(u32 mbps)
+{
+	int i;
+
+	for (i = DPHY_FREQ_RANGE_NUM - 1; i >= 0; i--) {
+		if (freqranges[i].default_mbps == mbps ||
+		    (mbps >= freqranges[i].min && mbps <= freqranges[i].max))
+			return i;
+	}
+
+	return DPHY_FREQ_RANGE_INVALID_INDEX;
+}
+
+int ipu6_isys_dwc_phy_config(struct ipu_isys *isys, u32 phy_id, u32 mbps)
+{
+	u32 index;
+	u32 osc_freq_target;
+	u32 cfg_clk_freqrange;
+	struct ipu_bus_device *adev = to_ipu_bus_device(&isys->adev->dev);
+	struct ipu_device *isp = adev->isp;
+
+	dev_dbg(&isys->adev->dev, "config phy %u with %u mbps", phy_id, mbps);
+
+	index = get_hsfreq_by_mbps(mbps);
+	if (index == DPHY_FREQ_RANGE_INVALID_INDEX) {
+		dev_err(&isys->adev->dev, "link freq not found for mbps %u",
+			mbps);
+		return -EINVAL;
+	}
+
+	dwc_dphy_write_mask(isys, phy_id, IPU_DWC_DPHY_HSFREQRANGE,
+			    freqranges[index].hsfreq, 0, 7);
+
+	/* Force termination Calibration */
+	if (isys->phy_termcal_val) {
+		dwc_dphy_ifc_write_mask(isys, phy_id, 0x20a, 0x1, 0, 1);
+		dwc_dphy_ifc_write_mask(isys, phy_id, 0x209, 0x3, 0, 2);
+		dwc_dphy_ifc_write_mask(isys, phy_id, 0x209,
+					isys->phy_termcal_val, 4, 4);
+	}
+
+	/*
+	 * Enable override to configure the DDL target oscillation
+	 * frequency on bit 0 of register 0xe4
+	 */
+	dwc_dphy_ifc_write_mask(isys, phy_id, 0xe4, 0x1, 0, 1);
+	/*
+	 * configure registers 0xe2, 0xe3 with the
+	 * appropriate DDL target oscillation frequency
+	 * 0x1cc(460)
+	 */
+	osc_freq_target = freqranges[index].osc_freq_target;
+	dwc_dphy_ifc_write_mask(isys, phy_id, 0xe2,
+				osc_freq_target & 0xff, 0, 8);
+	dwc_dphy_ifc_write_mask(isys, phy_id, 0xe3,
+				(osc_freq_target >> 8) & 0xf, 0, 4);
+
+	if (mbps < 1500) {
+		/* deskew_polarity_rw, for < 1.5Gbps */
+		dwc_dphy_ifc_write_mask(isys, phy_id, 0x8, 0x1, 5, 1);
+	}
+
+	/*
+	 * Set cfgclkfreqrange[5:0] = round[(Fcfg_clk(MHz)-17)*4]
+	 * (38.4 - 17) * 4 = ~85 (0x55)
+	 */
+	cfg_clk_freqrange = (isp->buttress.ref_clk - 170) * 4 / 10;
+	dev_dbg(&isys->adev->dev, "ref_clk = %u clf_freqrange = %u",
+		isp->buttress.ref_clk, cfg_clk_freqrange);
+	dwc_dphy_write_mask(isys, phy_id, IPU_DWC_DPHY_CFGCLKFREQRANGE,
+			    cfg_clk_freqrange, 0, 8);
+
+	/*
+	 * run without external reference resistor for 2Gbps
+	 * dwc_dphy_ifc_write_mask(isys, phy_id, 0x4, 0x0, 4, 1);
+	 */
+
+	dwc_dphy_write_mask(isys, phy_id, IPU_DWC_DPHY_DFT_CTRL2, 0x1, 4, 1);
+	dwc_dphy_write_mask(isys, phy_id, IPU_DWC_DPHY_DFT_CTRL2, 0x1, 8, 1);
+
+	return 0;
+}
+
+void ipu6_isys_dwc_phy_aggr_setup(struct ipu_isys *isys, u32 master, u32 slave,
+				  u32 mbps)
+{
+	/* Config mastermacro */
+	dwc_dphy_ifc_write_mask(isys, master, 0x133, 0x1, 0, 1);
+	dwc_dphy_ifc_write_mask(isys, slave, 0x133, 0x0, 0, 1);
+
+	/* Config master PHY clk lane to drive long channel clk */
+	dwc_dphy_ifc_write_mask(isys, master, 0x307, 0x1, 2, 1);
+	dwc_dphy_ifc_write_mask(isys, slave, 0x307, 0x0, 2, 1);
+
+	/* Config both PHYs data lanes to get clk from long channel */
+	dwc_dphy_ifc_write_mask(isys, master, 0x508, 0x1, 5, 1);
+	dwc_dphy_ifc_write_mask(isys, slave, 0x508, 0x1, 5, 1);
+	dwc_dphy_ifc_write_mask(isys, master, 0x708, 0x1, 5, 1);
+	dwc_dphy_ifc_write_mask(isys, slave, 0x708, 0x1, 5, 1);
+
+	/* Config slave PHY clk lane to bypass long channel clk to DDR clk */
+	dwc_dphy_ifc_write_mask(isys, master, 0x308, 0x0, 3, 1);
+	dwc_dphy_ifc_write_mask(isys, slave, 0x308, 0x1, 3, 1);
+
+	/* Override slave PHY clk lane enable (DPHYRXCLK_CLL_demux module) */
+	dwc_dphy_ifc_write_mask(isys, slave, 0xe0, 0x3, 0, 2);
+
+	/* Override slave PHY DDR clk lane enable (DPHYHSRX_div124 module) */
+	dwc_dphy_ifc_write_mask(isys, slave, 0xe1, 0x1, 1, 1);
+	dwc_dphy_ifc_write_mask(isys, slave, 0x307, 0x1, 3, 1);
+
+	/* Turn off slave PHY LP-RX clk lane */
+	dwc_dphy_ifc_write_mask(isys, slave, 0x304, 0x1, 7, 1);
+	dwc_dphy_ifc_write_mask(isys, slave, 0x305, 0xa, 0, 5);
+}
+
+#define PHY_E	(4)
+int ipu6_isys_dwc_phy_powerup_ack(struct ipu_isys *isys, u32 phy_id)
+{
+	int rval;
+	u32 rescal_done;
+
+	rval = dwc_dphy_pwr_up(isys, phy_id);
+	if (rval != 0) {
+		dev_err(&isys->adev->dev, "dphy%u power up failed(%d)", phy_id,
+			rval);
+		return rval;
+	}
+
+	/* reset forcerxmode */
+	dwc_dphy_write_mask(isys, phy_id, IPU_DWC_DPHY_DFT_CTRL2, 0, 4, 1);
+	dwc_dphy_write_mask(isys, phy_id, IPU_DWC_DPHY_DFT_CTRL2, 0, 8, 1);
+
+	dev_dbg(&isys->adev->dev, "phy %u is ready!", phy_id);
+
+	if (phy_id != PHY_E || isys->phy_termcal_val)
+		return 0;
+
+	usleep_range(100, 200);
+	rescal_done = dwc_dphy_ifc_read_mask(isys, phy_id, 0x221, 7, 1);
+	if (rescal_done) {
+		isys->phy_termcal_val = dwc_dphy_ifc_read_mask(isys, phy_id,
+							       0x220, 2, 4);
+		dev_dbg(&isys->adev->dev, "termcal done with value = %u",
+			isys->phy_termcal_val);
+	}
+
+	return 0;
+}
+
+void ipu6_isys_dwc_phy_reset(struct ipu_isys *isys, u32 phy_id)
+{
+	dev_dbg(&isys->adev->dev, "Reset phy %u", phy_id);
+
+	dwc_dphy_write(isys, phy_id, IPU_DWC_DPHY_SHUTDOWNZ, 0);
+	dwc_dphy_write(isys, phy_id, IPU_DWC_DPHY_RSTZ, 0);
+	dwc_dphy_write(isys, phy_id, IPU_DWC_DPHY_TEST_IFC_ACCESS_MODE,
+		       TEST_IFC_ACCESS_MODE_FSM);
+	dwc_dphy_write(isys, phy_id, IPU_DWC_DPHY_TEST_IFC_REQ,
+		       TEST_IFC_REQ_RESET);
+}
Index: b/drivers/media/pci/intel/ipu6/ipu6-isys-dwc-phy.h
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu6/ipu6-isys-dwc-phy.h
@@ -0,0 +1,15 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2013 - 2022 Intel Corporation
+ */
+
+#ifndef IPU6_ISYS_DWC_PHY_H
+#define IPU6_ISYS_DWC_PHY_H
+
+int ipu6_isys_dwc_phy_powerup_ack(struct ipu_isys *isys, u32 phy_id);
+int ipu6_isys_dwc_phy_config(struct ipu_isys *isys, u32 phy_id, u32 mbps);
+int ipu6_isys_dwc_phy_termcal_rext(struct ipu_isys *isys, u32 mbps);
+void ipu6_isys_dwc_phy_reset(struct ipu_isys *isys, u32 phy_id);
+void ipu6_isys_dwc_phy_aggr_setup(struct ipu_isys *isys, u32 master, u32 slave,
+				  u32 mbps);
+#endif
Index: b/drivers/media/pci/intel/ipu6/ipu6-isys-gpc.c
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu6/ipu6-isys-gpc.c
@@ -0,0 +1,203 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) 2020 Intel Corporation
+
+#ifdef CONFIG_DEBUG_FS
+#include <linux/debugfs.h>
+#include <linux/pm_runtime.h>
+
+#include "ipu-isys.h"
+#include "ipu-platform-regs.h"
+
+#define IPU_ISYS_GPC_NUM		16
+
+#ifndef CONFIG_PM
+#define pm_runtime_get_sync(d)		0
+#define pm_runtime_put(d)		0
+#endif
+
+struct ipu_isys_gpc {
+	bool enable;
+	unsigned int route;
+	unsigned int source;
+	unsigned int sense;
+	unsigned int gpcindex;
+	void *prit;
+};
+
+struct ipu_isys_gpcs {
+	bool gpc_enable;
+	struct ipu_isys_gpc gpc[IPU_ISYS_GPC_NUM];
+	void *prit;
+};
+
+static int ipu6_isys_gpc_global_enable_get(void *data, u64 *val)
+{
+	struct ipu_isys_gpcs *isys_gpcs = data;
+	struct ipu_isys *isys = isys_gpcs->prit;
+
+	mutex_lock(&isys->mutex);
+
+	*val = isys_gpcs->gpc_enable;
+
+	mutex_unlock(&isys->mutex);
+	return 0;
+}
+
+static int ipu6_isys_gpc_global_enable_set(void *data, u64 val)
+{
+	struct ipu_isys_gpcs *isys_gpcs = data;
+	struct ipu_isys *isys = isys_gpcs->prit;
+	void __iomem *base;
+	int i, ret;
+
+	if (val != 0 && val != 1)
+		return -EINVAL;
+
+	if (!isys || !isys->pdata || !isys->pdata->base)
+		return -EINVAL;
+
+	mutex_lock(&isys->mutex);
+
+	base = isys->pdata->base + IPU_ISYS_GPC_BASE;
+
+	ret = pm_runtime_get_sync(&isys->adev->dev);
+	if (ret < 0) {
+		pm_runtime_put(&isys->adev->dev);
+		mutex_unlock(&isys->mutex);
+		return ret;
+	}
+
+	if (!val) {
+		writel(0x0, base + IPU_ISYS_GPREG_TRACE_TIMER_RST);
+		writel(0x0, base + IPU_ISF_CDC_MMU_GPC_OVERALL_ENABLE);
+		writel(0xffff, base + IPU_ISF_CDC_MMU_GPC_SOFT_RESET);
+		isys_gpcs->gpc_enable = false;
+		for (i = 0; i < IPU_ISYS_GPC_NUM; i++) {
+			isys_gpcs->gpc[i].enable = 0;
+			isys_gpcs->gpc[i].sense = 0;
+			isys_gpcs->gpc[i].route = 0;
+			isys_gpcs->gpc[i].source = 0;
+		}
+		pm_runtime_mark_last_busy(&isys->adev->dev);
+		pm_runtime_put_autosuspend(&isys->adev->dev);
+	} else {
+		/*
+		 * Set gpc reg and start all gpc here.
+		 * RST free running local timer.
+		 */
+		writel(0x0, base + IPU_ISYS_GPREG_TRACE_TIMER_RST);
+		writel(0x1, base + IPU_ISYS_GPREG_TRACE_TIMER_RST);
+
+		for (i = 0; i < IPU_ISYS_GPC_NUM; i++) {
+			/* Enable */
+			writel(isys_gpcs->gpc[i].enable,
+			       base + IPU_ISF_CDC_MMU_GPC_ENABLE0 + 4 * i);
+			/* Setting (route/source/sense) */
+			writel((isys_gpcs->gpc[i].sense
+					<< IPU_GPC_SENSE_OFFSET)
+				+ (isys_gpcs->gpc[i].route
+					<< IPU_GPC_ROUTE_OFFSET)
+				+ (isys_gpcs->gpc[i].source
+					<< IPU_GPC_SOURCE_OFFSET),
+				base + IPU_ISF_CDC_MMU_GPC_CNT_SEL0 + 4 * i);
+		}
+
+		/* Soft reset and Overall Enable. */
+		writel(0x0, base + IPU_ISF_CDC_MMU_GPC_OVERALL_ENABLE);
+		writel(0xffff, base + IPU_ISF_CDC_MMU_GPC_SOFT_RESET);
+		writel(0x1, base + IPU_ISF_CDC_MMU_GPC_OVERALL_ENABLE);
+
+		isys_gpcs->gpc_enable = true;
+	}
+
+	mutex_unlock(&isys->mutex);
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(isys_gpc_globe_enable_fops,
+			ipu6_isys_gpc_global_enable_get,
+			ipu6_isys_gpc_global_enable_set, "%llu\n");
+
+static int ipu6_isys_gpc_count_get(void *data, u64 *val)
+{
+	struct ipu_isys_gpc *isys_gpc = data;
+	struct ipu_isys *isys = isys_gpc->prit;
+	void __iomem *base;
+
+	if (!isys || !isys->pdata || !isys->pdata->base)
+		return -EINVAL;
+
+	spin_lock(&isys->power_lock);
+	if (isys->power) {
+		base = isys->pdata->base + IPU_ISYS_GPC_BASE;
+		*val = readl(base + IPU_ISF_CDC_MMU_GPC_VALUE0
+				 + 4 * isys_gpc->gpcindex);
+	} else {
+		*val = 0;
+	}
+	spin_unlock(&isys->power_lock);
+
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(isys_gpc_count_fops, ipu6_isys_gpc_count_get,
+			NULL, "%llu\n");
+
+int ipu_isys_gpc_init_debugfs(struct ipu_isys *isys)
+{
+	struct dentry *gpcdir;
+	struct dentry *dir;
+	struct dentry *file;
+	int i;
+	char gpcname[10];
+	struct ipu_isys_gpcs *isys_gpcs;
+
+	isys_gpcs = devm_kzalloc(&isys->adev->dev, sizeof(*isys_gpcs),
+				 GFP_KERNEL);
+	if (!isys_gpcs)
+		return -ENOMEM;
+
+	gpcdir = debugfs_create_dir("gpcs", isys->debugfsdir);
+	if (IS_ERR(gpcdir))
+		return -ENOMEM;
+
+	isys_gpcs->prit = isys;
+	file = debugfs_create_file("enable", 0600, gpcdir, isys_gpcs,
+				   &isys_gpc_globe_enable_fops);
+	if (IS_ERR(file))
+		goto err;
+
+	for (i = 0; i < IPU_ISYS_GPC_NUM; i++) {
+		sprintf(gpcname, "gpc%d", i);
+		dir = debugfs_create_dir(gpcname, gpcdir);
+		if (IS_ERR(dir))
+			goto err;
+
+		debugfs_create_bool("enable", 0600, dir,
+				    &isys_gpcs->gpc[i].enable);
+
+		debugfs_create_u32("source", 0600, dir,
+				   &isys_gpcs->gpc[i].source);
+
+		debugfs_create_u32("route", 0600, dir,
+				   &isys_gpcs->gpc[i].route);
+
+		debugfs_create_u32("sense", 0600, dir,
+				   &isys_gpcs->gpc[i].sense);
+
+		isys_gpcs->gpc[i].gpcindex = i;
+		isys_gpcs->gpc[i].prit = isys;
+		file = debugfs_create_file("count", 0400, dir,
+					   &isys_gpcs->gpc[i],
+					   &isys_gpc_count_fops);
+		if (IS_ERR(file))
+			goto err;
+	}
+
+	return 0;
+
+err:
+	debugfs_remove_recursive(gpcdir);
+	return -ENOMEM;
+}
+#endif
Index: b/drivers/media/pci/intel/ipu6/ipu6-isys-phy.c
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu6/ipu6-isys-phy.c
@@ -0,0 +1,667 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2013 - 2020 Intel Corporation
+ */
+
+#include <linux/delay.h>
+#include <media/ipu-isys.h>
+#include <media/v4l2-device.h>
+#include "ipu.h"
+#include "ipu-buttress.h"
+#include "ipu-isys.h"
+#include "ipu-isys-csi2.h"
+#include "ipu-platform-regs.h"
+#include "ipu-platform-isys-csi2-reg.h"
+#include "ipu6-isys-csi2.h"
+#include "ipu6-isys-phy.h"
+
+#define LOOP (2000)
+
+#define PHY_REG_INIT_CTL	     0x00000694
+#define PHY_REG_INIT_CTL_PORT_OFFSET 0x00000600
+
+struct phy_reg {
+	u32 reg;
+	u32 val;
+};
+
+static const struct phy_reg common_init_regs[] = {
+	/* for TGL-U, use 0x80000000 */
+	{0x00000040, 0x80000000},
+	{0x00000044, 0x00a80880},
+	{0x00000044, 0x00b80880},
+	{0x00000010, 0x0000078c},
+	{0x00000344, 0x2f4401e2},
+	{0x00000544, 0x924401e2},
+	{0x00000744, 0x594401e2},
+	{0x00000944, 0x624401e2},
+	{0x00000b44, 0xfc4401e2},
+	{0x00000d44, 0xc54401e2},
+	{0x00000f44, 0x034401e2},
+	{0x00001144, 0x8f4401e2},
+	{0x00001344, 0x754401e2},
+	{0x00001544, 0xe94401e2},
+	{0x00001744, 0xcb4401e2},
+	{0x00001944, 0xfa4401e2}
+};
+
+static const struct phy_reg x1_port0_config_regs[] = {
+	{0x00000694, 0xc80060fa},
+	{0x00000680, 0x3d4f78ea},
+	{0x00000690, 0x10a0140b},
+	{0x000006a8, 0xdf04010a},
+	{0x00000700, 0x57050060},
+	{0x00000710, 0x0030001c},
+	{0x00000738, 0x5f004444},
+	{0x0000073c, 0x78464204},
+	{0x00000748, 0x7821f940},
+	{0x0000074c, 0xb2000433},
+	{0x00000494, 0xfe6030fa},
+	{0x00000480, 0x29ef5ed0},
+	{0x00000490, 0x10a0540b},
+	{0x000004a8, 0x7a01010a},
+	{0x00000500, 0xef053460},
+	{0x00000510, 0xe030101c},
+	{0x00000538, 0xdf808444},
+	{0x0000053c, 0xc8422204},
+	{0x00000540, 0x0180088c},
+	{0x00000574, 0x00000000},
+	{0x00000000, 0x00000000}
+};
+
+static const struct phy_reg x1_port1_config_regs[] = {
+	{0x00000c94, 0xc80060fa},
+	{0x00000c80, 0xcf47abea},
+	{0x00000c90, 0x10a0840b},
+	{0x00000ca8, 0xdf04010a},
+	{0x00000d00, 0x57050060},
+	{0x00000d10, 0x0030001c},
+	{0x00000d38, 0x5f004444},
+	{0x00000d3c, 0x78464204},
+	{0x00000d48, 0x7821f940},
+	{0x00000d4c, 0xb2000433},
+	{0x00000a94, 0xc91030fa},
+	{0x00000a80, 0x5a166ed0},
+	{0x00000a90, 0x10a0540b},
+	{0x00000aa8, 0x5d060100},
+	{0x00000b00, 0xef053460},
+	{0x00000b10, 0xa030101c},
+	{0x00000b38, 0xdf808444},
+	{0x00000b3c, 0xc8422204},
+	{0x00000b40, 0x0180088c},
+	{0x00000b74, 0x00000000},
+	{0x00000000, 0x00000000}
+};
+
+static const struct phy_reg x1_port2_config_regs[] = {
+	{0x00001294, 0x28f000fa},
+	{0x00001280, 0x08130cea},
+	{0x00001290, 0x10a0140b},
+	{0x000012a8, 0xd704010a},
+	{0x00001300, 0x8d050060},
+	{0x00001310, 0x0030001c},
+	{0x00001338, 0xdf008444},
+	{0x0000133c, 0x78422204},
+	{0x00001348, 0x7821f940},
+	{0x0000134c, 0x5a000433},
+	{0x00001094, 0x2d20b0fa},
+	{0x00001080, 0xade75dd0},
+	{0x00001090, 0x10a0540b},
+	{0x000010a8, 0xb101010a},
+	{0x00001100, 0x33053460},
+	{0x00001110, 0x0030101c},
+	{0x00001138, 0xdf808444},
+	{0x0000113c, 0xc8422204},
+	{0x00001140, 0x8180088c},
+	{0x00001174, 0x00000000},
+	{0x00000000, 0x00000000}
+};
+
+static const struct phy_reg x1_port3_config_regs[] = {
+	{0x00001894, 0xc80060fa},
+	{0x00001880, 0x0f90fd6a},
+	{0x00001890, 0x10a0840b},
+	{0x000018a8, 0xdf04010a},
+	{0x00001900, 0x57050060},
+	{0x00001910, 0x0030001c},
+	{0x00001938, 0x5f004444},
+	{0x0000193c, 0x78464204},
+	{0x00001948, 0x7821f940},
+	{0x0000194c, 0xb2000433},
+	{0x00001694, 0x3050d0fa},
+	{0x00001680, 0x0ef6d050},
+	{0x00001690, 0x10a0540b},
+	{0x000016a8, 0xe301010a},
+	{0x00001700, 0x69053460},
+	{0x00001710, 0xa030101c},
+	{0x00001738, 0xdf808444},
+	{0x0000173c, 0xc8422204},
+	{0x00001740, 0x0180088c},
+	{0x00001774, 0x00000000},
+	{0x00000000, 0x00000000}
+};
+
+static const struct phy_reg x2_port0_config_regs[] = {
+	{0x00000694, 0xc80060fa},
+	{0x00000680, 0x3d4f78ea},
+	{0x00000690, 0x10a0140b},
+	{0x000006a8, 0xdf04010a},
+	{0x00000700, 0x57050060},
+	{0x00000710, 0x0030001c},
+	{0x00000738, 0x5f004444},
+	{0x0000073c, 0x78464204},
+	{0x00000748, 0x7821f940},
+	{0x0000074c, 0xb2000433},
+	{0x00000494, 0xc80060fa},
+	{0x00000480, 0x29ef5ed8},
+	{0x00000490, 0x10a0540b},
+	{0x000004a8, 0x7a01010a},
+	{0x00000500, 0xef053460},
+	{0x00000510, 0xe030101c},
+	{0x00000538, 0xdf808444},
+	{0x0000053c, 0xc8422204},
+	{0x00000540, 0x0180088c},
+	{0x00000574, 0x00000000},
+	{0x00000294, 0xc80060fa},
+	{0x00000280, 0xcb45b950},
+	{0x00000290, 0x10a0540b},
+	{0x000002a8, 0x8c01010a},
+	{0x00000300, 0xef053460},
+	{0x00000310, 0x8030101c},
+	{0x00000338, 0x41808444},
+	{0x0000033c, 0x32422204},
+	{0x00000340, 0x0180088c},
+	{0x00000374, 0x00000000},
+	{0x00000000, 0x00000000}
+};
+
+static const struct phy_reg x2_port1_config_regs[] = {
+	{0x00000c94, 0xc80060fa},
+	{0x00000c80, 0xcf47abea},
+	{0x00000c90, 0x10a0840b},
+	{0x00000ca8, 0xdf04010a},
+	{0x00000d00, 0x57050060},
+	{0x00000d10, 0x0030001c},
+	{0x00000d38, 0x5f004444},
+	{0x00000d3c, 0x78464204},
+	{0x00000d48, 0x7821f940},
+	{0x00000d4c, 0xb2000433},
+	{0x00000a94, 0xc80060fa},
+	{0x00000a80, 0x5a166ed8},
+	{0x00000a90, 0x10a0540b},
+	{0x00000aa8, 0x7a01010a},
+	{0x00000b00, 0xef053460},
+	{0x00000b10, 0xa030101c},
+	{0x00000b38, 0xdf808444},
+	{0x00000b3c, 0xc8422204},
+	{0x00000b40, 0x0180088c},
+	{0x00000b74, 0x00000000},
+	{0x00000894, 0xc80060fa},
+	{0x00000880, 0x4d4f21d0},
+	{0x00000890, 0x10a0540b},
+	{0x000008a8, 0x5601010a},
+	{0x00000900, 0xef053460},
+	{0x00000910, 0x8030101c},
+	{0x00000938, 0xdf808444},
+	{0x0000093c, 0xc8422204},
+	{0x00000940, 0x0180088c},
+	{0x00000974, 0x00000000},
+	{0x00000000, 0x00000000}
+};
+
+static const struct phy_reg x2_port2_config_regs[] = {
+	{0x00001294, 0xc80060fa},
+	{0x00001280, 0x08130cea},
+	{0x00001290, 0x10a0140b},
+	{0x000012a8, 0xd704010a},
+	{0x00001300, 0x8d050060},
+	{0x00001310, 0x0030001c},
+	{0x00001338, 0xdf008444},
+	{0x0000133c, 0x78422204},
+	{0x00001348, 0x7821f940},
+	{0x0000134c, 0x5a000433},
+	{0x00001094, 0xc80060fa},
+	{0x00001080, 0xade75dd8},
+	{0x00001090, 0x10a0540b},
+	{0x000010a8, 0xb101010a},
+	{0x00001100, 0x33053460},
+	{0x00001110, 0x0030101c},
+	{0x00001138, 0xdf808444},
+	{0x0000113c, 0xc8422204},
+	{0x00001140, 0x8180088c},
+	{0x00001174, 0x00000000},
+	{0x00000e94, 0xc80060fa},
+	{0x00000e80, 0x0fbf16d0},
+	{0x00000e90, 0x10a0540b},
+	{0x00000ea8, 0x7a01010a},
+	{0x00000f00, 0xf5053460},
+	{0x00000f10, 0xc030101c},
+	{0x00000f38, 0xdf808444},
+	{0x00000f3c, 0xc8422204},
+	{0x00000f40, 0x8180088c},
+	{0x00000000, 0x00000000}
+};
+
+static const struct phy_reg x2_port3_config_regs[] = {
+	{0x00001894, 0xc80060fa},
+	{0x00001880, 0x0f90fd6a},
+	{0x00001890, 0x10a0840b},
+	{0x000018a8, 0xdf04010a},
+	{0x00001900, 0x57050060},
+	{0x00001910, 0x0030001c},
+	{0x00001938, 0x5f004444},
+	{0x0000193c, 0x78464204},
+	{0x00001948, 0x7821f940},
+	{0x0000194c, 0xb2000433},
+	{0x00001694, 0xc80060fa},
+	{0x00001680, 0x0ef6d058},
+	{0x00001690, 0x10a0540b},
+	{0x000016a8, 0x7a01010a},
+	{0x00001700, 0x69053460},
+	{0x00001710, 0xa030101c},
+	{0x00001738, 0xdf808444},
+	{0x0000173c, 0xc8422204},
+	{0x00001740, 0x0180088c},
+	{0x00001774, 0x00000000},
+	{0x00001494, 0xc80060fa},
+	{0x00001480, 0xf9d34bd0},
+	{0x00001490, 0x10a0540b},
+	{0x000014a8, 0x7a01010a},
+	{0x00001500, 0x1b053460},
+	{0x00001510, 0x0030101c},
+	{0x00001538, 0xdf808444},
+	{0x0000153c, 0xc8422204},
+	{0x00001540, 0x8180088c},
+	{0x00001574, 0x00000000},
+	{0x00000000, 0x00000000}
+};
+
+static const struct phy_reg x4_port0_config_regs[] = {
+	{0x00000694, 0xc80060fa},
+	{0x00000680, 0x3d4f78fa},
+	{0x00000690, 0x10a0140b},
+	{0x000006a8, 0xdf04010a},
+	{0x00000700, 0x57050060},
+	{0x00000710, 0x0030001c},
+	{0x00000738, 0x5f004444},
+	{0x0000073c, 0x78464204},
+	{0x00000748, 0x7821f940},
+	{0x0000074c, 0xb2000433},
+	{0x00000494, 0xfe6030fa},
+	{0x00000480, 0x29ef5ed8},
+	{0x00000490, 0x10a0540b},
+	{0x000004a8, 0x7a01010a},
+	{0x00000500, 0xef053460},
+	{0x00000510, 0xe030101c},
+	{0x00000538, 0xdf808444},
+	{0x0000053c, 0xc8422204},
+	{0x00000540, 0x0180088c},
+	{0x00000574, 0x00000004},
+	{0x00000294, 0x23e030fa},
+	{0x00000280, 0xcb45b950},
+	{0x00000290, 0x10a0540b},
+	{0x000002a8, 0x8c01010a},
+	{0x00000300, 0xef053460},
+	{0x00000310, 0x8030101c},
+	{0x00000338, 0x41808444},
+	{0x0000033c, 0x32422204},
+	{0x00000340, 0x0180088c},
+	{0x00000374, 0x00000004},
+	{0x00000894, 0x5620b0fa},
+	{0x00000880, 0x4d4f21dc},
+	{0x00000890, 0x10a0540b},
+	{0x000008a8, 0x5601010a},
+	{0x00000900, 0xef053460},
+	{0x00000910, 0x8030101c},
+	{0x00000938, 0xdf808444},
+	{0x0000093c, 0xc8422204},
+	{0x00000940, 0x0180088c},
+	{0x00000974, 0x00000004},
+	{0x00000a94, 0xc91030fa},
+	{0x00000a80, 0x5a166ecc},
+	{0x00000a90, 0x10a0540b},
+	{0x00000aa8, 0x5d01010a},
+	{0x00000b00, 0xef053460},
+	{0x00000b10, 0xa030101c},
+	{0x00000b38, 0xdf808444},
+	{0x00000b3c, 0xc8422204},
+	{0x00000b40, 0x0180088c},
+	{0x00000b74, 0x00000004},
+	{0x00000000, 0x00000000}
+};
+
+static const struct phy_reg x4_port1_config_regs[] = {
+	{0x00000000, 0x00000000}
+};
+
+static const struct phy_reg x4_port2_config_regs[] = {
+	{0x00001294, 0x28f000fa},
+	{0x00001280, 0x08130cfa},
+	{0x00001290, 0x10c0140b},
+	{0x000012a8, 0xd704010a},
+	{0x00001300, 0x8d050060},
+	{0x00001310, 0x0030001c},
+	{0x00001338, 0xdf008444},
+	{0x0000133c, 0x78422204},
+	{0x00001348, 0x7821f940},
+	{0x0000134c, 0x5a000433},
+	{0x00001094, 0x2d20b0fa},
+	{0x00001080, 0xade75dd8},
+	{0x00001090, 0x10a0540b},
+	{0x000010a8, 0xb101010a},
+	{0x00001100, 0x33053460},
+	{0x00001110, 0x0030101c},
+	{0x00001138, 0xdf808444},
+	{0x0000113c, 0xc8422204},
+	{0x00001140, 0x8180088c},
+	{0x00001174, 0x00000004},
+	{0x00000e94, 0xd308d0fa},
+	{0x00000e80, 0x0fbf16d0},
+	{0x00000e90, 0x10a0540b},
+	{0x00000ea8, 0x2c01010a},
+	{0x00000f00, 0xf5053460},
+	{0x00000f10, 0xc030101c},
+	{0x00000f38, 0xdf808444},
+	{0x00000f3c, 0xc8422204},
+	{0x00000f40, 0x8180088c},
+	{0x00000f74, 0x00000004},
+	{0x00001494, 0x136850fa},
+	{0x00001480, 0xf9d34bdc},
+	{0x00001490, 0x10a0540b},
+	{0x000014a8, 0x5a01010a},
+	{0x00001500, 0x1b053460},
+	{0x00001510, 0x0030101c},
+	{0x00001538, 0xdf808444},
+	{0x0000153c, 0xc8422204},
+	{0x00001540, 0x8180088c},
+	{0x00001574, 0x00000004},
+	{0x00001694, 0x3050d0fa},
+	{0x00001680, 0x0ef6d04c},
+	{0x00001690, 0x10a0540b},
+	{0x000016a8, 0xe301010a},
+	{0x00001700, 0x69053460},
+	{0x00001710, 0xa030101c},
+	{0x00001738, 0xdf808444},
+	{0x0000173c, 0xc8422204},
+	{0x00001740, 0x0180088c},
+	{0x00001774, 0x00000004},
+	{0x00000000, 0x00000000}
+};
+
+static const struct phy_reg x4_port3_config_regs[] = {
+	{0x00000000, 0x00000000}
+};
+
+static const struct phy_reg *x1_config_regs[4] = {
+	x1_port0_config_regs,
+	x1_port1_config_regs,
+	x1_port2_config_regs,
+	x1_port3_config_regs
+};
+
+static const struct phy_reg *x2_config_regs[4] = {
+	x2_port0_config_regs,
+	x2_port1_config_regs,
+	x2_port2_config_regs,
+	x2_port3_config_regs
+};
+
+static const struct phy_reg *x4_config_regs[4] = {
+	x4_port0_config_regs,
+	x4_port1_config_regs,
+	x4_port2_config_regs,
+	x4_port3_config_regs
+};
+
+static const struct phy_reg **config_regs[3] = {
+	x1_config_regs,
+	x2_config_regs,
+	x4_config_regs,
+};
+
+int ipu6_isys_phy_powerup_ack(struct ipu_isys *isys, unsigned int phy_id)
+{
+	unsigned int i;
+	u32 val;
+	void __iomem *isys_base = isys->pdata->base;
+
+	val = readl(isys_base + CSI_REG_HUB_GPREG_PHY_CONTROL(phy_id));
+	val |= CSI_REG_HUB_GPREG_PHY_CONTROL_PWR_EN;
+	writel(val, isys_base + CSI_REG_HUB_GPREG_PHY_CONTROL(phy_id));
+
+	for (i = 0; i < LOOP; i++) {
+		if (readl(isys_base + CSI_REG_HUB_GPREG_PHY_STATUS(phy_id)) &
+		    CSI_REG_HUB_GPREG_PHY_STATUS_POWER_ACK)
+			return 0;
+		usleep_range(100, 200);
+	}
+
+	dev_warn(&isys->adev->dev, "PHY%d powerup ack timeout", phy_id);
+
+	return -ETIMEDOUT;
+}
+
+int ipu6_isys_phy_powerdown_ack(struct ipu_isys *isys, unsigned int phy_id)
+{
+	unsigned int i;
+	u32 val;
+	void __iomem *isys_base = isys->pdata->base;
+
+	writel(0, isys_base + CSI_REG_HUB_GPREG_PHY_CONTROL(phy_id));
+	for (i = 0; i < LOOP; i++) {
+		usleep_range(10, 20);
+		val = readl(isys_base + CSI_REG_HUB_GPREG_PHY_STATUS(phy_id));
+		if (!(val & CSI_REG_HUB_GPREG_PHY_STATUS_POWER_ACK))
+			return 0;
+	}
+
+	dev_warn(&isys->adev->dev, "PHY %d poweroff ack timeout.\n", phy_id);
+
+	return -ETIMEDOUT;
+}
+
+int ipu6_isys_phy_reset(struct ipu_isys *isys, unsigned int phy_id,
+			bool assert)
+{
+	void __iomem *isys_base = isys->pdata->base;
+	u32 val;
+
+	val = readl(isys_base + CSI_REG_HUB_GPREG_PHY_CONTROL(phy_id));
+	if (assert)
+		val |= CSI_REG_HUB_GPREG_PHY_CONTROL_RESET;
+	else
+		val &= ~(CSI_REG_HUB_GPREG_PHY_CONTROL_RESET);
+
+	writel(val, isys_base + CSI_REG_HUB_GPREG_PHY_CONTROL(phy_id));
+
+	return 0;
+}
+
+int ipu6_isys_phy_ready(struct ipu_isys *isys, unsigned int phy_id)
+{
+	unsigned int i;
+	u32 val;
+	void __iomem *isys_base = isys->pdata->base;
+
+	for (i = 0; i < LOOP; i++) {
+		val = readl(isys_base + CSI_REG_HUB_GPREG_PHY_STATUS(phy_id));
+		dev_dbg(&isys->adev->dev, "PHY%d ready status 0x%x\n",
+			phy_id, val);
+		if (val & CSI_REG_HUB_GPREG_PHY_STATUS_PHY_READY)
+			return 0;
+		usleep_range(10, 20);
+	}
+
+	dev_warn(&isys->adev->dev, "PHY%d ready timeout\n", phy_id);
+
+	return -ETIMEDOUT;
+}
+
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA)
+int ipu6_isys_phy_common_init(struct ipu_isys *isys, struct ipu_isys_csi2_config *cfg)
+{
+	unsigned int phy_id;
+	void __iomem *phy_base;
+	struct ipu_bus_device *adev = to_ipu_bus_device(&isys->adev->dev);
+	struct ipu_device *isp = adev->isp;
+	void __iomem *isp_base = isp->base;
+	unsigned int i;
+
+	phy_id = cfg->port / 4;
+	phy_base = isp_base + IPU6_ISYS_PHY_BASE(phy_id);
+
+	for (i = 0 ; i < ARRAY_SIZE(common_init_regs); i++) {
+		writel(common_init_regs[i].val,
+			phy_base + common_init_regs[i].reg);
+	}
+
+	return 0;
+}
+#else
+int ipu6_isys_phy_common_init(struct ipu_isys *isys)
+{
+	unsigned int phy_id;
+	void __iomem *phy_base;
+	struct ipu_bus_device *adev = to_ipu_bus_device(&isys->adev->dev);
+	struct ipu_device *isp = adev->isp;
+	void __iomem *isp_base = isp->base;
+	struct v4l2_async_subdev *asd;
+	struct sensor_async_subdev *s_asd;
+	unsigned int i;
+
+	list_for_each_entry(asd, &isys->notifier.asd_list, asd_list) {
+		s_asd = container_of(asd, struct sensor_async_subdev, asd);
+		phy_id = s_asd->csi2.port / 4;
+		phy_base = isp_base + IPU6_ISYS_PHY_BASE(phy_id);
+
+		for (i = 0 ; i < ARRAY_SIZE(common_init_regs); i++) {
+			writel(common_init_regs[i].val,
+				phy_base + common_init_regs[i].reg);
+		}
+	}
+
+	return 0;
+}
+#endif
+
+static int ipu6_isys_driver_port_to_phy_port(struct ipu_isys_csi2_config *cfg)
+{
+	int phy_port;
+	int ret;
+
+	if (!(cfg->nlanes == 4 || cfg->nlanes == 2 || cfg->nlanes == 1))
+		return -EINVAL;
+
+	/* B,F -> C0 A,E -> C1 C,G -> C2 D,H -> C4 */
+	/* normalize driver port number */
+	phy_port = cfg->port % 4;
+
+	/* swap port number only for A and B */
+	if (phy_port == 0)
+		phy_port = 1;
+	else if (phy_port == 1)
+		phy_port = 0;
+
+	ret = phy_port;
+
+	/* check validity per lane configuration */
+	if ((cfg->nlanes == 4) &&
+		 !(phy_port == 0 || phy_port == 2))
+		ret = -EINVAL;
+	else if ((cfg->nlanes == 2 || cfg->nlanes == 1) &&
+		 !(phy_port >= 0 && phy_port <= 3))
+		ret = -EINVAL;
+
+	return ret;
+}
+
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA)
+int ipu6_isys_phy_config(struct ipu_isys *isys, struct ipu_isys_csi2_config *cfg)
+{
+	unsigned int phy_port, phy_id;
+	void __iomem *phy_base;
+	struct ipu_bus_device *adev = to_ipu_bus_device(&isys->adev->dev);
+	struct ipu_device *isp = adev->isp;
+	void __iomem *isp_base = isp->base;
+	const struct phy_reg **phy_config_regs;
+	struct ipu_isys_subdev_pdata *spdata = isys->pdata->spdata;
+	struct ipu_isys_subdev_info **subdevs, *sd_info;
+	int i;
+
+	if (!spdata) {
+		dev_err(&isys->adev->dev, "no subdevice info provided\n");
+		return -EINVAL;
+	}
+
+	phy_id = cfg->port / 4;
+	phy_base = isp_base + IPU6_ISYS_PHY_BASE(phy_id);
+	for (subdevs = spdata->subdevs; *subdevs; subdevs++) {
+		sd_info = *subdevs;
+		if (!sd_info->csi2)
+			continue;
+
+		phy_port = ipu6_isys_driver_port_to_phy_port(sd_info->csi2);
+		if (phy_port < 0) {
+			dev_err(&isys->adev->dev, "invalid port %d for lane %d",
+					cfg->port, cfg->nlanes);
+			return -ENXIO;
+		}
+
+		if ((sd_info->csi2->port / 4) != phy_id)
+			continue;
+
+		dev_dbg(&isys->adev->dev, "port%d PHY%u lanes %u\n",
+			phy_port, phy_id, cfg->nlanes);
+
+		phy_config_regs = config_regs[sd_info->csi2->nlanes/2];
+
+		for (i = 0; phy_config_regs[phy_port][i].reg; i++) {
+			writel(phy_config_regs[phy_port][i].val,
+				phy_base + phy_config_regs[phy_port][i].reg);
+		}
+	}
+
+	return 0;
+}
+#else
+int ipu6_isys_phy_config(struct ipu_isys *isys)
+{
+	int phy_port;
+	unsigned int phy_id;
+	void __iomem *phy_base;
+	struct ipu_bus_device *adev = to_ipu_bus_device(&isys->adev->dev);
+	struct ipu_device *isp = adev->isp;
+	void __iomem *isp_base = isp->base;
+	const struct phy_reg **phy_config_regs;
+	struct v4l2_async_subdev *asd;
+	struct sensor_async_subdev *s_asd;
+	struct ipu_isys_csi2_config cfg;
+	int i;
+
+	list_for_each_entry(asd, &isys->notifier.asd_list, asd_list) {
+		s_asd = container_of(asd, struct sensor_async_subdev, asd);
+		cfg.port = s_asd->csi2.port;
+		cfg.nlanes = s_asd->csi2.nlanes;
+		phy_port = ipu6_isys_driver_port_to_phy_port(&cfg);
+		if (phy_port < 0) {
+			dev_err(&isys->adev->dev, "invalid port %d for lane %d",
+				cfg.port, cfg.nlanes);
+			return -ENXIO;
+		}
+
+		phy_id = cfg.port / 4;
+		phy_base = isp_base + IPU6_ISYS_PHY_BASE(phy_id);
+		dev_dbg(&isys->adev->dev, "port%d PHY%u lanes %u\n",
+			cfg.port, phy_id, cfg.nlanes);
+
+		phy_config_regs = config_regs[cfg.nlanes/2];
+		cfg.port = phy_port;
+		for (i = 0; phy_config_regs[cfg.port][i].reg; i++) {
+			writel(phy_config_regs[cfg.port][i].val,
+				phy_base + phy_config_regs[cfg.port][i].reg);
+		}
+	}
+
+	return 0;
+}
+#endif
Index: b/drivers/media/pci/intel/ipu6/ipu6-isys-phy.h
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu6/ipu6-isys-phy.h
@@ -0,0 +1,164 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2013 - 2020 Intel Corporation
+ */
+
+#ifndef IPU6_ISYS_PHY_H
+#define IPU6_ISYS_PHY_H
+
+/* bridge to phy in buttress reg map, each phy has 16 kbytes
+ * for tgl u/y, only 2 phys
+ */
+#define IPU6_ISYS_PHY_0_BASE			0x10000
+#define IPU6_ISYS_PHY_1_BASE			0x14000
+#define IPU6_ISYS_PHY_2_BASE			0x18000
+#define IPU6_ISYS_PHY_BASE(i)			(0x10000 + (i) * 0x4000)
+
+/* ppi mapping per phy :
+ *
+ * x4x4:
+ * port0 - PPI range {0, 1, 2, 3, 4}
+ * port2 - PPI range {6, 7, 8, 9, 10}
+ *
+ * x4x2:
+ * port0 - PPI range {0, 1, 2, 3, 4}
+ * port2 - PPI range {6, 7, 8}
+ *
+ * x2x4:
+ * port0 - PPI range {0, 1, 2}
+ * port2 - PPI range {6, 7, 8, 9, 10}
+ *
+ * x2x2:
+ * port0 - PPI range {0, 1, 2}
+ * port1 - PPI range {3, 4, 5}
+ * port2 - PPI range {6, 7, 8}
+ * port3 - PPI range {9, 10, 11}
+ */
+
+/* cbbs config regs */
+#define PHY_CBBS1_BASE				0x0
+/* register offset */
+#define PHY_CBBS1_DFX_VMISCCTL			0x0
+#define PHY_CBBS1_DFX_VBYTESEL0			0x4
+#define PHY_CBBS1_DFX_VBYTESEL1			0x8
+#define PHY_CBBS1_VISA2OBS_CTRL_REG		0xc
+#define PHY_CBBS1_PGL_CTRL_REG			0x10
+#define PHY_CBBS1_RCOMP_CTRL_REG_1		0x14
+#define PHY_CBBS1_RCOMP_CTRL_REG_2		0x18
+#define PHY_CBBS1_RCOMP_CTRL_REG_3		0x1c
+#define PHY_CBBS1_RCOMP_CTRL_REG_4		0x20
+#define PHY_CBBS1_RCOMP_CTRL_REG_5		0x24
+#define PHY_CBBS1_RCOMP_STATUS_REG_1		0x28
+#define PHY_CBBS1_RCOMP_STATUS_REG_2		0x2c
+#define PHY_CBBS1_CLOCK_CTRL_REG		0x30
+#define PHY_CBBS1_CBB_ISOLATION_REG		0x34
+#define PHY_CBBS1_CBB_PLL_CONTROL		0x38
+#define PHY_CBBS1_CBB_STATUS_REG		0x3c
+#define PHY_CBBS1_AFE_CONTROL_REG_1		0x40
+#define PHY_CBBS1_AFE_CONTROL_REG_2		0x44
+#define PHY_CBBS1_CBB_SPARE			0x48
+#define PHY_CBBS1_CRI_CLK_CONTROL		0x4c
+
+/* dbbs shared, i = [0..11] */
+#define PHY_DBBS_SHARED(ppi)			((ppi) * 0x200 + 0x200)
+/* register offset */
+#define PHY_DBBDFE_DFX_V1MISCCTL		0x0
+#define PHY_DBBDFE_DFX_V1BYTESEL0		0x4
+#define PHY_DBBDFE_DFX_V1BYTESEL1		0x8
+#define PHY_DBBDFE_DFX_V2MISCCTL		0xc
+#define PHY_DBBDFE_DFX_V2BYTESEL0		0x10
+#define PHY_DBBDFE_DFX_V2BYTESEL1		0x14
+#define PHY_DBBDFE_GBLCTL			0x18
+#define PHY_DBBDFE_GBL_STATUS			0x1c
+
+/* dbbs udln, i = [0..11] */
+#define IPU6_ISYS_PHY_DBBS_UDLN(ppi)		((ppi) * 0x200 + 0x280)
+/* register offset */
+#define PHY_DBBUDLN_CTL				0x0
+#define PHY_DBBUDLN_CLK_CTL			0x4
+#define PHY_DBBUDLN_SOFT_RST_CTL		0x8
+#define PHY_DBBUDLN_STRAP_VALUES		0xc
+#define PHY_DBBUDLN_TXRX_CTL			0x10
+#define PHY_DBBUDLN_MST_SLV_INIT_CTL		0x14
+#define PHY_DBBUDLN_TX_TIMING_CTL0		0x18
+#define PHY_DBBUDLN_TX_TIMING_CTL1		0x1c
+#define PHY_DBBUDLN_TX_TIMING_CTL2		0x20
+#define PHY_DBBUDLN_TX_TIMING_CTL3		0x24
+#define PHY_DBBUDLN_RX_TIMING_CTL		0x28
+#define PHY_DBBUDLN_PPI_STATUS_CTL		0x2c
+#define PHY_DBBUDLN_PPI_STATUS			0x30
+#define PHY_DBBUDLN_ERR_CTL			0x34
+#define PHY_DBBUDLN_ERR_STATUS			0x38
+#define PHY_DBBUDLN_DFX_LPBK_CTL		0x3c
+#define PHY_DBBUDLN_DFX_PPI_CTL			0x40
+#define PHY_DBBUDLN_DFX_TX_DPHY_CTL		0x44
+#define PHY_DBBUDLN_DFX_TXRX_PRBSPAT_CTL	0x48
+#define PHY_DBBUDLN_DFX_TXRX_PRBSPAT_SEED	0x4c
+#define PHY_DBBUDLN_DFX_PRBSPAT_MAX_WRD_CNT	0x50
+#define PHY_DBBUDLN_DFX_PRBSPAT_STATUS		0x54
+#define PHY_DBBUDLN_DFX_PRBSPAT_WRD_CNT0_STATUS	0x58
+#define PHY_DBBUDLN_DFX_PRBSPAT_WRD_CNT1_STATUS	0x5c
+#define PHY_DBBUDLN_DFX_PRBSPAT_FF_ERR_STATUS	0x60
+#define PHY_DBBUDLN_DFX_PRBSPAT_FF_REF_STATUS		0x64
+#define PHY_DBBUDLN_DFX_PRBSPAT_FF_WRD_CNT0_STATUS	0x68
+#define PHY_DBBUDLN_DFX_PRBSPAT_FF_WRD_CNT1_STATUS	0x6c
+#define PHY_DBBUDLN_RSVD_CTL				0x70
+#define PHY_DBBUDLN_TINIT_DONE				BIT(27)
+
+/* dbbs supar, i = [0..11] */
+#define IPU6_ISYS_PHY_DBBS_SUPAR(ppi)		((ppi) * 0x200 + 0x300)
+/* register offset */
+#define PHY_DBBSUPAR_TXRX_FUPAR_CTL		0x0
+#define PHY_DBBSUPAR_TXHS_AFE_CTL		0x4
+#define PHY_DBBSUPAR_TXHS_AFE_LEGDIS_CTL	0x8
+#define PHY_DBBSUPAR_TXHS_AFE_EQ_CTL		0xc
+#define PHY_DBBSUPAR_RXHS_AFE_CTL1		0x10
+#define PHY_DBBSUPAR_RXHS_AFE_PICTL1		0x14
+#define PHY_DBBSUPAR_TXRXLP_AFE_CTL		0x18
+#define PHY_DBBSUPAR_DFX_TXRX_STATUS		0x1c
+#define PHY_DBBSUPAR_DFX_TXRX_CTL		0x20
+#define PHY_DBBSUPAR_DFX_DIGMON_CTL		0x24
+#define PHY_DBBSUPAR_DFX_LOCMON_CTL		0x28
+#define PHY_DBBSUPAR_DFX_RCOMP_CTL1		0x2c
+#define PHY_DBBSUPAR_DFX_RCOMP_CTL2		0x30
+#define PHY_DBBSUPAR_CAL_TOP1			0x34
+#define PHY_DBBSUPAR_CAL_SHARED1		0x38
+#define PHY_DBBSUPAR_CAL_SHARED2		0x3c
+#define PHY_DBBSUPAR_CAL_CDR1			0x40
+#define PHY_DBBSUPAR_CAL_OCAL1			0x44
+#define PHY_DBBSUPAR_CAL_DCC_DLL1		0x48
+#define PHY_DBBSUPAR_CAL_DLL2			0x4c
+#define PHY_DBBSUPAR_CAL_DFX1			0x50
+#define PHY_DBBSUPAR_CAL_DFX2			0x54
+#define PHY_DBBSUPAR_CAL_DFX3			0x58
+#define PHY_BBSUPAR_CAL_DFX4			0x5c
+#define PHY_DBBSUPAR_CAL_DFX5			0x60
+#define PHY_DBBSUPAR_CAL_DFX6			0x64
+#define PHY_DBBSUPAR_CAL_DFX7			0x68
+#define PHY_DBBSUPAR_DFX_AFE_SPARE_CTL1		0x6c
+#define PHY_DBBSUPAR_DFX_AFE_SPARE_CTL2		0x70
+#define	PHY_DBBSUPAR_SPARE			0x74
+
+/* sai, i = [0..11] */
+#define	IPU6_ISYS_PHY_SAI			0xf800
+/* register offset */
+#define PHY_SAI_CTRL_REG0                       0x40
+#define PHY_SAI_CTRL_REG0_1                     0x44
+#define PHY_SAI_WR_REG0                         0x48
+#define PHY_SAI_WR_REG0_1                       0x4c
+#define PHY_SAI_RD_REG0                         0x50
+#define PHY_SAI_RD_REG0_1                       0x54
+
+int ipu6_isys_phy_powerup_ack(struct ipu_isys *isys, unsigned int phy_id);
+int ipu6_isys_phy_powerdown_ack(struct ipu_isys *isys, unsigned int phy_id);
+int ipu6_isys_phy_reset(struct ipu_isys *isys, unsigned int phy_id,
+			bool assert);
+int ipu6_isys_phy_ready(struct ipu_isys *isys, unsigned int phy_id);
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA)
+int ipu6_isys_phy_common_init(struct ipu_isys *isys, struct ipu_isys_csi2_config *cfg);
+int ipu6_isys_phy_config(struct ipu_isys *isys, struct ipu_isys_csi2_config *cfg);
+#else
+int ipu6_isys_phy_common_init(struct ipu_isys *isys);
+int ipu6_isys_phy_config(struct ipu_isys *isys);
+#endif
+#endif
Index: b/drivers/media/pci/intel/ipu6/ipu6-isys.c
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu6/ipu6-isys.c
@@ -0,0 +1,190 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) 2020 Intel Corporation
+
+#include <linux/module.h>
+#include <media/v4l2-event.h>
+
+#include "ipu.h"
+#include "ipu-platform-regs.h"
+#include "ipu-trace.h"
+#include "ipu-isys.h"
+#include "ipu-platform-isys-csi2-reg.h"
+
+const struct ipu_isys_pixelformat ipu_isys_pfmts[] = {
+	{V4L2_PIX_FMT_SBGGR12, 16, 12, 0, MEDIA_BUS_FMT_SBGGR12_1X12,
+	 IPU_FW_ISYS_FRAME_FORMAT_RAW16},
+	{V4L2_PIX_FMT_SGBRG12, 16, 12, 0, MEDIA_BUS_FMT_SGBRG12_1X12,
+	 IPU_FW_ISYS_FRAME_FORMAT_RAW16},
+	{V4L2_PIX_FMT_SGRBG12, 16, 12, 0, MEDIA_BUS_FMT_SGRBG12_1X12,
+	 IPU_FW_ISYS_FRAME_FORMAT_RAW16},
+	{V4L2_PIX_FMT_SRGGB12, 16, 12, 0, MEDIA_BUS_FMT_SRGGB12_1X12,
+	 IPU_FW_ISYS_FRAME_FORMAT_RAW16},
+	{V4L2_PIX_FMT_SBGGR10, 16, 10, 0, MEDIA_BUS_FMT_SBGGR10_1X10,
+	 IPU_FW_ISYS_FRAME_FORMAT_RAW16},
+	{V4L2_PIX_FMT_SGBRG10, 16, 10, 0, MEDIA_BUS_FMT_SGBRG10_1X10,
+	 IPU_FW_ISYS_FRAME_FORMAT_RAW16},
+	{V4L2_PIX_FMT_SGRBG10, 16, 10, 0, MEDIA_BUS_FMT_SGRBG10_1X10,
+	 IPU_FW_ISYS_FRAME_FORMAT_RAW16},
+	{V4L2_PIX_FMT_SRGGB10, 16, 10, 0, MEDIA_BUS_FMT_SRGGB10_1X10,
+	 IPU_FW_ISYS_FRAME_FORMAT_RAW16},
+	{V4L2_PIX_FMT_SBGGR8, 8, 8, 0, MEDIA_BUS_FMT_SBGGR8_1X8,
+	 IPU_FW_ISYS_FRAME_FORMAT_RAW8},
+	{V4L2_PIX_FMT_SGBRG8, 8, 8, 0, MEDIA_BUS_FMT_SGBRG8_1X8,
+	 IPU_FW_ISYS_FRAME_FORMAT_RAW8},
+	{V4L2_PIX_FMT_SGRBG8, 8, 8, 0, MEDIA_BUS_FMT_SGRBG8_1X8,
+	 IPU_FW_ISYS_FRAME_FORMAT_RAW8},
+	{V4L2_PIX_FMT_SRGGB8, 8, 8, 0, MEDIA_BUS_FMT_SRGGB8_1X8,
+	 IPU_FW_ISYS_FRAME_FORMAT_RAW8},
+	{}
+};
+
+struct ipu_trace_block isys_trace_blocks[] = {
+	{
+		.offset = IPU_TRACE_REG_IS_TRACE_UNIT_BASE,
+		.type = IPU_TRACE_BLOCK_TUN,
+	},
+	{
+		.offset = IPU_TRACE_REG_IS_SP_EVQ_BASE,
+		.type = IPU_TRACE_BLOCK_TM,
+	},
+	{
+		.offset = IPU_TRACE_REG_IS_SP_GPC_BASE,
+		.type = IPU_TRACE_BLOCK_GPC,
+	},
+	{
+		.offset = IPU_TRACE_REG_IS_ISL_GPC_BASE,
+		.type = IPU_TRACE_BLOCK_GPC,
+	},
+	{
+		.offset = IPU_TRACE_REG_IS_MMU_GPC_BASE,
+		.type = IPU_TRACE_BLOCK_GPC,
+	},
+	{
+		/* Note! this covers all 8 blocks */
+		.offset = IPU_TRACE_REG_CSI2_TM_BASE(0),
+		.type = IPU_TRACE_CSI2,
+	},
+	{
+		/* Note! this covers all 11 blocks */
+		.offset = IPU_TRACE_REG_CSI2_PORT_SIG2SIO_GR_BASE(0),
+		.type = IPU_TRACE_SIG2CIOS,
+	},
+	{
+		.offset = IPU_TRACE_REG_IS_GPREG_TRACE_TIMER_RST_N,
+		.type = IPU_TRACE_TIMER_RST,
+	},
+	{
+		.type = IPU_TRACE_BLOCK_END,
+	}
+};
+
+void isys_setup_hw(struct ipu_isys *isys)
+{
+	void __iomem *base = isys->pdata->base;
+	const u8 *thd = isys->pdata->ipdata->hw_variant.cdc_fifo_threshold;
+	u32 irqs = 0;
+	unsigned int i, nr;
+
+	nr = (ipu_ver == IPU_VER_6 || ipu_ver == IPU_VER_6EP ||
+	      ipu_ver == IPU_VER_6EP_MTL) ?
+		IPU6_ISYS_CSI_PORT_NUM : IPU6SE_ISYS_CSI_PORT_NUM;
+
+	/* Enable irqs for all MIPI ports */
+	for (i = 0; i < nr; i++)
+		irqs |= IPU_ISYS_UNISPART_IRQ_CSI2(i);
+
+	if (ipu_ver == IPU_VER_6EP_MTL) {
+		writel(irqs, base + IPU6V6_REG_ISYS_CSI_TOP_CTRL0_IRQ_EDGE);
+		writel(irqs, base + IPU6V6_REG_ISYS_CSI_TOP_CTRL0_IRQ_LEVEL_NOT_PULSE);
+		writel(0xffffffff, base + IPU6V6_REG_ISYS_CSI_TOP_CTRL0_IRQ_CLEAR);
+		writel(irqs, base + IPU6V6_REG_ISYS_CSI_TOP_CTRL0_IRQ_MASK);
+		writel(irqs, base + IPU6V6_REG_ISYS_CSI_TOP_CTRL0_IRQ_ENABLE);
+	} else {
+		writel(irqs, base + IPU_REG_ISYS_CSI_TOP_CTRL0_IRQ_EDGE);
+		writel(irqs, base + IPU_REG_ISYS_CSI_TOP_CTRL0_IRQ_LEVEL_NOT_PULSE);
+		writel(0xffffffff, base + IPU_REG_ISYS_CSI_TOP_CTRL0_IRQ_CLEAR);
+		writel(irqs, base + IPU_REG_ISYS_CSI_TOP_CTRL0_IRQ_MASK);
+		writel(irqs, base + IPU_REG_ISYS_CSI_TOP_CTRL0_IRQ_ENABLE);
+	}
+
+	irqs = ISYS_UNISPART_IRQS;
+	writel(irqs, base + IPU_REG_ISYS_UNISPART_IRQ_EDGE);
+	writel(irqs, base + IPU_REG_ISYS_UNISPART_IRQ_LEVEL_NOT_PULSE);
+	writel(0xffffffff, base + IPU_REG_ISYS_UNISPART_IRQ_CLEAR);
+	writel(irqs, base + IPU_REG_ISYS_UNISPART_IRQ_MASK);
+	writel(irqs, base + IPU_REG_ISYS_UNISPART_IRQ_ENABLE);
+
+	writel(0, base + IPU_REG_ISYS_UNISPART_SW_IRQ_REG);
+	writel(0, base + IPU_REG_ISYS_UNISPART_SW_IRQ_MUX_REG);
+
+	/* Write CDC FIFO threshold values for isys */
+	for (i = 0; i < isys->pdata->ipdata->hw_variant.cdc_fifos; i++)
+		writel(thd[i], base + IPU_REG_ISYS_CDC_THRESHOLD(i));
+}
+
+irqreturn_t isys_isr(struct ipu_bus_device *adev)
+{
+	struct ipu_isys *isys = ipu_bus_get_drvdata(adev);
+	void __iomem *base = isys->pdata->base;
+	u32 status_sw, status_csi;
+	u32 ctrl0_status, ctrl0_clear;
+
+	spin_lock(&isys->power_lock);
+	if (!isys->power) {
+		spin_unlock(&isys->power_lock);
+		return IRQ_NONE;
+	}
+
+	if (ipu_ver == IPU_VER_6EP_MTL) {
+		ctrl0_status = IPU6V6_REG_ISYS_CSI_TOP_CTRL0_IRQ_STATUS;
+		ctrl0_clear = IPU6V6_REG_ISYS_CSI_TOP_CTRL0_IRQ_CLEAR;
+	} else {
+		ctrl0_status = IPU_REG_ISYS_CSI_TOP_CTRL0_IRQ_STATUS;
+		ctrl0_clear = IPU_REG_ISYS_CSI_TOP_CTRL0_IRQ_CLEAR;
+	}
+
+	status_csi = readl(isys->pdata->base + ctrl0_status);
+	status_sw = readl(isys->pdata->base + IPU_REG_ISYS_UNISPART_IRQ_STATUS);
+
+	writel(ISYS_UNISPART_IRQS & ~IPU_ISYS_UNISPART_IRQ_SW,
+	       base + IPU_REG_ISYS_UNISPART_IRQ_MASK);
+
+	do {
+		writel(status_csi, isys->pdata->base + ctrl0_clear);
+
+		writel(status_sw, isys->pdata->base +
+			   IPU_REG_ISYS_UNISPART_IRQ_CLEAR);
+
+		if (isys->isr_csi2_bits & status_csi) {
+			unsigned int i;
+
+			for (i = 0; i < isys->pdata->ipdata->csi2.nports; i++) {
+				/* irq from not enabled port */
+				if (!isys->csi2[i].base)
+					continue;
+				if (status_csi & IPU_ISYS_UNISPART_IRQ_CSI2(i))
+					ipu_isys_csi2_isr(&isys->csi2[i]);
+			}
+		}
+
+		writel(0, base + IPU_REG_ISYS_UNISPART_SW_IRQ_REG);
+
+		if (!isys_isr_one(adev))
+			status_sw = IPU_ISYS_UNISPART_IRQ_SW;
+		else
+			status_sw = 0;
+
+		status_csi = readl(isys->pdata->base + ctrl0_status);
+		status_sw |= readl(isys->pdata->base +
+				   IPU_REG_ISYS_UNISPART_IRQ_STATUS);
+	} while (((status_csi & isys->isr_csi2_bits) ||
+		  (status_sw & IPU_ISYS_UNISPART_IRQ_SW)) &&
+		 !isys->adev->isp->flr_done);
+
+	writel(ISYS_UNISPART_IRQS, base + IPU_REG_ISYS_UNISPART_IRQ_MASK);
+
+	spin_unlock(&isys->power_lock);
+
+	return IRQ_HANDLED;
+}
+
Index: b/drivers/media/pci/intel/ipu6/ipu6-l-scheduler.c
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu6/ipu6-l-scheduler.c
@@ -0,0 +1,615 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) 2020 Intel Corporation
+
+#include "ipu-psys.h"
+#include "ipu6-ppg.h"
+
+extern bool enable_power_gating;
+
+struct sched_list {
+	struct list_head list;
+	/* to protect the list */
+	struct mutex lock;
+};
+
+static struct sched_list start_list = {
+	.list	= LIST_HEAD_INIT(start_list.list),
+	.lock	= __MUTEX_INITIALIZER(start_list.lock),
+};
+
+static struct sched_list stop_list = {
+	.list	= LIST_HEAD_INIT(stop_list.list),
+	.lock	= __MUTEX_INITIALIZER(stop_list.lock),
+};
+
+static struct sched_list *get_sc_list(enum SCHED_LIST type)
+{
+	/* for debug purposes */
+	WARN_ON(type != SCHED_START_LIST && type != SCHED_STOP_LIST);
+
+	if (type == SCHED_START_LIST)
+		return &start_list;
+	return &stop_list;
+}
+
+static bool is_kppg_in_list(struct ipu_psys_ppg *kppg, struct list_head *head)
+{
+	struct ipu_psys_ppg *tmp;
+
+	list_for_each_entry(tmp, head, sched_list) {
+		if (kppg == tmp)
+			return true;
+	}
+
+	return false;
+}
+
+void ipu_psys_scheduler_remove_kppg(struct ipu_psys_ppg *kppg,
+				    enum SCHED_LIST type)
+{
+	struct sched_list *sc_list = get_sc_list(type);
+	struct ipu_psys_ppg *tmp0, *tmp1;
+	struct ipu_psys *psys = kppg->fh->psys;
+
+	mutex_lock(&sc_list->lock);
+	list_for_each_entry_safe(tmp0, tmp1, &sc_list->list, sched_list) {
+		if (tmp0 == kppg) {
+			dev_dbg(&psys->adev->dev,
+				 "remove from %s list, kppg(%d 0x%p) state %d\n",
+				 type == SCHED_START_LIST ? "start" : "stop",
+				 kppg->kpg->pg->ID, kppg, kppg->state);
+			list_del_init(&kppg->sched_list);
+		}
+	}
+	mutex_unlock(&sc_list->lock);
+}
+
+void ipu_psys_scheduler_add_kppg(struct ipu_psys_ppg *kppg,
+				 enum SCHED_LIST type)
+{
+	int cur_pri = kppg->pri_base + kppg->pri_dynamic;
+	struct sched_list *sc_list = get_sc_list(type);
+	struct ipu_psys *psys = kppg->fh->psys;
+	struct ipu_psys_ppg *tmp0, *tmp1;
+
+	dev_dbg(&psys->adev->dev,
+		"add to %s list, kppg(%d 0x%p) state %d prio(%d %d) fh 0x%p\n",
+		type == SCHED_START_LIST ? "start" : "stop",
+		kppg->kpg->pg->ID, kppg, kppg->state,
+		kppg->pri_base, kppg->pri_dynamic, kppg->fh);
+
+	mutex_lock(&sc_list->lock);
+	if (list_empty(&sc_list->list)) {
+		list_add(&kppg->sched_list, &sc_list->list);
+		goto out;
+	}
+
+	if (is_kppg_in_list(kppg, &sc_list->list)) {
+		dev_dbg(&psys->adev->dev, "kppg already in list\n");
+		goto out;
+	}
+
+	list_for_each_entry_safe(tmp0, tmp1, &sc_list->list, sched_list) {
+		int tmp_pri = tmp0->pri_base + tmp0->pri_dynamic;
+
+		dev_dbg(&psys->adev->dev,
+			"found kppg(%d 0x%p), state %d pri(%d %d) fh 0x%p\n",
+			tmp0->kpg->pg->ID, tmp0, tmp0->state,
+			tmp0->pri_base, tmp0->pri_dynamic, tmp0->fh);
+
+		if (type == SCHED_START_LIST && tmp_pri > cur_pri) {
+			list_add(&kppg->sched_list, tmp0->sched_list.prev);
+			goto out;
+		} else if (type == SCHED_STOP_LIST && tmp_pri < cur_pri) {
+			list_add(&kppg->sched_list, tmp0->sched_list.prev);
+			goto out;
+		}
+	}
+
+	list_add_tail(&kppg->sched_list, &sc_list->list);
+out:
+	mutex_unlock(&sc_list->lock);
+}
+
+static int ipu_psys_detect_resource_contention(struct ipu_psys_ppg *kppg)
+{
+	struct ipu_psys_resource_pool *try_res_pool;
+	struct ipu_psys *psys = kppg->fh->psys;
+	int ret = 0;
+	int state;
+
+	try_res_pool = kzalloc(sizeof(*try_res_pool), GFP_KERNEL);
+	if (IS_ERR_OR_NULL(try_res_pool))
+		return -ENOMEM;
+
+	mutex_lock(&kppg->mutex);
+	state = kppg->state;
+	mutex_unlock(&kppg->mutex);
+	if (state == PPG_STATE_STARTED || state == PPG_STATE_RUNNING ||
+	    state == PPG_STATE_RESUMED)
+		goto exit;
+
+	ret = ipu_psys_resource_pool_init(try_res_pool);
+	if (ret < 0) {
+		dev_err(&psys->adev->dev, "unable to alloc pg resources\n");
+		WARN_ON(1);
+		goto exit;
+	}
+
+	ipu_psys_resource_copy(&psys->resource_pool_running, try_res_pool);
+	ret = ipu_psys_try_allocate_resources(&psys->adev->dev,
+					      kppg->kpg->pg,
+					      kppg->manifest,
+					      try_res_pool);
+
+	ipu_psys_resource_pool_cleanup(try_res_pool);
+exit:
+	kfree(try_res_pool);
+
+	return ret;
+}
+
+static void ipu_psys_scheduler_ppg_sort(struct ipu_psys *psys, bool *stopping)
+{
+	struct ipu_psys_ppg *kppg, *tmp;
+	struct ipu_psys_scheduler *sched;
+	struct ipu_psys_fh *fh;
+
+	list_for_each_entry(fh, &psys->fhs, list) {
+		mutex_lock(&fh->mutex);
+		sched = &fh->sched;
+
+		if (list_empty(&sched->ppgs)) {
+			mutex_unlock(&fh->mutex);
+			continue;
+		}
+
+		list_for_each_entry_safe(kppg, tmp, &sched->ppgs, list) {
+			mutex_lock(&kppg->mutex);
+			if (kppg->state == PPG_STATE_START ||
+			    kppg->state == PPG_STATE_RESUME) {
+				ipu_psys_scheduler_add_kppg(kppg,
+							    SCHED_START_LIST);
+			} else if (kppg->state == PPG_STATE_RUNNING) {
+				ipu_psys_scheduler_add_kppg(kppg,
+							    SCHED_STOP_LIST);
+			} else if (kppg->state == PPG_STATE_SUSPENDING ||
+				   kppg->state == PPG_STATE_STOPPING) {
+				/* there are some suspending/stopping ppgs */
+				*stopping = true;
+			} else if (kppg->state == PPG_STATE_RESUMING ||
+				   kppg->state == PPG_STATE_STARTING) {
+				   /* how about kppg are resuming/starting? */
+			}
+			mutex_unlock(&kppg->mutex);
+		}
+		mutex_unlock(&fh->mutex);
+	}
+}
+
+static void ipu_psys_scheduler_update_start_ppg_priority(void)
+{
+	struct sched_list *sc_list = get_sc_list(SCHED_START_LIST);
+	struct ipu_psys_ppg *kppg, *tmp;
+
+	mutex_lock(&sc_list->lock);
+	if (!list_empty(&sc_list->list))
+		list_for_each_entry_safe(kppg, tmp, &sc_list->list, sched_list)
+			kppg->pri_dynamic--;
+	mutex_unlock(&sc_list->lock);
+}
+
+static bool ipu_psys_scheduler_switch_ppg(struct ipu_psys *psys)
+{
+	struct sched_list *sc_list = get_sc_list(SCHED_STOP_LIST);
+	struct ipu_psys_ppg *kppg;
+	bool resched = false;
+
+	mutex_lock(&sc_list->lock);
+	if (list_empty(&sc_list->list)) {
+		/* some ppgs are RESUMING/STARTING */
+		dev_dbg(&psys->adev->dev, "no candidated stop ppg\n");
+		mutex_unlock(&sc_list->lock);
+		return false;
+	}
+	kppg = list_first_entry(&sc_list->list, struct ipu_psys_ppg,
+				sched_list);
+	mutex_unlock(&sc_list->lock);
+
+	mutex_lock(&kppg->mutex);
+	if (!(kppg->state & PPG_STATE_STOP)) {
+		dev_dbg(&psys->adev->dev, "s_change:%s: %p %d -> %d\n",
+			__func__, kppg, kppg->state, PPG_STATE_SUSPEND);
+		kppg->state = PPG_STATE_SUSPEND;
+		resched = true;
+	}
+	mutex_unlock(&kppg->mutex);
+
+	return resched;
+}
+
+/*
+ * search all kppgs and sort them into start_list and stop_list, alway start
+ * first kppg(high priority) in start_list;
+ * if there is resource contention, it would switch kppgs in stop_list
+ * to suspend state one by one
+ */
+static bool ipu_psys_scheduler_ppg_start(struct ipu_psys *psys)
+{
+	struct sched_list *sc_list = get_sc_list(SCHED_START_LIST);
+	struct ipu_psys_ppg *kppg, *kppg0;
+	bool stopping_existed = false;
+	int ret;
+
+	ipu_psys_scheduler_ppg_sort(psys, &stopping_existed);
+
+	mutex_lock(&sc_list->lock);
+	if (list_empty(&sc_list->list)) {
+		dev_dbg(&psys->adev->dev, "no ppg to start\n");
+		mutex_unlock(&sc_list->lock);
+		return false;
+	}
+
+	list_for_each_entry_safe(kppg, kppg0,
+				 &sc_list->list, sched_list) {
+		mutex_unlock(&sc_list->lock);
+
+		ret = ipu_psys_detect_resource_contention(kppg);
+		if (ret < 0) {
+			dev_dbg(&psys->adev->dev,
+				"ppg %d resource detect failed(%d)\n",
+				kppg->kpg->pg->ID, ret);
+			/*
+			 * switch out other ppg in 2 cases:
+			 * 1. resource contention
+			 * 2. no suspending/stopping ppg
+			 */
+			if (ret == -ENOSPC) {
+				if (!stopping_existed &&
+				    ipu_psys_scheduler_switch_ppg(psys)) {
+					return true;
+				}
+				dev_dbg(&psys->adev->dev,
+					"ppg is suspending/stopping\n");
+			} else {
+				dev_err(&psys->adev->dev,
+					"detect resource error %d\n", ret);
+			}
+		} else {
+			kppg->pri_dynamic = 0;
+
+			mutex_lock(&kppg->mutex);
+			if (kppg->state == PPG_STATE_START)
+				ipu_psys_ppg_start(kppg);
+			else
+				ipu_psys_ppg_resume(kppg);
+			mutex_unlock(&kppg->mutex);
+
+			ipu_psys_scheduler_remove_kppg(kppg,
+						       SCHED_START_LIST);
+			ipu_psys_scheduler_update_start_ppg_priority();
+		}
+		mutex_lock(&sc_list->lock);
+	}
+	mutex_unlock(&sc_list->lock);
+
+	return false;
+}
+
+static bool ipu_psys_scheduler_ppg_enqueue_bufset(struct ipu_psys *psys)
+{
+	struct ipu_psys_scheduler *sched;
+	struct ipu_psys_ppg *kppg;
+	struct ipu_psys_fh *fh;
+	bool resched = false;
+
+	list_for_each_entry(fh, &psys->fhs, list) {
+		mutex_lock(&fh->mutex);
+		sched = &fh->sched;
+		if (list_empty(&sched->ppgs)) {
+			mutex_unlock(&fh->mutex);
+			continue;
+		}
+
+		list_for_each_entry(kppg, &sched->ppgs, list) {
+			if (ipu_psys_ppg_enqueue_bufsets(kppg))
+				resched = true;
+		}
+		mutex_unlock(&fh->mutex);
+	}
+
+	return resched;
+}
+
+/*
+ * This function will check all kppgs within fhs, and if kppg state
+ * is STOP or SUSPEND, l-scheduler will call ppg function to stop
+ * or suspend it and update stop list
+ */
+
+static bool ipu_psys_scheduler_ppg_halt(struct ipu_psys *psys)
+{
+	struct ipu_psys_scheduler *sched;
+	struct ipu_psys_ppg *kppg, *tmp;
+	struct ipu_psys_fh *fh;
+	bool stopping_exit = false;
+
+	list_for_each_entry(fh, &psys->fhs, list) {
+		mutex_lock(&fh->mutex);
+		sched = &fh->sched;
+		if (list_empty(&sched->ppgs)) {
+			mutex_unlock(&fh->mutex);
+			continue;
+		}
+
+		list_for_each_entry_safe(kppg, tmp, &sched->ppgs, list) {
+			mutex_lock(&kppg->mutex);
+			if (kppg->state & PPG_STATE_STOP) {
+				ipu_psys_ppg_stop(kppg);
+				ipu_psys_scheduler_remove_kppg(kppg,
+							       SCHED_STOP_LIST);
+			} else if (kppg->state == PPG_STATE_SUSPEND) {
+				ipu_psys_ppg_suspend(kppg);
+				ipu_psys_scheduler_remove_kppg(kppg,
+							       SCHED_STOP_LIST);
+			} else if (kppg->state == PPG_STATE_SUSPENDING ||
+				   kppg->state == PPG_STATE_STOPPING) {
+				stopping_exit = true;
+			}
+			mutex_unlock(&kppg->mutex);
+		}
+		mutex_unlock(&fh->mutex);
+	}
+	return stopping_exit;
+}
+
+static void ipu_psys_update_ppg_state_by_kcmd(struct ipu_psys *psys,
+					      struct ipu_psys_ppg *kppg,
+					      struct ipu_psys_kcmd *kcmd)
+{
+	int old_ppg_state = kppg->state;
+
+	/*
+	 * Respond kcmd when ppg is in stable state:
+	 * STARTED/RESUMED/RUNNING/SUSPENDED/STOPPED
+	 */
+	if (kppg->state == PPG_STATE_STARTED ||
+	    kppg->state == PPG_STATE_RESUMED ||
+	    kppg->state == PPG_STATE_RUNNING) {
+		if (kcmd->state == KCMD_STATE_PPG_START)
+			ipu_psys_kcmd_complete(kppg, kcmd, 0);
+		else if (kcmd->state == KCMD_STATE_PPG_STOP)
+			kppg->state = PPG_STATE_STOP;
+	} else if (kppg->state == PPG_STATE_SUSPENDED) {
+		if (kcmd->state == KCMD_STATE_PPG_START)
+			ipu_psys_kcmd_complete(kppg, kcmd, 0);
+		else if (kcmd->state == KCMD_STATE_PPG_STOP)
+			/*
+			 * Record the previous state
+			 * because here need resume at first
+			 */
+			kppg->state |= PPG_STATE_STOP;
+		else if (kcmd->state == KCMD_STATE_PPG_ENQUEUE)
+			kppg->state = PPG_STATE_RESUME;
+	} else if (kppg->state == PPG_STATE_STOPPED) {
+		if (kcmd->state == KCMD_STATE_PPG_START)
+			kppg->state = PPG_STATE_START;
+		else if (kcmd->state == KCMD_STATE_PPG_STOP)
+			ipu_psys_kcmd_complete(kppg, kcmd, 0);
+		else if (kcmd->state == KCMD_STATE_PPG_ENQUEUE) {
+			dev_err(&psys->adev->dev, "ppg %p stopped!\n", kppg);
+			ipu_psys_kcmd_complete(kppg, kcmd, -EIO);
+		}
+	}
+
+	if (old_ppg_state != kppg->state)
+		dev_dbg(&psys->adev->dev, "s_change:%s: %p %d -> %d\n",
+			__func__, kppg, old_ppg_state, kppg->state);
+}
+
+static void ipu_psys_scheduler_kcmd_set(struct ipu_psys *psys)
+{
+	struct ipu_psys_kcmd *kcmd;
+	struct ipu_psys_scheduler *sched;
+	struct ipu_psys_ppg *kppg, *tmp;
+	struct ipu_psys_fh *fh;
+
+	list_for_each_entry(fh, &psys->fhs, list) {
+		mutex_lock(&fh->mutex);
+		sched = &fh->sched;
+		if (list_empty(&sched->ppgs)) {
+			mutex_unlock(&fh->mutex);
+			continue;
+		}
+
+		list_for_each_entry_safe(kppg, tmp, &sched->ppgs, list) {
+			mutex_lock(&kppg->mutex);
+			if (list_empty(&kppg->kcmds_new_list)) {
+				mutex_unlock(&kppg->mutex);
+				continue;
+			};
+
+			kcmd = list_first_entry(&kppg->kcmds_new_list,
+						struct ipu_psys_kcmd, list);
+			ipu_psys_update_ppg_state_by_kcmd(psys, kppg, kcmd);
+			mutex_unlock(&kppg->mutex);
+		}
+		mutex_unlock(&fh->mutex);
+	}
+}
+
+static bool is_ready_to_enter_power_gating(struct ipu_psys *psys)
+{
+	struct ipu_psys_scheduler *sched;
+	struct ipu_psys_ppg *kppg, *tmp;
+	struct ipu_psys_fh *fh;
+
+	list_for_each_entry(fh, &psys->fhs, list) {
+		mutex_lock(&fh->mutex);
+		sched = &fh->sched;
+		if (list_empty(&sched->ppgs)) {
+			mutex_unlock(&fh->mutex);
+			continue;
+		}
+
+		list_for_each_entry_safe(kppg, tmp, &sched->ppgs, list) {
+			mutex_lock(&kppg->mutex);
+			if (!list_empty(&kppg->kcmds_new_list) ||
+			    !list_empty(&kppg->kcmds_processing_list)) {
+				mutex_unlock(&kppg->mutex);
+				mutex_unlock(&fh->mutex);
+				return false;
+			}
+			if (!(kppg->state == PPG_STATE_RUNNING ||
+			      kppg->state == PPG_STATE_STOPPED ||
+			      kppg->state == PPG_STATE_SUSPENDED)) {
+				mutex_unlock(&kppg->mutex);
+				mutex_unlock(&fh->mutex);
+				return false;
+			}
+			mutex_unlock(&kppg->mutex);
+		}
+		mutex_unlock(&fh->mutex);
+	}
+
+	return true;
+}
+
+static bool has_pending_kcmd(struct ipu_psys *psys)
+{
+	struct ipu_psys_scheduler *sched;
+	struct ipu_psys_ppg *kppg, *tmp;
+	struct ipu_psys_fh *fh;
+
+	list_for_each_entry(fh, &psys->fhs, list) {
+		mutex_lock(&fh->mutex);
+		sched = &fh->sched;
+		if (list_empty(&sched->ppgs)) {
+			mutex_unlock(&fh->mutex);
+			continue;
+		}
+
+		list_for_each_entry_safe(kppg, tmp, &sched->ppgs, list) {
+			mutex_lock(&kppg->mutex);
+			if (!list_empty(&kppg->kcmds_new_list) ||
+			    !list_empty(&kppg->kcmds_processing_list)) {
+				mutex_unlock(&kppg->mutex);
+				mutex_unlock(&fh->mutex);
+				return true;
+			}
+			mutex_unlock(&kppg->mutex);
+		}
+		mutex_unlock(&fh->mutex);
+	}
+
+	return false;
+}
+
+static bool ipu_psys_scheduler_exit_power_gating(struct ipu_psys *psys)
+{
+	/* Assume power gating process can be aborted directly during START */
+	if (psys->power_gating == PSYS_POWER_GATED) {
+		dev_dbg(&psys->adev->dev, "powergating: exit ---\n");
+		ipu_psys_exit_power_gating(psys);
+	}
+	psys->power_gating = PSYS_POWER_NORMAL;
+	return false;
+}
+
+static bool ipu_psys_scheduler_enter_power_gating(struct ipu_psys *psys)
+{
+	struct ipu_psys_scheduler *sched;
+	struct ipu_psys_ppg *kppg, *tmp;
+	struct ipu_psys_fh *fh;
+
+	if (!enable_power_gating)
+		return false;
+
+	if (psys->power_gating == PSYS_POWER_NORMAL &&
+	    is_ready_to_enter_power_gating(psys)) {
+		/* Enter power gating */
+		dev_dbg(&psys->adev->dev, "powergating: enter +++\n");
+		psys->power_gating = PSYS_POWER_GATING;
+	}
+
+	if (psys->power_gating != PSYS_POWER_GATING)
+		return false;
+
+	/* Suspend ppgs one by one */
+	list_for_each_entry(fh, &psys->fhs, list) {
+		mutex_lock(&fh->mutex);
+		sched = &fh->sched;
+		if (list_empty(&sched->ppgs)) {
+			mutex_unlock(&fh->mutex);
+			continue;
+		}
+
+		list_for_each_entry_safe(kppg, tmp, &sched->ppgs, list) {
+			mutex_lock(&kppg->mutex);
+			if (kppg->state == PPG_STATE_RUNNING) {
+				kppg->state = PPG_STATE_SUSPEND;
+				mutex_unlock(&kppg->mutex);
+				mutex_unlock(&fh->mutex);
+				return true;
+			}
+
+			if (kppg->state != PPG_STATE_SUSPENDED &&
+			    kppg->state != PPG_STATE_STOPPED) {
+				/* Can't enter power gating */
+				mutex_unlock(&kppg->mutex);
+				mutex_unlock(&fh->mutex);
+				/* Need re-run l-scheduler to suspend ppg? */
+				return (kppg->state & PPG_STATE_STOP ||
+					kppg->state == PPG_STATE_SUSPEND);
+			}
+			mutex_unlock(&kppg->mutex);
+		}
+		mutex_unlock(&fh->mutex);
+	}
+
+	psys->power_gating = PSYS_POWER_GATED;
+	ipu_psys_enter_power_gating(psys);
+
+	return false;
+}
+
+void ipu_psys_run_next(struct ipu_psys *psys)
+{
+	/* Wake up scheduler due to unfinished work */
+	bool need_trigger = false;
+	/* Wait FW callback if there are stopping/suspending/running ppg */
+	bool wait_fw_finish = false;
+	/*
+	 * Code below will crash if fhs is empty. Normally this
+	 * shouldn't happen.
+	 */
+	if (list_empty(&psys->fhs)) {
+		WARN_ON(1);
+		return;
+	}
+
+	/* Abort power gating process */
+	if (psys->power_gating != PSYS_POWER_NORMAL &&
+	    has_pending_kcmd(psys))
+		need_trigger = ipu_psys_scheduler_exit_power_gating(psys);
+
+	/* Handle kcmd and related ppg switch */
+	if (psys->power_gating == PSYS_POWER_NORMAL) {
+		ipu_psys_scheduler_kcmd_set(psys);
+		wait_fw_finish = ipu_psys_scheduler_ppg_halt(psys);
+		need_trigger |= ipu_psys_scheduler_ppg_start(psys);
+		need_trigger |= ipu_psys_scheduler_ppg_enqueue_bufset(psys);
+	}
+	if (!(need_trigger || wait_fw_finish)) {
+		/* Nothing to do, enter power gating */
+		need_trigger = ipu_psys_scheduler_enter_power_gating(psys);
+		if (psys->power_gating == PSYS_POWER_GATING)
+			wait_fw_finish = ipu_psys_scheduler_ppg_halt(psys);
+	}
+
+	if (need_trigger && !wait_fw_finish) {
+		dev_dbg(&psys->adev->dev, "scheduler: wake up\n");
+		atomic_set(&psys->wakeup_count, 1);
+		wake_up_interruptible(&psys->sched_cmd_wq);
+	}
+}
Index: b/drivers/media/pci/intel/ipu6/ipu6-platform-resources.h
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu6/ipu6-platform-resources.h
@@ -0,0 +1,196 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2018 - 2020 Intel Corporation */
+
+#ifndef IPU6_PLATFORM_RESOURCES_H
+#define IPU6_PLATFORM_RESOURCES_H
+
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include "ipu-platform-resources.h"
+
+#define	IPU6_FW_PSYS_N_PADDING_UINT8_IN_PROCESS_EXT_STRUCT		0
+
+enum {
+	IPU6_FW_PSYS_CMD_QUEUE_COMMAND_ID = 0,
+	IPU6_FW_PSYS_CMD_QUEUE_DEVICE_ID,
+	IPU6_FW_PSYS_CMD_QUEUE_PPG0_COMMAND_ID,
+	IPU6_FW_PSYS_CMD_QUEUE_PPG1_COMMAND_ID,
+	IPU6_FW_PSYS_CMD_QUEUE_PPG2_COMMAND_ID,
+	IPU6_FW_PSYS_CMD_QUEUE_PPG3_COMMAND_ID,
+	IPU6_FW_PSYS_CMD_QUEUE_PPG4_COMMAND_ID,
+	IPU6_FW_PSYS_CMD_QUEUE_PPG5_COMMAND_ID,
+	IPU6_FW_PSYS_CMD_QUEUE_PPG6_COMMAND_ID,
+	IPU6_FW_PSYS_CMD_QUEUE_PPG7_COMMAND_ID,
+	IPU6_FW_PSYS_CMD_QUEUE_PPG8_COMMAND_ID,
+	IPU6_FW_PSYS_CMD_QUEUE_PPG9_COMMAND_ID,
+	IPU6_FW_PSYS_CMD_QUEUE_PPG10_COMMAND_ID,
+	IPU6_FW_PSYS_CMD_QUEUE_PPG11_COMMAND_ID,
+	IPU6_FW_PSYS_CMD_QUEUE_PPG12_COMMAND_ID,
+	IPU6_FW_PSYS_CMD_QUEUE_PPG13_COMMAND_ID,
+	IPU6_FW_PSYS_CMD_QUEUE_PPG14_COMMAND_ID,
+	IPU6_FW_PSYS_CMD_QUEUE_PPG15_COMMAND_ID,
+	IPU6_FW_PSYS_CMD_QUEUE_PPG16_COMMAND_ID,
+	IPU6_FW_PSYS_CMD_QUEUE_PPG17_COMMAND_ID,
+	IPU6_FW_PSYS_CMD_QUEUE_PPG18_COMMAND_ID,
+	IPU6_FW_PSYS_CMD_QUEUE_PPG19_COMMAND_ID,
+	IPU6_FW_PSYS_CMD_QUEUE_PPG20_COMMAND_ID,
+	IPU6_FW_PSYS_CMD_QUEUE_PPG21_COMMAND_ID,
+	IPU6_FW_PSYS_CMD_QUEUE_PPG22_COMMAND_ID,
+	IPU6_FW_PSYS_CMD_QUEUE_PPG23_COMMAND_ID,
+	IPU6_FW_PSYS_CMD_QUEUE_PPG24_COMMAND_ID,
+	IPU6_FW_PSYS_CMD_QUEUE_PPG25_COMMAND_ID,
+	IPU6_FW_PSYS_CMD_QUEUE_PPG26_COMMAND_ID,
+	IPU6_FW_PSYS_CMD_QUEUE_PPG27_COMMAND_ID,
+	IPU6_FW_PSYS_CMD_QUEUE_PPG28_COMMAND_ID,
+	IPU6_FW_PSYS_CMD_QUEUE_PPG29_COMMAND_ID,
+	IPU6_FW_PSYS_N_PSYS_CMD_QUEUE_ID
+};
+
+enum {
+	IPU6_FW_PSYS_TRANSFER_VMEM0_TYPE_ID = 0,
+	IPU6_FW_PSYS_TRANSFER_VMEM1_TYPE_ID,
+	IPU6_FW_PSYS_LB_VMEM_TYPE_ID,
+	IPU6_FW_PSYS_DMEM_TYPE_ID,
+	IPU6_FW_PSYS_VMEM_TYPE_ID,
+	IPU6_FW_PSYS_BAMEM_TYPE_ID,
+	IPU6_FW_PSYS_PMEM_TYPE_ID,
+	IPU6_FW_PSYS_N_MEM_TYPE_ID
+};
+
+enum ipu6_mem_id {
+	IPU6_FW_PSYS_VMEM0_ID = 0,	/* ISP0 VMEM */
+	IPU6_FW_PSYS_TRANSFER_VMEM0_ID,	/* TRANSFER VMEM 0 */
+	IPU6_FW_PSYS_TRANSFER_VMEM1_ID,	/* TRANSFER VMEM 1 */
+	IPU6_FW_PSYS_LB_VMEM_ID,	/* LB VMEM */
+	IPU6_FW_PSYS_BAMEM0_ID,	/* ISP0 BAMEM */
+	IPU6_FW_PSYS_DMEM0_ID,	/* SPC0 Dmem */
+	IPU6_FW_PSYS_DMEM1_ID,	/* SPP0 Dmem */
+	IPU6_FW_PSYS_DMEM2_ID,	/* SPP1 Dmem */
+	IPU6_FW_PSYS_DMEM3_ID,	/* ISP0 Dmem */
+	IPU6_FW_PSYS_PMEM0_ID,	/* ISP0 PMEM */
+	IPU6_FW_PSYS_N_MEM_ID
+};
+
+enum {
+	IPU6_FW_PSYS_DEV_CHN_DMA_EXT0_ID = 0,
+	IPU6_FW_PSYS_DEV_CHN_DMA_EXT1_READ_ID,
+	IPU6_FW_PSYS_DEV_CHN_DMA_EXT1_WRITE_ID,
+	IPU6_FW_PSYS_DEV_CHN_DMA_INTERNAL_ID,
+	IPU6_FW_PSYS_DEV_CHN_DMA_ISA_ID,
+	IPU6_FW_PSYS_N_DEV_CHN_ID
+};
+
+enum {
+	IPU6_FW_PSYS_SP_CTRL_TYPE_ID = 0,
+	IPU6_FW_PSYS_SP_SERVER_TYPE_ID,
+	IPU6_FW_PSYS_VP_TYPE_ID,
+	IPU6_FW_PSYS_ACC_PSA_TYPE_ID,
+	IPU6_FW_PSYS_ACC_ISA_TYPE_ID,
+	IPU6_FW_PSYS_ACC_OSA_TYPE_ID,
+	IPU6_FW_PSYS_GDC_TYPE_ID,
+	IPU6_FW_PSYS_TNR_TYPE_ID,
+	IPU6_FW_PSYS_N_CELL_TYPE_ID
+};
+
+enum {
+	IPU6_FW_PSYS_SP0_ID = 0,
+	IPU6_FW_PSYS_VP0_ID,
+	IPU6_FW_PSYS_PSA_ACC_BNLM_ID,
+	IPU6_FW_PSYS_PSA_ACC_DM_ID,
+	IPU6_FW_PSYS_PSA_ACC_ACM_ID,
+	IPU6_FW_PSYS_PSA_ACC_GTC_YUV1_ID,
+	IPU6_FW_PSYS_BB_ACC_OFS_PIN_MAIN_ID,
+	IPU6_FW_PSYS_BB_ACC_OFS_PIN_DISPLAY_ID,
+	IPU6_FW_PSYS_BB_ACC_OFS_PIN_PP_ID,
+	IPU6_FW_PSYS_PSA_ACC_GAMMASTAR_ID,
+	IPU6_FW_PSYS_PSA_ACC_GLTM_ID,
+	IPU6_FW_PSYS_PSA_ACC_XNR_ID,
+	IPU6_FW_PSYS_PSA_VCSC_ID,	/* VCSC */
+	IPU6_FW_PSYS_ISA_ICA_ID,
+	IPU6_FW_PSYS_ISA_LSC_ID,
+	IPU6_FW_PSYS_ISA_DPC_ID,
+	IPU6_FW_PSYS_ISA_SIS_A_ID,
+	IPU6_FW_PSYS_ISA_SIS_B_ID,
+	IPU6_FW_PSYS_ISA_B2B_ID,
+	IPU6_FW_PSYS_ISA_B2R_R2I_SIE_ID,
+	IPU6_FW_PSYS_ISA_R2I_DS_A_ID,
+	IPU6_FW_PSYS_ISA_R2I_DS_B_ID,
+	IPU6_FW_PSYS_ISA_AWB_ID,
+	IPU6_FW_PSYS_ISA_AE_ID,
+	IPU6_FW_PSYS_ISA_AF_ID,
+	IPU6_FW_PSYS_ISA_DOL_ID,
+	IPU6_FW_PSYS_ISA_ICA_MEDIUM_ID,
+	IPU6_FW_PSYS_ISA_X2B_MD_ID,
+	IPU6_FW_PSYS_ISA_X2B_SVE_RGBIR_ID,
+	IPU6_FW_PSYS_ISA_PAF_ID,
+	IPU6_FW_PSYS_BB_ACC_GDC0_ID,
+	IPU6_FW_PSYS_BB_ACC_TNR_ID,
+	IPU6_FW_PSYS_N_CELL_ID
+};
+
+enum {
+	IPU6_FW_PSYS_DEV_DFM_BB_FULL_PORT_ID = 0,
+	IPU6_FW_PSYS_DEV_DFM_BB_EMPTY_PORT_ID,
+	IPU6_FW_PSYS_DEV_DFM_ISL_FULL_PORT_ID,
+	IPU6_FW_PSYS_DEV_DFM_ISL_EMPTY_PORT_ID,
+	IPU6_FW_PSYS_DEV_DFM_LB_FULL_PORT_ID,
+	IPU6_FW_PSYS_DEV_DFM_LB_EMPTY_PORT_ID,
+};
+
+/* Excluding PMEM */
+#define IPU6_FW_PSYS_N_DATA_MEM_TYPE_ID	(IPU6_FW_PSYS_N_MEM_TYPE_ID - 1)
+#define IPU6_FW_PSYS_N_DEV_DFM_ID	\
+	(IPU6_FW_PSYS_DEV_DFM_LB_EMPTY_PORT_ID + 1)
+
+#define IPU6_FW_PSYS_VMEM0_MAX_SIZE		0x0800
+/* Transfer VMEM0 words, ref HAS Transfer*/
+#define IPU6_FW_PSYS_TRANSFER_VMEM0_MAX_SIZE	0x0800
+/* Transfer VMEM1 words, ref HAS Transfer*/
+#define IPU6_FW_PSYS_TRANSFER_VMEM1_MAX_SIZE	0x0800
+#define IPU6_FW_PSYS_LB_VMEM_MAX_SIZE		0x0400	/* LB VMEM words */
+#define IPU6_FW_PSYS_BAMEM0_MAX_SIZE		0x0800
+#define IPU6_FW_PSYS_DMEM0_MAX_SIZE		0x4000
+#define IPU6_FW_PSYS_DMEM1_MAX_SIZE		0x1000
+#define IPU6_FW_PSYS_DMEM2_MAX_SIZE		0x1000
+#define IPU6_FW_PSYS_DMEM3_MAX_SIZE		0x1000
+#define IPU6_FW_PSYS_PMEM0_MAX_SIZE		0x0500
+
+#define IPU6_FW_PSYS_DEV_CHN_DMA_EXT0_MAX_SIZE		30
+#define IPU6_FW_PSYS_DEV_CHN_GDC_MAX_SIZE		0
+#define IPU6_FW_PSYS_DEV_CHN_DMA_EXT1_READ_MAX_SIZE	30
+#define IPU6_FW_PSYS_DEV_CHN_DMA_EXT1_WRITE_MAX_SIZE	43
+#define IPU6_FW_PSYS_DEV_CHN_DMA_INTERNAL_MAX_SIZE	8
+#define IPU6_FW_PSYS_DEV_CHN_DMA_IPFD_MAX_SIZE		0
+#define IPU6_FW_PSYS_DEV_CHN_DMA_ISA_MAX_SIZE		2
+
+#define IPU6_FW_PSYS_DEV_DFM_BB_FULL_PORT_ID_MAX_SIZE		32
+#define IPU6_FW_PSYS_DEV_DFM_ISL_FULL_PORT_ID_MAX_SIZE		32
+#define IPU6_FW_PSYS_DEV_DFM_LB_FULL_PORT_ID_MAX_SIZE		32
+#define IPU6_FW_PSYS_DEV_DFM_BB_EMPTY_PORT_ID_MAX_SIZE		32
+#define IPU6_FW_PSYS_DEV_DFM_ISL_EMPTY_PORT_ID_MAX_SIZE		32
+#define IPU6_FW_PSYS_DEV_DFM_LB_EMPTY_PORT_ID_MAX_SIZE		32
+
+struct ipu6_fw_psys_program_manifest_ext {
+	u32 dfm_port_bitmap[IPU6_FW_PSYS_N_DEV_DFM_ID];
+	u32 dfm_active_port_bitmap[IPU6_FW_PSYS_N_DEV_DFM_ID];
+	u16 ext_mem_size[IPU6_FW_PSYS_N_DATA_MEM_TYPE_ID];
+	u16 ext_mem_offset[IPU6_FW_PSYS_N_DATA_MEM_TYPE_ID];
+	u16 dev_chn_size[IPU6_FW_PSYS_N_DEV_CHN_ID];
+	u16 dev_chn_offset[IPU6_FW_PSYS_N_DEV_CHN_ID];
+	u8 is_dfm_relocatable[IPU6_FW_PSYS_N_DEV_DFM_ID];
+	u8 dec_resources_input[IPU_FW_PSYS_MAX_INPUT_DEC_RESOURCES];
+	u8 dec_resources_input_terminal[IPU_FW_PSYS_MAX_INPUT_DEC_RESOURCES];
+	u8 dec_resources_output[IPU_FW_PSYS_MAX_OUTPUT_DEC_RESOURCES];
+	u8 dec_resources_output_terminal[IPU_FW_PSYS_MAX_OUTPUT_DEC_RESOURCES];
+	u8 padding[IPU_FW_PSYS_N_PADDING_UINT8_IN_PROGRAM_MANIFEST_EXT];
+};
+
+struct ipu6_fw_psys_process_ext {
+	u32 dfm_port_bitmap[IPU6_FW_PSYS_N_DEV_DFM_ID];
+	u32 dfm_active_port_bitmap[IPU6_FW_PSYS_N_DEV_DFM_ID];
+	u16 ext_mem_offset[IPU6_FW_PSYS_N_DATA_MEM_TYPE_ID];
+	u16 dev_chn_offset[IPU6_FW_PSYS_N_DEV_CHN_ID];
+	u8 ext_mem_id[IPU6_FW_PSYS_N_DATA_MEM_TYPE_ID];
+};
+
+#endif /* IPU6_PLATFORM_RESOURCES_H */
Index: b/drivers/media/pci/intel/ipu6/ipu6-ppg.c
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu6/ipu6-ppg.c
@@ -0,0 +1,560 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) 2020 Intel Corporation
+
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+
+#include <asm/cacheflush.h>
+
+#include "ipu6-ppg.h"
+
+static bool enable_suspend_resume;
+module_param(enable_suspend_resume, bool, 0664);
+MODULE_PARM_DESC(enable_suspend_resume, "enable fw ppg suspend/resume api");
+
+static struct ipu_psys_kcmd *
+ipu_psys_ppg_get_kcmd(struct ipu_psys_ppg *kppg, enum ipu_psys_cmd_state state)
+{
+	struct ipu_psys_kcmd *kcmd;
+
+	if (list_empty(&kppg->kcmds_new_list))
+		return NULL;
+
+	list_for_each_entry(kcmd, &kppg->kcmds_new_list, list) {
+		if (kcmd->state == state)
+			return kcmd;
+	}
+
+	return NULL;
+}
+
+struct ipu_psys_kcmd *ipu_psys_ppg_get_stop_kcmd(struct ipu_psys_ppg *kppg)
+{
+	struct ipu_psys_kcmd *kcmd;
+
+	WARN(!mutex_is_locked(&kppg->mutex), "ppg locking error");
+
+	if (list_empty(&kppg->kcmds_processing_list))
+		return NULL;
+
+	list_for_each_entry(kcmd, &kppg->kcmds_processing_list, list) {
+		if (kcmd->state == KCMD_STATE_PPG_STOP)
+			return kcmd;
+	}
+
+	return NULL;
+}
+
+static struct ipu_psys_buffer_set *
+__get_buf_set(struct ipu_psys_fh *fh, size_t buf_set_size)
+{
+	struct ipu_psys_buffer_set *kbuf_set;
+	struct ipu_psys_scheduler *sched = &fh->sched;
+
+	mutex_lock(&sched->bs_mutex);
+	list_for_each_entry(kbuf_set, &sched->buf_sets, list) {
+		if (!kbuf_set->buf_set_size &&
+		    kbuf_set->size >= buf_set_size) {
+			kbuf_set->buf_set_size = buf_set_size;
+			mutex_unlock(&sched->bs_mutex);
+			return kbuf_set;
+		}
+	}
+
+	mutex_unlock(&sched->bs_mutex);
+	/* no suitable buffer available, allocate new one */
+	kbuf_set = kzalloc(sizeof(*kbuf_set), GFP_KERNEL);
+	if (!kbuf_set)
+		return NULL;
+
+	kbuf_set->kaddr = dma_alloc_attrs(&fh->psys->adev->dev,
+					  buf_set_size, &kbuf_set->dma_addr,
+					  GFP_KERNEL, 0);
+	if (!kbuf_set->kaddr) {
+		kfree(kbuf_set);
+		return NULL;
+	}
+
+	kbuf_set->buf_set_size = buf_set_size;
+	kbuf_set->size = buf_set_size;
+	mutex_lock(&sched->bs_mutex);
+	list_add(&kbuf_set->list, &sched->buf_sets);
+	mutex_unlock(&sched->bs_mutex);
+
+	return kbuf_set;
+}
+
+static struct ipu_psys_buffer_set *
+ipu_psys_create_buffer_set(struct ipu_psys_kcmd *kcmd,
+			   struct ipu_psys_ppg *kppg)
+{
+	struct ipu_psys_fh *fh = kcmd->fh;
+	struct ipu_psys *psys = fh->psys;
+	struct ipu_psys_buffer_set *kbuf_set;
+	size_t buf_set_size;
+	u32 *keb;
+
+	buf_set_size = ipu_fw_psys_ppg_get_buffer_set_size(kcmd);
+
+	kbuf_set = __get_buf_set(fh, buf_set_size);
+	if (!kbuf_set) {
+		dev_err(&psys->adev->dev, "failed to create buffer set\n");
+		return NULL;
+	}
+
+	kbuf_set->buf_set = ipu_fw_psys_ppg_create_buffer_set(kcmd,
+							      kbuf_set->kaddr,
+							      0);
+
+	ipu_fw_psys_ppg_buffer_set_vaddress(kbuf_set->buf_set,
+					    kbuf_set->dma_addr);
+	keb = kcmd->kernel_enable_bitmap;
+	ipu_fw_psys_ppg_buffer_set_set_kernel_enable_bitmap(kbuf_set->buf_set,
+							    keb);
+
+	return kbuf_set;
+}
+
+int ipu_psys_ppg_get_bufset(struct ipu_psys_kcmd *kcmd,
+			    struct ipu_psys_ppg *kppg)
+{
+	struct ipu_psys *psys = kppg->fh->psys;
+	struct ipu_psys_buffer_set *kbuf_set;
+	unsigned int i;
+	int ret;
+
+	kbuf_set = ipu_psys_create_buffer_set(kcmd, kppg);
+	if (!kbuf_set) {
+		ret = -EINVAL;
+		goto error;
+	}
+	kcmd->kbuf_set = kbuf_set;
+	kbuf_set->kcmd = kcmd;
+
+	for (i = 0; i < kcmd->nbuffers; i++) {
+		struct ipu_fw_psys_terminal *terminal;
+		u32 buffer;
+
+		terminal = ipu_fw_psys_pg_get_terminal(kcmd, i);
+		if (!terminal)
+			continue;
+
+		buffer = (u32)kcmd->kbufs[i]->dma_addr +
+				    kcmd->buffers[i].data_offset;
+
+		ret = ipu_fw_psys_ppg_set_buffer_set(kcmd, terminal, i, buffer);
+		if (ret) {
+			dev_err(&psys->adev->dev, "Unable to set bufset\n");
+			goto error;
+		}
+	}
+
+	return 0;
+
+error:
+	dev_err(&psys->adev->dev, "failed to get buffer set\n");
+	return ret;
+}
+
+void ipu_psys_ppg_complete(struct ipu_psys *psys, struct ipu_psys_ppg *kppg)
+{
+	u8 queue_id;
+	int old_ppg_state;
+
+	if (!psys || !kppg)
+		return;
+
+	mutex_lock(&kppg->mutex);
+	old_ppg_state = kppg->state;
+	if (kppg->state == PPG_STATE_STOPPING) {
+		struct ipu_psys_kcmd tmp_kcmd = {
+			.kpg = kppg->kpg,
+		};
+
+		kppg->state = PPG_STATE_STOPPED;
+		ipu_psys_free_resources(&kppg->kpg->resource_alloc,
+					&psys->resource_pool_running);
+		queue_id = ipu_fw_psys_ppg_get_base_queue_id(&tmp_kcmd);
+		ipu_psys_free_cmd_queue_resource(&psys->resource_pool_running,
+						 queue_id);
+		pm_runtime_put(&psys->adev->dev);
+	} else {
+		if (kppg->state == PPG_STATE_SUSPENDING) {
+			kppg->state = PPG_STATE_SUSPENDED;
+			ipu_psys_free_resources(&kppg->kpg->resource_alloc,
+						&psys->resource_pool_running);
+		} else if (kppg->state == PPG_STATE_STARTED ||
+			   kppg->state == PPG_STATE_RESUMED) {
+			kppg->state = PPG_STATE_RUNNING;
+		}
+
+		/* Kick l-scheduler thread for FW callback,
+		 * also for checking if need to enter power gating
+		 */
+		atomic_set(&psys->wakeup_count, 1);
+		wake_up_interruptible(&psys->sched_cmd_wq);
+	}
+	if (old_ppg_state != kppg->state)
+		dev_dbg(&psys->adev->dev, "s_change:%s: %p %d -> %d\n",
+			__func__, kppg, old_ppg_state, kppg->state);
+
+	mutex_unlock(&kppg->mutex);
+}
+
+int ipu_psys_ppg_start(struct ipu_psys_ppg *kppg)
+{
+	struct ipu_psys *psys = kppg->fh->psys;
+	struct ipu_psys_kcmd *kcmd = ipu_psys_ppg_get_kcmd(kppg,
+						KCMD_STATE_PPG_START);
+	unsigned int i;
+	int ret;
+
+	if (!kcmd) {
+		dev_err(&psys->adev->dev, "failed to find start kcmd!\n");
+		return -EINVAL;
+	}
+
+	dev_dbg(&psys->adev->dev, "start ppg id %d, addr 0x%p\n",
+		ipu_fw_psys_pg_get_id(kcmd), kppg);
+
+	kppg->state = PPG_STATE_STARTING;
+	for (i = 0; i < kcmd->nbuffers; i++) {
+		struct ipu_fw_psys_terminal *terminal;
+
+		terminal = ipu_fw_psys_pg_get_terminal(kcmd, i);
+		if (!terminal)
+			continue;
+
+		ret = ipu_fw_psys_terminal_set(terminal, i, kcmd, 0,
+					       kcmd->buffers[i].len);
+		if (ret) {
+			dev_err(&psys->adev->dev, "Unable to set terminal\n");
+			return ret;
+		}
+	}
+
+	ret = ipu_fw_psys_pg_submit(kcmd);
+	if (ret) {
+		dev_err(&psys->adev->dev, "failed to submit kcmd!\n");
+		return ret;
+	}
+
+	ret = ipu_psys_allocate_resources(&psys->adev->dev,
+					  kcmd->kpg->pg,
+					  kcmd->pg_manifest,
+					  &kcmd->kpg->resource_alloc,
+					  &psys->resource_pool_running);
+	if (ret) {
+		dev_err(&psys->adev->dev, "alloc resources failed!\n");
+		return ret;
+	}
+
+	ret = pm_runtime_get_sync(&psys->adev->dev);
+	if (ret < 0) {
+		dev_err(&psys->adev->dev, "failed to power on psys\n");
+		goto error;
+	}
+
+	ret = ipu_psys_kcmd_start(psys, kcmd);
+	if (ret) {
+		ipu_psys_kcmd_complete(kppg, kcmd, -EIO);
+		goto error;
+	}
+
+	dev_dbg(&psys->adev->dev, "s_change:%s: %p %d -> %d\n",
+		__func__, kppg, kppg->state, PPG_STATE_STARTED);
+	kppg->state = PPG_STATE_STARTED;
+	ipu_psys_kcmd_complete(kppg, kcmd, 0);
+
+	return 0;
+
+error:
+	pm_runtime_put_noidle(&psys->adev->dev);
+	ipu_psys_reset_process_cell(&psys->adev->dev,
+				    kcmd->kpg->pg,
+				    kcmd->pg_manifest,
+				    kcmd->kpg->pg->process_count);
+	ipu_psys_free_resources(&kppg->kpg->resource_alloc,
+				&psys->resource_pool_running);
+
+	dev_err(&psys->adev->dev, "failed to start ppg\n");
+	return ret;
+}
+
+int ipu_psys_ppg_resume(struct ipu_psys_ppg *kppg)
+{
+	struct ipu_psys *psys = kppg->fh->psys;
+	struct ipu_psys_kcmd tmp_kcmd = {
+		.kpg = kppg->kpg,
+		.fh = kppg->fh,
+	};
+	int ret;
+
+	dev_dbg(&psys->adev->dev, "resume ppg id %d, addr 0x%p\n",
+		ipu_fw_psys_pg_get_id(&tmp_kcmd), kppg);
+
+	kppg->state = PPG_STATE_RESUMING;
+	if (enable_suspend_resume) {
+		ret = ipu_psys_allocate_resources(&psys->adev->dev,
+						  kppg->kpg->pg,
+						  kppg->manifest,
+						  &kppg->kpg->resource_alloc,
+						  &psys->resource_pool_running);
+		if (ret) {
+			dev_err(&psys->adev->dev, "failed to allocate res\n");
+			return -EIO;
+		}
+
+		ret = ipu_fw_psys_ppg_resume(&tmp_kcmd);
+		if (ret) {
+			dev_err(&psys->adev->dev, "failed to resume ppg\n");
+			goto error;
+		}
+	} else {
+		kppg->kpg->pg->state = IPU_FW_PSYS_PROCESS_GROUP_READY;
+		ret = ipu_fw_psys_pg_submit(&tmp_kcmd);
+		if (ret) {
+			dev_err(&psys->adev->dev, "failed to submit kcmd!\n");
+			return ret;
+		}
+
+		ret = ipu_psys_allocate_resources(&psys->adev->dev,
+						  kppg->kpg->pg,
+						  kppg->manifest,
+						  &kppg->kpg->resource_alloc,
+						  &psys->resource_pool_running);
+		if (ret) {
+			dev_err(&psys->adev->dev, "failed to allocate res\n");
+			return ret;
+		}
+
+		ret = ipu_psys_kcmd_start(psys, &tmp_kcmd);
+		if (ret) {
+			dev_err(&psys->adev->dev, "failed to start kcmd!\n");
+			goto error;
+		}
+	}
+	dev_dbg(&psys->adev->dev, "s_change:%s: %p %d -> %d\n",
+		__func__, kppg, kppg->state, PPG_STATE_RESUMED);
+	kppg->state = PPG_STATE_RESUMED;
+
+	return 0;
+
+error:
+	ipu_psys_reset_process_cell(&psys->adev->dev,
+				    kppg->kpg->pg,
+				    kppg->manifest,
+				    kppg->kpg->pg->process_count);
+	ipu_psys_free_resources(&kppg->kpg->resource_alloc,
+				&psys->resource_pool_running);
+
+	return ret;
+}
+
+int ipu_psys_ppg_stop(struct ipu_psys_ppg *kppg)
+{
+	struct ipu_psys_kcmd *kcmd = ipu_psys_ppg_get_kcmd(kppg,
+							   KCMD_STATE_PPG_STOP);
+	struct ipu_psys *psys = kppg->fh->psys;
+	struct ipu_psys_kcmd kcmd_temp;
+	int ppg_id, ret = 0;
+
+	if (kcmd) {
+		list_move_tail(&kcmd->list, &kppg->kcmds_processing_list);
+	} else {
+		dev_dbg(&psys->adev->dev, "Exceptional stop happened!\n");
+		kcmd_temp.kpg = kppg->kpg;
+		kcmd_temp.fh = kppg->fh;
+		kcmd = &kcmd_temp;
+		/* delete kppg in stop list to avoid this ppg resuming */
+		ipu_psys_scheduler_remove_kppg(kppg, SCHED_STOP_LIST);
+	}
+
+	ppg_id = ipu_fw_psys_pg_get_id(kcmd);
+	dev_dbg(&psys->adev->dev, "stop ppg(%d, addr 0x%p)\n", ppg_id, kppg);
+
+	if (kppg->state & PPG_STATE_SUSPENDED) {
+		if (enable_suspend_resume) {
+			dev_dbg(&psys->adev->dev, "need resume before stop!\n");
+			kcmd_temp.kpg = kppg->kpg;
+			kcmd_temp.fh = kppg->fh;
+			ret = ipu_fw_psys_ppg_resume(&kcmd_temp);
+			if (ret)
+				dev_err(&psys->adev->dev,
+					"ppg(%d) failed to resume\n", ppg_id);
+		} else if (kcmd != &kcmd_temp) {
+			ipu_psys_free_cmd_queue_resource(
+				&psys->resource_pool_running,
+				ipu_fw_psys_ppg_get_base_queue_id(kcmd));
+			ipu_psys_kcmd_complete(kppg, kcmd, 0);
+			dev_dbg(&psys->adev->dev,
+				"s_change:%s %p %d -> %d\n", __func__,
+				kppg, kppg->state, PPG_STATE_STOPPED);
+			pm_runtime_put(&psys->adev->dev);
+			kppg->state = PPG_STATE_STOPPED;
+			return 0;
+		} else {
+			return 0;
+		}
+	}
+	dev_dbg(&psys->adev->dev, "s_change:%s %p %d -> %d\n",
+		__func__, kppg, kppg->state, PPG_STATE_STOPPING);
+	kppg->state = PPG_STATE_STOPPING;
+	ret = ipu_fw_psys_pg_abort(kcmd);
+	if (ret)
+		dev_err(&psys->adev->dev, "ppg(%d) failed to abort\n", ppg_id);
+
+	return ret;
+}
+
+int ipu_psys_ppg_suspend(struct ipu_psys_ppg *kppg)
+{
+	struct ipu_psys *psys = kppg->fh->psys;
+	struct ipu_psys_kcmd tmp_kcmd = {
+		.kpg = kppg->kpg,
+		.fh = kppg->fh,
+	};
+	int ppg_id = ipu_fw_psys_pg_get_id(&tmp_kcmd);
+	int ret = 0;
+
+	dev_dbg(&psys->adev->dev, "suspend ppg(%d, addr 0x%p)\n", ppg_id, kppg);
+
+	dev_dbg(&psys->adev->dev, "s_change:%s %p %d -> %d\n",
+		__func__, kppg, kppg->state, PPG_STATE_SUSPENDING);
+	kppg->state = PPG_STATE_SUSPENDING;
+	if (enable_suspend_resume)
+		ret = ipu_fw_psys_ppg_suspend(&tmp_kcmd);
+	else
+		ret = ipu_fw_psys_pg_abort(&tmp_kcmd);
+	if (ret)
+		dev_err(&psys->adev->dev, "failed to %s ppg(%d)\n",
+			enable_suspend_resume ? "suspend" : "stop", ret);
+
+	return ret;
+}
+
+static bool ipu_psys_ppg_is_bufset_existing(struct ipu_psys_ppg *kppg)
+{
+	return !list_empty(&kppg->kcmds_new_list);
+}
+
+/*
+ * ipu_psys_ppg_enqueue_bufsets - enqueue buffer sets to firmware
+ * Sometimes, if the ppg is at suspended state, this function will return true
+ * to reschedule and let the resume command scheduled before the buffer sets
+ * enqueuing.
+ */
+bool ipu_psys_ppg_enqueue_bufsets(struct ipu_psys_ppg *kppg)
+{
+	struct ipu_psys_kcmd *kcmd, *kcmd0;
+	struct ipu_psys *psys = kppg->fh->psys;
+	bool need_resume = false;
+
+	mutex_lock(&kppg->mutex);
+
+	if (kppg->state & (PPG_STATE_STARTED | PPG_STATE_RESUMED |
+			   PPG_STATE_RUNNING)) {
+		if (ipu_psys_ppg_is_bufset_existing(kppg)) {
+			list_for_each_entry_safe(kcmd, kcmd0,
+						 &kppg->kcmds_new_list, list) {
+				int ret;
+
+				if (kcmd->state != KCMD_STATE_PPG_ENQUEUE) {
+					need_resume = true;
+					break;
+				}
+
+				ret = ipu_fw_psys_ppg_enqueue_bufs(kcmd);
+				if (ret) {
+					dev_err(&psys->adev->dev,
+						"kppg 0x%p fail to qbufset %d",
+						kppg, ret);
+					break;
+				}
+				list_move_tail(&kcmd->list,
+					       &kppg->kcmds_processing_list);
+				dev_dbg(&psys->adev->dev,
+					"kppg %d %p queue kcmd 0x%p fh 0x%p\n",
+					ipu_fw_psys_pg_get_id(kcmd),
+					kppg, kcmd, kcmd->fh);
+			}
+		}
+	}
+
+	mutex_unlock(&kppg->mutex);
+	return need_resume;
+}
+
+void ipu_psys_enter_power_gating(struct ipu_psys *psys)
+{
+	struct ipu_psys_scheduler *sched;
+	struct ipu_psys_ppg *kppg, *tmp;
+	struct ipu_psys_fh *fh;
+	int ret = 0;
+
+	list_for_each_entry(fh, &psys->fhs, list) {
+		mutex_lock(&fh->mutex);
+		sched = &fh->sched;
+		if (list_empty(&sched->ppgs)) {
+			mutex_unlock(&fh->mutex);
+			continue;
+		}
+
+		list_for_each_entry_safe(kppg, tmp, &sched->ppgs, list) {
+			mutex_lock(&kppg->mutex);
+			/*
+			 * Only for SUSPENDED kppgs, STOPPED kppgs has already
+			 * power down and new kppgs might come now.
+			 */
+			if (kppg->state != PPG_STATE_SUSPENDED) {
+				mutex_unlock(&kppg->mutex);
+				continue;
+			}
+
+			ret = pm_runtime_put_autosuspend(&psys->adev->dev);
+			if (ret < 0) {
+				dev_err(&psys->adev->dev,
+					"failed to power gating off\n");
+				pm_runtime_get_sync(&psys->adev->dev);
+
+			}
+			mutex_unlock(&kppg->mutex);
+		}
+		mutex_unlock(&fh->mutex);
+	}
+}
+
+void ipu_psys_exit_power_gating(struct ipu_psys *psys)
+{
+	struct ipu_psys_scheduler *sched;
+	struct ipu_psys_ppg *kppg, *tmp;
+	struct ipu_psys_fh *fh;
+	int ret = 0;
+
+	list_for_each_entry(fh, &psys->fhs, list) {
+		mutex_lock(&fh->mutex);
+		sched = &fh->sched;
+		if (list_empty(&sched->ppgs)) {
+			mutex_unlock(&fh->mutex);
+			continue;
+		}
+
+		list_for_each_entry_safe(kppg, tmp, &sched->ppgs, list) {
+			mutex_lock(&kppg->mutex);
+			/* Only for SUSPENDED kppgs */
+			if (kppg->state != PPG_STATE_SUSPENDED) {
+				mutex_unlock(&kppg->mutex);
+				continue;
+			}
+
+			ret = pm_runtime_get_sync(&psys->adev->dev);
+			if (ret < 0) {
+				dev_err(&psys->adev->dev,
+					"failed to power gating\n");
+				pm_runtime_put_noidle(&psys->adev->dev);
+			}
+			mutex_unlock(&kppg->mutex);
+		}
+		mutex_unlock(&fh->mutex);
+	}
+}
Index: b/drivers/media/pci/intel/ipu6/ipu6-ppg.h
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu6/ipu6-ppg.h
@@ -0,0 +1,38 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2020 Intel Corporation
+ */
+
+#ifndef IPU6_PPG_H
+#define IPU6_PPG_H
+
+#include "ipu-psys.h"
+/* starting from '2' in case of someone passes true or false */
+enum SCHED_LIST {
+	SCHED_START_LIST = 2,
+	SCHED_STOP_LIST
+};
+
+enum ipu_psys_power_gating_state {
+	PSYS_POWER_NORMAL = 0,
+	PSYS_POWER_GATING,
+	PSYS_POWER_GATED
+};
+
+int ipu_psys_ppg_get_bufset(struct ipu_psys_kcmd *kcmd,
+			    struct ipu_psys_ppg *kppg);
+struct ipu_psys_kcmd *ipu_psys_ppg_get_stop_kcmd(struct ipu_psys_ppg *kppg);
+void ipu_psys_scheduler_remove_kppg(struct ipu_psys_ppg *kppg,
+				    enum SCHED_LIST type);
+void ipu_psys_scheduler_add_kppg(struct ipu_psys_ppg *kppg,
+				 enum SCHED_LIST type);
+int ipu_psys_ppg_start(struct ipu_psys_ppg *kppg);
+int ipu_psys_ppg_resume(struct ipu_psys_ppg *kppg);
+int ipu_psys_ppg_stop(struct ipu_psys_ppg *kppg);
+int ipu_psys_ppg_suspend(struct ipu_psys_ppg *kppg);
+void ipu_psys_ppg_complete(struct ipu_psys *psys, struct ipu_psys_ppg *kppg);
+bool ipu_psys_ppg_enqueue_bufsets(struct ipu_psys_ppg *kppg);
+void ipu_psys_enter_power_gating(struct ipu_psys *psys);
+void ipu_psys_exit_power_gating(struct ipu_psys *psys);
+
+#endif /* IPU6_PPG_H */
Index: b/drivers/media/pci/intel/ipu6/ipu6-psys-gpc.c
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu6/ipu6-psys-gpc.c
@@ -0,0 +1,210 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) 2020 Intel Corporation
+
+#ifdef CONFIG_DEBUG_FS
+#include <linux/debugfs.h>
+#include <linux/pm_runtime.h>
+
+#include "ipu-psys.h"
+#include "ipu-platform-regs.h"
+
+/*
+ * GPC (Gerneral Performance Counters)
+ */
+#define IPU_PSYS_GPC_NUM 16
+
+#ifndef CONFIG_PM
+#define pm_runtime_get_sync(d)			0
+#define pm_runtime_put(d)			0
+#endif
+
+struct ipu_psys_gpc {
+	bool enable;
+	unsigned int route;
+	unsigned int source;
+	unsigned int sense;
+	unsigned int gpcindex;
+	void *prit;
+};
+
+struct ipu_psys_gpcs {
+	bool gpc_enable;
+	struct ipu_psys_gpc gpc[IPU_PSYS_GPC_NUM];
+	void *prit;
+};
+
+static int ipu6_psys_gpc_global_enable_get(void *data, u64 *val)
+{
+	struct ipu_psys_gpcs *psys_gpcs = data;
+	struct ipu_psys *psys = psys_gpcs->prit;
+
+	mutex_lock(&psys->mutex);
+
+	*val = psys_gpcs->gpc_enable;
+
+	mutex_unlock(&psys->mutex);
+	return 0;
+}
+
+static int ipu6_psys_gpc_global_enable_set(void *data, u64 val)
+{
+	struct ipu_psys_gpcs *psys_gpcs = data;
+	struct ipu_psys *psys = psys_gpcs->prit;
+	void __iomem *base;
+	int idx, res;
+
+	if (val != 0 && val != 1)
+		return -EINVAL;
+
+	if (!psys || !psys->pdata || !psys->pdata->base)
+		return -EINVAL;
+
+	mutex_lock(&psys->mutex);
+
+	base = psys->pdata->base + IPU_GPC_BASE;
+
+	res = pm_runtime_get_sync(&psys->adev->dev);
+	if (res < 0) {
+		pm_runtime_put(&psys->adev->dev);
+		mutex_unlock(&psys->mutex);
+		return res;
+	}
+
+	if (val == 0) {
+		writel(0x0, base + IPU_GPREG_TRACE_TIMER_RST);
+		writel(0x0, base + IPU_CDC_MMU_GPC_OVERALL_ENABLE);
+		writel(0xffff, base + IPU_CDC_MMU_GPC_SOFT_RESET);
+		psys_gpcs->gpc_enable = false;
+		for (idx = 0; idx < IPU_PSYS_GPC_NUM; idx++) {
+			psys_gpcs->gpc[idx].enable = 0;
+			psys_gpcs->gpc[idx].sense = 0;
+			psys_gpcs->gpc[idx].route = 0;
+			psys_gpcs->gpc[idx].source = 0;
+		}
+		pm_runtime_mark_last_busy(&psys->adev->dev);
+		pm_runtime_put_autosuspend(&psys->adev->dev);
+	} else {
+		/* Set gpc reg and start all gpc here.
+		 * RST free running local timer.
+		 */
+		writel(0x0, base + IPU_GPREG_TRACE_TIMER_RST);
+		writel(0x1, base + IPU_GPREG_TRACE_TIMER_RST);
+
+		for (idx = 0; idx < IPU_PSYS_GPC_NUM; idx++) {
+			/* Enable */
+			writel(psys_gpcs->gpc[idx].enable,
+			       base + IPU_CDC_MMU_GPC_ENABLE0 + 4 * idx);
+			/* Setting (route/source/sense) */
+			writel((psys_gpcs->gpc[idx].sense
+					<< IPU_GPC_SENSE_OFFSET)
+				+ (psys_gpcs->gpc[idx].route
+					<< IPU_GPC_ROUTE_OFFSET)
+				+ (psys_gpcs->gpc[idx].source
+					<< IPU_GPC_SOURCE_OFFSET),
+				base + IPU_CDC_MMU_GPC_CNT_SEL0 + 4 * idx);
+		}
+
+		/* Soft reset and Overall Enable. */
+		writel(0x0, base + IPU_CDC_MMU_GPC_OVERALL_ENABLE);
+		writel(0xffff, base + IPU_CDC_MMU_GPC_SOFT_RESET);
+		writel(0x1, base + IPU_CDC_MMU_GPC_OVERALL_ENABLE);
+
+		psys_gpcs->gpc_enable = true;
+	}
+
+	mutex_unlock(&psys->mutex);
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(psys_gpc_globe_enable_fops,
+			ipu6_psys_gpc_global_enable_get,
+			ipu6_psys_gpc_global_enable_set, "%llu\n");
+
+static int ipu6_psys_gpc_count_get(void *data, u64 *val)
+{
+	struct ipu_psys_gpc *psys_gpc = data;
+	struct ipu_psys *psys = psys_gpc->prit;
+	void __iomem *base;
+	int res;
+
+	if (!psys || !psys->pdata || !psys->pdata->base)
+		return -EINVAL;
+
+	mutex_lock(&psys->mutex);
+
+	base = psys->pdata->base + IPU_GPC_BASE;
+
+	res = pm_runtime_get_sync(&psys->adev->dev);
+	if (res < 0) {
+		pm_runtime_put(&psys->adev->dev);
+		mutex_unlock(&psys->mutex);
+		return res;
+	}
+
+	*val = readl(base + IPU_CDC_MMU_GPC_VALUE0 + 4 * psys_gpc->gpcindex);
+
+	mutex_unlock(&psys->mutex);
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(psys_gpc_count_fops,
+			ipu6_psys_gpc_count_get,
+			NULL, "%llu\n");
+
+int ipu_psys_gpc_init_debugfs(struct ipu_psys *psys)
+{
+	struct dentry *gpcdir;
+	struct dentry *dir;
+	struct dentry *file;
+	int idx;
+	char gpcname[10];
+	struct ipu_psys_gpcs *psys_gpcs;
+
+	psys_gpcs = devm_kzalloc(&psys->dev, sizeof(*psys_gpcs), GFP_KERNEL);
+	if (!psys_gpcs)
+		return -ENOMEM;
+
+	gpcdir = debugfs_create_dir("gpc", psys->debugfsdir);
+	if (IS_ERR(gpcdir))
+		return -ENOMEM;
+
+	psys_gpcs->prit = psys;
+	file = debugfs_create_file("enable", 0600, gpcdir, psys_gpcs,
+				   &psys_gpc_globe_enable_fops);
+	if (IS_ERR(file))
+		goto err;
+
+	for (idx = 0; idx < IPU_PSYS_GPC_NUM; idx++) {
+		sprintf(gpcname, "gpc%d", idx);
+		dir = debugfs_create_dir(gpcname, gpcdir);
+		if (IS_ERR(dir))
+			goto err;
+
+		debugfs_create_bool("enable", 0600, dir,
+				    &psys_gpcs->gpc[idx].enable);
+
+		debugfs_create_u32("source", 0600, dir,
+				   &psys_gpcs->gpc[idx].source);
+
+		debugfs_create_u32("route", 0600, dir,
+				   &psys_gpcs->gpc[idx].route);
+
+		debugfs_create_u32("sense", 0600, dir,
+				   &psys_gpcs->gpc[idx].sense);
+
+		psys_gpcs->gpc[idx].gpcindex = idx;
+		psys_gpcs->gpc[idx].prit = psys;
+		file = debugfs_create_file("count", 0400, dir,
+					   &psys_gpcs->gpc[idx],
+					   &psys_gpc_count_fops);
+		if (IS_ERR(file))
+			goto err;
+	}
+
+	return 0;
+
+err:
+	debugfs_remove_recursive(gpcdir);
+	return -ENOMEM;
+}
+#endif
Index: b/drivers/media/pci/intel/ipu6/ipu6-psys.c
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu6/ipu6-psys.c
@@ -0,0 +1,1032 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) 2022 Intel Corporation
+
+#include <linux/uaccess.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/highmem.h>
+#include <linux/mm.h>
+#include <linux/pm_runtime.h>
+#include <linux/kthread.h>
+#include <linux/init_task.h>
+#include <linux/version.h>
+#include <uapi/linux/sched/types.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+
+#include "ipu.h"
+#include "ipu-psys.h"
+#include "ipu6-ppg.h"
+#include "ipu-platform-regs.h"
+#include "ipu-trace.h"
+
+static bool early_pg_transfer;
+module_param(early_pg_transfer, bool, 0664);
+MODULE_PARM_DESC(early_pg_transfer,
+		 "Copy PGs back to user after resource allocation");
+
+bool enable_power_gating = true;
+module_param(enable_power_gating, bool, 0664);
+MODULE_PARM_DESC(enable_power_gating, "enable power gating");
+
+struct ipu_trace_block psys_trace_blocks[] = {
+	{
+		.offset = IPU_TRACE_REG_PS_TRACE_UNIT_BASE,
+		.type = IPU_TRACE_BLOCK_TUN,
+	},
+	{
+		.offset = IPU_TRACE_REG_PS_SPC_EVQ_BASE,
+		.type = IPU_TRACE_BLOCK_TM,
+	},
+	{
+		.offset = IPU_TRACE_REG_PS_SPP0_EVQ_BASE,
+		.type = IPU_TRACE_BLOCK_TM,
+	},
+	{
+		.offset = IPU_TRACE_REG_PS_SPC_GPC_BASE,
+		.type = IPU_TRACE_BLOCK_GPC,
+	},
+	{
+		.offset = IPU_TRACE_REG_PS_SPP0_GPC_BASE,
+		.type = IPU_TRACE_BLOCK_GPC,
+	},
+	{
+		.offset = IPU_TRACE_REG_PS_MMU_GPC_BASE,
+		.type = IPU_TRACE_BLOCK_GPC,
+	},
+	{
+		.offset = IPU_TRACE_REG_PS_GPREG_TRACE_TIMER_RST_N,
+		.type = IPU_TRACE_TIMER_RST,
+	},
+	{
+		.type = IPU_TRACE_BLOCK_END,
+	}
+};
+
+static void ipu6_set_sp_info_bits(void *base)
+{
+	int i;
+
+	writel(IPU_INFO_REQUEST_DESTINATION_IOSF,
+	       base + IPU_REG_PSYS_INFO_SEG_0_CONFIG_ICACHE_MASTER);
+
+	for (i = 0; i < 4; i++)
+		writel(IPU_INFO_REQUEST_DESTINATION_IOSF,
+		       base + IPU_REG_PSYS_INFO_SEG_CMEM_MASTER(i));
+	for (i = 0; i < 4; i++)
+		writel(IPU_INFO_REQUEST_DESTINATION_IOSF,
+		       base + IPU_REG_PSYS_INFO_SEG_XMEM_MASTER(i));
+}
+
+#define PSYS_SUBDOMAINS_STATUS_WAIT_COUNT        1000
+void ipu_psys_subdomains_power(struct ipu_psys *psys, bool on)
+{
+	unsigned int i;
+	u32 val;
+
+	/* power domain req */
+	dev_dbg(&psys->adev->dev, "power %s psys sub-domains",
+		on ? "UP" : "DOWN");
+	if (on)
+		writel(IPU_PSYS_SUBDOMAINS_POWER_MASK,
+		       psys->adev->isp->base + IPU_PSYS_SUBDOMAINS_POWER_REQ);
+	else
+		writel(0x0,
+		       psys->adev->isp->base + IPU_PSYS_SUBDOMAINS_POWER_REQ);
+
+	i = 0;
+	do {
+		usleep_range(10, 20);
+		val = readl(psys->adev->isp->base +
+			    IPU_PSYS_SUBDOMAINS_POWER_STATUS);
+		if (!(val & BIT(31))) {
+			dev_dbg(&psys->adev->dev,
+				"PS sub-domains req done with status 0x%x",
+				val);
+			break;
+		}
+		i++;
+	} while (i < PSYS_SUBDOMAINS_STATUS_WAIT_COUNT);
+
+	if (i == PSYS_SUBDOMAINS_STATUS_WAIT_COUNT)
+		dev_warn(&psys->adev->dev, "Psys sub-domains %s req timeout!",
+			 on ? "UP" : "DOWN");
+}
+
+void ipu_psys_setup_hw(struct ipu_psys *psys)
+{
+	void __iomem *base = psys->pdata->base;
+	void __iomem *spc_regs_base =
+	    base + psys->pdata->ipdata->hw_variant.spc_offset;
+	void *psys_iommu0_ctrl;
+	u32 irqs;
+	const u8 r3 = IPU_DEVICE_AB_GROUP1_TARGET_ID_R3_SPC_STATUS_REG;
+	const u8 r4 = IPU_DEVICE_AB_GROUP1_TARGET_ID_R4_SPC_MASTER_BASE_ADDR;
+	const u8 r5 = IPU_DEVICE_AB_GROUP1_TARGET_ID_R5_SPC_PC_STALL;
+
+	if (!psys->adev->isp->secure_mode) {
+		/* configure access blocker for non-secure mode */
+		writel(NCI_AB_ACCESS_MODE_RW,
+		       base + IPU_REG_DMA_TOP_AB_GROUP1_BASE_ADDR +
+		       IPU_REG_DMA_TOP_AB_RING_ACCESS_OFFSET(r3));
+		writel(NCI_AB_ACCESS_MODE_RW,
+		       base + IPU_REG_DMA_TOP_AB_GROUP1_BASE_ADDR +
+		       IPU_REG_DMA_TOP_AB_RING_ACCESS_OFFSET(r4));
+		writel(NCI_AB_ACCESS_MODE_RW,
+		       base + IPU_REG_DMA_TOP_AB_GROUP1_BASE_ADDR +
+		       IPU_REG_DMA_TOP_AB_RING_ACCESS_OFFSET(r5));
+	}
+	psys_iommu0_ctrl = base +
+		psys->pdata->ipdata->hw_variant.mmu_hw[0].offset +
+		IPU_MMU_INFO_OFFSET;
+	writel(IPU_INFO_REQUEST_DESTINATION_IOSF, psys_iommu0_ctrl);
+
+	ipu6_set_sp_info_bits(spc_regs_base + IPU_PSYS_REG_SPC_STATUS_CTRL);
+	ipu6_set_sp_info_bits(spc_regs_base + IPU_PSYS_REG_SPP0_STATUS_CTRL);
+
+	/* Enable FW interrupt #0 */
+	writel(0, base + IPU_REG_PSYS_GPDEV_FWIRQ(0));
+	irqs = IPU_PSYS_GPDEV_IRQ_FWIRQ(IPU_PSYS_GPDEV_FWIRQ0);
+	writel(irqs, base + IPU_REG_PSYS_GPDEV_IRQ_EDGE);
+	writel(irqs, base + IPU_REG_PSYS_GPDEV_IRQ_LEVEL_NOT_PULSE);
+	writel(0xffffffff, base + IPU_REG_PSYS_GPDEV_IRQ_CLEAR);
+	writel(irqs, base + IPU_REG_PSYS_GPDEV_IRQ_MASK);
+	writel(irqs, base + IPU_REG_PSYS_GPDEV_IRQ_ENABLE);
+}
+
+static struct ipu_psys_ppg *ipu_psys_identify_kppg(struct ipu_psys_kcmd *kcmd)
+{
+	struct ipu_psys_scheduler *sched = &kcmd->fh->sched;
+	struct ipu_psys_ppg *kppg, *tmp;
+
+	mutex_lock(&kcmd->fh->mutex);
+	if (list_empty(&sched->ppgs))
+		goto not_found;
+
+	list_for_each_entry_safe(kppg, tmp, &sched->ppgs, list) {
+		if (ipu_fw_psys_pg_get_token(kcmd)
+		    != kppg->token)
+			continue;
+		mutex_unlock(&kcmd->fh->mutex);
+		return kppg;
+	}
+
+not_found:
+	mutex_unlock(&kcmd->fh->mutex);
+	return NULL;
+}
+
+/*
+ * Called to free up all resources associated with a kcmd.
+ * After this the kcmd doesn't anymore exist in the driver.
+ */
+static void ipu_psys_kcmd_free(struct ipu_psys_kcmd *kcmd)
+{
+	struct ipu_psys_ppg *kppg;
+	struct ipu_psys_scheduler *sched;
+
+	if (!kcmd)
+		return;
+
+	kppg = ipu_psys_identify_kppg(kcmd);
+	sched = &kcmd->fh->sched;
+
+	if (kcmd->kbuf_set) {
+		mutex_lock(&sched->bs_mutex);
+		kcmd->kbuf_set->buf_set_size = 0;
+		mutex_unlock(&sched->bs_mutex);
+		kcmd->kbuf_set = NULL;
+	}
+
+	if (kppg) {
+		mutex_lock(&kppg->mutex);
+		if (!list_empty(&kcmd->list))
+			list_del(&kcmd->list);
+		mutex_unlock(&kppg->mutex);
+	}
+
+	kfree(kcmd->pg_manifest);
+	kfree(kcmd->kbufs);
+	kfree(kcmd->buffers);
+	kfree(kcmd);
+}
+
+static struct ipu_psys_kcmd *ipu_psys_copy_cmd(struct ipu_psys_command *cmd,
+					       struct ipu_psys_fh *fh)
+{
+	struct ipu_psys *psys = fh->psys;
+	struct ipu_psys_kcmd *kcmd;
+	struct ipu_psys_kbuffer *kpgbuf;
+	unsigned int i;
+	int ret, prevfd, fd;
+
+	fd = prevfd = -1;
+
+	if (cmd->bufcount > IPU_MAX_PSYS_CMD_BUFFERS)
+		return NULL;
+
+	if (!cmd->pg_manifest_size)
+		return NULL;
+
+	kcmd = kzalloc(sizeof(*kcmd), GFP_KERNEL);
+	if (!kcmd)
+		return NULL;
+
+	kcmd->state = KCMD_STATE_PPG_NEW;
+	kcmd->fh = fh;
+	INIT_LIST_HEAD(&kcmd->list);
+
+	mutex_lock(&fh->mutex);
+	fd = cmd->pg;
+	kpgbuf = ipu_psys_lookup_kbuffer(fh, fd);
+	if (!kpgbuf || !kpgbuf->sgt) {
+		dev_err(&psys->adev->dev, "%s kbuf %p with fd %d not found.\n",
+			__func__, kpgbuf, fd);
+		mutex_unlock(&fh->mutex);
+		goto error;
+	}
+
+	/* check and remap if possibe */
+	ret = ipu_psys_mapbuf_locked(fd, fh, kpgbuf);
+	if (ret) {
+		dev_err(&psys->adev->dev, "%s remap failed\n", __func__);
+		mutex_unlock(&fh->mutex);
+		goto error;
+	}
+
+	kpgbuf = ipu_psys_lookup_kbuffer(fh, fd);
+	if (!kpgbuf || !kpgbuf->sgt) {
+		WARN(1, "kbuf not found or unmapped.\n");
+		mutex_unlock(&fh->mutex);
+		goto error;
+	}
+	mutex_unlock(&fh->mutex);
+
+	kcmd->pg_user = kpgbuf->kaddr;
+	kcmd->kpg = __get_pg_buf(psys, kpgbuf->len);
+	if (!kcmd->kpg)
+		goto error;
+
+	memcpy(kcmd->kpg->pg, kcmd->pg_user, kcmd->kpg->pg_size);
+
+	kcmd->pg_manifest = kzalloc(cmd->pg_manifest_size, GFP_KERNEL);
+	if (!kcmd->pg_manifest)
+		goto error;
+
+	ret = copy_from_user(kcmd->pg_manifest, cmd->pg_manifest,
+			     cmd->pg_manifest_size);
+	if (ret)
+		goto error;
+
+	kcmd->pg_manifest_size = cmd->pg_manifest_size;
+
+	kcmd->user_token = cmd->user_token;
+	kcmd->issue_id = cmd->issue_id;
+	kcmd->priority = cmd->priority;
+	if (kcmd->priority >= IPU_PSYS_CMD_PRIORITY_NUM)
+		goto error;
+
+	/*
+	 * Kenel enable bitmap be used only.
+	 */
+	memcpy(kcmd->kernel_enable_bitmap, cmd->kernel_enable_bitmap,
+	       sizeof(cmd->kernel_enable_bitmap));
+
+	kcmd->nbuffers = ipu_fw_psys_pg_get_terminal_count(kcmd);
+	kcmd->buffers = kcalloc(kcmd->nbuffers, sizeof(*kcmd->buffers),
+				GFP_KERNEL);
+	if (!kcmd->buffers)
+		goto error;
+
+	kcmd->kbufs = kcalloc(kcmd->nbuffers, sizeof(kcmd->kbufs[0]),
+			      GFP_KERNEL);
+	if (!kcmd->kbufs)
+		goto error;
+
+	/* should be stop cmd for ppg */
+	if (!cmd->buffers) {
+		kcmd->state = KCMD_STATE_PPG_STOP;
+		return kcmd;
+	}
+
+	if (!cmd->bufcount || kcmd->nbuffers > cmd->bufcount)
+		goto error;
+
+	ret = copy_from_user(kcmd->buffers, cmd->buffers,
+			     kcmd->nbuffers * sizeof(*kcmd->buffers));
+	if (ret)
+		goto error;
+
+	for (i = 0; i < kcmd->nbuffers; i++) {
+		struct ipu_fw_psys_terminal *terminal;
+
+		terminal = ipu_fw_psys_pg_get_terminal(kcmd, i);
+		if (!terminal)
+			continue;
+
+		if (!(kcmd->buffers[i].flags & IPU_BUFFER_FLAG_DMA_HANDLE)) {
+			kcmd->state = KCMD_STATE_PPG_START;
+			continue;
+		}
+		if (kcmd->state == KCMD_STATE_PPG_START) {
+			dev_err(&psys->adev->dev,
+				"err: all buffer.flags&DMA_HANDLE must 0\n");
+			goto error;
+		}
+
+		mutex_lock(&fh->mutex);
+		fd = kcmd->buffers[i].base.fd;
+		kpgbuf = ipu_psys_lookup_kbuffer(fh, fd);
+		if (!kpgbuf || !kpgbuf->sgt) {
+			dev_err(&psys->adev->dev,
+				"%s kcmd->buffers[%d] %p fd %d not found.\n",
+				__func__, i, kpgbuf, fd);
+			mutex_unlock(&fh->mutex);
+			goto error;
+		}
+
+		ret = ipu_psys_mapbuf_locked(fd, fh, kpgbuf);
+		if (ret) {
+			dev_err(&psys->adev->dev, "%s remap failed\n",
+				__func__);
+			mutex_unlock(&fh->mutex);
+			goto error;
+		}
+
+		kpgbuf = ipu_psys_lookup_kbuffer(fh, fd);
+		if (!kpgbuf || !kpgbuf->sgt) {
+			WARN(1, "kbuf not found or unmapped.\n");
+			mutex_unlock(&fh->mutex);
+			goto error;
+		}
+		mutex_unlock(&fh->mutex);
+		kcmd->kbufs[i] = kpgbuf;
+		if (!kcmd->kbufs[i] || !kcmd->kbufs[i]->sgt ||
+		    kcmd->kbufs[i]->len < kcmd->buffers[i].bytes_used)
+			goto error;
+		if ((kcmd->kbufs[i]->flags &
+		     IPU_BUFFER_FLAG_NO_FLUSH) ||
+		    (kcmd->buffers[i].flags &
+		     IPU_BUFFER_FLAG_NO_FLUSH) ||
+		    prevfd == kcmd->buffers[i].base.fd)
+			continue;
+
+		prevfd = kcmd->buffers[i].base.fd;
+		dma_sync_sg_for_device(&psys->adev->dev,
+				       kcmd->kbufs[i]->sgt->sgl,
+				       kcmd->kbufs[i]->sgt->orig_nents,
+				       DMA_BIDIRECTIONAL);
+	}
+
+	if (kcmd->state != KCMD_STATE_PPG_START)
+		kcmd->state = KCMD_STATE_PPG_ENQUEUE;
+
+	return kcmd;
+error:
+	ipu_psys_kcmd_free(kcmd);
+
+	dev_dbg(&psys->adev->dev, "failed to copy cmd\n");
+
+	return NULL;
+}
+
+static struct ipu_psys_buffer_set *
+ipu_psys_lookup_kbuffer_set(struct ipu_psys *psys, u32 addr)
+{
+	struct ipu_psys_fh *fh;
+	struct ipu_psys_buffer_set *kbuf_set;
+	struct ipu_psys_scheduler *sched;
+
+	list_for_each_entry(fh, &psys->fhs, list) {
+		sched = &fh->sched;
+		mutex_lock(&sched->bs_mutex);
+		list_for_each_entry(kbuf_set, &sched->buf_sets, list) {
+			if (kbuf_set->buf_set &&
+			    kbuf_set->buf_set->ipu_virtual_address == addr) {
+				mutex_unlock(&sched->bs_mutex);
+				return kbuf_set;
+			}
+		}
+		mutex_unlock(&sched->bs_mutex);
+	}
+
+	return NULL;
+}
+
+static struct ipu_psys_ppg *ipu_psys_lookup_ppg(struct ipu_psys *psys,
+						dma_addr_t pg_addr)
+{
+	struct ipu_psys_scheduler *sched;
+	struct ipu_psys_ppg *kppg, *tmp;
+	struct ipu_psys_fh *fh;
+
+	list_for_each_entry(fh, &psys->fhs, list) {
+		sched = &fh->sched;
+		mutex_lock(&fh->mutex);
+		if (list_empty(&sched->ppgs)) {
+			mutex_unlock(&fh->mutex);
+			continue;
+		}
+
+		list_for_each_entry_safe(kppg, tmp, &sched->ppgs, list) {
+			if (pg_addr != kppg->kpg->pg_dma_addr)
+				continue;
+			mutex_unlock(&fh->mutex);
+			return kppg;
+		}
+		mutex_unlock(&fh->mutex);
+	}
+
+	return NULL;
+}
+
+/*
+ * Move kcmd into completed state (due to running finished or failure).
+ * Fill up the event struct and notify waiters.
+ */
+void ipu_psys_kcmd_complete(struct ipu_psys_ppg *kppg,
+			    struct ipu_psys_kcmd *kcmd, int error)
+{
+	struct ipu_psys_fh *fh = kcmd->fh;
+	struct ipu_psys *psys = fh->psys;
+
+	kcmd->ev.type = IPU_PSYS_EVENT_TYPE_CMD_COMPLETE;
+	kcmd->ev.user_token = kcmd->user_token;
+	kcmd->ev.issue_id = kcmd->issue_id;
+	kcmd->ev.error = error;
+	list_move_tail(&kcmd->list, &kppg->kcmds_finished_list);
+
+	if (kcmd->constraint.min_freq)
+		ipu_buttress_remove_psys_constraint(psys->adev->isp,
+						    &kcmd->constraint);
+
+	if (!early_pg_transfer && kcmd->pg_user && kcmd->kpg->pg) {
+		struct ipu_psys_kbuffer *kbuf;
+
+		kbuf = ipu_psys_lookup_kbuffer_by_kaddr(kcmd->fh,
+							kcmd->pg_user);
+		if (kbuf && kbuf->valid)
+			memcpy(kcmd->pg_user,
+			       kcmd->kpg->pg, kcmd->kpg->pg_size);
+		else
+			dev_dbg(&psys->adev->dev, "Skipping unmapped buffer\n");
+	}
+
+	kcmd->state = KCMD_STATE_PPG_COMPLETE;
+	wake_up_interruptible(&fh->wait);
+}
+
+/*
+ * Submit kcmd into psys queue. If running fails, complete the kcmd
+ * with an error.
+ *
+ * Found a runnable PG. Move queue to the list tail for round-robin
+ * scheduling and run the PG. Start the watchdog timer if the PG was
+ * started successfully. Enable PSYS power if requested.
+ */
+int ipu_psys_kcmd_start(struct ipu_psys *psys, struct ipu_psys_kcmd *kcmd)
+{
+	int ret;
+
+	if (psys->adev->isp->flr_done)
+		return -EIO;
+
+	if (early_pg_transfer && kcmd->pg_user && kcmd->kpg->pg)
+		memcpy(kcmd->pg_user, kcmd->kpg->pg, kcmd->kpg->pg_size);
+
+	ret = ipu_fw_psys_pg_start(kcmd);
+	if (ret) {
+		dev_err(&psys->adev->dev, "failed to start kcmd!\n");
+		return ret;
+	}
+
+	ipu_fw_psys_pg_dump(psys, kcmd, "run");
+
+	ret = ipu_fw_psys_pg_disown(kcmd);
+	if (ret) {
+		dev_err(&psys->adev->dev, "failed to start kcmd!\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int ipu_psys_kcmd_send_to_ppg_start(struct ipu_psys_kcmd *kcmd)
+{
+	struct ipu_psys_fh *fh = kcmd->fh;
+	struct ipu_psys_scheduler *sched = &fh->sched;
+	struct ipu_psys *psys = fh->psys;
+	struct ipu_psys_ppg *kppg;
+	struct ipu_psys_resource_pool *rpr;
+	int queue_id;
+	int ret;
+
+	rpr = &psys->resource_pool_running;
+
+	kppg = kzalloc(sizeof(*kppg), GFP_KERNEL);
+	if (!kppg)
+		return -ENOMEM;
+
+	kppg->fh = fh;
+	kppg->kpg = kcmd->kpg;
+	kppg->state = PPG_STATE_START;
+	kppg->pri_base = kcmd->priority;
+	kppg->pri_dynamic = 0;
+	INIT_LIST_HEAD(&kppg->list);
+
+	mutex_init(&kppg->mutex);
+	INIT_LIST_HEAD(&kppg->kcmds_new_list);
+	INIT_LIST_HEAD(&kppg->kcmds_processing_list);
+	INIT_LIST_HEAD(&kppg->kcmds_finished_list);
+	INIT_LIST_HEAD(&kppg->sched_list);
+
+	kppg->manifest = kzalloc(kcmd->pg_manifest_size, GFP_KERNEL);
+	if (!kppg->manifest) {
+		kfree(kppg);
+		return -ENOMEM;
+	}
+	memcpy(kppg->manifest, kcmd->pg_manifest,
+	       kcmd->pg_manifest_size);
+
+	queue_id = ipu_psys_allocate_cmd_queue_resource(rpr);
+	if (queue_id == -ENOSPC) {
+		dev_err(&psys->adev->dev, "no available queue\n");
+		kfree(kppg->manifest);
+		kfree(kppg);
+		mutex_unlock(&psys->mutex);
+		return -ENOMEM;
+	}
+
+	/*
+	 * set token as start cmd will immediately be followed by a
+	 * enqueue cmd so that kppg could be retrieved.
+	 */
+	kppg->token = (u64)kcmd->kpg;
+	ipu_fw_psys_pg_set_token(kcmd, kppg->token);
+	ipu_fw_psys_ppg_set_base_queue_id(kcmd, queue_id);
+	ret = ipu_fw_psys_pg_set_ipu_vaddress(kcmd,
+					      kcmd->kpg->pg_dma_addr);
+	if (ret) {
+		ipu_psys_free_cmd_queue_resource(rpr, queue_id);
+		kfree(kppg->manifest);
+		kfree(kppg);
+		return -EIO;
+	}
+	memcpy(kcmd->pg_user, kcmd->kpg->pg, kcmd->kpg->pg_size);
+
+	mutex_lock(&fh->mutex);
+	list_add_tail(&kppg->list, &sched->ppgs);
+	mutex_unlock(&fh->mutex);
+
+	mutex_lock(&kppg->mutex);
+	list_add(&kcmd->list, &kppg->kcmds_new_list);
+	mutex_unlock(&kppg->mutex);
+
+	dev_dbg(&psys->adev->dev,
+		"START ppg(%d, 0x%p) kcmd 0x%p, queue %d\n",
+		ipu_fw_psys_pg_get_id(kcmd), kppg, kcmd, queue_id);
+
+	/* Kick l-scheduler thread */
+	atomic_set(&psys->wakeup_count, 1);
+	wake_up_interruptible(&psys->sched_cmd_wq);
+
+	return 0;
+}
+
+static int ipu_psys_kcmd_send_to_ppg(struct ipu_psys_kcmd *kcmd)
+{
+	struct ipu_psys_fh *fh = kcmd->fh;
+	struct ipu_psys *psys = fh->psys;
+	struct ipu_psys_ppg *kppg;
+	struct ipu_psys_resource_pool *rpr;
+	unsigned long flags;
+	u8 id;
+	bool resche = true;
+
+	rpr = &psys->resource_pool_running;
+	if (kcmd->state == KCMD_STATE_PPG_START)
+		return ipu_psys_kcmd_send_to_ppg_start(kcmd);
+
+	kppg = ipu_psys_identify_kppg(kcmd);
+	spin_lock_irqsave(&psys->pgs_lock, flags);
+	kcmd->kpg->pg_size = 0;
+	spin_unlock_irqrestore(&psys->pgs_lock, flags);
+	if (!kppg) {
+		dev_err(&psys->adev->dev, "token not match\n");
+		return -EINVAL;
+	}
+
+	kcmd->kpg = kppg->kpg;
+
+	dev_dbg(&psys->adev->dev, "%s ppg(%d, 0x%p) kcmd %p\n",
+		(kcmd->state == KCMD_STATE_PPG_STOP) ?
+		"STOP" : "ENQUEUE",
+		ipu_fw_psys_pg_get_id(kcmd), kppg, kcmd);
+
+	if (kcmd->state == KCMD_STATE_PPG_STOP) {
+		mutex_lock(&kppg->mutex);
+		if (kppg->state == PPG_STATE_STOPPED) {
+			dev_dbg(&psys->adev->dev,
+				"kppg 0x%p  stopped!\n", kppg);
+			id = ipu_fw_psys_ppg_get_base_queue_id(kcmd);
+			ipu_psys_free_cmd_queue_resource(rpr, id);
+			ipu_psys_kcmd_complete(kppg, kcmd, 0);
+			pm_runtime_put(&psys->adev->dev);
+			resche = false;
+		} else {
+			list_add(&kcmd->list, &kppg->kcmds_new_list);
+		}
+		mutex_unlock(&kppg->mutex);
+	} else {
+		int ret;
+
+		ret = ipu_psys_ppg_get_bufset(kcmd, kppg);
+		if (ret)
+			return ret;
+
+		mutex_lock(&kppg->mutex);
+		list_add_tail(&kcmd->list, &kppg->kcmds_new_list);
+		mutex_unlock(&kppg->mutex);
+	}
+
+	if (resche) {
+		/* Kick l-scheduler thread */
+		atomic_set(&psys->wakeup_count, 1);
+		wake_up_interruptible(&psys->sched_cmd_wq);
+	}
+	return 0;
+}
+
+int ipu_psys_kcmd_new(struct ipu_psys_command *cmd, struct ipu_psys_fh *fh)
+{
+	struct ipu_psys *psys = fh->psys;
+	struct ipu_psys_kcmd *kcmd;
+	size_t pg_size;
+	int ret;
+
+	if (psys->adev->isp->flr_done)
+		return -EIO;
+
+	kcmd = ipu_psys_copy_cmd(cmd, fh);
+	if (!kcmd)
+		return -EINVAL;
+
+	pg_size = ipu_fw_psys_pg_get_size(kcmd);
+	if (pg_size > kcmd->kpg->pg_size) {
+		dev_dbg(&psys->adev->dev, "pg size mismatch %lu %lu\n",
+			pg_size, kcmd->kpg->pg_size);
+		ret = -EINVAL;
+		goto error;
+	}
+
+	if (ipu_fw_psys_pg_get_protocol(kcmd) !=
+			IPU_FW_PSYS_PROCESS_GROUP_PROTOCOL_PPG) {
+		dev_err(&psys->adev->dev, "No support legacy pg now\n");
+		ret = -EINVAL;
+		goto error;
+	}
+
+	if (cmd->min_psys_freq) {
+		kcmd->constraint.min_freq = cmd->min_psys_freq;
+		ipu_buttress_add_psys_constraint(psys->adev->isp,
+						 &kcmd->constraint);
+	}
+
+	ret = ipu_psys_kcmd_send_to_ppg(kcmd);
+	if (ret)
+		goto error;
+
+	dev_dbg(&psys->adev->dev,
+		"IOC_QCMD: user_token:%llx issue_id:0x%llx pri:%d\n",
+		cmd->user_token, cmd->issue_id, cmd->priority);
+
+	return 0;
+
+error:
+	ipu_psys_kcmd_free(kcmd);
+
+	return ret;
+}
+
+static bool ipu_psys_kcmd_is_valid(struct ipu_psys *psys,
+				   struct ipu_psys_kcmd *kcmd)
+{
+	struct ipu_psys_fh *fh;
+	struct ipu_psys_kcmd *kcmd0;
+	struct ipu_psys_ppg *kppg, *tmp;
+	struct ipu_psys_scheduler *sched;
+
+	list_for_each_entry(fh, &psys->fhs, list) {
+		sched = &fh->sched;
+		mutex_lock(&fh->mutex);
+		if (list_empty(&sched->ppgs)) {
+			mutex_unlock(&fh->mutex);
+			continue;
+		}
+		list_for_each_entry_safe(kppg, tmp, &sched->ppgs, list) {
+			mutex_lock(&kppg->mutex);
+			list_for_each_entry(kcmd0,
+					    &kppg->kcmds_processing_list,
+					    list) {
+				if (kcmd0 == kcmd) {
+					mutex_unlock(&kppg->mutex);
+					mutex_unlock(&fh->mutex);
+					return true;
+				}
+			}
+			mutex_unlock(&kppg->mutex);
+		}
+		mutex_unlock(&fh->mutex);
+	}
+
+	return false;
+}
+
+void ipu_psys_handle_events(struct ipu_psys *psys)
+{
+	struct ipu_psys_kcmd *kcmd;
+	struct ipu_fw_psys_event event;
+	struct ipu_psys_ppg *kppg;
+	bool error;
+	u32 hdl;
+	u16 cmd, status;
+	int res;
+
+	do {
+		memset(&event, 0, sizeof(event));
+		if (!ipu_fw_psys_rcv_event(psys, &event))
+			break;
+
+		if (!event.context_handle)
+			break;
+
+		dev_dbg(&psys->adev->dev, "ppg event: 0x%x, %d, status %d\n",
+			event.context_handle, event.command, event.status);
+
+		error = false;
+		/*
+		 * event.command == CMD_RUN shows this is fw processing frame
+		 * done as pPG mode, and event.context_handle should be pointer
+		 * of buffer set; so we make use of this pointer to lookup
+		 * kbuffer_set and kcmd
+		 */
+		hdl = event.context_handle;
+		cmd = event.command;
+		status = event.status;
+
+		kppg = NULL;
+		kcmd = NULL;
+		if (cmd == IPU_FW_PSYS_PROCESS_GROUP_CMD_RUN) {
+			struct ipu_psys_buffer_set *kbuf_set;
+			/*
+			 * Need change ppg state when the 1st running is done
+			 * (after PPG started/resumed)
+			 */
+			kbuf_set = ipu_psys_lookup_kbuffer_set(psys, hdl);
+			if (kbuf_set)
+				kcmd = kbuf_set->kcmd;
+			if (!kbuf_set || !kcmd)
+				error = true;
+			else
+				kppg = ipu_psys_identify_kppg(kcmd);
+		} else if (cmd == IPU_FW_PSYS_PROCESS_GROUP_CMD_STOP ||
+			   cmd == IPU_FW_PSYS_PROCESS_GROUP_CMD_SUSPEND ||
+			   cmd == IPU_FW_PSYS_PROCESS_GROUP_CMD_RESUME) {
+			/*
+			 * STOP/SUSPEND/RESUME cmd event would run this branch;
+			 * only stop cmd queued by user has stop_kcmd and need
+			 * to notify user to dequeue.
+			 */
+			kppg = ipu_psys_lookup_ppg(psys, hdl);
+			if (kppg) {
+				mutex_lock(&kppg->mutex);
+				if (kppg->state == PPG_STATE_STOPPING) {
+					kcmd = ipu_psys_ppg_get_stop_kcmd(kppg);
+					if (!kcmd)
+						error = true;
+				}
+				mutex_unlock(&kppg->mutex);
+			}
+		} else {
+			dev_err(&psys->adev->dev, "invalid event\n");
+			continue;
+		}
+
+		if (error || !kppg) {
+			dev_err(&psys->adev->dev, "event error, command %d\n",
+				cmd);
+			break;
+		}
+
+		dev_dbg(&psys->adev->dev, "event to kppg 0x%p, kcmd 0x%p\n",
+			kppg, kcmd);
+
+		ipu_psys_ppg_complete(psys, kppg);
+
+		if (kcmd && ipu_psys_kcmd_is_valid(psys, kcmd)) {
+			res = (status == IPU_PSYS_EVENT_CMD_COMPLETE ||
+			       status == IPU_PSYS_EVENT_FRAGMENT_COMPLETE) ?
+				0 : -EIO;
+			mutex_lock(&kppg->mutex);
+			ipu_psys_kcmd_complete(kppg, kcmd, res);
+			mutex_unlock(&kppg->mutex);
+		}
+	} while (1);
+}
+
+int ipu_psys_fh_init(struct ipu_psys_fh *fh)
+{
+	struct ipu_psys *psys = fh->psys;
+	struct ipu_psys_buffer_set *kbuf_set, *kbuf_set_tmp;
+	struct ipu_psys_scheduler *sched = &fh->sched;
+	int i;
+
+	mutex_init(&sched->bs_mutex);
+	INIT_LIST_HEAD(&sched->buf_sets);
+	INIT_LIST_HEAD(&sched->ppgs);
+	pm_runtime_dont_use_autosuspend(&psys->adev->dev);
+	/* allocate and map memory for buf_sets */
+	for (i = 0; i < IPU_PSYS_BUF_SET_POOL_SIZE; i++) {
+		kbuf_set = kzalloc(sizeof(*kbuf_set), GFP_KERNEL);
+		if (!kbuf_set)
+			goto out_free_buf_sets;
+		kbuf_set->kaddr = dma_alloc_attrs(&psys->adev->dev,
+						  IPU_PSYS_BUF_SET_MAX_SIZE,
+						  &kbuf_set->dma_addr,
+						  GFP_KERNEL,
+						  0);
+		if (!kbuf_set->kaddr) {
+			kfree(kbuf_set);
+			goto out_free_buf_sets;
+		}
+		kbuf_set->size = IPU_PSYS_BUF_SET_MAX_SIZE;
+		list_add(&kbuf_set->list, &sched->buf_sets);
+	}
+
+	return 0;
+
+out_free_buf_sets:
+	list_for_each_entry_safe(kbuf_set, kbuf_set_tmp,
+				 &sched->buf_sets, list) {
+		dma_free_attrs(&psys->adev->dev,
+			       kbuf_set->size, kbuf_set->kaddr,
+			       kbuf_set->dma_addr, 0);
+		list_del(&kbuf_set->list);
+		kfree(kbuf_set);
+	}
+	mutex_destroy(&sched->bs_mutex);
+
+	return -ENOMEM;
+}
+
+int ipu_psys_fh_deinit(struct ipu_psys_fh *fh)
+{
+	struct ipu_psys *psys = fh->psys;
+	struct ipu_psys_ppg *kppg, *kppg0;
+	struct ipu_psys_kcmd *kcmd, *kcmd0;
+	struct ipu_psys_buffer_set *kbuf_set, *kbuf_set0;
+	struct ipu_psys_scheduler *sched = &fh->sched;
+	struct ipu_psys_resource_pool *rpr;
+	struct ipu_psys_resource_alloc *alloc;
+	u8 id;
+
+	mutex_lock(&fh->mutex);
+	if (!list_empty(&sched->ppgs)) {
+		list_for_each_entry_safe(kppg, kppg0, &sched->ppgs, list) {
+			unsigned long flags;
+
+			mutex_lock(&kppg->mutex);
+			if (!(kppg->state &
+			      (PPG_STATE_STOPPED |
+			       PPG_STATE_STOPPING))) {
+				struct ipu_psys_kcmd tmp = {
+					.kpg = kppg->kpg,
+				};
+
+				rpr = &psys->resource_pool_running;
+				alloc = &kppg->kpg->resource_alloc;
+				id = ipu_fw_psys_ppg_get_base_queue_id(&tmp);
+				ipu_psys_ppg_stop(kppg);
+				ipu_psys_free_resources(alloc, rpr);
+				ipu_psys_free_cmd_queue_resource(rpr, id);
+				dev_dbg(&psys->adev->dev,
+				    "s_change:%s %p %d -> %d\n", __func__,
+				    kppg, kppg->state, PPG_STATE_STOPPED);
+				kppg->state = PPG_STATE_STOPPED;
+				if (psys->power_gating != PSYS_POWER_GATED)
+					pm_runtime_put(&psys->adev->dev);
+			}
+			list_del(&kppg->list);
+			mutex_unlock(&kppg->mutex);
+
+			list_for_each_entry_safe(kcmd, kcmd0,
+						 &kppg->kcmds_new_list, list) {
+				kcmd->pg_user = NULL;
+				mutex_unlock(&fh->mutex);
+				ipu_psys_kcmd_free(kcmd);
+				mutex_lock(&fh->mutex);
+			}
+
+			list_for_each_entry_safe(kcmd, kcmd0,
+						 &kppg->kcmds_processing_list,
+						 list) {
+				kcmd->pg_user = NULL;
+				mutex_unlock(&fh->mutex);
+				ipu_psys_kcmd_free(kcmd);
+				mutex_lock(&fh->mutex);
+			}
+
+			list_for_each_entry_safe(kcmd, kcmd0,
+						 &kppg->kcmds_finished_list,
+						 list) {
+				kcmd->pg_user = NULL;
+				mutex_unlock(&fh->mutex);
+				ipu_psys_kcmd_free(kcmd);
+				mutex_lock(&fh->mutex);
+			}
+
+			spin_lock_irqsave(&psys->pgs_lock, flags);
+			kppg->kpg->pg_size = 0;
+			spin_unlock_irqrestore(&psys->pgs_lock, flags);
+
+			mutex_destroy(&kppg->mutex);
+			kfree(kppg->manifest);
+			kfree(kppg);
+		}
+	}
+	mutex_unlock(&fh->mutex);
+
+	mutex_lock(&sched->bs_mutex);
+	list_for_each_entry_safe(kbuf_set, kbuf_set0, &sched->buf_sets, list) {
+		dma_free_attrs(&psys->adev->dev,
+			       kbuf_set->size, kbuf_set->kaddr,
+			       kbuf_set->dma_addr, 0);
+		list_del(&kbuf_set->list);
+		kfree(kbuf_set);
+	}
+	mutex_unlock(&sched->bs_mutex);
+	mutex_destroy(&sched->bs_mutex);
+
+	return 0;
+}
+
+struct ipu_psys_kcmd *ipu_get_completed_kcmd(struct ipu_psys_fh *fh)
+{
+	struct ipu_psys_scheduler *sched = &fh->sched;
+	struct ipu_psys_kcmd *kcmd;
+	struct ipu_psys_ppg *kppg;
+
+	mutex_lock(&fh->mutex);
+	if (list_empty(&sched->ppgs)) {
+		mutex_unlock(&fh->mutex);
+		return NULL;
+	}
+
+	list_for_each_entry(kppg, &sched->ppgs, list) {
+		mutex_lock(&kppg->mutex);
+		if (list_empty(&kppg->kcmds_finished_list)) {
+			mutex_unlock(&kppg->mutex);
+			continue;
+		}
+
+		kcmd = list_first_entry(&kppg->kcmds_finished_list,
+					struct ipu_psys_kcmd, list);
+		mutex_unlock(&fh->mutex);
+		mutex_unlock(&kppg->mutex);
+		dev_dbg(&fh->psys->adev->dev,
+			"get completed kcmd 0x%p\n", kcmd);
+		return kcmd;
+	}
+	mutex_unlock(&fh->mutex);
+
+	return NULL;
+}
+
+long ipu_ioctl_dqevent(struct ipu_psys_event *event,
+		       struct ipu_psys_fh *fh, unsigned int f_flags)
+{
+	struct ipu_psys *psys = fh->psys;
+	struct ipu_psys_kcmd *kcmd = NULL;
+	int rval;
+
+	dev_dbg(&psys->adev->dev, "IOC_DQEVENT\n");
+
+	if (!(f_flags & O_NONBLOCK)) {
+		rval = wait_event_interruptible(fh->wait,
+						(kcmd =
+						 ipu_get_completed_kcmd(fh)));
+		if (rval == -ERESTARTSYS)
+			return rval;
+	}
+
+	if (!kcmd) {
+		kcmd = ipu_get_completed_kcmd(fh);
+		if (!kcmd)
+			return -ENODATA;
+	}
+
+	*event = kcmd->ev;
+	ipu_psys_kcmd_free(kcmd);
+
+	return 0;
+}
Index: b/drivers/media/pci/intel/ipu6/ipu6.c
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu6/ipu6.c
@@ -0,0 +1,334 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) 2018 - 2021 Intel Corporation
+
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/firmware.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+
+#include "ipu.h"
+#include "ipu-cpd.h"
+#include "ipu-isys.h"
+#include "ipu-psys.h"
+#include "ipu-platform.h"
+#include "ipu-platform-regs.h"
+#include "ipu-platform-buttress-regs.h"
+#include "ipu-platform-isys-csi2-reg.h"
+
+struct ipu_cell_program_t {
+	unsigned int magic_number;
+
+	unsigned int blob_offset;
+	unsigned int blob_size;
+
+	unsigned int start[3];
+
+	unsigned int icache_source;
+	unsigned int icache_target;
+	unsigned int icache_size;
+
+	unsigned int pmem_source;
+	unsigned int pmem_target;
+	unsigned int pmem_size;
+
+	unsigned int data_source;
+	unsigned int data_target;
+	unsigned int data_size;
+
+	unsigned int bss_target;
+	unsigned int bss_size;
+
+	unsigned int cell_id;
+	unsigned int regs_addr;
+
+	unsigned int cell_pmem_data_bus_address;
+	unsigned int cell_dmem_data_bus_address;
+	unsigned int cell_pmem_control_bus_address;
+	unsigned int cell_dmem_control_bus_address;
+
+	unsigned int next;
+	unsigned int dummy[2];
+};
+
+static unsigned int ipu6se_csi_offsets[] = {
+	IPU_CSI_PORT_A_ADDR_OFFSET,
+	IPU_CSI_PORT_B_ADDR_OFFSET,
+	IPU_CSI_PORT_C_ADDR_OFFSET,
+	IPU_CSI_PORT_D_ADDR_OFFSET,
+};
+
+static unsigned int ipu6_csi_offsets[] = {
+	IPU_CSI_PORT_A_ADDR_OFFSET,
+	IPU_CSI_PORT_B_ADDR_OFFSET,
+	IPU_CSI_PORT_C_ADDR_OFFSET,
+	IPU_CSI_PORT_D_ADDR_OFFSET,
+	IPU_CSI_PORT_E_ADDR_OFFSET,
+	IPU_CSI_PORT_F_ADDR_OFFSET,
+	IPU_CSI_PORT_G_ADDR_OFFSET,
+	IPU_CSI_PORT_H_ADDR_OFFSET
+};
+
+struct ipu_isys_internal_pdata isys_ipdata = {
+	.hw_variant = {
+		       .offset = IPU_UNIFIED_OFFSET,
+		       .nr_mmus = 3,
+		       .mmu_hw = {
+				{
+				   .offset = IPU_ISYS_IOMMU0_OFFSET,
+				   .info_bits =
+				   IPU_INFO_REQUEST_DESTINATION_IOSF,
+				   .nr_l1streams = 16,
+				   .l1_block_sz = {
+						   3, 8, 2, 2, 2, 2, 2, 2, 1, 1,
+						   1, 1, 1, 1, 1, 1
+				   },
+				   .nr_l2streams = 16,
+				   .l2_block_sz = {
+						   2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+						   2, 2, 2, 2, 2, 2
+				   },
+				   .insert_read_before_invalidate = false,
+				   .l1_stream_id_reg_offset =
+				   IPU_MMU_L1_STREAM_ID_REG_OFFSET,
+				   .l2_stream_id_reg_offset =
+				   IPU_MMU_L2_STREAM_ID_REG_OFFSET,
+				},
+				{
+				   .offset = IPU_ISYS_IOMMU1_OFFSET,
+				   .info_bits = IPU_INFO_STREAM_ID_SET(0),
+				   .nr_l1streams = 16,
+				   .l1_block_sz = {
+						   2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+						   2, 2, 2, 1, 1, 4
+				   },
+				   .nr_l2streams = 16,
+				   .l2_block_sz = {
+						   2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+						   2, 2, 2, 2, 2, 2
+				   },
+				   .insert_read_before_invalidate = false,
+				   .l1_stream_id_reg_offset =
+				   IPU_MMU_L1_STREAM_ID_REG_OFFSET,
+				   .l2_stream_id_reg_offset =
+				   IPU_MMU_L2_STREAM_ID_REG_OFFSET,
+				},
+				{
+				   .offset = IPU_ISYS_IOMMUI_OFFSET,
+				   .info_bits = IPU_INFO_STREAM_ID_SET(0),
+				   .nr_l1streams = 0,
+				   .nr_l2streams = 0,
+				   .insert_read_before_invalidate = false,
+				},
+			},
+		       .cdc_fifos = 3,
+		       .cdc_fifo_threshold = {6, 8, 2},
+		       .dmem_offset = IPU_ISYS_DMEM_OFFSET,
+		       .spc_offset = IPU_ISYS_SPC_OFFSET,
+	},
+	.isys_dma_overshoot = IPU_ISYS_OVERALLOC_MIN,
+};
+
+struct ipu_psys_internal_pdata psys_ipdata = {
+	.hw_variant = {
+		       .offset = IPU_UNIFIED_OFFSET,
+		       .nr_mmus = 4,
+		       .mmu_hw = {
+				{
+				   .offset = IPU_PSYS_IOMMU0_OFFSET,
+				   .info_bits =
+				   IPU_INFO_REQUEST_DESTINATION_IOSF,
+				   .nr_l1streams = 16,
+				   .l1_block_sz = {
+						   2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+						   2, 2, 2, 2, 2, 2
+				   },
+				   .nr_l2streams = 16,
+				   .l2_block_sz = {
+						   2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+						   2, 2, 2, 2, 2, 2
+				   },
+				   .insert_read_before_invalidate = false,
+				   .l1_stream_id_reg_offset =
+				   IPU_MMU_L1_STREAM_ID_REG_OFFSET,
+				   .l2_stream_id_reg_offset =
+				   IPU_MMU_L2_STREAM_ID_REG_OFFSET,
+				},
+				{
+				   .offset = IPU_PSYS_IOMMU1_OFFSET,
+				   .info_bits = IPU_INFO_STREAM_ID_SET(0),
+				   .nr_l1streams = 32,
+				   .l1_block_sz = {
+						   1, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+						   2, 2, 2, 2, 2, 10,
+						   5, 4, 14, 6, 4, 14, 6, 4, 8,
+						   4, 2, 1, 1, 1, 1, 14
+				   },
+				   .nr_l2streams = 32,
+				   .l2_block_sz = {
+						   2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+						   2, 2, 2, 2, 2, 2,
+						   2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+						   2, 2, 2, 2, 2, 2
+				   },
+				   .insert_read_before_invalidate = false,
+				   .l1_stream_id_reg_offset =
+				   IPU_MMU_L1_STREAM_ID_REG_OFFSET,
+				   .l2_stream_id_reg_offset =
+				   IPU_PSYS_MMU1W_L2_STREAM_ID_REG_OFFSET,
+				},
+				{
+				   .offset = IPU_PSYS_IOMMU1R_OFFSET,
+				   .info_bits = IPU_INFO_STREAM_ID_SET(0),
+				   .nr_l1streams = 16,
+				   .l1_block_sz = {
+						   1, 4, 4, 4, 4, 16, 8, 4, 32,
+						   16, 16, 2, 2, 2, 1, 12
+				   },
+				   .nr_l2streams = 16,
+				   .l2_block_sz = {
+						   2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+						   2, 2, 2, 2, 2, 2
+				   },
+				   .insert_read_before_invalidate = false,
+				   .l1_stream_id_reg_offset =
+				   IPU_MMU_L1_STREAM_ID_REG_OFFSET,
+				   .l2_stream_id_reg_offset =
+				   IPU_MMU_L2_STREAM_ID_REG_OFFSET,
+				},
+				{
+				   .offset = IPU_PSYS_IOMMUI_OFFSET,
+				   .info_bits = IPU_INFO_STREAM_ID_SET(0),
+				   .nr_l1streams = 0,
+				   .nr_l2streams = 0,
+				   .insert_read_before_invalidate = false,
+				},
+		},
+	       .dmem_offset = IPU_PSYS_DMEM_OFFSET,
+	},
+};
+
+const struct ipu_buttress_ctrl isys_buttress_ctrl = {
+	.ratio = IPU_IS_FREQ_CTL_DEFAULT_RATIO,
+	.qos_floor = IPU_IS_FREQ_CTL_DEFAULT_QOS_FLOOR_RATIO,
+	.freq_ctl = IPU_BUTTRESS_REG_IS_FREQ_CTL,
+	.pwr_sts_shift = IPU_BUTTRESS_PWR_STATE_IS_PWR_SHIFT,
+	.pwr_sts_mask = IPU_BUTTRESS_PWR_STATE_IS_PWR_MASK,
+	.pwr_sts_on = IPU_BUTTRESS_PWR_STATE_UP_DONE,
+	.pwr_sts_off = IPU_BUTTRESS_PWR_STATE_DN_DONE,
+};
+
+const struct ipu_buttress_ctrl psys_buttress_ctrl = {
+	.ratio = IPU_PS_FREQ_CTL_DEFAULT_RATIO,
+	.qos_floor = IPU_PS_FREQ_CTL_DEFAULT_QOS_FLOOR_RATIO,
+	.freq_ctl = IPU_BUTTRESS_REG_PS_FREQ_CTL,
+	.pwr_sts_shift = IPU_BUTTRESS_PWR_STATE_PS_PWR_SHIFT,
+	.pwr_sts_mask = IPU_BUTTRESS_PWR_STATE_PS_PWR_MASK,
+	.pwr_sts_on = IPU_BUTTRESS_PWR_STATE_UP_DONE,
+	.pwr_sts_off = IPU_BUTTRESS_PWR_STATE_DN_DONE,
+};
+
+static void ipu6_pkg_dir_configure_spc(struct ipu_device *isp,
+				       const struct ipu_hw_variants *hw_variant,
+				       int pkg_dir_idx, void __iomem *base,
+				       u64 *pkg_dir,
+				       dma_addr_t pkg_dir_vied_address)
+{
+	struct ipu_psys *psys = ipu_bus_get_drvdata(isp->psys);
+	struct ipu_isys *isys = ipu_bus_get_drvdata(isp->isys);
+	unsigned int server_fw_virtaddr;
+	struct ipu_cell_program_t *prog;
+	void __iomem *spc_base;
+	dma_addr_t dma_addr;
+
+	if (!pkg_dir || !isp->cpd_fw) {
+		dev_err(&isp->pdev->dev, "invalid addr\n");
+		return;
+	}
+
+	server_fw_virtaddr = *(pkg_dir + (pkg_dir_idx + 1) * 2);
+	if (pkg_dir_idx == IPU_CPD_PKG_DIR_ISYS_SERVER_IDX) {
+		dma_addr = sg_dma_address(isys->fw_sgt.sgl);
+		prog = (struct ipu_cell_program_t *)((u64)isp->cpd_fw->data +
+							(server_fw_virtaddr -
+							 dma_addr));
+	} else {
+		dma_addr = sg_dma_address(psys->fw_sgt.sgl);
+		prog = (struct ipu_cell_program_t *)((u64)isp->cpd_fw->data +
+							(server_fw_virtaddr -
+							 dma_addr));
+	}
+
+	spc_base = base + prog->regs_addr;
+	if (spc_base != (base + hw_variant->spc_offset))
+		dev_warn(&isp->pdev->dev,
+			 "SPC reg addr 0x%p not matching value from CPD 0x%p\n",
+			 base + hw_variant->spc_offset, spc_base);
+	writel(server_fw_virtaddr + prog->blob_offset +
+	       prog->icache_source, spc_base + IPU_PSYS_REG_SPC_ICACHE_BASE);
+	writel(IPU_INFO_REQUEST_DESTINATION_IOSF,
+	       spc_base + IPU_REG_PSYS_INFO_SEG_0_CONFIG_ICACHE_MASTER);
+	writel(prog->start[1], spc_base + IPU_PSYS_REG_SPC_START_PC);
+	writel(pkg_dir_vied_address, base + hw_variant->dmem_offset);
+}
+
+void ipu_configure_spc(struct ipu_device *isp,
+		       const struct ipu_hw_variants *hw_variant,
+		       int pkg_dir_idx, void __iomem *base, u64 *pkg_dir,
+		       dma_addr_t pkg_dir_dma_addr)
+{
+	u32 val;
+	void __iomem *dmem_base = base + hw_variant->dmem_offset;
+	void __iomem *spc_regs_base = base + hw_variant->spc_offset;
+
+	val = readl(spc_regs_base + IPU_PSYS_REG_SPC_STATUS_CTRL);
+	val |= IPU_PSYS_SPC_STATUS_CTRL_ICACHE_INVALIDATE;
+	writel(val, spc_regs_base + IPU_PSYS_REG_SPC_STATUS_CTRL);
+
+	if (isp->secure_mode)
+		writel(IPU_PKG_DIR_IMR_OFFSET, dmem_base);
+	else
+		ipu6_pkg_dir_configure_spc(isp, hw_variant, pkg_dir_idx, base,
+					   pkg_dir, pkg_dir_dma_addr);
+}
+EXPORT_SYMBOL(ipu_configure_spc);
+
+int ipu_buttress_psys_freq_get(void *data, u64 *val)
+{
+	struct ipu_device *isp = data;
+	u32 reg_val;
+	int rval;
+
+	rval = pm_runtime_get_sync(&isp->psys->dev);
+	if (rval < 0) {
+		pm_runtime_put(&isp->psys->dev);
+		dev_err(&isp->pdev->dev, "Runtime PM failed (%d)\n", rval);
+		return rval;
+	}
+
+	reg_val = readl(isp->base + BUTTRESS_REG_PS_FREQ_CTL);
+
+	pm_runtime_put(&isp->psys->dev);
+
+	*val = IPU_PS_FREQ_RATIO_BASE *
+	    (reg_val & IPU_BUTTRESS_PS_FREQ_CTL_DIVISOR_MASK);
+
+	return 0;
+}
+
+void ipu_internal_pdata_init(void)
+{
+	if (ipu_ver == IPU_VER_6 || ipu_ver == IPU_VER_6EP ||
+	    ipu_ver == IPU_VER_6EP_MTL) {
+		isys_ipdata.csi2.nports = ARRAY_SIZE(ipu6_csi_offsets);
+		isys_ipdata.csi2.offsets = ipu6_csi_offsets;
+		isys_ipdata.num_parallel_streams = IPU6_ISYS_NUM_STREAMS;
+		psys_ipdata.hw_variant.spc_offset = IPU6_PSYS_SPC_OFFSET;
+
+	} else if (ipu_ver == IPU_VER_6SE) {
+		isys_ipdata.csi2.nports = ARRAY_SIZE(ipu6se_csi_offsets);
+		isys_ipdata.csi2.offsets = ipu6se_csi_offsets;
+		isys_ipdata.num_parallel_streams = IPU6SE_ISYS_NUM_STREAMS;
+		psys_ipdata.hw_variant.spc_offset = IPU6SE_PSYS_SPC_OFFSET;
+	}
+}
Index: b/drivers/media/pci/intel/ipu6/ipu6ep-fw-resources.c
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu6/ipu6ep-fw-resources.c
@@ -0,0 +1,393 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) 2020 Intel Corporation
+
+#include <linux/err.h>
+#include <linux/string.h>
+
+#include "ipu-psys.h"
+#include "ipu-fw-psys.h"
+#include "ipu6-platform-resources.h"
+#include "ipu6ep-platform-resources.h"
+
+/* resources table */
+
+/*
+ * Cell types by cell IDs
+ */
+static const u8 ipu6ep_fw_psys_cell_types[IPU6EP_FW_PSYS_N_CELL_ID] = {
+	IPU6_FW_PSYS_SP_CTRL_TYPE_ID,
+	IPU6_FW_PSYS_VP_TYPE_ID,
+	IPU6_FW_PSYS_ACC_PSA_TYPE_ID,
+	IPU6_FW_PSYS_ACC_PSA_TYPE_ID,
+	IPU6_FW_PSYS_ACC_PSA_TYPE_ID,
+	IPU6_FW_PSYS_ACC_PSA_TYPE_ID,
+	IPU6_FW_PSYS_ACC_OSA_TYPE_ID,
+	IPU6_FW_PSYS_ACC_OSA_TYPE_ID,
+	IPU6_FW_PSYS_ACC_OSA_TYPE_ID,
+	IPU6_FW_PSYS_ACC_PSA_TYPE_ID,
+	IPU6_FW_PSYS_ACC_PSA_TYPE_ID,
+	IPU6_FW_PSYS_ACC_PSA_TYPE_ID,
+	IPU6_FW_PSYS_ACC_PSA_TYPE_ID,
+	IPU6_FW_PSYS_ACC_ISA_TYPE_ID,
+	IPU6_FW_PSYS_ACC_ISA_TYPE_ID,
+	IPU6_FW_PSYS_ACC_ISA_TYPE_ID,
+	IPU6_FW_PSYS_ACC_ISA_TYPE_ID,
+	IPU6_FW_PSYS_ACC_ISA_TYPE_ID,
+	IPU6_FW_PSYS_ACC_ISA_TYPE_ID,
+	IPU6_FW_PSYS_ACC_ISA_TYPE_ID,
+	IPU6_FW_PSYS_ACC_ISA_TYPE_ID,
+	IPU6_FW_PSYS_ACC_ISA_TYPE_ID,
+	IPU6_FW_PSYS_ACC_ISA_TYPE_ID,
+	IPU6_FW_PSYS_ACC_ISA_TYPE_ID, /* AF */
+	IPU6_FW_PSYS_ACC_ISA_TYPE_ID, /* X2B_MD */
+	IPU6_FW_PSYS_ACC_ISA_TYPE_ID, /* X2B_SVE_RGBIR */
+	IPU6_FW_PSYS_ACC_ISA_TYPE_ID, /* PAF */
+	IPU6_FW_PSYS_GDC_TYPE_ID,
+	IPU6_FW_PSYS_TNR_TYPE_ID,
+};
+
+static const u16 ipu6ep_fw_num_dev_channels[IPU6_FW_PSYS_N_DEV_CHN_ID] = {
+	IPU6_FW_PSYS_DEV_CHN_DMA_EXT0_MAX_SIZE,
+	IPU6_FW_PSYS_DEV_CHN_DMA_EXT1_READ_MAX_SIZE,
+	IPU6_FW_PSYS_DEV_CHN_DMA_EXT1_WRITE_MAX_SIZE,
+	IPU6_FW_PSYS_DEV_CHN_DMA_INTERNAL_MAX_SIZE,
+	IPU6_FW_PSYS_DEV_CHN_DMA_ISA_MAX_SIZE,
+};
+
+static const u16 ipu6ep_fw_psys_mem_size[IPU6_FW_PSYS_N_MEM_ID] = {
+	IPU6_FW_PSYS_VMEM0_MAX_SIZE,
+	IPU6_FW_PSYS_TRANSFER_VMEM0_MAX_SIZE,
+	IPU6_FW_PSYS_TRANSFER_VMEM1_MAX_SIZE,
+	IPU6_FW_PSYS_LB_VMEM_MAX_SIZE,
+	IPU6_FW_PSYS_BAMEM0_MAX_SIZE,
+	IPU6_FW_PSYS_DMEM0_MAX_SIZE,
+	IPU6_FW_PSYS_DMEM1_MAX_SIZE,
+	IPU6_FW_PSYS_DMEM2_MAX_SIZE,
+	IPU6_FW_PSYS_DMEM3_MAX_SIZE,
+	IPU6_FW_PSYS_PMEM0_MAX_SIZE
+};
+
+static const u16 ipu6ep_fw_psys_dfms[IPU6_FW_PSYS_N_DEV_DFM_ID] = {
+	IPU6_FW_PSYS_DEV_DFM_BB_FULL_PORT_ID_MAX_SIZE,
+	IPU6_FW_PSYS_DEV_DFM_BB_EMPTY_PORT_ID_MAX_SIZE,
+	IPU6_FW_PSYS_DEV_DFM_ISL_FULL_PORT_ID_MAX_SIZE,
+	IPU6_FW_PSYS_DEV_DFM_ISL_EMPTY_PORT_ID_MAX_SIZE,
+	IPU6_FW_PSYS_DEV_DFM_LB_FULL_PORT_ID_MAX_SIZE,
+	IPU6_FW_PSYS_DEV_DFM_LB_EMPTY_PORT_ID_MAX_SIZE,
+};
+
+static const u8
+ipu6ep_fw_psys_c_mem[IPU6EP_FW_PSYS_N_CELL_ID][IPU6_FW_PSYS_N_MEM_TYPE_ID] = {
+	{
+		/* IPU6_FW_PSYS_SP0_ID */
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_DMEM0_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+	},
+	{
+		/* IPU6_FW_PSYS_SP1_ID */
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_DMEM1_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+	},
+	{
+		/* IPU6_FW_PSYS_VP0_ID */
+		IPU6_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6_FW_PSYS_TRANSFER_VMEM1_ID,
+		IPU6_FW_PSYS_LB_VMEM_ID,
+		IPU6_FW_PSYS_DMEM3_ID,
+		IPU6_FW_PSYS_VMEM0_ID,
+		IPU6_FW_PSYS_BAMEM0_ID,
+		IPU6_FW_PSYS_PMEM0_ID,
+	},
+	{
+		/* IPU6_FW_PSYS_ACC1_ID BNLM */
+		IPU6_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6_FW_PSYS_TRANSFER_VMEM1_ID,
+		IPU6_FW_PSYS_LB_VMEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+	},
+	{
+		/* IPU6_FW_PSYS_ACC2_ID DM */
+		IPU6_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6_FW_PSYS_TRANSFER_VMEM1_ID,
+		IPU6_FW_PSYS_LB_VMEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+	},
+	{
+		/* IPU6_FW_PSYS_ACC3_ID ACM */
+		IPU6_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6_FW_PSYS_TRANSFER_VMEM1_ID,
+		IPU6_FW_PSYS_LB_VMEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+	},
+	{
+		/* IPU6_FW_PSYS_ACC4_ID GTC YUV1 */
+		IPU6_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6_FW_PSYS_TRANSFER_VMEM1_ID,
+		IPU6_FW_PSYS_LB_VMEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+	},
+	{
+		/* IPU6_FW_PSYS_ACC5_ID OFS pin main */
+		IPU6_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6_FW_PSYS_TRANSFER_VMEM1_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+	},
+	{
+		/* IPU6_FW_PSYS_ACC6_ID OFS pin display */
+		IPU6_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6_FW_PSYS_TRANSFER_VMEM1_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+	},
+	{
+		/* IPU6_FW_PSYS_ACC7_ID OFS pin pp */
+		IPU6_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6_FW_PSYS_TRANSFER_VMEM1_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+	},
+	{
+		/* IPU6_FW_PSYS_ACC8_ID GAMMASTAR */
+		IPU6_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6_FW_PSYS_TRANSFER_VMEM1_ID,
+		IPU6_FW_PSYS_LB_VMEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+	},
+	{
+		/* IPU6_FW_PSYS_ACC9_ID GLTM */
+		IPU6_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6_FW_PSYS_TRANSFER_VMEM1_ID,
+		IPU6_FW_PSYS_LB_VMEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+	},
+	{
+		/* IPU6_FW_PSYS_ACC10_ID XNR */
+		IPU6_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6_FW_PSYS_TRANSFER_VMEM1_ID,
+		IPU6_FW_PSYS_LB_VMEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+	},
+	{
+		/* IPU6_FW_PSYS_ISA_ICA_ID */
+		IPU6_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6_FW_PSYS_TRANSFER_VMEM1_ID,
+		IPU6_FW_PSYS_LB_VMEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+	},
+	{
+		/* IPU6_FW_PSYS_ISA_LSC_ID */
+		IPU6_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6_FW_PSYS_TRANSFER_VMEM1_ID,
+		IPU6_FW_PSYS_LB_VMEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+	},
+	{
+		/* IPU6_FW_PSYS_ISA_DPC_ID */
+		IPU6_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6_FW_PSYS_TRANSFER_VMEM1_ID,
+		IPU6_FW_PSYS_LB_VMEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+	},
+	{
+		/* IPU6_FW_PSYS_ISA_SIS_A_ID */
+		IPU6_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6_FW_PSYS_TRANSFER_VMEM1_ID,
+		IPU6_FW_PSYS_LB_VMEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+	},
+	{
+		/* IPU6_FW_PSYS_ISA_SIS_B_ID */
+		IPU6_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6_FW_PSYS_TRANSFER_VMEM1_ID,
+		IPU6_FW_PSYS_LB_VMEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+	},
+	{
+		/* IPU6_FW_PSYS_ISA_B2B_ID */
+		IPU6_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6_FW_PSYS_TRANSFER_VMEM1_ID,
+		IPU6_FW_PSYS_LB_VMEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+	},
+	{
+		/* IPU6_FW_PSYS_ISA_B2R_ID and ISA_R2I_SIE */
+		IPU6_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6_FW_PSYS_TRANSFER_VMEM1_ID,
+		IPU6_FW_PSYS_LB_VMEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+	},
+	{
+		/* IPU6_FW_PSYS_ISA_R2I_DS_A_ID */
+		IPU6_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6_FW_PSYS_TRANSFER_VMEM1_ID,
+		IPU6_FW_PSYS_LB_VMEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+	},
+	{
+		/* IPU6_FW_PSYS_ISA_AWB_ID */
+		IPU6_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6_FW_PSYS_TRANSFER_VMEM1_ID,
+		IPU6_FW_PSYS_LB_VMEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+	},
+	{
+		/* IPU6_FW_PSYS_ISA_AE_ID */
+		IPU6_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6_FW_PSYS_TRANSFER_VMEM1_ID,
+		IPU6_FW_PSYS_LB_VMEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+	},
+	{
+		/* IPU6_FW_PSYS_ISA_AF_ID */
+		IPU6_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6_FW_PSYS_TRANSFER_VMEM1_ID,
+		IPU6_FW_PSYS_LB_VMEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+	},
+	{
+		/* IPU6_FW_PSYS_ISA_X2B_MD_ID */
+		IPU6_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6_FW_PSYS_TRANSFER_VMEM1_ID,
+		IPU6_FW_PSYS_LB_VMEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+	},
+	{
+		/* IPU6_FW_PSYS_ISA_X2B_SVE_RGBIR_ID */
+		IPU6_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6_FW_PSYS_TRANSFER_VMEM1_ID,
+		IPU6_FW_PSYS_LB_VMEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+	},
+	{
+		/* IPU6_FW_PSYS_ISA_PAF_ID */
+		IPU6_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6_FW_PSYS_TRANSFER_VMEM1_ID,
+		IPU6_FW_PSYS_LB_VMEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+	},
+	{
+		/* IPU6_FW_PSYS_BB_ACC_GDC0_ID */
+		IPU6_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6_FW_PSYS_TRANSFER_VMEM1_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+	},
+	{
+		/* IPU6_FW_PSYS_BB_ACC_TNR_ID */
+		IPU6_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6_FW_PSYS_TRANSFER_VMEM1_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+		IPU6_FW_PSYS_N_MEM_ID,
+	}
+};
+
+static const struct ipu_fw_resource_definitions ipu6ep_defs = {
+	.cells = ipu6ep_fw_psys_cell_types,
+	.num_cells = IPU6EP_FW_PSYS_N_CELL_ID,
+	.num_cells_type = IPU6_FW_PSYS_N_CELL_TYPE_ID,
+
+	.dev_channels = ipu6ep_fw_num_dev_channels,
+	.num_dev_channels = IPU6_FW_PSYS_N_DEV_CHN_ID,
+
+	.num_ext_mem_types = IPU6_FW_PSYS_N_DATA_MEM_TYPE_ID,
+	.num_ext_mem_ids = IPU6_FW_PSYS_N_MEM_ID,
+	.ext_mem_ids = ipu6ep_fw_psys_mem_size,
+
+	.num_dfm_ids = IPU6_FW_PSYS_N_DEV_DFM_ID,
+
+	.dfms = ipu6ep_fw_psys_dfms,
+
+	.cell_mem_row = IPU6_FW_PSYS_N_MEM_TYPE_ID,
+	.cell_mem = &ipu6ep_fw_psys_c_mem[0][0],
+};
+
+const struct ipu_fw_resource_definitions *ipu6ep_res_defs = &ipu6ep_defs;
Index: b/drivers/media/pci/intel/ipu6/ipu6ep-platform-resources.h
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu6/ipu6ep-platform-resources.h
@@ -0,0 +1,42 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2020 Intel Corporation */
+
+#ifndef IPU6EP_PLATFORM_RESOURCES_H
+#define IPU6EP_PLATFORM_RESOURCES_H
+
+#include <linux/kernel.h>
+#include <linux/device.h>
+
+enum {
+	IPU6EP_FW_PSYS_SP0_ID = 0,
+	IPU6EP_FW_PSYS_VP0_ID,
+	IPU6EP_FW_PSYS_PSA_ACC_BNLM_ID,
+	IPU6EP_FW_PSYS_PSA_ACC_DM_ID,
+	IPU6EP_FW_PSYS_PSA_ACC_ACM_ID,
+	IPU6EP_FW_PSYS_PSA_ACC_GTC_YUV1_ID,
+	IPU6EP_FW_PSYS_BB_ACC_OFS_PIN_MAIN_ID,
+	IPU6EP_FW_PSYS_BB_ACC_OFS_PIN_DISPLAY_ID,
+	IPU6EP_FW_PSYS_BB_ACC_OFS_PIN_PP_ID,
+	IPU6EP_FW_PSYS_PSA_ACC_GAMMASTAR_ID,
+	IPU6EP_FW_PSYS_PSA_ACC_GLTM_ID,
+	IPU6EP_FW_PSYS_PSA_ACC_XNR_ID,
+	IPU6EP_FW_PSYS_PSA_VCSC_ID,	/* VCSC */
+	IPU6EP_FW_PSYS_ISA_ICA_ID,
+	IPU6EP_FW_PSYS_ISA_LSC_ID,
+	IPU6EP_FW_PSYS_ISA_DPC_ID,
+	IPU6EP_FW_PSYS_ISA_SIS_A_ID,
+	IPU6EP_FW_PSYS_ISA_SIS_B_ID,
+	IPU6EP_FW_PSYS_ISA_B2B_ID,
+	IPU6EP_FW_PSYS_ISA_B2R_R2I_SIE_ID,
+	IPU6EP_FW_PSYS_ISA_R2I_DS_A_ID,
+	IPU6EP_FW_PSYS_ISA_AWB_ID,
+	IPU6EP_FW_PSYS_ISA_AE_ID,
+	IPU6EP_FW_PSYS_ISA_AF_ID,
+	IPU6EP_FW_PSYS_ISA_X2B_MD_ID,
+	IPU6EP_FW_PSYS_ISA_X2B_SVE_RGBIR_ID,
+	IPU6EP_FW_PSYS_ISA_PAF_ID,
+	IPU6EP_FW_PSYS_BB_ACC_GDC0_ID,
+	IPU6EP_FW_PSYS_BB_ACC_TNR_ID,
+	IPU6EP_FW_PSYS_N_CELL_ID
+};
+#endif /* IPU6EP_PLATFORM_RESOURCES_H */
Index: b/drivers/media/pci/intel/ipu6/ipu6se-fw-resources.c
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu6/ipu6se-fw-resources.c
@@ -0,0 +1,194 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) 2015 - 2019 Intel Corporation
+
+#include <linux/err.h>
+#include <linux/string.h>
+
+#include "ipu-psys.h"
+#include "ipu-fw-psys.h"
+#include "ipu6se-platform-resources.h"
+
+/* resources table */
+
+/*
+ * Cell types by cell IDs
+ */
+/* resources table */
+
+/*
+ * Cell types by cell IDs
+ */
+const u8 ipu6se_fw_psys_cell_types[IPU6SE_FW_PSYS_N_CELL_ID] = {
+	IPU6SE_FW_PSYS_SP_CTRL_TYPE_ID,
+	IPU6SE_FW_PSYS_ACC_ISA_TYPE_ID, /* IPU6SE_FW_PSYS_ISA_ICA_ID */
+	IPU6SE_FW_PSYS_ACC_ISA_TYPE_ID, /* IPU6SE_FW_PSYS_ISA_LSC_ID */
+	IPU6SE_FW_PSYS_ACC_ISA_TYPE_ID, /* IPU6SE_FW_PSYS_ISA_DPC_ID */
+	IPU6SE_FW_PSYS_ACC_ISA_TYPE_ID, /* IPU6SE_FW_PSYS_ISA_B2B_ID */
+	IPU6SE_FW_PSYS_ACC_ISA_TYPE_ID, /* IPU6SE_FW_PSYS_ISA_BNLM_ID */
+	IPU6SE_FW_PSYS_ACC_ISA_TYPE_ID, /* IPU6SE_FW_PSYS_ISA_DM_ID */
+	IPU6SE_FW_PSYS_ACC_ISA_TYPE_ID, /* IPU6SE_FW_PSYS_ISA_R2I_SIE_ID */
+	IPU6SE_FW_PSYS_ACC_ISA_TYPE_ID, /* IPU6SE_FW_PSYS_ISA_R2I_DS_A_ID */
+	IPU6SE_FW_PSYS_ACC_ISA_TYPE_ID, /* IPU6SE_FW_PSYS_ISA_R2I_DS_B_ID */
+	IPU6SE_FW_PSYS_ACC_ISA_TYPE_ID, /* IPU6SE_FW_PSYS_ISA_AWB_ID */
+	IPU6SE_FW_PSYS_ACC_ISA_TYPE_ID, /* IPU6SE_FW_PSYS_ISA_AE_ID */
+	IPU6SE_FW_PSYS_ACC_ISA_TYPE_ID, /* IPU6SE_FW_PSYS_ISA_AF_ID*/
+	IPU6SE_FW_PSYS_ACC_ISA_TYPE_ID  /* PAF */
+};
+
+const u16 ipu6se_fw_num_dev_channels[IPU6SE_FW_PSYS_N_DEV_CHN_ID] = {
+	IPU6SE_FW_PSYS_DEV_CHN_DMA_EXT0_MAX_SIZE,
+	IPU6SE_FW_PSYS_DEV_CHN_DMA_EXT1_READ_MAX_SIZE,
+	IPU6SE_FW_PSYS_DEV_CHN_DMA_EXT1_WRITE_MAX_SIZE,
+	IPU6SE_FW_PSYS_DEV_CHN_DMA_ISA_MAX_SIZE,
+};
+
+const u16 ipu6se_fw_psys_mem_size[IPU6SE_FW_PSYS_N_MEM_ID] = {
+	IPU6SE_FW_PSYS_TRANSFER_VMEM0_MAX_SIZE,
+	IPU6SE_FW_PSYS_LB_VMEM_MAX_SIZE,
+	IPU6SE_FW_PSYS_DMEM0_MAX_SIZE,
+	IPU6SE_FW_PSYS_DMEM1_MAX_SIZE
+};
+
+const u16 ipu6se_fw_psys_dfms[IPU6SE_FW_PSYS_N_DEV_DFM_ID] = {
+	IPU6SE_FW_PSYS_DEV_DFM_ISL_FULL_PORT_ID_MAX_SIZE,
+	IPU6SE_FW_PSYS_DEV_DFM_ISL_EMPTY_PORT_ID_MAX_SIZE
+};
+
+const u8
+ipu6se_fw_psys_c_mem[IPU6SE_FW_PSYS_N_CELL_ID][IPU6SE_FW_PSYS_N_MEM_TYPE_ID] = {
+	{ /* IPU6SE_FW_PSYS_SP0_ID */
+		IPU6SE_FW_PSYS_N_MEM_ID,
+		IPU6SE_FW_PSYS_N_MEM_ID,
+		IPU6SE_FW_PSYS_DMEM0_ID,
+		IPU6SE_FW_PSYS_N_MEM_ID,
+		IPU6SE_FW_PSYS_N_MEM_ID,
+		IPU6SE_FW_PSYS_N_MEM_ID,
+	},
+	{ /* IPU6SE_FW_PSYS_ISA_ICA_ID */
+		IPU6SE_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6SE_FW_PSYS_LB_VMEM_ID,
+		IPU6SE_FW_PSYS_N_MEM_ID,
+		IPU6SE_FW_PSYS_N_MEM_ID,
+		IPU6SE_FW_PSYS_N_MEM_ID,
+		IPU6SE_FW_PSYS_N_MEM_ID,
+	},
+	{ /* IPU6SE_FW_PSYS_ISA_LSC_ID */
+		IPU6SE_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6SE_FW_PSYS_LB_VMEM_ID,
+		IPU6SE_FW_PSYS_N_MEM_ID,
+		IPU6SE_FW_PSYS_N_MEM_ID,
+		IPU6SE_FW_PSYS_N_MEM_ID,
+		IPU6SE_FW_PSYS_N_MEM_ID,
+	},
+	{ /* IPU6SE_FW_PSYS_ISA_DPC_ID */
+		IPU6SE_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6SE_FW_PSYS_LB_VMEM_ID,
+		IPU6SE_FW_PSYS_N_MEM_ID,
+		IPU6SE_FW_PSYS_N_MEM_ID,
+		IPU6SE_FW_PSYS_N_MEM_ID,
+		IPU6SE_FW_PSYS_N_MEM_ID,
+	},
+	{ /* IPU6SE_FW_PSYS_ISA_B2B_ID */
+		IPU6SE_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6SE_FW_PSYS_LB_VMEM_ID,
+		IPU6SE_FW_PSYS_N_MEM_ID,
+		IPU6SE_FW_PSYS_N_MEM_ID,
+		IPU6SE_FW_PSYS_N_MEM_ID,
+		IPU6SE_FW_PSYS_N_MEM_ID,
+	},
+
+	{ /* IPU6SE_FW_PSYS_ISA_BNLM_ID */
+		IPU6SE_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6SE_FW_PSYS_LB_VMEM_ID,
+		IPU6SE_FW_PSYS_N_MEM_ID,
+		IPU6SE_FW_PSYS_N_MEM_ID,
+		IPU6SE_FW_PSYS_N_MEM_ID,
+		IPU6SE_FW_PSYS_N_MEM_ID,
+	},
+	{ /* IPU6SE_FW_PSYS_ISA_DM_ID */
+		IPU6SE_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6SE_FW_PSYS_LB_VMEM_ID,
+		IPU6SE_FW_PSYS_N_MEM_ID,
+		IPU6SE_FW_PSYS_N_MEM_ID,
+		IPU6SE_FW_PSYS_N_MEM_ID,
+		IPU6SE_FW_PSYS_N_MEM_ID,
+	},
+	{ /* IPU6SE_FW_PSYS_ISA_R2I_SIE_ID */
+		IPU6SE_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6SE_FW_PSYS_LB_VMEM_ID,
+		IPU6SE_FW_PSYS_N_MEM_ID,
+		IPU6SE_FW_PSYS_N_MEM_ID,
+		IPU6SE_FW_PSYS_N_MEM_ID,
+		IPU6SE_FW_PSYS_N_MEM_ID,
+	},
+	{ /* IPU6SE_FW_PSYS_ISA_R2I_DS_A_ID */
+		IPU6SE_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6SE_FW_PSYS_LB_VMEM_ID,
+		IPU6SE_FW_PSYS_N_MEM_ID,
+		IPU6SE_FW_PSYS_N_MEM_ID,
+		IPU6SE_FW_PSYS_N_MEM_ID,
+		IPU6SE_FW_PSYS_N_MEM_ID,
+	},
+	{ /* IPU6SE_FW_PSYS_ISA_R2I_DS_B_ID */
+		IPU6SE_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6SE_FW_PSYS_LB_VMEM_ID,
+		IPU6SE_FW_PSYS_N_MEM_ID,
+		IPU6SE_FW_PSYS_N_MEM_ID,
+		IPU6SE_FW_PSYS_N_MEM_ID,
+		IPU6SE_FW_PSYS_N_MEM_ID,
+	},
+	{ /* IPU6SE_FW_PSYS_ISA_AWB_ID */
+		IPU6SE_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6SE_FW_PSYS_LB_VMEM_ID,
+		IPU6SE_FW_PSYS_N_MEM_ID,
+		IPU6SE_FW_PSYS_N_MEM_ID,
+		IPU6SE_FW_PSYS_N_MEM_ID,
+		IPU6SE_FW_PSYS_N_MEM_ID,
+	},
+	{ /* IPU6SE_FW_PSYS_ISA_AE_ID */
+		IPU6SE_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6SE_FW_PSYS_LB_VMEM_ID,
+		IPU6SE_FW_PSYS_N_MEM_ID,
+		IPU6SE_FW_PSYS_N_MEM_ID,
+		IPU6SE_FW_PSYS_N_MEM_ID,
+		IPU6SE_FW_PSYS_N_MEM_ID,
+	},
+	{ /* IPU6SE_FW_PSYS_ISA_AF_ID */
+		IPU6SE_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6SE_FW_PSYS_LB_VMEM_ID,
+		IPU6SE_FW_PSYS_N_MEM_ID,
+		IPU6SE_FW_PSYS_N_MEM_ID,
+		IPU6SE_FW_PSYS_N_MEM_ID,
+		IPU6SE_FW_PSYS_N_MEM_ID,
+	},
+	{ /* IPU6SE_FW_PSYS_ISA_PAF_ID */
+		IPU6SE_FW_PSYS_TRANSFER_VMEM0_ID,
+		IPU6SE_FW_PSYS_LB_VMEM_ID,
+		IPU6SE_FW_PSYS_N_MEM_ID,
+		IPU6SE_FW_PSYS_N_MEM_ID,
+		IPU6SE_FW_PSYS_N_MEM_ID,
+		IPU6SE_FW_PSYS_N_MEM_ID,
+	}
+};
+
+static const struct ipu_fw_resource_definitions ipu6se_defs = {
+	.cells = ipu6se_fw_psys_cell_types,
+	.num_cells = IPU6SE_FW_PSYS_N_CELL_ID,
+	.num_cells_type = IPU6SE_FW_PSYS_N_CELL_TYPE_ID,
+
+	.dev_channels = ipu6se_fw_num_dev_channels,
+	.num_dev_channels = IPU6SE_FW_PSYS_N_DEV_CHN_ID,
+
+	.num_ext_mem_types = IPU6SE_FW_PSYS_N_DATA_MEM_TYPE_ID,
+	.num_ext_mem_ids = IPU6SE_FW_PSYS_N_MEM_ID,
+	.ext_mem_ids = ipu6se_fw_psys_mem_size,
+
+	.num_dfm_ids = IPU6SE_FW_PSYS_N_DEV_DFM_ID,
+
+	.dfms = ipu6se_fw_psys_dfms,
+
+	.cell_mem_row = IPU6SE_FW_PSYS_N_MEM_TYPE_ID,
+	.cell_mem = &ipu6se_fw_psys_c_mem[0][0],
+};
+
+const struct ipu_fw_resource_definitions *ipu6se_res_defs = &ipu6se_defs;
Index: b/drivers/media/pci/intel/ipu6/ipu6se-platform-resources.h
===================================================================
--- /dev/null
+++ b/drivers/media/pci/intel/ipu6/ipu6se-platform-resources.h
@@ -0,0 +1,103 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2018 - 2020 Intel Corporation */
+
+#ifndef IPU6SE_PLATFORM_RESOURCES_H
+#define IPU6SE_PLATFORM_RESOURCES_H
+
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include "ipu-platform-resources.h"
+
+#define	IPU6SE_FW_PSYS_N_PADDING_UINT8_IN_PROCESS_EXT_STRUCT		1
+
+enum {
+	IPU6SE_FW_PSYS_CMD_QUEUE_COMMAND_ID = 0,
+	IPU6SE_FW_PSYS_CMD_QUEUE_DEVICE_ID,
+	IPU6SE_FW_PSYS_CMD_QUEUE_PPG0_COMMAND_ID,
+	IPU6SE_FW_PSYS_CMD_QUEUE_PPG1_COMMAND_ID,
+	IPU6SE_FW_PSYS_CMD_QUEUE_PPG2_COMMAND_ID,
+	IPU6SE_FW_PSYS_CMD_QUEUE_PPG3_COMMAND_ID,
+	IPU6SE_FW_PSYS_CMD_QUEUE_PPG4_COMMAND_ID,
+	IPU6SE_FW_PSYS_CMD_QUEUE_PPG5_COMMAND_ID,
+	IPU6SE_FW_PSYS_N_PSYS_CMD_QUEUE_ID
+};
+
+enum {
+	IPU6SE_FW_PSYS_TRANSFER_VMEM0_TYPE_ID = 0,
+	IPU6SE_FW_PSYS_LB_VMEM_TYPE_ID,
+	IPU6SE_FW_PSYS_DMEM_TYPE_ID,
+	IPU6SE_FW_PSYS_VMEM_TYPE_ID,
+	IPU6SE_FW_PSYS_BAMEM_TYPE_ID,
+	IPU6SE_FW_PSYS_PMEM_TYPE_ID,
+	IPU6SE_FW_PSYS_N_MEM_TYPE_ID
+};
+
+enum ipu6se_mem_id {
+	IPU6SE_FW_PSYS_TRANSFER_VMEM0_ID = 0,	/* TRANSFER VMEM 0 */
+	IPU6SE_FW_PSYS_LB_VMEM_ID,	/* LB VMEM */
+	IPU6SE_FW_PSYS_DMEM0_ID,	/* SPC0 Dmem */
+	IPU6SE_FW_PSYS_DMEM1_ID,	/* SPP0 Dmem */
+	IPU6SE_FW_PSYS_N_MEM_ID
+};
+
+enum {
+	IPU6SE_FW_PSYS_DEV_CHN_DMA_EXT0_ID = 0,
+	IPU6SE_FW_PSYS_DEV_CHN_DMA_EXT1_READ_ID,
+	IPU6SE_FW_PSYS_DEV_CHN_DMA_EXT1_WRITE_ID,
+	IPU6SE_FW_PSYS_DEV_CHN_DMA_ISA_ID,
+	IPU6SE_FW_PSYS_N_DEV_CHN_ID
+};
+
+enum {
+	IPU6SE_FW_PSYS_SP_CTRL_TYPE_ID = 0,
+	IPU6SE_FW_PSYS_SP_SERVER_TYPE_ID,
+	IPU6SE_FW_PSYS_ACC_ISA_TYPE_ID,
+	IPU6SE_FW_PSYS_N_CELL_TYPE_ID
+};
+
+enum {
+	IPU6SE_FW_PSYS_SP0_ID = 0,
+	IPU6SE_FW_PSYS_ISA_ICA_ID,
+	IPU6SE_FW_PSYS_ISA_LSC_ID,
+	IPU6SE_FW_PSYS_ISA_DPC_ID,
+	IPU6SE_FW_PSYS_ISA_B2B_ID,
+	IPU6SE_FW_PSYS_ISA_BNLM_ID,
+	IPU6SE_FW_PSYS_ISA_DM_ID,
+	IPU6SE_FW_PSYS_ISA_R2I_SIE_ID,
+	IPU6SE_FW_PSYS_ISA_R2I_DS_A_ID,
+	IPU6SE_FW_PSYS_ISA_R2I_DS_B_ID,
+	IPU6SE_FW_PSYS_ISA_AWB_ID,
+	IPU6SE_FW_PSYS_ISA_AE_ID,
+	IPU6SE_FW_PSYS_ISA_AF_ID,
+	IPU6SE_FW_PSYS_ISA_PAF_ID,
+	IPU6SE_FW_PSYS_N_CELL_ID
+};
+
+enum {
+	IPU6SE_FW_PSYS_DEV_DFM_ISL_FULL_PORT_ID = 0,
+	IPU6SE_FW_PSYS_DEV_DFM_ISL_EMPTY_PORT_ID,
+};
+
+/* Excluding PMEM */
+#define IPU6SE_FW_PSYS_N_DATA_MEM_TYPE_ID (IPU6SE_FW_PSYS_N_MEM_TYPE_ID - 1)
+#define IPU6SE_FW_PSYS_N_DEV_DFM_ID	\
+	(IPU6SE_FW_PSYS_DEV_DFM_ISL_EMPTY_PORT_ID + 1)
+#define IPU6SE_FW_PSYS_VMEM0_MAX_SIZE		0x0800
+/* Transfer VMEM0 words, ref HAS Transfer*/
+#define IPU6SE_FW_PSYS_TRANSFER_VMEM0_MAX_SIZE	0x0800
+#define IPU6SE_FW_PSYS_LB_VMEM_MAX_SIZE		0x0400	/* LB VMEM words */
+#define IPU6SE_FW_PSYS_DMEM0_MAX_SIZE		0x4000
+#define IPU6SE_FW_PSYS_DMEM1_MAX_SIZE		0x1000
+
+#define IPU6SE_FW_PSYS_DEV_CHN_DMA_EXT0_MAX_SIZE		22
+#define IPU6SE_FW_PSYS_DEV_CHN_DMA_EXT1_READ_MAX_SIZE	22
+#define IPU6SE_FW_PSYS_DEV_CHN_DMA_EXT1_WRITE_MAX_SIZE	22
+#define IPU6SE_FW_PSYS_DEV_CHN_DMA_IPFD_MAX_SIZE		0
+#define IPU6SE_FW_PSYS_DEV_CHN_DMA_ISA_MAX_SIZE		2
+
+#define IPU6SE_FW_PSYS_DEV_DFM_ISL_FULL_PORT_ID_MAX_SIZE		32
+#define IPU6SE_FW_PSYS_DEV_DFM_LB_FULL_PORT_ID_MAX_SIZE		32
+#define IPU6SE_FW_PSYS_DEV_DFM_ISL_EMPTY_PORT_ID_MAX_SIZE		32
+#define IPU6SE_FW_PSYS_DEV_DFM_LB_EMPTY_PORT_ID_MAX_SIZE		32
+
+#endif /* IPU6SE_PLATFORM_RESOURCES_H */
Index: b/drivers/media/platform/intel/Makefile
===================================================================
--- a/drivers/media/platform/intel/Makefile
+++ b/drivers/media/platform/intel/Makefile
@@ -1,2 +1,16 @@
-# SPDX-License-Identifier: GPL-2.0-only
-obj-$(CONFIG_VIDEO_PXA27x) += pxa_camera.o
+# SPDX-License-Identifier: GPL-2.0
+# Copyright (c) 2010 - 2022 Intel Corporation.
+
+ifneq ($(EXTERNAL_BUILD), 1)
+srcpath := $(srctree)
+endif
+
+ccflags-y += -I$(srcpath)/$(src)/../../../../include/
+ccflags-y += -I$(srcpath)/$(src)/../../pci/intel/
+
+obj-$(CONFIG_INTEL_IPU6_TGLRVP_PDATA) += ipu6-tglrvp-pdata.o
+obj-$(CONFIG_INTEL_IPU6_JSLRVP_PDATA) += ipu6-jslrvp-pdata.o
+obj-$(CONFIG_INTEL_IPU6_ADLRVP_PDATA) += ipu6-adlrvp-pdata.o
+obj-$(CONFIG_INTEL_IPU6_ACPI)         += ipu6-acpi.o \
+					ipu6-acpi-pdata.o \
+					ipu6-acpi-common.o
Index: b/drivers/media/platform/intel/ipu6-acpi-common.c
===================================================================
--- /dev/null
+++ b/drivers/media/platform/intel/ipu6-acpi-common.c
@@ -0,0 +1,357 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2016--2022 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ */
+#include <linux/platform_device.h>
+#include <linux/version.h>
+#include <media/ipu-acpi-pdata.h>
+#include <media/ipu-acpi.h>
+
+static int get_integer_dsdt_data(struct device *dev, const u8 *dsdt,
+				 int func, u64 *out)
+{
+	struct acpi_handle *dev_handle = ACPI_HANDLE(dev);
+	union acpi_object *obj;
+
+	obj = acpi_evaluate_dsm(dev_handle, (void *)dsdt, 0, func, NULL);
+	if (!obj) {
+		dev_err(dev, "No dsdt\n");
+		return -ENODEV;
+	}
+	dev_dbg(dev, "ACPI type %d", obj->type);
+
+	if (obj->type != ACPI_TYPE_INTEGER) {
+		ACPI_FREE(obj);
+		return -ENODEV;
+	}
+	*out = obj->integer.value;
+	ACPI_FREE(obj);
+	return 0;
+}
+
+static int read_acpi_block(struct device *dev, char *id, void *data, u32 size)
+{
+	union acpi_object *obj;
+	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+	struct acpi_handle *dev_handle = ACPI_HANDLE(dev);
+	int status;
+	u32 buffer_length;
+
+	status = acpi_evaluate_object(dev_handle, id, NULL, &buffer);
+	if (!ACPI_SUCCESS(status))
+		return -ENODEV;
+
+	obj = (union acpi_object *)buffer.pointer;
+	if (!obj || obj->type != ACPI_TYPE_BUFFER) {
+		dev_err(dev, "Could't read acpi buffer\n");
+		status = -ENODEV;
+		goto err;
+	}
+
+	if (obj->buffer.length > size) {
+		dev_err(dev, "Given buffer is too small\n");
+		status = -ENODEV;
+		goto err;
+	}
+
+	memcpy(data, obj->buffer.pointer, min(size, obj->buffer.length));
+	buffer_length = obj->buffer.length;
+	kfree(buffer.pointer);
+
+	return buffer_length;
+err:
+	kfree(buffer.pointer);
+	return status;
+}
+
+int ipu_acpi_get_gpio_data(struct device *dev, struct ipu_gpio_info *gpio, int size,
+				u64 *gpio_num)
+{
+	const u8 dsdt_cam_gpio[] = {
+		0x40, 0x46, 0x23, 0x79, 0x10, 0x9e, 0xea, 0x4f,
+		0xa5, 0xc1, 0xB5, 0xaa, 0x8b, 0x19, 0x75, 0x6f };
+
+	int i = 0, j = 0, retries = 0, loop = 0;
+	u64 num_gpio;
+
+	int rval = get_integer_dsdt_data(dev, dsdt_cam_gpio, 1, &num_gpio);
+
+	if (rval < 0) {
+		dev_err(dev, "Failed to get number of GPIO pins\n");
+		return rval;
+	}
+
+	dev_dbg(dev, "Num of gpio found = %lld", num_gpio);
+
+	if (num_gpio == 0) {
+		*gpio_num = num_gpio;
+		return rval;
+	}
+
+	if (num_gpio > size) {
+		dev_err(dev, "Incorrect number of GPIO pins\n");
+		return rval;
+	}
+
+	/* repeat until all gpio pin is saved */
+	while (i < num_gpio && loop <= LOOP_SIZE) {
+		u64 data;
+		struct gpio_desc *desc = NULL;
+
+		rval = get_integer_dsdt_data(dev, dsdt_cam_gpio, i + 2, &data);
+
+		if (rval < 0) {
+			dev_err(dev, "No gpio data\n");
+			return -ENODEV;
+		}
+
+		gpio[i].func = (data & 0xff);
+		gpio[i].valid = FALSE;
+
+		desc = gpiod_get_index(dev, NULL, i + retries, GPIOD_ASIS);
+
+		if (!IS_ERR(desc)) {
+			unsigned short pin = desc_to_gpio(desc);
+			bool save = TRUE;
+
+			/* always save first GPIO pin */
+			if (i == 0)
+				save = TRUE;
+
+			/* check subsequent GPIO pin for replicate */
+			else {
+				for (j = 0; j <= i; j++) {
+					/* retry if same as previous pin */
+					if (gpio[j].pin == pin) {
+						retries++;
+						save = FALSE;
+						gpiod_put(desc);
+						break;
+					}
+				}
+			}
+
+			/* save into array */
+			if (save == TRUE) {
+				gpio[i].pin = pin;
+				gpio[i].valid = TRUE;
+				gpiod_put(desc);
+				i++;
+				retries = 0;
+			}
+		}
+		loop++;
+	}
+	*gpio_num = num_gpio;
+
+	return rval;
+}
+
+int ipu_acpi_get_i2c_info(struct device *dev, struct ipu_i2c_info *i2c, int size, u64 *num)
+{
+	const u8 dsdt_cam_i2c[] = {
+		0x49, 0x75, 0x25, 0x26, 0x71, 0x92, 0xA4, 0x4C,
+		0xBB, 0x43, 0xC4, 0x89, 0x9D, 0x5A, 0x48, 0x81};
+
+	u64 num_i2c;
+	int i;
+	int rval = get_integer_dsdt_data(dev, dsdt_cam_i2c, 1, &num_i2c);
+
+	if (rval < 0) {
+		dev_err(dev, "Failed to get number of I2C\n");
+		return -ENODEV;
+	}
+
+	for (i = 0; i < num_i2c && i < size; i++) {
+		u64 data;
+
+		rval = get_integer_dsdt_data(dev, dsdt_cam_i2c, i + 2,
+					     &data);
+
+		if (rval < 0) {
+			dev_err(dev, "Failed to get I2C data\n");
+			return -ENODEV;
+		}
+
+		i2c[i].bus = ((data >> 24) & 0xff);
+		i2c[i].addr = (data >> 8) & 0xff;
+
+		dev_dbg(dev, "ACPI camera option: i2c bus %d addr %x",
+			i2c[i].bus, i2c[i].addr);
+	}
+
+	*num = num_i2c;
+
+	return 0;
+}
+
+static int match_depend(struct device *dev, const void *data)
+{
+	return (dev && dev->fwnode == data) ? 1 : 0;
+}
+
+int ipu_acpi_get_control_logic_data(struct device *dev,
+					struct control_logic_data **ctl_data)
+{
+	/* CLDB data */
+	struct control_logic_data_packed ctl_logic_data;
+	int ret = read_acpi_block(dev, "CLDB", &ctl_logic_data,
+				sizeof(ctl_logic_data));
+
+	if (ret < 0) {
+		dev_err(dev, "no such CLDB block");
+		return ret;
+	}
+
+	(*ctl_data)->type = ctl_logic_data.controllogictype;
+	(*ctl_data)->id = ctl_logic_data.controllogicid;
+	(*ctl_data)->sku = ctl_logic_data.sensorcardsku;
+
+	dev_dbg(dev, "CLDB data version %d clid %d cltype %d sku %d",
+		ctl_logic_data.version,
+		ctl_logic_data.controllogicid,
+		ctl_logic_data.controllogictype,
+		ctl_logic_data.sensorcardsku);
+
+	/* GPIO data */
+	ret = ipu_acpi_get_gpio_data(dev, (*ctl_data)->gpio, ARRAY_SIZE((*ctl_data)->gpio),
+				&((*ctl_data)->gpio_num));
+
+	if (ret < 0) {
+		dev_err(dev, "Failed to get GPIO data");
+		return ret;
+	}
+	return 0;
+}
+
+int ipu_acpi_get_dep_data(struct device *dev,
+			     struct control_logic_data *ctl_data)
+{
+	struct acpi_handle *dev_handle = ACPI_HANDLE(dev);
+	struct acpi_handle_list dep_devices;
+	acpi_status status;
+	int i;
+	int rval;
+
+	ctl_data->completed = false;
+
+	if (!acpi_has_method(dev_handle, "_DEP")) {
+		dev_err(dev, "ACPI does not have _DEP method");
+		return 0;
+	}
+
+	status = acpi_evaluate_reference(dev_handle, "_DEP", NULL,
+					 &dep_devices);
+
+	if (ACPI_FAILURE(status)) {
+		dev_err(dev, "Failed to evaluate _DEP.\n");
+		return -ENODEV;
+	}
+
+	for (i = 0; i < dep_devices.count; i++) {
+		struct acpi_device *device;
+		struct acpi_device_info *info;
+		struct device *p_dev;
+		int match;
+
+		status = acpi_get_object_info(dep_devices.handles[i], &info);
+		if (ACPI_FAILURE(status)) {
+			dev_err(dev, "Error reading _DEP device info\n");
+			continue;
+		}
+
+		match = info->valid & ACPI_VALID_HID &&
+			!strcmp(info->hardware_id.string, "INT3472");
+
+		kfree(info);
+
+		if (!match)
+			continue;
+
+		/* Process device IN3472 created by acpi */
+		device = acpi_fetch_acpi_dev(dep_devices.handles[i]);
+		if (!device) {
+			dev_err(dev, "INT3472 does not have dep device");
+			return -ENODEV;
+		}
+
+		dev_dbg(dev, "Depend ACPI device found: %s\n",
+			dev_name(&device->dev));
+
+		p_dev = bus_find_device(&platform_bus_type, NULL,
+					&device->fwnode, match_depend);
+
+		if (p_dev) {
+			dev_err(dev, "Dependent platform device found %s\n",
+				dev_name(p_dev));
+
+			/* obtain Control Logic Data from BIOS */
+			rval = ipu_acpi_get_control_logic_data(p_dev, &ctl_data);
+
+			if (rval) {
+				dev_err(dev, "Error getting Control Logic Data");
+				return rval;
+			}
+
+			ctl_data->completed = true;
+		} else
+			dev_err(dev, "Dependent platform device not found\n");
+	}
+
+	if (!ctl_data->completed) {
+		ctl_data->type = CL_EMPTY;
+		dev_err(dev, "No control logic data available");
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_acpi_get_dep_data);
+
+int ipu_acpi_get_cam_data(struct device *dev,
+			     struct sensor_bios_data *sensor)
+{
+	/* SSDB */
+	struct sensor_bios_data_packed sensor_data;
+
+	int ret = read_acpi_block(dev, "SSDB", &sensor_data,
+				  sizeof(sensor_data));
+
+	if (ret < 0) {
+		dev_err(dev, "Fail to read from SSDB");
+		return ret;
+	}
+
+	/* Xshutdown is not part of the ssdb data */
+	sensor->link = sensor_data.link;
+	sensor->lanes = sensor_data.lanes;
+	sensor->pprval = sensor_data.pprval;
+	sensor->pprunit = sensor_data.pprunit;
+
+	dev_dbg(dev, "sensor ACPI data: name %s link %d, lanes %d pprval %d pprunit %x",
+		dev_name(dev), sensor->link, sensor->lanes, sensor->pprval, sensor->pprunit);
+
+	/* I2C */
+	ret = ipu_acpi_get_i2c_info(dev, sensor->i2c, ARRAY_SIZE(sensor->i2c), &sensor->i2c_num);
+
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_acpi_get_cam_data);
+
+MODULE_AUTHOR("Samu Onkalo <samu.onkalo@intel.com>");
+MODULE_AUTHOR("Khai Wen Ng <khai.wen.ng@intel.com>");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("IPU6 ACPI support");
+
Index: b/drivers/media/platform/intel/ipu6-acpi-pdata.c
===================================================================
--- /dev/null
+++ b/drivers/media/platform/intel/ipu6-acpi-pdata.c
@@ -0,0 +1,888 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2016--2023 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <media/ipu-acpi.h>
+#include <media/ipu-acpi-pdata.h>
+
+#define MIN_SENSOR_I2C 1
+#define MIN_SERDES_I2C 3
+#define SUFFIX_BASE 96
+#define MSG_LEN 128
+
+static struct ipu_isys_subdev_pdata *ptr_built_in_pdata;
+
+void set_built_in_pdata(struct ipu_isys_subdev_pdata *pdata)
+{
+	ptr_built_in_pdata = pdata;
+};
+EXPORT_SYMBOL(set_built_in_pdata);
+
+static struct ipu_isys_clk_mapping clk_mapping[] = {
+	{ CLKDEV_INIT(NULL, NULL, NULL), NULL }
+};
+
+struct ipu_isys_subdev_pdata acpi_subdev_pdata = {
+	.subdevs = (struct ipu_isys_subdev_info *[]) {
+		NULL,
+	},
+	.clk_map = clk_mapping,
+};
+
+struct serdes_local serdes_info;
+
+struct ipu_isys_subdev_pdata *get_acpi_subdev_pdata(void)
+{
+	struct ipu_isys_subdev_pdata *ptr;
+	ptr = &acpi_subdev_pdata;
+	return ptr;
+}
+EXPORT_SYMBOL(get_acpi_subdev_pdata);
+
+void print_serdes_sdinfo(struct serdes_subdev_info *sdinfo)
+{
+	int j;
+	struct serdes_module_pdata *sd_mpdata = sdinfo->board_info.platform_data;
+
+	if (!sd_mpdata) {
+		pr_err("Empty serdes module pdata");
+		return;
+	}
+
+	pr_debug("\t\trx_port \t\t= %d", sdinfo->rx_port);
+	pr_debug("\t\tphy_i2c_addr \t\t= 0x%x", sdinfo->phy_i2c_addr);
+	pr_debug("\t\tser_alias \t\t= 0x%x", sdinfo->ser_alias);
+	pr_debug("\t\tsuffix \t\t\t= %c", sdinfo->suffix);
+	pr_debug("\t\tboard_info.type \t= %s", sdinfo->board_info.type);
+	pr_debug("\t\tboard_info.addr \t= 0x%x", sdinfo->board_info.addr);
+
+	pr_debug("serdes board_info.platform_data");
+	pr_debug("\t\tlanes \t\t\t= %d", sd_mpdata->lanes);
+	pr_debug("\t\tmodule_name \t\t= %s", sd_mpdata->module_name);
+	pr_debug("\t\tfsin \t\t\t= %d", sd_mpdata->fsin);
+
+	if (serdes_info.gpio_powerup_seq > 0)
+		for (j = 0; j < serdes_info.gpio_powerup_seq; j++)
+			pr_debug("\t\t gpio_powerup_seq[%d] \t= %d", j,
+				(int)sd_mpdata->gpio_powerup_seq[j]);
+}
+
+void print_serdes_subdev(struct ipu_isys_subdev_info *sd)
+{
+	struct serdes_platform_data *sd_pdata = sd->i2c.board_info.platform_data;
+	int i;
+	struct serdes_subdev_info *sd_sdinfo;
+	struct serdes_module_pdata *sd_mpdata;
+
+	if (!sd_pdata) {
+		pr_err("Empty serdes subdev pdata");
+		return;
+	}
+
+	pr_debug("IPU6 ACPI %s", __func__);
+	pr_debug("sd_csi2");
+	pr_debug("\t\tnlanes \t\t\t= %d", sd->csi2->nlanes);
+	pr_debug("\t\tport \t\t\t= %d", sd->csi2->port);
+
+	pr_debug("sd->i2c");
+	pr_debug("\t\ti2c_adapter_bdf \t= %s", sd->i2c.i2c_adapter_bdf);
+	pr_debug("\t\tboard_info.type \t= %s", sd->i2c.board_info.type);
+	pr_debug("\t\tboard_info.addr \t= 0x%x", sd->i2c.board_info.addr);
+
+	pr_debug("sd->i2c.board_info.platform_data");
+	pr_debug("\t\treset_gpio \t\t= %d", sd_pdata->reset_gpio);
+	pr_debug("\t\tFPD_gpio \t\t= %d", sd_pdata->FPD_gpio);
+	pr_debug("\t\tsuffix \t\t\t= %c", sd_pdata->suffix);
+
+	for (i = 0; i < serdes_info.rx_port; i++) {
+		sd_sdinfo = &sd_pdata->subdev_info[i];
+		sd_mpdata = sd_sdinfo->board_info.platform_data;
+
+		if (!sd_mpdata)
+			continue;
+
+		pr_debug("serdes subdev_info[%d]", i);
+		print_serdes_sdinfo(sd_sdinfo);
+	}
+
+}
+
+void print_subdev(struct ipu_isys_subdev_info *sd)
+{
+	struct sensor_platform_data *spdata = sd->i2c.board_info.platform_data;
+	int i;
+
+	if (!spdata) {
+		pr_err("Empty sensor subdev");
+		return;
+	}
+
+	pr_debug("IPU6 ACPI %s", __func__);
+	pr_debug("sd->csi2");
+	pr_debug("\t\tnlanes \t\t\t= %d", sd->csi2->nlanes);
+	pr_debug("\t\tport \t\t\t= %d", sd->csi2->port);
+
+	pr_debug("sd->i2c");
+	pr_debug("\t\ti2c_adapter_bdf \t= %s", sd->i2c.i2c_adapter_bdf);
+	pr_debug("\t\tboard_info.type \t= %s", sd->i2c.board_info.type);
+	pr_debug("\t\tboard_info.addr \t= 0x%x", sd->i2c.board_info.addr);
+
+	pr_debug("sd->i2c.platform_data");
+	pr_debug("\t\tport \t\t\t= %d", spdata->port);
+	pr_debug("\t\tlanes \t\t\t= %d", spdata->lanes);
+	pr_debug("\t\ti2c_slave_address \t= 0x%x", spdata->i2c_slave_address);
+	pr_debug("\t\tirq_pin \t\t= %d", spdata->irq_pin);
+	pr_debug("\t\tirq_pin_name \t\t= %s", spdata->irq_pin_name);
+	pr_debug("\t\tsuffix \t\t\t= %c", spdata->suffix);
+	pr_debug("\t\treset_pin \t\t= %d", spdata->reset_pin);
+	pr_debug("\t\tdetect_pin \t\t= %d", spdata->detect_pin);
+
+	for (i = 0; i < IPU_SPDATA_GPIO_NUM; i++)
+		pr_debug("\t\tgpios[%d] \t\t= %d", i, spdata->gpios[i]);
+}
+
+void add_local_subdevs(struct ipu_isys_subdev_info *new_subdev_info)
+{
+	struct ipu_isys_subdev_pdata *ptr_acpi_subdev_pdata = &acpi_subdev_pdata;
+	int i = 0;
+
+	while (i <= MAX_ACPI_SENSOR_NUM) {
+		if (!ptr_acpi_subdev_pdata->subdevs[i]) {
+			ptr_acpi_subdev_pdata->subdevs[i] = new_subdev_info;
+			ptr_acpi_subdev_pdata->subdevs[i+1] = NULL;
+			break;
+		}
+		i++;
+	}
+}
+
+void update_short(struct device *dev,
+		char msg[MSG_LEN],
+		unsigned short *old_short,
+		unsigned int new_short)
+{
+	if (*old_short != new_short) {
+		dev_info(dev, "%s 0x%x -> 0x%x", msg, *old_short, new_short);
+		*old_short = new_short;
+	}
+}
+
+void update_hex(struct device *dev,
+		char msg[MSG_LEN],
+		unsigned int *old_hex,
+		unsigned int new_hex)
+{
+	if (*old_hex != new_hex) {
+		dev_info(dev, "%s 0x%x -> 0x%x", msg, *old_hex, new_hex);
+		*old_hex = new_hex;
+	}
+}
+
+void update_int(struct device *dev,
+		char msg[MSG_LEN],
+		unsigned int *old_int,
+		unsigned int new_int)
+{
+	if (*old_int != new_int) {
+		dev_info(dev, "%s %d -> %d", msg, *old_int, new_int);
+		*old_int = new_int;
+	}
+}
+
+void update_inta(struct device *dev,
+		char msg[MSG_LEN],
+		int old_int[MSG_LEN],
+		int new_int[MSG_LEN],
+		size_t size)
+{
+	int i;
+
+	for (i = 0; i < size; i++) {
+		if (old_int[i] != new_int[i]) {
+			dev_info(dev, "%s %d -> %d", msg, old_int[i], new_int[i]);
+			old_int[i] = new_int[i];
+		}
+	}
+}
+
+void update_str(struct device *dev,
+		char msg[MSG_LEN],
+		char old_str[MSG_LEN],
+		char new_str[MSG_LEN])
+{
+	if (strcmp(old_str, new_str) != 0) {
+		dev_info(dev, "%s %s -> %s", msg, old_str, new_str);
+		strlcpy(old_str, new_str, strlen(new_str)+1);
+	}
+}
+
+void update_subdev(struct device *dev,
+			struct ipu_isys_subdev_info *new_sd,
+			struct ipu_isys_subdev_info **old_sd)
+{
+	struct sensor_platform_data *old_pdata =
+					(*old_sd)->i2c.board_info.platform_data;
+
+	struct sensor_platform_data *new_pdata =
+					new_sd->i2c.board_info.platform_data;
+
+	/* csi2 */
+	update_int(dev, "CSI2 port", &(*old_sd)->csi2->port, new_sd->csi2->port);
+	update_int(dev, "CSI2 nlanes", &(*old_sd)->csi2->nlanes, new_sd->csi2->nlanes);
+
+	/* i2c */
+	update_short(dev, "I2C board_info addr", &(*old_sd)->i2c.board_info.addr,
+		new_sd->i2c.board_info.addr);
+	update_str(dev, "I2C i2c_adapter_bdf", (*old_sd)->i2c.i2c_adapter_bdf,
+		new_sd->i2c.i2c_adapter_bdf);
+
+	/* platform data */
+	update_int(dev, "pdata port", &(old_pdata)->port, new_pdata->port);
+	update_int(dev, "pdata lanes", &(old_pdata)->lanes, new_pdata->lanes);
+	update_hex(dev, "pdata I2C slave addr", &(old_pdata)->i2c_slave_address,
+		new_pdata->i2c_slave_address);
+	update_int(dev, "pdata irq_pin", &(old_pdata)->irq_pin, new_pdata->irq_pin);
+	update_str(dev, "pdata irq_pin_name", old_pdata->irq_pin_name, new_pdata->irq_pin_name);
+	update_int(dev, "pdata reset_pin", &(old_pdata)->reset_pin, new_pdata->reset_pin);
+	update_int(dev, "pdata detect_pin", &(old_pdata)->detect_pin, new_pdata->detect_pin);
+	update_inta(dev, "pdata gpios", old_pdata->gpios, new_pdata->gpios, IPU_SPDATA_GPIO_NUM);
+}
+
+void update_serdes_subdev(struct device *dev,
+			struct ipu_isys_subdev_info *new_sd,
+			struct ipu_isys_subdev_info **old_sd)
+{
+	struct serdes_platform_data *old_pdata =
+					(*old_sd)->i2c.board_info.platform_data;
+
+	struct serdes_platform_data *new_pdata =
+					new_sd->i2c.board_info.platform_data;
+
+	int i;
+	struct serdes_subdev_info *old_sdinfo, *new_sdinfo;
+	struct serdes_module_pdata *old_mpdata, *new_mpdata;
+
+	/* csi2 */
+	update_int(dev, "CSI2 port", &(*old_sd)->csi2->port, new_sd->csi2->port);
+	update_int(dev, "CSI2 nlanes", &(*old_sd)->csi2->nlanes, new_sd->csi2->nlanes);
+
+	/* i2c */
+	update_short(dev, "I2C board_info addr", &(*old_sd)->i2c.board_info.addr,
+		new_sd->i2c.board_info.addr);
+	update_str(dev, "I2C i2c_adapter_bdf", (*old_sd)->i2c.i2c_adapter_bdf,
+		new_sd->i2c.i2c_adapter_bdf);
+
+	update_int(dev, "I2C Pdata reset_gpio", &old_pdata->reset_gpio,
+		new_pdata->reset_gpio);
+	update_int(dev, "I2C Pdata FPD_gpio", &old_pdata->FPD_gpio, new_pdata->FPD_gpio);
+
+	/* platform data */
+	for (i = 0; i < SERDES_MAX_PORT; i++) {
+		old_sdinfo = &old_pdata->subdev_info[i];
+		old_mpdata = old_sdinfo->board_info.platform_data;
+
+		new_sdinfo = &new_pdata->subdev_info[i];
+		new_mpdata = new_sdinfo->board_info.platform_data;
+
+		if (!strcmp(old_sdinfo->board_info.type, new_sdinfo->board_info.type) &&
+			old_sdinfo->suffix == new_sdinfo->suffix) {
+			update_short(dev, "SdInfo port", &old_sdinfo->rx_port,
+				new_sdinfo->rx_port);
+			update_short(dev, "SdInfo ser_alias", &old_sdinfo->ser_alias,
+				new_sdinfo->ser_alias);
+			update_short(dev, "SdInfo board_info.addr", &old_sdinfo->board_info.addr,
+				new_sdinfo->board_info.addr);
+
+			if (!strcmp(old_mpdata->module_name, new_mpdata->module_name)) {
+				update_int(dev, "mPdata lanes", &old_mpdata->lanes,
+					new_mpdata->lanes);
+				update_int(dev, "mPdata fsin", &old_mpdata->fsin,
+					new_mpdata->fsin);
+				update_inta(dev, "mPdata gpio_powerup_seq",
+						(int *)old_mpdata->gpio_powerup_seq,
+						(int *)new_mpdata->gpio_powerup_seq,
+						SERDES_MAX_GPIO_POWERUP_SEQ);
+			}
+		}
+	}
+}
+
+int compare_subdev(struct device *dev,
+			struct ipu_isys_subdev_info *new_subdev,
+			struct ipu_isys_subdev_info *old_subdev,
+			enum connection_type connect)
+{
+	/* check for ACPI HID in existing pdata */
+	if (old_subdev->acpi_hid) {
+		/* compare with HID for User Custom */
+		if (!strcmp(old_subdev->acpi_hid, dev_name(dev))) {
+			dev_info(dev, "Found matching sensor : %s", dev_name(dev));
+			return 0;
+		}
+	}
+	/* compare sensor type */
+	if (!strcmp(old_subdev->i2c.board_info.type,
+			new_subdev->i2c.board_info.type)) {
+
+		if (connect == TYPE_DIRECT) {
+			struct sensor_platform_data *old_pdata, *new_pdata;
+
+			old_pdata = (struct sensor_platform_data *)
+					old_subdev->i2c.board_info.platform_data;
+
+			new_pdata = (struct sensor_platform_data *)
+					new_subdev->i2c.board_info.platform_data;
+
+			if (old_pdata->suffix == new_pdata->suffix) {
+				dev_info(dev, "Found matching sensor : %s %c",
+					old_subdev->i2c.board_info.type,
+					old_pdata->suffix);
+				return 0;
+			}
+		} else if (connect == TYPE_SERDES) {
+			struct serdes_platform_data *old_pdata, *new_pdata;
+
+			old_pdata = (struct serdes_platform_data *)
+					old_subdev->i2c.board_info.platform_data;
+
+			new_pdata = (struct serdes_platform_data *)
+					new_subdev->i2c.board_info.platform_data;
+
+			if (old_pdata->suffix == new_pdata->suffix) {
+				dev_info(dev, "Found matching sensor : %s %c",
+					old_subdev->i2c.board_info.type,
+					old_pdata->suffix);
+				return 0;
+			}
+		}
+	}
+	return -1;
+}
+
+void update_pdata(struct device *dev,
+			struct ipu_isys_subdev_info *new_subdev,
+			enum connection_type connect)
+{
+	struct ipu_isys_subdev_info *acpi_subdev;
+	bool found = false;
+
+	acpi_subdev = new_subdev;
+
+	/* update local ipu_isys_subdev_pdata */
+	add_local_subdevs(acpi_subdev);
+
+	/* found existing pdata */
+	if (ptr_built_in_pdata) {
+		struct ipu_isys_subdev_info **subdevs, *sd_info;
+
+		for (subdevs = ptr_built_in_pdata->subdevs; *subdevs; subdevs++) {
+			sd_info = *subdevs;
+
+			/* found similar subdev in existing pdata*/
+			if (!compare_subdev(dev, acpi_subdev, sd_info, connect)) {
+				/* print and update old subdev */
+				if (connect == TYPE_DIRECT) {
+					dev_dbg(dev, "Old sensor subdev\n");
+					print_subdev(sd_info);
+					update_subdev(dev, acpi_subdev, &sd_info);
+					dev_dbg(dev, "Updated subdev\n");
+					print_subdev(sd_info);
+				} else if (connect == TYPE_SERDES) {
+					dev_dbg(dev, "Old serdes subdev\n");
+					print_serdes_subdev(sd_info);
+					update_serdes_subdev(dev, acpi_subdev, &sd_info);
+					dev_dbg(dev, "Updated subdev\n");
+					print_serdes_subdev(sd_info);
+				}
+
+				/* stop once similar subdev updated */
+				found = true;
+				break;
+			}
+		}
+
+		/* no similar subdev found */
+		if (!found) {
+			if (connect == TYPE_DIRECT) {
+				struct sensor_platform_data *acpi_pdata;
+
+				acpi_pdata = (struct sensor_platform_data *)
+					acpi_subdev->i2c.board_info.platform_data;
+
+				dev_err(dev, "Pdata does not contain %s %c\n",
+					acpi_subdev->i2c.board_info.type,
+					acpi_pdata->suffix);
+
+				/* print new subdev */
+				print_subdev(acpi_subdev);
+
+			} else {
+				struct serdes_platform_data *acpi_pdata;
+
+				acpi_pdata = (struct serdes_platform_data *)
+					acpi_subdev->i2c.board_info.platform_data;
+
+				dev_err(dev, "Pdata does not contain %s %c\n",
+					acpi_subdev->i2c.board_info.type,
+					acpi_pdata->suffix);
+
+				print_serdes_subdev(acpi_subdev);
+			}
+		}
+	}
+	/* does not have existing pdata */
+	else {
+		/* print new subdev */
+		if (connect == TYPE_DIRECT) {
+			dev_dbg(dev, "New sensor subdev\n");
+			print_subdev(acpi_subdev);
+		} else {
+			dev_dbg(dev, "New serdes subdev\n");
+			print_serdes_subdev(acpi_subdev);
+		}
+	}
+
+	/* update total num of sensor connected */
+	if (connect == TYPE_SERDES) {
+		if (!serdes_info.sensor_num)
+			serdes_info.sensor_num = serdes_info.rx_port;
+		else
+			serdes_info.sensor_num += serdes_info.rx_port;
+
+		serdes_info.deser_num++;
+	}
+}
+
+void set_ti960_gpio(struct control_logic_data *ctl_data, struct serdes_platform_data **pdata)
+{
+	int i;
+
+	(*pdata)->reset_gpio = 0;
+	(*pdata)->FPD_gpio = -1;
+
+	if (ctl_data->completed && ctl_data->gpio_num > 0) {
+		for (i = 0; i < ctl_data->gpio_num; i++) {
+			/* check for RESET selection in BIOS */
+			if (ctl_data->gpio[i].valid && ctl_data->gpio[i].func == GPIO_RESET)
+				(*pdata)->FPD_gpio = ctl_data->gpio[i].pin;
+		}
+	}
+}
+
+void set_lt_gpio(struct control_logic_data *ctl_data, struct sensor_platform_data **pdata,
+			bool is_dummy)
+{
+	int i;
+
+	(*pdata)->irq_pin = -1;
+	(*pdata)->reset_pin = -1;
+	(*pdata)->detect_pin = -1;
+
+	if (ctl_data->completed && ctl_data->gpio_num > 0 && !is_dummy) {
+		for (i = 0; i < ctl_data->gpio_num; i++) {
+			/* check for RESET selection in BIOS */
+			if (ctl_data->gpio[i].valid && ctl_data->gpio[i].func == GPIO_RESET)
+				(*pdata)->reset_pin = ctl_data->gpio[i].pin;
+
+			/* check for READY_STAT selection in BIOS */
+			if (ctl_data->gpio[i].valid && ctl_data->gpio[i].func == GPIO_READY_STAT) {
+				(*pdata)->irq_pin = ctl_data->gpio[i].pin;
+				(*pdata)->irq_pin_flags = IRQF_TRIGGER_RISING |
+							IRQF_TRIGGER_FALLING |
+							IRQF_ONESHOT;
+				strlcpy((*pdata)->irq_pin_name, "READY_STAT", sizeof("READY_STAT"));
+			}
+
+			/* check for HDMI_DETECT selection in BIOS */
+			if (ctl_data->gpio[i].valid && ctl_data->gpio[i].func == GPIO_HDMI_DETECT)
+				(*pdata)->detect_pin = ctl_data->gpio[i].pin;
+		}
+	}
+}
+
+void set_common_gpio(struct sensor_platform_data **pdata)
+{
+	/* TODO: consider remove specific naming such as irq_pin, and use gpios[] */
+
+	(*pdata)->irq_pin = -1;
+	(*pdata)->reset_pin = -1;
+	(*pdata)->detect_pin = -1;
+
+	(*pdata)->gpios[0] = -1;
+	(*pdata)->gpios[1] = 0;
+	(*pdata)->gpios[2] = 0;
+	(*pdata)->gpios[3] = 0;
+}
+
+int set_csi2(struct ipu_isys_subdev_info **sensor_sd,
+		unsigned int lanes,
+		unsigned int port)
+{
+	struct ipu_isys_csi2_config *csi2_config;
+
+	csi2_config = kzalloc(sizeof(*csi2_config), GFP_KERNEL);
+	if (!csi2_config)
+		return -ENOMEM;
+
+	csi2_config->nlanes = lanes;
+	csi2_config->port = port;
+	(*sensor_sd)->csi2 = csi2_config;
+
+	return 0;
+}
+
+void set_i2c(struct ipu_isys_subdev_info **sensor_sd,
+		struct device *dev,
+		const char sensor_name[I2C_NAME_SIZE],
+		unsigned int addr)
+{
+	(*sensor_sd)->i2c.board_info.addr = addr;
+	strlcpy((*sensor_sd)->i2c.board_info.type, sensor_name, I2C_NAME_SIZE);
+	strlcpy((*sensor_sd)->i2c.i2c_adapter_bdf, dev_name(dev->parent->parent->parent),
+		sizeof((*sensor_sd)->i2c.i2c_adapter_bdf));
+}
+
+void set_serdes_sd_pdata(struct serdes_module_pdata **module_pdata, char sensor_name[I2C_NAME_SIZE],
+			unsigned int lanes)
+{
+	/* general */
+	(*module_pdata)->lanes = lanes;
+	strlcpy((*module_pdata)->module_name, sensor_name, I2C_NAME_SIZE);
+
+	/* TI960 and IMX390 specific */
+	if (!strcmp(sensor_name, IMX390_NAME)) {
+		(*module_pdata)->gpio_powerup_seq[0] = 0;
+		(*module_pdata)->gpio_powerup_seq[1] = 0x9;
+		(*module_pdata)->gpio_powerup_seq[2] = -1;
+		(*module_pdata)->gpio_powerup_seq[3] = -1;
+		(*module_pdata)->module_flags = TI960_FL_POWERUP | TI960_FL_INIT_SER_CLK;
+		(*module_pdata)->fsin = 3;
+	}
+}
+
+#define PORT_NR 8
+
+int set_serdes_subdev(struct ipu_isys_subdev_info **serdes_sd,
+		struct device *dev,
+		struct serdes_platform_data **pdata,
+		char sensor_name[I2C_NAME_SIZE],
+		unsigned int lanes,
+		unsigned int addr,
+		unsigned int subdev_port)
+{
+	int i;
+	struct serdes_module_pdata *module_pdata[PORT_NR];
+	struct serdes_subdev_info *serdes_sdinfo;
+	size_t subdev_size = subdev_port * sizeof(*serdes_sdinfo);
+
+	serdes_sdinfo = kzalloc(subdev_size, GFP_KERNEL);
+	if (!serdes_sdinfo)
+		return -ENOMEM;
+
+	for (i = 0; i < subdev_port; i++) {
+		module_pdata[i] = kzalloc(sizeof(*module_pdata[i]), GFP_KERNEL);
+		if (!module_pdata[i]) {
+			kfree(serdes_sdinfo);
+			return -ENOMEM;
+		}
+
+		set_serdes_sd_pdata(&module_pdata[i], sensor_name, lanes);
+
+		/* board info */
+		strlcpy(serdes_sdinfo[i].board_info.type, sensor_name, I2C_NAME_SIZE);
+		if (!strcmp(sensor_name, D457_NAME))
+			serdes_sdinfo[i].board_info.addr = serdes_info.sensor_map_addr;
+		else
+			serdes_sdinfo[i].board_info.addr = serdes_info.sensor_map_addr +
+			serdes_info.sensor_num + i;
+		serdes_sdinfo[i].board_info.platform_data = module_pdata[i];
+
+		/* serdes_subdev_info */
+		serdes_sdinfo[i].rx_port = i;
+		serdes_sdinfo[i].ser_alias = serdes_info.ser_map_addr + serdes_info.sensor_num + i;
+		serdes_sdinfo[i].phy_i2c_addr = serdes_info.phy_i2c_addr;
+		serdes_sdinfo[i].suffix = SUFFIX_BASE + serdes_info.sensor_num + i + 1;
+	}
+
+	(*pdata)->subdev_info = serdes_sdinfo;
+	(*pdata)->subdev_num = subdev_port;
+
+	return 0;
+}
+
+int set_pdata(struct ipu_isys_subdev_info **sensor_sd,
+		struct device *dev,
+		char sensor_name[I2C_NAME_SIZE],
+		struct control_logic_data *ctl_data,
+		unsigned int port,
+		unsigned int lanes,
+		unsigned int addr,
+		unsigned int rx_port,
+		bool is_dummy,
+		enum connection_type connect)
+{
+	if (connect == TYPE_DIRECT) {
+		struct sensor_platform_data *pdata;
+
+		pdata = kzalloc(sizeof(*pdata), GFP_KERNEL);
+		if (!pdata)
+			return -ENOMEM;
+		/* use ascii */
+		/* port for start from 0 */
+		if (port >= 0)
+			pdata->suffix = port + SUFFIX_BASE + 1;
+		else
+			dev_err(dev, "INVALID MIPI PORT");
+
+		pdata->port = port;
+		pdata->lanes = lanes;
+		pdata->i2c_slave_address = addr;
+
+		/* gpio */
+		if (!strcmp(sensor_name, LT6911UXC_NAME))
+			set_lt_gpio(ctl_data, &pdata, is_dummy);
+		else
+			set_common_gpio(&pdata);
+
+		(*sensor_sd)->i2c.board_info.platform_data = pdata;
+	} else if (connect == TYPE_SERDES) {
+		struct serdes_platform_data *pdata;
+
+		pdata = kzalloc(sizeof(*pdata), GFP_KERNEL);
+		if (!pdata)
+			return -ENOMEM;
+
+		/* use ascii */
+		if (!strcmp(sensor_name, D457_NAME) && port >= 0)
+			pdata->suffix = serdes_info.deser_num + SUFFIX_BASE + 1;
+		else if (port > 0)
+			pdata->suffix = port + SUFFIX_BASE;
+		else
+			dev_err(dev, "INVALID MIPI PORT");
+
+		if (!strcmp(sensor_name, IMX390_NAME))
+			set_ti960_gpio(ctl_data, &pdata);
+
+		set_serdes_subdev(sensor_sd, dev, &pdata, sensor_name, lanes, addr, rx_port);
+
+		(*sensor_sd)->i2c.board_info.platform_data = pdata;
+		pdata->deser_board_info = &(*sensor_sd)->i2c.board_info;
+	}
+
+	return 0;
+}
+
+void set_serdes_info(struct device *dev, char *sensor_name, const char *serdes_name, struct sensor_bios_data *cam_data)
+{
+	/* pprunit as num of sensor connected to deserializer */
+	serdes_info.rx_port = cam_data->pprunit;
+
+	/* i2c devices */
+	serdes_info.i2c_num = cam_data->i2c_num;
+
+	/* sensor mapped addr */
+	serdes_info.sensor_map_addr = cam_data->i2c[cam_data->i2c_num - 1].addr;
+
+	/* serializer mapped addr */
+	serdes_info.ser_map_addr = cam_data->i2c[cam_data->i2c_num - 2].addr;
+
+	/* TI960 specific */
+	if (!strcmp(serdes_name, TI960_NAME))
+		serdes_info.gpio_powerup_seq = TI960_MAX_GPIO_POWERUP_SEQ;
+	else
+		serdes_info.gpio_powerup_seq = 0;
+
+	if (!strcmp(sensor_name, IMX390_NAME))
+		serdes_info.phy_i2c_addr = IMX390_D3CM_I2C_ADDRESS;
+	else
+		serdes_info.phy_i2c_addr = 0;
+}
+
+int populate_dummy(struct device *dev,
+			char sensor_name[I2C_NAME_SIZE],
+			struct sensor_bios_data *cam_data,
+			struct control_logic_data *ctl_data,
+			enum connection_type connect)
+{
+	struct ipu_isys_subdev_info *dummy;
+	unsigned short addr_dummy = 0x11;
+	int ret;
+
+	dummy = kzalloc(sizeof(*dummy), GFP_KERNEL);
+	if (!dummy)
+		return -ENOMEM;
+
+	ret = set_csi2(&dummy, cam_data->lanes, cam_data->pprval);
+	if (ret) {
+		kfree(dummy);
+		return ret;
+	}
+
+	set_i2c(&dummy, dev, sensor_name, addr_dummy);
+
+	ret = set_pdata(&dummy, dev, sensor_name, ctl_data, cam_data->pprval,
+		cam_data->lanes, addr_dummy, 0, true, connect);
+	if (ret) {
+		kfree(dummy);
+		return ret;
+	}
+
+	update_pdata(dev, dummy, connect);
+
+	return 0;
+}
+
+int populate_sensor_pdata(struct device *dev,
+			struct ipu_isys_subdev_info **sensor_sd,
+			char sensor_name[I2C_NAME_SIZE],
+			struct sensor_bios_data *cam_data,
+			struct control_logic_data *ctl_data,
+			enum connection_type connect,
+			const char *serdes_name)
+{
+	int ret;
+
+	if (connect == TYPE_DIRECT) {
+		/* sensor csi2 info */
+		ret = set_csi2(sensor_sd, cam_data->lanes, cam_data->link);
+		if (ret)
+			return ret;
+
+		/* sensor i2c info */
+		if (cam_data->i2c_num == MIN_SENSOR_I2C) {
+			set_i2c(sensor_sd, dev, sensor_name, cam_data->i2c[0].addr);
+		} else {
+			dev_err(dev, "IPU6 ACPI: Incorrect number of I2C device for sensor (%lld)",
+				cam_data->i2c_num);
+			return -1;
+		}
+
+	} else if (connect == TYPE_SERDES) {
+		/* serdes csi2 info. pprval as deserializer lane */
+		ret = set_csi2(sensor_sd, cam_data->pprval, cam_data->link);
+		if (ret)
+			return ret;
+
+		/* Use DISCRETE Control Logic or No Control Logic for serdes */
+		if (ctl_data->type != CL_DISCRETE && ctl_data->type != CL_EMPTY) {
+			dev_err(dev, "IPU6 ACPI: Incorrect Control Logic Type for serdes (%d)",
+				ctl_data->type);
+			return -1;
+		}
+
+		/* serdes i2c info */
+		if (cam_data->i2c_num == MIN_SERDES_I2C) {
+			dev_info(dev, "IPU6 ACPI: Detected minimum number of i2c device for serdes");
+			set_i2c(sensor_sd, dev, serdes_name, cam_data->i2c[0].addr);
+		} else {
+			dev_err(dev, "IPU6 ACPI: Incorrect number of I2C device for serdes (%lld)",
+				cam_data->i2c_num);
+			return -1;
+		}
+
+		/* local serdes info */
+		set_serdes_info(dev, sensor_name, serdes_name, cam_data);
+	}
+
+	/* Use last I2C device */
+	ret = set_pdata(sensor_sd, dev, sensor_name, ctl_data, cam_data->link,
+		cam_data->lanes, cam_data->i2c[cam_data->i2c_num - 1].addr,
+		cam_data->pprunit, false, connect);
+
+	if (ret)
+		return ret;
+
+	update_pdata(dev, *sensor_sd, connect);
+
+	/* Lontium specific */
+	if (!strcmp(sensor_name, LT6911UXC_NAME)) {
+		if (cam_data->pprval != cam_data->link) {
+			ret = populate_dummy(dev, sensor_name, cam_data, ctl_data, connect);
+			if (ret)
+				return ret;
+		}
+	}
+
+	return 0;
+}
+
+int get_sensor_pdata(struct i2c_client *client,
+			struct ipu_camera_module_data *data,
+			struct ipu_i2c_helper *helper,
+			void *priv, size_t size,
+			enum connection_type connect, const char *serdes_name)
+{
+	struct sensor_bios_data *cam_data;
+	struct control_logic_data *ctl_data;
+	struct ipu_isys_subdev_info *sensor_sd;
+	int rval;
+
+	cam_data = kzalloc(sizeof(*cam_data), GFP_KERNEL);
+	if (!cam_data)
+		return -ENOMEM;
+
+	cam_data->dev = &client->dev;
+
+	ctl_data = kzalloc(sizeof(*ctl_data), GFP_KERNEL);
+	if (!ctl_data) {
+		kfree(cam_data);
+		return -ENOMEM;
+	}
+
+	sensor_sd = kzalloc(sizeof(*sensor_sd), GFP_KERNEL);
+	if (!sensor_sd) {
+		kfree(cam_data);
+		kfree(ctl_data);
+		return -ENOMEM;
+	}
+
+	/* camera info */
+	rval = ipu_acpi_get_cam_data(&client->dev, cam_data);
+	if (rval) {
+		kfree(sensor_sd);
+		kfree(cam_data);
+		kfree(ctl_data);
+		return rval;
+	}
+
+	/* control logic info */
+	rval = ipu_acpi_get_dep_data(&client->dev, ctl_data);
+	if (rval) {
+		kfree(sensor_sd);
+		kfree(cam_data);
+		kfree(ctl_data);
+		return rval;
+	}
+
+	/* populate pdata */
+	rval = populate_sensor_pdata(&client->dev, &sensor_sd,
+				client->name, cam_data, ctl_data, connect, serdes_name);
+	if (rval) {
+		kfree(sensor_sd);
+		kfree(cam_data);
+		kfree(ctl_data);
+		return rval;
+	}
+
+	client->dev.platform_data = sensor_sd;
+
+	kfree(cam_data);
+	kfree(ctl_data);
+	return rval;
+}
+EXPORT_SYMBOL(get_sensor_pdata);
+
+MODULE_AUTHOR("Khai Wen, Ng <khai.wen.ng@intel.com>");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("IPU6 ACPI support");
Index: b/drivers/media/platform/intel/ipu6-acpi.c
===================================================================
--- /dev/null
+++ b/drivers/media/platform/intel/ipu6-acpi.c
@@ -0,0 +1,227 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2016--2022 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/acpi.h>
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/gpio/consumer.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/regulator/driver.h>
+#include <linux/regulator/fixed.h>
+#include <linux/regulator/gpio-regulator.h>
+#include <linux/regulator/machine.h>
+#include <linux/list.h>
+#include <linux/platform_device.h>
+#include <linux/clkdev.h>
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <media/ipu-isys.h>
+#include "ipu.h"
+#include <media/ipu-acpi-pdata.h>
+#include <media/ipu-acpi.h>
+#include <media/ar0234.h>
+#include <media/lt6911uxc.h>
+#include <media/imx390.h>
+#include <media/ti960.h>
+#include <media/d4xx_pdata.h>
+
+static LIST_HEAD(devices);
+
+static struct ipu_camera_module_data *add_device_to_list(
+	struct list_head *devices)
+{
+	struct ipu_camera_module_data *cam_device;
+
+	cam_device = kzalloc(sizeof(*cam_device), GFP_KERNEL);
+	if (!cam_device)
+		return NULL;
+
+	list_add(&cam_device->list, devices);
+	return cam_device;
+}
+
+static const struct ipu_acpi_devices supported_devices[] = {
+/*
+ *	{ "ACPI ID", sensor_name, get_sensor_pdata, NULL, 0, TYPE, serdes_name },	// Custom HID
+ */
+	{ "INTC10C0", AR0234_NAME, get_sensor_pdata, NULL, 0, TYPE_DIRECT, NULL },	// AR0234 HID
+	{ "INTC10B1", LT6911UXC_NAME, get_sensor_pdata, NULL, 0, TYPE_DIRECT, NULL },	// Lontium HID
+	{ "INTC10C1", IMX390_NAME, get_sensor_pdata, NULL, 0, TYPE_SERDES, TI960_NAME },// IMX390 HID
+	{ "INTC10CD", D457_NAME, get_sensor_pdata, NULL, 0, TYPE_SERDES, D457_NAME },// D457 HID
+};
+
+static int get_table_index(struct device *device, const __u8 *acpi_name)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(supported_devices); i++) {
+		if (!strcmp(acpi_name, supported_devices[i].hid_name))
+			return i;
+	}
+
+	return -ENODEV;
+}
+
+/* List of ACPI devices what we can handle */
+/* Must match with HID in BIOS option. Add new sensor if required */
+static const struct acpi_device_id ipu_acpi_match[] = {
+/*
+ *	{ "AR0234A", 0 },	// Custom HID
+ */
+	{ "INTC10C0", 0 },	// AR0234 HID
+	{ "INTC10B1", 0 },	// Lontium HID
+	{ "INTC10C1", 0 },	// IMX390 HID
+	{ "INTC10CD", 0 },	// D457 HID
+	{},
+};
+static int ipu_acpi_get_pdata(struct i2c_client *client,
+				 const struct acpi_device_id *acpi_id,
+				 struct ipu_i2c_helper *helper)
+{
+	struct ipu_camera_module_data *camdata;
+	int index = get_table_index(&client->dev, acpi_id->id);
+
+	if (index < 0) {
+		dev_err(&client->dev,
+			"Device is not in supported devices list\n");
+		return -ENODEV;
+	}
+
+	camdata = add_device_to_list(&devices);
+	if (!camdata)
+		return -ENOMEM;
+
+	strlcpy(client->name, supported_devices[index].real_driver,
+		sizeof(client->name));
+
+	dev_info(&client->dev, "Getting BIOS data for %s", client->name);
+
+	supported_devices[index].get_platform_data(
+		client, camdata, helper,
+		supported_devices[index].priv_data,
+		supported_devices[index].priv_size,
+		supported_devices[index].connect,
+		supported_devices[index].serdes_name);
+
+	return 0;
+}
+
+static int ipu_i2c_test(struct device *dev, void *priv)
+{
+	struct i2c_client *client = i2c_verify_client(dev);
+	const struct acpi_device_id *acpi_id;
+
+	/*
+	 * Check that we are handling only I2C devices which really has
+	 * ACPI data and are one of the devices which we want to handle
+	 */
+
+	if (!ACPI_COMPANION(dev) || !client)
+		return 0;
+
+	acpi_id = acpi_match_device(ipu_acpi_match, dev);
+	if (!acpi_id) {
+		dev_err(dev, "acpi id not found, return 0");
+		return 0;
+	}
+
+	/*
+	 * Skip if platform data has already been added.
+	 * Probably ACPI data overruled by kernel platform data
+	 */
+	if (client->dev.platform_data)
+		return 0;
+
+	/* Looks that we got what we are looking for */
+	if (ipu_acpi_get_pdata(client, acpi_id, priv))
+		dev_err(dev, "Failed to process ACPI data");
+
+	/* Don't return error since we want to process remaining devices */
+
+	/* Unregister matching client */
+	i2c_unregister_device(client);
+
+	return 0;
+}
+
+/* Scan all i2c devices and pick ones which we can handle */
+
+/* Try to get all IPU related devices mentioned in BIOS and all related information
+ * If there is existing ipu_isys_subdev_pdata, update the existing pdata
+ * If not, return a new generated existing pdata
+ */
+
+int ipu_get_acpi_devices(void *driver_data,
+				struct device *dev,
+				struct ipu_isys_subdev_pdata **spdata,
+				struct ipu_isys_subdev_pdata **built_in_pdata,
+				int (*fn)
+				(struct device *, void *,
+				 struct ipu_isys_csi2_config *csi2,
+				 bool reprobe))
+{
+	struct ipu_i2c_helper helper = {
+		.fn = fn,
+		.driver_data = driver_data,
+	};
+	int rval;
+
+	if (!built_in_pdata)
+		dev_dbg(dev, "Built-in pdata not found");
+	else {
+		dev_dbg(dev, "Built-in pdata found");
+		set_built_in_pdata(*built_in_pdata);
+	}
+
+	if ((!fn) || (!driver_data))
+		return -ENODEV;
+
+	rval = i2c_for_each_dev(&helper, ipu_i2c_test);
+	if (rval < 0)
+		return rval;
+
+	if (!built_in_pdata) {
+		dev_dbg(dev, "Return ACPI generated pdata");
+		*spdata = get_acpi_subdev_pdata();
+	} else
+		dev_dbg(dev, "Return updated built-in pdata");
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_get_acpi_devices);
+
+static int __init ipu_acpi_init(void)
+{
+	set_built_in_pdata(NULL);
+	return 0;
+}
+
+static void __exit ipu_acpi_exit(void)
+{
+}
+
+module_init(ipu_acpi_init);
+module_exit(ipu_acpi_exit);
+
+MODULE_AUTHOR("Samu Onkalo <samu.onkalo@intel.com>");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("IPU6 ACPI support");
+
Index: b/drivers/media/platform/intel/ipu6-adlrvp-pdata.c
===================================================================
--- /dev/null
+++ b/drivers/media/platform/intel/ipu6-adlrvp-pdata.c
@@ -0,0 +1,621 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) 2022 Intel Corporation
+#include <linux/clk.h>
+#include <linux/clkdev.h>
+#include <linux/gpio.h>
+#include <linux/kernel.h>
+#include <linux/pci.h>
+
+#include <media/ipu-isys.h>
+#if IS_ENABLED(CONFIG_VIDEO_TI960)
+#include <media/ti960.h>
+#endif
+#if IS_ENABLED(CONFIG_VIDEO_AR0234)
+#include <media/ar0234.h>
+#endif
+#if IS_ENABLED(CONFIG_VIDEO_IMX390)
+#include <media/imx390.h>
+#endif
+#if IS_ENABLED(CONFIG_VIDEO_LT6911UXC)
+#include <media/lt6911uxc.h>
+#endif
+#if IS_ENABLED(CONFIG_VIDEO_D4XX)
+#include <media/d4xx_pdata.h>
+#endif
+
+#include "ipu.h"
+
+#if IS_ENABLED(CONFIG_VIDEO_AR0234)
+#define AR0234_LANES       2
+#define AR0234_I2C_ADDRESS 0x10
+
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA) \
+	&& IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_PDATA_DYNAMIC_LOADING)
+static void ar0234_fixup_spdata(const void *spdata_rep, void *spdata)
+{
+	const struct ipu_spdata_rep *rep = spdata_rep;
+	struct ar0234_platform_data *platform = spdata;
+
+	if (spdata_rep && spdata) {
+		platform->port = rep->port_n;
+		platform->lanes = rep->lanes;
+		platform->i2c_slave_address = rep->slave_addr_n;
+		platform->gpios[0] = rep->gpios[0];
+		platform->irq_pin = rep->irq_pin;
+		platform->irq_pin_flags = rep->irq_pin_flags;
+		strcpy(platform->irq_pin_name, rep->irq_pin_name);
+		platform->suffix = rep->suffix;
+	}
+}
+#endif
+
+static struct ipu_isys_csi2_config ar0234_csi2_cfg_1 = {
+	.nlanes = AR0234_LANES,
+	.port = 1,
+};
+
+static struct ar0234_platform_data ar0234_pdata_1 = {
+	.port = 1,
+	.lanes = 2,
+	.i2c_slave_address = AR0234_I2C_ADDRESS,
+	.irq_pin = -1,
+	.irq_pin_name = "",
+	.irq_pin_flags = IRQF_TRIGGER_RISING
+		| IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
+	.suffix = 'a',
+	.gpios = {-1, 0, 0, 0},
+};
+
+static struct ipu_isys_subdev_info ar0234_sd_1 = {
+	.csi2 = &ar0234_csi2_cfg_1,
+	.i2c = {
+	.board_info = {
+		I2C_BOARD_INFO("ar0234", AR0234_I2C_ADDRESS),
+		.platform_data = &ar0234_pdata_1,
+	},
+	.i2c_adapter_bdf = "0000:00:15.1",
+	},
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA) \
+	&& IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_PDATA_DYNAMIC_LOADING)
+	.fixup_spdata = ar0234_fixup_spdata,
+#endif
+};
+
+static struct ipu_isys_csi2_config ar0234_csi2_cfg_2 = {
+	.nlanes = AR0234_LANES,
+	.port = 2,
+};
+
+static struct ar0234_platform_data ar0234_pdata_2 = {
+	.port = 2,
+	.lanes = 2,
+	.i2c_slave_address = AR0234_I2C_ADDRESS,
+	.irq_pin = -1,
+	.irq_pin_name = "",
+	.irq_pin_flags = IRQF_TRIGGER_RISING
+		| IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
+	.suffix = 'b',
+	.gpios = {-1, 0, 0, 0},
+};
+
+static struct ipu_isys_subdev_info ar0234_sd_2 = {
+	.csi2 = &ar0234_csi2_cfg_2,
+	.i2c = {
+	.board_info = {
+		I2C_BOARD_INFO("ar0234", AR0234_I2C_ADDRESS),
+		.platform_data = &ar0234_pdata_2,
+	},
+	.i2c_adapter_bdf = "0000:00:19.1",
+	},
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA) \
+	&& IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_PDATA_DYNAMIC_LOADING)
+	.fixup_spdata = ar0234_fixup_spdata,
+#endif
+};
+#endif
+
+#if IS_ENABLED(CONFIG_VIDEO_IMX390)
+#define IMX390_LANES       4
+#define IMX390_D3RCM_I2C_ADDRESS 0x1a
+#define IMX390_D3RCM_I2C_ADDRESS_8BIT (IMX390_D3RCM_I2C_ADDRESS << 1)
+#define IMX390_D3CM_I2C_ADDRESS 0x21
+#define IMX390_D3CM_I2C_ADDRESS_8BIT (IMX390_D3CM_I2C_ADDRESS << 1)
+#define IMX390_I2C_ADDRESS_3 0x1e
+#define IMX390_I2C_ADDRESS_8BIT_3 (IMX390_I2C_ADDRESS_3 << 1)
+#define IMX390_I2C_ADDRESS_4 0x20
+#define IMX390_I2C_ADDRESS_8BIT_4 (IMX390_I2C_ADDRESS_4 << 1)
+
+static struct ipu_isys_csi2_config imx390_csi2_cfg_1 = {
+	.nlanes = IMX390_LANES,
+	.port = 1,
+};
+
+static struct imx390_platform_data imx390_pdata_1 = {
+	.port = 1,
+	.lanes = 4,
+	.i2c_slave_address = IMX390_I2C_ADDRESS_3,
+	.suffix = 'a',
+};
+
+static struct ipu_isys_subdev_info imx390_sd_1 = {
+	.csi2 = &imx390_csi2_cfg_1,
+	.i2c = {
+	.board_info = {
+		I2C_BOARD_INFO("imx390", IMX390_I2C_ADDRESS_3),
+		.platform_data = &imx390_pdata_1,
+	},
+	.i2c_adapter_bdf = "0000:00:15.1",
+	},
+};
+
+static struct ipu_isys_csi2_config imx390_csi2_cfg_2 = {
+	.nlanes = IMX390_LANES,
+	.port = 2,
+};
+
+static struct imx390_platform_data imx390_pdata_2 = {
+	.port = 2,
+	.lanes = 4,
+	.i2c_slave_address = IMX390_I2C_ADDRESS_3,
+	.suffix = 'b',
+};
+
+static struct ipu_isys_subdev_info imx390_sd_2 = {
+	.csi2 = &imx390_csi2_cfg_2,
+	.i2c = {
+	.board_info = {
+		I2C_BOARD_INFO("imx390", IMX390_I2C_ADDRESS_3),
+		.platform_data = &imx390_pdata_2,
+	},
+	.i2c_adapter_bdf = "0000:00:19.1",
+	},
+};
+
+static struct ipu_isys_csi2_config imx390_csi2_cfg_3 = {
+	.nlanes = IMX390_LANES,
+	.port = 1,
+};
+
+static struct imx390_platform_data imx390_pdata_3 = {
+	.port = 1,
+	.lanes = 4,
+	.i2c_slave_address = IMX390_I2C_ADDRESS_4,
+	.suffix = 'a',
+};
+
+static struct ipu_isys_subdev_info imx390_sd_3 = {
+	.csi2 = &imx390_csi2_cfg_1,
+	.i2c = {
+	.board_info = {
+		I2C_BOARD_INFO("imx390", IMX390_I2C_ADDRESS_4),
+		.platform_data = &imx390_pdata_1,
+	},
+	.i2c_adapter_bdf = "0000:00:15.1",
+	},
+};
+
+static struct ipu_isys_csi2_config imx390_csi2_cfg_4 = {
+	.nlanes = IMX390_LANES,
+	.port = 2,
+};
+
+static struct imx390_platform_data imx390_pdata_4 = {
+	.port = 2,
+	.lanes = 4,
+	.i2c_slave_address = IMX390_I2C_ADDRESS_4,
+	.suffix = 'b',
+};
+
+static struct ipu_isys_subdev_info imx390_sd_4 = {
+	.csi2 = &imx390_csi2_cfg_2,
+	.i2c = {
+	.board_info = {
+		I2C_BOARD_INFO("imx390", IMX390_I2C_ADDRESS_4),
+		.platform_data = &imx390_pdata_2,
+	},
+	.i2c_adapter_bdf = "0000:00:19.1",
+	},
+};
+#endif
+
+#if IS_ENABLED(CONFIG_VIDEO_TI960)
+#define TI960_LANES	4
+
+#if IS_ENABLED(CONFIG_VIDEO_IMX390)
+#define IMX390A_ADDRESS		0x44
+#define IMX390B_ADDRESS		0x45
+#define IMX390C_ADDRESS		0x46
+#define IMX390D_ADDRESS		0x47
+
+#define IMX390A_SER_ADDRESS	0x40
+#define IMX390B_SER_ADDRESS	0x41
+#define IMX390C_SER_ADDRESS	0x42
+#define IMX390D_SER_ADDRESS	0x43
+
+static struct ti960_subdev_pdata imx390_d3rcm_pdata_stub = {
+	.lanes = 4,
+	.gpio_powerup_seq = {0, 0xa, -1, -1},
+	.module_flags = TI960_FL_POWERUP | TI960_FL_INIT_SER_CLK,
+	.module_name = "imx390",
+	.fsin = 0, /* gpio 0 used for FSIN */
+};
+
+static struct ti960_subdev_pdata imx390_d3cm_pdata_stub = {
+	.lanes = 4,
+	.gpio_powerup_seq = {0, 0x9, -1, -1},
+	.module_flags = TI960_FL_POWERUP | TI960_FL_INIT_SER_CLK,
+	.module_name = "imx390",
+	.fsin = 3, /* gpio 3 used for FSIN */
+};
+#endif
+
+static struct ipu_isys_csi2_config ti960_csi2_cfg_1 = {
+	.nlanes = TI960_LANES,
+	.port = 1,
+};
+
+static struct ipu_isys_csi2_config ti960_csi2_cfg_2 = {
+	.nlanes = TI960_LANES,
+	.port = 2,
+};
+
+static struct ti960_subdev_info ti960_subdevs[] = {
+#if IS_ENABLED(CONFIG_VIDEO_IMX390)
+	/* D3RCM */
+	{
+		.board_info = {
+			.type = "imx390",
+			.addr = IMX390A_ADDRESS,
+			.platform_data = &imx390_d3rcm_pdata_stub,
+		},
+		.rx_port = 0,
+		.phy_i2c_addr = IMX390_D3RCM_I2C_ADDRESS_8BIT,
+		.ser_alias = IMX390A_SER_ADDRESS,
+		.suffix = 'a',
+	},
+	{
+		.board_info = {
+			.type = "imx390",
+			.addr = IMX390B_ADDRESS,
+			.platform_data = &imx390_d3rcm_pdata_stub,
+		},
+		.rx_port = 1,
+		.phy_i2c_addr = IMX390_D3RCM_I2C_ADDRESS_8BIT,
+		.ser_alias = IMX390B_SER_ADDRESS,
+		.suffix = 'b',
+	},
+	{
+		.board_info = {
+			.type = "imx390",
+			.addr = IMX390C_ADDRESS,
+			.platform_data = &imx390_d3rcm_pdata_stub,
+		},
+		.rx_port = 2,
+		.phy_i2c_addr = IMX390_D3RCM_I2C_ADDRESS_8BIT,
+		.ser_alias = IMX390C_SER_ADDRESS,
+		.suffix = 'c',
+	},
+	{
+		.board_info = {
+			.type = "imx390",
+			.addr = IMX390D_ADDRESS,
+			.platform_data = &imx390_d3rcm_pdata_stub,
+		},
+		.rx_port = 3,
+		.phy_i2c_addr = IMX390_D3RCM_I2C_ADDRESS_8BIT,
+		.ser_alias = IMX390D_SER_ADDRESS,
+		.suffix = 'd',
+	},
+	/* D3CM */
+	{
+		.board_info = {
+			.type = "imx390",
+			.addr = IMX390A_ADDRESS,
+			.platform_data = &imx390_d3cm_pdata_stub,
+		},
+		.rx_port = 0,
+		.phy_i2c_addr = IMX390_D3CM_I2C_ADDRESS_8BIT,
+		.ser_alias = IMX390A_SER_ADDRESS,
+		.suffix = 'a',
+	},
+	{
+		.board_info = {
+			.type = "imx390",
+			.addr = IMX390B_ADDRESS,
+			.platform_data = &imx390_d3cm_pdata_stub,
+		},
+		.rx_port = 1,
+		.phy_i2c_addr = IMX390_D3CM_I2C_ADDRESS_8BIT,
+		.ser_alias = IMX390B_SER_ADDRESS,
+		.suffix = 'b',
+	},
+	{
+		.board_info = {
+			.type = "imx390",
+			.addr = IMX390C_ADDRESS,
+			.platform_data = &imx390_d3cm_pdata_stub,
+		},
+		.rx_port = 2,
+		.phy_i2c_addr = IMX390_D3CM_I2C_ADDRESS_8BIT,
+		.ser_alias = IMX390C_SER_ADDRESS,
+		.suffix = 'c',
+	},
+	{
+		.board_info = {
+			.type = "imx390",
+			.addr = IMX390D_ADDRESS,
+			.platform_data = &imx390_d3cm_pdata_stub,
+		},
+		.rx_port = 3,
+		.phy_i2c_addr = IMX390_D3CM_I2C_ADDRESS_8BIT,
+		.ser_alias = IMX390D_SER_ADDRESS,
+		.suffix = 'd',
+	},
+#endif
+};
+
+static struct ti960_pdata ti960_pdata_1 = {
+	.subdev_info = ti960_subdevs,
+	.subdev_num = ARRAY_SIZE(ti960_subdevs),
+	.reset_gpio = 0,
+	.FPD_gpio = -1,
+	.suffix = 'a',
+};
+
+static struct ti960_pdata ti960_pdata_2 = {
+	.subdev_info = ti960_subdevs,
+	.subdev_num = ARRAY_SIZE(ti960_subdevs),
+	.reset_gpio = 0,
+	.FPD_gpio = -1,
+	.suffix = 'b',
+};
+
+static struct ipu_isys_subdev_info ti960_sd_1 = {
+	.csi2 = &ti960_csi2_cfg_1,
+	.i2c = {
+		.board_info = {
+			 .type = "ti960",
+			 .addr = TI960_I2C_ADDRESS_2,
+			 .platform_data = &ti960_pdata_1,
+		},
+		.i2c_adapter_bdf = "0000:00:15.1",
+	}
+};
+
+static struct ipu_isys_subdev_info ti960_sd_2 = {
+	.csi2 = &ti960_csi2_cfg_2,
+	.i2c = {
+		.board_info = {
+			 .type = "ti960",
+			 .addr = TI960_I2C_ADDRESS_2,
+			 .platform_data = &ti960_pdata_2,
+		},
+		.i2c_adapter_bdf = "0000:00:19.1",
+	}
+};
+#endif
+
+#if IS_ENABLED(CONFIG_VIDEO_LT6911UXC)
+#define LT6911UXC_LANES       4
+#define LT6911UXC_I2C_ADDRESS 0x2B
+
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA) \
+	&& IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_PDATA_DYNAMIC_LOADING)
+static void lt6911uxc_fixup_spdata(const void *spdata_rep, void *spdata)
+{
+	const struct ipu_spdata_rep *rep = spdata_rep;
+	struct lt6911uxc_platform_data *platform = spdata;
+
+	if (spdata_rep && spdata) {
+		platform->port = rep->port_n;
+		platform->lanes = rep->lanes;
+		platform->i2c_slave_address = rep->slave_addr_n;
+		platform->gpios[0] = rep->gpios[0];
+		platform->irq_pin = rep->irq_pin;
+		platform->irq_pin_flags = rep->irq_pin_flags;
+		strcpy(platform->irq_pin_name, rep->irq_pin_name);
+		platform->suffix = rep->suffix;
+	}
+}
+#endif
+
+static struct ipu_isys_csi2_config lt6911uxc_csi2_cfg_1 = {
+	.nlanes = LT6911UXC_LANES,
+	.port = 1,
+};
+
+static struct lt6911uxc_platform_data lt6911uxc_pdata_1 = {
+	.port = 1,
+	.lanes = LT6911UXC_LANES,
+	.i2c_slave_address = LT6911UXC_I2C_ADDRESS,
+	.irq_pin = -1,
+	.irq_pin_name = "READY_STAT",
+	.irq_pin_flags = IRQF_TRIGGER_RISING
+		| IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
+	.suffix = 'a',
+	.reset_pin = -1,
+	.detect_pin = -1,
+	.gpios = {-1, 0, 0, 0},
+};
+
+static struct ipu_isys_subdev_info  lt6911uxc_sd_1 = {
+	.csi2 = &lt6911uxc_csi2_cfg_1,
+	.i2c = {
+	.board_info = {
+		I2C_BOARD_INFO("lt6911uxc", LT6911UXC_I2C_ADDRESS),
+		.platform_data = &lt6911uxc_pdata_1,
+	},
+	.i2c_adapter_bdf = "0000:00:15.1",
+	},
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA) \
+	&& IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_PDATA_DYNAMIC_LOADING)
+	.fixup_spdata = lt6911uxc_fixup_spdata,
+#endif
+};
+
+static struct ipu_isys_csi2_config lt6911uxc_csi2_cfg_2 = {
+	.nlanes = LT6911UXC_LANES,
+	.port = 2,
+};
+
+static struct lt6911uxc_platform_data lt6911uxc_pdata_2 = {
+	.port = 2,
+	.lanes = LT6911UXC_LANES,
+	.i2c_slave_address = LT6911UXC_I2C_ADDRESS,
+	.irq_pin = -1,
+	.irq_pin_name = "READY_STAT",
+	.irq_pin_flags = IRQF_TRIGGER_RISING
+		| IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
+	.suffix = 'b',
+	.reset_pin = -1,
+	.detect_pin = -1,
+	.gpios = {-1, 0, 0, 0},
+};
+
+static struct ipu_isys_subdev_info lt6911uxc_sd_2 = {
+	.csi2 = &lt6911uxc_csi2_cfg_2,
+	.i2c = {
+	.board_info = {
+		I2C_BOARD_INFO("lt6911uxc", LT6911UXC_I2C_ADDRESS),
+		.platform_data = &lt6911uxc_pdata_2,
+	},
+	.i2c_adapter_bdf = "0000:00:19.1",
+	},
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA) \
+	&& IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_PDATA_DYNAMIC_LOADING)
+	.fixup_spdata = lt6911uxc_fixup_spdata,
+#endif
+};
+#endif
+
+#if IS_ENABLED(CONFIG_VIDEO_D4XX)
+#define D4XX_LANES       2
+#define D4XX_I2C_ADDRESS_0 0x10
+#define D4XX_I2C_ADDRESS_1 0x12
+#define D4XX_I2C_ADDRESS_2 0x14
+#define D4XX_PORT0      0
+#define D4XX_PORT1      1
+#define D4XX_PORT2      2
+#define D4XX_PORT3      3
+
+static struct ipu_isys_csi2_config d4xx_csi2_cfg_0 = {
+	.nlanes = D4XX_LANES,
+	.port = D4XX_PORT0,
+};
+
+static struct d4xx_pdata d4xx_pdata_0 = {
+	.suffix = 'a',
+};
+
+static struct ipu_isys_subdev_info d4xx_sd_0 = {
+	.csi2 = &d4xx_csi2_cfg_0,
+	.i2c = {
+		.board_info = {
+			I2C_BOARD_INFO("d4xx", D4XX_I2C_ADDRESS_1),
+			.platform_data = &d4xx_pdata_0,
+		},
+		.i2c_adapter_bdf = "0000:00:15.1",
+	},
+};
+
+static struct ipu_isys_csi2_config d4xx_csi2_cfg_1 = {
+	.nlanes = D4XX_LANES,
+	.port = D4XX_PORT1,
+};
+
+static struct d4xx_pdata d4xx_pdata_1 = {
+	.suffix = 'b',
+};
+
+static struct ipu_isys_subdev_info d4xx_sd_1 = {
+	.csi2 = &d4xx_csi2_cfg_1,
+	.i2c = {
+	.board_info = {
+		I2C_BOARD_INFO("d4xx", D4XX_I2C_ADDRESS_2),
+		.platform_data = &d4xx_pdata_1,
+	},
+	.i2c_adapter_bdf = "0000:00:15.1",
+	},
+};
+
+static struct ipu_isys_csi2_config d4xx_csi2_cfg_2 = {
+	.nlanes = D4XX_LANES,
+	.port = D4XX_PORT2,
+};
+
+static struct d4xx_pdata d4xx_pdata_2 = {
+	.suffix = 'c',
+};
+
+static struct ipu_isys_subdev_info d4xx_sd_2 = {
+	.csi2 = &d4xx_csi2_cfg_2,
+	.i2c = {
+		.board_info = {
+			I2C_BOARD_INFO("d4xx", D4XX_I2C_ADDRESS_1),
+			.platform_data = &d4xx_pdata_2,
+		},
+		.i2c_adapter_bdf = "0000:00:19.1",
+	},
+};
+
+static struct ipu_isys_csi2_config d4xx_csi2_cfg_3 = {
+	.nlanes = D4XX_LANES,
+	.port = D4XX_PORT3,
+};
+
+static struct d4xx_pdata d4xx_pdata_3 = {
+	.suffix = 'd',
+};
+
+static struct ipu_isys_subdev_info d4xx_sd_3 = {
+	.csi2 = &d4xx_csi2_cfg_3,
+	.i2c = {
+	.board_info = {
+		I2C_BOARD_INFO("d4xx", D4XX_I2C_ADDRESS_2),
+	.platform_data = &d4xx_pdata_3,
+	},
+	.i2c_adapter_bdf = "0000:00:19.1",
+	},
+};
+#endif
+
+static struct ipu_isys_clk_mapping clk_mapping[] = {
+	{ CLKDEV_INIT(NULL, NULL, NULL), NULL }
+};
+
+static struct ipu_isys_subdev_pdata pdata = {
+	.subdevs = (struct ipu_isys_subdev_info *[]) {
+#if IS_ENABLED(CONFIG_VIDEO_AR0234)
+		&ar0234_sd_1,
+		&ar0234_sd_2,
+#endif
+#if IS_ENABLED(CONFIG_VIDEO_TI960)
+		&ti960_sd_1,
+		&ti960_sd_2,
+#endif
+#if IS_ENABLED(CONFIG_VIDEO_LT6911UXC)
+		&lt6911uxc_sd_1,
+		&lt6911uxc_sd_2,
+#endif
+#if IS_ENABLED(CONFIG_VIDEO_D4XX)
+		&d4xx_sd_0,
+		&d4xx_sd_1,
+		&d4xx_sd_2,
+		&d4xx_sd_3,
+#endif
+		NULL,
+	},
+	.clk_map = clk_mapping,
+};
+
+static void ipu6_quirk(struct pci_dev *pci_dev)
+{
+	dev_info(&pci_dev->dev, "%s() attach the platform data", __func__);
+	pci_dev->dev.platform_data = &pdata;
+}
+
+DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, IPU6EP_ADL_P_PCI_ID, ipu6_quirk);
+DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, IPU6EP_ADL_N_PCI_ID, ipu6_quirk);
+DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, IPU6EP_RPL_P_PCI_ID, ipu6_quirk);
+
+MODULE_LICENSE("GPL");
Index: b/drivers/media/platform/intel/ipu6-tglrvp-pdata.c
===================================================================
--- /dev/null
+++ b/drivers/media/platform/intel/ipu6-tglrvp-pdata.c
@@ -0,0 +1,638 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) 2022 Intel Corporation
+#include <linux/clk.h>
+#include <linux/clkdev.h>
+#include <linux/gpio.h>
+#include <linux/kernel.h>
+#include <linux/pci.h>
+
+#include <media/ipu-isys.h>
+
+#include <media/ti960.h>
+#include <media/ar0234.h>
+#include <media/imx390.h>
+#include <media/lt6911uxc.h>
+
+#include "ipu.h"
+
+#if defined(CONFIG_VIDEO_OV8856)
+#define OV8856_LANES       4
+#define OV8856_I2C_ADDRESS 0x10
+#define DW9714_I2C_ADDRESS 0xc
+
+static struct ipu_isys_csi2_config ov8856_csi2_cfg_1 = {
+	.nlanes = OV8856_LANES,
+	.port = 1,
+};
+
+static struct ipu_isys_csi2_config ov8856_csi2_cfg_2 = {
+	.nlanes = OV8856_LANES,
+	.port = 2,
+};
+
+static struct ipu_isys_subdev_info ov8856_sd_1 = {
+	.csi2 = &ov8856_csi2_cfg_1,
+	.i2c = {
+	.board_info = {
+		I2C_BOARD_INFO("ov8856", OV8856_I2C_ADDRESS),
+	},
+	.i2c_adapter_id = 13,
+	.i2c_adapter_bdf = "0000:00:15.3",
+	}
+};
+
+static struct ipu_isys_subdev_info dw9714_sd_1 = {
+	.i2c = {
+		.board_info = {
+			I2C_BOARD_INFO("dw9714", DW9714_I2C_ADDRESS),
+		},
+		.i2c_adapter_id = 13,
+		.i2c_adapter_bdf = "0000:00:15.3",
+	}
+};
+
+static struct ipu_isys_subdev_info ov8856_sd_2 = {
+	.csi2 = &ov8856_csi2_cfg_2,
+	.i2c = {
+	.board_info = {
+		I2C_BOARD_INFO("ov8856", OV8856_I2C_ADDRESS),
+	},
+	.i2c_adapter_id = 15,
+	.i2c_adapter_bdf = "0000:00:19.1",
+	}
+};
+
+#endif
+
+#if IS_ENABLED(CONFIG_VIDEO_AR0234)
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA) \
+	&& IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_PDATA_DYNAMIC_LOADING)
+static void ar0234_fixup_spdata(const void *spdata_rep, void *spdata)
+{
+	const struct ipu_spdata_rep *rep = spdata_rep;
+	struct ar0234_platform_data *platform = spdata;
+
+	if (spdata_rep && spdata) {
+		platform->port = rep->port_n;
+		platform->lanes = rep->lanes;
+		platform->i2c_slave_address = rep->slave_addr_n;
+		platform->gpios[0] = rep->gpios[0];
+		platform->irq_pin = rep->irq_pin;
+		platform->irq_pin_flags = rep->irq_pin_flags;
+		strcpy(platform->irq_pin_name, rep->irq_pin_name);
+		platform->suffix = rep->suffix;
+	}
+}
+#endif
+
+#define AR0234_LANES       2
+#define AR0234_I2C_ADDRESS 0x10
+#define AR0234_I2C_ADDRESS_2 0x18
+
+static struct ipu_isys_csi2_config ar0234_csi2_cfg_1 = {
+	.nlanes = AR0234_LANES,
+	.port = 1,
+};
+
+static struct ar0234_platform_data ar0234_pdata_1 = {
+	.port = 1,
+	.lanes = 2,
+	.i2c_slave_address = AR0234_I2C_ADDRESS,
+	.irq_pin = -1,
+	.irq_pin_name = "B23",
+	.irq_pin_flags = IRQF_TRIGGER_RISING
+		| IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
+	.suffix = 'a',
+	.gpios = {-1, 0, 0, 0},
+};
+
+static struct ipu_isys_subdev_info ar0234_sd_1 = {
+	.csi2 = &ar0234_csi2_cfg_1,
+	.i2c = {
+	.board_info = {
+		I2C_BOARD_INFO("ar0234", AR0234_I2C_ADDRESS),
+		.platform_data = &ar0234_pdata_1,
+	},
+	.i2c_adapter_bdf = "0000:00:15.3",
+	},
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA) \
+	&& IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_PDATA_DYNAMIC_LOADING)
+	.fixup_spdata = ar0234_fixup_spdata,
+#endif
+};
+
+static struct ipu_isys_csi2_config ar0234_csi2_cfg_2 = {
+	.nlanes = AR0234_LANES,
+	.port = 2,
+};
+
+static struct ar0234_platform_data ar0234_pdata_2 = {
+	.port = 2,
+	.lanes = 2,
+	.i2c_slave_address = AR0234_I2C_ADDRESS,
+	.irq_pin = -1,
+	.irq_pin_name = "R6",
+	.irq_pin_flags = IRQF_TRIGGER_RISING
+		| IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
+	.suffix = 'b',
+	.gpios = {-1, 0, 0, 0},
+};
+
+static struct ipu_isys_subdev_info ar0234_sd_2 = {
+	.csi2 = &ar0234_csi2_cfg_2,
+	.i2c = {
+	.board_info = {
+		I2C_BOARD_INFO("ar0234", AR0234_I2C_ADDRESS),
+		.platform_data = &ar0234_pdata_2,
+	},
+	.i2c_adapter_bdf = "0000:00:19.1",
+	},
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA) \
+	&& IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_PDATA_DYNAMIC_LOADING)
+	.fixup_spdata = ar0234_fixup_spdata,
+#endif
+};
+
+#if !IS_ENABLED(CONFIG_VIDEO_LT6911UXC)
+static struct ipu_isys_csi2_config ar0234_csi2_cfg_3 = {
+	.nlanes = AR0234_LANES,
+	.port = 4,
+};
+
+static struct ar0234_platform_data ar0234_pdata_3 = {
+	.port = 4,
+	.lanes = 2,
+	.i2c_slave_address = AR0234_I2C_ADDRESS,
+	.irq_pin = -1,
+	.irq_pin_name = "IMGCLKOUT_3",
+	.irq_pin_flags = IRQF_TRIGGER_RISING
+		| IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
+	.suffix = 'c',
+	.gpios = {-1, 0, 0, 0},
+};
+
+static struct ipu_isys_subdev_info ar0234_sd_3 = {
+	.csi2 = &ar0234_csi2_cfg_3,
+	.i2c = {
+	.board_info = {
+		I2C_BOARD_INFO("ar0234", AR0234_I2C_ADDRESS),
+		.platform_data = &ar0234_pdata_3,
+	},
+	.i2c_adapter_bdf = "0000:00:15.2",
+	},
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA) \
+	&& IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_PDATA_DYNAMIC_LOADING)
+	.fixup_spdata = ar0234_fixup_spdata,
+#endif
+};
+#endif
+
+static struct ipu_isys_csi2_config ar0234_csi2_cfg_4 = {
+	.nlanes = AR0234_LANES,
+	.port = 5,
+};
+
+static struct ar0234_platform_data ar0234_pdata_4 = {
+	.port = 5,
+	.lanes = 2,
+	.i2c_slave_address = AR0234_I2C_ADDRESS_2,
+	.irq_pin = -1,
+	.irq_pin_name = "H15",
+	.irq_pin_flags = IRQF_TRIGGER_RISING
+		| IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
+	.suffix = 'd',
+	.gpios = {-1, 0, 0, 0},
+};
+
+static struct ipu_isys_subdev_info ar0234_sd_4 = {
+	.csi2 = &ar0234_csi2_cfg_4,
+	.i2c = {
+	.board_info = {
+		I2C_BOARD_INFO("ar0234", AR0234_I2C_ADDRESS_2),
+		.platform_data = &ar0234_pdata_4,
+	},
+	.i2c_adapter_bdf = "0000:00:15.2",
+	},
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA) \
+	&& IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_PDATA_DYNAMIC_LOADING)
+	.fixup_spdata = ar0234_fixup_spdata,
+#endif
+};
+#endif
+
+#if IS_ENABLED(CONFIG_VIDEO_IMX390)
+#define IMX390_LANES       4
+#define IMX390_D3RCM_I2C_ADDRESS 0x1a
+#define IMX390_D3RCM_I2C_ADDRESS_8BIT (IMX390_D3RCM_I2C_ADDRESS << 1)
+#define IMX390_D3CM_I2C_ADDRESS 0x21
+#define IMX390_D3CM_I2C_ADDRESS_8BIT (IMX390_D3CM_I2C_ADDRESS << 1)
+#define IMX390_I2C_ADDRESS_3 0x1e
+#define IMX390_I2C_ADDRESS_8BIT_3 (IMX390_I2C_ADDRESS_3 << 1)
+#define IMX390_I2C_ADDRESS_4 0x20
+#define IMX390_I2C_ADDRESS_8BIT_4 (IMX390_I2C_ADDRESS_4 << 1)
+
+static struct ipu_isys_csi2_config imx390_csi2_cfg_1 = {
+	.nlanes = IMX390_LANES,
+	.port = 1,
+};
+
+static struct imx390_platform_data imx390_pdata_1 = {
+	.port = 1,
+	.lanes = 4,
+	.i2c_slave_address = IMX390_I2C_ADDRESS_3,
+	.suffix = 'a',
+};
+
+static struct ipu_isys_subdev_info imx390_sd_1 = {
+	.csi2 = &imx390_csi2_cfg_1,
+	.i2c = {
+	.board_info = {
+		I2C_BOARD_INFO("imx390", IMX390_I2C_ADDRESS_3),
+		.platform_data = &imx390_pdata_1,
+	},
+	.i2c_adapter_bdf = "0000:00:15.3",
+	},
+};
+
+static struct ipu_isys_csi2_config imx390_csi2_cfg_2 = {
+	.nlanes = IMX390_LANES,
+	.port = 2,
+};
+
+static struct imx390_platform_data imx390_pdata_2 = {
+	.port = 2,
+	.lanes = 4,
+	.i2c_slave_address = IMX390_I2C_ADDRESS_3,
+	.suffix = 'b',
+};
+
+static struct ipu_isys_subdev_info imx390_sd_2 = {
+	.csi2 = &imx390_csi2_cfg_2,
+	.i2c = {
+	.board_info = {
+		I2C_BOARD_INFO("imx390", IMX390_I2C_ADDRESS_3),
+		.platform_data = &imx390_pdata_2,
+	},
+	.i2c_adapter_bdf = "0000:00:19.1",
+	},
+};
+
+static struct ipu_isys_csi2_config imx390_csi2_cfg_3 = {
+	.nlanes = IMX390_LANES,
+	.port = 1,
+};
+
+static struct imx390_platform_data imx390_pdata_3 = {
+	.port = 1,
+	.lanes = 4,
+	.i2c_slave_address = IMX390_I2C_ADDRESS_4,
+	.suffix = 'a',
+};
+
+static struct ipu_isys_subdev_info imx390_sd_3 = {
+	.csi2 = &imx390_csi2_cfg_1,
+	.i2c = {
+	.board_info = {
+		I2C_BOARD_INFO("imx390", IMX390_I2C_ADDRESS_4),
+		.platform_data = &imx390_pdata_1,
+	},
+	.i2c_adapter_bdf = "0000:00:15.3",
+	},
+};
+
+static struct ipu_isys_csi2_config imx390_csi2_cfg_4 = {
+	.nlanes = IMX390_LANES,
+	.port = 2,
+};
+
+static struct imx390_platform_data imx390_pdata_4 = {
+	.port = 2,
+	.lanes = 4,
+	.i2c_slave_address = IMX390_I2C_ADDRESS_4,
+	.suffix = 'b',
+};
+
+static struct ipu_isys_subdev_info imx390_sd_4 = {
+	.csi2 = &imx390_csi2_cfg_2,
+	.i2c = {
+	.board_info = {
+		I2C_BOARD_INFO("imx390", IMX390_I2C_ADDRESS_4),
+		.platform_data = &imx390_pdata_2,
+	},
+	.i2c_adapter_bdf = "0000:00:19.1",
+	},
+};
+#endif
+
+#if IS_ENABLED(CONFIG_VIDEO_TI960)
+#define TI960_I2C_ADAPTER	2
+#define TI960_I2C_ADAPTER_2	4
+#define TI960_LANES	4
+
+#define IMX390A_ADDRESS		0x44
+#define IMX390B_ADDRESS		0x45
+#define IMX390C_ADDRESS		0x46
+#define IMX390D_ADDRESS		0x47
+
+#define IMX390A_SER_ADDRESS	0x40
+#define IMX390B_SER_ADDRESS	0x41
+#define IMX390C_SER_ADDRESS	0x42
+#define IMX390D_SER_ADDRESS	0x43
+
+static struct ti960_subdev_pdata imx390_d3rcm_pdata_stub = {
+	.lanes = 4,
+	.gpio_powerup_seq = {0, 0xa, -1, -1},
+	.module_flags = TI960_FL_POWERUP | TI960_FL_INIT_SER_CLK,
+	.module_name = "imx390",
+	.fsin = 0, /* gpio 0 used for FSIN */
+};
+
+static struct ti960_subdev_pdata imx390_d3cm_pdata_stub = {
+	.lanes = 4,
+	.gpio_powerup_seq = {0, 0x9, -1, -1},
+	.module_flags = TI960_FL_POWERUP | TI960_FL_INIT_SER_CLK,
+	.module_name = "imx390",
+	.fsin = 3, /* gpio 3 used for FSIN */
+};
+
+static struct ipu_isys_csi2_config ti960_csi2_cfg = {
+	.nlanes = TI960_LANES,
+	.port = 1,
+};
+
+static struct ti960_subdev_info ti960_subdevs[] = {
+#if IS_ENABLED(CONFIG_VIDEO_IMX390)
+	/* D3RCM */
+	{
+		.board_info = {
+			.type = "imx390",
+			.addr = IMX390A_ADDRESS,
+			.platform_data = &imx390_d3rcm_pdata_stub,
+		},
+		.rx_port = 0,
+		.phy_i2c_addr = IMX390_D3RCM_I2C_ADDRESS_8BIT,
+		.ser_alias = IMX390A_SER_ADDRESS,
+		.suffix = 'a',
+	},
+	{
+		.board_info = {
+			.type = "imx390",
+			.addr = IMX390B_ADDRESS,
+			.platform_data = &imx390_d3rcm_pdata_stub,
+		},
+		.rx_port = 1,
+		.phy_i2c_addr = IMX390_D3RCM_I2C_ADDRESS_8BIT,
+		.ser_alias = IMX390B_SER_ADDRESS,
+		.suffix = 'b',
+	},
+	{
+		.board_info = {
+			.type = "imx390",
+			.addr = IMX390C_ADDRESS,
+			.platform_data = &imx390_d3rcm_pdata_stub,
+		},
+		.rx_port = 2,
+		.phy_i2c_addr = IMX390_D3RCM_I2C_ADDRESS_8BIT,
+		.ser_alias = IMX390C_SER_ADDRESS,
+		.suffix = 'c',
+	},
+	{
+		.board_info = {
+			.type = "imx390",
+			.addr = IMX390D_ADDRESS,
+			.platform_data = &imx390_d3rcm_pdata_stub,
+		},
+		.rx_port = 3,
+		.phy_i2c_addr = IMX390_D3RCM_I2C_ADDRESS_8BIT,
+		.ser_alias = IMX390D_SER_ADDRESS,
+		.suffix = 'd',
+	},
+	/* D3CM */
+	{
+		.board_info = {
+			.type = "imx390",
+			.addr = IMX390A_ADDRESS,
+			.platform_data = &imx390_d3cm_pdata_stub,
+		},
+		.rx_port = 0,
+		.phy_i2c_addr = IMX390_D3CM_I2C_ADDRESS_8BIT,
+		.ser_alias = IMX390A_SER_ADDRESS,
+		.suffix = 'a',
+	},
+	{
+		.board_info = {
+			.type = "imx390",
+			.addr = IMX390B_ADDRESS,
+			.platform_data = &imx390_d3cm_pdata_stub,
+		},
+		.rx_port = 1,
+		.phy_i2c_addr = IMX390_D3CM_I2C_ADDRESS_8BIT,
+		.ser_alias = IMX390B_SER_ADDRESS,
+		.suffix = 'b',
+	},
+	{
+		.board_info = {
+			.type = "imx390",
+			.addr = IMX390C_ADDRESS,
+			.platform_data = &imx390_d3cm_pdata_stub,
+		},
+		.rx_port = 2,
+		.phy_i2c_addr = IMX390_D3CM_I2C_ADDRESS_8BIT,
+		.ser_alias = IMX390C_SER_ADDRESS,
+		.suffix = 'c',
+	},
+	{
+		.board_info = {
+			.type = "imx390",
+			.addr = IMX390D_ADDRESS,
+			.platform_data = &imx390_d3cm_pdata_stub,
+		},
+		.rx_port = 3,
+		.phy_i2c_addr = IMX390_D3CM_I2C_ADDRESS_8BIT,
+		.ser_alias = IMX390D_SER_ADDRESS,
+		.suffix = 'd',
+	},
+#endif
+};
+
+static struct ti960_pdata ti960_pdata = {
+	.subdev_info = ti960_subdevs,
+	.subdev_num = ARRAY_SIZE(ti960_subdevs),
+	.reset_gpio = 0,
+	.FPD_gpio = 175,
+	.suffix = 'a',
+};
+
+static struct ipu_isys_subdev_info ti960_sd = {
+	.csi2 = &ti960_csi2_cfg,
+	.i2c = {
+		.board_info = {
+			 .type = "ti960",
+			 .addr = TI960_I2C_ADDRESS,
+			 .platform_data = &ti960_pdata,
+		},
+		.i2c_adapter_bdf = "0000:00:15.3",
+	}
+};
+
+static struct ti960_pdata ti960_pdata_2 = {
+	.subdev_info = ti960_subdevs,
+	.subdev_num = ARRAY_SIZE(ti960_subdevs),
+	.reset_gpio = 0,
+	.FPD_gpio = -1,
+	.suffix = 'a',
+};
+
+static struct ipu_isys_subdev_info ti960_sd_2 = {
+	.csi2 = &ti960_csi2_cfg,
+	.i2c = {
+		.board_info = {
+			 .type = "ti960",
+			 .addr = TI960_I2C_ADDRESS_2,
+			 .platform_data = &ti960_pdata_2,
+		},
+		.i2c_adapter_bdf = "0000:00:15.0",
+	}
+};
+#endif
+
+#if IS_ENABLED(CONFIG_VIDEO_LT6911UXC)
+
+#define LT6911UXC_LANES       4
+#define LT6911UXC_I2C_ADDRESS 0x2B
+
+static struct ipu_isys_csi2_config lt6911uxc_csi2_cfg_0 = {
+	.nlanes = LT6911UXC_LANES,
+	.port = 5,
+};
+
+static struct lt6911uxc_platform_data lt6911uxc_pdata_0 = {
+	.port = 5,
+	.lanes = LT6911UXC_LANES,
+	.i2c_slave_address = LT6911UXC_I2C_ADDRESS,
+	.irq_pin = -1,		// -1 means it is an auxiliary port which has no
+	.irq_pin_name = "B23",
+	.irq_pin_flags = IRQF_TRIGGER_RISING
+		| IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
+	.suffix = 'e',
+	.reset_pin = -1,
+	.detect_pin = -1,
+	.gpios = {-1, 0, 0, 0},
+};
+
+static struct ipu_isys_subdev_info lt6911uxc_sd_0 = {
+	.csi2 = &lt6911uxc_csi2_cfg_0,
+	.i2c = {
+	.board_info = {
+		I2C_BOARD_INFO("lt6911uxc", LT6911UXC_I2C_ADDRESS),
+		.platform_data = &lt6911uxc_pdata_0,
+	},
+	.i2c_adapter_bdf = "0000:00:15.2",
+	},
+};
+
+static struct ipu_isys_csi2_config lt6911uxc_csi2_cfg_1 = {
+	.nlanes = LT6911UXC_LANES,
+	.port = 1,
+};
+
+static struct lt6911uxc_platform_data lt6911uxc_pdata_1 = {
+	.port = 1,
+	.lanes = LT6911UXC_LANES,
+	.i2c_slave_address = LT6911UXC_I2C_ADDRESS,
+	.irq_pin = -1,
+	.irq_pin_name = "C2",
+	.irq_pin_flags = IRQF_TRIGGER_RISING
+		| IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
+	.suffix = 'a',
+	.reset_pin = -1,
+	.detect_pin = -1,
+};
+
+static struct ipu_isys_subdev_info  lt6911uxc_sd_1 = {
+	.csi2 = &lt6911uxc_csi2_cfg_1,
+	.i2c = {
+	.board_info = {
+		I2C_BOARD_INFO("lt6911uxc", LT6911UXC_I2C_ADDRESS),
+		.platform_data = &lt6911uxc_pdata_1,
+	},
+	.i2c_adapter_bdf = "0000:00:15.3",
+	},
+};
+
+static struct ipu_isys_csi2_config lt6911uxc_csi2_cfg_2 = {
+	.nlanes = LT6911UXC_LANES,
+	.port = 2,
+};
+
+static struct lt6911uxc_platform_data lt6911uxc_pdata_2 = {
+	.port = 2,
+	.lanes = LT6911UXC_LANES,
+	.i2c_slave_address = LT6911UXC_I2C_ADDRESS,
+	.irq_pin = -1,
+	.irq_pin_name = "B18",
+	.irq_pin_flags = IRQF_TRIGGER_RISING
+		| IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
+	.suffix = 'b',
+	.reset_pin = -1,
+	.detect_pin = -1,
+};
+
+static struct ipu_isys_subdev_info lt6911uxc_sd_2 = {
+	.csi2 = &lt6911uxc_csi2_cfg_2,
+	.i2c = {
+	.board_info = {
+		I2C_BOARD_INFO("lt6911uxc", LT6911UXC_I2C_ADDRESS),
+		.platform_data = &lt6911uxc_pdata_2,
+	},
+	.i2c_adapter_bdf = "0000:00:19.1",
+	},
+};
+#endif
+
+static struct ipu_isys_clk_mapping clk_mapping[] = {
+	{ CLKDEV_INIT(NULL, NULL, NULL), NULL }
+};
+
+static struct ipu_isys_subdev_pdata pdata = {
+	.subdevs = (struct ipu_isys_subdev_info *[]) {
+#if defined(CONFIG_VIDEO_OV8856)
+		&ov8856_sd_1,
+		&dw9714_sd_1,
+		&ov8856_sd_2,
+#endif
+#if IS_ENABLED(CONFIG_VIDEO_AR0234)
+		&ar0234_sd_1,
+		&ar0234_sd_2,
+#if !IS_ENABLED(CONFIG_VIDEO_LT6911UXC)
+		&ar0234_sd_3,
+#endif
+		&ar0234_sd_4,
+#endif
+#if IS_ENABLED(CONFIG_VIDEO_IMX390)
+		&imx390_sd_1,
+		&imx390_sd_2,
+		&imx390_sd_3,
+		&imx390_sd_4,
+#endif
+#if IS_ENABLED(CONFIG_VIDEO_TI960)
+		&ti960_sd,
+		&ti960_sd_2,
+#endif
+#if IS_ENABLED(CONFIG_VIDEO_LT6911UXC)
+		&lt6911uxc_sd_0,	//Auxiliary port for 4k60fps
+		&lt6911uxc_sd_1,
+		&lt6911uxc_sd_2,
+#endif
+		NULL,
+	},
+	.clk_map = clk_mapping,
+};
+
+static void ipu6_quirk(struct pci_dev *pci_dev)
+{
+	pci_dev->dev.platform_data = &pdata;
+}
+DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, IPU6_PCI_ID, ipu6_quirk);
+
+MODULE_LICENSE("GPL");
Index: b/include/media/ar0234.h
===================================================================
--- /dev/null
+++ b/include/media/ar0234.h
@@ -0,0 +1,24 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2014 - 2022 Intel Corporation */
+
+#ifndef __AR0234_H
+#define __AR0234_H
+
+#include <linux/types.h>
+
+#define AR0234_NAME		"ar0234"
+
+struct ar0234_platform_data {
+	unsigned int port;
+	unsigned int lanes;
+	uint32_t i2c_slave_address;
+	int irq_pin;
+	unsigned int irq_pin_flags;
+	char irq_pin_name[16];
+	int reset_pin;
+	int detect_pin;
+	char suffix;
+	int gpios[4];
+};
+
+#endif /* __AR0234_H  */
Index: b/include/media/d4xx_pdata.h
===================================================================
--- /dev/null
+++ b/include/media/d4xx_pdata.h
@@ -0,0 +1,27 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2022 Intel Corporation */
+
+#ifndef D457_H
+#define D457_H
+
+#define D457_NAME "d4xx"
+#define MAX9296_NAME "MAX9296"
+
+struct d4xx_subdev_info {
+	struct i2c_board_info board_info;
+	int i2c_adapter_id;
+	unsigned short rx_port;
+	unsigned short phy_i2c_addr;
+	unsigned short ser_alias;
+	const char suffix; /* suffix for subdevs */
+};
+
+struct d4xx_pdata {
+	unsigned int subdev_num;
+	struct d4xx_subdev_info *subdev_info;
+	unsigned int reset_gpio;
+	int FPD_gpio;
+	const char suffix;
+	struct i2c_board_info *deser_board_info;
+};
+#endif
Index: b/include/media/imx390.h
===================================================================
--- /dev/null
+++ b/include/media/imx390.h
@@ -0,0 +1,24 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2014 - 2020 Intel Corporation */
+
+#ifndef __IMX390_H
+#define __IMX390_H
+
+#include <linux/types.h>
+
+#define IMX390_NAME "imx390"
+
+#define IMX390_D3CM_I2C_ADDRESS (0x21 << 1)
+
+struct imx390_platform_data {
+	unsigned int port;
+	unsigned int lanes;
+	uint32_t i2c_slave_address;
+	int irq_pin;
+	unsigned int irq_pin_flags;
+	char irq_pin_name[16];
+	char suffix;
+	int gpios[4];
+};
+
+#endif /* __IMX390_H  */
Index: b/include/media/ipu-acpi-pdata.h
===================================================================
--- /dev/null
+++ b/include/media/ipu-acpi-pdata.h
@@ -0,0 +1,103 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2022 Intel Corporation */
+#include <linux/interrupt.h>
+#include <media/ipu-acpi.h>
+#include <media/ar0234.h>
+#include <media/lt6911uxc.h>
+#include <media/ti960.h>
+#include <media/imx390.h>
+#include <media/d4xx_pdata.h>
+
+#define CL_EMPTY 0
+#define CL_DISCRETE 1
+#define SERDES_MAX_PORT 4
+#define SERDES_MAX_GPIO_POWERUP_SEQ 4
+#define LOOP_SIZE 10
+
+int get_sensor_pdata(struct i2c_client *client,
+			struct ipu_camera_module_data *data,
+			struct ipu_i2c_helper *helper,
+			void *priv, size_t size,
+			enum connection_type connect,
+			const char *serdes_name);
+
+struct ipu_isys_subdev_pdata *get_acpi_subdev_pdata(void);
+
+struct sensor_platform_data {
+	unsigned int port;
+	unsigned int lanes;
+	uint32_t i2c_slave_address;
+	int irq_pin;
+	unsigned int irq_pin_flags;
+	char irq_pin_name[IPU_SPDATA_IRQ_PIN_NAME_LEN];
+	int reset_pin;
+	int detect_pin;
+	char suffix;
+	int gpios[IPU_SPDATA_GPIO_NUM];
+};
+
+struct serdes_platform_data {
+	unsigned int subdev_num;
+	struct serdes_subdev_info *subdev_info;
+	unsigned int reset_gpio;
+	unsigned int FPD_gpio;
+	char suffix;
+	struct i2c_board_info *deser_board_info;
+};
+
+struct serdes_subdev_info {
+	struct i2c_board_info board_info;
+	int i2c_adapter_id;
+	unsigned short rx_port;
+	unsigned short phy_i2c_addr;
+	unsigned short ser_alias;
+	char suffix; /* suffix for subdevs */
+};
+
+struct serdes_module_pdata {
+	unsigned short i2c_addr;
+	unsigned short i2c_adapter;
+	unsigned int lanes;
+	int xshutdown;
+	int fsin;
+	int reset;
+	char gpio_powerup_seq[SERDES_MAX_GPIO_POWERUP_SEQ];
+	unsigned int module_flags;
+	char module_name[I2C_NAME_SIZE];
+	char suffix;
+};
+
+struct serdes_local {
+	/* num of camera sensor connected to current mipi port */
+	unsigned int rx_port;
+
+	/* num of i2c addr for current ACPI device */
+	unsigned int i2c_num;
+
+	/* current sensor_addr */
+	unsigned short sensor_addr;
+
+	/* physical i2c addr */
+	unsigned short phy_i2c_addr;
+
+	/* last mapped addr */
+	unsigned short sensor_map_addr;
+
+	/* current serializer_addr */
+	unsigned short ser_addr;
+
+	/* last mapped addr */
+	unsigned short ser_map_addr;
+
+	/* current gpio_powerup_seq */
+	unsigned int gpio_powerup_seq;
+
+	/* current module flag */
+	unsigned int module_flags;
+
+	/* counter for total camera sensor connected */
+	unsigned int sensor_num;
+
+	/* counter for total deser connected */
+	unsigned int deser_num;
+};
Index: b/include/media/ipu-acpi.h
===================================================================
--- /dev/null
+++ b/include/media/ipu-acpi.h
@@ -0,0 +1,205 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2016--2022 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef MEDIA_INTEL_IPU_ACPI_H
+#define MEDIA_INTEL_IPU_ACPI_H
+
+#include <media/ipu-isys.h>
+#include "ipu-isys.h"
+
+#define MAX_ACPI_SENSOR_NUM	4
+#define MAX_ACPI_I2C_NUM	12
+#define MAX_ACPI_GPIO_NUM	12
+
+#define GPIO_RESET		0x0
+#define GPIO_POWER_EN		0xb
+#define GPIO_READY_STAT		0x13
+#define GPIO_HDMI_DETECT	0x14
+
+void set_built_in_pdata(struct ipu_isys_subdev_pdata *pdata);
+
+enum connection_type {
+	TYPE_DIRECT,
+	TYPE_SERDES
+};
+
+/* Data representation as it is in ACPI SSDB buffer */
+struct sensor_bios_data_packed {
+	u8 version;
+	u8 sku;
+	u8 guid_csi2[16];
+	u8 devfunction;
+	u8 bus;
+	u32 dphylinkenfuses;
+	u32 clockdiv;
+	u8 link;
+	u8 lanes;
+	u32 csiparams[10];
+	u32 maxlanespeed;
+	u8 sensorcalibfileidx;
+	u8 sensorcalibfileidxInMBZ[3];
+	u8 romtype;
+	u8 vcmtype;
+	u8 platforminfo;
+	u8 platformsubinfo;
+	u8 flash;
+	u8 privacyled;
+	u8 degree;
+	u8 mipilinkdefined;
+	u32 mclkspeed;
+	u8 controllogicid;
+	u8 mipidataformat;
+	u8 siliconversion;
+	u8 customerid;
+	u8 mclkport;
+	u8 pmicpos;
+	u8 voltagerail;
+	u8 pprval;
+	u8 pprunit;
+	u8 flashid;
+	u8 reserved2[8];
+} __attribute__((__packed__));
+
+struct ipu_i2c_info {
+	unsigned short bus;
+	unsigned short addr;
+};
+
+/* Fields needed by ipu driver */
+/* Each I2C client can have 12 device */
+struct sensor_bios_data {
+	struct device *dev;
+	u8 link;
+	u8 lanes;
+	u8 vcmtype;
+	u8 flash;
+	u8 degree;
+	u8 mclkport;
+	u32 mclkspeed;
+	u16 xshutdown;
+	u8 controllogicid;
+	u8 pprval;
+	u8 pprunit;
+	struct ipu_i2c_info i2c[MAX_ACPI_I2C_NUM];
+	u64 i2c_num;
+};
+
+struct control_logic_data_packed {
+	u8 version;
+	u8 controllogictype;
+	u8 controllogicid;
+	u8 sensorcardsku;
+	u8 inputclk;
+	u8 platformid;
+	u8 subplatformid;
+	u8 customerid;
+	u8 wled1_maxflashcurrent;
+	u8 wled1_maxtorchcurrent;
+	u8 wled2_maxflashcurrent;
+	u8 wled2_maxtorchcurrent;
+	u8 wled1_type;
+	u8 wled2_type;
+	u8 pch_clk_src;
+	u8 reserved2[17];
+} __attribute__((__packed__));
+
+struct ipu_gpio_info {
+	unsigned short init_state;
+	unsigned short pin;
+	unsigned short func;
+	bool valid;
+};
+
+struct ipu_irq_info {
+	int irq_pin;
+	char irq_pin_name[IPU_SPDATA_IRQ_PIN_NAME_LEN];
+};
+
+/* Each I2C client linked to 1 set of CTL Logic */
+struct control_logic_data {
+	struct device *dev;
+	u8 id;
+	u8 type;
+	u8 sku;
+	u64 gpio_num;
+	struct ipu_gpio_info gpio[MAX_ACPI_GPIO_NUM];
+	bool completed;
+};
+
+int ipu_get_acpi_devices(void *driver_data,
+				struct device *dev,
+				struct ipu_isys_subdev_pdata **spdata,
+				struct ipu_isys_subdev_pdata **built_in_pdata,
+				int (*fn)
+				(struct device *, void *,
+				 struct ipu_isys_csi2_config *csi2,
+				 bool reprobe));
+
+struct ipu_isys_subdev_pdata *get_built_in_pdata(void);
+
+int ipu_acpi_get_cam_data(struct device *dev,
+				struct sensor_bios_data *sensor);
+
+int ipu_acpi_get_dep_data(struct device *dev,
+				struct control_logic_data *ctl_data);
+
+int ipu_acpi_get_control_logic_data(struct device *dev,
+				struct control_logic_data **ctl_data);
+
+struct intel_ipu6_regulator {
+	char *src_dev_name;
+	char *src_rail;
+	char *dest_rail;
+};
+
+struct ipu_i2c_helper {
+	int (*fn)(struct device *dev, void *priv,
+		struct ipu_isys_csi2_config *csi2,
+		bool reprobe);
+	void *driver_data;
+};
+
+struct ipu_i2c_new_dev {
+	struct list_head list;
+	struct i2c_board_info info;
+	unsigned short int bus;
+};
+
+struct ipu_camera_module_data {
+	struct list_head list;
+	struct ipu_isys_subdev_info sd;
+	struct ipu_isys_csi2_config csi2;
+	unsigned int ext_clk;
+	void *pdata; /* Ptr to generated platform data*/
+	void *priv; /* Private for specific subdevice */
+};
+
+struct ipu_acpi_devices {
+	const char *hid_name;
+	const char *real_driver;
+	int (*get_platform_data)(struct i2c_client *client,
+				 struct ipu_camera_module_data *data,
+				 struct ipu_i2c_helper *helper,
+				 void *priv,
+				 size_t size,
+				 enum connection_type type,
+				 const char *serdes_name);
+	void *priv_data;
+	size_t priv_size;
+	enum connection_type connect;
+	const char *serdes_name;
+};
+
+#endif
Index: b/include/media/ipu-isys.h
===================================================================
--- /dev/null
+++ b/include/media/ipu-isys.h
@@ -0,0 +1,96 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2014 - 2022 Intel Corporation */
+
+#ifndef MEDIA_IPU_H
+#define MEDIA_IPU_H
+
+#include <linux/i2c.h>
+#include <linux/clkdev.h>
+#include <media/v4l2-async.h>
+
+#define IPU_ISYS_MAX_CSI2_LANES		4
+
+struct ipu_isys_csi2_config {
+	unsigned int nlanes;
+	unsigned int port;
+};
+
+struct ipu_isys_subdev_i2c_info {
+	struct i2c_board_info board_info;
+	int i2c_adapter_id;
+	char i2c_adapter_bdf[32];
+};
+
+#if (IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA) \
+	&& IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_PDATA_DYNAMIC_LOADING)) \
+	|| IS_ENABLED(CONFIG_INTEL_IPU6_ACPI)
+#define IPU_SPDATA_NAME_LEN	20
+#define IPU_SPDATA_BDF_LEN	32
+#define IPU_SPDATA_GPIO_NUM 	4
+#define IPU_SPDATA_IRQ_PIN_NAME_LEN 16
+#endif
+
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA) \
+	&& IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_PDATA_DYNAMIC_LOADING)
+/**
+ * struct ipu_spdata_rep - override subdev platform data
+ *
+ * @name: i2c_board_info.type
+ * @i2c_adapter_bdf_o: old i2c adapter bdf
+ * @slave_addr_o: old i2c slave address
+ * @i2c_adapter_bdf_n: new i2c adapter bdf
+ * @slave_addr_n: new i2c slave address
+ *
+ * identify a subdev with @name, @i2c_adapter_bdf_o and @slave_addr_o and
+ * configure it to use the new  @i2c_adapter_bdf_n and @slave_addr_n
+ */
+struct ipu_spdata_rep {
+	/* i2c old information */
+	char name[IPU_SPDATA_NAME_LEN];
+	unsigned int port_o;
+	char i2c_adapter_bdf_o[IPU_SPDATA_BDF_LEN];
+	uint32_t slave_addr_o;
+
+	/* i2c new information */
+	unsigned int port_n;
+	char i2c_adapter_bdf_n[IPU_SPDATA_BDF_LEN];
+	uint32_t slave_addr_n;
+
+	/* sensor_platform */
+	unsigned int lanes;
+	int gpios[IPU_SPDATA_GPIO_NUM];
+	int irq_pin;
+	unsigned int irq_pin_flags;
+	char irq_pin_name[IPU_SPDATA_IRQ_PIN_NAME_LEN];
+	char suffix;
+};
+#endif
+
+struct ipu_isys_subdev_info {
+	struct ipu_isys_csi2_config *csi2;
+	struct ipu_isys_subdev_i2c_info i2c;
+#if IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_USE_PLATFORMDATA) \
+	&& IS_ENABLED(CONFIG_VIDEO_INTEL_IPU_PDATA_DYNAMIC_LOADING)
+	void (*fixup_spdata)(const void *spdata_rep, void *spdata);
+#endif
+#if IS_ENABLED(CONFIG_INTEL_IPU6_ACPI)
+	char *acpi_hid;
+#endif
+};
+
+struct ipu_isys_clk_mapping {
+	struct clk_lookup clkdev_data;
+	char *platform_clock_name;
+};
+
+struct ipu_isys_subdev_pdata {
+	struct ipu_isys_subdev_info **subdevs;
+	struct ipu_isys_clk_mapping *clk_map;
+};
+
+struct sensor_async_subdev {
+	struct v4l2_async_subdev asd;
+	struct ipu_isys_csi2_config csi2;
+};
+
+#endif /* MEDIA_IPU_H */
Index: b/include/media/lt6911uxc.h
===================================================================
--- /dev/null
+++ b/include/media/lt6911uxc.h
@@ -0,0 +1,24 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2014 - 2022 Intel Corporation */
+
+#ifndef __LT6911UXC_H
+#define __LT6911UXC_H
+
+#include <linux/types.h>
+
+#define LT6911UXC_NAME             "lt6911uxc"
+
+struct lt6911uxc_platform_data {
+	unsigned int port;
+	unsigned int lanes;
+	uint32_t i2c_slave_address;
+	int irq_pin;
+	unsigned int irq_pin_flags;
+	char irq_pin_name[16];
+	int reset_pin;
+	int detect_pin;
+	char suffix;
+	int gpios[4];
+};
+
+#endif /* __LT6911UXC_H  */
Index: b/include/media/ti960.h
===================================================================
--- /dev/null
+++ b/include/media/ti960.h
@@ -0,0 +1,110 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2020 Intel Corporation */
+
+#ifndef TI960_H
+#define TI960_H
+
+#include <linux/i2c.h>
+#include <linux/regmap.h>
+#include <media/v4l2-common.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+
+#define TI960_NAME "ti960"
+
+#define TI960_I2C_ADDRESS	0x32
+#define TI960_I2C_ADDRESS_2	0x3d
+
+#define PIXEL_ORDER_GRBG	0
+#define PIXEL_ORDER_RGGB	1
+#define PIXEL_ORDER_BGGR	2
+#define PIXEL_ORDER_GBRG	3
+
+#define NR_OF_TI960_VCS_PER_SINK_PAD 2
+#define NR_OF_TI960_VCS_SOURCE_PAD 4
+#define NR_OF_TI960_SOURCE_PADS	1
+#define NR_OF_TI960_SINK_PADS	4
+#define NR_OF_TI960_PADS \
+	(NR_OF_TI960_SOURCE_PADS + NR_OF_TI960_SINK_PADS)
+/* 4port * 2vc/port * 8 stream total */
+#define NR_OF_TI960_STREAMS	\
+	(NR_OF_TI960_SINK_PADS * NR_OF_TI960_VCS_PER_SINK_PAD \
+	* NR_OF_TI960_VCS_SOURCE_PAD)
+#define NR_OF_GPIOS_PER_PORT	2
+#define NR_OF_TI960_GPIOS	\
+	(NR_OF_TI960_SINK_PADS * NR_OF_GPIOS_PER_PORT)
+
+#define TI960_PAD_SOURCE	4
+
+#define TI960_MIN_WIDTH		640
+#define TI960_MIN_HEIGHT	480
+#define TI960_MAX_WIDTH		1920
+#define TI960_MAX_HEIGHT	1200
+
+struct ti960_csi_data_format {
+	u32 code;
+	u8 width;
+	u8 compressed;
+	u8 pixel_order;
+	u8 mipi_dt_code;
+};
+
+struct ti960_subdev_info {
+	struct i2c_board_info board_info;
+	int i2c_adapter_id;
+	unsigned short rx_port;
+	unsigned short phy_i2c_addr;
+	unsigned short ser_alias;
+	const char suffix; /* suffix for subdevs */
+};
+
+struct ti960_pdata {
+	unsigned int subdev_num;
+	struct ti960_subdev_info *subdev_info;
+	unsigned int reset_gpio;
+	int FPD_gpio;
+	const char suffix;
+};
+
+#define TI960_MAX_GPIO_POWERUP_SEQ        4
+
+/* set this flag if this module needs serializer initialization */
+#define TI960_FL_INIT_SER	BIT(0)
+/* set this flag if this module has extra powerup sequence */
+#define TI960_FL_POWERUP	BIT(1)
+/* set this flag if this module needs reset signal */
+#define TI960_FL_RESET	BIT(2)
+/* set this flag if it need to init serial clk only */
+#define TI960_FL_INIT_SER_CLK	BIT(4)
+
+struct ti960_subdev_pdata {
+	unsigned short i2c_addr;
+	unsigned short i2c_adapter;
+
+	unsigned int lanes;		/* Number of CSI-2 lanes */
+
+	/* specify gpio pins of Deser for PWDN, FSIN, RESET. */
+	int xshutdown;
+	int fsin;
+	int reset;
+
+	/* specify gpio pins boot timing. */
+	/* Bit 3 write 0/1 on GPIO3
+	 * Bit 2 write 0/1 on GPIO2
+	 * Bit 1 write 0/1 on GPIO1
+	 * Bit 0 write 0/1 on GPIO0
+	 */
+	char gpio_powerup_seq[TI960_MAX_GPIO_POWERUP_SEQ];
+
+	/* module_flags can be:
+	 * TI960_FL_INIT_SER
+	 * TI960_FL_POWERUP
+	 * TI960_FL_RESET
+	 */
+	unsigned int module_flags;
+
+	char module_name[16]; /* module name from ACPI */
+	char suffix; /* suffix to identify multi sensors, abcd.. */
+};
+
+#endif
Index: b/include/media/ti964.h
===================================================================
--- /dev/null
+++ b/include/media/ti964.h
@@ -0,0 +1,71 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2016 - 2020 Intel Corporation */
+
+#ifndef TI964_H
+#define TI964_H
+
+#include <linux/i2c.h>
+#include <linux/regmap.h>
+#include <media/v4l2-common.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+
+#define TI964_NAME "ti964"
+
+#define PIXEL_ORDER_GRBG	0
+#define PIXEL_ORDER_RGGB	1
+#define PIXEL_ORDER_BGGR	2
+#define PIXEL_ORDER_GBRG	3
+
+#define NR_OF_TI964_STREAMS	4
+#define NR_OF_TI964_SOURCE_PADS	1
+#define NR_OF_TI964_SINK_PADS	4
+#define NR_OF_TI964_PADS \
+	(NR_OF_TI964_SOURCE_PADS + NR_OF_TI964_SINK_PADS)
+#define NR_OF_GPIOS_PER_PORT	2
+#define NR_OF_TI964_GPIOS	\
+	(NR_OF_TI964_SINK_PADS * NR_OF_GPIOS_PER_PORT)
+
+#define TI964_PAD_SOURCE	4
+
+#define TI964_MIN_WIDTH		640
+#define TI964_MIN_HEIGHT	480
+#define TI964_MAX_WIDTH		1920
+#define TI964_MAX_HEIGHT	1080
+
+struct ti964_csi_data_format {
+	u32 code;
+	u8 width;
+	u8 compressed;
+	u8 pixel_order;
+	u8 mipi_dt_code;
+};
+
+struct ti964_subdev_info {
+	struct i2c_board_info board_info;
+	int i2c_adapter_id;
+	unsigned short rx_port;
+	unsigned short phy_i2c_addr;
+	const char suffix; /* suffix for subdevs */
+};
+
+struct ti964_pdata {
+	unsigned int subdev_num;
+	struct ti964_subdev_info *subdev_info;
+	unsigned int reset_gpio;
+	const char suffix; /* suffix for multi aggregators, abcd... */
+};
+
+struct ti964_platform_data {
+	unsigned short i2c_addr;
+	unsigned short i2c_adapter;
+
+	/* specify gpio pins of Deser for PWDN, FSIN, RESET. */
+	int xshutdown;
+
+	char module_name[16]; /* module name from ACPI */
+	char suffix; /* suffix to identify multi sensors, abcd.. */
+	unsigned int high_framevalid_flags; /* high framevaild flags*/
+};
+
+#endif
