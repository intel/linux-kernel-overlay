From fb18021660b06374eae7c4ae5218d691e1b1a29a Mon Sep 17 00:00:00 2001
From: Ranjan Dutta <ranjan.dutta@intel.com>
Date: Wed, 28 Dec 2022 01:01:36 +0800
Subject: [PATCH 11/28] Revert "drm/display: Don't assume dual mode adaptors
 support i2c sub-addressing"

This reverts commit 4f0cea018e0326e53ddfc079fe6379b22099875c.
---
 drivers/gpu/drm/drm_dp_dual_mode_helper.c | 51 ++++++++++-------------
 1 file changed, 22 insertions(+), 29 deletions(-)

diff --git a/drivers/gpu/drm/drm_dp_dual_mode_helper.c b/drivers/gpu/drm/drm_dp_dual_mode_helper.c
index f2ff0bfdf54d7..1c9ea9f7fdafe 100644
--- a/drivers/gpu/drm/drm_dp_dual_mode_helper.c
+++ b/drivers/gpu/drm/drm_dp_dual_mode_helper.c
@@ -62,45 +62,23 @@
 ssize_t drm_dp_dual_mode_read(struct i2c_adapter *adapter,
 			      u8 offset, void *buffer, size_t size)
 {
-	u8 zero = 0;
-	char *tmpbuf = NULL;
-	/*
-	 * As sub-addressing is not supported by all adaptors,
-	 * always explicitly read from the start and discard
-	 * any bytes that come before the requested offset.
-	 * This way, no matter whether the adaptor supports it
-	 * or not, we'll end up reading the proper data.
-	 */
 	struct i2c_msg msgs[] = {
 		{
 			.addr = DP_DUAL_MODE_SLAVE_ADDRESS,
 			.flags = 0,
 			.len = 1,
-			.buf = &zero,
+			.buf = &offset,
 		},
 		{
 			.addr = DP_DUAL_MODE_SLAVE_ADDRESS,
 			.flags = I2C_M_RD,
-			.len = size + offset,
+			.len = size,
 			.buf = buffer,
 		},
 	};
 	int ret;
 
-	if (offset) {
-		tmpbuf = kmalloc(size + offset, GFP_KERNEL);
-		if (!tmpbuf)
-			return -ENOMEM;
-
-		msgs[1].buf = tmpbuf;
-	}
-
 	ret = i2c_transfer(adapter, msgs, ARRAY_SIZE(msgs));
-	if (tmpbuf)
-		memcpy(buffer, tmpbuf + offset, size);
-
-	kfree(tmpbuf);
-
 	if (ret < 0)
 		return ret;
 	if (ret != ARRAY_SIZE(msgs))
@@ -227,6 +205,18 @@ enum drm_dp_dual_mode_type drm_dp_dual_mode_detect(struct i2c_adapter *adapter)
 	if (ret)
 		return DRM_DP_DUAL_MODE_UNKNOWN;
 
+	/*
+	 * Sigh. Some (maybe all?) type 1 adaptors are broken and ack
+	 * the offset but ignore it, and instead they just always return
+	 * data from the start of the HDMI ID buffer. So for a broken
+	 * type 1 HDMI adaptor a single byte read will always give us
+	 * 0x44, and for a type 1 DVI adaptor it should give 0x00
+	 * (assuming it implements any registers). Fortunately neither
+	 * of those values will match the type 2 signature of the
+	 * DP_DUAL_MODE_ADAPTOR_ID register so we can proceed with
+	 * the type 2 adaptor detection safely even in the presence
+	 * of broken type 1 adaptors.
+	 */
 	ret = drm_dp_dual_mode_read(adapter, DP_DUAL_MODE_ADAPTOR_ID,
 				    &adaptor_id, sizeof(adaptor_id));
 	DRM_DEBUG_KMS("DP dual mode adaptor ID: %02x (err %zd)\n",
@@ -241,10 +231,11 @@ enum drm_dp_dual_mode_type drm_dp_dual_mode_detect(struct i2c_adapter *adapter)
 				return DRM_DP_DUAL_MODE_TYPE2_DVI;
 		}
 		/*
-		 * If not a proper type 1 ID, still assume type 1, but let
-		 * the user know that we may have misdetected the type.
+		 * If neither a proper type 1 ID nor a broken type 1 adaptor
+		 * as described above, assume type 1, but let the user know
+		 * that we may have misdetected the type.
 		 */
-		if (!is_type1_adaptor(adaptor_id))
+		if (!is_type1_adaptor(adaptor_id) && adaptor_id != hdmi_id[0])
 			DRM_ERROR("Unexpected DP dual mode adaptor ID %02x\n",
 				  adaptor_id);
 
@@ -348,8 +339,10 @@ EXPORT_SYMBOL(drm_dp_dual_mode_get_tmds_output);
  * @enable: enable (as opposed to disable) the TMDS output buffers
  *
  * Set the state of the TMDS output buffers in the adaptor. For
- * type2 this is set via the DP_DUAL_MODE_TMDS_OEN register.
- * Type1 adaptors do not support any register writes.
+ * type2 this is set via the DP_DUAL_MODE_TMDS_OEN register. As
+ * some type 1 adaptors have problems with registers (see comments
+ * in drm_dp_dual_mode_detect()) we avoid touching the register,
+ * making this function a no-op on type 1 adaptors.
  *
  * Returns:
  * 0 on success, negative error code on failure
-- 
2.25.1

