From c7c1cefaf7355a445dca29893ffe9dddbe3c73a8 Mon Sep 17 00:00:00 2001
From: Chen Meng J <meng.j.chen@intel.com>
Date: Wed, 12 Jul 2023 14:20:44 +0800
Subject: [PATCH 26/43] sensors: Use clk-framework instead of a "clken" GPIO

Use the clk-framework to get a clk-provider reference and use
clk_prepare_enable() / clk_disable_unprepare() to control the clk.
This replace modelling the clock as a "clken" GPIO, which is not a
valid way to model it when the clk is e.g. generated by the
clk-generator of a TPS68470 PMIC.
This relies on the following upstream bugfix for the INT3472
linux.git/commit/?id=cf5ac2d45f6e4d11ad78e7b10ae9a4121ba5e995
are in output mode"
This patch is available since upstream kernel 6.1.7, so the new code
is only enabled for LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 7)
This allow susing the IPU6 sensor drivers with the upstream int3472
driver with unmodified upstream kernels >= 6.1.7 .

Signed-off-by: Hans de Goede <hdegoede@redhat.com>
Signed-off-by: Hao Yao <hao.yao@intel.com>
Signed-off-by: Chen Meng J <meng.j.chen@intel.com>
---
 drivers/media/i2c/hm11b1.c  | 18 +++++++++---------
 drivers/media/i2c/ov01a1s.c | 18 +++++++++---------
 2 files changed, 18 insertions(+), 18 deletions(-)

diff --git a/drivers/media/i2c/hm11b1.c b/drivers/media/i2c/hm11b1.c
index 474e0b4e98c9..60e7ed474729 100644
--- a/drivers/media/i2c/hm11b1.c
+++ b/drivers/media/i2c/hm11b1.c
@@ -468,8 +468,8 @@ struct hm11b1 {
 	struct gpio_desc *reset_gpio;
 	/* GPIO for powerdown */
 	struct gpio_desc *powerdown_gpio;
-	/* GPIO for clock enable */
-	struct gpio_desc *clken_gpio;
+	/* Clock provider */
+	struct clk *clk;
 	/* GPIO for privacy LED */
 	struct gpio_desc *pled_gpio;
 #endif
@@ -508,7 +508,10 @@ static void hm11b1_set_power(struct hm11b1 *hm11b1, int on)
 		return;
 	gpiod_set_value_cansleep(hm11b1->reset_gpio, on);
 	gpiod_set_value_cansleep(hm11b1->powerdown_gpio, on);
-	gpiod_set_value_cansleep(hm11b1->clken_gpio, on);
+	if (on)
+		clk_prepare_enable(hm11b1->clk);
+	else
+		clk_disable_unprepare(hm11b1->clk);
 	gpiod_set_value_cansleep(hm11b1->pled_gpio, on);
 	msleep(20);
 #elif IS_ENABLED(CONFIG_POWER_CTRL_LOGIC)
@@ -1057,12 +1060,9 @@ static int hm11b1_parse_dt(struct hm11b1 *hm11b1)
 		return ret;
 	}
 
-	hm11b1->clken_gpio = devm_gpiod_get(dev, "clken", GPIOD_OUT_HIGH);
-	ret = PTR_ERR_OR_ZERO(hm11b1->clken_gpio);
-	if (ret < 0) {
-		dev_err(dev, "error while getting clken_gpio gpio: %d\n", ret);
-		return ret;
-	}
+	hm11b1->clk = devm_clk_get_optional(dev, "clk");
+	if (IS_ERR(hm11b1->clk))
+		return dev_err_probe(dev, PTR_ERR(hm11b1->clk), "getting clk\n");
 
 	hm11b1->pled_gpio = devm_gpiod_get(dev, "pled", GPIOD_OUT_HIGH);
 	ret = PTR_ERR_OR_ZERO(hm11b1->pled_gpio);
diff --git a/drivers/media/i2c/ov01a1s.c b/drivers/media/i2c/ov01a1s.c
index b03c369990bd..01fdf1d15936 100644
--- a/drivers/media/i2c/ov01a1s.c
+++ b/drivers/media/i2c/ov01a1s.c
@@ -314,8 +314,8 @@ struct ov01a1s {
 	struct gpio_desc *reset_gpio;
 	/* GPIO for powerdown */
 	struct gpio_desc *powerdown_gpio;
-	/* GPIO for clock enable */
-	struct gpio_desc *clken_gpio;
+	/* Clock provider */
+	struct clk *clk;
 	/* GPIO for privacy LED */
 	struct gpio_desc *pled_gpio;
 #endif
@@ -336,7 +336,10 @@ static void ov01a1s_set_power(struct ov01a1s *ov01a1s, int on)
 		return;
 	gpiod_set_value_cansleep(ov01a1s->reset_gpio, on);
 	gpiod_set_value_cansleep(ov01a1s->powerdown_gpio, on);
-	gpiod_set_value_cansleep(ov01a1s->clken_gpio, on);
+	if (on)
+		clk_prepare_enable(ov01a1s->clk);
+	else
+		clk_disable_unprepare(ov01a1s->clk);
 	gpiod_set_value_cansleep(ov01a1s->pled_gpio, on);
 	msleep(20);
 #elif IS_ENABLED(CONFIG_POWER_CTRL_LOGIC)
@@ -884,12 +887,9 @@ static int ov01a1s_parse_dt(struct ov01a1s *ov01a1s)
 		return -EPROBE_DEFER;
 	}
 
-	ov01a1s->clken_gpio = devm_gpiod_get(dev, "clken", GPIOD_OUT_HIGH);
-	ret = PTR_ERR_OR_ZERO(ov01a1s->clken_gpio);
-	if (ret < 0) {
-		dev_err(dev, "error while getting clken_gpio gpio: %d\n", ret);
-		return -EPROBE_DEFER;
-	}
+	ov01a1s->clk = devm_clk_get_optional(dev, "clk");
+	if (IS_ERR(ov01a1s->clk))
+		return dev_err_probe(dev, PTR_ERR(ov01a1s->clk), "getting clk\n");
 
 	ov01a1s->pled_gpio = devm_gpiod_get(dev, "pled", GPIOD_OUT_HIGH);
 	ret = PTR_ERR_OR_ZERO(ov01a1s->pled_gpio);
-- 
2.25.1

