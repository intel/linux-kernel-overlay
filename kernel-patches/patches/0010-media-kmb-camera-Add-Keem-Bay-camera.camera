From c1704ffef37c554b1d201a316e78b640d7459c81 Mon Sep 17 00:00:00 2001
From: Martina Krasteva <martinax.krasteva@intel.com>
Date: Fri, 26 Jun 2020 14:26:10 +0100
Subject: [PATCH 10/42] media: kmb-camera: Add Keem Bay camera

Add support for the Keem Bay camera subsystem.

Signed-off-by: Martina Krasteva <martinax.krasteva@intel.com>
Signed-off-by: Daniele Alessandrelli <daniele.alessandrelli@intel.com>
---
 drivers/media/platform/Kconfig                |    2 +
 drivers/media/platform/Makefile               |    1 +
 drivers/media/platform/kmb-camera/Kconfig     |    8 +
 drivers/media/platform/kmb-camera/Makefile    |    4 +
 .../media/platform/kmb-camera/kmb-camera.c    | 1586 ++++++++++++
 .../media/platform/kmb-camera/kmb-camera.h    |  143 ++
 .../platform/kmb-camera/kmb-isp-config.c      |  541 ++++
 .../platform/kmb-camera/kmb-isp-config.h      |   79 +
 drivers/media/platform/kmb-camera/kmb-isp.c   | 2192 ++++++++++++++++
 drivers/media/platform/kmb-camera/kmb-isp.h   |  207 ++
 .../media/platform/kmb-camera/kmb-lrt-cmd.h   |  106 +
 .../media/platform/kmb-camera/kmb-lrt-frame.h |   70 +
 .../media/platform/kmb-camera/kmb-lrt-pipe.h  |   87 +
 .../media/platform/kmb-camera/kmb-lrt-src.h   |  124 +
 drivers/media/platform/kmb-camera/kmb-video.c | 2231 +++++++++++++++++
 drivers/media/platform/kmb-camera/kmb-video.h |  154 ++
 include/uapi/linux/kmb-isp-ctl.h              |  169 ++
 17 files changed, 7704 insertions(+)
 create mode 100644 drivers/media/platform/kmb-camera/Kconfig
 create mode 100644 drivers/media/platform/kmb-camera/Makefile
 create mode 100644 drivers/media/platform/kmb-camera/kmb-camera.c
 create mode 100644 drivers/media/platform/kmb-camera/kmb-camera.h
 create mode 100644 drivers/media/platform/kmb-camera/kmb-isp-config.c
 create mode 100644 drivers/media/platform/kmb-camera/kmb-isp-config.h
 create mode 100644 drivers/media/platform/kmb-camera/kmb-isp.c
 create mode 100644 drivers/media/platform/kmb-camera/kmb-isp.h
 create mode 100644 drivers/media/platform/kmb-camera/kmb-lrt-cmd.h
 create mode 100644 drivers/media/platform/kmb-camera/kmb-lrt-frame.h
 create mode 100644 drivers/media/platform/kmb-camera/kmb-lrt-pipe.h
 create mode 100644 drivers/media/platform/kmb-camera/kmb-lrt-src.h
 create mode 100644 drivers/media/platform/kmb-camera/kmb-video.c
 create mode 100644 drivers/media/platform/kmb-camera/kmb-video.h
 create mode 100644 include/uapi/linux/kmb-isp-ctl.h

diff --git a/drivers/media/platform/Kconfig b/drivers/media/platform/Kconfig
index 80321e03809a..ade1a9607b3c 100644
--- a/drivers/media/platform/Kconfig
+++ b/drivers/media/platform/Kconfig
@@ -29,6 +29,8 @@ source "drivers/media/platform/cadence/Kconfig"
 
 source "drivers/media/platform/davinci/Kconfig"
 
+source "drivers/media/platform/kmb-camera/Kconfig"
+
 source "drivers/media/platform/omap/Kconfig"
 
 config VIDEO_ASPEED
diff --git a/drivers/media/platform/Makefile b/drivers/media/platform/Makefile
index 73ce083c2fc6..95c2eb7a2149 100644
--- a/drivers/media/platform/Makefile
+++ b/drivers/media/platform/Makefile
@@ -86,3 +86,4 @@ obj-$(CONFIG_VIDEO_QCOM_VENUS)		+= qcom/venus/
 obj-y					+= sunxi/
 
 obj-$(CONFIG_VIDEO_MESON_GE2D)		+= meson/ge2d/
+obj-$(CONFIG_VIDEO_INTEL_KEEMBAY_CAMERA)	+= kmb-camera/
diff --git a/drivers/media/platform/kmb-camera/Kconfig b/drivers/media/platform/kmb-camera/Kconfig
new file mode 100644
index 000000000000..40396929d762
--- /dev/null
+++ b/drivers/media/platform/kmb-camera/Kconfig
@@ -0,0 +1,8 @@
+config VIDEO_INTEL_KEEMBAY_CAMERA
+	tristate "INTEL KeemBay camera subsystem"
+	depends on VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API && HAS_DMA
+	depends on XLINK_CORE && KEEMBAY_IPC && KEEMBAY_VPU_IPC
+	select VIDEOBUF2_DMA_CONTIG
+	select V4L2_FWNODE
+	help
+	  Driver for KeemBay camera subsystem
diff --git a/drivers/media/platform/kmb-camera/Makefile b/drivers/media/platform/kmb-camera/Makefile
new file mode 100644
index 000000000000..82a950b5fab1
--- /dev/null
+++ b/drivers/media/platform/kmb-camera/Makefile
@@ -0,0 +1,4 @@
+kmb-cam-objs = kmb-camera.o \
+	kmb-isp.o kmb-video.o kmb-isp-config.o
+
+obj-$(CONFIG_VIDEO_INTEL_KEEMBAY_CAMERA) += kmb-cam.o
diff --git a/drivers/media/platform/kmb-camera/kmb-camera.c b/drivers/media/platform/kmb-camera/kmb-camera.c
new file mode 100644
index 000000000000..705115babd7c
--- /dev/null
+++ b/drivers/media/platform/kmb-camera/kmb-camera.c
@@ -0,0 +1,1586 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * kmb-camera.c - KeemBay Camera Driver.
+ *
+ * Copyright (C) 2018-2019 Intel Corporation
+ */
+#include <linux/of.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/of_reserved_mem.h>
+#include <linux/dma-mapping.h>
+#include <linux/kmb-isp-ctl.h>
+#include <media/v4l2-fwnode.h>
+
+#include "kmb-camera.h"
+#include "kmb-lrt-cmd.h"
+
+#define KMB_CAM_XLINK_CHAN_ID_BASE	30
+#define RT_CONTROL_CH_ID		27
+#define KMB_RT_CTRL_CH_DATA_SIZE	1024
+#define KMB_RT_CTRL_CH_TIMEOUT_MS	5000
+
+#define to_kmb_camera_pipe(ptr_entity)					\
+({									\
+	struct video_device *vdev =					\
+		container_of(entity, struct video_device, entity);	\
+	struct kmb_video *kmb_vid =					\
+		(struct kmb_video *)video_get_drvdata(vdev);		\
+	struct kmb_cam_pipeline *pipe = kmb_vid->priv;			\
+	pipe;								\
+})
+
+/**
+ * kmb_cam_accuire_channel_id - Allocate channel id
+ * @priv: callback private data
+ *
+ * Return: channel id
+ */
+static int kmb_cam_accuire_channel_id(void *priv)
+{
+	struct kmb_cam_pipeline *pipeline = (struct kmb_cam_pipeline *)priv;
+	int id;
+
+	id = ida_alloc_range(pipeline->rt_pipe.id_alloc,
+		KMB_CAM_XLINK_CHAN_ID_BASE, U16_MAX, GFP_KERNEL);
+
+	return id;
+}
+
+/**
+ * kmb_cam_free_channel_id - Free channel id
+ * @priv: callback private data
+ * @id: channel id
+ *
+ * Return: none
+ */
+static void kmb_cam_free_channel_id(void *priv, unsigned int id)
+{
+	struct kmb_cam_pipeline *pipeline = (struct kmb_cam_pipeline *)priv;
+
+	ida_free(pipeline->rt_pipe.id_alloc, id);
+}
+
+/* ISP channel ID operations */
+struct kmb_isp_channel_ops kmb_isp_channel_ops = {
+	.accuire_id = kmb_cam_accuire_channel_id,
+	.free_id = kmb_cam_free_channel_id,
+};
+
+/* Video device channel ID operations */
+struct kmb_video_channel_ops kmb_vid_channel_ops = {
+	.accuire_id = kmb_cam_accuire_channel_id,
+	.free_id = kmb_cam_free_channel_id,
+};
+
+/**
+ * kmb_cam_print_pipeline_config - Print pipeline configuration
+ * @cfg: LRT pipeline configuration
+ * @ctrl: LRT Control type
+ * @result: Flag indicating result configuration
+ *
+ * Return: none
+ */
+static void kmb_cam_print_pipeline_config(struct pipeConfigEvS *cfg,
+					  u32 ctrl, bool result)
+{
+	int i;
+
+	switch (ctrl) {
+	case IC_EVENT_TYPE_CONFIG_ISP_PIPE:
+		pr_debug("IC_EVENT_TYPE_CONFIG_ISP_PIPE %s",
+			 result ? "result" : "");
+		break;
+	case IC_EVENT_TYPE_BUILD_ISP_PIPE:
+		pr_debug("IC_EVENT_TYPE_BUILD_ISP_PIPE %s",
+			 result ? "result" : "result");
+		break;
+	case IC_EVENT_TYPE_DELETE_ISP_PIPE:
+		pr_debug("IC_EVENT_TYPE_DELETE_ISP_PIPE %s",
+			 result ? "result" : "");
+		break;
+	default:
+		pr_err("Unknown control %d\n", ctrl);
+		break;
+	}
+
+	pr_debug("\tpipeID %u\n", cfg->pipeID);
+	pr_debug("\tpipeType %u\n", cfg->pipeType);
+	pr_debug("\tsrcType %u\n", cfg->srcType);
+	pr_debug("\tpipeTransHub %u\n", cfg->pipeTransHub);
+	pr_debug("\tinIspRes %ux%u\n", cfg->inIspRes.w, cfg->inIspRes.h);
+	pr_debug("\tinIspStride %u\n", cfg->inIspStride);
+	pr_debug("\tinExpOffsets[0] %u\n\tinExpOffsets[1] %u\n"
+		"\tinExpOffsets[2] %u\n",
+		cfg->inExpOffsets[0], cfg->inExpOffsets[1],
+		cfg->inExpOffsets[2]);
+
+	for (i = 0; i < PIPE_OUTPUT_ID_MAX; i++) {
+		pr_debug("\tOUTPUT ID: %d\n", i);
+		pr_debug("\t\toutMinRes %ux%u\n",
+			cfg->outMinRes[i].w, cfg->outMinRes[i].h);
+		pr_debug("\t\toutMaxRes %ux%u\n",
+			cfg->outMaxRes[i].w, cfg->outMaxRes[i].h);
+	}
+
+	for (i = 0; i < PIPE_OUTPUT_ID_MAX; i++) {
+		pr_debug("\tpipeXlinkChann: %d\n", i);
+		pr_debug("\t\tchID: %u %ux%u\n",
+			cfg->pipeXlinkChann[i].chID,
+			cfg->pipeXlinkChann[i].frmRes.w,
+			cfg->pipeXlinkChann[i].frmRes.h);
+	}
+
+	pr_debug("\tkeepAspectRatio %u\n", cfg->keepAspectRatio);
+	pr_debug("\tinDataWidth %u\n", cfg->inDataWidth);
+	pr_debug("\tinDataPacked %u\n", cfg->inDataPacked);
+	pr_debug("\toutDataWidth %u\n", cfg->outDataWidth);
+	pr_debug("\tvpuInternalMemAddr 0x%llx\n", cfg->vpuInternalMemAddr);
+	pr_debug("\tvpuInternalMemSize %u\n", cfg->vpuInternalMemSize);
+}
+
+/**
+ * kmb_cam_config_isp_src - Fill endpoint configuration from sensor fwnode
+ * @kmb_cam: pointer to kmb camera device
+ * @pipeline: pointer to kmb_cam_pipeline
+ *
+ * Return: none
+ */
+static void kmb_cam_config_isp_src(struct kmb_camera *kmb_cam,
+				   struct kmb_cam_pipeline *pipeline)
+{
+	struct kmb_cam_endpoint_data *ep = NULL;
+	struct kmb_isp_src_config src_config;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(kmb_cam->ep_data); i++) {
+		if (kmb_cam->ep_data[i].remote == pipeline->sensor->fwnode) {
+			ep = &kmb_cam->ep_data[i];
+			break;
+		}
+	}
+	if (!ep)
+		return;
+
+	memset(&src_config, 0, sizeof(src_config));
+	src_config.num_phy_lanes = ep->ep_data.bus.mipi_csi2.num_data_lanes;
+	src_config.controller_num = ep->controller_num;
+	switch (ep->ep_data.bus_type) {
+	case V4L2_MBUS_CSI2_DPHY:
+		src_config.type = KMB_ISP_CSI2;
+		break;
+	default:
+		src_config.type = KMB_ISP_MEMORY;
+		break;
+	}
+
+	kmb_isp_set_src_config(&pipeline->isp,
+			KMB_ISP_SINK_PAD_SENSOR, &src_config);
+}
+
+/**
+ * kmb_cam_update_isp_pads_ranges - Update isp pads format ranges
+ * @cfg: LRT pipeline configuration
+ * @kmb_isp: pointer to KMB ISP sub-device
+ *
+ * Return: none
+ */
+static void kmb_cam_update_isp_pads_ranges(struct pipeConfigEvS *cfg,
+					   struct kmb_isp *kmb_isp)
+{
+	struct kmb_isp_res_range range;
+	u32 isp_pad = KMB_ISP_SRC_PAD_RAW;
+	int ret;
+	int i;
+
+	/* Update ISP source pad frame size ranges */
+	for (i = PIPE_OUTPUT_ID_RAW; i < PIPE_OUTPUT_ID_MAX; i++) {
+		if (i == PIPE_OUTPUT_ID_ISP_CTRL)
+			continue;
+
+		range.min_width = cfg->outMinRes[i].w;
+		range.min_height = cfg->outMinRes[i].h;
+		range.max_width = cfg->outMaxRes[i].w;
+		range.max_height = cfg->outMaxRes[i].h;
+		ret = kmb_isp_set_pad_fmt_range(kmb_isp, isp_pad, &range);
+		if (ret < 0)
+			break;
+
+		isp_pad++;
+	}
+
+	/* Update sink pad format range to be the same as sensor res */
+	range.min_width = cfg->inIspRes.w;
+	range.min_height = cfg->inIspRes.h;
+	range.max_width = cfg->inIspRes.w;
+	range.max_height = cfg->inIspRes.h;
+	kmb_isp_set_pad_fmt_range(kmb_isp, KMB_ISP_SINK_PAD_RAW, &range);
+	kmb_isp_set_pad_fmt_range(kmb_isp, KMB_ISP_SINK_PAD_SENSOR, &range);
+}
+
+/**
+ * kmb_cam_init_pipe - Initialize kmb camera pipeline instance
+ * @kmb_cam: pointer to KMB Camera device
+ * @pipeline: pointer to kmb_cam_pipeline
+ *
+ * Return: none
+ */
+static void kmb_cam_init_pipe(struct kmb_camera *kmb_cam,
+			      struct kmb_cam_pipeline *pipeline)
+{
+	pipeline->config_refcnt = 0;
+	pipeline->built_refcnt = 0;
+	pipeline->streaming_refcnt = 0;
+	mutex_init(&pipeline->lock);
+
+	memset(&pipeline->rt_pipe.pipe_cfg, 0,
+		sizeof(pipeline->rt_pipe.pipe_cfg));
+
+	pipeline->rt_pipe.ctrl_chan = &kmb_cam->ctrl_channel;
+	pipeline->rt_pipe.id_alloc = &kmb_cam->id_alloc;
+
+	pipeline->rt_pipe.work_mem.dev = kmb_cam->dev;
+}
+
+/**
+ * kmb_cam_get_subdev_channel_ids - Get all needed channel IDs
+ * @pipeline: pointer to kmb_cam_pipeline
+ *
+ * Return: none
+ */
+static void kmb_cam_get_subdev_channel_ids(struct kmb_cam_pipeline *pipeline)
+{
+	int i;
+
+	pipeline->rt_pipe.raw_channel_id =
+			kmb_video_get_channel_id(&pipeline->raw_input);
+	if (!pipeline->rt_pipe.raw_channel_id)
+		pipeline->rt_pipe.raw_channel_id =
+			kmb_video_get_channel_id(&pipeline->raw_output);
+
+	pipeline->rt_pipe.isp_channel_id =
+			kmb_isp_get_channel_id(&pipeline->isp);
+
+	for (i = 0; i < KMB_MAX_OUTPUT_COUNT; i++)
+		pipeline->rt_pipe.video_channel_id[i] =
+			kmb_video_get_channel_id(&pipeline->output[i]);
+}
+
+/**
+ * kmb_cam_init_control_channel - Initialize camera xlink control channel
+ * @kmb_cam: pointer to KMB Camera device
+ *
+ * Return: 0 if successful
+ */
+static int kmb_cam_init_control_channel(struct kmb_camera *kmb_cam)
+{
+	struct kmb_cam_ctrl_channel *c_chan = &kmb_cam->ctrl_channel;
+
+	c_chan->cma_vaddr = dma_alloc_coherent(kmb_cam->dev,
+			sizeof(struct pipeConfigEvS),
+			(dma_addr_t *)&c_chan->cma_phy_addr, 0);
+	if (!c_chan->cma_vaddr)
+		return -ENOMEM;
+
+	mutex_init(&c_chan->lock);
+	c_chan->refcnt = 0;
+	c_chan->ipc_dev_handler = &kmb_cam->ipc_dev_handler;
+
+	dev_dbg(kmb_cam->dev, "CTRL CHANNEL CMA: phy 0x%x vaddr %p\n",
+		c_chan->cma_phy_addr, c_chan->cma_vaddr);
+
+	return 0;
+}
+
+/**
+ * kmb_cam_destroy_control_channel - Destroy camera xlink control channel
+ * @kmb_cam: pointer to KMB Camera device
+ */
+static void kmb_cam_destroy_control_channel(struct kmb_camera *kmb_cam)
+{
+	struct kmb_cam_ctrl_channel *c_chan = &kmb_cam->ctrl_channel;
+
+	dma_free_coherent(kmb_cam->dev, sizeof(struct pipeConfigEvS),
+			  c_chan->cma_vaddr, c_chan->cma_phy_addr);
+	mutex_destroy(&c_chan->lock);
+}
+
+/**
+ * kmb_cam_alloc_dma_mem - Allocate DMA memory
+ * @work_mem: DMA memory object
+ * @size: requested memory block size
+ *
+ * Return: 0 if successful
+ */
+static int kmb_cam_alloc_dma_mem(struct kmb_cam_dma_mem *work_mem, u32 size)
+{
+	work_mem->vaddr = dma_alloc_attrs(work_mem->dev, size,
+		&work_mem->phy_addr, GFP_KERNEL, DMA_ATTR_FORCE_CONTIGUOUS);
+	if (!work_mem->vaddr)
+		return -ENOMEM;
+
+	work_mem->size = size;
+
+	dev_dbg(work_mem->dev, "Alloc mem phy 0x%pad vaddr %p size %u\n",
+		&work_mem->phy_addr, work_mem->vaddr, work_mem->size);
+
+	return 0;
+}
+
+/**
+ * kmb_cam_free_dma_mem - Free DMA memory
+ * @work_mem: DMA memory object
+ */
+static void kmb_cam_free_dma_mem(struct kmb_cam_dma_mem *work_mem)
+{
+	dev_dbg(work_mem->dev, "Free mem phy 0x%pad vaddr %p size %u\n",
+		&work_mem->phy_addr, work_mem->vaddr, work_mem->size);
+
+	dma_free_attrs(work_mem->dev, work_mem->size, work_mem->vaddr,
+		       work_mem->phy_addr, DMA_ATTR_FORCE_CONTIGUOUS);
+}
+
+/**
+ * kmb_cam_request_control_channel - Request camera xlink control channel
+ * @c_chan: Camera control channel
+ *
+ * Return: 0 if successful
+ */
+static int kmb_cam_request_control_channel(struct kmb_cam_ctrl_channel *c_chan)
+{
+	int ret = 0;
+
+	mutex_lock(&c_chan->lock);
+
+	if (c_chan->refcnt == 0) {
+		/* Open control channel */
+		ret = xlink_open_channel(c_chan->ipc_dev_handler,
+					RT_CONTROL_CH_ID,
+					RXB_TXB, KMB_RT_CTRL_CH_DATA_SIZE,
+					KMB_RT_CTRL_CH_TIMEOUT_MS);
+		if (ret)
+			goto done;
+
+	}
+	c_chan->refcnt++;
+
+done:
+	mutex_unlock(&c_chan->lock);
+
+	return ret;
+}
+
+/**
+ * kmb_cam_release_control_channel - Release camera xlink control channel
+ * @c_chan: Camera control channel
+ *
+ * Return: 0 if successful
+ */
+static int kmb_cam_release_control_channel(struct kmb_cam_ctrl_channel *c_chan)
+{
+	int ret = 0;
+
+	mutex_lock(&c_chan->lock);
+
+	if (WARN_ON(c_chan->refcnt == 0))
+		goto done;
+
+	if (c_chan->refcnt == 1) {
+		/* Close control channel */
+		ret = xlink_close_channel(c_chan->ipc_dev_handler,
+					  RT_CONTROL_CH_ID);
+		if (ret)
+			pr_err("Failed to close ctrl chan: %d\n", ret);
+
+	}
+	c_chan->refcnt--;
+done:
+	mutex_unlock(&c_chan->lock);
+	return ret;
+}
+
+/**
+ * kmb_cam_write_control_message - Write camera control message
+ * @c_chan: Camera control channel
+ * @cfg_pipe_evt: Pointer to pipe configuration
+ * @ctrl_type: Control message type
+ *
+ * Return: 0 if successful
+ */
+static int kmb_cam_write_control_message(struct kmb_cam_ctrl_channel *c_chan,
+					 struct pipeConfigEvS *cfg_pipe_evt,
+					 u32 ctrl_type)
+{
+	struct pipeConfigEvS *cma_cfg_pipe_evt;
+	size_t init_evt_size = sizeof(struct icEvS);
+	struct icEvS init_evt;
+	u32 expected_result = IC_EVENT_TYPE_SUCCESFULL;
+	int ret = -EINVAL;
+
+	mutex_lock(&c_chan->lock);
+
+	if (WARN_ON(c_chan->refcnt == 0))
+		goto exit_unlock;
+
+	kmb_cam_print_pipeline_config(cfg_pipe_evt, ctrl_type, false);
+
+	cma_cfg_pipe_evt = c_chan->cma_vaddr;
+
+	/* Copy messages to cma memory */
+	*cma_cfg_pipe_evt = *cfg_pipe_evt;
+
+	memset(&init_evt, 0, sizeof(init_evt));
+	init_evt.ctrl = ctrl_type;
+	init_evt.EvInfo.instId = cma_cfg_pipe_evt->pipeID;
+	init_evt.EvInfo.userDataBaseAddr01 = c_chan->cma_phy_addr;
+
+	ret = xlink_write_volatile(c_chan->ipc_dev_handler,
+				   RT_CONTROL_CH_ID,
+				   (u8 *)&init_evt,
+				   init_evt_size);
+	if (ret) {
+		pr_err("Error ret %d ctrl %d\n", ret, ctrl_type);
+		goto exit_unlock;
+	}
+
+	/*
+	 * For some reason lrt is returning config pipe as result for
+	 * config pipe control. This is temporary workaround to avoid fail.
+	 */
+	if (ctrl_type == IC_EVENT_TYPE_CONFIG_ISP_PIPE)
+		expected_result = IC_EVENT_TYPE_CONFIG_ISP_PIPE;
+
+	ret = xlink_read_data_to_buffer(c_chan->ipc_dev_handler,
+					RT_CONTROL_CH_ID,
+					(u8 *const)&init_evt,
+					(u32 *)&init_evt_size);
+	if (ret != X_LINK_SUCCESS || init_evt.ctrl != expected_result) {
+		pr_err("Error ret %d ctrl %d  %d\n", ret,
+			ctrl_type, init_evt.ctrl);
+		ret = ret ? ret : -ENODEV;
+		goto exit_unlock;
+	}
+
+	/* Some of the settings are modified copy them back */
+	*cfg_pipe_evt = *cma_cfg_pipe_evt;
+
+	kmb_cam_print_pipeline_config(cfg_pipe_evt, ctrl_type, true);
+
+exit_unlock:
+	mutex_unlock(&c_chan->lock);
+	return ret;
+}
+
+/**
+ * kmb_cam_config_lrt_pipe - Negotiate LRT pipeline configuration
+ * @pipeline: pointer to pipeline
+ * @input_fmt: pointer to pad-level media bus format
+ * @output_fmt: (optional)pointer to media bus format
+ *
+ * Return: 0 if successful
+ */
+static int kmb_cam_config_lrt_pipe(struct kmb_cam_pipeline *pipeline,
+				   struct v4l2_subdev_format *input_fmt,
+				   struct v4l2_mbus_framefmt *output_fmt)
+{
+	const struct kmb_isp_format *fmt;
+	struct pipeConfigEvS *cfg_pipe_evt = &pipeline->rt_pipe.pipe_cfg;
+	struct kmb_isp_hdr_info *hdr_info =
+		(struct kmb_isp_hdr_info *) input_fmt->format.reserved;
+	int ret;
+
+	cfg_pipe_evt->pipeID = pipeline->rt_pipe.pipe_instance_id;
+	cfg_pipe_evt->pipeType =
+		kmb_isp_get_lrt_camera_mode(&pipeline->isp);
+	cfg_pipe_evt->pipeTransHub =
+		kmb_isp_get_lrt_transform_hub(&pipeline->isp);
+
+	kmb_cam_get_subdev_channel_ids(pipeline);
+
+	if (!pipeline->rt_pipe.raw_channel_id) {
+		pr_debug("no raw channel, use SRC_TYPE_ALLOC_VPU_DATA_MIPI");
+		cfg_pipe_evt->srcType = SRC_TYPE_ALLOC_VPU_DATA_MIPI;
+		cfg_pipe_evt->inDataPacked = true;
+	} else if (pipeline->raw_input.channel_id ==
+		   pipeline->rt_pipe.raw_channel_id) {
+		pr_debug("raw input, use SRC_TYPE_ALLOC_ARM_DATA_ARM");
+		cfg_pipe_evt->srcType = SRC_TYPE_ALLOC_ARM_DATA_ARM;
+		cfg_pipe_evt->inDataPacked = pipeline->raw_input.packed_fmt;
+	} else if (pipeline->raw_output.channel_id ==
+		   pipeline->rt_pipe.raw_channel_id) {
+		pr_debug("raw output, use SRC_TYPE_ALLOC_ARM_DATA_MIPI");
+		cfg_pipe_evt->srcType = SRC_TYPE_ALLOC_ARM_DATA_MIPI;
+		cfg_pipe_evt->inDataPacked = pipeline->raw_output.packed_fmt;
+	}
+
+	/*
+	 * This is the only supported srcType for
+	 * pipeType PIPE_TYPE_SRC_NO_ISP
+	 */
+	if (cfg_pipe_evt->pipeType == PIPE_TYPE_SRC_NO_ISP)
+		cfg_pipe_evt->srcType = SRC_TYPE_ALLOC_ARM_DATA_MIPI;
+
+	cfg_pipe_evt->inIspRes.w = input_fmt->format.width;
+	cfg_pipe_evt->inIspRes.h = input_fmt->format.height;
+
+	fmt = kmb_isp_get_fmt_by_code(input_fmt->format.code);
+	if (!fmt)
+		return -ERANGE;
+
+	cfg_pipe_evt->inDataWidth = fmt->bpp;
+
+	switch (hdr_info->type) {
+	case HDR_2DOL_LI: {
+			u8 num_exposures = 2;
+
+			cfg_pipe_evt->inExpOffsets[0] = hdr_info->offset0;
+			cfg_pipe_evt->inExpOffsets[1] = hdr_info->offset1;
+
+			cfg_pipe_evt->inIspStride = cfg_pipe_evt->inIspRes.w *
+						    num_exposures * fmt->bpp /
+						    8;
+		}
+		break;
+	case HDR_3DOL_LI: {
+			u8 num_exposures = 3;
+
+			cfg_pipe_evt->inExpOffsets[0] = hdr_info->offset0;
+			cfg_pipe_evt->inExpOffsets[1] = hdr_info->offset1;
+			cfg_pipe_evt->inExpOffsets[2] = hdr_info->offset2;
+
+			cfg_pipe_evt->inIspStride = cfg_pipe_evt->inIspRes.w *
+						    num_exposures * fmt->bpp /
+						    8;
+		}
+		break;
+	default:
+		break;
+	}
+
+	fmt = kmb_isp_get_fmt_by_code(
+		pipeline->isp.pad_fmt_caps[KMB_ISP_SRC_PAD_VID_BASE].code[0]);
+	if (!fmt)
+		return -ERANGE;
+
+	cfg_pipe_evt->outDataWidth = fmt->bpp;
+
+	if (output_fmt) {
+		int rotation = kmb_isp_get_rotation(&pipeline->isp);
+		/*
+		 * Rotation is applied after the isp. Correct
+		 * the resolution if is rotated.
+		 */
+		if (rotation == 90 || rotation == 270) {
+			cfg_pipe_evt->outIspRes.w = output_fmt->height;
+			cfg_pipe_evt->outIspRes.h = output_fmt->width;
+		} else {
+			cfg_pipe_evt->outIspRes.w = output_fmt->width;
+			cfg_pipe_evt->outIspRes.h = output_fmt->height;
+		}
+	} else {
+		cfg_pipe_evt->outIspRes = cfg_pipe_evt->inIspRes;
+	}
+
+	ret = kmb_cam_write_control_message(pipeline->rt_pipe.ctrl_chan,
+		cfg_pipe_evt, IC_EVENT_TYPE_CONFIG_ISP_PIPE);
+
+	/* If no raw output range is set, use sensor res */
+	if (cfg_pipe_evt->outMaxRes[PIPE_OUTPUT_ID_RAW].w <
+	    cfg_pipe_evt->inIspRes.w)
+		cfg_pipe_evt->outMaxRes[PIPE_OUTPUT_ID_RAW].w =
+			cfg_pipe_evt->inIspRes.w;
+
+	if (cfg_pipe_evt->outMaxRes[PIPE_OUTPUT_ID_RAW].h <
+	    cfg_pipe_evt->inIspRes.h)
+		cfg_pipe_evt->outMaxRes[PIPE_OUTPUT_ID_RAW].h =
+			cfg_pipe_evt->inIspRes.h;
+
+	return ret;
+}
+
+/**
+ * kmb_cam_set_fmt_camera_mode - Set media bus format reserved field
+ * @camera_mode: camera mode
+ * @fmt: pointer to media bus format
+ *
+ * Set media bus format reserved field based on the selected camera mode
+ *
+ * Return: none
+ */
+static void kmb_cam_set_fmt_camera_mode(const u32 camera_mode,
+					struct v4l2_mbus_framefmt *fmt)
+{
+	if (!fmt)
+		return;
+
+	switch (camera_mode) {
+	case PIPE_TYPE_ISP_ISP_2DOL:
+		fmt->reserved[0] = 2;
+		break;
+	case PIPE_TYPE_ISP_ISP_3DOL:
+		fmt->reserved[0] = 3;
+		break;
+	default:
+		fmt->reserved[0] = 0;
+		break;
+	}
+}
+
+/**
+ * kmb_cam_reconfigure_pipeline - Reconfigure LRT pipeline
+ * @pipeline: pointer to kmb_cam_pipeline
+ * @cam_mode: new camera mode to configure RT pipe with
+ *
+ * Return: 0 if successful
+ */
+static int kmb_cam_reconfigure_pipeline(struct kmb_cam_pipeline *pipeline,
+					uint8_t cam_mode)
+{
+	struct v4l2_subdev_format fmt;
+	int ret;
+
+	memset(&fmt, 0, sizeof(fmt));
+
+	fmt.pad = KMB_ISP_SINK_PAD_SENSOR;
+	fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
+	ret = v4l2_subdev_call(&pipeline->isp.subdev,
+			pad, get_fmt, NULL, &fmt);
+	if (ret < 0) {
+		pr_err("Cannot acquire ISP sink pad fmt %d\n", ret);
+		return ret;
+	}
+
+	fmt.pad = 0;
+	fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
+	kmb_cam_set_fmt_camera_mode(cam_mode, &fmt.format);
+
+	ret = v4l2_subdev_call(pipeline->sensor, pad, set_fmt, NULL, &fmt);
+	if (ret < 0) {
+		pr_err("Cannot change sensor source pad fmt %d\n", ret);
+		return ret;
+	}
+
+	/* Update only sensor format */
+	ret = kmb_cam_config_lrt_pipe(pipeline, &fmt, NULL);
+	if (ret < 0) {
+		pr_err("Cannot re-configure lrt pipe %d\n", ret);
+		return ret;
+	}
+
+	return ret;
+}
+
+/**
+ * kmb_cam_build_pipeline - Build LRT pipeline
+ * @entity: pointer to media entity
+ *
+ * Return: 0 if successful
+ */
+static int kmb_cam_build_pipeline(struct media_entity *entity)
+{
+	struct kmb_cam_pipeline *pipeline = to_kmb_camera_pipe(entity);
+	struct pipeConfigEvS *cfg_pipe_evt = &pipeline->rt_pipe.pipe_cfg;
+	struct v4l2_subdev_format pad_fmt;
+	uint8_t cam_mode = kmb_isp_get_lrt_camera_mode(&pipeline->isp);
+	u32 isp_pad, cid_idx;
+	int i;
+	int ret;
+
+	mutex_lock(&pipeline->lock);
+	if (pipeline->built_refcnt > 0) {
+		pipeline->built_refcnt++;
+		mutex_unlock(&pipeline->lock);
+		return 0;
+	}
+
+	/* Allocate additional work memory for vpu if necessary */
+	if (cfg_pipe_evt->vpuInternalMemSize) {
+		ret = kmb_cam_alloc_dma_mem(&pipeline->rt_pipe.work_mem,
+					    cfg_pipe_evt->vpuInternalMemSize);
+		if (ret < 0) {
+			dev_err(pipeline->rt_pipe.work_mem.dev,
+				"Failed to allocate LRT memory pool");
+			ret = -ENOMEM;
+			goto error_unlock;
+		}
+
+		cfg_pipe_evt->vpuInternalMemAddr =
+			(u64) pipeline->rt_pipe.work_mem.phy_addr;
+
+		dev_dbg(pipeline->rt_pipe.work_mem.dev,
+			"vpuInternalMemSize %u vpuInternalMemAddr 0x%llx",
+			cfg_pipe_evt->vpuInternalMemSize,
+			cfg_pipe_evt->vpuInternalMemAddr);
+	}
+
+	/*
+	 * Handle inDataPacked here:
+	 * - In PIPE_TYPE_SRC_NO_ISP the output is directly connected to MIPI
+	 * - For raw output it is possible to have default format on config
+	 *   streams. In that case update the flag here. In the worst case we
+	 *   will allocate memory for unpacked data.
+	 * - When VPU is using internal pool flag should be raised
+	 */
+	if (cam_mode == PIPE_TYPE_SRC_NO_ISP)
+		cfg_pipe_evt->inDataPacked = pipeline->output[0].packed_fmt;
+	else if (cfg_pipe_evt->srcType == SRC_TYPE_ALLOC_ARM_DATA_MIPI)
+		cfg_pipe_evt->inDataPacked = pipeline->raw_output.packed_fmt;
+	else
+		cfg_pipe_evt->inDataPacked = true;
+
+	memset(&pad_fmt, 0, sizeof(pad_fmt));
+
+	if (cfg_pipe_evt->srcType == SRC_TYPE_ALLOC_ARM_DATA_ARM)
+		pad_fmt.pad = KMB_ISP_SINK_PAD_RAW;
+	else if (cfg_pipe_evt->srcType == SRC_TYPE_ALLOC_ARM_DATA_MIPI)
+		pad_fmt.pad = KMB_ISP_SRC_PAD_RAW;
+
+	pad_fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
+	ret = v4l2_subdev_call(&pipeline->isp.subdev,
+		pad, get_fmt, NULL, &pad_fmt);
+	if (ret < 0)
+		goto error_unlock;
+
+	cfg_pipe_evt->pipeXlinkChann[PIPE_OUTPUT_ID_RAW].frmRes.w =
+			pad_fmt.format.width;
+	cfg_pipe_evt->pipeXlinkChann[PIPE_OUTPUT_ID_RAW].frmRes.h =
+			pad_fmt.format.height;
+	cfg_pipe_evt->pipeXlinkChann[PIPE_OUTPUT_ID_RAW].chID =
+			pipeline->rt_pipe.raw_channel_id;
+
+	cid_idx = 0;
+	isp_pad = KMB_ISP_SRC_PAD_VID_BASE;
+	memset(&pad_fmt, 0, sizeof(pad_fmt));
+	for (i = PIPE_OUTPUT_ID_0; i < PIPE_OUTPUT_ID_MAX; i++) {
+		if (cid_idx >= KMB_MAX_OUTPUT_COUNT)
+			break;
+
+		pad_fmt.pad = isp_pad++;
+		pad_fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
+		ret = v4l2_subdev_call(&pipeline->isp.subdev,
+			pad, get_fmt, NULL, &pad_fmt);
+		if (ret < 0)
+			break;
+
+		cfg_pipe_evt->pipeXlinkChann[i].frmRes.w =
+			pad_fmt.format.width;
+		cfg_pipe_evt->pipeXlinkChann[i].frmRes.h =
+			pad_fmt.format.height;
+
+		cfg_pipe_evt->pipeXlinkChann[i].chID =
+			pipeline->rt_pipe.video_channel_id[cid_idx++];
+	}
+
+	cfg_pipe_evt->pipeXlinkChann[PIPE_OUTPUT_ID_ISP_CTRL].chID =
+			pipeline->rt_pipe.isp_channel_id;
+	cfg_pipe_evt->pipeXlinkChann[PIPE_OUTPUT_ID_ISP_CTRL].frmRes.w =
+			cfg_pipe_evt->pipeXlinkChann[PIPE_OUTPUT_ID_0].frmRes.w;
+	cfg_pipe_evt->pipeXlinkChann[PIPE_OUTPUT_ID_ISP_CTRL].frmRes.h =
+			cfg_pipe_evt->pipeXlinkChann[PIPE_OUTPUT_ID_0].frmRes.h;
+
+	if (cfg_pipe_evt->pipeType != cam_mode) {
+		ret = kmb_cam_reconfigure_pipeline(pipeline, cam_mode);
+		if (ret < 0)
+			goto error_free_mem;
+	}
+
+	ret = kmb_cam_write_control_message(pipeline->rt_pipe.ctrl_chan,
+		cfg_pipe_evt, IC_EVENT_TYPE_BUILD_ISP_PIPE);
+	if (ret < 0)
+		goto error_free_mem;
+
+	pipeline->built_refcnt++;
+
+	mutex_unlock(&pipeline->lock);
+	return 0;
+
+error_free_mem:
+	kmb_cam_free_dma_mem(&pipeline->rt_pipe.work_mem);
+error_unlock:
+	mutex_unlock(&pipeline->lock);
+	return ret;
+}
+
+/**
+ * kmb_cam_teardown_pipeline - Teardown LRT pipeline
+ * @entity: pointer to media entity
+ *
+ * Return: none
+ */
+static void kmb_cam_teardown_pipeline(struct media_entity *entity)
+{
+	struct kmb_cam_pipeline *pipeline = to_kmb_camera_pipe(entity);
+
+	mutex_lock(&pipeline->lock);
+
+	if (WARN_ON(pipeline->built_refcnt == 0))
+		goto exit_unlock;
+
+	if (pipeline->built_refcnt > 1) {
+		pipeline->built_refcnt--;
+		goto exit_unlock;
+	}
+
+	kmb_cam_write_control_message(pipeline->rt_pipe.ctrl_chan,
+		&pipeline->rt_pipe.pipe_cfg, IC_EVENT_TYPE_DELETE_ISP_PIPE);
+
+	kmb_cam_free_dma_mem(&pipeline->rt_pipe.work_mem);
+	memset(&pipeline->rt_pipe.pipe_cfg, 0,
+		sizeof(pipeline->rt_pipe.pipe_cfg));
+
+	pipeline->built_refcnt--;
+
+exit_unlock:
+	mutex_unlock(&pipeline->lock);
+}
+
+/**
+ * kmb_cam_pipeline_request_config - Request LRT pipeline configuration
+ * @entity: pointer to media entity
+ * @fmt: pointer to media bus format
+ *
+ * Return: 0 if successful
+ */
+static int kmb_cam_pipeline_request_config(struct media_entity *entity,
+					   struct v4l2_mbus_framefmt *fmt)
+{
+	struct v4l2_subdev_format input_fmt;
+	struct kmb_cam_pipeline *pipeline = to_kmb_camera_pipe(entity);
+	struct media_pad *remote;
+	u32 camera_mode;
+	int ret;
+
+	mutex_lock(&pipeline->lock);
+
+	memset(&input_fmt, 0x00, sizeof(input_fmt));
+
+	camera_mode = kmb_isp_get_lrt_camera_mode(&pipeline->isp);
+
+	kmb_cam_set_fmt_camera_mode(camera_mode, fmt);
+
+	pr_debug("%s: camera mode %d reserved %d", __func__,
+		camera_mode, fmt->reserved[0]);
+
+	input_fmt.format = *fmt;
+	if (pipeline->config_refcnt == 0) {
+
+		input_fmt.pad = 0;
+		input_fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
+		ret = v4l2_subdev_call(pipeline->sensor,
+				pad, set_fmt, NULL, &input_fmt);
+		if (ret < 0) {
+			pr_err("Couldn't set sensor source pad fmt %d\n", ret);
+			goto exit;
+		}
+
+		pr_debug("Sensor output format is set to wxh %dx%d cspc %d\n",
+			input_fmt.format.width, input_fmt.format.height,
+			input_fmt.format.code);
+
+		input_fmt.pad = KMB_ISP_SINK_PAD_SENSOR;
+		input_fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
+		ret = v4l2_subdev_call(&pipeline->isp.subdev,
+				pad, set_fmt, NULL, &input_fmt);
+		if (ret < 0) {
+			pr_err("Couldn't set isp sens sink pad fmt %d\n", ret);
+			goto exit;
+		}
+
+		ret = kmb_cam_config_lrt_pipe(pipeline, &input_fmt, fmt);
+		if (ret < 0)
+			goto exit;
+
+		/* Update isp pads when pipeline is configured */
+		kmb_cam_update_isp_pads_ranges(&pipeline->rt_pipe.pipe_cfg,
+					       &pipeline->isp);
+	}
+
+	/* In DOL interleaved mode always use single plane raw output frame */
+	if (pipeline->rt_pipe.pipe_cfg.inExpOffsets[0] ||
+	    pipeline->rt_pipe.pipe_cfg.inExpOffsets[1] ||
+	    pipeline->rt_pipe.pipe_cfg.inExpOffsets[2])
+		input_fmt.format.reserved[0] = 1;
+
+	remote = media_entity_remote_pad(entity->pads);
+	input_fmt.pad = remote->index;
+	input_fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
+	input_fmt.format.width = fmt->width;
+	input_fmt.format.height = fmt->height;
+	input_fmt.format.code = fmt->code;
+	ret = v4l2_subdev_call(&pipeline->isp.subdev,
+			pad, set_fmt, NULL, &input_fmt);
+	if (ret < 0) {
+		pr_err("Couldn't get isp output source pad fmt %d\n", ret);
+		goto exit;
+	}
+
+	*fmt = input_fmt.format;
+
+	pipeline->config_refcnt++;
+exit:
+	mutex_unlock(&pipeline->lock);
+	return ret;
+}
+
+/**
+ * kmb_cam_pipeline_release_config - Release LRT pipeline configuration
+ * @entity: pointer to media entity
+ *
+ * Return: 0 if successful
+ */
+static int kmb_cam_pipeline_release_config(struct media_entity *entity)
+{
+	struct kmb_cam_pipeline *pipeline = to_kmb_camera_pipe(entity);
+
+	mutex_lock(&pipeline->lock);
+	if (!WARN_ON(pipeline->config_refcnt == 0))
+		pipeline->config_refcnt--;
+	mutex_unlock(&pipeline->lock);
+	return 0;
+}
+
+/**
+ * kmb_cam_pipeline_s_stream - LRT pipeline set stream
+ * @entity: pointer to media entity
+ * @enable: state to set to the stream
+ *
+ * Return: 0 if successful
+ */
+static int kmb_cam_pipeline_s_stream(struct media_entity *entity, int enable)
+{
+	struct kmb_cam_pipeline *pipeline = to_kmb_camera_pipe(entity);
+	int ret;
+
+	pr_debug("%s Pipeline enable streaming %d\n", __func__, enable);
+
+	mutex_lock(&pipeline->lock);
+
+	if (enable) {
+		if (pipeline->streaming_refcnt > 0) {
+			pipeline->streaming_refcnt++;
+			goto success;
+		}
+
+		ret = v4l2_subdev_call(&pipeline->isp.subdev,
+				       video, s_stream, enable);
+		if (ret < 0 && ret != -ENOIOCTLCMD) {
+			pr_err("Cannot s_stream %d to ISP\n", enable);
+			goto error;
+		}
+
+		ret = v4l2_subdev_call(pipeline->sensor,
+				       video, s_stream, enable);
+		if (ret < 0 && ret != -ENOIOCTLCMD) {
+			pr_err("Cannot s_stream %d to sensor\n", enable);
+			goto error_isp_stream_disable;
+		}
+
+		pipeline->streaming_refcnt++;
+	} else {
+		BUG_ON(!pipeline->streaming_refcnt);
+
+		if (pipeline->streaming_refcnt > 1) {
+			pipeline->streaming_refcnt--;
+			goto success;
+		}
+
+		ret = v4l2_subdev_call(&pipeline->isp.subdev,
+				       video, s_stream, enable);
+		if (ret < 0 && ret != -ENOIOCTLCMD) {
+			pr_err("Cannot s_stream %d to ISP\n", enable);
+			goto error;
+		}
+
+		ret = v4l2_subdev_call(pipeline->sensor,
+				       video, s_stream, enable);
+		if (ret < 0 && ret != -ENOIOCTLCMD) {
+			pr_err("Cannot s_stream %d to sensor\n", enable);
+			goto error;
+		}
+
+		pipeline->streaming_refcnt--;
+	}
+
+success:
+	mutex_unlock(&pipeline->lock);
+	return 0;
+
+error_isp_stream_disable:
+	v4l2_subdev_call(&pipeline->isp.subdev, video, s_stream, 0);
+error:
+	mutex_unlock(&pipeline->lock);
+	return ret;
+}
+
+/**
+ * kmb_cam_pipeline_s_power - Power ON/OFF LRT pipeline
+ * @entity: pointer to media entity
+ * @on: Set to power on LRT pipeline
+ *
+ * Return: 0 if successful
+ */
+static int kmb_cam_pipeline_s_power(struct media_entity *entity, int on)
+{
+	struct kmb_cam_pipeline *pipeline = to_kmb_camera_pipe(entity);
+	struct kmb_cam_ctrl_channel *c_chan = pipeline->rt_pipe.ctrl_chan;
+	int ret;
+
+	if (on)
+		ret = kmb_cam_request_control_channel(c_chan);
+	else
+		ret = kmb_cam_release_control_channel(c_chan);
+
+	return ret;
+}
+
+/* Pipeline operations */
+struct kmb_pipeline_ops kmb_pipe_ops = {
+	.s_power = kmb_cam_pipeline_s_power,
+	.build = kmb_cam_build_pipeline,
+	.teardown = kmb_cam_teardown_pipeline,
+	.request_config = kmb_cam_pipeline_request_config,
+	.release_config = kmb_cam_pipeline_release_config,
+	.s_stream = kmb_cam_pipeline_s_stream,
+};
+
+/**
+ * kmb_cam_init_subdevices - Initialize Kmb camera subdevices
+ * @kmb_cam: pointer to kmb media device
+ * @pipeline: pointer to kmb_cam_pipeline
+ *
+ * Return: 0 if successful
+ */
+static int kmb_cam_init_subdevices(struct kmb_camera *kmb_cam,
+				   struct kmb_cam_pipeline *pipeline)
+{
+	char vnode_name[KMB_MAX_OUTPUT_NAME_LEN];
+	int i;
+	int ret;
+
+	pipeline->isp.pipe = &pipeline->media_pipe;
+	pipeline->isp.priv = (void *)pipeline;
+	pipeline->isp.ipc_dev_handler = &kmb_cam->ipc_dev_handler;
+	pipeline->isp.channel_ops = kmb_isp_channel_ops;
+
+	kmb_isp_init(&pipeline->isp, kmb_cam->dev);
+	kmb_cam_config_isp_src(kmb_cam, pipeline);
+
+	pipeline->raw_input.pipe = &pipeline->media_pipe;
+	pipeline->raw_input.ipc_dev_handler = &kmb_cam->ipc_dev_handler;
+	pipeline->raw_input.priv = (void *)pipeline;
+	pipeline->raw_input.dma_dev = kmb_cam->dev;
+	pipeline->raw_input.pipe_ops = kmb_pipe_ops;
+	pipeline->raw_input.channel_ops = kmb_vid_channel_ops;
+
+	ret = kmb_video_init(&pipeline->raw_input, "isp-raw-input",
+			     KMB_VIDEO_RAW_INPUT);
+	if (ret < 0)
+		dev_err(kmb_cam->dev, "Fail to init raw input video node\n");
+
+	for (i = 0; i < KMB_MAX_OUTPUT_COUNT; i++) {
+		memset(vnode_name, 0, KMB_MAX_OUTPUT_NAME_LEN);
+		pipeline->output[i].pipe = &pipeline->media_pipe;
+		pipeline->output[i].ipc_dev_handler = &kmb_cam->ipc_dev_handler;
+		pipeline->output[i].priv = (void *)pipeline;
+		pipeline->output[i].dma_dev = kmb_cam->dev;
+		pipeline->output[i].pipe_ops = kmb_pipe_ops;
+		pipeline->output[i].channel_ops = kmb_vid_channel_ops;
+
+		snprintf(vnode_name, KMB_MAX_OUTPUT_NAME_LEN,
+			 "isp-output-%d", i);
+		ret = kmb_video_init(&pipeline->output[i], vnode_name,
+				     KMB_VIDEO_YUV_OUTPUT);
+		if (ret < 0)
+			dev_err(kmb_cam->dev, "Fail to init video node\n");
+	}
+
+	pipeline->raw_output.pipe = &pipeline->media_pipe;
+	pipeline->raw_output.ipc_dev_handler = &kmb_cam->ipc_dev_handler;
+	pipeline->raw_output.priv = (void *)pipeline;
+	pipeline->raw_output.dma_dev = kmb_cam->dev;
+	pipeline->raw_output.pipe_ops = kmb_pipe_ops;
+	pipeline->raw_output.channel_ops = kmb_vid_channel_ops;
+
+	ret = kmb_video_init(&pipeline->raw_output, "isp-raw-output",
+			     KMB_VIDEO_RAW_OUTPUT);
+	if (ret < 0)
+		dev_err(kmb_cam->dev, "Fail to init raw output video node\n");
+
+	return ret;
+}
+
+/**
+ * kmb_cam_register_entities - Register entities
+ * @kmb_cam: pointer to kmb camera device
+ * @pipeline: pointer to kmb_cam_pipeline
+ *
+ * Return: 0 if successful
+ */
+static int kmb_cam_register_entities(struct kmb_camera *kmb_cam,
+				     struct kmb_cam_pipeline *pipeline)
+{
+	int i, j;
+	int ret;
+
+	ret = kmb_isp_register_entities(&pipeline->isp, &kmb_cam->v4l2_dev);
+	if (ret < 0) {
+		dev_err(kmb_cam->dev, "Fail to register kmb isp entity\n");
+		goto error;
+	}
+
+	ret = kmb_video_register(&pipeline->raw_input, &kmb_cam->v4l2_dev);
+	if (ret < 0) {
+		dev_err(kmb_cam->dev, "Fail to register kmb raw input node\n");
+		goto error_unregister_isp_entities;
+	}
+
+	for (i = 0; i < KMB_MAX_OUTPUT_COUNT; i++) {
+		ret = kmb_video_register(&pipeline->output[i],
+					 &kmb_cam->v4l2_dev);
+		if (ret < 0) {
+			dev_err(kmb_cam->dev,
+				"Fail to register kmb video node %d\n", i);
+			goto error_unregister_output_entities;
+		}
+	}
+
+	ret = kmb_video_register(&pipeline->raw_output, &kmb_cam->v4l2_dev);
+	if (ret < 0) {
+		dev_err(kmb_cam->dev, "Fail to register kmb raw output node\n");
+		goto error_unregister_output_entities;
+	}
+
+	return 0;
+
+error_unregister_output_entities:
+	for (j = 0; j < i; j++)
+		kmb_video_unregister(&pipeline->output[i]);
+
+	kmb_video_unregister(&pipeline->raw_input);
+error_unregister_isp_entities:
+	kmb_isp_unregister_entities(&pipeline->isp);
+error:
+	return ret;
+}
+
+/**
+ * kmb_cam_unregister_entities - Unregister pipeline entities
+ * @pipeline: pointer to kmb_cam_pipeline
+ *
+ * Return: none
+ */
+static void kmb_cam_unregister_entities(struct kmb_cam_pipeline *pipeline)
+{
+	int i;
+
+	kmb_video_unregister(&pipeline->raw_input);
+	for (i = 0; i < KMB_MAX_OUTPUT_COUNT; i++)
+		kmb_video_unregister(&pipeline->output[i]);
+	kmb_video_unregister(&pipeline->raw_output);
+	kmb_isp_unregister_entities(&pipeline->isp);
+	mutex_destroy(&pipeline->lock);
+}
+
+/**
+ * kmb_cam_create_links - Create pad links connecting sub-devices
+ * @kmb_cam: pointer to kmb camera device
+ * @pipeline: pointer to kmb_cam_pipeline
+ *
+ * Return: 0 if successful
+ */
+static int kmb_cam_create_links(struct kmb_camera *kmb_cam,
+				struct kmb_cam_pipeline *pipeline)
+{
+	int i, j;
+	int ret;
+
+	ret = media_create_pad_link(
+			&pipeline->sensor->entity, 0,
+			&pipeline->isp.subdev.entity, KMB_ISP_SINK_PAD_SENSOR,
+			MEDIA_LNK_FL_IMMUTABLE | MEDIA_LNK_FL_ENABLED);
+	if (ret < 0) {
+		dev_err(kmb_cam->dev, "Fail to link %s->%s entities\n",
+				pipeline->sensor->entity.name,
+				pipeline->isp.subdev.entity.name);
+		return ret;
+	}
+
+	ret = media_create_pad_link(
+			&pipeline->raw_input.video->entity, 0,
+			&pipeline->isp.subdev.entity, KMB_ISP_SINK_PAD_RAW,
+			MEDIA_LNK_FL_IMMUTABLE | MEDIA_LNK_FL_ENABLED);
+	if (ret < 0) {
+		dev_err(kmb_cam->dev, "Fail to link %s->%s entities\n",
+				pipeline->raw_input.video->entity.name,
+				pipeline->isp.subdev.entity.name);
+		goto error_remove_sensor_links;
+	}
+
+	for (i = 0; i < KMB_MAX_OUTPUT_COUNT; i++) {
+		ret = media_create_pad_link(
+				&pipeline->isp.subdev.entity,
+				KMB_ISP_SRC_PAD_VID_BASE + i,
+				&pipeline->output[i].video->entity, 0,
+				MEDIA_LNK_FL_IMMUTABLE | MEDIA_LNK_FL_ENABLED);
+		if (ret < 0) {
+			dev_err(kmb_cam->dev, "Fail to link %s->%s entities\n",
+				pipeline->isp.subdev.entity.name,
+				pipeline->output[i].video->entity.name);
+			goto error_remove_video_links;
+		}
+	}
+
+	ret = media_create_pad_link(
+			&pipeline->isp.subdev.entity, KMB_ISP_SRC_PAD_RAW,
+			&pipeline->raw_output.video->entity, 0,
+			MEDIA_LNK_FL_IMMUTABLE | MEDIA_LNK_FL_ENABLED);
+	if (ret < 0) {
+		dev_err(kmb_cam->dev, "Fail to link %s->%s entities\n",
+				pipeline->isp.subdev.entity.name,
+				pipeline->raw_output.video->entity.name);
+		goto error_remove_video_links;
+	}
+
+	return 0;
+
+error_remove_video_links:
+	for (j = 0; j < i; j++)
+		media_entity_remove_links(&pipeline->output[j].video->entity);
+
+	media_entity_remove_links(&pipeline->raw_input.video->entity);
+error_remove_sensor_links:
+	media_entity_remove_links(&pipeline->sensor->entity);
+	return ret;
+}
+
+/**
+ * kmb_cam_parse_mipi_config - Parse mipi csi2 configuration from device tree
+ * @kmb_cam: pointer to kmb camera device
+ * @fwnode: kmb camera port fwnode handle
+ * @remote: fwnode handle of the remote port
+ * @idx: index of the current port
+ *
+ * Return: 0 if successful
+ */
+static inline int kmb_cam_parse_mipi_config(struct kmb_camera *kmb_cam,
+					    struct fwnode_handle *fwnode,
+					    struct fwnode_handle *remote,
+					    int idx)
+{
+	struct v4l2_fwnode_endpoint ep_data;
+	u32 val = 0;
+	int ret;
+
+	memset(&ep_data, 0, sizeof(ep_data));
+	ep_data.bus_type = V4L2_MBUS_CSI2_DPHY;
+	ret = v4l2_fwnode_endpoint_parse(fwnode, &ep_data);
+	if (ret) {
+		dev_err(kmb_cam->dev, "No endpoint to parse in this fwnode\n");
+		return -ENOENT;
+	}
+
+	kmb_cam->ep_data[idx].ep_data = ep_data;
+	kmb_cam->ep_data[idx].remote = remote;
+
+	dev_dbg(kmb_cam->dev, "num_data_lanes %d\n",
+			ep_data.bus.mipi_csi2.num_data_lanes);
+
+	ret = fwnode_property_read_u32(fwnode, "reg", &val);
+	if (ret) {
+		dev_err(kmb_cam->dev, "Could not match reg %d", ret);
+		return ret;
+	}
+
+	kmb_cam->ep_data[idx].controller_num = val;
+
+	dev_dbg(kmb_cam->dev, "mipi controller %u\n", val);
+
+	return 0;
+}
+
+/**
+ * kmb_cam_bound - Bound
+ * @n: pointer to V4L2 asynchronous notifier
+ * @sd: pointer to V4L2 subdevice
+ * @asd: pointer to V4L2 async subdevice
+ *
+ * This function is called when a subdevice driver has successfully probed one
+ * of the subdevices.
+ *
+ * Return: 0 if successful
+ */
+static int kmb_cam_bound(struct v4l2_async_notifier *n,
+			 struct v4l2_subdev *sd,
+			 struct v4l2_async_subdev *asd)
+{
+	struct v4l2_device *v4l2_dev = n->v4l2_dev;
+	struct kmb_camera *kmb_cam =
+			container_of(v4l2_dev, struct kmb_camera, v4l2_dev);
+	struct kmb_cam_pipeline *pipeline;
+	int ret;
+
+	if (kmb_cam->idx >= (int)(ARRAY_SIZE(kmb_cam->pipeline) - 1)) {
+		dev_info(kmb_cam->dev,
+				"Reached max pipeline count. Skip Sensor!");
+		return 0;
+	}
+
+	pipeline = &kmb_cam->pipeline[++kmb_cam->idx];
+
+	kmb_cam_init_pipe(kmb_cam, pipeline);
+	pipeline->sensor = sd;
+
+	/* register isp, eeprom and video nodes for each sensor */
+	kmb_cam_init_subdevices(kmb_cam, pipeline);
+
+	ret = kmb_cam_register_entities(kmb_cam, pipeline);
+	if (ret < 0) {
+		dev_err(kmb_cam->dev, "Fail to register kmb entities: %d\n",
+				ret);
+		goto error_unregister_subdevs;
+	}
+
+	ret = kmb_cam_create_links(kmb_cam, pipeline);
+	if (ret < 0) {
+		dev_err(kmb_cam->dev, "Fail to create links: %d\n", ret);
+		goto error_remove_links;
+	}
+
+	pipeline->rt_pipe.pipe_instance_id = kmb_cam->idx;
+
+	return 0;
+
+error_remove_links:
+	media_entity_remove_links(&pipeline->sensor->entity);
+	media_entity_remove_links(&pipeline->isp.subdev.entity);
+error_unregister_subdevs:
+	kmb_cam_unregister_entities(pipeline);
+	kmb_cam->idx--;
+	return ret;
+}
+/**
+ * kmb_cam_complete - Complete
+ * @n: pointer to V4L2 asynchronous notifier
+ *
+ * This function is called when all sub-devices have been probed successfully.
+ *
+ * Return: 0 if successful
+ */
+static int kmb_cam_complete(struct v4l2_async_notifier *n)
+{
+	int ret;
+
+	ret = v4l2_device_register_subdev_nodes(n->v4l2_dev);
+	if (ret < 0) {
+		ret = -ENOENT;
+		pr_err("Failed to register subdevs to media v4l2 device");
+	}
+
+	return ret;
+}
+
+static const struct v4l2_async_notifier_operations notifier_ops = {
+	.bound = kmb_cam_bound,
+	.complete = kmb_cam_complete
+};
+
+/**
+ * kmb_cam_parse_nodes - Parse nodes
+ * @kmb_cam: pointer to kmb camera device
+ *
+ * Return: 0 if successful
+ */
+static int kmb_cam_parse_nodes(struct kmb_camera *kmb_cam)
+{
+	struct fwnode_handle *remote;
+	struct fwnode_handle *fwnode = NULL;
+	struct v4l2_async_notifier *n;
+	struct v4l2_async_subdev *a_subdev;
+	struct fwnode_handle *cam_fwnode = dev_fwnode(kmb_cam->dev);
+	int ret = 0;
+
+	fwnode = fwnode_graph_get_next_endpoint(cam_fwnode, fwnode);
+	while (fwnode) {
+		if (kmb_cam->num_notifiers == KMB_MAX_SENSOR_COUNT) {
+			dev_err(kmb_cam->dev, "Max notifiers count reached!!!");
+			break;
+		}
+
+		n = &kmb_cam->v4l2_notifier[kmb_cam->num_notifiers];
+		v4l2_async_notifier_init(n);
+		remote = fwnode_graph_get_remote_port_parent(fwnode);
+		a_subdev = v4l2_async_notifier_add_fwnode_subdev(
+				n, remote,
+				sizeof(struct v4l2_async_subdev));
+		if (IS_ERR(a_subdev))
+			return PTR_ERR(a_subdev);
+
+		ret = kmb_cam_parse_mipi_config(kmb_cam, fwnode, remote,
+						kmb_cam->num_notifiers);
+		if (ret < 0)
+			return ret;
+
+		n->ops = &notifier_ops;
+		ret = v4l2_async_notifier_register(&kmb_cam->v4l2_dev, n);
+		if (ret != 0)
+			dev_err(kmb_cam->dev,
+				"Could not register notifier! %d", ret);
+		else
+			kmb_cam->num_notifiers++;
+
+		fwnode = fwnode_graph_get_next_endpoint(cam_fwnode, fwnode);
+	}
+
+	return ret;
+}
+
+/**
+ * kmb_cam_probe - Platform device binding
+ * @pdev: pointer to platform device
+ *
+ * Return: 0 if successful,
+ *         -ENOMEM if there is not enough memory
+ *         -EPROBE_DEFER on probe retry
+ */
+static int kmb_cam_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct v4l2_device *v4l2_dev;
+	struct kmb_camera *kmb_cam;
+	int ret;
+
+	dev_dbg(&pdev->dev, "%s: Probe KMB media\n", __func__);
+
+	kmb_cam = devm_kzalloc(dev, sizeof(*kmb_cam), GFP_KERNEL);
+	if (!kmb_cam)
+		return -ENOMEM;
+
+	kmb_cam->dev = dev;
+
+	strlcpy(kmb_cam->media_dev.model, "KMB Camera Media device",
+			sizeof(kmb_cam->media_dev.model));
+	kmb_cam->media_dev.dev = dev;
+	kmb_cam->media_dev.hw_revision = 0;
+	media_device_init(&kmb_cam->media_dev);
+
+	v4l2_dev = &kmb_cam->v4l2_dev;
+	v4l2_dev->mdev = &kmb_cam->media_dev;
+	strlcpy(v4l2_dev->name, "kmb-camera-media", sizeof(v4l2_dev->name));
+
+	ret = v4l2_device_register(dev, &kmb_cam->v4l2_dev);
+	if (ret < 0) {
+		v4l2_err(v4l2_dev, "Fail to register v4l2_device: %d\n", ret);
+		return ret;
+	}
+
+	ret = of_reserved_mem_device_init(dev);
+	if (ret)
+		dev_info(dev, "Default CMA memory region will be used!\n");
+
+	/* xlink channel ID allocator */
+	ida_init(&kmb_cam->id_alloc);
+
+	/* Connect to the device before opening channels */
+	memset(&kmb_cam->ipc_dev_handler, 0, sizeof(kmb_cam->ipc_dev_handler));
+	kmb_cam->ipc_dev_handler.dev_type = VPUIP_DEVICE;
+	ret = xlink_connect(&kmb_cam->ipc_dev_handler);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to connect: %d\n", ret);
+		goto error_v4l2_dev_unregister;
+	}
+	dev_dbg(&pdev->dev, "Connected to Xlink\n");
+
+	ret = kmb_cam_init_control_channel(kmb_cam);
+	if (ret < 0)
+		goto error_disconnect_xlink;
+
+	kmb_cam->idx = -1;
+	kmb_cam->num_notifiers = 0;
+	ret = kmb_cam_parse_nodes(kmb_cam);
+	if (ret < 0) {
+		v4l2_err(v4l2_dev, "Fail to parse nodes: %d\n", ret);
+		goto error_destroy_control_channel;
+	}
+
+	platform_set_drvdata(pdev, kmb_cam);
+
+	ret = media_device_register(&kmb_cam->media_dev);
+	if (ret < 0) {
+		dev_err(kmb_cam->dev, "Fail to register media device: %d\n",
+				ret);
+		goto error_destroy_control_channel;
+	}
+
+	return 0;
+
+error_destroy_control_channel:
+	kmb_cam_destroy_control_channel(kmb_cam);
+error_disconnect_xlink:
+	xlink_disconnect(&kmb_cam->ipc_dev_handler);
+error_v4l2_dev_unregister:
+	ida_destroy(&kmb_cam->id_alloc);
+	v4l2_device_unregister(&kmb_cam->v4l2_dev);
+	return ret;
+}
+
+/**
+ * kmb_cam_remove - Platform device unbinding
+ * @pdev: pointer to platform device
+ *
+ * Return: 0 if successful
+ */
+static int kmb_cam_remove(struct platform_device *pdev)
+{
+	struct kmb_camera *kmb_cam = platform_get_drvdata(pdev);
+	int ret;
+	int i;
+
+	dev_dbg(&pdev->dev, "%s: Remove KMB media\n", __func__);
+
+	kmb_cam_destroy_control_channel(kmb_cam);
+
+	/* Disconnect from the device after closing channels */
+	ret = xlink_disconnect(&kmb_cam->ipc_dev_handler);
+	if (ret) {
+		dev_err(&pdev->dev,
+			"Failed to disconnect: %d\n", ret);
+	}
+	dev_dbg(&pdev->dev, "Disconnected from Xlink\n");
+
+	for (i = 0; i < kmb_cam->num_notifiers; i++)
+		v4l2_async_notifier_unregister(&kmb_cam->v4l2_notifier[i]);
+
+	for (i = 0; i <= kmb_cam->idx; i++)
+		kmb_cam_unregister_entities(&kmb_cam->pipeline[i]);
+
+	kmb_cam->idx = -1;
+	kmb_cam->num_notifiers = 0;
+	ida_destroy(&kmb_cam->id_alloc);
+
+	media_device_unregister(&kmb_cam->media_dev);
+	media_device_cleanup(&kmb_cam->media_dev);
+	v4l2_device_unregister(&kmb_cam->v4l2_dev);
+
+	return 0;
+}
+
+static const struct of_device_id kmb_cam_dt_match[] = {
+	{.compatible = "intel,kmb-camera"},
+	{}
+};
+MODULE_DEVICE_TABLE(of, kmb_cam_dt_match);
+
+static struct platform_driver kmb_cam_drv = {
+	.probe	= kmb_cam_probe,
+	.remove = kmb_cam_remove,
+	.driver = {
+		.name = "kmb-camera",
+		.owner = THIS_MODULE,
+		.of_match_table = kmb_cam_dt_match,
+	}
+};
+
+module_platform_driver(kmb_cam_drv);
+
+MODULE_DESCRIPTION("KeemBay Camera V4L2 media device");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/platform/kmb-camera/kmb-camera.h b/drivers/media/platform/kmb-camera/kmb-camera.h
new file mode 100644
index 000000000000..bd22e74eb293
--- /dev/null
+++ b/drivers/media/platform/kmb-camera/kmb-camera.h
@@ -0,0 +1,143 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * kmb-camera.h - KeemBay Camera Driver.
+ *
+ * Copyright (C) 2018-2019 Intel Corporation
+ */
+#ifndef KMB_MEDIA_H
+#define KMB_MEDIA_H
+
+#include <linux/xlink.h>
+#include <media/v4l2-device.h>
+
+#include "kmb-lrt-pipe.h"
+#include "kmb-video.h"
+#include "kmb-isp.h"
+
+#define KMB_MAX_SENSOR_COUNT	10
+#define KMB_MAX_OUTPUT_COUNT	6
+#define KMB_MAX_OUTPUT_NAME_LEN	16
+
+/**
+ * struct kmb_cam_dma_mem - KMB Camera DMA memory pool
+ * @size: memory block size
+ * @phy_addr: memory block physical address
+ * @vaddr: memory block virtual address
+ * @dev: memory block owner
+ */
+struct kmb_cam_dma_mem {
+	u32 size;
+	dma_addr_t phy_addr;
+	void *vaddr;
+	struct device *dev;
+};
+
+/**
+ * struct kmb_cam_ctrl_channel - KMB Camera xlink control channel
+ * @lock: Serialize access to control channel
+ * @refcnt: Control channel reference count
+ * @ipc_dev_handler: xLink IPC device handler
+ * @cma_phy_addr: control channel physical CMA address
+ * @cma_vaddr: control channel virtual CMA address
+ */
+struct kmb_cam_ctrl_channel {
+	struct mutex lock;
+	unsigned int refcnt;
+	struct xlink_handle *ipc_dev_handler;
+	u32 cma_phy_addr;
+	void *cma_vaddr;
+};
+
+/**
+ * struct kmb_cam_rt_pipeline - RT pipeline data
+ * @pipe_instance_id: rt pipeline id
+ * @raw_channel_id: raw channel id
+ * @video_channel_id: array of video channel ids
+ * @isp_channel_id: isp channel id
+ * @id_alloc: pointer to id allocator
+ * @pipe_cfg: rt pipeline configuration
+ * @ctrl_chan: Pointer to camera control channel
+ * @work_mem: RT work memory pool
+ */
+struct kmb_cam_rt_pipeline {
+	u32 pipe_instance_id;
+	u32 raw_channel_id;
+	u32 video_channel_id[KMB_MAX_OUTPUT_COUNT];
+	u32 isp_channel_id;
+	struct ida *id_alloc;
+	struct pipeConfigEvS pipe_cfg;
+	struct kmb_cam_ctrl_channel *ctrl_chan;
+	struct kmb_cam_dma_mem work_mem;
+};
+
+/**
+ * struct kmb_cam_pipeline - KMB camera sub-device set
+ * @lock: serialize pipeline calls
+ * @sensor: pointer to V4L2 sensor sub-device
+ * @isp: KMB ISP sub-device
+ * @output: KMB output video nodes array
+ * @raw_input: KMB raw input video node
+ * @raw_output: KMB raw output video node
+ * @media_pipe: Media pipeline
+ * @rt_pipe: RT pipeline
+ * @config_refcnt: configure stream reference count
+ * @streaming_refcnt: set stream reference count
+ * @built_refcnt: pipeline built reference count
+ */
+struct kmb_cam_pipeline {
+	struct mutex lock;
+	struct v4l2_subdev *sensor;
+	struct kmb_isp isp;
+	struct kmb_video output[KMB_MAX_OUTPUT_COUNT];
+	struct kmb_video raw_input;
+	struct kmb_video raw_output;
+	struct media_pipeline media_pipe;
+	struct kmb_cam_rt_pipeline rt_pipe;
+	unsigned int config_refcnt;
+	unsigned int streaming_refcnt;
+	unsigned int built_refcnt;
+};
+
+/**
+ * struct kmb_cam_endpoint_data - KMB Camera configuration data
+ * @remote: pointer to remote fwnode handle(sensor fwnode)
+ * @ep_data: parsed endpoint data
+ * @controller_num: mipi controller number
+ */
+struct kmb_cam_endpoint_data {
+	struct fwnode_handle *remote;
+	struct v4l2_fwnode_endpoint ep_data;
+	u32 controller_num;
+};
+
+/**
+ * struct kmb_camera - KMB Camera media device structure
+ * @dev: pointer to basic device structure
+ * @media_dev: media device
+ * @v4l2_dev: V4L2 sub-device
+ * @v4l2_notifier: array of V4L2 async notifiers
+ * @num_notifiers: number of registered notifiers
+ * @pipeline: array of camera sub-devices and pipelines associated with them
+ * @ep_data: array of endpoint configuration data
+ * @id_alloc: xLink channel ID allocator
+ * @idx: current max camera index
+ * @ipc_dev_handler: xLink IPC device handler
+ * @ctrl_channel: camera control channel
+ */
+struct kmb_camera {
+	struct device *dev;
+	struct media_device media_dev;
+	struct v4l2_device v4l2_dev;
+	struct v4l2_async_notifier v4l2_notifier[KMB_MAX_SENSOR_COUNT];
+	int num_notifiers;
+
+	struct kmb_cam_pipeline pipeline[KMB_MAX_SENSOR_COUNT];
+	struct kmb_cam_endpoint_data ep_data[KMB_MAX_SENSOR_COUNT];
+	struct ida id_alloc;
+	int idx;
+
+	struct xlink_handle ipc_dev_handler;
+	struct kmb_cam_ctrl_channel ctrl_channel;
+};
+
+#endif /* KMB_MEDIA_H */
diff --git a/drivers/media/platform/kmb-camera/kmb-isp-config.c b/drivers/media/platform/kmb-camera/kmb-isp-config.c
new file mode 100644
index 000000000000..036a12923cc6
--- /dev/null
+++ b/drivers/media/platform/kmb-camera/kmb-isp-config.c
@@ -0,0 +1,541 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * kmb-isp-config.c - KeemBay Camera ISP Configuration Video Node Driver.
+ *
+ * Copyright (C) 2019 Intel Corporation
+ */
+#include <media/v4l2-device.h>
+#include <media/v4l2-ioctl.h>
+#include <media/videobuf2-dma-contig.h>
+
+#include "kmb-isp-config.h"
+
+#define KMB_ISP_CONFIG_NAME "kmb-camera-isp-config"
+
+/**
+ * kmb_isp_config_queue_setup - Setup queue
+ * @q: pointer to video buffer queue
+ * @num_buffers: pointer to number of buffers
+ * @num_planes: pointer to number of planes
+ * @sizes: array of image sizes
+ * @alloc_devs: pointer to array of devices
+ *
+ * Return: 0 if successful
+ */
+static int kmb_isp_config_queue_setup(struct vb2_queue *q,
+		unsigned int *num_buffers, unsigned int *num_planes,
+		unsigned int sizes[], struct device *alloc_devs[])
+{
+	struct kmb_isp_cfg_fh *cfg_fh = vb2_get_drv_priv(q);
+
+	*num_planes = 1;
+	sizes[0] = cfg_fh->data_size;
+	return 0;
+}
+
+/**
+ * kmb_isp_config_buffer_prepare - Buffer prepare
+ * @vb: pointer to video buffer
+ *
+ * Called every time the buffer is queued perform to initialization required
+ * before each hardware operation
+ *
+ * Return: 0 if successful
+ */
+static int kmb_isp_config_buffer_prepare(struct vb2_buffer *vb)
+{
+	struct kmb_isp_cfg_fh *cfg_fh = vb2_get_drv_priv(vb->vb2_queue);
+
+	vb2_set_plane_payload(vb, 0, cfg_fh->data_size);
+	return 0;
+}
+
+/**
+ * kmb_isp_config_buf_init - Buffer initialize
+ * @vb: pointer to video buffer
+ *
+ * Called once after allocating a buffer for additional buffer-related
+ * initialization
+ *
+ * Return: 0 if successful
+ */
+static int kmb_isp_config_buf_init(struct vb2_buffer *vb)
+{
+	return 0;
+}
+
+/**
+ * kmb_isp_config_buf_queue - Pass buffer vb to the driver
+ * @vb: pointer to video buffer
+ */
+static void kmb_isp_config_buf_queue(struct vb2_buffer *vb)
+{
+	int ret;
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
+	struct kmb_isp_cfg_data *buf = (struct kmb_isp_cfg_data *)vbuf;
+	struct kmb_isp_cfg_fh *cfg_fh = vb2_get_drv_priv(vb->vb2_queue);
+	struct kmb_isp_config *kmb_cfg = cfg_fh->kmb_cfg;
+
+	buf->addr = vb2_dma_contig_plane_dma_addr(vb, 0);
+
+	ret = kmb_cfg->queue_ops.queue(kmb_cfg->priv, buf);
+	if (ret) {
+		dev_err(&kmb_cfg->video_out->dev,
+				"Fail isp configuration queue ret %d\n", ret);
+		kmb_cfg->queue_ops.flush(kmb_cfg->priv);
+		return;
+	}
+}
+
+/**
+ * kmb_isp_config_start_streaming - Set streaming state to enable
+ * @q: pointer to videobuf queue
+ * @count: (unused)number of buffers owned by the driver
+ *
+ * Return: 0 if successful, -EPIPE - broken pipe
+ */
+static int kmb_isp_config_start_streaming(struct vb2_queue *q,
+		unsigned int count)
+{
+	return 0;
+}
+
+/**
+ * kmb_isp_config_stop_streaming - Set streaming state to disable
+ * @q: pointer to videobuf queue
+ */
+static void kmb_isp_config_stop_streaming(struct vb2_queue *q)
+{
+	struct kmb_isp_cfg_fh *cfg_fh = vb2_get_drv_priv(q);
+	struct kmb_isp_config *kmb_cfg = cfg_fh->kmb_cfg;
+
+	kmb_cfg->queue_ops.flush(kmb_cfg->priv);
+}
+
+/* driver-specific operations */
+static struct vb2_ops kmb_video_vb2_q_ops = {
+	.queue_setup     = kmb_isp_config_queue_setup,
+	.buf_prepare     = kmb_isp_config_buffer_prepare,
+	.buf_init        = kmb_isp_config_buf_init,
+	.buf_queue       = kmb_isp_config_buf_queue,
+	.start_streaming = kmb_isp_config_start_streaming,
+	.stop_streaming  = kmb_isp_config_stop_streaming,
+};
+
+/**
+ * kmb_isp_config_querycap - Query device capabilities
+ * @file: pointer to file containing video device data
+ * @fh: pointer to V4L2 sub-device file handle
+ * @cap: pointer to V4L2 device capabilities structure
+ *
+ * VIDIOC_QUERYCAP ioctl handler
+ *
+ * Return: 0 if successful
+ */
+static int kmb_isp_config_querycap(struct file *file,
+	void *fh, struct v4l2_capability *cap)
+{
+	struct kmb_isp_cfg_fh *cfg_fh =
+			container_of(fh, struct kmb_isp_cfg_fh, fh);
+	cap->bus_info[0] = 0;
+	strlcpy(cap->driver, KMB_ISP_CONFIG_NAME, sizeof(cap->driver));
+	strlcpy(cap->card, KMB_ISP_CONFIG_NAME, sizeof(cap->card));
+	cap->capabilities = cfg_fh->fh.vdev->device_caps |
+			    V4L2_CAP_DEVICE_CAPS;
+	cap->device_caps = cfg_fh->fh.vdev->device_caps;
+
+	return 0;
+}
+
+/**
+ * kmb_isp_config_get_fmt - Get format for video capture in multiple plain mode
+ * @file: pointer to file containing video device data
+ * @fh: pointer to V4L2 sub-device file handle
+ * @f: pointer to stream data format
+ *
+ * VIDIOC_G_FMT ioctl handler
+ *
+ * Return: 0 if successful
+ */
+static int kmb_isp_config_get_fmt(struct file *file,
+		void *fh, struct v4l2_format *f)
+{
+	struct kmb_isp_cfg_fh *cfg_fh =
+			container_of(fh, struct kmb_isp_cfg_fh, fh);
+
+	if (f->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)
+		return -EINVAL;
+
+	f->fmt.pix.width = cfg_fh->data_size;
+	f->fmt.pix.height = 1;
+	f->fmt.pix.pixelformat = V4L2_PIX_FMT_GREY;
+	f->fmt.pix.field = V4L2_FIELD_NONE;
+	f->fmt.pix.bytesperline = f->fmt.pix.width;
+	f->fmt.pix.sizeimage = f->fmt.pix.bytesperline * f->fmt.pix.height;
+	f->fmt.pix.colorspace = V4L2_COLORSPACE_RAW;
+
+	return 0;
+}
+
+/**
+ * kmb_isp_config_set_fmt - Set format for video capture in multiple plain mode
+ * @file: pointer to file containing video device data
+ * @fh: pointer to V4L2 sub-device file handle
+ * @f: pointer to stream data format
+ *
+ * VIDIOC_S_FMT ioctl handler
+ *
+ * Return: 0 if successful
+ */
+static int kmb_isp_config_set_fmt(struct file *file,
+	void *fh, struct v4l2_format *f)
+{
+	struct kmb_isp_cfg_fh *cfg_fh =
+			container_of(fh, struct kmb_isp_cfg_fh, fh);
+
+	if (f->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)
+		return -EINVAL;
+
+	f->fmt.pix.bytesperline = f->fmt.pix.width;
+	f->fmt.pix.sizeimage = f->fmt.pix.bytesperline * f->fmt.pix.height;
+	cfg_fh->data_size = f->fmt.pix.sizeimage;
+
+	return 0;
+}
+
+/**
+ * kmb_isp_config_reqbufs - Initiate memory mapped or user pointer I/O
+ * @file: pointer to file containing video device data
+ * @fh: pointer to V4L2 sub-device file handle
+ * @req: pointer to request buffers structure
+ *
+ * VIDIOC_REQBUFS ioctl handler
+ *
+ * Return: 0 if successful
+ */
+static int kmb_isp_config_reqbufs(struct file *file,
+	void *fh, struct v4l2_requestbuffers *req)
+{
+	struct kmb_isp_cfg_fh *cfg_fh =
+			container_of(fh, struct kmb_isp_cfg_fh, fh);
+
+	return vb2_reqbufs(&cfg_fh->vb2_q, req);
+}
+
+/**
+ * kmb_isp_config_query_buf - Query the status of a buffer
+ * @file: pointer to file containing video device data
+ * @fh: pointer to V4L2 sub-device file handle
+ * @pb: pointer to video buffer information
+ *
+ * VIDIOC_QUERYBUF ioctl handler
+ *
+ * Return: 0 if successful
+ */
+static int kmb_isp_config_query_buf(struct file *file, void *fh,
+		struct v4l2_buffer *pb)
+{
+	struct kmb_isp_cfg_fh *cfg_fh =
+			container_of(fh, struct kmb_isp_cfg_fh, fh);
+
+	return vb2_querybuf(&cfg_fh->vb2_q, pb);
+}
+
+/**
+ * kmb_isp_config_qbuf - Queue buffer
+ * @file: pointer to file containing video device data
+ * @fh: pointer to V4L2 sub-device file handle
+ * @pb: pointer to video buffer information
+ *
+ * VIDIOC_QBUF ioctl handler. Enqueue an empty (capturing) or filled (output)
+ * buffer in the driver's incoming queue.
+ *
+ * Return: 0 if successful
+ */
+static int kmb_isp_config_qbuf(struct file *file, void *fh,
+	struct v4l2_buffer *pb)
+{
+	struct kmb_isp_cfg_fh *cfg_fh =
+			container_of(fh, struct kmb_isp_cfg_fh, fh);
+	struct media_device *mdev = cfg_fh->fh.vdev->v4l2_dev->mdev;
+
+	return vb2_qbuf(&cfg_fh->vb2_q, mdev, pb);
+}
+
+/**
+ * kmb_video_dqbuf - Dequeue a filled buffer from the driver's outgoing queue
+ * @file: pointer to file containing video device data
+ * @fh: pointer to V4L2 sub-device file handle
+ * @pb: pointer to video buffer information
+ *
+ * VIDIOC_DQBUF ioctl handler
+ *
+ * Return: 0 if successful
+ */
+static int kmb_isp_config_dqbuf(struct file *file, void *fh,
+	struct v4l2_buffer *pb)
+{
+	struct kmb_isp_cfg_fh *cfg_fh =
+			container_of(fh, struct kmb_isp_cfg_fh, fh);
+
+	return vb2_dqbuf(&cfg_fh->vb2_q, pb, file->f_flags & O_NONBLOCK);
+}
+
+/**
+ * kmb_isp_config_streamon - Start streaming
+ * @file: pointer to file containing video device data
+ * @fh: pointer to V4L2 sub-device file handle
+ * @buf_type: V4L2 buffer type
+ *
+ * VIDIOC_STREAMON ioctl handler
+ *
+ * Return: 0 if successful
+ */
+static int kmb_isp_config_streamon(struct file *file,
+	void *fh, enum v4l2_buf_type buf_type)
+{
+	struct kmb_isp_cfg_fh *cfg_fh =
+			container_of(fh, struct kmb_isp_cfg_fh, fh);
+	int ret;
+
+	ret = vb2_streamon(&cfg_fh->vb2_q, buf_type);
+	if (ret < 0) {
+		dev_err(&cfg_fh->fh.vdev->dev,
+			"Stream ON failed! ret = %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+/**
+ * kmb_isp_config_streamoff - Stop streaming
+ * @file: pointer to file containing video device data
+ * @fh: pointer to V4L2 sub-device file handle
+ * @buf_type: V4L2 buffer type
+ *
+ * VIDIOC_STREAMOFF ioctl handler
+ *
+ * Return: 0 if successful
+ */
+static int kmb_isp_config_streamoff(struct file *file,
+	void *fh, enum v4l2_buf_type buf_type)
+{
+	struct kmb_isp_cfg_fh *cfg_fh =
+			container_of(fh, struct kmb_isp_cfg_fh, fh);
+
+	return vb2_streamoff(&cfg_fh->vb2_q, buf_type);
+}
+
+/* V4L2 ioctl operations */
+static const struct v4l2_ioctl_ops kmb_vid_ioctl_ops = {
+	.vidioc_querycap      = kmb_isp_config_querycap,
+	.vidioc_g_fmt_vid_out = kmb_isp_config_get_fmt,
+	.vidioc_s_fmt_vid_out = kmb_isp_config_set_fmt,
+	.vidioc_reqbufs       = kmb_isp_config_reqbufs,
+	.vidioc_querybuf      = kmb_isp_config_query_buf,
+	.vidioc_qbuf          = kmb_isp_config_qbuf,
+	.vidioc_dqbuf         = kmb_isp_config_dqbuf,
+	.vidioc_streamon      = kmb_isp_config_streamon,
+	.vidioc_streamoff     = kmb_isp_config_streamoff,
+};
+
+/**
+ * kmb_isp_config_open - Device node open
+ * @file: pointer to file containing video device data
+ *
+ * Return: 0 if successful, -ENOMEM if there is not enough memory
+ */
+static int kmb_isp_config_open(struct file *file)
+{
+	int ret;
+	struct kmb_isp_cfg_fh *cfg_fh;
+	struct kmb_isp_config *kmb_out = video_drvdata(file);
+	struct video_device *output = video_devdata(file);
+
+	cfg_fh = kzalloc(sizeof(*cfg_fh), GFP_KERNEL);
+	if (!cfg_fh)
+		return -ENOMEM;
+
+	mutex_init(&cfg_fh->lock);
+	v4l2_fh_init(&cfg_fh->fh, output);
+
+	file->private_data = &cfg_fh->fh;
+	v4l2_fh_add(&cfg_fh->fh);
+
+	cfg_fh->kmb_cfg = kmb_out;
+	cfg_fh->vb2_q.drv_priv = cfg_fh;
+	cfg_fh->vb2_q.ops = &kmb_video_vb2_q_ops;
+	cfg_fh->vb2_q.buf_struct_size = sizeof(struct kmb_isp_cfg_data);
+
+	cfg_fh->vb2_q.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+	cfg_fh->vb2_q.io_modes = VB2_DMABUF | VB2_MMAP;
+	cfg_fh->vb2_q.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;
+	cfg_fh->vb2_q.mem_ops = &vb2_dma_contig_memops;
+	cfg_fh->vb2_q.dev = kmb_out->dma_dev;
+	cfg_fh->vb2_q.lock = &cfg_fh->lock;
+
+	ret = vb2_queue_init(&cfg_fh->vb2_q);
+	if (ret < 0) {
+		dev_err(&output->dev, "Error vb2 queue init\n");
+		goto error_release_v4l2_fh;
+	}
+
+	/* default size */
+	cfg_fh->data_size = 8192;
+
+	return 0;
+
+error_release_v4l2_fh:
+	v4l2_fh_del(&cfg_fh->fh);
+	v4l2_fh_exit(&cfg_fh->fh);
+	kfree(cfg_fh);
+	return ret;
+}
+
+/**
+ * kmb_isp_config_release - Video device release
+ * @file: pointer to file containing video device data
+ *
+ * Return: 0 if successful
+ */
+static int kmb_isp_config_release(struct file *file)
+{
+	struct kmb_isp_cfg_fh *cfg_fh = container_of(
+			file->private_data, struct kmb_isp_cfg_fh, fh);
+
+	vb2_queue_release(&cfg_fh->vb2_q);
+
+	v4l2_fh_del(&cfg_fh->fh);
+	v4l2_fh_exit(&cfg_fh->fh);
+
+	mutex_destroy(&cfg_fh->lock);
+
+	kfree(cfg_fh);
+	return 0;
+}
+
+/**
+ * kmb_isp_config_poll - Poll
+ * @file: pointer to file containing video device data
+ * @wait: poll table wait
+ *
+ * Return: 0 if successful
+ */
+static unsigned int kmb_isp_config_poll(struct file *file,
+	struct poll_table_struct *wait)
+{
+	struct kmb_isp_cfg_fh *cfg_fh = container_of(
+			file->private_data, struct kmb_isp_cfg_fh, fh);
+
+	return vb2_poll(&cfg_fh->vb2_q, file, wait);
+}
+
+/**
+ * kmb_isp_config_mmap - Memory map
+ * @file: pointer to file containing video device data
+ * @vma: VMM memory area
+ *
+ * Return: 0 if successful
+ */
+static int kmb_isp_config_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct kmb_isp_cfg_fh *cfg_fh = container_of(
+			file->private_data, struct kmb_isp_cfg_fh, fh);
+
+	return vb2_mmap(&cfg_fh->vb2_q, vma);
+}
+
+/* FS operations for V4L2 device */
+static const struct v4l2_file_operations kmb_vid_output_fops = {
+	.owner          = THIS_MODULE,
+	.open           = kmb_isp_config_open,
+	.release        = kmb_isp_config_release,
+	.poll           = kmb_isp_config_poll,
+	.unlocked_ioctl = video_ioctl2,
+	.mmap           = kmb_isp_config_mmap
+};
+
+/**
+ * kmb_video_init - Initialize entity
+ * @kmb_out: pointer to kmb isp config device
+ *
+ * Return: 0 if successful
+ */
+int kmb_isp_config_init(struct kmb_isp_config *kmb_out)
+{
+	int ret;
+
+	kmb_out->video_out = video_device_alloc();
+	if (!kmb_out->video_out) {
+		dev_err(&kmb_out->video_out->dev,
+			"Failed to allocate video device\n");
+		return -ENOMEM;
+	}
+
+	mutex_init(&kmb_out->lock);
+
+	kmb_out->pad.flags = MEDIA_PAD_FL_SOURCE;
+	ret = media_entity_pads_init(
+			&kmb_out->video_out->entity, 1, &kmb_out->pad);
+	if (ret < 0)
+		return ret;
+
+	kmb_out->video_out->device_caps = V4L2_CAP_VIDEO_OUTPUT |
+					  V4L2_CAP_STREAMING;
+	kmb_out->video_out->fops  = &kmb_vid_output_fops;
+	kmb_out->video_out->ioctl_ops = &kmb_vid_ioctl_ops;
+	kmb_out->video_out->minor = -1;
+	kmb_out->video_out->release  = video_device_release;
+	kmb_out->video_out->vfl_type = VFL_TYPE_VIDEO;
+	kmb_out->video_out->vfl_dir = VFL_DIR_TX;
+	kmb_out->video_out->lock = &kmb_out->lock;
+	snprintf(kmb_out->video_out->name, sizeof(kmb_out->video_out->name),
+			KMB_ISP_CONFIG_NAME);
+
+	video_set_drvdata(kmb_out->video_out, kmb_out);
+	return 0;
+}
+
+/**
+ * kmb_isp_config_deinit - Free resources associated with entity
+ * @kmb_out: pointer to kmb isp config device
+ */
+void kmb_isp_config_deinit(struct kmb_isp_config *kmb_out)
+{
+	media_entity_cleanup(&kmb_out->video_out->entity);
+	mutex_destroy(&kmb_out->lock);
+}
+
+/**
+ * kmb_isp_config_register - Register V4L2 device
+ * @kmb_out: pointer to kmb isp config device
+ * @v4l2_dev: pointer to V4L2 device drivers
+ *
+ * Return: 0 if successful
+ */
+int kmb_isp_config_register(struct kmb_isp_config *kmb_out,
+		       struct v4l2_device *v4l2_dev)
+{
+	int ret;
+
+	kmb_out->video_out->v4l2_dev = v4l2_dev;
+	ret = video_register_device(kmb_out->video_out, VFL_TYPE_VIDEO, -1);
+	if (ret < 0) {
+		v4l2_err(v4l2_dev, "Failed to register video device\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+/**
+ * kmb_isp_config_unregister - Unregister V4L device
+ * @kmb_out: pointer to kmb isp config device
+ */
+void kmb_isp_config_unregister(struct kmb_isp_config *kmb_out)
+{
+	kmb_isp_config_deinit(kmb_out);
+	mutex_destroy(&kmb_out->lock);
+	video_unregister_device(kmb_out->video_out);
+}
diff --git a/drivers/media/platform/kmb-camera/kmb-isp-config.h b/drivers/media/platform/kmb-camera/kmb-isp-config.h
new file mode 100644
index 000000000000..51d67cacfb2d
--- /dev/null
+++ b/drivers/media/platform/kmb-camera/kmb-isp-config.h
@@ -0,0 +1,79 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * kmb-isp-config.h - KeemBay Camera ISP Configuration Video Node Driver.
+ *
+ * Copyright (C) 2019 Intel Corporation
+ */
+#ifndef KMB_ISP_CONFIG_VNODE_H
+#define KMB_ISP_CONFIG_VNODE_H
+
+#include <media/v4l2-dev.h>
+#include <media/v4l2-subdev.h>
+#include <media/videobuf2-v4l2.h>
+
+/**
+ * struct kmb_isp_cfg_data - KMB ISP configuration data
+ * @vb: video buffer
+ * @addr: dma buffer address
+ * @isp_cfgs: isp config buffers queue
+ */
+struct kmb_isp_cfg_data {
+	struct vb2_v4l2_buffer vb;
+	dma_addr_t addr;
+	struct list_head isp_cfgs;
+};
+
+/**
+ * struct kmb_isp_cfg_queue_ops - KMB ISP Config queue operations
+ * @queue: queue an ISP config buffer
+ * @flish: discard all ISP config buffers
+ */
+struct kmb_isp_cfg_queue_ops {
+	int (*queue)(void *priv, struct kmb_isp_cfg_data *buf);
+	void (*flush)(void *priv);
+};
+
+/**
+ * struct kmb_isp_config - KMB camera isp config device structure
+ * @lock: mutex
+ * @video_out: pointer to V4L2 video device node
+ * @dma_dev: pointer to dma device
+ * @pad: media pad graph objects
+ * @pipe: pointer to media pipeline
+ * @queue_ops: ISP config buffer queue operations
+ * @priv: pointer to private data
+ */
+struct kmb_isp_config {
+	struct mutex lock;
+	struct video_device *video_out;
+	struct device *dma_dev;
+	struct media_pad pad;
+	struct media_pipeline *pipe;
+	struct kmb_isp_cfg_queue_ops queue_ops;
+	void *priv;
+};
+
+/**
+ * struct kmb_isp_cfg_fh - KMB isp config file handler
+ * @lock: mutex serializing fh operations
+ * @fh: V4L2 file handler
+ * @vb2_q: video buffer queue
+ * @data_size: isp configuration data size
+ * @kmb_cfg: pointer to KMB isp config device
+ */
+struct kmb_isp_cfg_fh {
+	struct mutex lock;
+	struct v4l2_fh fh;
+	struct vb2_queue vb2_q;
+	int data_size;
+	struct kmb_isp_config *kmb_cfg;
+};
+
+int kmb_isp_config_init(struct kmb_isp_config *kmb_cfg);
+void kmb_isp_config_deinit(struct kmb_isp_config *kmb_cfg);
+
+int kmb_isp_config_register(struct kmb_isp_config *kmb_cfg,
+			    struct v4l2_device *v4l2_dev);
+void kmb_isp_config_unregister(struct kmb_isp_config *kmb_cfg);
+
+#endif /* KMB_ISP_CONFIG_VNODE_H */
diff --git a/drivers/media/platform/kmb-camera/kmb-isp.c b/drivers/media/platform/kmb-camera/kmb-isp.c
new file mode 100644
index 000000000000..af046601f7fd
--- /dev/null
+++ b/drivers/media/platform/kmb-camera/kmb-isp.c
@@ -0,0 +1,2192 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * kmb-isp.c - KeemBay Camera ISP Driver.
+ *
+ * Copyright (C) 2018-2019 Intel Corporation
+ */
+#include <linux/kmb-isp-ctl.h>
+#include <linux/kthread.h>
+#include <linux/freezer.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-event.h>
+#include <media/v4l2-ioctl.h>
+
+#include "kmb-isp.h"
+#include "kmb-lrt-cmd.h"
+#include "kmb-lrt-pipe.h"
+
+#define KMB_ISP_MAX_ERR_CNT		5
+#define KMB_RT_ISP_CH_DATA_SIZE		1024
+#define KMB_RT_ISP_CH_TIMEOUT_MS	5000
+#define RT_DATA_CH_ID_ISP		30
+#define KMB_STOP_SOURCE_TIMEOUT_MS	1000
+
+enum kmb_isp_stop_method {
+	KMB_ISP_STOP_SYNC = 0,
+	KMB_ISP_STOP_FORCE = 1,
+};
+
+static const struct kmb_isp_format isp_fmt[] = {
+	{
+		.code = MEDIA_BUS_FMT_SRGGB8_1X8,
+		.bayer_pattern = IC_BAYER_FORMAT_RGGB,
+		.bpp = 8,
+		.rx_data_type = IC_IPIPE_RAW_8,
+	},
+	{
+		.code = MEDIA_BUS_FMT_SGRBG8_1X8,
+		.bayer_pattern = IC_BAYER_FORMAT_GRBG,
+		.bpp = 8,
+		.rx_data_type = IC_IPIPE_RAW_8,
+	},
+	{
+		.code = MEDIA_BUS_FMT_SGBRG8_1X8,
+		.bayer_pattern = IC_BAYER_FORMAT_GBRG,
+		.bpp = 8,
+		.rx_data_type = IC_IPIPE_RAW_8,
+	},
+	{
+		.code = MEDIA_BUS_FMT_SBGGR8_1X8,
+		.bayer_pattern = IC_BAYER_FORMAT_BGGR,
+		.bpp = 8,
+		.rx_data_type = IC_IPIPE_RAW_8,
+	},
+	{
+		.code = MEDIA_BUS_FMT_SRGGB10_1X10,
+		.bayer_pattern = IC_BAYER_FORMAT_RGGB,
+		.bpp = 10,
+		.rx_data_type = IC_IPIPE_RAW_10,
+	},
+	{
+		.code = MEDIA_BUS_FMT_SGRBG10_1X10,
+		.bayer_pattern = IC_BAYER_FORMAT_GRBG,
+		.bpp = 10,
+		.rx_data_type = IC_IPIPE_RAW_10,
+	},
+	{
+		.code = MEDIA_BUS_FMT_SGBRG10_1X10,
+		.bayer_pattern = IC_BAYER_FORMAT_GBRG,
+		.bpp = 10,
+		.rx_data_type = IC_IPIPE_RAW_10,
+	},
+	{
+		.code = MEDIA_BUS_FMT_SBGGR10_1X10,
+		.bayer_pattern = IC_BAYER_FORMAT_BGGR,
+		.bpp = 10,
+		.rx_data_type = IC_IPIPE_RAW_10,
+	},
+	{
+		.code = MEDIA_BUS_FMT_SRGGB12_1X12,
+		.bayer_pattern = IC_BAYER_FORMAT_RGGB,
+		.bpp = 12,
+		.rx_data_type = IC_IPIPE_RAW_12,
+	},
+	{
+		.code = MEDIA_BUS_FMT_SGRBG12_1X12,
+		.bayer_pattern = IC_BAYER_FORMAT_GRBG,
+		.bpp = 12,
+		.rx_data_type = IC_IPIPE_RAW_12,
+	},
+	{
+		.code = MEDIA_BUS_FMT_SGBRG12_1X12,
+		.bayer_pattern = IC_BAYER_FORMAT_GBRG,
+		.bpp = 12,
+		.rx_data_type = IC_IPIPE_RAW_12,
+	},
+	{
+		.code = MEDIA_BUS_FMT_SBGGR12_1X12,
+		.bayer_pattern = IC_BAYER_FORMAT_BGGR,
+		.bpp = 12,
+		.rx_data_type = IC_IPIPE_RAW_12,
+	},
+	{
+		.code = MEDIA_BUS_FMT_YUYV8_1_5X8,
+		.bayer_pattern = IC_BAYER_FORMAT_BGGR,
+		.bpp = 8,
+		.rx_data_type = IC_IPIPE_YUV_420_B8,
+	},
+	{
+		.code = MEDIA_BUS_FMT_UYYVYY8_0_5X24,
+		.bayer_pattern = IC_BAYER_FORMAT_BGGR,
+		.bpp = 8,
+		.rx_data_type = IC_IPIPE_YUV_420_B8,
+	},
+	{
+		.code = MEDIA_BUS_FMT_YUV8_1X24,
+		.bayer_pattern = IC_BAYER_FORMAT_BGGR,
+		.bpp = 8,
+		.rx_data_type = IC_IPIPE_YUV_420_B8,
+	},
+	{
+		.code = MEDIA_BUS_FMT_Y8_1X8,
+		.bayer_pattern = IC_BAYER_FORMAT_BGGR,
+		.bpp = 8,
+		.rx_data_type = IC_IPIPE_RAW_8,
+	},
+	{
+		.code = MEDIA_BUS_FMT_Y10_1X10,
+		.bayer_pattern = IC_BAYER_FORMAT_BGGR,
+		.bpp = 10,
+		.rx_data_type = IC_IPIPE_RAW_10,
+	},
+	{
+		.code = MEDIA_BUS_FMT_VUY8_1X24,
+		.bayer_pattern = IC_BAYER_FORMAT_GRBG,
+		.bpp = 12,
+		.rx_data_type = IC_IPIPE_YUV_420_B8,
+	},
+	{
+		.code = MEDIA_BUS_FMT_YUV10_1X30,
+		.bayer_pattern = IC_BAYER_FORMAT_GRBG,
+		.bpp = 24,
+		.rx_data_type = IC_IPIPE_YUV_420_B10,
+	},
+	{
+		.code = MEDIA_BUS_FMT_YVYU10_1X20,
+		.bayer_pattern = IC_BAYER_FORMAT_GRBG,
+		.bpp = 15,
+		.rx_data_type = IC_IPIPE_YUV_420_B10,
+	},
+	{
+		.code = MEDIA_BUS_FMT_YVYU8_2X8,
+		.bayer_pattern = IC_BAYER_FORMAT_GRBG,
+		.bpp = 12,
+		.rx_data_type = IC_IPIPE_YUV_420_B8_L,
+	},
+	{
+		.code = MEDIA_BUS_FMT_YUYV8_2X8,
+		.bayer_pattern = IC_BAYER_FORMAT_GRBG,
+		.bpp = 12,
+		.rx_data_type = IC_IPIPE_YUV_420_B8_CSPS,
+	},
+	{
+		.code = MEDIA_BUS_FMT_UYVY10_1X20,
+		.bayer_pattern = IC_BAYER_FORMAT_GRBG,
+		.bpp = 24,
+		.rx_data_type = IC_IPIPE_YUV_420_B10_CSPS,
+	},
+	{
+		.code = MEDIA_BUS_FMT_VYUY10_1X20,
+		.bayer_pattern = IC_BAYER_FORMAT_GRBG,
+		.bpp = 15,
+		.rx_data_type = IC_IPIPE_YUV_420_B10_CSPS,
+	},
+	{
+		.code = MEDIA_BUS_FMT_YVYU8_1X16,
+		.bayer_pattern = IC_BAYER_FORMAT_GRBG,
+		.bpp = 16,
+		.rx_data_type = IC_IPIPE_YUV_422_B8,
+	},
+	{
+		.code = MEDIA_BUS_FMT_VYUY10_2X10,
+		.bayer_pattern = IC_BAYER_FORMAT_GRBG,
+		.bpp = 32,
+		.rx_data_type = IC_IPIPE_YUV_422_B10,
+	},
+	{
+		.code = MEDIA_BUS_FMT_YUYV10_2X10,
+		.bayer_pattern = IC_BAYER_FORMAT_GRBG,
+		.bpp = 20,
+		.rx_data_type = IC_IPIPE_YUV_422_B10,
+	},
+};
+
+static const u32 rt_isp_thb[][2] = {
+	{ PIPE_TRANSFORM_HUB_NONE, KMB_CAMERA_TRANSFORM_HUB_NONE },
+	{ PIPE_TRANSFORM_HUB_BASIC, KMB_CAMERA_TRANSFORM_HUB_BASIC },
+	{ PIPE_TRANSFORM_HUB_FULL, KMB_CAMERA_TRANSFORM_HUB_FULL },
+	{ PIPE_TRANSFORM_HUB_STITCH, KMB_CAMERA_TRANSFORM_HUB_STITCHING },
+	{ PIPE_TRANSFORM_HUB_EPTZ, KMB_CAMERA_TRANSFORM_HUB_EPTZ },
+};
+
+static const u32 rt_isp_cam_mode[][2] = {
+	{ PIPE_TYPE_ISP_ISP_ULL, KMB_CAMERA_MODE_ULL },
+	{ PIPE_TYPE_ISP_ISP_2DOL, KMB_CAMERA_MODE_HDR_2DOL },
+	{ PIPE_TYPE_ISP_ISP_3DOL, KMB_CAMERA_MODE_HDR_3DOL },
+	{ PIPE_TYPE_SRC_NO_ISP, KMB_CAMERA_MODE_NO_ISP },
+	{ PIPE_TYPE_ISP_ISP_MONO, KMB_CAMERA_MODE_MONO },
+};
+
+/**
+ * kmb_isp_print_src_cfg - Print source configuration
+ * @src_cfg: LRT source configuration
+ *
+ * Return: none
+ */
+static void kmb_isp_print_src_cfg(icSourceConfig *src_cfg)
+{
+	pr_debug("--SOURCE CONFIGURATION--\n");
+	pr_debug("\tbayerFormat %u\n", src_cfg->bayerFormat);
+	pr_debug("\tbitsPerPixel %u\n", src_cfg->bitsPerPixel);
+	pr_debug("\tcameraOutputSize %ux%u\n",
+		src_cfg->cameraOutputSize.w,
+		src_cfg->cameraOutputSize.h);
+	pr_debug("\tcropWindow x1 %d x2 %d  y1 %d y2 %d\n",
+		src_cfg->cropWindow.x1, src_cfg->cropWindow.x2,
+		src_cfg->cropWindow.y1, src_cfg->cropWindow.y2);
+	pr_debug("\tmipiRxData controllerNo %u dataMode %u\n",
+		src_cfg->mipiRxData.controllerNo,
+		src_cfg->mipiRxData.dataMode);
+	pr_debug("\t\tdataType %u laneRateMbps %u noLanes %u\n",
+		src_cfg->mipiRxData.dataType,
+		src_cfg->mipiRxData.laneRateMbps,
+		src_cfg->mipiRxData.noLanes);
+	pr_debug("\tnoExposure %u\n", src_cfg->noExposure);
+	pr_debug("\tmetadataWidth %u metadataHeight %u metadataDataType %u\n",
+		src_cfg->metadataWidth, src_cfg->metadataHeight,
+		src_cfg->metadataDataType);
+}
+
+/**
+ * kmb_isp_get_pad_format_by_idx - Get ISP pad format by given media pad index
+ * @kmb_isp: pointer to kmb isp device
+ * @idx: media pad index
+ *
+ * Return: pointer to isp pad format
+ */
+static struct v4l2_subdev_format *
+kmb_isp_get_pad_format_by_idx(struct kmb_isp *kmb_isp, u32 idx)
+{
+	if (idx < KMB_ISP_PADS_NUM)
+		return &kmb_isp->pad_format[idx];
+
+	return NULL;
+}
+
+/**
+ * kmb_isp_limit_camera_modes_range - Limit available camera modes based on
+ *                                    sensor capabilities
+ * @kmb_isp: pointer to kmb isp device
+ */
+static void kmb_isp_limit_camera_modes_range(struct kmb_isp *kmb_isp)
+{
+	if (MEDIA_BUS_FMT_Y10_1X10 ==
+	    kmb_isp->pad_fmt_caps[KMB_ISP_SINK_PAD_SENSOR].code[0]) {
+		v4l2_ctrl_modify_range(kmb_isp->ctrls.camera_mode,
+			KMB_CAMERA_MODE_NO_ISP, KMB_CAMERA_MODE_MONO, 1,
+			KMB_CAMERA_MODE_MONO);
+	} else {
+		v4l2_ctrl_modify_range(kmb_isp->ctrls.camera_mode,
+			KMB_CAMERA_MODE_ULL, KMB_CAMERA_MODE_NO_ISP, 1,
+			KMB_CAMERA_MODE_ULL);
+	}
+}
+
+/**
+ * kmb_isp_get_fmt_by_code - Get KeemBay ISP source format
+ * @code: media bus format code
+ *
+ * Return: kmb isp source format or NULL
+ */
+const struct kmb_isp_format *kmb_isp_get_fmt_by_code(u32 code)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(isp_fmt); i++) {
+		if (isp_fmt[i].code == code)
+			return &isp_fmt[i];
+	}
+	return NULL;
+}
+
+/**
+ * kmb_isp_alloc_pipe_cma_area - Allocate CMA area
+ * @kmb_isp: pointer to KMB ISP device
+ *
+ * Allocate continuous memory for data structures used by RT
+ *
+ * Return: 0 if successful
+ */
+static int kmb_isp_alloc_pipe_cma_area(struct kmb_isp *kmb_isp)
+{
+	kmb_isp->cma_vaddr = dma_alloc_coherent(kmb_isp->dev,
+			sizeof(icSourceConfig),
+			(dma_addr_t *)&kmb_isp->cma_phy_addr, 0);
+	if (!kmb_isp->cma_vaddr)
+		return -ENOMEM;
+
+	dev_dbg(kmb_isp->dev, "ISP CHANNEL CMA: phy 0x%x vaddr %p\n",
+			kmb_isp->cma_phy_addr, kmb_isp->cma_vaddr);
+
+	return 0;
+}
+
+/**
+ * kmb_isp_free_pipe_cma_area - Free CMA area
+ * @kmb_isp: pointer to KMB ISP device
+ *
+ * Free continuous memory for data structures used by RT
+ */
+static void kmb_isp_free_pipe_cma_area(struct kmb_isp *kmb_isp)
+{
+	if (kmb_isp->cma_vaddr)
+		dma_free_coherent(kmb_isp->dev, sizeof(icSourceConfig),
+				kmb_isp->cma_vaddr, kmb_isp->cma_phy_addr);
+	kmb_isp->cma_vaddr = NULL;
+}
+
+/**
+ * kmb_isp_reset_pad_formats - Reset ISP pads format
+ * @kmb_isp: pointer to KMB ISP device
+ */
+static void kmb_isp_reset_pad_formats(struct kmb_isp *kmb_isp)
+{
+	memset(kmb_isp->pad_format, 0, sizeof(kmb_isp->pad_format));
+	memset(kmb_isp->pad_fmt_caps, 0, sizeof(kmb_isp->pad_fmt_caps));
+
+	/* For now set input pads to max range */
+	kmb_isp->pad_fmt_caps[KMB_ISP_SINK_PAD_SENSOR].range.max_width =
+			U32_MAX;
+	kmb_isp->pad_fmt_caps[KMB_ISP_SINK_PAD_SENSOR].range.max_height =
+			U32_MAX;
+
+	kmb_isp->pad_fmt_caps[KMB_ISP_SINK_PAD_CFG].range.max_width = U32_MAX;
+	kmb_isp->pad_fmt_caps[KMB_ISP_SINK_PAD_CFG].range.max_height = U32_MAX;
+
+	kmb_isp->pad_fmt_caps[KMB_ISP_SINK_PAD_RAW].range.max_width = U32_MAX;
+	kmb_isp->pad_fmt_caps[KMB_ISP_SINK_PAD_RAW].range.max_height = U32_MAX;
+}
+
+/**
+ * kmb_isp_populate_pad_formats - Populate pad formats based on supported
+ *                                sensor media bus formats
+ * @kmb_isp: pointer to KMB ISP device
+ *
+ * Return: 0 if successful
+ */
+static int kmb_isp_populate_pad_formats(struct kmb_isp *kmb_isp)
+{
+	struct v4l2_subdev_mbus_code_enum mbus;
+	struct media_pad *remote;
+	struct v4l2_subdev *subdev;
+	u32 code[30] = {0};
+	int isp_pad_idx, in_fmt_cnt, out_fmt_cnt;
+	int ret = 0;
+
+	remote = media_entity_remote_pad(
+			&kmb_isp->pads[KMB_ISP_SINK_PAD_SENSOR]);
+	if (remote == NULL)
+		return -ENOENT;
+
+	subdev = media_entity_to_v4l2_subdev(remote->entity);
+	if (subdev == NULL)
+		return -ENOENT;
+
+	in_fmt_cnt = 0;
+	memset(&mbus, 0, sizeof(mbus));
+	mbus.which = V4L2_SUBDEV_FORMAT_ACTIVE;
+	while (!v4l2_subdev_call(subdev, pad, enum_mbus_code,
+					NULL, &mbus)) {
+		switch (mbus.code) {
+		case MEDIA_BUS_FMT_SRGGB8_1X8:
+		case MEDIA_BUS_FMT_SGRBG8_1X8:
+		case MEDIA_BUS_FMT_SGBRG8_1X8:
+		case MEDIA_BUS_FMT_SBGGR8_1X8:
+		case MEDIA_BUS_FMT_SRGGB10_1X10:
+		case MEDIA_BUS_FMT_SGRBG10_1X10:
+		case MEDIA_BUS_FMT_SGBRG10_1X10:
+		case MEDIA_BUS_FMT_SBGGR10_1X10:
+		case MEDIA_BUS_FMT_SRGGB12_1X12:
+		case MEDIA_BUS_FMT_SGRBG12_1X12:
+		case MEDIA_BUS_FMT_SGBRG12_1X12:
+		case MEDIA_BUS_FMT_SBGGR12_1X12:
+			code[in_fmt_cnt++] = MEDIA_BUS_FMT_YUYV8_1_5X8;
+			code[in_fmt_cnt++] = MEDIA_BUS_FMT_UYYVYY8_0_5X24;
+			code[in_fmt_cnt++] = MEDIA_BUS_FMT_YUV8_1X24;
+			break;
+		case MEDIA_BUS_FMT_Y10_1X10:
+			code[in_fmt_cnt++] = MEDIA_BUS_FMT_Y8_1X8;
+			code[in_fmt_cnt++] = MEDIA_BUS_FMT_Y10_1X10;
+			break;
+		case MEDIA_BUS_FMT_VUY8_1X24:
+			code[in_fmt_cnt++] = MEDIA_BUS_FMT_VUY8_1X24;
+			break;
+		case MEDIA_BUS_FMT_YUV10_1X30:
+			code[in_fmt_cnt++] = MEDIA_BUS_FMT_YUV10_1X30;
+			break;
+		case MEDIA_BUS_FMT_YVYU10_1X20:
+			code[in_fmt_cnt++] = MEDIA_BUS_FMT_YVYU10_1X20;
+			break;
+		case MEDIA_BUS_FMT_YVYU8_2X8:
+			code[in_fmt_cnt++] = MEDIA_BUS_FMT_YVYU8_2X8;
+			break;
+		case MEDIA_BUS_FMT_YUYV8_2X8:
+			code[in_fmt_cnt++] = MEDIA_BUS_FMT_YUYV8_2X8;
+			break;
+		case MEDIA_BUS_FMT_UYVY10_1X20:
+			code[in_fmt_cnt++] = MEDIA_BUS_FMT_UYVY10_1X20;
+			break;
+		case MEDIA_BUS_FMT_VYUY10_1X20:
+			code[in_fmt_cnt++] = MEDIA_BUS_FMT_VYUY10_1X20;
+			break;
+		case MEDIA_BUS_FMT_YVYU8_1X16:
+			code[in_fmt_cnt++] = MEDIA_BUS_FMT_YVYU8_1X16;
+			break;
+		case MEDIA_BUS_FMT_VYUY10_2X10:
+			code[in_fmt_cnt++] = MEDIA_BUS_FMT_VYUY10_2X10;
+			break;
+		case MEDIA_BUS_FMT_YUYV10_2X10:
+			code[in_fmt_cnt++] = MEDIA_BUS_FMT_YUYV10_2X10;
+			break;
+		default:
+			dev_err(kmb_isp->dev, "Input format not supported! %d",
+				mbus.code);
+			return -EINVAL;
+			/* fallthrough */
+		}
+
+		kmb_isp->pad_fmt_caps[mbus.pad].code[mbus.index] = mbus.code;
+		kmb_isp->pad_fmt_caps[KMB_ISP_SRC_PAD_RAW].code[mbus.index] =
+				mbus.code;
+		kmb_isp->pad_fmt_caps[KMB_ISP_SINK_PAD_RAW].code[mbus.index] =
+				mbus.code;
+
+		mbus.index++;
+
+		kmb_isp->pad_fmt_caps[mbus.pad].num_fmts = mbus.index;
+		kmb_isp->pad_fmt_caps[KMB_ISP_SRC_PAD_RAW].num_fmts =
+				mbus.index;
+		kmb_isp->pad_fmt_caps[KMB_ISP_SINK_PAD_RAW].num_fmts =
+				mbus.index;
+	}
+
+	for (isp_pad_idx = KMB_ISP_SRC_PAD_VID_BASE;
+		isp_pad_idx < KMB_ISP_PADS_NUM; isp_pad_idx++) {
+		for (out_fmt_cnt = 0; out_fmt_cnt < in_fmt_cnt;) {
+			kmb_isp->pad_fmt_caps[isp_pad_idx].code[out_fmt_cnt] =
+				code[out_fmt_cnt];
+			kmb_isp->pad_fmt_caps[isp_pad_idx].num_fmts =
+				++out_fmt_cnt;
+		}
+	}
+
+	return ret;
+}
+
+/**
+ * kmb_isp_ipc_event - Handle IPC events
+ * @kmb_isp: pointer to KMB ISP device
+ * @evt: ipc event
+ * @evt_priv: isp cfg buffer private data
+ */
+static void kmb_isp_ipc_event(struct kmb_isp *kmb_isp,
+		const __u32 evt,
+		const struct kmb_isp_cfg_event_data evt_priv)
+{
+	struct v4l2_event v4l2_evt = {0};
+	struct kmb_isp_cfg_event_data *prv_data =
+		(struct kmb_isp_cfg_event_data *) v4l2_evt.u.data;
+
+	prv_data->valid = evt_priv.valid;
+	if (evt_priv.valid)
+		prv_data->index = evt_priv.index;
+
+	v4l2_evt.type = evt;
+
+	v4l2_subdev_notify_event(&kmb_isp->subdev, &v4l2_evt);
+	dev_dbg(kmb_isp->dev, "Notify event type:%d\n", evt);
+}
+
+/**
+ * kmb_isp_insert_config - Insert isp config buffer in queue
+ * @kmb_isp: pointer to KMB ISP device
+ * @cfg: pointer to ISP configuration data
+ */
+static void kmb_isp_insert_config(struct kmb_isp *kmb_isp,
+				  struct kmb_isp_cfg_data *cfg)
+{
+	mutex_lock(&kmb_isp->cfg_q_lock);
+	INIT_LIST_HEAD(&cfg->isp_cfgs);
+	list_add_tail(&cfg->isp_cfgs, &kmb_isp->isp_cfgs_queue);
+	mutex_unlock(&kmb_isp->cfg_q_lock);
+}
+
+/**
+ * kmb_isp_config_done - Remove isp config from internal queue and
+ *                       make buf done on video buffer queue.
+ * @kmb_isp: pointer to KMB ISP device
+ * @cfg: pointer to ISP configuration data
+ */
+static void kmb_isp_config_done(struct kmb_isp *kmb_isp,
+				struct kmb_isp_cfg_data *cfg)
+{
+	/* Remove isp config on buf done */
+	mutex_lock(&kmb_isp->cfg_q_lock);
+	list_del(&cfg->isp_cfgs);
+	mutex_unlock(&kmb_isp->cfg_q_lock);
+
+	vb2_buffer_done(&cfg->vb.vb2_buf, VB2_BUF_STATE_DONE);
+	dev_dbg(kmb_isp->dev, "Isp cfg done %pad", &cfg->addr);
+}
+
+/**
+ * kmb_isp_find_config_by_addr - Get isp config by given physical address
+ * @kmb_isp: pointer to KMB ISP device
+ * @addr: physical dma address
+ *
+ * Return: pointer to isp config data
+ */
+static struct kmb_isp_cfg_data *
+kmb_isp_find_config_by_addr(struct kmb_isp *kmb_isp, dma_addr_t addr)
+{
+	struct kmb_isp_cfg_data *isp_cfg = NULL;
+	struct list_head *node, *next;
+
+	mutex_lock(&kmb_isp->cfg_q_lock);
+
+	list_for_each_safe(node, next, &kmb_isp->isp_cfgs_queue) {
+		isp_cfg = list_entry(node,
+				struct kmb_isp_cfg_data, isp_cfgs);
+		if (isp_cfg->addr == addr)
+			break;
+
+		isp_cfg = NULL;
+	}
+
+	mutex_unlock(&kmb_isp->cfg_q_lock);
+
+	return isp_cfg;
+}
+
+/**
+ * kmb_isp_get_lane_info - Get lane rate and number of data lanes
+ * @kmb_isp: pointer to KMB ISP device
+ * @subdev: pointer to sensor sub-device
+ * @bpp: input format bits per pixel
+ * @lane_rate_mbps: lane rate
+ * @num_used_lanes: number of used data lanes
+ *
+ * Return: 0 if successful
+ */
+static int kmb_isp_get_lane_info(struct kmb_isp *kmb_isp,
+				 struct v4l2_subdev *subdev, u32 bpp,
+				 u32 *lane_rate_mbps, u32 *num_used_lanes)
+{
+	struct v4l2_ctrl *ctrl;
+	struct v4l2_querymenu link_freq = {.id = V4L2_CID_LINK_FREQ, };
+	struct kmb_isp_src_config *src_config;
+	s64 pix_rate;
+	u64 lane_rate_u64, num_lanes_u64;
+	int ret;
+
+	ctrl = v4l2_ctrl_find(subdev->ctrl_handler, V4L2_CID_PIXEL_RATE);
+	if (!ctrl) {
+		dev_err(kmb_isp->dev, "Can't find V4L2_CID_PIXEL_RATE ctrl");
+		return -EINVAL;
+	}
+
+	/* Avoid division of 64 bit numbers */
+	pix_rate = v4l2_ctrl_g_ctrl_int64(ctrl);
+
+	ctrl = v4l2_ctrl_find(subdev->ctrl_handler, V4L2_CID_LINK_FREQ);
+	if (!ctrl) {
+		dev_dbg(kmb_isp->dev, "Can't find V4L2_CID_LINK_FREQ ctrl");
+
+		src_config = &kmb_isp->src_config[KMB_ISP_SINK_PAD_SENSOR];
+		*num_used_lanes = src_config->num_phy_lanes;
+		lane_rate_u64 = pix_rate * bpp;
+		do_div(lane_rate_u64, *num_used_lanes);
+		do_div(lane_rate_u64, 1000000);
+		*lane_rate_mbps = (u32)lane_rate_u64;
+	} else {
+		link_freq.index = v4l2_ctrl_g_ctrl(ctrl);
+		ret = v4l2_querymenu(subdev->ctrl_handler, &link_freq);
+		if (ret)
+			return ret;
+
+		*lane_rate_mbps = link_freq.value;
+		*lane_rate_mbps /= 1000000;
+		pix_rate *= bpp;
+		/* Add half of divisor to round up */
+		pix_rate += *lane_rate_mbps >> 1;
+		do_div(pix_rate, *lane_rate_mbps);
+		num_lanes_u64 = pix_rate;
+		do_div(num_lanes_u64, 1000000);
+		*num_used_lanes = (u32)num_lanes_u64;
+	}
+
+	return 0;
+}
+
+/**
+ * kmb_isp_get_meta_info - Get metadata size
+ * @subdev: pointer to sensor sub-device
+ * @bpp: input format bits per pixel
+ * @width: input width
+ * @meta_width: metadata width
+ * @meta_height: metadata height
+ *
+ * Return: none
+ */
+static void kmb_isp_get_meta_info(struct v4l2_subdev *subdev, u32 bpp,
+				 u32 width, u32 *meta_width, u32 *meta_height)
+{
+	struct v4l2_mbus_frame_desc desc;
+	u32 embedded_data = 0;
+	int ret;
+
+	ret = v4l2_subdev_call(subdev, sensor, g_skip_top_lines, meta_height);
+	if (ret < 0) {
+		pr_debug("Couldn't get sensor metadata lines\n");
+		*meta_height = 0;
+		*meta_width = 0;
+	}
+
+	ret = v4l2_subdev_call(subdev, pad, get_frame_desc, 0, &desc);
+	if (ret < 0)
+		pr_debug("Couldn't get sensor metadata lines\n");
+	else
+		embedded_data = desc.entry[0].length;
+
+	if (embedded_data) {
+		*meta_width = embedded_data +
+			(width * *meta_height * bpp / 8);
+		*meta_height = 0;
+	} else if (*meta_height) {
+		*meta_width = width;
+	}
+}
+
+/**
+ * kmb_isp_worker_thread - ISP worker thread
+ * @isp: pointer to KMB ISP sub-device
+ *
+ * Return: 0 if successful
+ */
+static int kmb_isp_worker_thread(void *isp)
+{
+	struct kmb_isp *kmb_isp = isp;
+	struct icEvS cfg_evt;
+	size_t cfg_evt_size;
+	struct kmb_isp_cfg_event_data evt_priv;
+	struct kmb_isp_cfg_data *isp_cfg;
+	bool stopped = false;
+	int ret;
+
+	set_freezable();
+
+	while (!kthread_should_stop()) {
+		try_to_freeze();
+
+		if (stopped) {
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule();
+			dev_dbg(kmb_isp->dev, "Source is stopped\n");
+			continue;
+		}
+
+		memset(&cfg_evt, 0x00, sizeof(cfg_evt));
+		cfg_evt.ctrl = IC_EVENT_MAX;
+		cfg_evt_size = sizeof(cfg_evt);
+		ret = xlink_read_data_to_buffer(kmb_isp->ipc_dev_handler,
+				kmb_isp->channel_id, (uint8_t *const)&cfg_evt,
+				(uint32_t *)&cfg_evt_size);
+		if (ret != X_LINK_SUCCESS) {
+			dev_dbg(kmb_isp->dev, "Channel closed %d\n", ret);
+			stopped = true;
+			complete_all(&kmb_isp->source_stopped);
+			continue;
+		}
+
+		isp_cfg = kmb_isp_find_config_by_addr(kmb_isp,
+				cfg_evt.EvInfo.userDataBaseAddr01);
+		if (isp_cfg) {
+			evt_priv.index = isp_cfg->vb.vb2_buf.index;
+			evt_priv.valid = 1;
+		} else {
+			evt_priv.index = 0;
+			evt_priv.valid = 0;
+		}
+
+		switch (cfg_evt.ctrl) {
+		case IC_EVENT_TYPE_READOUT_START:
+			kmb_isp_ipc_event(kmb_isp, V4L2_EVENT_KMB_SENSOR_SOF,
+					  evt_priv);
+			break;
+		case IC_EVENT_TYPE_READOUT_END:
+			kmb_isp_ipc_event(kmb_isp, V4L2_EVENT_KMB_SENSOR_EOF,
+					  evt_priv);
+			break;
+		case IC_EVENT_TYPE_ISP_START:
+			kmb_isp_ipc_event(kmb_isp, V4L2_EVENT_KMB_ISP_SOF,
+					  evt_priv);
+			break;
+		case IC_EVENT_TYPE_ISP_END:
+			if (isp_cfg) {
+				kmb_isp_ipc_event(kmb_isp,
+						  V4L2_EVENT_KMB_ISP_EOF,
+						  evt_priv);
+				kmb_isp_config_done(kmb_isp, isp_cfg);
+			} else {
+				kmb_isp_ipc_event(kmb_isp,
+						  V4L2_EVENT_KMB_GEN_ERROR,
+						  evt_priv);
+				dev_err(kmb_isp->dev,
+					"Receive ISP_END without config %x",
+					cfg_evt.EvInfo.userDataBaseAddr01);
+			}
+			break;
+		case IC_EVENT_TYPE_STATS_READY:
+			/* Do nothing */
+			break;
+		case IC_ERROR_SRC_MIPI_CFG_SKIPPED:
+			if (isp_cfg) {
+				kmb_isp_ipc_event(kmb_isp,
+						  V4L2_EVENT_KMB_CFG_SKIPPED,
+						  evt_priv);
+				kmb_isp_config_done(kmb_isp, isp_cfg);
+			} else {
+				kmb_isp_ipc_event(kmb_isp,
+						  V4L2_EVENT_KMB_GEN_ERROR,
+						  evt_priv);
+				dev_err(kmb_isp->dev,
+					"Receive CFG_SKIP without config %x",
+					cfg_evt.EvInfo.userDataBaseAddr01);
+			}
+			break;
+		case IC_ERROR_SRC_MIPI_CFG_MISSING:
+			kmb_isp_ipc_event(kmb_isp, V4L2_EVENT_KMB_CFG_MISSING,
+					  evt_priv);
+			break;
+		case IC_ERROR_SRC_MIPI_OUT_BUFFERS_NOT_AVAILABLE:
+			kmb_isp_ipc_event(kmb_isp, V4L2_EVENT_KMB_BUF_MISSING,
+					  evt_priv);
+			break;
+		case IC_EVENT_TYPE_SOURCE_STOPPED:
+			complete_all(&kmb_isp->source_stopped);
+			stopped = true;
+			dev_dbg(kmb_isp->dev, "Source stopped\n");
+			break;
+		default:
+			dev_dbg(kmb_isp->dev, "Received event %d",
+					cfg_evt.ctrl);
+			break;
+		}
+	}
+	dev_dbg(kmb_isp->dev, "ISP thread exits\n");
+	return 0;
+}
+
+/**
+ * kmb_isp_configure_source - ISP configure source event
+ * @kmb_isp: pointer to KMB ISP sub-device
+ *
+ * Return: 0 if successful
+ */
+static int kmb_isp_configure_source(struct kmb_isp *kmb_isp)
+{
+	struct icEvS mipi_cfg_evt;
+	size_t mipi_cfg_evt_size;
+	icSourceConfig *src_cfg;
+	struct v4l2_subdev_format sd_fmt;
+	const struct kmb_isp_format *fmt;
+	struct kmb_isp_hdr_info *hdr_info;
+	struct media_pad *remote;
+	struct v4l2_subdev *subdev;
+	int ret;
+
+	remote = media_entity_remote_pad(
+			&kmb_isp->pads[KMB_ISP_SINK_PAD_SENSOR]);
+	if (remote == NULL)
+		return -ENOENT;
+
+	subdev = media_entity_to_v4l2_subdev(remote->entity);
+	if (subdev == NULL)
+		return -ENOENT;
+
+	memset(&sd_fmt, 0, sizeof(sd_fmt));
+	sd_fmt.pad = remote->index;
+	sd_fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
+	ret = v4l2_subdev_call(subdev, pad, get_fmt, NULL, &sd_fmt);
+	if (ret < 0) {
+		dev_err(kmb_isp->dev, "Couldn't get sensor format\n");
+		return ret;
+	}
+
+	fmt = kmb_isp_get_fmt_by_code(sd_fmt.format.code);
+	if (!fmt) {
+		dev_info(kmb_isp->dev, "Couldn't get source format\n");
+		fmt = &isp_fmt[0];
+	}
+
+	src_cfg = kmb_isp->cma_vaddr;
+	memset(src_cfg, 0, sizeof(*src_cfg));
+
+	src_cfg->bayerFormat = fmt->bayer_pattern;
+	src_cfg->bitsPerPixel = fmt->bpp;
+
+	/* Not scaled isp output is always set on first output pad */
+	src_cfg->cameraOutputSize.w = sd_fmt.format.width;
+	src_cfg->cameraOutputSize.h = sd_fmt.format.height;
+
+	hdr_info = (struct kmb_isp_hdr_info *) sd_fmt.format.reserved;
+
+	switch (hdr_info->type) {
+	case NO_HDR:
+	case HDR_2DOL_LI:
+	case HDR_3DOL_LI:
+		src_cfg->noExposure = 1;
+		break;
+	case HDR_2DOL_VC:
+		src_cfg->noExposure = 2;
+		break;
+	case HDR_3DOL_VC:
+		src_cfg->noExposure = 3;
+		break;
+	}
+
+	src_cfg->cropWindow.x1 = 0;
+	src_cfg->cropWindow.x2 = src_cfg->cameraOutputSize.w;
+	src_cfg->cropWindow.y1 = 0;
+	src_cfg->cropWindow.y2 = src_cfg->cameraOutputSize.h;
+
+	src_cfg->mipiRxData.controllerNo =
+		kmb_isp->src_config[KMB_ISP_SINK_PAD_SENSOR].controller_num;
+	src_cfg->mipiRxData.dataMode = 1;
+	src_cfg->mipiRxData.dataType = fmt->rx_data_type;
+
+	/* This configuration should be negotiated with sensor */
+	ret = kmb_isp_get_lane_info(kmb_isp, subdev, fmt->bpp,
+				    &src_cfg->mipiRxData.laneRateMbps,
+				    &src_cfg->mipiRxData.noLanes);
+	if (ret < 0) {
+		dev_err(kmb_isp->dev, "Couldn't get lane info\n");
+		return ret;
+	}
+
+	kmb_isp_get_meta_info(subdev, fmt->bpp, sd_fmt.format.width,
+			      &src_cfg->metadataWidth,
+			      &src_cfg->metadataHeight);
+
+	src_cfg->metadataDataType = IC_IPIPE_EMBEDDED_8BIT;
+
+	dev_dbg(kmb_isp->dev,
+		"icEvS ctrl IC_EVENT_TYPE_CONFIG_SOURCE channel id %d\n",
+		kmb_isp->channel_id);
+
+	kmb_isp_print_src_cfg(src_cfg);
+
+	memset(&mipi_cfg_evt, 0, sizeof(mipi_cfg_evt));
+	mipi_cfg_evt_size = sizeof(mipi_cfg_evt);
+	mipi_cfg_evt.ctrl = IC_EVENT_TYPE_CONFIG_SOURCE;
+	mipi_cfg_evt.EvInfo.instId = 0;
+	mipi_cfg_evt.EvInfo.userDataBaseAddr01 = kmb_isp->cma_phy_addr;
+
+	ret = xlink_write_volatile(kmb_isp->ipc_dev_handler,
+			kmb_isp->channel_id,
+			(u8 *)&mipi_cfg_evt,
+			(uint32_t)mipi_cfg_evt_size);
+	if (ret) {
+		dev_err(kmb_isp->dev,
+				"Error on IC_EVENT_TYPE_CONFIG_SOURCE %d\n",
+				ret);
+		return ret;
+	}
+
+	ret = xlink_read_data_to_buffer(kmb_isp->ipc_dev_handler,
+			kmb_isp->channel_id,
+			(uint8_t *const)&mipi_cfg_evt,
+			(uint32_t *)&mipi_cfg_evt_size);
+	if ((ret != X_LINK_SUCCESS) ||
+	    (mipi_cfg_evt.ctrl != IC_EVENT_TYPE_SOURCE_CONFIGURED)) {
+		dev_err(kmb_isp->dev, "Config source fail ret %d ctrl %d\n",
+				ret, mipi_cfg_evt.ctrl);
+		return ret ? ret : -ENODEV;
+	}
+
+	dev_dbg(kmb_isp->dev,
+			"rcv icEvS ctrl IC_EVENT_TYPE_CONFIG_SOURCE"
+			" channel id %d\n",
+			kmb_isp->channel_id);
+
+	kmb_isp_print_src_cfg(src_cfg);
+
+	return 0;
+}
+
+/**
+ * kmb_isp_start_source - ISP start source event
+ * @kmb_isp: pointer to KMB ISP sub-device
+ *
+ * Return: 0 if successful
+ */
+static int kmb_isp_start_source(struct kmb_isp *kmb_isp)
+{
+	struct icEvS cfg_evt;
+	size_t cfg_evt_size;
+	int ret;
+
+	BUG_ON(kmb_isp->source_streaming);
+
+	memset(&cfg_evt, 0, sizeof(cfg_evt));
+	cfg_evt_size = sizeof(cfg_evt);
+	cfg_evt.ctrl = IC_EVENT_TYPE_START_SOURCE;
+	cfg_evt.EvInfo.instId = 0;
+
+	dev_dbg(kmb_isp->dev, "IC_EVENT_TYPE_START_SOURCE\n");
+	ret = xlink_write_volatile(kmb_isp->ipc_dev_handler,
+			kmb_isp->channel_id,
+			(u8 *)&cfg_evt,
+			cfg_evt_size);
+	if (ret) {
+		dev_err(kmb_isp->dev, "Error on IC_EVENT_TYPE_START_SOURCE %d\n",
+				ret);
+		return ret;
+	}
+
+	ret = xlink_read_data_to_buffer(kmb_isp->ipc_dev_handler,
+			kmb_isp->channel_id,
+			(uint8_t *const)&cfg_evt,
+			(uint32_t *)&cfg_evt_size);
+	if ((ret != X_LINK_SUCCESS) ||
+	    (cfg_evt.ctrl != IC_EVENT_TYPE_SOURCE_STARTED)) {
+		dev_err(kmb_isp->dev, "Start source fail %d ctrl %d\n",
+				ret, cfg_evt.ctrl);
+		return ret ? ret : -ENODEV;
+	}
+
+	init_completion(&kmb_isp->source_stopped);
+	kmb_isp->thread = kthread_run(kmb_isp_worker_thread,
+			kmb_isp, "kmb_isp_thread");
+	if (IS_ERR(kmb_isp->thread)) {
+		kmb_isp->thread = NULL;
+		dev_err(kmb_isp->dev, "%s Thread run failed\n", __func__);
+		return -ENOMEM;
+	}
+
+	kmb_isp->source_streaming = true;
+
+	return 0;
+}
+
+/**
+ * kmb_isp_stop_source - ISP stop source event
+ * @kmb_isp: pointer to KMB ISP sub-device
+ * @method: stop source method
+ *
+ * Return: 0 if successful
+ */
+static int kmb_isp_stop_source(struct kmb_isp *kmb_isp,
+			       enum kmb_isp_stop_method method)
+{
+	struct icEvS cfg_evt;
+	int ret;
+
+	BUG_ON(!kmb_isp->source_streaming);
+
+	if (method == KMB_ISP_STOP_SYNC) {
+		memset(&cfg_evt, 0, sizeof(cfg_evt));
+		cfg_evt.ctrl = IC_EVENT_TYPE_STOP_SOURCE;
+		cfg_evt.EvInfo.instId = 0;
+
+		ret = xlink_write_volatile(kmb_isp->ipc_dev_handler,
+				kmb_isp->channel_id,
+				(u8 *)&cfg_evt,
+				sizeof(cfg_evt));
+		if (ret) {
+			dev_err(kmb_isp->dev,
+				"Error IC_EVENT_TYPE_STOP_SOURCE %d\n", ret);
+			return ret;
+		}
+
+		ret = wait_for_completion_timeout(&kmb_isp->source_stopped,
+			msecs_to_jiffies(KMB_STOP_SOURCE_TIMEOUT_MS));
+		if (ret == 0) {
+			dev_err(kmb_isp->dev, "Source stopped timeout");
+			return -ETIMEDOUT;
+		}
+	}
+
+	if (kmb_isp->thread) {
+		ret = kthread_stop(kmb_isp->thread);
+		if (ret < 0) {
+			dev_err(kmb_isp->dev,
+				"%s Thread stop failed ret = %d\n",
+				__func__, ret);
+			return ret;
+		}
+		kmb_isp->thread = NULL;
+		dev_dbg(kmb_isp->dev, "%s Thread stopped ret = %d\n",
+			__func__, ret);
+	}
+
+	kmb_isp->source_streaming = false;
+
+	return 0;
+}
+
+/**
+ * kmb_isp_process_config - Process an ISP config
+ * @kmb_isp: pointer to KMB ISP sub-device
+ * @buf: pointer to isp config buffer
+ *
+ * Return: 0 if successful
+ */
+static int kmb_isp_process_config(struct kmb_isp *kmb_isp,
+				  struct kmb_isp_cfg_data *buf)
+{
+	struct icEvS cfg_evt;
+	uint32_t cfg_evt_size;
+	int ret;
+
+	memset(&cfg_evt, 0, sizeof(cfg_evt));
+	cfg_evt_size = sizeof(cfg_evt);
+	cfg_evt.ctrl = IC_EVENT_TYPE_CONFIG_ISP;
+	cfg_evt.EvInfo.seqNr = kmb_isp->sequence++;
+	cfg_evt.EvInfo.userDataBaseAddr01 = buf->addr;
+
+	dev_dbg(kmb_isp->dev, "IC_EVENT_TYPE_CONFIG_ISP %pad\n", &buf->addr);
+
+	ret = xlink_write_volatile(kmb_isp->ipc_dev_handler,
+				 kmb_isp->channel_id,
+				 (u8 *)&cfg_evt,
+				 cfg_evt_size);
+	if (ret) {
+		dev_err(kmb_isp->dev, "Error on IC_EVENT_TYPE_CONFIG_ISP %d\n",
+				ret);
+		return ret;
+	}
+
+	/* Start source if is not running */
+	if (!kmb_isp->source_streaming) {
+		ret = kmb_isp_start_source(kmb_isp);
+		if (ret) {
+			dev_err(kmb_isp->dev, "Can not start isp source");
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+/**
+ * kmb_isp_discard_config - Discard isp config buffer
+ * @buf: pointer to isp config buffer
+ *
+ * Return: 0 if successful
+ */
+static void kmb_isp_discard_config(struct kmb_isp_cfg_data *buf)
+{
+	list_del(&buf->isp_cfgs);
+	vb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);
+}
+
+/**
+ * kmb_isp_process_all_configs - Process all isp configs
+ * @kmb_isp: pointer to KMB ISP sub-device
+ *
+ * Return: 0 if successful
+ */
+static int kmb_isp_process_all_configs(struct kmb_isp *kmb_isp)
+{
+	struct kmb_isp_cfg_data *buf;
+	struct list_head *pos, *next;
+	int ret = 0;
+
+	mutex_lock(&kmb_isp->cfg_q_lock);
+	list_for_each_safe(pos, next, &kmb_isp->isp_cfgs_queue) {
+		buf = list_entry(pos, struct kmb_isp_cfg_data, isp_cfgs);
+
+		ret = kmb_isp_process_config(kmb_isp, buf);
+		if (ret) {
+			dev_err(kmb_isp->dev, "Can not process isp config");
+			kmb_isp_discard_config(buf);
+			continue;
+		}
+	}
+	mutex_unlock(&kmb_isp->cfg_q_lock);
+
+	return ret;
+}
+
+/**
+ * kmb_isp_discard_all_configs - Discard all isp configs
+ * @kmb_isp: pointer to KMB ISP sub-device
+ *
+ * Return: 0 if successful
+ */
+static void kmb_isp_discard_all_configs(struct kmb_isp *kmb_isp)
+{
+	struct kmb_isp_cfg_data *buf;
+	struct list_head *pos, *next;
+	struct kmb_isp_cfg_event_data event;
+
+	event.valid = 1;
+	mutex_lock(&kmb_isp->cfg_q_lock);
+	list_for_each_safe(pos, next, &kmb_isp->isp_cfgs_queue) {
+		buf = list_entry(pos, struct kmb_isp_cfg_data, isp_cfgs);
+		list_del(&buf->isp_cfgs);
+
+		/* Notify that configuration is skipped */
+		event.index = buf->vb.vb2_buf.index;
+		kmb_isp_ipc_event(kmb_isp, V4L2_EVENT_KMB_CFG_SKIPPED, event);
+
+		vb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);
+	}
+	mutex_unlock(&kmb_isp->cfg_q_lock);
+}
+
+/**
+ * kmb_isp_queue_isp_cfg_buf - Queue isp cfg buffer
+ * @priv: pointer to KMB ISP sub-device
+ * @cfg: isp cfg buffer to queue
+ *
+ * Return: 0 if successful
+ */
+static int kmb_isp_queue_isp_cfg_buf(void *priv, struct kmb_isp_cfg_data *cfg)
+{
+	struct kmb_isp *kmb_isp = priv;
+	int ret = 0;
+
+	kmb_isp_insert_config(kmb_isp, cfg);
+
+	mutex_lock(&kmb_isp->lock);
+
+	/* Process ISP configurations only when ISP is streaming */
+	if (kmb_isp->isp_streaming) {
+		ret = kmb_isp_process_config(kmb_isp, cfg);
+		if (ret)
+			dev_err(kmb_isp->dev, "Fail to process isp config\n");
+	}
+
+	mutex_unlock(&kmb_isp->lock);
+
+	return ret;
+}
+
+/**
+ * kmb_isp_queue_flush - Flush isp cfg buffers
+ * @priv: pointer to KMB ISP sub-device
+ *
+ * Return: 0 if successful
+ */
+static void kmb_isp_queue_flush(void *priv)
+{
+	kmb_isp_discard_all_configs(priv);
+}
+
+struct kmb_isp_cfg_queue_ops isp_cfg_queue_ops = {
+	.queue = kmb_isp_queue_isp_cfg_buf,
+	.flush = kmb_isp_queue_flush,
+};
+
+/**
+ * kmb_isp_open_xlink_channel - Open xlink channel for ISP
+ * @kmb_isp: pointer to ISP sub-device
+ *
+ * Return: 0 if successful
+ */
+static int kmb_isp_open_xlink_channel(struct kmb_isp *kmb_isp)
+{
+	int ret;
+
+	ret = xlink_open_channel(kmb_isp->ipc_dev_handler, kmb_isp->channel_id,
+				 RXB_TXB, KMB_RT_ISP_CH_DATA_SIZE,
+				 KMB_RT_ISP_CH_TIMEOUT_MS);
+	if (ret) {
+		dev_err(kmb_isp->dev, "Failed to open ISP channel: %d\n", ret);
+		return ret;
+	}
+	dev_dbg(kmb_isp->dev, "Opened ISP channel %u\n", kmb_isp->channel_id);
+
+	return 0;
+}
+
+/**
+ * kmb_isp_close_xlink_channel - Close xlink channel for ISP
+ * @kmb_isp: pointer to ISP sub-device
+ *
+ * Return: 0 if successful
+ */
+static int kmb_isp_close_xlink_channel(struct kmb_isp *kmb_isp)
+{
+	int ret;
+
+	ret = xlink_close_channel(kmb_isp->ipc_dev_handler, kmb_isp->channel_id);
+	if (ret) {
+		dev_err(kmb_isp->dev,
+				"Failed to close ISP channel: %d\n", ret);
+		return ret;
+	}
+	dev_dbg(kmb_isp->dev, "Closed ISP channel\n");
+
+	return 0;
+}
+
+/**
+ * kmb_isp_open - Sub-device node open
+ * @subdev: pointer to V4L2 sub-device
+ * @fh: pointer to V4L2 sub-device file handle
+ *
+ * Return: 0 if successful
+ */
+static int kmb_isp_open(struct v4l2_subdev *subdev,
+			struct v4l2_subdev_fh *fh)
+{
+	struct kmb_isp *kmb_isp = v4l2_get_subdevdata(subdev);
+	int ret;
+
+	/*
+	 * Camera mode control depends on pad formats
+	 * And formats should also be populated on open.
+	 */
+	mutex_lock(&kmb_isp->lock);
+	ret = kmb_isp_populate_pad_formats(kmb_isp);
+	mutex_unlock(&kmb_isp->lock);
+	if (ret < 0)
+		return ret;
+
+	/* Limit camera modes hold isp lock */
+	kmb_isp_limit_camera_modes_range(kmb_isp);
+	return 0;
+}
+
+/**
+ * kmb_isp_close - Sub-device node close
+ * @subdev: pointer to V4L2 sub-device
+ * @fh: pointer to V4L2 sub-device file handle
+ *
+ * Return: 0 if successful
+ */
+static int kmb_isp_close(struct v4l2_subdev *subdev,
+			 struct v4l2_subdev_fh *fh)
+{
+	return 0;
+}
+
+/* sub-device internal operations */
+static const struct v4l2_subdev_internal_ops kmb_isp_internal_ops = {
+	.open = kmb_isp_open,
+	.close = kmb_isp_close,
+};
+
+/**
+ * kmb_isp_get_closest_res - Set format ratio to the closest possible
+ * @kmb_isp: pointer to ISP sub-device
+ * @pad: ISP pad index
+ * @format: pointer to media bus frame format
+ *
+ * Return: 0 if successful
+ */
+static void kmb_isp_align_fmt(struct kmb_isp *kmb_isp, u32 pad,
+			      struct v4l2_mbus_framefmt *format)
+{
+	if (pad >= KMB_ISP_PADS_NUM)
+		return;
+
+	format->width = clamp(format->width,
+			      kmb_isp->pad_fmt_caps[pad].range.min_width,
+			      kmb_isp->pad_fmt_caps[pad].range.max_width);
+
+	format->height = clamp(format->height,
+			      kmb_isp->pad_fmt_caps[pad].range.min_height,
+			      kmb_isp->pad_fmt_caps[pad].range.max_height);
+
+	dev_dbg(kmb_isp->dev, "Resolution for pad-idx %d was set to %ux%u\n",
+		pad, format->width, format->height);
+}
+
+/**
+ * kmb_isp_subdev_get_fmt - Get mbus format
+ * @sd: pointer to V4L2 sub-device
+ * @cfg: pointer to sub-device pad information
+ * @format: pointer to pad-level media bus format
+ *
+ * VIDIOC_SUBDEV_G_FMT ioctl handler
+ *
+ * Return: 0 if successful
+ */
+static int kmb_isp_subdev_get_fmt(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_pad_config *cfg,
+				  struct v4l2_subdev_format *format)
+{
+	struct kmb_isp *kmb_isp = v4l2_get_subdevdata(sd);
+	struct v4l2_subdev_format *pad_fmt;
+
+	if (format->pad >= KMB_ISP_PADS_NUM)
+		return -EINVAL;
+
+	if (format->which == V4L2_SUBDEV_FORMAT_TRY) {
+		format->format =
+			*v4l2_subdev_get_try_format(sd, cfg, format->pad);
+		kmb_isp_align_fmt(kmb_isp, format->pad, &format->format);
+		return 0;
+	}
+
+	pad_fmt = kmb_isp_get_pad_format_by_idx(kmb_isp, format->pad);
+	if (!pad_fmt)
+		return -EINVAL;
+
+	kmb_isp_align_fmt(kmb_isp, format->pad, &pad_fmt->format);
+	*format = *pad_fmt;
+
+	return 0;
+}
+
+/**
+ * kmb_isp_subdev_set_fmt - Set mbus format
+ * @sd: pointer to V4L2 sub-device
+ * @cfg: pointer to sub-device pad information
+ * @format: pointer to pad-level media bus format
+ *
+ * VIDIOC_SUBDEV_S_FMT ioctl handler
+ *
+ * Return: 0 if successful
+ */
+static int kmb_isp_subdev_set_fmt(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_pad_config *cfg,
+				  struct v4l2_subdev_format *format)
+{
+	struct kmb_isp *kmb_isp = v4l2_get_subdevdata(sd);
+	struct v4l2_subdev_format *pad_fmt;
+
+	if (format->pad >= KMB_ISP_PADS_NUM)
+		return -EINVAL;
+
+	if (format->which == V4L2_SUBDEV_FORMAT_TRY) {
+		format->format =
+			*v4l2_subdev_get_try_format(sd, cfg, format->pad);
+		kmb_isp_align_fmt(kmb_isp, format->pad, &format->format);
+		return 0;
+	}
+
+	pad_fmt = kmb_isp_get_pad_format_by_idx(kmb_isp, format->pad);
+	if (!pad_fmt)
+		return -EINVAL;
+
+	kmb_isp_align_fmt(kmb_isp, format->pad, &format->format);
+	*pad_fmt = *format;
+
+	return 0;
+}
+
+/**
+ * kmb_isp_subdev_enum_frame_interval - Enumerate frame intervals
+ * @sd: pointer to V4L2 sub-device
+ * @cfg: pointer to sub-device pad information
+ * @fie: pointer to pad-level frame interval enumeration
+ *
+ * VIDIOC_SUBDEV_ENUM_FRAME_INTERVAL ioctl handler
+ *
+ * Return: 0 if successful
+ */
+static int
+kmb_isp_subdev_enum_frame_interval(struct v4l2_subdev *sd,
+				   struct v4l2_subdev_pad_config *cfg,
+				   struct v4l2_subdev_frame_interval_enum *fie)
+{
+	struct kmb_isp *kmb_isp = v4l2_get_subdevdata(sd);
+	struct v4l2_subdev_frame_interval_enum interval;
+	struct v4l2_subdev *subdev;
+	struct media_pad *remote;
+	int ret;
+
+	if (fie->pad >= KMB_ISP_PADS_NUM)
+		return -EINVAL;
+
+	remote = media_entity_remote_pad(
+			&kmb_isp->pads[KMB_ISP_SINK_PAD_SENSOR]);
+	if (remote == NULL)
+		return -ENOENT;
+
+	subdev = media_entity_to_v4l2_subdev(remote->entity);
+
+	mutex_lock(&kmb_isp->lock);
+
+	memcpy(&interval, fie, sizeof(*fie));
+	interval.pad = 0;
+	interval.which = V4L2_SUBDEV_FORMAT_TRY;
+	interval.code = kmb_isp->pad_fmt_caps[KMB_ISP_SINK_PAD_SENSOR].code[0];
+	ret = v4l2_subdev_call(subdev, pad, enum_frame_interval,
+				cfg, &interval);
+	if (ret < 0) {
+		mutex_unlock(&kmb_isp->lock);
+		return ret == -ENOIOCTLCMD ? -ENOTTY : ret;
+	}
+
+	fie->interval = interval.interval;
+
+	mutex_unlock(&kmb_isp->lock);
+
+	return 0;
+}
+
+/**
+ * kmb_isp_subdev_enum_mbus_code - Enumerate media bus code
+ * @sd: pointer to V4L2 sub-device
+ * @cfg: pointer to sub-device pad information
+ * @code: pointer to pad-level media bus code
+ *
+ * VIDIOC_SUBDEV_ENUM_MBUS_CODE ioctl handler
+ *
+ * Return: 0 if successful
+ */
+static int kmb_isp_subdev_enum_mbus_code(struct v4l2_subdev *sd,
+					struct v4l2_subdev_pad_config *cfg,
+					struct v4l2_subdev_mbus_code_enum *code)
+{
+	struct kmb_isp *kmb_isp = v4l2_get_subdevdata(sd);
+
+	if (code->index >= kmb_isp->pad_fmt_caps[code->pad].num_fmts)
+		return -EINVAL;
+
+	mutex_lock(&kmb_isp->lock);
+	code->code = kmb_isp->pad_fmt_caps[code->pad].code[code->index];
+	mutex_unlock(&kmb_isp->lock);
+
+	return 0;
+}
+
+/**
+ * kmb_isp_g_frame_interval - Get frame intervals
+ * @sd: pointer to V4L2 sub-device
+ * @interval: pointer to pad-level subdevice frame interval enumeration
+ *
+ * VIDIOC_SUBDEV_G_FRAME_INTERVAL ioctl handler
+ *
+ * Return: 0 if successful
+ */
+static int kmb_isp_g_frame_interval(struct v4l2_subdev *sd,
+				    struct v4l2_subdev_frame_interval *interval)
+{
+	struct kmb_isp *kmb_isp = v4l2_get_subdevdata(sd);
+	struct v4l2_subdev_frame_interval ival;
+	struct v4l2_subdev *subdev;
+	struct media_pad *remote;
+	int ret;
+
+	if (interval->pad >= KMB_ISP_PADS_NUM)
+		return -EINVAL;
+
+	remote = media_entity_remote_pad(
+			&kmb_isp->pads[KMB_ISP_SINK_PAD_SENSOR]);
+	if (remote == NULL)
+		return -ENOENT;
+
+	subdev = media_entity_to_v4l2_subdev(remote->entity);
+
+	memcpy(&ival, interval, sizeof(*interval));
+	ival.pad = 0;
+	ret = v4l2_subdev_call(subdev, video, g_frame_interval, &ival);
+	if (ret < 0) {
+		dev_err(kmb_isp->dev, "Couldn't get sensor frame interval\n");
+		return ret == -ENOIOCTLCMD ? -ENOTTY : ret;
+	}
+
+	interval->interval = ival.interval;
+
+	return 0;
+}
+
+/**
+ * kmb_isp_s_frame_interval - Set frame intervals
+ * @sd: pointer to V4L2 sub-device
+ * @interval: pointer to pad-level subdevice frame interval enumeration
+ *
+ * VIDIOC_SUBDEV_S_FRAME_INTERVAL ioctl handler
+ *
+ * Return: 0 if successful
+ */
+static int kmb_isp_s_frame_interval(struct v4l2_subdev *sd,
+				    struct v4l2_subdev_frame_interval *interval)
+{
+	struct kmb_isp *kmb_isp = v4l2_get_subdevdata(sd);
+	struct v4l2_subdev_frame_interval ival;
+	struct v4l2_subdev *subdev;
+	struct media_pad *remote;
+	int ret;
+
+	if (interval->pad >= KMB_ISP_PADS_NUM)
+		return -EINVAL;
+
+	remote = media_entity_remote_pad(
+			&kmb_isp->pads[KMB_ISP_SINK_PAD_SENSOR]);
+	if (remote == NULL)
+		return -ENOENT;
+
+	subdev = media_entity_to_v4l2_subdev(remote->entity);
+
+	memcpy(&ival, interval, sizeof(*interval));
+	ival.pad = 0;
+	ret = v4l2_subdev_call(subdev, video, s_frame_interval, &ival);
+	if (ret < 0) {
+		dev_err(kmb_isp->dev, "Couldn't set sensor frame interval\n");
+		return ret == -ENOIOCTLCMD ? -ENOTTY : ret;
+	}
+
+	interval->interval = ival.interval;
+
+	return 0;
+}
+
+/**
+ * kmb_isp_s_stream - Set video stream stop/start
+ * @sd: pointer to V4L2 sub-device
+ * @enable: stream state
+ *
+ * Return: 0 if successful
+ */
+static int kmb_isp_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct kmb_isp *kmb_isp = v4l2_get_subdevdata(sd);
+	u32 camera_mode = v4l2_ctrl_g_ctrl(kmb_isp->ctrls.camera_mode);
+	int ret;
+
+	mutex_lock(&kmb_isp->lock);
+
+	/* Don't send isp config on stream disable */
+	if (enable) {
+		ret = kmb_isp_open_xlink_channel(kmb_isp);
+		if (ret) {
+			dev_err(kmb_isp->dev,
+					"Fail to open xlink channel %d\n", ret);
+			goto error;
+		}
+
+		ret = kmb_isp_configure_source(kmb_isp);
+		if (ret) {
+			dev_err(kmb_isp->dev, "Fail to configure source %d\n",
+					ret);
+			goto error_close_xlink_channel;
+		}
+
+		/* Process all pending isp configurations on stream enable */
+		ret = kmb_isp_process_all_configs(kmb_isp);
+		if (ret) {
+			dev_err(kmb_isp->dev,
+				"Fail to configure source %d\n", ret);
+			goto error_close_xlink_channel;
+		}
+		/*
+		 * In case of smart sensor we may not have configurations
+		 * in that case start the source
+		 */
+		if (camera_mode == KMB_CAMERA_MODE_NO_ISP &&
+		    !kmb_isp->source_streaming) {
+			ret = kmb_isp_start_source(kmb_isp);
+			if (ret) {
+				dev_err(kmb_isp->dev, "Can not start isp src");
+				goto error_close_xlink_channel;
+			}
+		}
+
+		kmb_isp->isp_streaming = true;
+	} else {
+		/* Try top to stop the source synchronized */
+		if (kmb_isp->source_streaming)
+			kmb_isp_stop_source(kmb_isp, KMB_ISP_STOP_SYNC);
+
+		kmb_isp_close_xlink_channel(kmb_isp);
+
+		/* Force stop isp if still streaming after channel is closed */
+		if (kmb_isp->source_streaming)
+			kmb_isp_stop_source(kmb_isp, KMB_ISP_STOP_FORCE);
+
+		/* Discard all unprocessed configuration */
+		kmb_isp_discard_all_configs(kmb_isp);
+		kmb_isp->isp_streaming = false;
+		kmb_isp->sequence = 0;
+	}
+
+	mutex_unlock(&kmb_isp->lock);
+	return 0;
+
+error_close_xlink_channel:
+	kmb_isp_close_xlink_channel(kmb_isp);
+error:
+	mutex_unlock(&kmb_isp->lock);
+	return ret;
+}
+
+/**
+ * kmb_isp_subdev_ioctl - Private ioctl handling
+ * @sd: pointer to V4L2 sub-device
+ * @cmd: ioctl command
+ * @arg: pointer to ioctl arguments
+ *
+ * Return: 0 if successful, -ENOTTY if command is not supported
+ */
+static long kmb_isp_subdev_ioctl(struct v4l2_subdev *sd,
+				 unsigned int cmd, void *arg)
+{
+	struct kmb_isp *kmb_isp = v4l2_get_subdevdata(sd);
+	int ret;
+
+	mutex_lock(&kmb_isp->lock);
+
+	switch (cmd) {
+	default:
+		dev_dbg(kmb_isp->dev, "Unknown cmd 0x%x\n", cmd);
+		ret = -ENOTTY;
+		break;
+	}
+
+	mutex_unlock(&kmb_isp->lock);
+
+	return ret;
+}
+
+/**
+ * kmb_isp_s_power - Put device in power saving or normal mode
+ * @sd: pointer to V4L2 sub-device
+ * @on: power state (0 - power saving mode, 1 - normal operation mode)
+ *
+ * Return: 0 if successful
+ */
+static int kmb_isp_s_power(struct v4l2_subdev *sd, int on)
+{
+	struct kmb_isp *kmb_isp = v4l2_get_subdevdata(sd);
+	int ret = 0;
+
+	mutex_lock(&kmb_isp->lock);
+
+	if (on) {
+		if (kmb_isp->channel_ops.accuire_id)
+			kmb_isp->channel_id =
+				kmb_isp->channel_ops.accuire_id(kmb_isp->priv);
+		ret = kmb_isp_populate_pad_formats(kmb_isp);
+	} else {
+		if (kmb_isp->channel_ops.free_id && kmb_isp->channel_id)
+			kmb_isp->channel_ops.free_id(kmb_isp->priv,
+						     kmb_isp->channel_id);
+		kmb_isp->channel_id = 0;
+		kmb_isp_reset_pad_formats(kmb_isp);
+	}
+
+	mutex_unlock(&kmb_isp->lock);
+
+	kmb_isp_limit_camera_modes_range(kmb_isp);
+
+	dev_dbg(kmb_isp->dev, "%s: Set power_on %d %d\n", __func__, on, ret);
+	return ret;
+}
+
+/**
+ * kmb_isp_subscribe_event - Event subscription
+ * @sd: pointer to V4L2 sub-device
+ * @fh: pointer to V4L2 sub-device file handle
+ * @sub: pointer to event subscription structure
+ *
+ * Request event subscription from control framework, driver will be warned
+ * when control value changes
+ *
+ * Return: 0 if successful
+ */
+static int kmb_isp_subscribe_event(struct v4l2_subdev *sd,
+			struct v4l2_fh *fh,
+			struct v4l2_event_subscription *sub)
+{
+	struct kmb_isp *kmb_isp = v4l2_get_subdevdata(sd);
+	int ret;
+
+	switch (sub->type) {
+	case V4L2_EVENT_KMB_SENSOR_SOF:
+	case V4L2_EVENT_KMB_SENSOR_EOF:
+	case V4L2_EVENT_KMB_ISP_SOF:
+	case V4L2_EVENT_KMB_ISP_EOF:
+	case V4L2_EVENT_KMB_CFG_SKIPPED:
+	case V4L2_EVENT_KMB_CFG_MISSING:
+	case V4L2_EVENT_KMB_BUF_MISSING:
+	case V4L2_EVENT_KMB_GEN_ERROR:
+		ret = v4l2_event_subscribe(
+				fh, sub, KMB_ISP_EVT_Q_LEN, NULL);
+		dev_dbg(kmb_isp->dev,
+				"Subscribe to event %d\n", sub->type);
+		break;
+	default:
+		dev_err(kmb_isp->dev, "Unknown event %d\n", sub->type);
+		ret = -ENOTTY;
+		break;
+	}
+
+	return ret;
+}
+
+/**
+ * kmb_isp_unsubscribe_event - Remove event subscription
+ * @sd: pointer to V4L2 sub-device
+ * @fh: pointer to V4L2 sub-device file handle
+ * @sub: pointer to event subscription structure
+ *
+ * Remove event subscription from the control framework
+ *
+ * Return: 0 if successful
+ */
+static int kmb_isp_unsubscribe_event(struct v4l2_subdev *sd,
+			struct v4l2_fh *fh,
+			struct v4l2_event_subscription *sub)
+{
+	return v4l2_event_unsubscribe(fh, sub);
+}
+
+/**
+ * kmb_isp_set_transform_hub - Set transform hub mode
+ * @kmb_isp: pointer to isp device
+ * @mode: chosen transform hub mode
+ *
+ * Return: 0 if successful
+ */
+static int kmb_isp_set_transform_hub(struct kmb_isp *kmb_isp, int mode)
+{
+	pr_debug("%s: kmb set transform hub %d", __func__, mode);
+
+	return 0;
+}
+
+/**
+ * kmb_isp_set_camera_mode - Set camera mode
+ * @kmb_isp: pointer to isp device
+ * @mode: chosen camera mode
+ *
+ * Return: 0 if successful
+ */
+static int kmb_isp_set_camera_mode(struct kmb_isp *kmb_isp, int mode)
+{
+	if (kmb_isp->source_streaming)
+		return -EBUSY;
+
+	pr_debug("%s: kmb set camera mode %d", __func__, mode);
+	return 0;
+}
+
+/**
+ * kmb_isp_get_transform_hub - Get transform hub mode
+ * @kmb_isp: pointer to isp device
+ * @mode: current transform hub mode
+ *
+ * Return: 0 if successful
+ */
+static int kmb_isp_get_transform_hub(struct kmb_isp *kmb_isp, int *mode)
+{
+	pr_debug("%s: kmb get transform hub %d", __func__, *mode);
+
+	return 0;
+}
+
+/**
+ * kmb_isp_get_camera_mode - Get camera mode
+ * @kmb_isp: pointer to isp device
+ * @mode: current camera mode
+ *
+ * Return: 0 if successful
+ */
+static int kmb_isp_get_camera_mode(struct kmb_isp *kmb_isp, int *mode)
+{
+	pr_debug("%s: kmb get camera mode %d", __func__, *mode);
+
+	return 0;
+}
+
+/**
+ * kmb_isp_s_ctrl - Set new control value
+ * @ctrl: pointer to control structure
+ *
+ * Return: 0 if successful
+ */
+static int kmb_isp_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct v4l2_subdev *sd = &(container_of(ctrl->handler, struct kmb_isp,
+					ctrls.handler)->subdev);
+	struct kmb_isp *kmb_isp = container_of(sd, struct kmb_isp, subdev);
+
+	dev_dbg(kmb_isp->dev, "s_ctrl: %s, value: %d\n",
+			ctrl->name, ctrl->val);
+
+	mutex_lock(&kmb_isp->lock);
+
+	switch (ctrl->id) {
+	case V4L2_CID_KMB_CAMERA_TRANSFORM_HUB:
+		kmb_isp_set_transform_hub(kmb_isp, ctrl->val);
+		break;
+	case V4L2_CID_KMB_CAMERA_MODE:
+		kmb_isp_set_camera_mode(kmb_isp, ctrl->val);
+		break;
+	default:
+		dev_dbg(kmb_isp->dev, "%s: KMB isp set %d\n",
+				__func__, ctrl->id);
+	}
+
+	mutex_unlock(&kmb_isp->lock);
+	return 0;
+}
+
+/**
+ * kmb_isp_g_ctrl - Get control value
+ * @ctrl: pointer to control structure
+ *
+ * Return: 0 if successful
+ */
+static int kmb_isp_g_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct v4l2_subdev *sd = &(container_of(ctrl->handler, struct kmb_isp,
+					ctrls.handler)->subdev);
+	struct kmb_isp *kmb_isp = container_of(sd, struct kmb_isp, subdev);
+
+	mutex_lock(&kmb_isp->lock);
+	switch (ctrl->id) {
+	case V4L2_CID_KMB_CAMERA_TRANSFORM_HUB:
+		kmb_isp_get_transform_hub(kmb_isp, &ctrl->val);
+		break;
+	case V4L2_CID_KMB_CAMERA_MODE:
+		kmb_isp_get_camera_mode(kmb_isp, &ctrl->val);
+		break;
+	default:
+		dev_dbg(kmb_isp->dev, "%s: KMB isp get %d\n",
+				__func__, ctrl->id);
+	}
+	mutex_unlock(&kmb_isp->lock);
+
+	return 0;
+}
+
+/* sub-device core operations */
+static struct v4l2_subdev_core_ops kmb_isp_subdev_core_ops = {
+	.ioctl = kmb_isp_subdev_ioctl,
+	.s_power = kmb_isp_s_power,
+	.subscribe_event = kmb_isp_subscribe_event,
+	.unsubscribe_event = kmb_isp_unsubscribe_event,
+};
+
+/* sub-device video operations */
+static struct v4l2_subdev_video_ops kmb_isp_subdev_video_ops = {
+	.s_stream = kmb_isp_s_stream,
+	.g_frame_interval = kmb_isp_g_frame_interval,
+	.s_frame_interval = kmb_isp_s_frame_interval,
+};
+
+/* sub-device pad operations */
+static struct v4l2_subdev_pad_ops kmb_isp_subdev_pad_ops = {
+	.set_fmt = kmb_isp_subdev_set_fmt,
+	.get_fmt = kmb_isp_subdev_get_fmt,
+	.enum_mbus_code = kmb_isp_subdev_enum_mbus_code,
+	.enum_frame_interval = kmb_isp_subdev_enum_frame_interval,
+};
+
+/* sub-device operations */
+static const struct v4l2_subdev_ops kmb_isp_subdev_ops = {
+	.core = &kmb_isp_subdev_core_ops,
+	.video = &kmb_isp_subdev_video_ops,
+	.pad = &kmb_isp_subdev_pad_ops,
+};
+
+/* V4L2 control operations */
+static const struct v4l2_ctrl_ops kmb_isp_ctrl_ops = {
+	.s_ctrl = kmb_isp_s_ctrl,
+	.g_volatile_ctrl = kmb_isp_g_ctrl,
+};
+
+static const struct v4l2_ctrl_config transform_hub = {
+	.ops = &kmb_isp_ctrl_ops,
+	.id = V4L2_CID_KMB_CAMERA_TRANSFORM_HUB,
+	.name = "Transform Hub",
+	.type = V4L2_CTRL_TYPE_INTEGER,
+	.min = KMB_CAMERA_TRANSFORM_HUB_NONE,
+	.max = KMB_CAMERA_TRANSFORM_HUB_EPTZ,
+	.def = KMB_CAMERA_TRANSFORM_HUB_NONE,
+	.step = 1,
+	.menu_skip_mask = 0,
+};
+
+static const struct v4l2_ctrl_config camera_mode = {
+	.ops = &kmb_isp_ctrl_ops,
+	.id = V4L2_CID_KMB_CAMERA_MODE,
+	.name = "Camera Mode",
+	.type = V4L2_CTRL_TYPE_INTEGER,
+	.min = KMB_CAMERA_MODE_ULL,
+	.max = KMB_CAMERA_MODE_MONO,
+	.def = KMB_CAMERA_MODE_ULL,
+	.step = 1,
+	.menu_skip_mask = 0,
+};
+
+/**
+ * kmb_isp_initialize_controls - Initialize handled isp controls
+ * @kmb_isp: pointer to isp device
+ *
+ * Return: 0 if successful
+ */
+static int kmb_isp_initialize_controls(struct kmb_isp *kmb_isp)
+{
+	struct kmb_isp_ctrls *ctrls = &kmb_isp->ctrls;
+	int ret;
+
+	ret = v4l2_ctrl_handler_init(&ctrls->handler, 5);
+	if (ret < 0) {
+		dev_err(kmb_isp->dev, "%s: Control handler init failed %d\n",
+				__func__, ret);
+		return ret;
+	}
+
+	ctrls->transform_hub = v4l2_ctrl_new_custom(&ctrls->handler,
+			&transform_hub, NULL);
+	if (!ctrls->transform_hub) {
+		dev_err(kmb_isp->dev, "%s: Init transform hub control failed\n",
+				__func__);
+		return -EINVAL;
+	}
+	ctrls->camera_mode = v4l2_ctrl_new_custom(&ctrls->handler,
+			&camera_mode, NULL);
+	if (!ctrls->camera_mode) {
+		dev_err(kmb_isp->dev, "%s: Init camera mode control failed\n",
+				__func__);
+		return -EINVAL;
+	}
+
+	ctrls->rotate = v4l2_ctrl_new_std(&ctrls->handler, &kmb_isp_ctrl_ops,
+					  V4L2_CID_ROTATE, 0, 270, 90, 0);
+	if (!ctrls->rotate) {
+		dev_err(kmb_isp->dev, "%s: Init rotate control failed\n",
+				__func__);
+		return -EINVAL;
+	}
+
+	if (ctrls->handler.error) {
+		ret = ctrls->handler.error;
+		v4l2_ctrl_handler_free(&ctrls->handler);
+		dev_err(kmb_isp->dev, "%s: Error %d\n", __func__, ret);
+		return ret;
+	}
+
+	kmb_isp->subdev.ctrl_handler = &ctrls->handler;
+	return 0;
+}
+
+/**
+ * kmb_isp_init - Initialize Kmb isp subdevice
+ * @kmb_isp: Pointer to kmb isp device
+ * @dev: Pointer to camera device for which isp will be associated with
+ */
+void kmb_isp_init(struct kmb_isp *kmb_isp, struct device *dev)
+{
+	mutex_init(&kmb_isp->lock);
+	mutex_init(&kmb_isp->cfg_q_lock);
+
+	v4l2_subdev_init(&kmb_isp->subdev, &kmb_isp_subdev_ops);
+	v4l2_set_subdevdata(&kmb_isp->subdev, kmb_isp);
+
+	INIT_LIST_HEAD(&kmb_isp->isp_cfgs_queue);
+	kmb_isp->isp_streaming = false;
+
+	kmb_isp->dev = dev;
+	kmb_isp->channel_id = 0;
+}
+
+/**
+ * kmb_isp_register_entities - Register entities
+ * @kmb_isp: pointer to kmb isp device
+ * @v4l2_dev: pointer to V4L2 device drivers
+ *
+ * Return: 0 if successful
+ */
+int kmb_isp_register_entities(struct kmb_isp *kmb_isp,
+			      struct v4l2_device *v4l2_dev)
+{
+	struct media_pad *pads = kmb_isp->pads;
+	struct device *dev = kmb_isp->dev;
+	int i;
+	int ret;
+
+	kmb_isp->subdev.internal_ops = &kmb_isp_internal_ops;
+	kmb_isp->subdev.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE |
+			V4L2_SUBDEV_FL_HAS_EVENTS;
+	kmb_isp->subdev.entity.function = MEDIA_INTF_T_V4L_SUBDEV;
+	snprintf(kmb_isp->subdev.name,
+		ARRAY_SIZE(kmb_isp->subdev.name), KMB_ISP_DRV_NAME);
+
+	pads[KMB_ISP_SINK_PAD_RAW].flags = MEDIA_PAD_FL_SINK;
+	pads[KMB_ISP_SINK_PAD_SENSOR].flags = MEDIA_PAD_FL_SINK;
+	pads[KMB_ISP_SINK_PAD_CFG].flags = MEDIA_PAD_FL_SINK;
+	pads[KMB_ISP_SRC_PAD_RAW].flags = MEDIA_PAD_FL_SOURCE;
+
+	for (i = 0; i < KMB_ISP_SRC_PADS_NUM; i++)
+		pads[KMB_ISP_SRC_PAD_VID_BASE + i].flags = MEDIA_PAD_FL_SOURCE;
+
+	ret = media_entity_pads_init(&kmb_isp->subdev.entity,
+				     KMB_ISP_PADS_NUM, pads);
+	if (ret < 0) {
+		dev_err(dev, "Fail to init media entity");
+		return ret;
+	}
+
+	ret = kmb_isp_initialize_controls(kmb_isp);
+	if (ret < 0) {
+		dev_err(dev, "Fail to initialize isp controls");
+		return ret;
+	}
+
+	ret = v4l2_device_register_subdev(v4l2_dev, &kmb_isp->subdev);
+	if (ret < 0) {
+		dev_err(dev, "Fail to register media entity");
+		return ret;
+	}
+
+	kmb_isp->cma_vaddr = NULL;
+	kmb_isp->cma_phy_addr = 0;
+
+	ret = kmb_isp_alloc_pipe_cma_area(kmb_isp);
+	if (ret < 0)
+		goto error_unregister_subdev;
+
+	/* kmb config node - isp input */
+	kmb_isp->config.pipe = kmb_isp->pipe;
+	kmb_isp->config.priv = (void *)kmb_isp;
+	kmb_isp->config.dma_dev = kmb_isp->dev;
+	kmb_isp->config.queue_ops = isp_cfg_queue_ops;
+
+	ret = kmb_isp_config_init(&kmb_isp->config);
+	if (ret < 0)
+		goto error_cma_free;
+
+	ret = kmb_isp_config_register(&kmb_isp->config, v4l2_dev);
+	if (ret < 0)
+		goto error_deinit_config;
+
+	ret = media_create_pad_link(
+			&kmb_isp->config.video_out->entity, 0,
+			&kmb_isp->subdev.entity, KMB_ISP_SINK_PAD_CFG,
+			MEDIA_LNK_FL_IMMUTABLE | MEDIA_LNK_FL_ENABLED);
+	if (ret < 0) {
+		dev_err(kmb_isp->dev, "Fail to link %s->%s entities\n",
+			kmb_isp->config.video_out->entity.name,
+			kmb_isp->subdev.entity.name);
+		goto error_unregister_config;
+	}
+
+	return 0;
+
+error_unregister_config:
+	kmb_isp_config_unregister(&kmb_isp->config);
+error_deinit_config:
+	kmb_isp_config_deinit(&kmb_isp->config);
+error_cma_free:
+	kmb_isp_free_pipe_cma_area(kmb_isp);
+error_unregister_subdev:
+	v4l2_device_unregister_subdev(&kmb_isp->subdev);
+	return ret;
+}
+
+/**
+ * kmb_isp_unregister_entities - Unregister this media's entities
+ * @kmb_isp: pointer to kmb isp device
+ */
+void kmb_isp_unregister_entities(struct kmb_isp *kmb_isp)
+{
+	kmb_isp_config_unregister(&kmb_isp->config);
+	mutex_destroy(&kmb_isp->cfg_q_lock);
+	v4l2_ctrl_handler_free(&kmb_isp->ctrls.handler);
+	kmb_isp_free_pipe_cma_area(kmb_isp);
+	mutex_destroy(&kmb_isp->lock);
+	v4l2_device_unregister_subdev(&kmb_isp->subdev);
+}
+
+/**
+ * kmb_isp_get_channel_id - Get ISP xLink channel id
+ * @kmb_isp: pointer to kmb isp device
+ *
+ * Return: xLink channel id
+ */
+u32 kmb_isp_get_channel_id(struct kmb_isp *kmb_isp)
+{
+	return kmb_isp->channel_id;
+}
+
+/**
+ * kmb_isp_get_lrt_transform_hub - Get LRT Transform Hub
+ * @kmb_isp: pointer to kmb isp device
+ *
+ * Return: LRT transform hub
+ */
+u32 kmb_isp_get_lrt_transform_hub(struct kmb_isp *kmb_isp)
+{
+	int transform_hub = v4l2_ctrl_g_ctrl(kmb_isp->ctrls.transform_hub);
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(rt_isp_thb); i++) {
+		if (transform_hub == rt_isp_thb[i][1])
+			return rt_isp_thb[i][0];
+	}
+
+	return rt_isp_thb[0][0];
+}
+
+/**
+ * kmb_isp_get_lrt_camera_mode - Get LRT Camera Mode
+ * @kmb_isp: pointer to kmb isp device
+ *
+ * Return: LRT camera mode
+ */
+u32 kmb_isp_get_lrt_camera_mode(struct kmb_isp *kmb_isp)
+{
+	int camera_mode = v4l2_ctrl_g_ctrl(kmb_isp->ctrls.camera_mode);
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(rt_isp_cam_mode); i++) {
+		if (camera_mode == rt_isp_cam_mode[i][1])
+			return rt_isp_cam_mode[i][0];
+	}
+
+	return rt_isp_cam_mode[0][0];
+}
+
+/**
+ * kmb_isp_get_rotation - Get rotation
+ * @kmb_isp: pointer to kmb isp device
+ *
+ * Return: Rotation 0, 90, 180, 270
+ */
+int kmb_isp_get_rotation(struct kmb_isp *kmb_isp)
+{
+	return v4l2_ctrl_g_ctrl(kmb_isp->ctrls.rotate);
+}
+
+/**
+ * kmb_isp_set_pad_fmt_range - Set pad format range
+ * @kmb_isp: pointer to kmb isp device
+ * @pad: Isp subdevice pad index
+ * @range: Pointer to resolution range to be set
+ *
+ * Return: 0 if successful
+ */
+int kmb_isp_set_pad_fmt_range(struct kmb_isp *kmb_isp, u32 pad,
+			      struct kmb_isp_res_range *range)
+{
+	if (pad >= KMB_ISP_PADS_NUM)
+		return -EINVAL;
+
+	mutex_lock(&kmb_isp->lock);
+	kmb_isp->pad_fmt_caps[pad].range = *range;
+
+	kmb_isp->pad_format[pad].format.width = range->min_width;
+	kmb_isp->pad_format[pad].format.height = range->min_height;
+	mutex_unlock(&kmb_isp->lock);
+
+	dev_dbg(kmb_isp->dev, "Format range pad %d min %dx%d max %dx%d\n",
+		pad, range->min_width, range->min_height,
+		range->max_width, range->max_height);
+
+	return 0;
+}
+
+/**
+ * kmb_isp_set_src_config - Set source configuration information
+ * @kmb_isp: pointer to kmb isp device
+ * @pad: Isp subdevice pad index
+ * @src_config: pointer to source configuration
+ *
+ * Return: 0 if successful
+ */
+int kmb_isp_set_src_config(struct kmb_isp *kmb_isp, u32 pad,
+			   struct kmb_isp_src_config *src_config)
+{
+	if (pad >= KMB_ISP_SINK_PADS_NUM)
+		return -EINVAL;
+
+	mutex_lock(&kmb_isp->lock);
+	kmb_isp->src_config[pad] = *src_config;
+	mutex_unlock(&kmb_isp->lock);
+
+	return 0;
+}
diff --git a/drivers/media/platform/kmb-camera/kmb-isp.h b/drivers/media/platform/kmb-camera/kmb-isp.h
new file mode 100644
index 000000000000..c76137aeaa57
--- /dev/null
+++ b/drivers/media/platform/kmb-camera/kmb-isp.h
@@ -0,0 +1,207 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * kmb-isp.h - KeemBay Camera ISP Driver.
+ *
+ * Copyright (C) 2018-2019 Intel Corporation
+ */
+#ifndef KMB_ISP_H
+#define KMB_ISP_H
+
+#include <linux/xlink.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-ctrls.h>
+
+#include "kmb-isp-config.h"
+#include "kmb-lrt-src.h"
+
+#define KMB_ISP_DRV_NAME "kmb-camera-isp"
+
+#define KMB_ISP_SINK_PAD_SENSOR		0
+#define KMB_ISP_SINK_PAD_CFG		1
+#define KMB_ISP_SINK_PAD_RAW		2
+#define KMB_ISP_SINK_PADS_NUM		3
+
+#define KMB_ISP_SRC_PAD_RAW		KMB_ISP_SINK_PADS_NUM
+
+/*
+ * ISP source pads are connected to video nodes
+ * pads are (base + index) first index is 0
+ */
+#define KMB_ISP_SRC_PAD_VID_BASE	(KMB_ISP_SRC_PAD_RAW + 1)
+#define KMB_ISP_SRC_PADS_NUM		6
+#define KMB_ISP_PADS_NUM		\
+	(KMB_ISP_SINK_PADS_NUM + KMB_ISP_SRC_PADS_NUM + 1)
+
+/* Predefined event queue length */
+#define KMB_ISP_EVT_Q_LEN	8
+
+#define KMB_ISP_MAX_SUPPORTED_FMTS	10
+
+/**
+ * struct kmb_isp_channel_ops - xLink channel ID operations
+ * @accuire_id: accuire xlink channel ID
+ * @free_id: free xlink channel ID
+ */
+struct kmb_isp_channel_ops {
+	int (*accuire_id)(void *priv);
+	void (*free_id)(void *priv, unsigned int id);
+};
+
+/**
+ * enum source_type - Source interface type
+ */
+enum kmb_isp_source_type {
+	KMB_ISP_NONE = 0,
+	KMB_ISP_CSI2 = 1,
+	KMB_ISP_LLVM = 2,
+	KMB_ISP_MEMORY = 3
+};
+
+/**
+ * struct kmb_isp_src_config - Source configuration
+ * @type: source interface type
+ * @num_phy_lanes: number of physical lanes
+ * @controller_num: mipi controller number
+ */
+struct kmb_isp_src_config {
+	enum kmb_isp_source_type type;
+	u32 num_phy_lanes;
+	u32 controller_num;
+};
+
+/**
+ * struct kmb_isp_format - ISP formats description
+ * @code: media bus format
+ * @bayer_pattern: Bayer pattern
+ * @bpp: bits per pixel (for the first plane if several)
+ * @rx_data_type: LRT MIPI data type
+ */
+struct kmb_isp_format {
+	u32 code;
+	u32 bayer_pattern;
+	u32 bpp;
+	IcMipiRxDataTypeT rx_data_type;
+};
+
+/**
+ * struct kmb_isp_res_range - ISP output resolution ranges
+ * @min_width: minimum width supported by the LRT
+ * @min_height: minimum height supported by the LRT
+ * @max_width: maximum width supported by the LRT
+ * @max_height: maximum height supported by the LRT
+ */
+struct kmb_isp_res_range {
+	u32 min_width;
+	u32 min_height;
+	u32 max_width;
+	u32 max_height;
+};
+
+/**
+ * struct kmb_isp_format_range - ISP output resolution ranges
+ * @range: resolution range supported by LRT
+ * @num_fmts: number of supported formats
+ * @code: array of supported media bus formats
+ */
+struct kmb_isp_format_caps {
+	struct kmb_isp_res_range range;
+	u32 num_fmts;
+	u32 code[KMB_ISP_MAX_SUPPORTED_FMTS];
+};
+
+/**
+ * struct kmb_isp_ctrls - KMB Camera isp controls structure
+ * @handler: control handler
+ * @transform_hub: transform hub
+ * @camera_mode: camera mode
+ * @rotate: rotation control
+ * @update: update flag
+ */
+struct kmb_isp_ctrls {
+	struct v4l2_ctrl_handler handler;
+	struct v4l2_ctrl *transform_hub;
+	struct v4l2_ctrl *camera_mode;
+	struct v4l2_ctrl *rotate;
+	u8 update;
+};
+
+/**
+ * struct kmb_isp - KMB Camera ISP device structure
+ * @dev: pointer to basic device structure
+ * @lock: mutex
+ * @thread: pointer to worker thread data
+ * @ipc_dev_handler: xLink IPC device handler
+ * @priv: pointer to private data
+ * @channel_ops: xLink channel id operations
+ * @channel_id: xLink channel id
+ * @cma_phy_addr: ISP channel physical CMA address
+ * @cma_vaddr: ISP channel virtual CMA address
+ * @cfg_q_lock: mutex to serialize access to isp cfg bufferss queue
+ * @isp_cfgs_queue: isp cfg buffers queue
+ * @isp_streaming: flag to indicate isp state
+ * @source_streaming: flag to indicate source state
+ * @source_stopped: Completion to wait until LRT source is stopped
+ * @subdev: V4L2 sub-device
+ * @pads: array of media pad graph objects
+ * @pipe: pointer to media pipeline related information
+ * @pad_format: pad-level media bus formats
+ * @pad_fmt_caps: pad format capabilities
+ * @src_config: array of source configuration data
+ * @ctrls: v4l2 custom controls
+ * @config: KMB ISP Config vnode
+ * @sequence: frame sequence number
+ */
+struct kmb_isp {
+	struct device *dev;
+	struct mutex lock;
+	struct task_struct *thread;
+	struct xlink_handle *ipc_dev_handler;
+
+	void *priv;
+	struct kmb_isp_channel_ops channel_ops;
+	u32 channel_id;
+	u32 cma_phy_addr;
+	void *cma_vaddr;
+
+	struct mutex cfg_q_lock;
+	struct list_head isp_cfgs_queue;
+
+	bool isp_streaming;
+	bool source_streaming;
+	struct completion source_stopped;
+
+	struct v4l2_subdev subdev;
+	struct media_pad pads[KMB_ISP_PADS_NUM];
+	struct media_pipeline *pipe;
+
+	struct v4l2_subdev_format pad_format[KMB_ISP_PADS_NUM];
+	struct kmb_isp_format_caps pad_fmt_caps[KMB_ISP_PADS_NUM];
+	struct kmb_isp_src_config src_config[KMB_ISP_SINK_PADS_NUM];
+
+	struct kmb_isp_ctrls ctrls;
+
+	struct kmb_isp_config config;
+	u32 sequence;
+};
+
+void kmb_isp_init(struct kmb_isp *kmb_isp, struct device *dev);
+
+int kmb_isp_register_entities(struct kmb_isp *kmb_isp,
+			      struct v4l2_device *v4l2_dev);
+void kmb_isp_unregister_entities(struct kmb_isp *kmb_isp);
+
+u32 kmb_isp_get_channel_id(struct kmb_isp *kmb_isp);
+
+u32 kmb_isp_get_lrt_transform_hub(struct kmb_isp *kmb_isp);
+u32 kmb_isp_get_lrt_camera_mode(struct kmb_isp *kmb_isp);
+int kmb_isp_get_rotation(struct kmb_isp *kmb_isp);
+
+int kmb_isp_set_pad_fmt_range(struct kmb_isp *kmb_isp, u32 pad,
+			      struct kmb_isp_res_range *range);
+
+const struct kmb_isp_format *kmb_isp_get_fmt_by_code(u32 code);
+
+int kmb_isp_set_src_config(struct kmb_isp *kmb_isp, u32 pad,
+			   struct kmb_isp_src_config *src_config);
+
+#endif /* KMB_ISP_H */
diff --git a/drivers/media/platform/kmb-camera/kmb-lrt-cmd.h b/drivers/media/platform/kmb-camera/kmb-lrt-cmd.h
new file mode 100644
index 000000000000..27af15e09e1d
--- /dev/null
+++ b/drivers/media/platform/kmb-camera/kmb-lrt-cmd.h
@@ -0,0 +1,106 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * kmb-lrt-cmd.h - KeemBay Camera LRT Commands
+ *
+ * Copyright (C) 2018-2019 Intel Corporation
+ */
+#ifndef KMB_LRT_CMD_H
+#define KMB_LRT_CMD_H
+
+/**************************************************************************************************
+ ~~~  Specific #defines
+ **************************************************************************************************/
+#define IC_EVENT_CTRL_TYPE_MASK 0xFF
+#define IC_INITI_PIPE_SINGLE 0x1
+#define IC_INIT_TRANFORM_HUB_FULL (1 << 4)
+
+// IC_EVENT_TYPE enum to define event messages
+enum {
+	IC_EVENT_TYPE_SUCCESFULL = 0,
+	IC_EVENT_TYPE_CONFIG_ISP_PIPE,
+	IC_EVENT_TYPE_BUILD_ISP_PIPE,
+	IC_EVENT_TYPE_DELETE_ISP_PIPE,
+
+	IC_EVENT_TYPE_INIT_MAX
+};
+
+enum {
+	// Control -> Source
+	IC_EVENT_TYPE_CONFIG_SOURCE = (IC_EVENT_TYPE_INIT_MAX + 1),
+	IC_EVENT_TYPE_START_SOURCE,
+	IC_EVENT_TYPE_STOP_SOURCE,
+	IC_EVENT_TYPE_CONFIG_SOURCE_DYNAMIC,
+	IC_EVENT_TYPE_SOURCE_SEND_USER_DATA,
+
+	// Source -> Control
+	IC_EVENT_TYPE_SOURCE_CONFIGURED,
+	IC_EVENT_TYPE_SOURCE_STARTED,
+	IC_EVENT_TYPE_SOURCE_STOPPED,
+	IC_EVENT_TYPE_SOURCE_DYN_CONFIGURED,
+
+	// Source events
+	IC_EVENT_TYPE_READOUT_START,
+	IC_EVENT_TYPE_READOUT_END,
+	IC_EVENT_TYPE_LINE_REACHED,
+
+	// ISP events
+	IC_EVENT_TYPE_ISP_START,
+	IC_EVENT_TYPE_ISP_END,
+	IC_EVENT_TYPE_STATS_READY,
+	IC_EVENT_TYPE_ISP_CONFIG_ACCEPTED,
+	IC_EVENT_TYPE_ZSL_LOCKED,
+	IC_EVENT_TYPE_CAPTURE_MADE,
+
+	// Isp config events
+	IC_EVENT_TYPE_CONFIG_ISP,
+	IC_EVENT_TYPE_LOCK_ZSL,
+	IC_EVENT_TYPE_CAPTURE,
+	IC_EVENT_TYPE_UNLOCK_ZSL,
+	IC_EVENT_TYPE_ZSL_ADD,
+	IC_EVENT_TYPE_ERROR,
+
+	IC_EVENT_MAX
+};
+
+enum {
+	IC_ERROR_PIPE_INIT = (IC_EVENT_MAX + 1),
+	IC_ERROR_ISP_CONFIG,
+	IC_ERROR_YUV_BUFF_MISSING,
+
+	IC_ERROR_ISP_MAX
+};
+
+enum {
+	IC_ERROR_SRC_MIPI_WRONG_STATE = (IC_ERROR_ISP_MAX + 1),
+	IC_ERROR_SRC_MIPI_BAD_PARAMETER,
+	IC_ERROR_SRC_MIPI_CFG_MISSING,
+	IC_ERROR_SRC_MIPI_CFG_SKIPPED,
+	IC_ERROR_SRC_MIPI_OUT_BUFFERS_NOT_AVAILABLE,
+	IC_ERROR_SRC_MIPI_EOF_TIMEOUT,
+	IC_ERROR_SRC_MIPI_LOC_BUF_NOT_AVAILABLE,
+	IC_ERROR_SRC_MIPI_INTERNAL_ERROR,
+	IC_ERROR_SRC_TRANSMISION_ERROR,
+	IC_ERROR_SRC_DRIVER_UNEXPECTED,
+
+	IC_ERROR_SRC_MIPI_MAX
+};
+
+enum {
+	IC_ERROR_NO_ZSL_BUFFS_AVAILABLE = (IC_ERROR_SRC_MIPI_MAX + 1),
+	IC_ERROR_TRIGGER_NOT_EXISTING_BUFF,
+
+	IC_ERROR_ISP_CTRL_MAX,
+};
+
+typedef struct __attribute__((aligned(64), packed)) icEvS {
+	struct {
+		uint32_t instId;
+		uint32_t seqNr;
+		uint32_t userDataBaseAddr01;
+		uint32_t userDataBaseAddr02;
+		int64_t ts;
+	} EvInfo;
+	volatile uint32_t ctrl; /* See IC_EVENT_TYPE_* */
+} icEv;
+
+#endif /* KMB_LRT_CMD_H */
diff --git a/drivers/media/platform/kmb-camera/kmb-lrt-frame.h b/drivers/media/platform/kmb-camera/kmb-lrt-frame.h
new file mode 100644
index 000000000000..1005e03744c7
--- /dev/null
+++ b/drivers/media/platform/kmb-camera/kmb-lrt-frame.h
@@ -0,0 +1,70 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * kmb-lrt-frame.h - KeemBay Camera LRT frame data
+ *
+ * Copyright (C) 2018-2019 Intel Corporation
+ */
+
+#ifndef KMB_LRT_FRAME_H_
+#define KMB_LRT_FRAME_H_
+
+typedef enum frameTypes {
+     YUV422i,   // interleaved 8 bit
+     YUV444p,   // planar 4:4:4 format
+     YUV420p,   // planar 4:2:0 format
+     YUV422p,   // planar 8 bit
+     YUV400p,   // 8-bit greyscale
+     RGBA8888,  // RGBA interleaved stored in 32 bit word
+     RGB888,    // Planar 8 bit RGB data
+     RGB888p,   // Planar 8 bit RGB data
+     RGB888i,   // Interleaved 8 bit RGB data
+     BGR888p,   // Planar 8 bit BGR data
+     BGR888i,   // Interleaved 8 bit BGR data
+     LUT2,      // 1 bit  per pixel, Lookup table (used for graphics layers)
+     LUT4,      // 2 bits per pixel, Lookup table (used for graphics layers)
+     LUT16,     // 4 bits per pixel, Lookup table (used for graphics layers)
+     RAW16,     // save any raw type (8, 10, 12bit) on 16 bits
+     RAW14,     // 14bit value in 16bit storage
+     RAW12,     // 12bit value in 16bit storage
+     RAW10,     // 10bit value in 16bit storage
+     RAW8,
+     PACK10,    // SIPP 10bit packed format
+     PACK12,    // SIPP 12bit packed format
+     YUV444i,
+     NV12,
+     NV21,
+     BITSTREAM, // used for video encoder bitstream
+     HDR,
+     NV12PACK10, // nv12 format with pixels encoded in pack 10
+
+     // MIPI YUV Formats:
+     MIPI_YUV8BIT420,           // MIPI Specification YUV 8 Bit 420 (DT 0x18)
+     MIPI_YUV10BIT420,          // MIPI Specification YUV 10 Bit 420 (DT 0x19)
+     MIPI_YUV10BIT420_PACK,     // MIPI Specification YUV 10 Bit 420 (DT 0x19) Packed output data.
+     MIPI_YUV8BIT420LEG,        // MIPI Specification YUV 8 Bit 420 Legacy (DT 0x1A)
+     MIPI_YUV8BIT420CSPS,       // MIPI Specification YUV 8 Bit 420 CSPS (DT 0x1C)
+     MIPI_YUV10BIT420CSPS,      // MIPI Specification YUV 8 Bit 420 CSPS (DT 0x1D)
+     MIPI_YUV10BIT420CSPS_PACK, // MIPI Specification YUV 8 Bit 420 CSPS (DT 0x1D) Packed output data
+     MIPI_YUV8BIT422,           // MIPI Specification YUV 8 Bit 422 (DT 0x1E)
+     MIPI_YUV10BIT422,          // MIPI Specification YUV 10 Bit 422 (DT 0x1F)
+     MIPI_YUV10BIT422_PACK,     // MIPI Specification YUV 10 Bit 422 (DT 0x1F) Packed output data
+     NONE
+} frameType;
+
+typedef struct frameSpecs {
+     uint16_t   type;      // Values from frameType
+     uint16_t   height;    // width in pixels
+     uint16_t   width;     // width in pixels
+     uint16_t   stride;    // defined as distance in bytes from pix(y,x) to pix(y+1,x)
+     uint16_t   bitsPP;    // bits per pixel (for unpacked types set 8 or 16, for NV12 set only luma pixel size)
+} frameSpec;
+
+typedef struct frameElements {
+     frameSpec spec;
+     uint64_t p1;  // Addr to first image plane
+     uint64_t p2;  // Addr to second image plane (if used)
+     uint64_t p3;  // Addr to third image plane  (if used)
+     int64_t  ts;  // Timestamp in NS
+} frameBuffer;
+
+#endif /* KMB_LRT_FRAME_H_ */
diff --git a/drivers/media/platform/kmb-camera/kmb-lrt-pipe.h b/drivers/media/platform/kmb-camera/kmb-lrt-pipe.h
new file mode 100644
index 000000000000..44db48b177e5
--- /dev/null
+++ b/drivers/media/platform/kmb-camera/kmb-lrt-pipe.h
@@ -0,0 +1,87 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * kmb-lrt-pipe.h - KeemBay Camera LRT pipe definitions
+ *
+ * Copyright (C) 2018-2019 Intel Corporation
+ */
+#ifndef KMB_LRT_PIPE_H
+#define KMB_LRT_PIPE_H
+
+#include "kmb-lrt-src.h"
+
+/**************************************************************************************************
+ ~~~  Specific #defines
+ **************************************************************************************************/
+#define PIPE_TYPE_ISP_MAX_EXP   3
+
+enum {
+    PIPE_TYPE_ISP_ISP_ULL        = 1,
+    PIPE_TYPE_ISP_ISP_2DOL,
+    PIPE_TYPE_ISP_ISP_3DOL,
+    PIPE_TYPE_ISP_ISP_MONO,
+    PIPE_TYPE_SRC_NO_ISP,
+
+    PIPE_TYPE_MAX
+};
+
+enum {
+    SRC_TYPE_ALLOC_VPU_DATA_MIPI = 0,
+    SRC_TYPE_ALLOC_VPU_DATA_DBG,
+    SRC_TYPE_ALLOC_ARM_DATA_ARM,
+    SRC_TYPE_ALLOC_ARM_DATA_MIPI,
+    SRC_TYPE_ALLOC_ARM_DATA_DBG,
+
+    SRC_TYPE_ALLOC_DATA_MAX
+};
+
+enum {
+    PIPE_TRANSFORM_HUB_NONE     = 0,
+    PIPE_TRANSFORM_HUB_BASIC,
+    PIPE_TRANSFORM_HUB_FULL,
+    PIPE_TRANSFORM_HUB_STITCH,
+    PIPE_TRANSFORM_HUB_EPTZ,
+
+    PIPE_TRANSFORM_HUB_MAX
+};
+
+enum {
+    PIPE_OUTPUT_ID_RAW       = 0,
+    PIPE_OUTPUT_ID_ISP_CTRL,
+    PIPE_OUTPUT_ID_0,
+    PIPE_OUTPUT_ID_1,
+    PIPE_OUTPUT_ID_2,
+    PIPE_OUTPUT_ID_3,
+    PIPE_OUTPUT_ID_4,
+    PIPE_OUTPUT_ID_5,
+    PIPE_OUTPUT_ID_6,
+
+    PIPE_OUTPUT_ID_MAX
+};
+// IC_EVENT_TYPE enum to define event messages
+
+typedef struct {
+    uint32_t     chID;
+    icImgSize    frmRes;
+} channelCfg;
+
+typedef struct __attribute__((aligned(64))) pipeConfigEvS {
+    uint8_t     pipeID;
+    uint8_t     pipeType;
+    uint8_t     srcType;
+    uint8_t     pipeTransHub;
+    icImgSize   inIspRes;
+    icImgSize   outIspRes;
+    uint16_t    inIspStride; // in bytes
+    uint32_t    inExpOffsets[PIPE_TYPE_ISP_MAX_EXP]; //in bytes
+    icImgSize   outMinRes[PIPE_OUTPUT_ID_MAX];
+    icImgSize   outMaxRes[PIPE_OUTPUT_ID_MAX];
+    channelCfg  pipeXlinkChann[PIPE_OUTPUT_ID_MAX];
+    uint8_t     keepAspectRatio;
+    uint8_t     inDataWidth;
+    uint8_t     inDataPacked;
+    uint8_t     outDataWidth;
+    uint64_t    vpuInternalMemAddr;
+    uint32_t    vpuInternalMemSize;
+} pipeConfigEv;
+
+#endif  /* KMB_LRT_PIPE_H */
diff --git a/drivers/media/platform/kmb-camera/kmb-lrt-src.h b/drivers/media/platform/kmb-camera/kmb-lrt-src.h
new file mode 100644
index 000000000000..8bb2f1d46f7d
--- /dev/null
+++ b/drivers/media/platform/kmb-camera/kmb-lrt-src.h
@@ -0,0 +1,124 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * kmb-lrt-src.h - KeemBay Camera LRT Source Configuration
+ *
+ * Copyright (C) 2018-2019 Intel Corporation
+ */
+
+#ifndef KMB_LRT_SRC_H
+#define KMB_LRT_SRC_H
+
+/**************************************************************************************************
+ ~~~  Specific #defines
+ **************************************************************************************************/
+typedef struct {
+	uint32_t w;
+	uint32_t h;
+} icImgSize;
+
+typedef struct {
+	int32_t x1;
+	int32_t y1;
+	int32_t x2;
+	int32_t y2;
+} icImgRect;
+
+// 6 hw mipi/cif input device supported by myriad2
+typedef enum {
+	IC_SOURCE_0 = 0,
+	IC_SOURCE_1 = 1,
+	IC_SOURCE_2 = 2,
+	IC_SOURCE_3 = 3,
+	IC_SOURCE_4 = 4,
+	IC_SOURCE_5 = 5,
+} icSourceInstance;
+
+/* Bayer pattern order */
+typedef enum {
+	IC_BAYER_FORMAT_GRBG = 0,
+	IC_BAYER_FORMAT_RGGB = 1,
+	IC_BAYER_FORMAT_GBRG = 2,
+	IC_BAYER_FORMAT_BGGR = 3,
+} icBayerFormat;
+
+//list of myriad receiver Id's  (unified list) for a specific sensor
+// read the documentation, as IC_MIPI_CTRL_0 can be connected just to 2 different receivers
+typedef enum {
+	IC_SIPP_DEVICE0 = 0,
+	IC_SIPP_DEVICE1 = 1,
+	IC_SIPP_DEVICE2 = 2,
+	IC_SIPP_DEVICE3 = 3,
+	IC_CIF0_DEVICE4 = 4,
+	IC_CIF1_DEVICE5 = 5
+} IcMipiRxCtrlRecNoT;
+
+// all mipi controller from chip
+typedef enum {
+	IC_MIPI_CTRL_0 = 0,
+	IC_MIPI_CTRL_1,
+	IC_MIPI_CTRL_2,
+	IC_MIPI_CTRL_3,
+	IC_MIPI_CTRL_4,
+	IC_MIPI_CTRL_5
+} IcMipiRxCtrlNoT;
+
+// all sported raw, sensor input formats
+typedef enum {
+	IC_IPIPE_YUV_420_B8 = 0x18,
+	IC_IPIPE_YUV_420_B10 = 0x19,
+	IC_IPIPE_YUV_420_B8_L = 0x1A,
+	IC_IPIPE_YUV_420_B8_CSPS = 0x1C,
+	IC_IPIPE_YUV_420_B10_CSPS = 0x1D,
+	IC_IPIPE_YUV_422_B8 = 0x1E,
+	IC_IPIPE_YUV_422_B10 = 0x1F,
+	IC_IPIPE_RAW_8 = 0x2A, // feet to mipi CSI standard
+	IC_IPIPE_RAW_10 = 0x2B,
+	IC_IPIPE_RAW_12 = 0x2C,
+	IC_IPIPE_RAW_14 = 0x2D,
+	IC_IPIPE_EMBEDDED_8BIT = 0x12
+} IcMipiRxDataTypeT;
+
+/*
+ * Per-source configuration of parameters which can be modified dynamically
+ * (the source does not need to be stopped).  Settings will take effect during
+ * the next blanking interval.
+ */
+typedef struct {
+	/*
+     * Line number upon which IC_EVENT_TYPE_LINE REACHED will be sent
+     * to the Leon OS.  Set to -1 to disable notification.
+     */
+	int32_t notificationLine;
+} icSourceConfigDynamic;
+
+// mipiRx, receiver Configuration structure
+typedef struct {
+	uint32_t controllerNo;
+	uint32_t noLanes;
+	uint32_t laneRateMbps;
+	uint32_t dataType;
+	uint32_t dataMode;
+	uint32_t recNrl;
+} icMipiConfig;
+
+typedef struct __attribute__((aligned(64))) {
+	icImgSize cameraOutputSize;
+	icImgRect cropWindow;
+
+	/*
+     * Bayer Format - Raw, Demosaic and LSC blocks should be programmed
+     * to match the Bayer order specified here.
+     */
+	uint32_t bayerFormat;
+	uint32_t bitsPerPixel;
+
+	/* mipi RX data configuration     */
+	icMipiConfig mipiRxData;
+
+	uint32_t noExposure;
+	uint32_t metadataWidth;
+	uint32_t metadataHeight;
+	uint32_t metadataDataType;
+} icSourceConfig;
+
+#endif /* KMB_LRT_SRC_H */
diff --git a/drivers/media/platform/kmb-camera/kmb-video.c b/drivers/media/platform/kmb-camera/kmb-video.c
new file mode 100644
index 000000000000..7d78017d3e18
--- /dev/null
+++ b/drivers/media/platform/kmb-camera/kmb-video.c
@@ -0,0 +1,2231 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * kmb-video.c - KeemBay Camera Video node Driver.
+ *
+ * Copyright (C) 2018-2019 Intel Corporation
+ */
+#include <linux/kthread.h>
+#include <linux/freezer.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-ioctl.h>
+#include <media/videobuf2-dma-contig.h>
+#include <media/v4l2-mc.h>
+#include <linux/kmb-isp-ctl.h>
+
+#include "kmb-video.h"
+#include "kmb-lrt-pipe.h"
+#include "kmb-lrt-frame.h"
+
+#define KMB_RT_VID_CH_DATA_SIZE		1024
+#define KMB_RT_VID_CH_TIMEOUT_MS	5000
+#define RT_DATA_CH_ID_VID_BASE		50
+#define RT_DATA_CH_ID_RAW_IN		40
+
+#define KMB_VIDEO_TYPE_IS_RAW(ptr_kmb_vid)		\
+	(kmb_vid->type == KMB_VIDEO_RAW_INPUT ||	\
+	kmb_vid->type == KMB_VIDEO_RAW_OUTPUT)
+
+/* Kmb video format info structure */
+struct kmb_video_fmt_info {
+	const char *description;
+	u32 code;
+	u32 pixelformat;
+	frameType type;
+	u32 colorspace;
+	unsigned int planes;
+	unsigned int bpp;
+	bool packed;
+	unsigned int h_subsample;
+	unsigned int v_subsample;
+	bool contiguous_memory;
+};
+
+/* Supported video formats */
+static const struct kmb_video_fmt_info video_formats[] = {
+	{
+		.description = "NV12",
+		.code = MEDIA_BUS_FMT_YUYV8_1_5X8,
+		.pixelformat = V4L2_PIX_FMT_NV12,
+		.type = NV12,
+		.colorspace = V4L2_COLORSPACE_JPEG,
+		.planes = 2,
+		.bpp = 8,
+		.packed = true,
+		.h_subsample = 1,
+		.v_subsample = 2,
+		.contiguous_memory = true,
+	},
+	{
+		.description = "Planar YUV 4:2:0",
+		.code = MEDIA_BUS_FMT_UYYVYY8_0_5X24,
+		.pixelformat = V4L2_PIX_FMT_YUV420,
+		.type = YUV420p,
+		.colorspace = V4L2_COLORSPACE_JPEG,
+		.planes = 3,
+		.bpp = 8,
+		.packed = true,
+		.h_subsample = 2,
+		.v_subsample = 2,
+		.contiguous_memory = false,
+	},
+	{
+		.description = "Planar YUV 4:4:4",
+		.code = MEDIA_BUS_FMT_YUV8_1X24,
+		.pixelformat = V4L2_PIX_FMT_YUV444,
+		.type = YUV444p,
+		.colorspace = V4L2_COLORSPACE_JPEG,
+		.planes = 3,
+		.bpp = 8,
+		.packed = false,
+		.h_subsample = 1,
+		.v_subsample = 1,
+		.contiguous_memory = false,
+	},
+	{
+		.description = "MIPI Specification YUV 8 Bit 4:2:0",
+		.code = MEDIA_BUS_FMT_VUY8_1X24,
+		.pixelformat = V4L2_PIX_FMT_YUV420_MIPI8,
+		.type = MIPI_YUV8BIT420,
+		.colorspace = V4L2_COLORSPACE_JPEG,
+		.planes = 1,
+		.bpp = 12,
+		.packed = true,
+		.h_subsample = 1,
+		.v_subsample = 1,
+		.contiguous_memory = false,
+	},
+	{
+		.description = "MIPI Specification YUV 10 Bit 4:2:0",
+		.code = MEDIA_BUS_FMT_YUV10_1X30,
+		.pixelformat = V4L2_PIX_FMT_YUV420_MIPI10,
+		.type = MIPI_YUV10BIT420,
+		.colorspace = V4L2_COLORSPACE_JPEG,
+		.planes = 1,
+		.bpp = 24,
+		.packed = true,
+		.h_subsample = 1,
+		.v_subsample = 1,
+		.contiguous_memory = false,
+	},
+	{
+		.description = "MIPI Specification YUV 10 Bit 4:2:0 packed",
+		.code = MEDIA_BUS_FMT_YVYU10_1X20,
+		.pixelformat = V4L2_PIX_FMT_YUV420_MIPI10P,
+		.type = MIPI_YUV10BIT420_PACK,
+		.colorspace = V4L2_COLORSPACE_JPEG,
+		.planes = 1,
+		.bpp = 15,
+		.packed = true,
+		.h_subsample = 1,
+		.v_subsample = 1,
+		.contiguous_memory = false,
+	},
+	{
+		.description = "MIPI Specification YUV 8 Bit 4:2:0 Legacy",
+		.code = MEDIA_BUS_FMT_YVYU8_2X8,
+		.pixelformat = V4L2_PIX_FMT_YUV420_MIPI8L,
+		.type = MIPI_YUV8BIT420LEG,
+		.colorspace = V4L2_COLORSPACE_JPEG,
+		.planes = 1,
+		.bpp = 12,
+		.packed = true,
+		.h_subsample = 1,
+		.v_subsample = 1,
+		.contiguous_memory = false,
+	},
+	{
+		.description = "MIPI Specification YUV 8 Bit 4:2:0 CSPS",
+		.code = MEDIA_BUS_FMT_YUYV8_2X8,
+		.pixelformat = V4L2_PIX_FMT_YUV420_MIPI8CS,
+		.type = MIPI_YUV8BIT420CSPS,
+		.colorspace = V4L2_COLORSPACE_JPEG,
+		.planes = 1,
+		.bpp = 12,
+		.packed = true,
+		.h_subsample = 1,
+		.v_subsample = 1,
+		.contiguous_memory = false,
+	},
+	{
+		.description = "MIPI Specification YUV 10 Bit 4:2:0 CSPS",
+		.code = MEDIA_BUS_FMT_UYVY10_1X20,
+		.pixelformat = V4L2_PIX_FMT_YUV420_MIPI10CS,
+		.type = MIPI_YUV10BIT420CSPS,
+		.colorspace = V4L2_COLORSPACE_JPEG,
+		.planes = 1,
+		.bpp = 24,
+		.packed = true,
+		.h_subsample = 1,
+		.v_subsample = 1,
+		.contiguous_memory = false,
+	},
+	{
+		.description = "MIPI YUV 10 Bit 4:2:0 CSPS Packed",
+		.code = MEDIA_BUS_FMT_VYUY10_1X20,
+		.pixelformat = V4L2_PIX_FMT_YUV420_MIPI10CSP,
+		.type = MIPI_YUV10BIT420CSPS_PACK,
+		.colorspace = V4L2_COLORSPACE_JPEG,
+		.planes = 1,
+		.bpp = 15,
+		.packed = true,
+		.h_subsample = 1,
+		.v_subsample = 1,
+		.contiguous_memory = false,
+	},
+	{
+		.description = "MIPI Specification YUV 8 Bit 4:2:2",
+		.code = MEDIA_BUS_FMT_YVYU8_1X16,
+		.pixelformat = V4L2_PIX_FMT_YUV422_MIPI8,
+		.type = MIPI_YUV8BIT422,
+		.colorspace = V4L2_COLORSPACE_JPEG,
+		.planes = 1,
+		.bpp = 16,
+		.packed = true,
+		.h_subsample = 1,
+		.v_subsample = 1,
+		.contiguous_memory = false,
+	},
+	{
+		.description = "MIPI Specification YUV 10 Bit 4:2:2",
+		.code = MEDIA_BUS_FMT_VYUY10_2X10,
+		.pixelformat = V4L2_PIX_FMT_YUV422_MIPI10,
+		.type = MIPI_YUV10BIT422,
+		.colorspace = V4L2_COLORSPACE_JPEG,
+		.planes = 1,
+		.bpp = 32,
+		.packed = true,
+		.h_subsample = 1,
+		.v_subsample = 1,
+		.contiguous_memory = false,
+	},
+	{
+		.description = "MIPI Specification YUV 10 Bit 4:2:2 Packed",
+		.code = MEDIA_BUS_FMT_YUYV10_2X10,
+		.pixelformat = V4L2_PIX_FMT_YUV422_MIPI10P,
+		.type = MIPI_YUV10BIT422_PACK,
+		.colorspace = V4L2_COLORSPACE_JPEG,
+		.planes = 1,
+		.bpp = 20,
+		.packed = true,
+		.h_subsample = 1,
+		.v_subsample = 1,
+		.contiguous_memory = false,
+	},
+	{
+		.description = "RAW 8 Garyscale",
+		.code = MEDIA_BUS_FMT_Y8_1X8,
+		.pixelformat = V4L2_PIX_FMT_GREY,
+		.type = RAW8,
+		.colorspace = V4L2_COLORSPACE_JPEG,
+		.planes = 1,
+		.bpp = 8,
+		.packed = false,
+		.h_subsample = 1,
+		.v_subsample = 1,
+		.contiguous_memory = false,
+	},
+	{
+		.description = "RAW 10 Grayscale",
+		.code = MEDIA_BUS_FMT_Y10_1X10,
+		.pixelformat = V4L2_PIX_FMT_Y10,
+		.type = RAW10,
+		.colorspace = V4L2_COLORSPACE_JPEG,
+		.planes = 1,
+		.bpp = 10,
+		.packed = false,
+		.h_subsample = 1,
+		.v_subsample = 1,
+		.contiguous_memory = false,
+	}
+};
+
+static const struct kmb_video_fmt_info raw_formats[] = {
+	{
+		.description = "10bit Bayer BGGR format",
+		.code = MEDIA_BUS_FMT_SBGGR10_1X10,
+		.pixelformat = V4L2_PIX_FMT_SBGGR10,
+		.type = RAW10,
+		.colorspace = V4L2_COLORSPACE_RAW,
+		.planes = 1,
+		.bpp = 10,
+		.packed = false,
+		.h_subsample = 1,
+		.v_subsample = 1,
+		.contiguous_memory = true,
+	},
+	{
+		.description = "10bit Bayer GBRG format",
+		.code = MEDIA_BUS_FMT_SGBRG10_1X10,
+		.pixelformat = V4L2_PIX_FMT_SGBRG10,
+		.type = RAW10,
+		.colorspace = V4L2_COLORSPACE_RAW,
+		.planes = 1,
+		.bpp = 10,
+		.packed = false,
+		.h_subsample = 1,
+		.v_subsample = 1,
+		.contiguous_memory = true,
+	},
+	{
+		.description = "10bit Bayer GRBG format",
+		.code = MEDIA_BUS_FMT_SGRBG10_1X10,
+		.pixelformat = V4L2_PIX_FMT_SGRBG10,
+		.type = RAW10,
+		.colorspace = V4L2_COLORSPACE_RAW,
+		.planes = 1,
+		.bpp = 10,
+		.packed = false,
+		.h_subsample = 1,
+		.v_subsample = 1,
+		.contiguous_memory = true,
+	},
+	{
+		.description = "10bit Bayer RGGB format",
+		.code = MEDIA_BUS_FMT_SRGGB10_1X10,
+		.pixelformat = V4L2_PIX_FMT_SRGGB10,
+		.type = RAW10,
+		.colorspace = V4L2_COLORSPACE_RAW,
+		.planes = 1,
+		.bpp = 10,
+		.packed = false,
+		.h_subsample = 1,
+		.v_subsample = 1,
+		.contiguous_memory = true,
+	},
+	{
+		.description = "10bit Bayer BGGR packed format",
+		.code = MEDIA_BUS_FMT_SBGGR10_1X10,
+		.pixelformat = V4L2_PIX_FMT_SBGGR10P,
+		.type = RAW10,
+		.colorspace = V4L2_COLORSPACE_RAW,
+		.planes = 1,
+		.bpp = 10,
+		.packed = true,
+		.h_subsample = 1,
+		.v_subsample = 1,
+		.contiguous_memory = true,
+	},
+	{
+		.description = "10bit Bayer GBRG packed format",
+		.code = MEDIA_BUS_FMT_SGBRG10_1X10,
+		.pixelformat = V4L2_PIX_FMT_SGBRG10P,
+		.type = RAW10,
+		.colorspace = V4L2_COLORSPACE_RAW,
+		.planes = 1,
+		.bpp = 10,
+		.packed = true,
+		.h_subsample = 1,
+		.v_subsample = 1,
+		.contiguous_memory = true,
+	},
+	{
+		.description = "10bit Bayer GRBG packed format",
+		.code = MEDIA_BUS_FMT_SGRBG10_1X10,
+		.pixelformat = V4L2_PIX_FMT_SGRBG10P,
+		.type = RAW10,
+		.colorspace = V4L2_COLORSPACE_RAW,
+		.planes = 1,
+		.bpp = 10,
+		.packed = true,
+		.h_subsample = 1,
+		.v_subsample = 1,
+		.contiguous_memory = true,
+	},
+	{
+		.description = "10bit Bayer RGGB packed format",
+		.code = MEDIA_BUS_FMT_SRGGB10_1X10,
+		.pixelformat = V4L2_PIX_FMT_SRGGB10P,
+		.type = RAW10,
+		.colorspace = V4L2_COLORSPACE_RAW,
+		.planes = 1,
+		.bpp = 10,
+		.packed = true,
+		.h_subsample = 1,
+		.v_subsample = 1,
+		.contiguous_memory = true,
+	},
+	{
+		.description = "12bit Bayer BGGR format",
+		.code = MEDIA_BUS_FMT_SBGGR12_1X12,
+		.pixelformat = V4L2_PIX_FMT_SBGGR12,
+		.type = RAW12,
+		.colorspace = V4L2_COLORSPACE_RAW,
+		.planes = 1,
+		.bpp = 12,
+		.packed = false,
+		.h_subsample = 1,
+		.v_subsample = 1,
+		.contiguous_memory = true,
+	},
+	{
+		.description = "12bit Bayer GBRG format",
+		.code = MEDIA_BUS_FMT_SGBRG12_1X12,
+		.pixelformat = V4L2_PIX_FMT_SGBRG12,
+		.type = RAW12,
+		.colorspace = V4L2_COLORSPACE_RAW,
+		.planes = 1,
+		.bpp = 12,
+		.packed = false,
+		.h_subsample = 1,
+		.v_subsample = 1,
+		.contiguous_memory = true,
+	},
+	{
+		.description = "12bit Bayer GRBG format",
+		.code = MEDIA_BUS_FMT_SGRBG12_1X12,
+		.pixelformat = V4L2_PIX_FMT_SGRBG12,
+		.type = RAW12,
+		.colorspace = V4L2_COLORSPACE_RAW,
+		.planes = 1,
+		.bpp = 12,
+		.packed = false,
+		.h_subsample = 1,
+		.v_subsample = 1,
+		.contiguous_memory = true,
+	},
+	{
+		.description = "12bit Bayer RGGB format",
+		.code = MEDIA_BUS_FMT_SRGGB12_1X12,
+		.pixelformat = V4L2_PIX_FMT_SRGGB12,
+		.type = RAW12,
+		.colorspace = V4L2_COLORSPACE_RAW,
+		.planes = 1,
+		.bpp = 12,
+		.packed = false,
+		.h_subsample = 1,
+		.v_subsample = 1,
+		.contiguous_memory = true,
+	},
+	{
+		.description = "12bit Bayer BGGR packed format",
+		.code = MEDIA_BUS_FMT_SBGGR12_1X12,
+		.pixelformat = V4L2_PIX_FMT_SBGGR12P,
+		.type = RAW12,
+		.colorspace = V4L2_COLORSPACE_RAW,
+		.planes = 1,
+		.bpp = 12,
+		.packed = true,
+		.h_subsample = 1,
+		.v_subsample = 1,
+		.contiguous_memory = true,
+	},
+	{
+		.description = "12bit Bayer GBRG packed format",
+		.code = MEDIA_BUS_FMT_SGBRG12_1X12,
+		.pixelformat = V4L2_PIX_FMT_SGBRG12P,
+		.type = RAW12,
+		.colorspace = V4L2_COLORSPACE_RAW,
+		.planes = 1,
+		.bpp = 12,
+		.packed = true,
+		.h_subsample = 1,
+		.v_subsample = 1,
+		.contiguous_memory = true,
+	},
+	{
+		.description = "12bit Bayer GRBG packed format",
+		.code = MEDIA_BUS_FMT_SGRBG12_1X12,
+		.pixelformat = V4L2_PIX_FMT_SGRBG12P,
+		.type = RAW12,
+		.colorspace = V4L2_COLORSPACE_RAW,
+		.planes = 1,
+		.bpp = 12,
+		.packed = true,
+		.h_subsample = 1,
+		.v_subsample = 1,
+		.contiguous_memory = true,
+	},
+	{
+		.description = "12bit Bayer RGGB packed format",
+		.code = MEDIA_BUS_FMT_SRGGB12_1X12,
+		.pixelformat = V4L2_PIX_FMT_SRGGB12P,
+		.type = RAW12,
+		.colorspace = V4L2_COLORSPACE_RAW,
+		.planes = 1,
+		.bpp = 12,
+		.packed = true,
+		.h_subsample = 1,
+		.v_subsample = 1,
+		.contiguous_memory = true,
+	},
+	{
+		.description = "10bit Grayscale format",
+		.code = MEDIA_BUS_FMT_Y10_1X10,
+		.pixelformat = V4L2_PIX_FMT_Y10,
+		.type = RAW10,
+		.colorspace = V4L2_COLORSPACE_RAW,
+		.planes = 1,
+		.bpp = 10,
+		.packed = false,
+		.h_subsample = 1,
+		.v_subsample = 1,
+		.contiguous_memory = true,
+	},
+};
+
+/**
+ * kmb_video_from_v4l2 - Get kmb video device file handler
+ * @fh: pointer to V4L2 file handler
+ *
+ * Get kmb video device file handler by given V4L2 file handler
+ *
+ * Return: pointer to kmb video file handler
+ */
+static inline struct kmb_video_fh *kmb_video_from_v4l2(struct v4l2_fh *fh)
+{
+	return container_of(fh, struct kmb_video_fh, fh);
+}
+
+/**
+ * kmb_video_get_fmt_info_by_pixfmt - Get KeemBay video format info
+ * @vid_fh: pointer to V4L2 sub-device file handle
+ * @pix_fmt: v4l2 pixel format
+ *
+ * Return: kmb video format info or NULL
+ */
+static const struct kmb_video_fmt_info *
+kmb_video_get_fmt_info_by_pixfmt(struct kmb_video_fh *vid_fh, u32 pix_fmt)
+{
+	struct kmb_video *kmb_vid = vid_fh->kmb_vid;
+	const struct kmb_video_fmt_info *arr = video_formats;
+	int i, n = ARRAY_SIZE(video_formats);
+
+	if (KMB_VIDEO_TYPE_IS_RAW(kmb_vid)) {
+		arr = raw_formats;
+		n = ARRAY_SIZE(raw_formats);
+	}
+
+	for (i = 0; i < n; i++) {
+		if (arr[i].pixelformat == pix_fmt)
+			return &arr[i];
+	}
+	return NULL;
+}
+
+/**
+ * kmb_video_get_fmt_info_by_code - Get KeemBay video format info
+ * @vid_fh: pointer to V4L2 sub-device file handle
+ * @code: media bus format code
+ * @packed: requested format is packed/unpacked
+ *
+ * Use packed flag only for raw formats
+ *
+ * Return: kmb video format info or NULL
+ */
+static const struct kmb_video_fmt_info *
+kmb_video_get_fmt_info_by_code(struct kmb_video_fh *vid_fh, u32 code,
+			       bool packed)
+{
+	struct kmb_video *kmb_vid = vid_fh->kmb_vid;
+	const struct kmb_video_fmt_info *arr = video_formats;
+	int i, n = ARRAY_SIZE(video_formats);
+
+	if (KMB_VIDEO_TYPE_IS_RAW(kmb_vid)) {
+		arr = raw_formats;
+		n = ARRAY_SIZE(raw_formats);
+
+		for (i = 0; i < n; i++)
+			if (arr[i].code == code && arr[i].packed == packed)
+				return &arr[i];
+	} else {
+		for (i = 0; i < n; i++)
+			if (arr[i].code == code)
+				return &arr[i];
+	}
+
+	return NULL;
+}
+
+/**
+ * kmb_video_insert_buf - Insert output buffer in queue
+ * @vid_fh: pointer to V4L2 sub-device file handle
+ * @buf: video output buffer to insert
+ *
+ * Return: 0 if successful
+ */
+static void kmb_video_insert_buf(struct kmb_video_fh *vid_fh,
+				 struct kmb_frame_buffer *buf)
+{
+	mutex_lock(&vid_fh->lock);
+	INIT_LIST_HEAD(&buf->list);
+	list_add_tail(&buf->list, &vid_fh->dma_queue);
+	mutex_unlock(&vid_fh->lock);
+}
+
+/**
+ * kmb_video_buf_discard - Discard vb buffer
+ * @buf: video output buffer
+ */
+static void kmb_video_buf_discard(struct kmb_frame_buffer *buf)
+{
+	list_del(&buf->list);
+	vb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);
+}
+
+/**
+ * kmb_video_process_buf - Process output buffer
+ * @vid_fh: pointer to V4L2 sub-device file handle
+ * @buf: video output buffer to insert
+ *
+ * Return: 0 if successful
+ */
+static int kmb_video_process_buf(struct kmb_video_fh *vid_fh,
+				 struct kmb_frame_buffer *buf)
+{
+	struct kmb_video *kmb_vid = vid_fh->kmb_vid;
+	const struct kmb_video_fmt_info *info;
+	frameBuffer rt_frame_buf;
+	uint32_t rt_frame_buf_size;
+	int ret;
+
+	info = kmb_video_get_fmt_info_by_pixfmt(vid_fh,
+			vid_fh->active_pix.pixelformat);
+	if (!info)
+		return -EINVAL;
+
+	memset(&rt_frame_buf, 0x00, sizeof(rt_frame_buf));
+	rt_frame_buf_size = sizeof(rt_frame_buf);
+	rt_frame_buf.spec.bitsPP = info->packed ?
+				   info->bpp : ALIGN(info->bpp, 8);
+	rt_frame_buf.spec.type = info->type;
+	rt_frame_buf.spec.width = vid_fh->active_pix.width;
+	rt_frame_buf.spec.height = vid_fh->active_pix.height;
+	rt_frame_buf.spec.stride = vid_fh->active_pix.plane_fmt[0].bytesperline;
+	rt_frame_buf.p1 = buf->addr[0];
+
+	if (vid_fh->active_pix.num_planes > 1)
+		rt_frame_buf.p2 = buf->addr[1];
+
+	if (vid_fh->active_pix.num_planes > 2)
+		rt_frame_buf.p3 = buf->addr[2];
+
+
+	dev_dbg(&kmb_vid->video->dev,
+			"Frame buffer %dx%d stride %d num_palnes %u\n",
+			rt_frame_buf.spec.width, rt_frame_buf.spec.height,
+			rt_frame_buf.spec.stride,
+			vid_fh->active_pix.num_planes);
+	dev_dbg(&kmb_vid->video->dev, "Plane addr: p1 %llx p2 %llx p3 %llx\n",
+			rt_frame_buf.p1, rt_frame_buf.p2, rt_frame_buf.p3);
+
+	ret = xlink_write_volatile(kmb_vid->ipc_dev_handler,
+			kmb_vid->channel_id,
+			(u8 *)&rt_frame_buf,
+			rt_frame_buf_size);
+	if (ret)
+		dev_err(&kmb_vid->video->dev,
+				"Error on buffer queue %d\n", ret);
+
+	return ret;
+}
+
+/**
+ * kmb_video_process_all_bufs - Send all output buffers to LRT for processing
+ * @vid_fh: pointer to V4L2 sub-device file handle
+ *
+ * Send each of the output buffers in dma queue to RT for processing. In case
+ * a buffer can't be processed, its state is marked as error and the buffer is
+ * dequeued.
+ *
+ * Return: none
+ */
+static void kmb_video_process_all_bufs(struct kmb_video_fh *vid_fh)
+{
+	struct kmb_frame_buffer *buf;
+	struct list_head *pos, *next;
+	int ret = 0;
+
+	mutex_lock(&vid_fh->lock);
+	list_for_each_safe(pos, next, &vid_fh->dma_queue) {
+		buf = list_entry(pos, struct kmb_frame_buffer, list);
+
+		ret = kmb_video_process_buf(vid_fh, buf);
+		if (ret) {
+			dev_err(&vid_fh->fh.vdev->dev,
+				"Cannot process output buf 0x%pad\n",
+				&buf->addr[0]);
+			list_del(&buf->list);
+			vb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);
+			continue;
+		}
+	}
+	mutex_unlock(&vid_fh->lock);
+}
+
+/**
+ * kmb_video_queue_output_buf - Queue isp cfg buffer
+ * @vid_fh: pointer to V4L2 sub-device file handle
+ * @buf: video output buffer to queue
+ *
+ * Return: 0 if successful
+ */
+static int kmb_video_queue_output_buf(struct kmb_video_fh *vid_fh,
+				      struct kmb_frame_buffer *buf)
+{
+	int ret = 0;
+
+	kmb_video_insert_buf(vid_fh, buf);
+
+	mutex_lock(&vid_fh->lock);
+
+	/* Process out buf only when device is streaming */
+	if (vb2_is_streaming(&vid_fh->vb2_q)) {
+		ret = kmb_video_process_buf(vid_fh, buf);
+		if (ret) {
+			dev_err(&vid_fh->fh.vdev->dev,
+				"Fail to process output buf 0x%pad\n",
+				&buf->addr[0]);
+			kmb_video_buf_discard(buf);
+		}
+	}
+
+	mutex_unlock(&vid_fh->lock);
+
+	return ret;
+}
+
+/**
+ * kmb_video_release_all_bufs - Release all buffers in pending queue
+ * @vid_fh: pointer to V4L2 sub-device file handle
+ * @state: state of the buffers
+ */
+static void kmb_video_release_all_bufs(struct kmb_video_fh *vid_fh,
+				       enum vb2_buffer_state state)
+{
+	struct kmb_frame_buffer *buf;
+	struct list_head *pos, *next;
+
+	mutex_lock(&vid_fh->lock);
+	list_for_each_safe(pos, next, &vid_fh->dma_queue) {
+		buf = list_entry(pos, struct kmb_frame_buffer, list);
+		list_del(&buf->list);
+		vb2_buffer_done(&buf->vb.vb2_buf, state);
+	}
+	mutex_unlock(&vid_fh->lock);
+}
+
+/**
+ * kmb_video_remove_buf - Remove output buffer from queue
+ * @vid_fh: pointer to V4L2 sub-device file handle
+ * @buf: pointer to kmb_frame_buffer
+ */
+static void kmb_video_remove_buf(struct kmb_video_fh *vid_fh,
+				 struct kmb_frame_buffer *buf)
+{
+	mutex_lock(&vid_fh->lock);
+	list_del(&buf->list);
+	mutex_unlock(&vid_fh->lock);
+}
+
+/**
+ * kmb_video_find_buf_by_addr - Find buffer dma_queue by address
+ * @vid_fh: pointer to V4L2 sub-device file handle
+ * @addr: rt buffer address
+ *
+ * Return: pointer to kmb_frame_buffer if successful
+ */
+static struct kmb_frame_buffer *
+kmb_video_find_buf_by_addr(struct kmb_video_fh *vid_fh, uint64_t addr)
+{
+	struct kmb_frame_buffer *buf = NULL;
+	struct list_head *node, *next;
+
+	mutex_lock(&vid_fh->lock);
+
+	list_for_each_safe(node, next, &vid_fh->dma_queue) {
+		buf = list_entry(node, struct kmb_frame_buffer, list);
+		/* Returned address may have data offset */
+		if (addr >= buf->addr[0] &&
+		    addr < buf->addr[0] + buf->vb.planes[0].length)
+			break;
+
+		buf = NULL;
+	}
+
+	mutex_unlock(&vid_fh->lock);
+	return buf;
+}
+
+/**
+ * kmb_video_remote_subdev - Get remote sub-device by given media pad index
+ * @video: pointer to kmb video device
+ * @pad: pointer to media pad index
+ *
+ * Return: pointer to V4L2 sub-device
+ */
+static struct v4l2_subdev *kmb_video_remote_subdev(struct kmb_video *video,
+						   u32 *pad)
+{
+	struct media_pad *remote;
+
+	remote = media_entity_remote_pad(&video->pad);
+
+	if (remote == NULL || !is_media_entity_v4l2_subdev(remote->entity))
+		return NULL;
+
+	if (pad)
+		*pad = remote->index;
+
+	return media_entity_to_v4l2_subdev(remote->entity);
+}
+
+/**
+ * kmb_video_fmt_info_to_pix - Convert format info to multiplanar pixel format
+ * @vid_fh: pointer to V4L2 sub-device file handle
+ * @info: pointer to kmb video format info structure
+ * @mbus_fmt: pointer to media bus frame format
+ * @pix: pointer to multiplanar format definitions
+ *
+ * Convert kmb video format info to multiplanar pixel format
+ */
+static void kmb_video_fmt_info_to_pix(struct kmb_video_fh *vid_fh,
+				      const struct kmb_video_fmt_info *info,
+				      struct v4l2_mbus_framefmt *mbus_fmt,
+				      struct v4l2_pix_format_mplane *pix)
+{
+	int i;
+	u32 bytesperline;
+	u32 sizeimage;
+	u32 v_sub = 1, h_sub = 1;
+	struct kmb_video *kmb_vid = vid_fh->kmb_vid;
+
+	pix->width = mbus_fmt->width;
+	pix->height = mbus_fmt->height;
+
+	pix->pixelformat = info->pixelformat;
+	pix->colorspace = info->colorspace;
+	pix->num_planes = info->planes;
+
+	if (KMB_VIDEO_TYPE_IS_RAW(kmb_vid))
+		if (mbus_fmt->reserved[0])
+			pix->num_planes = mbus_fmt->reserved[0];
+
+	for (i = 0; i < pix->num_planes; i++) {
+		/* subsample is not applied on the luma plane */
+		if (info->packed)
+			bytesperline = pix->width * info->bpp / 8 / h_sub;
+		else
+			bytesperline = pix->width *
+				       ALIGN(info->bpp, 8) / 8 / h_sub;
+
+		if (pix->plane_fmt[i].bytesperline < bytesperline)
+			pix->plane_fmt[i].bytesperline = bytesperline;
+
+		sizeimage =
+			pix->plane_fmt[i].bytesperline * pix->height / v_sub;
+
+		if (pix->plane_fmt[i].sizeimage < sizeimage)
+			pix->plane_fmt[i].sizeimage = sizeimage;
+
+		h_sub = info->h_subsample;
+		v_sub = info->v_subsample;
+
+		pr_debug("Pix %d #pl %d %dx%d pln[%d]: bpl %u sizeimg %u raw %d",
+			  pix->pixelformat, pix->num_planes,
+			  pix->width, pix->height,
+			  i, pix->plane_fmt[i].bytesperline,
+			  pix->plane_fmt[i].sizeimage,
+			  KMB_VIDEO_TYPE_IS_RAW(kmb_vid));
+	}
+}
+
+/**
+ * kmb_video_get_subdev_pix_fmt - Get sub-device pixel format
+ * @vid_fh: pointer to kmb video file handler
+ * @pix: pointer to multiplanar format definitions
+ *
+ * Return: 0 if successful, -EINVAL otherwise
+ */
+static int kmb_video_get_subdev_pix_fmt(struct kmb_video_fh *vid_fh,
+					struct v4l2_pix_format_mplane *pix)
+{
+	struct kmb_video *kmb_vid = vid_fh->kmb_vid;
+	const struct kmb_video_fmt_info *info;
+	struct v4l2_subdev_format sd_fmt;
+	struct v4l2_subdev *subdev;
+	u32 pad;
+	int ret;
+
+	subdev = kmb_video_remote_subdev(kmb_vid, &pad);
+	if (subdev == NULL)
+		return -EINVAL;
+
+	sd_fmt.pad = pad;
+	sd_fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
+	ret = v4l2_subdev_call(subdev, pad, get_fmt, NULL, &sd_fmt);
+	if (ret < 0)
+		return ret;
+
+	info = kmb_video_get_fmt_info_by_code(vid_fh, sd_fmt.format.code,
+					      kmb_vid->packed_fmt);
+	if (!info)
+		return -EINVAL;
+
+	kmb_video_fmt_info_to_pix(vid_fh, info, &sd_fmt.format, pix);
+
+	return 0;
+}
+
+/**
+ * kmb_video_try_subdev_pix_fmt - Negotiate sub-device pixel format
+ * @vid_fh: pointer to kmb video file handler
+ * @pix: pointer to multiplanar format definitions
+ *
+ * Return: 0 if successful, -EINVAL otherwise
+ */
+static int kmb_video_try_subdev_pix_fmt(struct kmb_video_fh *vid_fh,
+					struct v4l2_pix_format_mplane *pix)
+{
+	struct kmb_video *kmb_vid = vid_fh->kmb_vid;
+	const struct kmb_video_fmt_info *info;
+	struct v4l2_subdev_format sd_fmt;
+	struct v4l2_subdev *subdev;
+	u32 pad;
+	int ret;
+
+	subdev = kmb_video_remote_subdev(kmb_vid, &pad);
+	if (subdev == NULL)
+		return -EINVAL;
+
+	sd_fmt.pad = pad;
+	sd_fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
+	ret = v4l2_subdev_call(subdev, pad, get_fmt, NULL, &sd_fmt);
+	if (ret < 0)
+		return ret;
+
+	info = kmb_video_get_fmt_info_by_pixfmt(vid_fh, pix->pixelformat);
+	if (!info)
+		return -EINVAL;
+
+	info = kmb_video_get_fmt_info_by_code(vid_fh, sd_fmt.format.code,
+					      info->packed);
+	if (!info)
+		return -EINVAL;
+
+	kmb_video_fmt_info_to_pix(vid_fh, info, &sd_fmt.format, pix);
+
+	return 0;
+}
+
+/**
+ * kmb_video_get_channel_id - Get Video Node xLink channel id
+ * @kmb_vid: pointer to kmb video node device
+ *
+ * Return: xLink channel id
+ */
+u32 kmb_video_get_channel_id(struct kmb_video *kmb_vid)
+{
+	u32 channel_id;
+
+	mutex_lock(&kmb_vid->lock);
+	channel_id = kmb_vid->channel_id;
+	mutex_unlock(&kmb_vid->lock);
+
+	return channel_id;
+}
+
+/**
+ * kmb_video_alloc_pipe_cma_area - Allocate CMA area
+ * @kmb_vid: pointer to kmb video node device
+ *
+ * Allocate continuous memory for data structures used by RT
+ *
+ * Return: 0 if successful
+ */
+static int kmb_video_alloc_pipe_cma_area(struct kmb_video *kmb_vid)
+{
+	kmb_vid->cma_vaddr = dma_alloc_coherent(kmb_vid->dma_dev,
+			sizeof(struct pipeConfigEvS),
+			(dma_addr_t *)&kmb_vid->cma_phy_addr, 0);
+	if (!kmb_vid->cma_vaddr)
+		return -ENOMEM;
+
+	dev_dbg(&kmb_vid->video->dev, "OUTPUT CHANNEL CMA: phy 0x%x vaddr %p\n",
+			kmb_vid->cma_phy_addr, kmb_vid->cma_vaddr);
+
+	return 0;
+}
+
+/**
+ * kmb_video_free_pipe_cma_area - Free CMA area
+ * @kmb_vid: pointer to kmb video node device
+ *
+ * Free continuous memory for data structures used by RT
+ */
+static void kmb_video_free_pipe_cma_area(struct kmb_video *kmb_vid)
+{
+	if (kmb_vid->cma_vaddr)
+		dma_free_coherent(kmb_vid->dma_dev,
+				  sizeof(struct pipeConfigEvS),
+				  kmb_vid->cma_vaddr, kmb_vid->cma_phy_addr);
+	kmb_vid->cma_vaddr = NULL;
+}
+
+/**
+ * kmb_video_close_xlink_channel - Close xlink channel for video
+ * @vid_fh: pointer to video sub-device
+ *
+ * Return: 0 if successful
+ */
+static int kmb_video_close_xlink_channel(struct kmb_video_fh *vid_fh)
+{
+	struct kmb_video *kmb_vid = vid_fh->kmb_vid;
+	int ret;
+
+	ret = xlink_close_channel(kmb_vid->ipc_dev_handler,
+				  kmb_vid->channel_id);
+	if (ret) {
+		dev_err(kmb_vid->dma_dev,
+				"Failed to close VID channel: %d\n", ret);
+		return ret;
+	}
+
+	dev_dbg(kmb_vid->dma_dev, "Closed VID channel\n");
+
+	return 0;
+}
+
+/**
+ * kmb_video_open_xlink_channel - Open xlink channel for video
+ * @vid_fh: pointer to video sub-device
+ *
+ * Return: 0 if successful
+ */
+static int kmb_video_open_xlink_channel(struct kmb_video_fh *vid_fh)
+{
+	struct kmb_video *kmb_vid = vid_fh->kmb_vid;
+	int ret;
+
+	ret = xlink_open_channel(kmb_vid->ipc_dev_handler, kmb_vid->channel_id,
+				 RXB_TXB, KMB_RT_VID_CH_DATA_SIZE,
+				 KMB_RT_VID_CH_TIMEOUT_MS);
+	if (ret) {
+		dev_err(kmb_vid->dma_dev,
+				"Failed to open VID channel: %d\n", ret);
+		return ret;
+	}
+
+	dev_dbg(kmb_vid->dma_dev, "Opened VID channel %u\n",
+			kmb_vid->channel_id);
+
+	return 0;
+}
+
+/**
+ * kmb_video_config_stream - Configure LRT streaming
+ * @vid_fh: pointer to video sub-device
+ * @mbus_fmt: pointer to media bus frame format
+ *
+ * Return: 0 if successful
+ */
+static int kmb_video_config_stream(struct kmb_video_fh *vid_fh,
+				   struct v4l2_mbus_framefmt *mbus_fmt)
+{
+	struct kmb_video *kmb_vid = vid_fh->kmb_vid;
+	int ret;
+
+	if (vid_fh->cfg_requested &&
+	    vid_fh->active_pix.width == mbus_fmt->width &&
+	    vid_fh->active_pix.height == mbus_fmt->height)
+		return 0;
+
+	if (vid_fh->cfg_requested)
+		kmb_vid->pipe_ops.release_config(&kmb_vid->video->entity);
+
+	ret = kmb_vid->pipe_ops.request_config(&kmb_vid->video->entity,
+					       mbus_fmt);
+	if (ret)
+		return ret;
+
+	vid_fh->cfg_requested = true;
+
+	return ret;
+}
+
+/**
+ * kmb_video_queue_setup - Setup queue
+ * @q: pointer to video buffer queue
+ * @num_buffers: pointer to number of buffers
+ * @num_planes: pointer to number of planes
+ * @sizes: array of image sizes
+ * @alloc_devs: pointer to array of devices
+ *
+ * Return: 0 if successful
+ */
+static int kmb_video_queue_setup(struct vb2_queue *q,
+		   unsigned int *num_buffers, unsigned int *num_planes,
+		   unsigned int sizes[], struct device *alloc_devs[])
+{
+	struct kmb_video_fh *vid_fh = vb2_get_drv_priv(q);
+	int i;
+
+	if (vid_fh->contiguous_memory) {
+		*num_planes = 1;
+		for (i = 0; i < vid_fh->active_pix.num_planes; i++)
+			sizes[0] += vid_fh->active_pix.plane_fmt[i].sizeimage;
+	} else {
+		*num_planes = vid_fh->active_pix.num_planes;
+		for (i = 0; i < vid_fh->active_pix.num_planes; i++)
+			sizes[i] = vid_fh->active_pix.plane_fmt[i].sizeimage;
+	}
+
+	return 0;
+}
+
+/**
+ * kmb_video_buffer_prepare - Buffer prepare
+ * @vb: pointer to video buffer
+ *
+ * Called every time the buffer is queued perform to initialization required
+ * before each hardware operation
+ *
+ * Return: 0 if successful
+ */
+static int kmb_video_buffer_prepare(struct vb2_buffer *vb)
+{
+	struct kmb_video_fh *vid_fh = vb2_get_drv_priv(vb->vb2_queue);
+	unsigned int size_image = 0;
+	int i;
+
+	if (vid_fh->contiguous_memory) {
+		for (i = 0; i < vid_fh->active_pix.num_planes; i++)
+			size_image += vid_fh->active_pix.plane_fmt[i].sizeimage;
+
+		vb2_set_plane_payload(vb, 0, size_image);
+	} else {
+		for (i = 0; i < vid_fh->active_pix.num_planes; i++)
+			vb2_set_plane_payload(vb, i,
+				vid_fh->active_pix.plane_fmt[i].sizeimage);
+	}
+
+	return 0;
+}
+
+/**
+ * kmb_video_buf_init - Buffer initialize
+ * @vb: pointer to video buffer
+ *
+ * Called once after allocating a buffer for additional buffer-related
+ * initialization
+ *
+ * Return: 0 if successful
+ */
+static int kmb_video_buf_init(struct vb2_buffer *vb)
+{
+	return 0;
+}
+
+/**
+ * kmb_video_buf_queue - Pass buffer vb to the driver
+ * @vb: pointer to video buffer
+ */
+static void kmb_video_buf_queue(struct vb2_buffer *vb)
+{
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
+	struct kmb_frame_buffer *buf = (struct kmb_frame_buffer *)vbuf;
+	struct kmb_video_fh *vid_fh = vb2_get_drv_priv(vb->vb2_queue);
+	struct kmb_video *vid = vid_fh->kmb_vid;
+	int i;
+	int ret;
+
+	if (vid_fh->contiguous_memory) {
+		buf->addr[0] = vb2_dma_contig_plane_dma_addr(vb, 0);
+		for (i = 1; i < vid_fh->active_pix.num_planes; i++) {
+			buf->addr[i] = buf->addr[i - 1] +
+				vid_fh->active_pix.plane_fmt[i - 1].sizeimage;
+		}
+	} else {
+		for (i = 0; i < vid_fh->active_pix.num_planes; i++)
+			buf->addr[i] = vb2_dma_contig_plane_dma_addr(vb, i);
+	}
+
+	ret = kmb_video_queue_output_buf(vid_fh, buf);
+	if (ret)
+		dev_err(&vid->video->dev, "Fail output buf queue %d\n", ret);
+}
+
+/**
+ * kmb_video_worker_thread - Video node worker thread
+ * @video: pointer to KMB Video device
+ *
+ * Return: 0 if successful
+ */
+static int kmb_video_worker_thread(void *video)
+{
+	struct kmb_video_fh *vid_fh = video;
+	struct kmb_video *vid = vid_fh->kmb_vid;
+	struct kmb_frame_buffer *buf = NULL;
+	frameBuffer rt_frame_buf;
+	size_t rt_frame_buf_size;
+	bool stopped = false;
+	int ret;
+
+	set_freezable();
+
+	while (!kthread_should_stop()) {
+		try_to_freeze();
+
+		if (stopped) {
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule();
+			dev_dbg(&vid->video->dev, "Thread is stopped\n");
+			continue;
+		}
+
+		memset(&rt_frame_buf, 0x00, sizeof(rt_frame_buf));
+		rt_frame_buf_size = sizeof(rt_frame_buf);
+		ret = xlink_read_data_to_buffer(vid->ipc_dev_handler,
+					     vid->channel_id,
+					     (uint8_t *const)&rt_frame_buf,
+					     (uint32_t *)&rt_frame_buf_size);
+		if (ret != X_LINK_SUCCESS) {
+			dev_dbg(&vid->video->dev, "Channel closed %d\n", ret);
+			stopped = true;
+			continue;
+		}
+
+		buf = kmb_video_find_buf_by_addr(vid_fh, rt_frame_buf.p1);
+		if (buf) {
+			dev_dbg(&vid->video->dev, "Buffer done ok %d %pad\n",
+					buf->vb.vb2_buf.index, &buf->addr[0]);
+			kmb_video_remove_buf(vid_fh, buf);
+
+			buf->vb.vb2_buf.timestamp = rt_frame_buf.ts;
+
+			/* Set data offsets for all the planes */
+			buf->vb.vb2_buf.planes[0].data_offset =
+				rt_frame_buf.p1 - buf->addr[0];
+			buf->vb.vb2_buf.planes[1].data_offset =
+				rt_frame_buf.p2 - buf->addr[1];
+			buf->vb.vb2_buf.planes[2].data_offset =
+				rt_frame_buf.p3 - buf->addr[2];
+			vb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_DONE);
+		} else {
+			dev_err(&vid->video->dev,
+					"Ouch cannot find buff %llx\n",
+					rt_frame_buf.p1);
+		}
+	}
+
+	return 0;
+}
+
+/**
+ * kmb_video_processing_start - Start video processing
+ * @vid_fh: pointer to video device file handle
+ *
+ * Return: 0 if successful
+ */
+static int kmb_video_processing_start(struct kmb_video_fh *vid_fh)
+{
+	struct kmb_video *kmb_vid = vid_fh->kmb_vid;
+	int ret;
+
+	ret = kmb_video_open_xlink_channel(vid_fh);
+	if (ret)
+		return ret;
+
+	vid_fh->thread = kthread_run(kmb_video_worker_thread,
+				     vid_fh, "kmb_vnode_thread");
+	if (IS_ERR(vid_fh->thread)) {
+		dev_err(&kmb_vid->video->dev, "%s Cannot start thread\n",
+				__func__);
+		ret = -ENOMEM;
+		vid_fh->thread = NULL;
+		goto error_close_xlink_channel;
+	}
+	dev_dbg(&kmb_vid->video->dev, "%s Thread running\n", __func__);
+
+	return 0;
+
+error_close_xlink_channel:
+	kmb_video_close_xlink_channel(vid_fh);
+	return ret;
+}
+
+/**
+ * kmb_video_processing_stop - Stop video processing
+ * @vid_fh: pointer to video device file handle
+ *
+ * Return: 0 if successful
+ */
+static int kmb_video_processing_stop(struct kmb_video_fh *vid_fh)
+{
+	struct kmb_video *kmb_vid = vid_fh->kmb_vid;
+	int ret;
+
+	kmb_video_close_xlink_channel(vid_fh);
+
+	if (!vid_fh->thread) {
+		dev_dbg(&kmb_vid->video->dev, "No thread running\n");
+		return 0;
+	}
+
+	ret = kthread_stop(vid_fh->thread);
+	if (ret < 0) {
+		dev_err(&kmb_vid->video->dev, "%s Thread stop failed %d\n",
+				__func__, ret);
+	}
+
+	vid_fh->thread = NULL;
+	dev_dbg(&kmb_vid->video->dev, "%s Thread stopped\n", __func__);
+
+	return ret;
+}
+
+/**
+ * kmb_video_capture_start_streaming - Set streaming state to enable
+ * @q: pointer to videobuf queue
+ * @count: (unused)number of buffers owned by the driver
+ *
+ * Return: 0 if successful, -EPIPE - broken pipe
+ */
+static int kmb_video_capture_start_streaming(struct vb2_queue *q,
+					     unsigned int count)
+{
+	struct kmb_video_fh *vid_fh = vb2_get_drv_priv(q);
+	struct kmb_video *kmb_vid = vid_fh->kmb_vid;
+	int ret;
+
+	ret = kmb_vid->pipe_ops.build(&kmb_vid->video->entity);
+	if (ret < 0) {
+		dev_err(&kmb_vid->video->dev,
+				"Cannot initialize rt pipeline %d\n", ret);
+		goto error_discard_all_bufs;
+	}
+
+	ret = media_pipeline_start(&kmb_vid->video->entity, kmb_vid->pipe);
+	if (ret < 0)
+		goto error_teardown_pipeline;
+
+	ret = kmb_video_processing_start(vid_fh);
+	if (ret < 0)
+		goto error_media_pipeline_stop;
+
+	/* Process all pending buffers on stream enable */
+	kmb_video_process_all_bufs(vid_fh);
+
+	ret = kmb_vid->pipe_ops.s_stream(&kmb_vid->video->entity, 1);
+	if (ret) {
+		dev_err(&kmb_vid->video->dev,
+				"Fail to enable streaming %d\n", ret);
+		goto error_processing_stop;
+	}
+
+	return 0;
+
+error_processing_stop:
+	kmb_video_processing_stop(vid_fh);
+error_media_pipeline_stop:
+	media_pipeline_stop(&kmb_vid->video->entity);
+error_teardown_pipeline:
+	kmb_vid->pipe_ops.teardown(&kmb_vid->video->entity);
+error_discard_all_bufs:
+	kmb_video_release_all_bufs(vid_fh, VB2_BUF_STATE_QUEUED);
+	return ret;
+}
+
+/**
+ * kmb_video_capture_stop_streaming - Set streaming state to disable
+ * @q: pointer to videobuf queue
+ */
+static void kmb_video_capture_stop_streaming(struct vb2_queue *q)
+{
+	struct kmb_video_fh *vid_fh = vb2_get_drv_priv(q);
+	struct kmb_video *kmb_vid = vid_fh->kmb_vid;
+
+	kmb_vid->pipe_ops.s_stream(&kmb_vid->video->entity, 0);
+
+	kmb_vid->pipe_ops.teardown(&kmb_vid->video->entity);
+
+	media_pipeline_stop(&kmb_vid->video->entity);
+
+	kmb_video_processing_stop(vid_fh);
+
+	kmb_video_release_all_bufs(vid_fh, VB2_BUF_STATE_ERROR);
+}
+
+/**
+ * kmb_video_output_start_streaming - Set streaming state to enable
+ * @q: pointer to videobuf queue
+ * @count: (unused)number of buffers owned by the driver
+ *
+ * Return: 0 if successful, -EPIPE - broken pipe
+ */
+static int kmb_video_output_start_streaming(struct vb2_queue *q,
+					    unsigned int count)
+{
+	struct kmb_video_fh *vid_fh = vb2_get_drv_priv(q);
+	struct kmb_video *kmb_vid = vid_fh->kmb_vid;
+	int ret;
+
+	ret = kmb_vid->pipe_ops.build(&kmb_vid->video->entity);
+	if (ret < 0) {
+		dev_err(&kmb_vid->video->dev,
+				"Cannot initialize rt pipeline\n");
+		return ret;
+	}
+
+	ret = kmb_video_processing_start(vid_fh);
+	if (ret < 0)
+		return ret;
+
+	/* Process all pending buffers on stream enable */
+	kmb_video_process_all_bufs(vid_fh);
+
+	return 0;
+}
+
+/**
+ * kmb_video_output_stop_streaming - Set streaming state to disable
+ * @q: pointer to videobuf queue
+ */
+static void kmb_video_output_stop_streaming(struct vb2_queue *q)
+{
+	struct kmb_video_fh *vid_fh = vb2_get_drv_priv(q);
+	struct kmb_video *kmb_vid = vid_fh->kmb_vid;
+
+	kmb_vid->pipe_ops.teardown(&kmb_vid->video->entity);
+
+	kmb_video_processing_stop(vid_fh);
+
+	kmb_video_release_all_bufs(vid_fh, VB2_BUF_STATE_ERROR);
+}
+
+/* driver-specific operations */
+static struct vb2_ops kmb_video_vb2_q_capture_ops = {
+	.queue_setup     = kmb_video_queue_setup,
+	.buf_prepare     = kmb_video_buffer_prepare,
+	.buf_init        = kmb_video_buf_init,
+	.buf_queue       = kmb_video_buf_queue,
+	.start_streaming = kmb_video_capture_start_streaming,
+	.stop_streaming  = kmb_video_capture_stop_streaming,
+};
+
+static struct vb2_ops kmb_video_vb2_q_output_ops = {
+	.queue_setup     = kmb_video_queue_setup,
+	.buf_prepare     = kmb_video_buffer_prepare,
+	.buf_init        = kmb_video_buf_init,
+	.buf_queue       = kmb_video_buf_queue,
+	.start_streaming = kmb_video_output_start_streaming,
+	.stop_streaming  = kmb_video_output_stop_streaming,
+};
+
+/**
+ * kmb_video_querycap - Query device capabilities
+ * @file: pointer to file containing video device data
+ * @fh: pointer to V4L2 sub-device file handle
+ * @cap: pointer to V4L2 device capabilities structure
+ *
+ * VIDIOC_QUERYCAP ioctl handler
+ *
+ * Return: 0 if successful
+ */
+static int kmb_video_querycap(struct file *file,
+	void *fh, struct v4l2_capability *cap)
+{
+	struct kmb_video_fh *vid_fh = kmb_video_from_v4l2(fh);
+
+	cap->bus_info[0] = 0;
+	strlcpy(cap->driver, KMB_CAM_VIDEO_NAME, sizeof(cap->driver));
+	strlcpy(cap->card, KMB_CAM_VIDEO_NAME, sizeof(cap->card));
+	cap->device_caps = vid_fh->fh.vdev->device_caps;
+	cap->capabilities = vid_fh->fh.vdev->device_caps |
+			    V4L2_CAP_DEVICE_CAPS;
+
+	return 0;
+}
+
+/**
+ * kmb_video_enum_fmt - Enumerate format
+ * @file: pointer to file containing video device data
+ * @fh: pointer to V4L2 sub-device file handle
+ * @f: pointer to V4L2 format structure
+ *
+ * VIDIOC_ENUM_FMT ioctl handler. Enumerate image formats for video capture
+ * in multiple plain mode.
+ * If a raw input/output node is enumerated, enumerate each media bus format
+ * twice for a packed and unpacked pixel format
+ *
+ * Return: 0 if successful, -EINVAL if there is not such index
+ */
+static int kmb_video_enum_fmt(struct file *file,
+	void *fh, struct v4l2_fmtdesc *f)
+{
+	struct kmb_video_fh *vid_fh = kmb_video_from_v4l2(fh);
+	struct kmb_video *kmb_vid = vid_fh->kmb_vid;
+	struct v4l2_subdev_mbus_code_enum mbus_code;
+	const struct kmb_video_fmt_info *info;
+	struct v4l2_subdev *subdev;
+	int packed = 0;
+	u32 pad;
+	int ret;
+
+	subdev = kmb_video_remote_subdev(kmb_vid, &pad);
+	if (subdev == NULL)
+		return -EINVAL;
+
+	memset(&mbus_code, 0, sizeof(mbus_code));
+	mbus_code.pad = pad;
+	mbus_code.which =  V4L2_SUBDEV_FORMAT_ACTIVE;
+	mbus_code.index = f->index;
+
+	if (KMB_VIDEO_TYPE_IS_RAW(kmb_vid))
+		mbus_code.index = f->index / 2;
+
+	ret = v4l2_subdev_call(subdev, pad, enum_mbus_code, NULL, &mbus_code);
+	if (ret)
+		return -EINVAL;
+
+	if (KMB_VIDEO_TYPE_IS_RAW(kmb_vid))
+		packed = f->index & 0x01;
+
+	info = kmb_video_get_fmt_info_by_code(vid_fh, mbus_code.code, packed);
+	if (!info)
+		return -EINVAL;
+
+	strlcpy(f->description, info->description, sizeof(f->description));
+	f->pixelformat = info->pixelformat;
+
+	return 0;
+}
+
+/**
+ * kmb_video_enum_framesizes - Enumerate frame sizes
+ * @file: pointer to file containing video device data
+ * @fh: pointer to V4L2 sub-device file handle
+ * @fsize: pointer to V4L2 frame size enumeration
+ *
+ * VIDIOC_ENUM_FRAMESIZES ioctl handler
+ *
+ * Return: 0 if successful, -EINVAL if there is not such index
+ */
+static int kmb_video_enum_framesizes(struct file *file, void *fh,
+				     struct v4l2_frmsizeenum *fsize)
+{
+	struct kmb_video_fh *vid_fh = kmb_video_from_v4l2(fh);
+	struct v4l2_pix_format_mplane pix_mp;
+	int ret;
+
+	if (fsize->index > 0)
+		return -EINVAL;
+
+	memset(&pix_mp, 0, sizeof(pix_mp));
+	ret = kmb_video_get_subdev_pix_fmt(vid_fh, &pix_mp);
+	if (ret < 0)
+		return ret;
+
+	fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+	fsize->discrete.width = pix_mp.width;
+	fsize->discrete.height = pix_mp.height;
+
+	return 0;
+}
+
+/**
+ * kmb_video_enum_frameintervals - Enumerate frame intervals
+ * @file: pointer to file containing video device data
+ * @fh: pointer to V4L2 sub-device file handle
+ * @fival: pointer to V4L2 frame interval structure
+ *
+ * VIDIOC_ENUM_FRAMEINTERVALS ioctl handler
+ *
+ * Return: 0 if successful, -EINVAL if there is not such index
+ */
+static int kmb_video_enum_frameintervals(struct file *file, void *fh,
+					 struct v4l2_frmivalenum *fival)
+{
+	struct kmb_video_fh *vid_fh = kmb_video_from_v4l2(fh);
+	struct kmb_video *kmb_vid = vid_fh->kmb_vid;
+	struct v4l2_subdev_frame_interval_enum interval;
+	struct v4l2_subdev_pad_config cfg;
+	struct v4l2_subdev *subdev;
+	u32 pad;
+	int ret;
+
+	subdev = kmb_video_remote_subdev(kmb_vid, &pad);
+	if (subdev == NULL)
+		return -EINVAL;
+
+	memset(&interval, 0, sizeof(interval));
+	interval.pad = pad;
+	interval.index = fival->index;
+	interval.which = V4L2_SUBDEV_FORMAT_TRY;
+	interval.width = fival->width;
+	interval.height = fival->height;
+
+	ret = v4l2_subdev_call(subdev, pad, enum_frame_interval,
+				&cfg, &interval);
+	if (ret < 0)
+		return ret;
+
+	fival->type = V4L2_FRMIVAL_TYPE_DISCRETE;
+	fival->discrete = interval.interval;
+
+	return 0;
+}
+
+/**
+ * kmb_video_get_fmt - Get format for video capture in multiple plain mode
+ * @file: pointer to file containing video device data
+ * @fh: pointer to V4L2 sub-device file handle
+ * @f: pointer to stream data format
+ *
+ * VIDIOC_G_FMT ioctl handler
+ *
+ * Return: 0 if successful
+ */
+static int kmb_video_get_fmt(struct file *file,
+	void *fh, struct v4l2_format *f)
+{
+	struct kmb_video_fh *vid_fh = kmb_video_from_v4l2(fh);
+
+	f->fmt.pix_mp = vid_fh->active_pix;
+
+	return 0;
+}
+
+/**
+ * kmb_video_try_fmt_vid - Negotiate format for video capture
+ * @file: pointer to file containing video device data
+ * @fh: pointer to V4L2 sub-device file handle
+ * @f: pointer to stream data format
+ *
+ * VIDIOC_TRY_FMT ioctl handler. Negotiate format for video capture in
+ * multiple plain mode
+ *
+ * Return: 0 if successful
+ */
+static int kmb_video_try_fmt_vid(struct file *file,
+	void *fh, struct v4l2_format *f)
+{
+	struct kmb_video_fh *vid_fh = kmb_video_from_v4l2(fh);
+
+	return kmb_video_try_subdev_pix_fmt(vid_fh, &f->fmt.pix_mp);
+}
+
+/**
+ * kmb_video_set_fmt_vid - Set format for video capture in multiple plain mode
+ * @file: pointer to file containing video device data
+ * @fh: pointer to V4L2 sub-device file handle
+ * @f: pointer to stream data format
+ *
+ * VIDIOC_S_FMT ioctl handler
+ *
+ * Return: 0 if successful
+ */
+static int kmb_video_set_fmt_vid(struct file *file,
+	void *fh, struct v4l2_format *f)
+{
+	struct kmb_video_fh *vid_fh = kmb_video_from_v4l2(fh);
+	struct kmb_video *kmb_vid = vid_fh->kmb_vid;
+	const struct kmb_video_fmt_info *info;
+	struct v4l2_mbus_framefmt mbus_fmt;
+	int ret;
+
+	memset(&mbus_fmt, 0, sizeof(mbus_fmt));
+	info = kmb_video_get_fmt_info_by_pixfmt(vid_fh,
+						f->fmt.pix_mp.pixelformat);
+	if (!info) {
+		v4l2_err(kmb_vid->video->v4l2_dev, "Can not get format %x\n",
+				f->fmt.pix_mp.pixelformat);
+		return -EINVAL;
+	}
+
+	mbus_fmt.width = f->fmt.pix_mp.width;
+	mbus_fmt.height = f->fmt.pix_mp.height;
+	mbus_fmt.code = info->code;
+
+	ret = kmb_video_config_stream(vid_fh, &mbus_fmt);
+	if (ret)
+		return ret;
+
+	info = kmb_video_get_fmt_info_by_code(vid_fh, mbus_fmt.code,
+					      info->packed);
+	if (!info) {
+		v4l2_err(kmb_vid->video->v4l2_dev, "Can not get format %x\n",
+				mbus_fmt.code);
+		return -EINVAL;
+	}
+
+	f->fmt.pix_mp.width = mbus_fmt.width;
+	f->fmt.pix_mp.height = mbus_fmt.height;
+	f->fmt.pix_mp.pixelformat = info->pixelformat;
+
+	vid_fh->active_pix = f->fmt.pix_mp;
+
+	kmb_video_fmt_info_to_pix(vid_fh, info, &mbus_fmt, &vid_fh->active_pix);
+
+	f->fmt.pix_mp = vid_fh->active_pix;
+	vid_fh->contiguous_memory = info->contiguous_memory;
+	kmb_vid->packed_fmt = info->packed;
+
+	return 0;
+}
+
+/**
+ * kmb_video_reqbufs - Initiate memory mapped or user pointer I/O
+ * @file: pointer to file containing video device data
+ * @fh: pointer to V4L2 sub-device file handle
+ * @req: pointer to request buffers structure
+ *
+ * VIDIOC_REQBUFS ioctl handler
+ *
+ * Return: 0 if successful
+ */
+static int kmb_video_reqbufs(struct file *file,
+	void *fh, struct v4l2_requestbuffers *req)
+{
+	struct kmb_video_fh *vid_fh = kmb_video_from_v4l2(fh);
+
+	return vb2_reqbufs(&vid_fh->vb2_q, req);
+}
+
+/**
+ * kmb_video_expbuf - Export dma fd of memory mapped buffer
+ * @file: pointer to file containing video device data
+ * @fh: pointer to V4L2 sub-device file handle
+ * @expbuf: pointer to export buffer structure
+ *
+ * VIDIOC_EXPBUF ioctl handler
+ *
+ * Return: 0 if successful
+ */
+static int kmb_video_expbuf(struct file *file,
+	void *fh, struct v4l2_exportbuffer *expbuf)
+{
+	struct kmb_video_fh *vid_fh = kmb_video_from_v4l2(fh);
+
+	return vb2_expbuf(&vid_fh->vb2_q, expbuf);
+}
+
+/**
+ * kmb_video_qbuf - Queue buffer
+ * @file: pointer to file containing video device data
+ * @fh: pointer to V4L2 sub-device file handle
+ * @pb: pointer to video buffer information
+ *
+ * VIDIOC_QBUF ioctl handler. Enqueue an empty (capturing) or filled (output)
+ * buffer in the driver's incoming queue.
+ *
+ * Return: 0 if successful
+ */
+static int kmb_video_qbuf(struct file *file, void *fh,
+	struct v4l2_buffer *pb)
+{
+	struct kmb_video_fh *vid_fh = kmb_video_from_v4l2(fh);
+	struct media_device *mdev = vid_fh->fh.vdev->v4l2_dev->mdev;
+
+	return vb2_qbuf(&vid_fh->vb2_q, mdev, pb);
+}
+
+/**
+ * kmb_video_dqbuf - Dequeue a filled buffer from the driver's outgoing queue
+ * @file: pointer to file containing video device data
+ * @fh: pointer to V4L2 sub-device file handle
+ * @pb: pointer to video buffer information
+ *
+ * VIDIOC_DQBUF ioctl handler
+ *
+ * Return: 0 if successful
+ */
+static int kmb_video_dqbuf(struct file *file,
+	void *fh, struct v4l2_buffer *pb)
+{
+	struct kmb_video_fh *vid_fh = kmb_video_from_v4l2(fh);
+
+	return vb2_dqbuf(&vid_fh->vb2_q, pb, file->f_flags & O_NONBLOCK);
+}
+
+/**
+ * kmb_video_streamon - Start streaming
+ * @file: pointer to file containing video device data
+ * @fh: pointer to V4L2 sub-device file handle
+ * @buf_type: V4L2 buffer type
+ *
+ * VIDIOC_STREAMON ioctl handler
+ *
+ * Return: 0 if successful
+ */
+static int kmb_video_streamon(struct file *file,
+	void *fh, enum v4l2_buf_type buf_type)
+{
+	struct kmb_video_fh *vid_fh = kmb_video_from_v4l2(fh);
+	struct kmb_video *kmb_vid = vid_fh->kmb_vid;
+	int ret;
+
+	ret = vb2_streamon(&vid_fh->vb2_q, buf_type);
+	if (ret < 0)
+		dev_err(&kmb_vid->video->dev,
+			"Stream ON failed! ret = %d\n", ret);
+
+	return ret;
+}
+
+/**
+ * kmb_video_streamoff - Stop streaming
+ * @file: pointer to file containing video device data
+ * @fh: pointer to V4L2 sub-device file handle
+ * @buf_type: V4L2 buffer type
+ *
+ * VIDIOC_STREAMOFF ioctl handler
+ *
+ * Return: 0 if successful
+ */
+static int kmb_video_streamoff(struct file *file,
+	void *fh, enum v4l2_buf_type buf_type)
+{
+	struct kmb_video_fh *vid_fh = kmb_video_from_v4l2(fh);
+
+	return vb2_streamoff(&vid_fh->vb2_q, buf_type);
+}
+
+/**
+ * kmb_video_query_buf - Query the status of a buffer
+ * @file: pointer to file containing video device data
+ * @fh: pointer to V4L2 sub-device file handle
+ * @pb: pointer to video buffer information
+ *
+ * VIDIOC_QUERYBUF ioctl handler
+ *
+ * Return: 0 if successful
+ */
+static int kmb_video_query_buf(struct file *file, void *fh,
+	struct v4l2_buffer *pb)
+{
+	struct kmb_video_fh *vid_fh = kmb_video_from_v4l2(fh);
+
+	return vb2_querybuf(&vid_fh->vb2_q, pb);
+}
+
+/**
+ * kmb_video_get_pixelaspect - Dummy implementation
+ * @file: pointer to file containing video device data
+ * @fh: pointer to V4L2 sub-device file handle
+ * @buf_type: V4L2 buffer type
+ * @aspect: pointer to crop pixel aspect struct
+ *
+ * VIDIOC_CROPCAP ioctl handler for the pixel aspect
+ *
+ * Return: 0 if successful
+ */
+static int kmb_video_get_pixelaspect(struct file *file, void *fh,
+	int buf_type, struct v4l2_fract *aspect)
+{
+	aspect->numerator = 1;
+	aspect->denominator = 1;
+
+	return 0;
+}
+
+/**
+ * kmb_video_get_parm - Get streaming parameters
+ * @file: pointer to file containing video device data
+ * @fh: pointer to V4L2 sub-device file handle
+ * @params: pointer to V4L2 streaming parameters
+ *
+ * VIDIOC_G_PARM ioctl handler for streaming parameters
+ *
+ * Return: 0 if successful
+ */
+static int kmb_video_get_parm(struct file *file, void *fh,
+			       struct v4l2_streamparm *params)
+{
+	struct kmb_video_fh *vid_fh = kmb_video_from_v4l2(fh);
+	struct kmb_video *kmb_vid = vid_fh->kmb_vid;
+	struct v4l2_subdev_frame_interval interval;
+	struct v4l2_subdev *subdev;
+	u32 pad;
+	int ret;
+
+	if (V4L2_TYPE_IS_OUTPUT(params->type))
+		return -ENOTTY;
+
+	subdev = kmb_video_remote_subdev(kmb_vid, &pad);
+	if (subdev == NULL)
+		return -EINVAL;
+
+	memset(&interval, 0, sizeof(interval));
+	interval.pad = pad;
+	interval.interval = params->parm.capture.timeperframe;
+	ret = v4l2_subdev_call(subdev, video, g_frame_interval, &interval);
+	if (ret)
+		return ret;
+
+	params->parm.capture.capability = V4L2_CAP_TIMEPERFRAME;
+	params->parm.capture.timeperframe = interval.interval;
+
+	dev_dbg(&kmb_vid->video->dev, "Get frame interval %d/%d",
+		params->parm.capture.timeperframe.numerator,
+		params->parm.capture.timeperframe.denominator);
+
+	return 0;
+}
+
+/**
+ * kmb_video_set_parm - Set streaming parameters
+ * @file: pointer to file containing video device data
+ * @fh: pointer to V4L2 sub-device file handle
+ * @params: pointer to V4L2 streaming parameters
+ *
+ * VIDIOC_S_PARM ioctl handler for streaming parameters
+ *
+ * Return: 0 if successful
+ */
+static int kmb_video_set_parm(struct file *file, void *fh,
+			       struct v4l2_streamparm *params)
+{
+	struct kmb_video_fh *vid_fh = kmb_video_from_v4l2(fh);
+	struct kmb_video *kmb_vid = vid_fh->kmb_vid;
+	struct v4l2_subdev_frame_interval interval;
+	struct v4l2_subdev *subdev;
+	u32 pad;
+	int ret;
+
+	if (V4L2_TYPE_IS_OUTPUT(params->type))
+		return -ENOTTY;
+
+	subdev = kmb_video_remote_subdev(kmb_vid, &pad);
+	if (subdev == NULL)
+		return -EINVAL;
+
+	memset(&interval, 0, sizeof(interval));
+	interval.pad = pad;
+	interval.interval = params->parm.capture.timeperframe;
+	ret = v4l2_subdev_call(subdev, video, s_frame_interval, &interval);
+	if (ret)
+		return ret;
+
+	params->parm.capture.capability = V4L2_CAP_TIMEPERFRAME;
+	params->parm.capture.timeperframe = interval.interval;
+
+	dev_dbg(&kmb_vid->video->dev, "Set frame interval %d/%d",
+		params->parm.capture.timeperframe.numerator,
+		params->parm.capture.timeperframe.denominator);
+
+	return 0;
+}
+
+/* V4L2 ioctl operations */
+static const struct v4l2_ioctl_ops kmb_vid_ioctl_ops = {
+	.vidioc_querycap                 = kmb_video_querycap,
+	.vidioc_enum_fmt_vid_cap         = kmb_video_enum_fmt,
+	.vidioc_enum_fmt_vid_out         = kmb_video_enum_fmt,
+	.vidioc_enum_framesizes          = kmb_video_enum_framesizes,
+	.vidioc_enum_frameintervals      = kmb_video_enum_frameintervals,
+	.vidioc_g_fmt_vid_cap_mplane     = kmb_video_get_fmt,
+	.vidioc_try_fmt_vid_cap_mplane   = kmb_video_try_fmt_vid,
+	.vidioc_s_fmt_vid_cap_mplane     = kmb_video_set_fmt_vid,
+	.vidioc_g_fmt_vid_out_mplane	 = kmb_video_get_fmt,
+	.vidioc_try_fmt_vid_out_mplane	 = kmb_video_try_fmt_vid,
+	.vidioc_s_fmt_vid_out_mplane	 = kmb_video_set_fmt_vid,
+	.vidioc_g_parm                   = kmb_video_get_parm,
+	.vidioc_s_parm                   = kmb_video_set_parm,
+	.vidioc_querybuf                 = kmb_video_query_buf,
+	.vidioc_g_pixelaspect            = kmb_video_get_pixelaspect,
+	.vidioc_reqbufs                  = kmb_video_reqbufs,
+	.vidioc_qbuf                     = kmb_video_qbuf,
+	.vidioc_dqbuf                    = kmb_video_dqbuf,
+	.vidioc_streamon                 = kmb_video_streamon,
+	.vidioc_streamoff                = kmb_video_streamoff,
+	.vidioc_expbuf                   = kmb_video_expbuf
+};
+
+/**
+ * kmb_video_open - Device node open
+ * @file: pointer to file containing video device data
+ *
+ * Return: 0 if successful, -ENOMEM if there is not enough memory
+ */
+static int kmb_video_open(struct file *file)
+{
+	struct kmb_video *kmb_vid = video_drvdata(file);
+	struct video_device *video = video_devdata(file);
+	struct v4l2_mbus_framefmt fmt;
+	struct kmb_video_fh *vid_fh;
+	int ret;
+
+	vid_fh = kzalloc(sizeof(*vid_fh), GFP_KERNEL);
+	if (!vid_fh)
+		return -ENOMEM;
+
+	v4l2_fh_init(&vid_fh->fh, video);
+	vid_fh->kmb_vid = kmb_vid;
+	vid_fh->cfg_requested = false;
+	mutex_init(&vid_fh->lock);
+	mutex_init(&vid_fh->vb2_lock);
+	INIT_LIST_HEAD(&vid_fh->dma_queue);
+
+	file->private_data = &vid_fh->fh;
+	v4l2_fh_add(&vid_fh->fh);
+
+	if (kmb_vid->video->vfl_dir & VFL_DIR_TX) {
+		vid_fh->vb2_q.ops = &kmb_video_vb2_q_output_ops;
+		vid_fh->vb2_q.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
+	} else {
+		vid_fh->vb2_q.ops = &kmb_video_vb2_q_capture_ops;
+		vid_fh->vb2_q.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+	}
+
+	vid_fh->vb2_q.drv_priv = vid_fh;
+	vid_fh->vb2_q.buf_struct_size = sizeof(struct kmb_frame_buffer);
+	vid_fh->vb2_q.io_modes = VB2_MMAP | VB2_DMABUF;
+	vid_fh->vb2_q.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;
+	vid_fh->vb2_q.mem_ops = &vb2_dma_contig_memops;
+	vid_fh->vb2_q.dev = kmb_vid->dma_dev;
+	vid_fh->vb2_q.lock = &vid_fh->vb2_lock;
+
+	ret = vb2_queue_init(&vid_fh->vb2_q);
+	if (ret < 0) {
+		dev_err(&video->dev, "Error vb2 queue init\n");
+		goto error_release_v4l2_fh;
+	}
+
+	/* Fill default format. */
+	memset(&fmt, 0, sizeof(fmt));
+	if (KMB_VIDEO_TYPE_IS_RAW(kmb_vid)) {
+		kmb_video_fmt_info_to_pix(vid_fh, &raw_formats[0], &fmt,
+					  &vid_fh->active_pix);
+	} else {
+		struct media_pad *isp_pad;
+
+		kmb_video_fmt_info_to_pix(vid_fh, &video_formats[0], &fmt,
+					  &vid_fh->active_pix);
+
+		isp_pad = media_entity_remote_pad(&kmb_vid->pad);
+		if (!isp_pad) {
+			dev_err(&video->dev, "Cannot get remote pad\n");
+			ret = -ENODEV;
+			goto error_release_v4l2_fh;
+		}
+	}
+
+	if (kmb_vid->channel_ops.accuire_id)
+		kmb_vid->channel_id =
+			kmb_vid->channel_ops.accuire_id(kmb_vid->priv);
+
+	ret = kmb_video_alloc_pipe_cma_area(kmb_vid);
+	if (ret < 0)
+		goto error_release_v4l2_fh;
+
+	ret = kmb_vid->pipe_ops.s_power(&kmb_vid->video->entity, 1);
+	if (ret)
+		goto error_cma_free;
+
+	/* trigger power on on pipeline subdevs */
+	ret = v4l2_pipeline_pm_get(&kmb_vid->video->entity);
+	if (ret) {
+		dev_err(&kmb_vid->video->dev,
+			"Failed to set power on! %d", ret);
+		goto error_power_off_pipe;
+	}
+
+	return 0;
+
+error_power_off_pipe:
+	kmb_vid->pipe_ops.s_power(&kmb_vid->video->entity, 0);
+error_cma_free:
+	kmb_video_free_pipe_cma_area(kmb_vid);
+	if (kmb_vid->channel_ops.free_id && kmb_vid->channel_id)
+		kmb_vid->channel_ops.free_id(kmb_vid->priv,
+					     kmb_vid->channel_id);
+	kmb_vid->channel_id = 0;
+error_release_v4l2_fh:
+	v4l2_fh_del(&vid_fh->fh);
+	v4l2_fh_exit(&vid_fh->fh);
+	kfree(vid_fh);
+	return ret;
+}
+
+/**
+ * kmb_video_release - Video device release
+ * @file: pointer to file containing video device data
+ *
+ * Return: 0 if successful
+ */
+static int kmb_video_release(struct file *file)
+{
+	struct kmb_video_fh *vid_fh = kmb_video_from_v4l2(file->private_data);
+	struct kmb_video *kmb_vid = vid_fh->kmb_vid;
+	struct v4l2_mbus_framefmt fmt;
+
+	if (vid_fh->cfg_requested) {
+		kmb_vid->pipe_ops.release_config(&kmb_vid->video->entity);
+		vid_fh->cfg_requested = false;
+	}
+
+	kmb_video_free_pipe_cma_area(kmb_vid);
+	vb2_queue_release(&vid_fh->vb2_q);
+	v4l2_pipeline_pm_put(&kmb_vid->video->entity);
+	kmb_vid->pipe_ops.s_power(&kmb_vid->video->entity, 0);
+	if (kmb_vid->channel_ops.free_id && kmb_vid->channel_id)
+		kmb_vid->channel_ops.free_id(kmb_vid->priv,
+					     kmb_vid->channel_id);
+	kmb_vid->channel_id = 0;
+
+	/* reset remote pad format */
+	memset(&fmt, 0, sizeof(fmt));
+	fmt.code = raw_formats[0].code;
+	kmb_video_fmt_info_to_pix(vid_fh, &raw_formats[0], &fmt,
+				  &vid_fh->active_pix);
+	vid_fh->contiguous_memory = raw_formats[0].contiguous_memory;
+
+	v4l2_fh_del(&vid_fh->fh);
+	v4l2_fh_exit(&vid_fh->fh);
+	mutex_destroy(&vid_fh->vb2_lock);
+	mutex_destroy(&vid_fh->lock);
+
+	kfree(vid_fh);
+	return 0;
+}
+
+/**
+ * kmb_video_poll - Poll
+ * @file: pointer to file containing video device data
+ * @wait: poll table wait
+ *
+ * Return: 0 if successful
+ */
+static unsigned int kmb_video_poll(struct file *file,
+	struct poll_table_struct *wait)
+{
+	struct kmb_video_fh *vid_fh = kmb_video_from_v4l2(file->private_data);
+
+	return vb2_poll(&vid_fh->vb2_q, file, wait);
+}
+
+/**
+ * kmb_video_mmap - Memory map
+ * @file: pointer to file containing video device data
+ * @vma: VMM memory area
+ *
+ * Return: 0 if successful
+ */
+static int kmb_video_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct kmb_video_fh *vid_fh = kmb_video_from_v4l2(file->private_data);
+
+	return vb2_mmap(&vid_fh->vb2_q, vma);
+}
+
+/* FS operations for V4L2 device */
+static const struct v4l2_file_operations kmb_vid_fops = {
+	.owner          = THIS_MODULE,
+	.open           = kmb_video_open,
+	.release        = kmb_video_release,
+	.poll           = kmb_video_poll,
+	.unlocked_ioctl = video_ioctl2,
+	.mmap           = kmb_video_mmap
+};
+
+/**
+ * kmb_video_init - Initialize entity
+ * @kmb_vid: pointer to kmb video device
+ * @name: entity name
+ * @type: kmb video node type
+ *
+ * Return: 0 if successful
+ */
+int kmb_video_init(struct kmb_video *kmb_vid, const char *name,
+		   enum kmb_video_type type)
+{
+	int ret;
+
+	kmb_vid->video = video_device_alloc();
+	if (!kmb_vid->video) {
+		dev_err(&kmb_vid->video->dev,
+				"Failed to allocate video device\n");
+		return -ENOMEM;
+	}
+
+	mutex_init(&kmb_vid->lock);
+	mutex_init(&kmb_vid->video_lock);
+	kmb_vid->channel_id = 0;
+	kmb_vid->cma_vaddr = NULL;
+	kmb_vid->cma_phy_addr = 0;
+	kmb_vid->type = type;
+
+	switch (type) {
+	case KMB_VIDEO_RAW_INPUT:
+		kmb_vid->pad.flags = MEDIA_PAD_FL_SOURCE;
+		kmb_vid->video->vfl_dir = VFL_DIR_TX;
+		kmb_vid->video->device_caps = V4L2_CAP_VIDEO_OUTPUT_MPLANE |
+					      V4L2_CAP_STREAMING;
+		break;
+	case KMB_VIDEO_RAW_OUTPUT:
+	case KMB_VIDEO_YUV_OUTPUT:
+		kmb_vid->pad.flags = MEDIA_PAD_FL_SINK;
+		kmb_vid->video->device_caps = V4L2_CAP_VIDEO_CAPTURE_MPLANE |
+					      V4L2_CAP_STREAMING;
+		break;
+	default:
+		pr_err("No such video node type %d", type);
+		return -EINVAL;
+	}
+
+	ret = media_entity_pads_init(&kmb_vid->video->entity, 1, &kmb_vid->pad);
+	if (ret < 0)
+		return ret;
+
+	kmb_vid->video->fops  = &kmb_vid_fops;
+	kmb_vid->video->ioctl_ops = &kmb_vid_ioctl_ops;
+	kmb_vid->video->minor = -1;
+	kmb_vid->video->release  = video_device_release;
+	kmb_vid->video->vfl_type = VFL_TYPE_VIDEO;
+	kmb_vid->video->lock = &kmb_vid->video_lock;
+	snprintf(kmb_vid->video->name, sizeof(kmb_vid->video->name),
+		"kmb_video %s", name);
+
+	video_set_drvdata(kmb_vid->video, kmb_vid);
+	return 0;
+}
+
+/**
+ * kmb_video_deinit - Free resources associated with entity
+ * @kmb_vid: pointer to kmb video device
+ */
+void kmb_video_deinit(struct kmb_video *kmb_vid)
+{
+	media_entity_cleanup(&kmb_vid->video->entity);
+	mutex_destroy(&kmb_vid->lock);
+	mutex_destroy(&kmb_vid->video_lock);
+}
+
+/**
+ * kmb_video_register - Register V4L2 device
+ * @kmb_vid: pointer to kmb video device
+ * @v4l2_dev: pointer to V4L2 device drivers
+ *
+ * Return: 0 if successful
+ */
+int kmb_video_register(struct kmb_video *kmb_vid,
+		       struct v4l2_device *v4l2_dev)
+{
+	int ret;
+
+	kmb_vid->video->v4l2_dev = v4l2_dev;
+	ret = video_register_device(kmb_vid->video, VFL_TYPE_VIDEO, -1);
+	if (ret < 0) {
+		v4l2_err(v4l2_dev, "Failed to register video device\n");
+		goto error_vdev_release;
+	}
+
+	return 0;
+
+error_vdev_release:
+	kmb_video_deinit(kmb_vid);
+	video_device_release(kmb_vid->video);
+	return ret;
+}
+
+/**
+ * kmb_video_unregister - Unregister V4L device
+ * @kmb_vid: pointer to kmb video device
+ */
+void kmb_video_unregister(struct kmb_video *kmb_vid)
+{
+	kmb_video_deinit(kmb_vid);
+	video_unregister_device(kmb_vid->video);
+}
diff --git a/drivers/media/platform/kmb-camera/kmb-video.h b/drivers/media/platform/kmb-camera/kmb-video.h
new file mode 100644
index 000000000000..63578dbae818
--- /dev/null
+++ b/drivers/media/platform/kmb-camera/kmb-video.h
@@ -0,0 +1,154 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * kmb-video.h - KeemBay Camera Video node Driver.
+ *
+ * Copyright (C) 2018-2019 Intel Corporation
+ */
+#ifndef KMB_VIDEO_H
+#define KMB_VIDEO_H
+
+#include <linux/xlink.h>
+#include <media/v4l2-dev.h>
+#include <media/v4l2-subdev.h>
+#include <media/videobuf2-v4l2.h>
+
+#define KMB_CAM_VIDEO_NAME "kmb-video"
+
+/**
+ * struct kmb_dma_config - KMB dma configuration structure
+ * @line_length: line length
+ * @num_lines: number of lines
+ * @size: dma buffer size
+ */
+struct kmb_dma_config {
+	unsigned int line_length;
+	unsigned int num_lines;
+	unsigned int size;
+};
+
+/**
+ * struct kmb_frame_buffer - KMB frame buffer structure
+ * @vb: video buffer for v4l2
+ * @addr: array of dma buffer plane address
+ * @list: frame buffer list
+ */
+struct kmb_frame_buffer {
+	struct vb2_v4l2_buffer vb;
+	dma_addr_t addr[3];
+	struct list_head list;
+};
+
+/**
+ * struct kmb_pipeline_ops - KMB pipeline operations
+ * @s_power: pipeline power operation ON/OFF
+ * @build: build LRT pipeline
+ * @teardown: teardown LRT pipeline
+ * @request_config: Request LRT pipeline configuration
+ * @release_config: Release LRT pipeline configuration
+ * @s_stream: set LRT pipeline stream state
+ */
+struct kmb_pipeline_ops {
+	int (*s_power)(struct media_entity *entity, int on);
+	int (*build)(struct media_entity *entity);
+	void (*teardown)(struct media_entity *entity);
+	int (*request_config)(struct media_entity *entity,
+			      struct v4l2_mbus_framefmt *fmt);
+	int (*release_config)(struct media_entity *entity);
+	int (*s_stream)(struct media_entity *entity, int enable);
+};
+
+/**
+ * struct kmb_video_channel_ops - xLink channel ID operations
+ * @accuire_id: accuire xlink channel ID
+ * @free_id: free xlink channel ID
+ */
+struct kmb_video_channel_ops {
+	int (*accuire_id)(void *priv);
+	void (*free_id)(void *priv, unsigned int id);
+};
+
+/**
+ * enum kmb_video_type - KMB Video node type
+ * @KMB_VIDEO_RAW_INPUT - RAW input video node
+ * @KMB_VIDEO_RAW_OUTPUT - RAW output video node
+ * @KMB_VIDEO_YUV_OUTPUT - YUV output video node
+ */
+enum kmb_video_type {
+	KMB_VIDEO_RAW_INPUT,
+	KMB_VIDEO_RAW_OUTPUT,
+	KMB_VIDEO_YUV_OUTPUT
+};
+
+/**
+ * struct kmb_video - KMB Video device structure
+ * @lock: mutex
+ * @video_lock: mutex serializing video operations
+ * @video: pointer to V4L2 sub-device
+ * @dma_dev: pointer to dma device
+ * @pad: media pad graph objects
+ * @pipe: pointer to media pipeline
+ * @pipe_ops: pointer to KMB pipeline operations
+ * @ipc_dev_handler: xLink IPC device handler
+ * @channel_ops: xLink channel id operations
+ * @channel_id: xLink channel id
+ * @type: video node type
+ * @packed_fmt: packed flag used only by raw input/output video nodes
+ * @cma_phy_addr: video channel physical CMA address
+ * @cma_vaddr: video channel virtual CMA address
+ * @priv: pointer to private data
+ */
+struct kmb_video {
+	struct mutex lock;
+	struct mutex video_lock;
+	struct video_device *video;
+	struct device *dma_dev;
+	struct media_pad pad;
+	struct media_pipeline *pipe;
+	struct kmb_pipeline_ops pipe_ops;
+	struct xlink_handle *ipc_dev_handler;
+	struct kmb_video_channel_ops channel_ops;
+	u32 channel_id;
+	enum kmb_video_type type;
+	bool packed_fmt;
+	u32 cma_phy_addr;
+	void *cma_vaddr;
+	void *priv;
+};
+
+/**
+ * struct kmb_video_fh - KMB video file handler
+ * @lock: mutex serializing access to fh
+ * @vb2_lock: mutex serializing access to vb2 queue
+ * @fh: V4L2 file handler
+ * @vb2_q: video buffer queue
+ * @active_pix: multiplanar format definitions
+ * @contiguous_memory: Flag indicating that plane memory is contiguous
+ * @dma_queue: DMA buffers queue
+ * @thread: pointer to worker thread data
+ * @cfg_requested: flag to indicate whether the configuration was requested
+ * @kmb_vid: pointer to KMB video device
+ */
+struct kmb_video_fh {
+	struct mutex lock;
+	struct mutex vb2_lock;
+	struct v4l2_fh fh;
+	struct vb2_queue vb2_q;
+	struct v4l2_pix_format_mplane active_pix;
+	bool contiguous_memory;
+	struct list_head dma_queue;
+	struct task_struct *thread;
+	bool cfg_requested;
+	struct kmb_video *kmb_vid;
+};
+
+int kmb_video_init(struct kmb_video *kmb_vid, const char *name,
+		   enum kmb_video_type type);
+void kmb_video_deinit(struct kmb_video *kmb_vid);
+
+int kmb_video_register(struct kmb_video *kmb_vid,
+		       struct v4l2_device *v4l2_dev);
+void kmb_video_unregister(struct kmb_video *kmb_vid);
+
+u32 kmb_video_get_channel_id(struct kmb_video *kmb_vid);
+
+#endif /* KMB_VIDEO_H */
diff --git a/include/uapi/linux/kmb-isp-ctl.h b/include/uapi/linux/kmb-isp-ctl.h
new file mode 100644
index 000000000000..45654b84364d
--- /dev/null
+++ b/include/uapi/linux/kmb-isp-ctl.h
@@ -0,0 +1,169 @@
+/* SPDX-License-Identifier: GPL-2.0-only WITH Linux-syscall-note */
+/*
+ * kmb-isp-ctl.h - KeemBay Camera custom events and ioctls.
+ *
+ * Copyright (C) 2018-2019 Intel Corporation
+ */
+#ifndef KMB_ISP_CTL_H
+#define KMB_ISP_CTL_H
+
+#include <linux/types.h>
+
+#define V4L2_EVENT_KMB_CAMERA_CLASS	(V4L2_EVENT_PRIVATE_START)
+#define V4L2_EVENT_KMB_SENSOR_SOF	(V4L2_EVENT_KMB_CAMERA_CLASS | 0x1)
+#define V4L2_EVENT_KMB_SENSOR_EOF	(V4L2_EVENT_KMB_CAMERA_CLASS | 0x2)
+#define V4L2_EVENT_KMB_ISP_SOF		(V4L2_EVENT_KMB_CAMERA_CLASS | 0x3)
+#define V4L2_EVENT_KMB_ISP_EOF		(V4L2_EVENT_KMB_CAMERA_CLASS | 0x4)
+#define V4L2_EVENT_KMB_CFG_SKIPPED	(V4L2_EVENT_KMB_CAMERA_CLASS | 0x5)
+#define V4L2_EVENT_KMB_CFG_MISSING	(V4L2_EVENT_KMB_CAMERA_CLASS | 0x6)
+#define V4L2_EVENT_KMB_BUF_MISSING	(V4L2_EVENT_KMB_CAMERA_CLASS | 0x7)
+#define V4L2_EVENT_KMB_GEN_ERROR	(V4L2_EVENT_KMB_CAMERA_CLASS | 0x8)
+
+#define V4L2_CID_KMB_CAMERA_TRANSFORM_HUB	(V4L2_CID_USER_BASE | 0x1)
+#define V4L2_CID_KMB_CAMERA_MODE		(V4L2_CID_USER_BASE | 0x2)
+#define V4L2_CID_ANALOGUE_GAIN_SHORT		(V4L2_CID_USER_BASE | 0x3)
+#define V4L2_CID_ANALOGUE_GAIN_VERY_SHORT	(V4L2_CID_USER_BASE | 0x4)
+#define V4L2_CID_EXPOSURE_SHORT			(V4L2_CID_USER_BASE | 0x5)
+#define V4L2_CID_EXPOSURE_VERY_SHORT		(V4L2_CID_USER_BASE | 0x6)
+#define V4L2_CID_SYNC_MODE			(V4L2_CID_USER_BASE | 0x7)
+#define V4L2_CID_SYNC_START			(V4L2_CID_USER_BASE | 0x8)
+#define V4L2_CID_ROW_TIME_NS			(V4L2_CID_USER_BASE | 0x9)
+
+/* MIPI Specification YUV 8 Bit 420 (DT 0x18) */
+#define V4L2_PIX_FMT_YUV420_MIPI8	v4l2_fourcc('Y', 'U', 'V', '8')
+/* MIPI Specification YUV 10 Bit 420 (DT 0x19) */
+#define V4L2_PIX_FMT_YUV420_MIPI10	v4l2_fourcc('Y', 'U', '1', '0')
+/* MIPI Specification YUV 10 Bit 420 Packed (DT 0x19) */
+#define V4L2_PIX_FMT_YUV420_MIPI10P	v4l2_fourcc('Y', '1', '0', 'P')
+/* MIPI Specification YUV 8 Bit 420 Legacy (DT 0x1A) */
+#define V4L2_PIX_FMT_YUV420_MIPI8L	v4l2_fourcc('Y', 'U', '8', 'L')
+/* MIPI Specification YUV 8 Bit 420 Chroma separated pixel sampling */
+#define V4L2_PIX_FMT_YUV420_MIPI8CS	v4l2_fourcc('Y', 'U', '8', 'C')
+/* MIPI Specification YUV 10 Bit 420 Chroma separated pixel sampling */
+#define V4L2_PIX_FMT_YUV420_MIPI10CS	v4l2_fourcc('Y', '1', '0', 'C')
+/* MIPI Specification YUV 10 Bit 420 Packed Chroma separated pixel sampling */
+#define V4L2_PIX_FMT_YUV420_MIPI10CSP	v4l2_fourcc('1', '0', 'C', 'P')
+/* MIPI Specification YUV 8 Bit 422 (DT 0x1E) */
+#define V4L2_PIX_FMT_YUV422_MIPI8	v4l2_fourcc('4', '2', '2', '8')
+/* MIPI Specification YUV 10 Bit 422 (DT 0x1F) */
+#define V4L2_PIX_FMT_YUV422_MIPI10	v4l2_fourcc('4', '2', '2', '1')
+/* MIPI Specification YUV 10 Bit 422 Packed (DT 0x1F) */
+#define V4L2_PIX_FMT_YUV422_MIPI10P	v4l2_fourcc('4', '1', '0', 'P')
+
+/**
+ * kmb_isp_cfg_event_data - KMB ISP configuration event private data
+ *
+ * @valid: flag to indicate whether index is valid
+ * @index: isp configuration buffer index
+ */
+struct kmb_isp_cfg_event_data {
+	__u8 valid;
+	__u8 index;
+};
+
+/**
+ * kmb_camera_transform_hub - KMB Camera transform hub
+ *
+ * @KMB_CAMERA_TRANSFORM_HUB_NONE: single output mode with no resizer
+ * @KMB_CAMERA_TRANSFORM_HUB_BASIC: up to two outputs, one can be resized
+ * @KMB_CAMERA_TRANSFORM_HUB_FULL: up to three outputs, two can be resized
+ * @KMB_CAMERA_TRANSFORM_HUB_STITCHING: 2/4 inputs stitched into up to two
+ *					outputs, one of which can be resized
+ * @KMB_CAMERA_TRANSFORM_HUB_EPTZ: electronic pan/tilt/zoom with one input and
+ *				   up to six outputs which can be resized
+ */
+enum kmb_camera_transform_hub {
+	KMB_CAMERA_TRANSFORM_HUB_NONE = 0,
+	KMB_CAMERA_TRANSFORM_HUB_BASIC = 1,
+	KMB_CAMERA_TRANSFORM_HUB_FULL = 2,
+	KMB_CAMERA_TRANSFORM_HUB_STITCHING = 3,
+	KMB_CAMERA_TRANSFORM_HUB_EPTZ = 4,
+};
+
+/**
+ * kmb_camera_mode - KMB Camera sensor mode
+ *
+ * @KMB_CAMERA_MODE_ULL: ultra low light sensor mode
+ * @KMB_CAMERA_MODE_HDR_2DOL: two frame digital overlap HDR mode
+ * @KMB_CAMERA_MODE_HDR_3DOL: three frame digital overlap HDR mode
+ * @KMB_CAMERA_MODE_NO_ISP:TODO
+ * @KMB_CAMERA_MODE_MONO: monochromatic sensor mode
+ */
+enum kmb_camera_mode {
+	KMB_CAMERA_MODE_ULL = 0,
+	KMB_CAMERA_MODE_HDR_2DOL = 1,
+	KMB_CAMERA_MODE_HDR_3DOL = 2,
+	KMB_CAMERA_MODE_NO_ISP = 3,
+	KMB_CAMERA_MODE_MONO = 4,
+};
+
+/**
+ * kmb_hw_sync_mode - KMB sensor hw sync mode
+ *
+ * @KMB_HW_SYNC_NONE: No hw sync
+ * @KMB_HW_SYNC_MAIN: HW main sync mode
+ * @KMB_HW_SYNC_AUX: HW auxiliary sync mode
+ */
+enum kmb_hw_sync_mode {
+	KMB_HW_SYNC_NONE = 0,
+	KMB_HW_SYNC_MAIN = 1,
+	KMB_HW_SYNC_AUX = 2
+};
+
+/**
+ * kmb_isp_hdr_type - KMB HDR type
+ *
+ * @NO_HDR: non-HDR mode is selected
+ * @HDR_2DOL_LI: two frame digital overlap HDR mode, Line Information
+ * @HDR_2DOL_VC: two frame digital overlap HDR mode, Virtual Channel
+ * @HDR_3DOL_VC: three frame digital overlap HDR mode, Virtual Channel
+ * @HDR_3DOL_LI: three frame digital overlap HDR mode, Line Information
+ */
+enum kmb_isp_hdr_type {
+	NO_HDR = 0,
+	HDR_2DOL_LI = 1,
+	HDR_2DOL_VC = 2,
+	HDR_3DOL_VC = 3,
+	HDR_3DOL_LI = 4,
+};
+
+/**
+ * enum kmb_camera_test_pattern_type - KMB Smart sensor test pattern type
+ * @KMB_CAMERA_TEST_PATTERN_REPEATING - Repeating pattern where each pixel has
+ *                                      a value of 0 to max_val max_val depends
+ *                                      on data type bit depth. Once max val is
+ *                                      reached, the pattern repeats. Does not
+ *                                      care about bayer pattern or YUV data
+ *                                      layout.
+ * @KMB_CAMERA_TEST_PATTERN_REPEATING_SEED - Generates a pattern based on host
+ *                                           seed. The pattern is a pure byte
+ *                                           stream, where the first byte is
+ *                                           the seed used for generation for
+ *                                           easier verification on host side.
+ * @KMB_CAMERA_TEST_PATTERN_REPEATING_SEED_TS - Same as above, but uses current
+ *                                              system timestamp as seed value.
+ * @KMB_CAMERA_TEST_PATTERN_COLOR_BARS - Color bars test pattern.
+ */
+enum kmb_camera_test_pattern_type {
+	KMB_CAMERA_TEST_PATTERN_REPEATING = 0,
+	KMB_CAMERA_TEST_PATTERN_REPEATING_SEED = 1,
+	KMB_CAMERA_TEST_PATTERN_REPEATING_SEED_TS = 2,
+	KMB_CAMERA_TEST_PATTERN_COLOR_BARS = 3,
+};
+
+/**
+ * kmb_isp_hdr_info - KMB HDR information
+ *
+ * @type: HDR type
+ * @offset0: long exposure offset, valid only in HDR_LINE_INTERLEAVED
+ * @offset1: short exposure offset, valid only in HDR_LINE_INTERLEAVED
+ * @offset2: very short exposure offset, valid only in HDR_LINE_INTERLEAVED
+ */
+struct kmb_isp_hdr_info {
+	__u16 type;
+	__u32 offset0;
+	__u32 offset1;
+	__u32 offset2;
+};
+
+#endif /* KMB_ISP_CTL_H */
-- 
2.17.1

