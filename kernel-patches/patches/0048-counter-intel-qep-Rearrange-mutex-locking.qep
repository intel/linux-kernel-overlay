From cb8cbef22fcd45f469c7439cc7c0afa3632a06dc Mon Sep 17 00:00:00 2001
From: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date: Fri, 19 Feb 2021 18:10:23 +0200
Subject: [PATCH 48/69] counter: intel-qep: Rearrange mutex locking

This change has two meanings:
- To get qep->enabled protected by the mutex. This is important to be
  able to atomically check busyness of the HW.
- Get mutex before doing runtime PM. Semantically it makes more sense to
  power up HW only after getting the mutex, not keeping it powered while
  waiting.

Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
---
 drivers/counter/intel-qep.c | 24 ++++++++++--------------
 1 file changed, 10 insertions(+), 14 deletions(-)

diff --git a/drivers/counter/intel-qep.c b/drivers/counter/intel-qep.c
index 402c3994a462..04dc85d9c9ea 100644
--- a/drivers/counter/intel-qep.c
+++ b/drivers/counter/intel-qep.c
@@ -180,18 +180,18 @@ static int intel_qep_function_set(struct counter_device *counter,
 	struct intel_qep *qep = counter_to_qep(counter);
 	u32 reg;
 
+	mutex_lock(&qep->lock);
 	pm_runtime_get_sync(qep->dev);
 
-	mutex_lock(&qep->lock);
 	reg = intel_qep_readl(qep, INTEL_QEPCON);
 	if (function == INTEL_QEP_ENCODER_MODE_SWAPPED)
 		reg |= INTEL_QEPCON_SWPAB;
 	else
 		reg &= ~INTEL_QEPCON_SWPAB;
 	intel_qep_writel(qep, INTEL_QEPCON, reg);
-	mutex_unlock(&qep->lock);
 
 	pm_runtime_put(qep->dev);
+	mutex_unlock(&qep->lock);
 
 	return 0;
 }
@@ -223,9 +223,9 @@ static int intel_qep_action_set(struct counter_device *counter,
 	struct intel_qep *qep = counter_to_qep(counter);
 	u32 reg;
 
+	mutex_lock(&qep->lock);
 	pm_runtime_get_sync(qep->dev);
 
-	mutex_lock(&qep->lock);
 	reg = intel_qep_readl(qep, INTEL_QEPCON);
 
 	if (action == INTEL_QEP_SYNAPSE_ACTION_RISING_EDGE)
@@ -234,9 +234,9 @@ static int intel_qep_action_set(struct counter_device *counter,
 		reg &= ~synapse->signal->id;
 
 	intel_qep_writel(qep, INTEL_QEPCON, reg);
-	mutex_unlock(&qep->lock);
 
 	pm_runtime_put(qep->dev);
+	mutex_unlock(&qep->lock);
 
 	return 0;
 }
@@ -341,25 +341,21 @@ static ssize_t enable_write(struct counter_device *counter,
 	if (ret < 0)
 		return ret;
 
+	mutex_lock(&qep->lock);
 	if (val && !qep->enabled) {
 		pm_runtime_get_sync(qep->dev);
-
-		mutex_lock(&qep->lock);
 		reg = intel_qep_readl(qep, INTEL_QEPCON);
 		reg |= INTEL_QEPCON_EN;
 		intel_qep_writel(qep, INTEL_QEPCON, reg);
 		qep->enabled = true;
-		mutex_unlock(&qep->lock);
 	} else if (!val && qep->enabled) {
-		mutex_lock(&qep->lock);
 		reg = intel_qep_readl(qep, INTEL_QEPCON);
 		reg &= ~INTEL_QEPCON_EN;
 		intel_qep_writel(qep, INTEL_QEPCON, reg);
 		qep->enabled = false;
-		mutex_unlock(&qep->lock);
-
 		pm_runtime_put(qep->dev);
 	}
+	mutex_unlock(&qep->lock);
 
 	return len;
 }
@@ -416,9 +412,9 @@ static ssize_t noise_write(struct counter_device *counter,
 	if (max > INTEL_QEPFLT_MAX_COUNT(max))
 		return -EINVAL;
 
+	mutex_lock(&qep->lock);
 	pm_runtime_get_sync(qep->dev);
 
-	mutex_lock(&qep->lock);
 	reg = intel_qep_readl(qep, INTEL_QEPCON);
 
 	if (max == 0) {
@@ -429,9 +425,9 @@ static ssize_t noise_write(struct counter_device *counter,
 	}
 
 	intel_qep_writel(qep, INTEL_QEPCON, reg);
-	mutex_unlock(&qep->lock);
 
 	pm_runtime_put(qep->dev);
+	mutex_unlock(&qep->lock);
 
 	return len;
 }
@@ -461,9 +457,9 @@ static ssize_t preset_enable_write(struct counter_device *counter,
 	if (ret < 0)
 		return ret;
 
+	mutex_lock(&qep->lock);
 	pm_runtime_get_sync(qep->dev);
 
-	mutex_lock(&qep->lock);
 	reg = intel_qep_readl(qep, INTEL_QEPCON);
 
 	if (val)
@@ -472,9 +468,9 @@ static ssize_t preset_enable_write(struct counter_device *counter,
 		reg |= INTEL_QEPCON_COUNT_RST_MODE;
 
 	intel_qep_writel(qep, INTEL_QEPCON, reg);
-	mutex_unlock(&qep->lock);
 
 	pm_runtime_put(qep->dev);
+	mutex_unlock(&qep->lock);
 
 	return len;
 }
-- 
2.27.0

