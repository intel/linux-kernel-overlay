From ebdf9a67779494ea84f1cee1874f56598abd5cff Mon Sep 17 00:00:00 2001
From: sudarshan ravula <sudarshan.ravula@intel.com>
Date: Fri, 4 Mar 2022 19:20:00 +0530
Subject: [PATCH 2/2] counter: Add init sequence in QEP Runtime PM resume

Initialize QEP driver in runtime power management resume sequence. As
per the QEP data sheet, the peripheral needs to be disabled to update
control register bits by the processsor.
Add mutex lock to protect the read-modify-write sequence on the control
register.

Signed-off-by: sudarshan ravula <sudarshan.ravula@intel.com>
---
 drivers/counter/intel-qep.c | 22 ++++++++++++++++++++--
 1 file changed, 20 insertions(+), 2 deletions(-)

diff --git a/drivers/counter/intel-qep.c b/drivers/counter/intel-qep.c
index 7ea66b227836..738a08d4f58b 100644
--- a/drivers/counter/intel-qep.c
+++ b/drivers/counter/intel-qep.c
@@ -562,6 +562,8 @@ static int intel_qep_runtime_resume(struct device *dev)
 	struct intel_qep *qep = pci_get_drvdata(pdev);
 	u32 d0i3c_reg;
 	u32 cgsr_reg;
+	u32 ret = 0;
+	u32 reg;
 
 	cgsr_reg = intel_qep_readl(qep, INTEL_QEP_CGSR);
 
@@ -582,9 +584,25 @@ static int intel_qep_runtime_resume(struct device *dev)
 
 		writel(d0i3c_reg, dev + INTEL_QEP_D0I3C);
 	}
-	intel_qep_init(qep);
 
-	return 0;
+	mutex_lock(&qep->lock);
+	if (qep->enabled) {
+		ret = -EBUSY;
+		goto out;
+	}
+	reg = intel_qep_readl(qep, INTEL_QEPCON);
+	reg &= ~INTEL_QEPCON_EN;
+	intel_qep_writel(qep, INTEL_QEPCON, reg);
+	qep->enabled = false;
+	/*
+	 * Make sure peripheral is disabled by flushing the write with
+	 * a dummy read
+	 */
+	reg = intel_qep_readl(qep, INTEL_QEPCON);
+
+out:
+	mutex_unlock(&qep->lock);
+	return ret;
 }
 #endif
 
-- 
2.25.1

