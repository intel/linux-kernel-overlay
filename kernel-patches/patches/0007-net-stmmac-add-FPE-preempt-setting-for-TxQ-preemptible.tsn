From 1004573df8723da642bec40addcdf39b8d88c8e5 Mon Sep 17 00:00:00 2001
From: Ong Boon Leong <boon.leong.ong@intel.com>
Date: Sun, 7 Feb 2021 09:46:54 +0800
Subject: [PATCH 07/32] net: stmmac: add FPE preempt setting for TxQ
 preemptible MAC mapping

Make taprio hardware offload mode to allow user to set FPE preempt
that specifies which TxQ is mapped to preemptible MAC.

For FPE enabling, it is expected that FPE preempt has at least one
TxQ be selected as preemptible, i.e. 'preempt' option cannot be all 0s.

The FPE preempt setting is used to configure PEC field in MTL_FPE_CTRL_STS
register.

Signed-off-by: Ong Boon Leong <boon.leong.ong@intel.com>
Co-developed-by: Mohammad Athari Bin Ismail <mohammad.athari.ismail@intel.com>
Signed-off-by: Mohammad Athari Bin Ismail <mohammad.athari.ismail@intel.com>
---
 drivers/net/ethernet/stmicro/stmmac/dwmac5.c  |  8 +++-
 drivers/net/ethernet/stmicro/stmmac/dwmac5.h  |  6 ++-
 .../ethernet/stmicro/stmmac/dwxgmac2_core.c   |  2 +-
 drivers/net/ethernet/stmicro/stmmac/hwif.h    |  7 +++-
 .../net/ethernet/stmicro/stmmac/stmmac_main.c |  7 +++-
 .../net/ethernet/stmicro/stmmac/stmmac_tc.c   | 41 ++++++++++++++++++-
 include/linux/stmmac.h                        |  1 +
 7 files changed, 65 insertions(+), 7 deletions(-)

diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac5.c b/drivers/net/ethernet/stmicro/stmmac/dwmac5.c
index e02cebc3f1b7..ec51e160a4ef 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac5.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac5.c
@@ -575,8 +575,9 @@ int dwmac5_flex_pps_config(void __iomem *ioaddr, int index,
 
 void dwmac5_fpe_configure(void __iomem *ioaddr, struct stmmac_fpe_cfg *cfg,
 			  u32 num_txq, u32 num_rxq,
-			  bool enable)
+			  u32 txqpec, bool enable)
 {
+	u32 txqmask = (1 << num_txq) - 1;
 	u32 value;
 
 	if (enable) {
@@ -585,6 +586,11 @@ void dwmac5_fpe_configure(void __iomem *ioaddr, struct stmmac_fpe_cfg *cfg,
 		value &= ~GMAC_RXQCTRL_FPRQ;
 		value |= (num_rxq - 1) << GMAC_RXQCTRL_FPRQ_SHIFT;
 		writel(value, ioaddr + GMAC_RXQ_CTRL1);
+
+		value = readl(ioaddr + MTL_FPE_CTRL_STS);
+		value &= ~(txqmask << PEC_SHIFT);
+		value |= (txqpec << PEC_SHIFT);
+		writel(value, ioaddr + MTL_FPE_CTRL_STS);
 	} else {
 		cfg->fpe_csr = 0;
 	}
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac5.h b/drivers/net/ethernet/stmicro/stmmac/dwmac5.h
index bf33a51d229e..83a926c57346 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac5.h
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac5.h
@@ -39,6 +39,10 @@
 #define MAC_PPSx_INTERVAL(x)		(0x00000b88 + ((x) * 0x10))
 #define MAC_PPSx_WIDTH(x)		(0x00000b8c + ((x) * 0x10))
 
+#define MTL_FPE_CTRL_STS		0x00000c90
+#define PEC				GENMASK(15, 8)
+#define PEC_SHIFT			8
+
 #define MTL_RXP_CONTROL_STATUS		0x00000ca0
 #define RXPI				BIT(31)
 #define NPE				GENMASK(23, 16)
@@ -104,7 +108,7 @@ int dwmac5_flex_pps_config(void __iomem *ioaddr, int index,
 			   u32 sub_second_inc, u32 systime_flags);
 void dwmac5_fpe_configure(void __iomem *ioaddr, struct stmmac_fpe_cfg *cfg,
 			  u32 num_txq, u32 num_rxq,
-			  bool enable);
+			  u32 txqpec, bool enable);
 void dwmac5_fpe_send_mpacket(void __iomem *ioaddr,
 			     struct stmmac_fpe_cfg *cfg,
 			     enum stmmac_mpacket_type type);
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwxgmac2_core.c b/drivers/net/ethernet/stmicro/stmmac/dwxgmac2_core.c
index e841e312077e..7cf7728bcd8a 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwxgmac2_core.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwxgmac2_core.c
@@ -1515,7 +1515,7 @@ static void dwxgmac2_set_arp_offload(struct mac_device_info *hw, bool en,
 
 static void dwxgmac3_fpe_configure(void __iomem *ioaddr, struct stmmac_fpe_cfg *cfg,
 				   u32 num_txq,
-				   u32 num_rxq, bool enable)
+				   u32 num_rxq, u32 txqpec, bool enable)
 {
 	u32 value;
 
diff --git a/drivers/net/ethernet/stmicro/stmmac/hwif.h b/drivers/net/ethernet/stmicro/stmmac/hwif.h
index 7be04b54738b..c310a74c9610 100644
--- a/drivers/net/ethernet/stmicro/stmmac/hwif.h
+++ b/drivers/net/ethernet/stmicro/stmmac/hwif.h
@@ -421,7 +421,7 @@ struct stmmac_ops {
 	void (*set_arp_offload)(struct mac_device_info *hw, bool en, u32 addr);
 	void (*fpe_configure)(void __iomem *ioaddr, struct stmmac_fpe_cfg *cfg,
 			      u32 num_txq, u32 num_rxq,
-			      bool enable);
+			      u32 txqpec, bool enable);
 	void (*fpe_send_mpacket)(void __iomem *ioaddr,
 				 struct stmmac_fpe_cfg *cfg,
 				 enum stmmac_mpacket_type type);
@@ -604,6 +604,7 @@ struct flow_cls_offload;
 struct tc_taprio_qopt_offload;
 struct tc_etf_qopt_offload;
 struct tc_query_caps_base;
+struct tc_preempt_qopt_offload;
 
 struct stmmac_tc_ops {
 	int (*init)(struct stmmac_priv *priv);
@@ -619,6 +620,8 @@ struct stmmac_tc_ops {
 			 struct tc_etf_qopt_offload *qopt);
 	int (*query_caps)(struct stmmac_priv *priv,
 			  struct tc_query_caps_base *base);
+	int (*setup_preempt)(struct stmmac_priv *priv,
+			     struct tc_preempt_qopt_offload *qopt);
 };
 
 #define stmmac_tc_init(__priv, __args...) \
@@ -635,6 +638,8 @@ struct stmmac_tc_ops {
 	stmmac_do_callback(__priv, tc, setup_etf, __args)
 #define stmmac_tc_query_caps(__priv, __args...) \
 	stmmac_do_callback(__priv, tc, query_caps, __args)
+#define stmmac_tc_setup_preempt(__priv, __args...) \
+	stmmac_do_callback(__priv, tc, setup_preempt, __args)
 
 struct stmmac_counters;
 
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
index c283aa73c1ac..2c33df9c691c 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
@@ -6272,6 +6272,8 @@ static int stmmac_setup_tc(struct net_device *ndev, enum tc_setup_type type,
 		return stmmac_tc_setup_taprio(priv, priv, type_data);
 	case TC_SETUP_QDISC_ETF:
 		return stmmac_tc_setup_etf(priv, priv, type_data);
+	case TC_SETUP_PREEMPT:
+		return stmmac_tc_setup_preempt(priv, priv, type_data);
 	default:
 		return -EOPNOTSUPP;
 	}
@@ -7391,6 +7393,7 @@ static void stmmac_fpe_lp_task(struct work_struct *work)
 	enum stmmac_fpe_state *lp_state = &fpe_cfg->lp_fpe_state;
 	bool *hs_enable = &fpe_cfg->hs_enable;
 	bool *enable = &fpe_cfg->enable;
+	u32 *txqpec = &fpe_cfg->txqpec;
 	int retries = 20;
 
 	while (retries-- > 0) {
@@ -7404,7 +7407,7 @@ static void stmmac_fpe_lp_task(struct work_struct *work)
 					     fpe_cfg,
 					     priv->plat->tx_queues_to_use,
 					     priv->plat->rx_queues_to_use,
-					     *enable);
+					     *txqpec, *enable);
 
 			netdev_info(priv->dev, "configured FPE\n");
 
@@ -7913,7 +7916,7 @@ int stmmac_suspend(struct device *dev)
 		stmmac_fpe_configure(priv, priv->ioaddr,
 				     priv->plat->fpe_cfg,
 				     priv->plat->tx_queues_to_use,
-				     priv->plat->rx_queues_to_use, false);
+				     priv->plat->rx_queues_to_use, 0, false);
 
 		stmmac_fpe_handshake(priv, false);
 		stmmac_fpe_stop_wq(priv);
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_tc.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_tc.c
index cce00719937d..0d9c75fe9ce4 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_tc.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_tc.c
@@ -937,12 +937,17 @@ static void tc_taprio_map_maxsdu_txq(struct stmmac_priv *priv,
 	}
 }
 
+#define FPE_FMT	"If both EST and FPE are enabled, "\
+		"TxQ0 must not be express queue. "\
+		"So, changing TxQ0 setting to preemptible queue.\n"
 static int tc_taprio_configure(struct stmmac_priv *priv,
 			       struct tc_taprio_qopt_offload *qopt)
 {
 	u32 size, wid = priv->dma_cap.estwid, dep = priv->dma_cap.estdep;
+	u32 txqmask = (1 << priv->dma_cap.number_tx_queues) - 1;
 	struct plat_stmmacenet_data *plat = priv->plat;
 	struct timespec64 time, current_time, qopt_time;
+	u32 txqpec = priv->plat->fpe_cfg->txqpec;
 	ktime_t current_time_ns;
 	bool fpe = false;
 	int i, ret = 0;
@@ -1072,6 +1077,32 @@ static int tc_taprio_configure(struct stmmac_priv *priv,
 		return -EOPNOTSUPP;
 	}
 
+	if (fpe) {
+		if (!txqpec) {
+			netdev_err(priv->dev, "FPE preempt must not all 0s!\n");
+			mutex_unlock(&priv->plat->est->lock);
+			return -EINVAL;
+		}
+
+		/* Check PEC is within TxQ range */
+		if (txqpec & ~txqmask) {
+			netdev_err(priv->dev, "FPE preempt is out-of-bound.\n");
+			mutex_unlock(&priv->plat->est->lock);
+			return -EINVAL;
+		}
+
+		/* When EST and FPE are both enabled, TxQ0 is always preemptible
+		 * queue. If FPE is enabled, we expect at least lsb is set.
+		 */
+		if (txqpec && !(txqpec & BIT(0))) {
+			netdev_warn(priv->dev, FPE_FMT);
+			priv->plat->fpe_cfg->txqpec |= BIT(0);
+		}
+
+		netdev_info(priv->dev, "FPE: TxQ PEC = 0x%X\n",
+			    priv->plat->fpe_cfg->txqpec);
+	}
+
 	/* Actual FPE register configuration will be done after FPE handshake
 	 * is success.
 	 */
@@ -1113,7 +1144,7 @@ static int tc_taprio_configure(struct stmmac_priv *priv,
 			     priv->plat->fpe_cfg,
 			     priv->plat->tx_queues_to_use,
 			     priv->plat->rx_queues_to_use,
-			     false);
+			     0, false);
 	netdev_info(priv->dev, "disabled FPE\n");
 
 	stmmac_fpe_handshake(priv, false);
@@ -1213,6 +1244,13 @@ static int tc_query_caps(struct stmmac_priv *priv,
 	}
 }
 
+static int tc_setup_preempt(struct stmmac_priv *priv,
+			    struct tc_preempt_qopt_offload *qopt)
+{
+	priv->plat->fpe_cfg->txqpec = qopt->preemptible_queues;
+	return 0;
+}
+
 const struct stmmac_tc_ops dwmac510_tc_ops = {
 	.init = tc_init,
 	.setup_cls_u32 = tc_setup_cls_u32,
@@ -1221,4 +1259,5 @@ const struct stmmac_tc_ops dwmac510_tc_ops = {
 	.setup_taprio = tc_setup_taprio,
 	.setup_etf = tc_setup_etf,
 	.query_caps = tc_query_caps,
+	.setup_preempt = tc_setup_preempt,
 };
diff --git a/include/linux/stmmac.h b/include/linux/stmmac.h
index 34ee64090581..a371af77bb58 100644
--- a/include/linux/stmmac.h
+++ b/include/linux/stmmac.h
@@ -174,6 +174,7 @@ enum stmmac_fpe_task_state_t {
 struct stmmac_fpe_cfg {
 	bool enable;				/* FPE enable */
 	bool hs_enable;				/* FPE handshake enable */
+	u32 txqpec;				/* Preemption classification */
 	enum stmmac_fpe_state lp_fpe_state;	/* Link Partner FPE state */
 	enum stmmac_fpe_state lo_fpe_state;	/* Local station FPE state */
 	u32 fpe_csr;				/* MAC_FPE_CTRL_STS reg cache */
-- 
2.25.1

