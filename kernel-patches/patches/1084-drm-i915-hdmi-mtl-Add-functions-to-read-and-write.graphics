From ca4e39251a9186f7668e9e5bbf1fa2f6b88a1b91 Mon Sep 17 00:00:00 2001
From: "Garg, Nemesa" <nemesa.garg@intel.com>
Date: Tue, 24 Jan 2023 20:04:00 +0530
Subject: [PATCH 1084/1096] drm/i915/hdmi/mtl: Add functions to read and write
 emp registers

To send Extended Metadata Packets for VRR, EMP_CTL/HEADER/DATA registers
need to be programmed. This patch adds functions to write the EMP
registers with values computed during compute config phase.

Signed-off-by: Garg, Nemesa <nemesa.garg@intel.com>
Signed-off-by: Ankit Nautiyal <ankit.k.nautiyal@intel.com>
Reviewed-by: Manasi Navare <manasi.d.navare@intel.com>
---
 drivers/gpu/drm/i915/display/intel_hdmi.c | 100 ++++++++++++++++++++++
 drivers/gpu/drm/i915/display/intel_hdmi.h |  17 +++-
 2 files changed, 116 insertions(+), 1 deletion(-)

diff --git a/drivers/gpu/drm/i915/display/intel_hdmi.c b/drivers/gpu/drm/i915/display/intel_hdmi.c
index 0eda27ecf199..080dc9c4e6b0 100644
--- a/drivers/gpu/drm/i915/display/intel_hdmi.c
+++ b/drivers/gpu/drm/i915/display/intel_hdmi.c
@@ -4564,3 +4564,103 @@ void intel_hdmi_set_hcactive(struct drm_i915_private *dev_priv,
 
 	intel_de_write(dev_priv, TRANS_HDMI_HCTOTAL(cpu_transcoder), val);
 }
+
+static void intel_hdmi_mtl_write_vtemp(struct intel_encoder *encoder,
+				       const struct intel_crtc_state *crtc_state)
+{
+	const struct hdmi_vtem_payload *payload = &crtc_state->vrr.vtem_config.payload;
+	const struct hdmi_emp_first_dsf *vtemp = &crtc_state->vrr.vtem_config.vtemp.first_data_set;
+	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
+	enum transcoder trans = crtc_state->cpu_transcoder;
+	u32 emp_ctl = intel_de_read(dev_priv, TRANS_HDMI_EMP_CTL(trans));
+	u32 emp_header = 0;
+	u32 data[VTEM_NUM_DWORDS] = {0};
+	u8 payload_data[EMP_PAYLOAD_SIZE] = {0};
+	int i;
+
+	payload_data[0] = vtemp->pb0_sync << 1 | vtemp->pb0_vfr << 2 | vtemp->pb0_afr << 3
+		| vtemp->ds_type << 4 | vtemp->pb0_end << 6 | vtemp->pb0_new << 7;
+
+	payload_data[2] = vtemp->org_id;
+
+	payload_data[3] = vtemp->data_set_tag;
+	payload_data[4] = 0;
+	payload_data[5] = vtemp->data_set_length;
+	payload_data[6] = 0;
+
+	payload_data[7] = payload->vrr_en | payload->m_const << 1 | payload->qms_en << 2
+		| payload->fva_factor << 4;
+
+	payload_data[8] |= payload->base_vfront;
+
+	/* bits 8,9 of base refresh rate */
+	payload_data[9] = (payload->base_refresh_rate & 0x300) >> 8 | payload->rb << 2
+		| payload->next_tfr << 3;
+
+	/* bits 0-7 of base refresh rate */
+	payload_data[10] |= payload->base_refresh_rate & 0xFF;
+
+	data[0] = payload_data[3] << 24 | payload_data[2] << 16 |
+		payload_data[1] << 8 | payload_data[0];
+
+	data[1] = payload_data[7] << 24 | payload_data[6] << 16 |
+		payload_data[5] << 8 | payload_data[4];
+
+	data[2] = payload_data[11] << 24 | payload_data[10] << 16 |
+		payload_data[9] << 8 | payload_data[8];
+
+	emp_ctl |= HDMI_VTEM_ENABLE;
+
+	intel_de_write(dev_priv, TRANS_HDMI_EMP_CTL(trans), emp_ctl);
+
+	/*TRANS_HDMI_EMP_DATA is wriiten as DW at a time and stored in FIFO internally */
+	for (i = 0; i < VTEM_NUM_DWORDS; i++)
+		intel_de_write(dev_priv, TRANS_HDMI_EMP_DATA(trans), data[i]);
+
+	intel_hdmi_fill_emp_header_byte(&crtc_state->vrr.vtem_config.vtemp, &emp_header);
+
+	intel_de_write(dev_priv, TRANS_HDMI_EMP_HEADER(trans), emp_header);
+}
+
+void intel_mtl_write_emp(struct intel_encoder *encoder,
+			 const struct intel_crtc_state *crtc_state)
+{
+	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
+
+	if (DISPLAY_VER(dev_priv) < 14)
+		return;
+
+	if (crtc_state->vrr.vtem_config.vtemp.enabled)
+		intel_hdmi_mtl_write_vtemp(encoder, crtc_state);
+}
+
+static void intel_hdmi_mtl_read_vtemp(struct intel_encoder *encoder,
+				      struct intel_crtc_state *crtc_state)
+{
+	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
+	enum transcoder trans = crtc_state->cpu_transcoder;
+	u32 emp_ctl, emp_header;
+
+	emp_ctl = intel_de_read(dev_priv, TRANS_HDMI_EMP_CTL(trans));
+
+	if (emp_ctl & HDMI_VTEM_ENABLE) {
+		crtc_state->vrr.vtem_config.vtemp.type = HDMI_EMP_TYPE_VTEM;
+		crtc_state->vrr.vtem_config.vtemp.enabled = true;
+	}
+
+	emp_header =
+		intel_de_read(dev_priv, TRANS_HDMI_EMP_HEADER(trans));
+
+	crtc_state->vrr.vtem_config.vtemp.first_data_set.ds_type =
+		REG_FIELD_GET(TRANS_HDMI_EMP_DS_TYPE_MASK, emp_header);
+}
+
+void intel_mtl_read_emp(struct intel_encoder *encoder,
+			struct intel_crtc_state *crtc_state)
+{
+	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
+
+	if (DISPLAY_VER(dev_priv) < 14)
+		return;
+	intel_hdmi_mtl_read_vtemp(encoder, crtc_state);
+}
diff --git a/drivers/gpu/drm/i915/display/intel_hdmi.h b/drivers/gpu/drm/i915/display/intel_hdmi.h
index 4e561ad25cce..2b9ee8403e30 100644
--- a/drivers/gpu/drm/i915/display/intel_hdmi.h
+++ b/drivers/gpu/drm/i915/display/intel_hdmi.h
@@ -24,6 +24,18 @@ struct intel_encoder;
 struct intel_hdmi;
 union hdmi_infoframe;
 
+/* Total Payload Bytes in an EMP(PB0-PB27) is 28 Bytes*/
+#define EMP_PAYLOAD_SIZE 28
+
+/*
+ * Total VTEM Payload Packets to be written in 32bit EMP DATA REG
+ * DW1: PB3|PB2|PB1|PB0
+ * DW2: MD0|PB6|PB5|PB4
+ * DW3: MD4|MD3|MD2|MD1
+ * DW4-7: Padding
+ */
+#define VTEM_NUM_DWORDS (EMP_PAYLOAD_SIZE / 4)
+
 void intel_hdmi_init_connector(struct intel_digital_port *dig_port,
 			       struct intel_connector *intel_connector);
 int intel_hdmi_compute_config(struct intel_encoder *encoder,
@@ -65,5 +77,8 @@ void intel_hdmi_fill_emp_header_byte(const struct hdmi_extended_metadata_packet
 				     u32 *emp_header);
 void intel_hdmi_set_hcactive(struct drm_i915_private *dev_priv,
 			     const struct intel_crtc_state *crtc_state);
-
+void intel_mtl_write_emp(struct intel_encoder *encoder,
+			 const struct intel_crtc_state *crtc_state);
+void intel_mtl_read_emp(struct intel_encoder *encoder,
+			struct intel_crtc_state *crtc_state);
 #endif /* __INTEL_HDMI_H__ */
-- 
2.25.1

