From 727b148e5943f45d8d4176bccbdb2bb2654bbb0f Mon Sep 17 00:00:00 2001
From: zouxiaoh <xiaohong.zou@intel.com>
Date: Wed, 7 Aug 2024 17:10:03 +0800
Subject: [PATCH 13/27] driver: media: pci: i2c: support IMX390 on kernel 6.6

Change Description:
Support IMX390 on kernel 6.6.
Fix gpio default value check issue.
Fix stop 2nd stream, 1st stream entity be set to NULL issue.
Support MIPI PORT 0 for MTL.

Test Platform:
MTL

Signed-off-by: hepengpx <pengpengx.he@intel.com>
Signed-off-by: zouxiaoh <xiaohong.zou@intel.com>
---
 drivers/media/i2c/imx390.c                    |  6 ++---
 drivers/media/i2c/ti960-des.c                 | 27 ++++++++-----------
 drivers/media/pci/intel/ipu-isys-queue.c      | 11 +++++++-
 drivers/media/pci/intel/ipu-isys-video.c      | 25 ++++++++++++++---
 drivers/media/pci/intel/ipu-isys-video.h      |  5 ++++
 .../media/platform/intel/ipu6-acpi-pdata.c    | 11 ++++----
 6 files changed, 55 insertions(+), 30 deletions(-)

diff --git a/drivers/media/i2c/imx390.c b/drivers/media/i2c/imx390.c
index aca33716565a..0a5bbed85c38 100644
--- a/drivers/media/i2c/imx390.c
+++ b/drivers/media/i2c/imx390.c
@@ -1,5 +1,5 @@
 // SPDX-License-Identifier: GPL-2.0
-// Copyright (c) 2021-2023 Intel Corporation.
+// Copyright (c) 2021-2024 Intel Corporation.
 
 #include <asm/unaligned.h>
 #include <linux/acpi.h>
@@ -1702,7 +1702,6 @@ static int imx390_set_format(struct v4l2_subdev *sd,
 {
 	struct imx390 *imx390 = to_imx390(sd);
 	const struct imx390_mode *mode;
-	int ret = 0;
 	s32 vblank_def;
 	s64 hblank;
 	int i;
@@ -1907,7 +1906,7 @@ static int imx390_identify_module(struct imx390 *imx390)
 	return 0;
 }
 
-static int imx390_remove(struct i2c_client *client)
+static void imx390_remove(struct i2c_client *client)
 {
 	struct v4l2_subdev *sd = i2c_get_clientdata(client);
 	struct imx390 *imx390 = to_imx390(sd);
@@ -1918,7 +1917,6 @@ static int imx390_remove(struct i2c_client *client)
 	pm_runtime_disable(&client->dev);
 	mutex_destroy(&imx390->mutex);
 
-	return 0;
 }
 
 irqreturn_t imx390_threaded_irq_fn(int irq, void *dev_id)
diff --git a/drivers/media/i2c/ti960-des.c b/drivers/media/i2c/ti960-des.c
index 6644c9a1c663..a335c22b490b 100644
--- a/drivers/media/i2c/ti960-des.c
+++ b/drivers/media/i2c/ti960-des.c
@@ -1,5 +1,5 @@
 // SPDX-License-Identifier: GPL-2.0
-// Copyright (C) 2023 Intel Corporation
+// Copyright (C) 2024 Intel Corporation
 
 #include <linux/device.h>
 #include <linux/gpio.h>
@@ -11,6 +11,8 @@
 #include <linux/ipu-isys.h>
 #include <linux/version.h>
 
+#include <linux/gpio/driver.h>
+
 #include <media/media-device.h>
 #include <media/media-entity.h>
 #include <media/ti960.h>
@@ -395,10 +397,8 @@ static int ti960_enum_mbus_code(struct v4l2_subdev *sd,
 				struct v4l2_subdev_state *sd_state,
 				struct v4l2_subdev_mbus_code_enum *code)
 {
-	struct ti960 *va = to_ti960(sd);
 	const uint32_t *supported_code =
 		ti960_supported_codes[code->pad];
-	bool next_stream = false;
 	int i;
 
 	for (i = 0; supported_code[i]; i++) {
@@ -427,12 +427,11 @@ static const struct ti960_csi_data_format
 static int ti960_get_frame_desc(struct v4l2_subdev *sd,
 	unsigned int pad, struct v4l2_mbus_frame_desc *desc)
 {
-	struct ti960 *va = to_ti960(sd);
 	int sink_pad = pad;
 
 	if (sink_pad >= 0) {
 		struct media_pad *remote_pad =
-			media_entity_remote_pad(&sd->entity.pads[sink_pad]);
+			media_pad_remote_pad_first(&sd->entity.pads[sink_pad]);
 		if (remote_pad) {
 			struct v4l2_subdev *rsd = media_entity_to_v4l2_subdev(remote_pad->entity);
 
@@ -699,7 +698,7 @@ static int ti960_registered(struct v4l2_subdev *subdev)
 
 			/* boot sequence */
 			for (m = 0; m < TI960_MAX_GPIO_POWERUP_SEQ; m++) {
-				if (va->subdev_pdata[k].gpio_powerup_seq[m] < 0)
+				if (va->subdev_pdata[k].gpio_powerup_seq[m] == (char)-1)
 					break;
 				ti953_reg_write(&va->sd, info->rx_port, info->ser_alias,
 						TI953_LOCAL_GPIO_DATA,
@@ -844,7 +843,7 @@ static bool ti960_broadcast_mode(struct v4l2_subdev *subdev)
 
 	for (i = 0; i < NR_OF_TI960_SINK_PADS; i++) {
 		struct media_pad *remote_pad =
-			media_entity_remote_pad(&va->pad[i]);
+			media_pad_remote_pad_first(&va->pad[i]);
 
 		if (!remote_pad)
 			continue;
@@ -887,7 +886,6 @@ static bool ti960_broadcast_mode(struct v4l2_subdev *subdev)
 static int ti960_rx_port_config(struct ti960 *va, int sink, int rx_port)
 {
 	int rval;
-	int i;
 	unsigned int csi_vc_map;
 
 	/* Select RX port. */
@@ -987,7 +985,7 @@ static int ti960_set_stream(struct v4l2_subdev *subdev, int enable)
 	bitmap_zero(rx_port_enabled, 32);
 	for (i = 0; i < NR_OF_TI960_SINK_PADS; i++) {
 		struct media_pad *remote_pad =
-			media_entity_remote_pad(&va->pad[i]);
+			media_pad_remote_pad_first(&va->pad[i]);
 
 		if (!remote_pad)
 			continue;
@@ -1195,7 +1193,6 @@ static int ti960_s_ctrl(struct v4l2_ctrl *ctrl)
 {
 	struct ti960 *va = container_of(ctrl->handler,
 					     struct ti960, ctrl_handler);
-	struct i2c_client *client = v4l2_get_subdevdata(&va->sd);
 	u32 val;
 	u8 vc_id;
 	u8 state;
@@ -1468,7 +1465,7 @@ static int ti960_gpio_direction_output(struct gpio_chip *chip,
 static int ti960_probe(struct i2c_client *client)
 {
 	struct ti960 *va;
-	int i, j, k, l, rval = 0;
+	int i, rval = 0;
 	int gpio_FPD = 0;
 
 	if (client->dev.platform_data == NULL)
@@ -1583,22 +1580,21 @@ static int ti960_probe(struct i2c_client *client)
 		if (gpio_FPD == 0)
 			gpio_set_value(va->pdata->FPD_gpio, 0);
 
-		devm_gpio_free(&client->dev,
-			va->pdata->FPD_gpio);
+		gpio_free(va->pdata->FPD_gpio);
 	}
 
 	dev_err(&client->dev, "%s Probe Failed", va->sd.name);
 	return rval;
 }
 
-static int ti960_remove(struct i2c_client *client)
+static void ti960_remove(struct i2c_client *client)
 {
 	struct v4l2_subdev *subdev = i2c_get_clientdata(client);
 	struct ti960 *va = to_ti960(subdev);
 	int i;
 
 	if (!va)
-		return 0;
+		return;
 
 	mutex_destroy(&va->mutex);
 	v4l2_ctrl_handler_free(&va->ctrl_handler);
@@ -1617,7 +1613,6 @@ static int ti960_remove(struct i2c_client *client)
 
 	gpiochip_remove(&va->gc);
 
-	return 0;
 }
 
 #ifdef CONFIG_PM
diff --git a/drivers/media/pci/intel/ipu-isys-queue.c b/drivers/media/pci/intel/ipu-isys-queue.c
index fb88cd3e0f00..07e885819baa 100644
--- a/drivers/media/pci/intel/ipu-isys-queue.c
+++ b/drivers/media/pci/intel/ipu-isys-queue.c
@@ -1082,6 +1082,15 @@ static void stop_streaming(struct vb2_queue *q)
 	dev_dbg(&av->isys->adev->dev, "stop: %s: enter\n",
 		av->vdev.name);
 
+	bool is_vc = false;
+	struct media_pad *source_pad = media_pad_remote_pad_first(&av->pad);
+
+	if (!source_pad) {
+		dev_err(&av->isys->adev->dev, "stop stream: no link.\n");
+		return;
+	}
+	is_vc = is_support_vc(source_pad, ip);
+
 	mutex_unlock(&av->mutex);
 	mutex_lock(&av->isys->reset_mutex);
 	while (av->isys->in_reset || av->isys->in_stop_streaming) {
@@ -1147,7 +1156,7 @@ static void stop_streaming(struct vb2_queue *q)
 	mutex_unlock(&av->isys->reset_mutex);
 
 	if (av->isys->reset_needed) {
-		if (!ip->nr_streaming)
+		if (!ip->nr_streaming && (!is_vc || is_has_metadata(ip)))
 			ipu_isys_reset(av, ip);
 		else
 			av->isys->reset_needed = 0;
diff --git a/drivers/media/pci/intel/ipu-isys-video.c b/drivers/media/pci/intel/ipu-isys-video.c
index 5776909663ef..0fb44949fbf1 100644
--- a/drivers/media/pci/intel/ipu-isys-video.c
+++ b/drivers/media/pci/intel/ipu-isys-video.c
@@ -853,7 +853,7 @@ csi_short_packet_prepare_fw_cfg(struct ipu_isys_pipeline *ip,
 
 #define MEDIA_ENTITY_MAX_PADS		512
 
-static bool is_support_vc(struct media_pad *source_pad,
+bool is_support_vc(struct media_pad *source_pad,
 			  struct ipu_isys_pipeline *ip)
 {
 	struct media_pad *remote_pad = source_pad;
@@ -907,6 +907,17 @@ static bool is_support_vc(struct media_pad *source_pad,
 	return true;
 }
 
+bool is_has_metadata(const struct ipu_isys_pipeline *ip)
+{
+	int i = 0;
+
+	for (i = 0; i < CSI2_BE_SOC_SOURCE_PADS_NUM; i++) {
+		if (ip->asv[i].dt == IPU_ISYS_MIPI_CSI2_TYPE_EMBEDDED8)
+			return true;
+	}
+	return false;
+}
+
 static int ipu_isys_query_sensor_info(struct media_pad *source_pad,
 				      struct ipu_isys_pipeline *ip)
 {
@@ -1010,8 +1021,16 @@ static void media_pipeline_stop_for_vc(struct ipu_isys_video *av)
 		return;
 
 	media_graph_walk_start(&graph, entity);
-	while ((entity = media_graph_walk_next(&graph)))
-		entity->pads[0].pipe = NULL;
+	dev_dbg(av->vdev.entity.graph_obj.mdev->dev,
+			"stream count: %u, av entity name: %s.\n",
+			av->ip.csi2->stream_count, av->vdev.entity.name);
+	while ((entity = media_graph_walk_next(&graph))) {
+		dev_dbg(av->vdev.entity.graph_obj.mdev->dev,
+				"walk entity name: %s.\n",
+				entity->name);
+		if (av->ip.csi2->stream_count == 0 || !strcmp(entity->name, av->vdev.entity.name))
+			entity->pads[0].pipe = NULL;
+	}
 
 	media_graph_walk_cleanup(&graph);
 }
diff --git a/drivers/media/pci/intel/ipu-isys-video.h b/drivers/media/pci/intel/ipu-isys-video.h
index 5eb66d1eae4b..f71ea62662d2 100644
--- a/drivers/media/pci/intel/ipu-isys-video.h
+++ b/drivers/media/pci/intel/ipu-isys-video.h
@@ -192,4 +192,9 @@ void ipu_isys_video_add_capture_done(struct ipu_isys_pipeline *ip,
 				      (struct ipu_isys_pipeline *ip,
 				       struct ipu_fw_isys_resp_info_abi *resp));
 
+bool is_support_vc(struct media_pad *source_pad,
+						struct ipu_isys_pipeline *ip);
+
+bool is_has_metadata(const struct ipu_isys_pipeline *ip);
+
 #endif /* IPU_ISYS_VIDEO_H */
diff --git a/drivers/media/platform/intel/ipu6-acpi-pdata.c b/drivers/media/platform/intel/ipu6-acpi-pdata.c
index 1ff72ba1c071..32d69fcc8330 100644
--- a/drivers/media/platform/intel/ipu6-acpi-pdata.c
+++ b/drivers/media/platform/intel/ipu6-acpi-pdata.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (c) 2016--2023 Intel Corporation.
+ * Copyright (c) 2016--2024 Intel Corporation.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License version
@@ -712,12 +712,11 @@ int set_pdata(struct ipu_isys_subdev_info **sensor_sd,
 			pdata->suffix = serdes_info.deser_num + SUFFIX_BASE + 1;
 			pr_info("IPU6 ACPI: create %s %c, on deserializer port %d",
 				sensor_name, pdata->suffix, serdes_info.deser_num);
-		} else if (port > 0) {
-			pdata->suffix = port + SUFFIX_BASE;
-			pr_info("IPU6 ACPI: create %s %c, on mipi port %d",
+		} else if (port >= 0) {
+			pdata->suffix = port + SUFFIX_BASE + 1;
+			pr_info("IPU6 ACPI: create %s %c, on deserializer port %d",
 				sensor_name, pdata->suffix, port);
-		} else
-			pr_err("IPU6 ACPI: Invalid MIPI Port : %d", port);
+		}
 
 		if (!strcmp(sensor_name, IMX390_NAME))
 			set_ti960_gpio(ctl_data, &pdata);
-- 
2.34.1

