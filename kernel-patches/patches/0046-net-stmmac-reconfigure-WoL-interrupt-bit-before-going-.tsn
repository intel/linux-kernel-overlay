From 8bc23225af52d1872ba900769a35e00b6020d486 Mon Sep 17 00:00:00 2001
From: Gan Yi Fang <yi.fang.gan@intel.com>
Date: Mon, 24 Jul 2023 03:10:06 -0400
Subject: [PATCH 46/47] net: stmmac: reconfigure WoL interrupt bit before going
 S5

This patch introduces a new function stmmac_close() which will be
called before going to S5. This function will check and set the
WoL interrupt bit and then proceed with the normal shutdown flow.

Previous implementation reconfigures the PHY WoL interrupt before
suspending which is applicable for S3 and S4 only. However,
S5 uses different flow causing issues with the WoL interrupt bits.

Signed-off-by: Gan Yi Fang <yi.fang.gan@intel.com>
---
 .../net/ethernet/stmicro/stmmac/dwmac-intel.c | 12 +--------
 drivers/net/ethernet/stmicro/stmmac/stmmac.h  |  1 +
 .../net/ethernet/stmicro/stmmac/stmmac_main.c | 25 ++++++++++++++++++-
 3 files changed, 26 insertions(+), 12 deletions(-)

diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac-intel.c b/drivers/net/ethernet/stmicro/stmmac/dwmac-intel.c
index 6f9f624aac8a..8059af1018c6 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac-intel.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac-intel.c
@@ -1358,20 +1358,10 @@ static int __maybe_unused intel_eth_pci_suspend(struct device *dev)
 {
 	struct pci_dev *pdev = to_pci_dev(dev);
 	struct net_device *ndev = dev_get_drvdata(&pdev->dev);
-	struct stmmac_priv *priv = netdev_priv(ndev);
 	int ret;
 
 	rtnl_lock();
-	if (priv->plat->use_phy_wol) {
-		struct ethtool_wolinfo wol =  { .cmd = ETHTOOL_GWOL };
-
-		phylink_ethtool_get_wol(priv->phylink, &wol);
-
-		if (wol.wolopts) {
-			phylink_ethtool_set_wol(priv->phylink, &wol);
-			device_set_wakeup_enable(priv->device, !!wol.wolopts);
-		}
-	}
+	stmmac_rearm_wol(ndev);
 	rtnl_unlock();
 
 	ret = stmmac_suspend(dev);
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac.h b/drivers/net/ethernet/stmicro/stmmac/stmmac.h
index a351e20c9071..411a2706b61f 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac.h
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac.h
@@ -354,6 +354,7 @@ void stmmac_ptp_register(struct stmmac_priv *priv);
 void stmmac_ptp_unregister(struct stmmac_priv *priv);
 int stmmac_xdp_open(struct net_device *dev);
 void stmmac_xdp_release(struct net_device *dev);
+void stmmac_rearm_wol(struct net_device *dev);
 int stmmac_resume(struct device *dev);
 int stmmac_suspend(struct device *dev);
 void stmmac_dvr_remove(struct device *dev);
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
index ae9db93ffa38..6dde20f3f232 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
@@ -4038,6 +4038,29 @@ static int stmmac_release(struct net_device *dev)
 	return 0;
 }
 
+void stmmac_rearm_wol(struct net_device *dev)
+{
+	struct stmmac_priv *priv = netdev_priv(dev);
+
+	if (priv->plat->use_phy_wol) {
+		struct ethtool_wolinfo wol =  { .cmd = ETHTOOL_GWOL };
+
+		phylink_ethtool_get_wol(priv->phylink, &wol);
+
+		if (wol.wolopts) {
+			phylink_ethtool_set_wol(priv->phylink, &wol);
+			device_set_wakeup_enable(priv->device, !!wol.wolopts);
+		}
+	}
+}
+EXPORT_SYMBOL_GPL(stmmac_rearm_wol);
+
+static int stmmac_stop(struct net_device *dev)
+{
+	stmmac_rearm_wol(dev);
+	return stmmac_release(dev);
+}
+
 static bool stmmac_vlan_insert(struct stmmac_priv *priv, struct sk_buff *skb,
 			       struct stmmac_tx_queue *tx_q)
 {
@@ -6911,7 +6934,7 @@ int stmmac_xsk_wakeup(struct net_device *dev, u32 queue, u32 flags)
 static const struct net_device_ops stmmac_netdev_ops = {
 	.ndo_open = stmmac_open,
 	.ndo_start_xmit = stmmac_xmit,
-	.ndo_stop = stmmac_release,
+	.ndo_stop = stmmac_stop,
 	.ndo_change_mtu = stmmac_change_mtu,
 	.ndo_fix_features = stmmac_fix_features,
 	.ndo_set_features = stmmac_set_features,
-- 
2.25.1

