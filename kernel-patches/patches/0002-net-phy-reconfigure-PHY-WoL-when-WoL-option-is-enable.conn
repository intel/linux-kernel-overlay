From cd4f3256acf6608396f936417419898f84e51efc Mon Sep 17 00:00:00 2001
From: Gan Yi Fang <yi.fang.gan@intel.com>
Date: Thu, 6 Jul 2023 21:42:14 -0400
Subject: [PATCH 2/2] net: phy: reconfigure PHY WoL when WoL option is enabled

This patch reconfigures the PHY WoL event from two scenarios.
They are needed for the PHY that operated in PHY_POLL mode
where there is no ISR available to handle the WoL event.

1. PHY WoL status will only be clear after hard reboot. PHY WoL
reconfiguration is needed in init_phy for the WoL to set properly
after soft reboot.
2. After the PHY enables the WoL event, arm the WoL INT bit
before suspending to ensure the WoL is set properly.

Below are additional background.
In order for the WoL to work, the interrupt header needs to be
connected to the PM for the platform to wake up when there is a
rising edge from the WoL INT bit.

Ideal case to trigger the WoL:
1. User enables WoL (WoL INT bit: 0)
2. Sleep the platform
3. Platform receives magic packet (WoL INT bit: change from 0 to 1)
4. Platform wakes up

Issue might occur when:
1. User enables WoL (WoL INT bit: 0)
2. Platform receives 1st magic packet (WoL INT bit: change from 0 to 1)
3. Without handling the INT, sleeps the platform (WoL INT bit: 1)
4. Platform receives second magic packet (There is no change in
WoL INT bit)
5. Platform cannot wake up

Check and set the WoL INT bit to 0 will reset the PHY interrupt
before suspending so the issue can be avoided.

Signed-off-by: Gan Yi Fang <yi.fang.gan@intel.com>
---
 drivers/net/ethernet/stmicro/stmmac/dwmac-intel.c | 15 +++++++++++++++
 1 file changed, 15 insertions(+)

diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac-intel.c b/drivers/net/ethernet/stmicro/stmmac/dwmac-intel.c
index 64d6a2dd1652..da0b68375db9 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac-intel.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac-intel.c
@@ -1358,8 +1358,23 @@ static void intel_eth_pci_remove(struct pci_dev *pdev)
 static int __maybe_unused intel_eth_pci_suspend(struct device *dev)
 {
 	struct pci_dev *pdev = to_pci_dev(dev);
+	struct net_device *ndev = dev_get_drvdata(&pdev->dev);
+	struct stmmac_priv *priv = netdev_priv(ndev);
 	int ret;
 
+	rtnl_lock();
+	if (priv->plat->use_phy_wol) {
+		struct ethtool_wolinfo wol =  { .cmd = ETHTOOL_GWOL };
+
+		phylink_ethtool_get_wol(priv->phylink, &wol);
+
+		if (wol.wolopts) {
+			phylink_ethtool_set_wol(priv->phylink, &wol);
+			device_set_wakeup_enable(priv->device, !!wol.wolopts);
+		}
+	}
+	rtnl_unlock();
+
 	ret = stmmac_suspend(dev);
 	if (ret)
 		return ret;
-- 
2.25.1

