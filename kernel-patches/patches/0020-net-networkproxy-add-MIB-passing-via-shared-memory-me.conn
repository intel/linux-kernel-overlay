From 0e734435183553248d4ca675f2d351216b24e7a1 Mon Sep 17 00:00:00 2001
From: Song Yoong Siang <yoong.siang.song@intel.com>
Date: Mon, 6 Dec 2021 13:15:25 +0800
Subject: [PATCH 20/54] net: networkproxy: add MIB passing via shared memory
 mechanism

Add shared memory mechanism to pass SNMP OID tree and mDNS record
resources.

Signed-off-by: Ong Boon Leong <boon.leong.ong@intel.com>
Signed-off-by: Song Yoong Siang <yoong.siang.song@intel.com>
Signed-off-by: Wong Vee Khee <vee.khee.wong@linux.intel.com>
---
 drivers/net/networkproxy/network_proxy.c | 240 +++++++++++++++++++++++
 include/linux/network_proxy.h            |  11 ++
 include/linux/network_proxy_common.h     |  15 ++
 3 files changed, 266 insertions(+)

diff --git a/drivers/net/networkproxy/network_proxy.c b/drivers/net/networkproxy/network_proxy.c
index 60b1ac861ec6..a374f93bb14e 100644
--- a/drivers/net/networkproxy/network_proxy.c
+++ b/drivers/net/networkproxy/network_proxy.c
@@ -52,6 +52,105 @@ int netprox_send_ipc_msg(int cmd, const char *msg, int size)
 }
 EXPORT_SYMBOL(netprox_send_ipc_msg);
 
+static int netprox_rd_mib_shm(struct np_rules *rule)
+{
+	struct np_shm_info *shm_info_send;
+	struct np_shm_info *shm_info_resp;
+	struct np_rules *rule_send;
+	struct np_rules *rule_resp;
+	int shm_data_remain_size;
+	u64 shm_data_addr_user;
+	int shm_data_cpy_size;
+	int msg_payload_size;
+	long respond_timer;
+	char *shm_data;
+	int ret = 0;
+
+	if (rule->size > NP_RULE_ACCESS_MAX_BYTE) {
+		pr_err("Rule size exceeded limit.\n");
+		return -EPERM;
+	}
+
+	/* Allocate memory to temporary store the received shared memory data */
+	shm_data = kzalloc(rule->size, GFP_KERNEL);
+	if (!shm_data)
+		return -ENOMEM;
+
+	/* Allocate memory for IPC message payload */
+	msg_payload_size = sizeof(struct np_rules) + sizeof(struct np_shm_info);
+	rule_send = kzalloc(msg_payload_size, GFP_KERNEL);
+	if (!rule_send) {
+		kfree(shm_data);
+		return -ENOMEM;
+	}
+
+	memcpy(rule_send, rule, sizeof(struct np_rules));
+	shm_info_send = (struct np_shm_info *)(rule_send + 1);
+
+	shm_info_send->offset = 0;
+	do {
+		netprox_send_ipc_msg(NP_H2A_CMD_READ_SHM_DATA,
+				     (const char *)rule_send,
+				     msg_payload_size);
+
+		agent_access_task = current;
+		set_current_state(TASK_INTERRUPTIBLE);
+		respond_timer =
+			schedule_timeout(msecs_to_jiffies(NP_TIMEOUT_MS));
+		/* If respond_timer = 0, no response is received from Agent */
+		if (respond_timer == 0) {
+			pr_err("Netprox MIB passing timeout.\n");
+			break;
+		}
+		rule_resp = (struct np_rules *)ipc_ptr;
+		shm_info_resp = (struct np_shm_info *)(rule_resp + 1);
+
+		/* Check the response is same as query */
+		if (rule->group != rule_resp->group ||
+		    rule->type != rule_resp->type ||
+		    rule->offset != rule_resp->offset ||
+		    rule->size != rule_resp->size) {
+			pr_err("Response is not same as query.\n");
+			break;
+		}
+
+		/* Check the received OID tree is within requested range */
+		shm_data_remain_size = rule->size - shm_info_send->offset;
+		shm_data_cpy_size = min_t(int, shm_data_remain_size, (int)shm_info_resp->size);
+
+		memcpy_fromio(shm_data + shm_info_send->offset,
+			      np_ctx->np_shm->shm_ptr,
+			      shm_data_cpy_size);
+
+		shm_info_send->offset += shm_info_resp->size;
+	} while (shm_info_send->offset < rule->size &&
+		 shm_info_send->offset < shm_info_resp->total_size);
+
+	if (shm_info_send->offset) {
+		shm_data_addr_user = *(u64 *)rule->value;
+		if (copy_to_user(u64_to_user_ptr(shm_data_addr_user),
+				 shm_data, shm_info_send->offset)) {
+			pr_err("error in copying data from kernel to userspace.\n");
+			ret = -ENOMEM;
+		}
+	}
+
+	kfree(rule_send);
+	kfree(shm_data);
+
+	return ret;
+}
+
+static int netprox_rd_mib(struct np_rules *rule)
+{
+	if (!np_ctx->np_shm) {
+		pr_err("Netprox requires shared memory support for MIB passing.\n");
+		return -EPERM;
+	} else {
+		return netprox_rd_mib_shm(rule);
+	}
+}
+
 static int netprox_read_from_agent(struct np_rules *rule, void *content,
 				   int *size)
 {
@@ -150,6 +249,95 @@ int netprox_read_rule(struct np_rules *rule, void *content, int *size)
 }
 EXPORT_SYMBOL(netprox_read_rule);
 
+static int netprox_wr_mib_shm(struct np_rules *rule)
+{
+	struct np_shm_info *shm_info;
+	struct np_rules *rule_send;
+	u64 shm_data_addr_user;
+	int msg_payload_size;
+	long respond_timer;
+	char *shm_data;
+	int remain_sz;
+	int ret = 0;
+	int pos;
+
+	if (rule->size > NP_RULE_ACCESS_MAX_BYTE) {
+		pr_err("Rule size exceeded limit.\n");
+		return -EPERM;
+	}
+
+	/* Allocate memory for IPC message payload */
+	msg_payload_size = sizeof(struct np_rules) + sizeof(struct np_shm_info);
+	rule_send = kzalloc(msg_payload_size, GFP_KERNEL);
+	if (!rule_send)
+		return -ENOMEM;
+
+	/* Allocate memory to temporary store the received shared memory data */
+	shm_data = kzalloc(rule->size, GFP_KERNEL);
+	if (!shm_data) {
+		kfree(rule_send);
+		return -ENOMEM;
+	}
+
+	shm_data_addr_user = *(u64 *)rule->value;
+
+	if (copy_from_user(shm_data, (const void __user *)shm_data_addr_user,
+			   rule->size)) {
+		pr_err("error in copying data from userspace to kernel.\n");
+		kfree(shm_data);
+		kfree(rule_send);
+		return -ENOMEM;
+	}
+
+	memcpy(rule_send, rule, sizeof(struct np_rules));
+	shm_info = (struct np_shm_info *)(rule_send + 1);
+	shm_info->total_size = rule->size;
+
+	for (remain_sz = rule->size, pos = 0;
+	     remain_sz > 0;
+	     pos += shm_info->size) {
+		shm_info->offset = pos;
+
+		shm_info->size = min(np_ctx->np_shm->shm_max_len, remain_sz);
+		remain_sz -= shm_info->size;
+
+		memcpy_toio(np_ctx->np_shm->shm_ptr,
+			    shm_data + pos,
+			    shm_info->size);
+
+		netprox_send_ipc_msg(NP_H2A_CMD_WRITE_SHM_DATA,
+				     (const char *)rule_send,
+				     msg_payload_size);
+
+		agent_access_task = current;
+		set_current_state(TASK_INTERRUPTIBLE);
+		respond_timer =
+			schedule_timeout(msecs_to_jiffies(NP_TIMEOUT_MS));
+
+		/* If respond_timer = 0, no response is received from Agent */
+		if (respond_timer == 0) {
+			pr_err("Netprox MIB passing timeout.\n");
+			ret = -ETIME;
+			break;
+		}
+	}
+
+	kfree(rule_send);
+	kfree(shm_data);
+
+	return ret;
+}
+
+static int netprox_wr_mib(struct np_rules *rule)
+{
+	if (!np_ctx->np_shm) {
+		pr_err("Netprox requires shared memory support for MIB passing.\n");
+		return -EPERM;
+	} else {
+		return netprox_wr_mib_shm(rule);
+	}
+}
+
 static int netprox_send_netdev_mib(int rule_type)
 {
 	struct inet6_ifaddr *ifp, *tmp;
@@ -299,6 +487,32 @@ static int netprox_process_classifier_rule_write(struct np_rules *rule,
 	return ret;
 }
 
+static int netprox_process_mib_rule_write(struct np_rules *rule, int size)
+{
+	int ret = 0;
+
+	switch (rule->type) {
+	case NP_RL_T_SNMP_WRITE_OID_TREE:
+	case NP_RL_T_MDNS_WRITE_RR:
+		ret = netprox_wr_mib(rule);
+		break;
+	case NP_RL_T_SNMP_READ_OID_TREE:
+	case NP_RL_T_MDNS_READ_RR:
+		ret = netprox_rd_mib(rule);
+		break;
+	case NP_RL_T_SNMP_COMMUNITY_STR:
+	case NP_RL_T_TCP_WAKE_PORT:
+		ret = netprox_send_ipc_msg(NP_H2A_CMD_WRITE_CLS_RULE,
+					   (const char *)rule,
+					   size);
+		break;
+	default:
+		break;
+	}
+
+	return ret;
+}
+
 int netprox_write_rule(struct np_rules *rule, int size)
 {
 	int ret;
@@ -307,6 +521,9 @@ int netprox_write_rule(struct np_rules *rule, int size)
 	case NP_RL_G_CLS:
 		ret = netprox_process_classifier_rule_write(rule, size);
 		break;
+	case NP_RL_G_MIB:
+		ret = netprox_process_mib_rule_write(rule, size);
+		break;
 	default:
 		ret = -EINVAL;
 		break;
@@ -382,6 +599,13 @@ int netprox_ipc_recv(int cmd, unsigned char *payload, int size)
 		else
 			pr_err("Received cls_rule_result after timeout.\n");
 		break;
+	case NP_A2H_CMD_SHM_DATA_COMPLETE:
+		ipc_ptr = payload;
+		if (agent_access_task)
+			wake_up_process(agent_access_task);
+		else
+			pr_err("Received shm_data_complete after timeout.\n");
+		break;
 	default:
 		pr_err("%s unknown command %d\n", __func__, cmd);
 		break;
@@ -390,6 +614,22 @@ int netprox_ipc_recv(int cmd, unsigned char *payload, int size)
 }
 EXPORT_SYMBOL(netprox_ipc_recv);
 
+int netprox_register_shm(struct np_shm *np_shm)
+{
+	np_ctx->np_shm = np_shm;
+
+	return 0;
+}
+EXPORT_SYMBOL(netprox_register_shm);
+
+int netprox_deregister_shm(struct np_shm *np_shm)
+{
+	np_ctx->np_shm = NULL;
+
+	return 0;
+}
+EXPORT_SYMBOL(netprox_deregister_shm);
+
 int netprox_register_ipcdev(struct np_ipcdev *np_ipcdev)
 {
 	np_ctx->np_ipcdev = np_ipcdev;
diff --git a/include/linux/network_proxy.h b/include/linux/network_proxy.h
index 30dcc8e93e02..79ce749c6815 100644
--- a/include/linux/network_proxy.h
+++ b/include/linux/network_proxy.h
@@ -9,6 +9,8 @@
 #include <linux/printk.h>
 #include <linux/types.h>
 
+#define NP_RULE_ACCESS_MAX_BYTE			(500 * 1024)
+
 /* Network Proxy Host States */
 enum np_host_state {
 	NP_HOST_PROXY_EXIT = 0,
@@ -39,6 +41,12 @@ struct np_configfs {
 	void (*agent_info)(struct np_agent_info *info);
 };
 
+/* Shared Memory for Network Proxy Agent */
+struct np_shm {
+	char *shm_ptr;
+	int shm_max_len;
+};
+
 /* Network Proxy Context */
 struct np_context {
 	enum np_host_state host_state;
@@ -47,6 +55,7 @@ struct np_context {
 	struct np_netdev *np_netdev;
 	struct np_configfs *np_configfs;
 	struct np_agent_info np_agent_info;
+	struct np_shm *np_shm;
 };
 
 int netprox_agent_is_ready(void);
@@ -56,6 +65,8 @@ int netprox_send_ipc_msg(int cmd, const char *msg, int size);
 int netprox_read_rule(struct np_rules *rule, void *ptr, int *size);
 int netprox_write_rule(struct np_rules *rule, int size);
 int netprox_ipc_recv(int cmd, unsigned char *payload, int size);
+int netprox_register_shm(struct np_shm *np_shm);
+int netprox_deregister_shm(struct np_shm *np_shm);
 int netprox_register_ipcdev(struct np_ipcdev *np_ipcdev);
 int netprox_deregister_ipcdev(struct np_ipcdev *np_ipcdev);
 int netprox_register_netdev(struct np_netdev *np_netdev, void *config,
diff --git a/include/linux/network_proxy_common.h b/include/linux/network_proxy_common.h
index 3890bbdca709..3d3b41628a52 100644
--- a/include/linux/network_proxy_common.h
+++ b/include/linux/network_proxy_common.h
@@ -103,6 +103,16 @@ struct np_rules {
 	unsigned int value[0];
 };
 
+/* Shared Memory Passing Info */
+struct np_shm_info {
+	/* Offset in byte */
+	unsigned int offset;
+	/* Currently passed data size in byte */
+	unsigned int size;
+	/* Total shared memory size in byte */
+	unsigned int total_size;
+};
+
 /* Commands from Network Proxy Host to Agent */
 enum np_h2a_cmd {
 	/* Network Device for Network Proxy is ready */
@@ -117,6 +127,9 @@ enum np_h2a_cmd {
 	/* Read/Write Responder rule */
 	NP_H2A_CMD_READ_RESP_RULE,
 	NP_H2A_CMD_WRITE_RESP_RULE,
+	/* Read/Write Shared Memory Data */
+	NP_H2A_CMD_READ_SHM_DATA,
+	NP_H2A_CMD_WRITE_SHM_DATA,
 	NP_H2A_CMD_MAX,
 };
 
@@ -132,6 +145,8 @@ enum np_a2h_cmd {
 	NP_A2H_CMD_HOST_IS_AWAKE,
 	/* Network Proxy Mode Exited */
 	NP_A2H_CMD_HOST_IS_EXITED,
+	/* Processing of Shared Memory Data is complete */
+	NP_A2H_CMD_SHM_DATA_COMPLETE,
 	NP_A2H_CMD_MAX,
 };
 
-- 
2.25.1

