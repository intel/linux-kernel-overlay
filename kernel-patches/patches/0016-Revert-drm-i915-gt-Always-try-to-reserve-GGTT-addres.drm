From f977ed981cb0252110629c372c5682553b67b9e4 Mon Sep 17 00:00:00 2001
From: Ranjan Dutta <ranjan.dutta@intel.com>
Date: Sat, 13 Feb 2021 16:02:07 +0800
Subject: [PATCH 16/19] Revert "drm/i915/gt: Always try to reserve GGTT address
 0x0"

This reverts commit 29d35b73ead4e41aa0d1a954c9bfbdce659ec5d6.
---
 drivers/gpu/drm/i915/gt/intel_ggtt.c | 47 +++++++---------------------
 1 file changed, 12 insertions(+), 35 deletions(-)

diff --git a/drivers/gpu/drm/i915/gt/intel_ggtt.c b/drivers/gpu/drm/i915/gt/intel_ggtt.c
index 060f826b1d52..81c05f551b9c 100644
--- a/drivers/gpu/drm/i915/gt/intel_ggtt.c
+++ b/drivers/gpu/drm/i915/gt/intel_ggtt.c
@@ -526,39 +526,16 @@ static int init_ggtt(struct i915_ggtt *ggtt)
 
 	mutex_init(&ggtt->error_mutex);
 	if (ggtt->mappable_end) {
-		/*
-		 * Reserve a mappable slot for our lockless error capture.
-		 *
-		 * We strongly prefer taking address 0x0 in order to protect
-		 * other critical buffers against accidental overwrites,
-		 * as writing to address 0 is a very common mistake.
-		 *
-		 * Since 0 may already be in use by the system (e.g. the BIOS
-		 * framebuffer), we let the reservation fail quietly and hope
-		 * 0 remains reserved always.
-		 *
-		 * If we fail to reserve 0, and then fail to find any space
-		 * for an error-capture, remain silent. We can afford not
-		 * to reserve an error_capture node as we have fallback
-		 * paths, and we trust that 0 will remain reserved. However,
-		 * the only likely reason for failure to insert is a driver
-		 * bug, which we expect to cause other failures...
-		 */
-		ggtt->error_capture.size = I915_GTT_PAGE_SIZE;
-		ggtt->error_capture.color = I915_COLOR_UNEVICTABLE;
-		if (drm_mm_reserve_node(&ggtt->vm.mm, &ggtt->error_capture))
-			drm_mm_insert_node_in_range(&ggtt->vm.mm,
-						    &ggtt->error_capture,
-						    ggtt->error_capture.size, 0,
-						    ggtt->error_capture.color,
-						    0, ggtt->mappable_end,
-						    DRM_MM_INSERT_LOW);
+		/* Reserve a mappable slot for our lockless error capture */
+		ret = drm_mm_insert_node_in_range(&ggtt->vm.mm,
+						  &ggtt->error_capture,
+						  PAGE_SIZE, 0,
+						  I915_COLOR_UNEVICTABLE,
+						  0, ggtt->mappable_end,
+						  DRM_MM_INSERT_LOW);
+		if (ret)
+			return ret;
 	}
-	if (drm_mm_node_allocated(&ggtt->error_capture))
-		drm_dbg(&ggtt->vm.i915->drm,
-			"Reserved GGTT:[%llx, %llx] for use by error capture\n",
-			ggtt->error_capture.start,
-			ggtt->error_capture.start + ggtt->error_capture.size);
 
 	/*
 	 * The upper portion of the GuC address space has a sizeable hole
@@ -571,9 +548,9 @@ static int init_ggtt(struct i915_ggtt *ggtt)
 
 	/* Clear any non-preallocated blocks */
 	drm_mm_for_each_hole(entry, &ggtt->vm.mm, hole_start, hole_end) {
-		drm_dbg(&ggtt->vm.i915->drm,
-			"clearing unused GTT space: [%lx, %lx]\n",
-			hole_start, hole_end);
+		drm_dbg_kms(&ggtt->vm.i915->drm,
+			    "clearing unused GTT space: [%lx, %lx]\n",
+			    hole_start, hole_end);
 		ggtt->vm.clear_range(&ggtt->vm, hole_start,
 				     hole_end - hole_start);
 	}
-- 
2.25.1

