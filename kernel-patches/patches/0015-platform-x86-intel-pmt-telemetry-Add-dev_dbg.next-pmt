From be115ea86862ca14ff9e78f96db50a48a023cf16 Mon Sep 17 00:00:00 2001
From: "David E. Box" <david.e.box@linux.intel.com>
Date: Wed, 16 Dec 2020 11:46:42 -0800
Subject: [PATCH 15/15] platform/x86/intel/pmt: telemetry: Add dev_dbg

INTEL INTERNAL ONLY

Signed-off-by: David E. Box <david.e.box@linux.intel.com>
---
 drivers/platform/x86/intel/pmt/class.c     |  8 ++++++++
 drivers/platform/x86/intel/pmt/telemetry.c | 13 +++++++++++++
 2 files changed, 21 insertions(+)

diff --git a/drivers/platform/x86/intel/pmt/class.c b/drivers/platform/x86/intel/pmt/class.c
index 97e802330e25..4e901b414519 100644
--- a/drivers/platform/x86/intel/pmt/class.c
+++ b/drivers/platform/x86/intel/pmt/class.c
@@ -171,6 +171,7 @@ int intel_pmt_populate_entry(struct intel_pmt_entry *entry,
 				return -EINVAL;
 		}
 
+		dev_dbg(dev, "LOCAL base address 0x%lx\b", entry->base_addr);
 		break;
 	case ACCESS_BARID:
 		/*
@@ -180,6 +181,8 @@ int intel_pmt_populate_entry(struct intel_pmt_entry *entry,
 		 */
 		entry->base_addr = pci_resource_start(pci_dev, bir) +
 				   GET_ADDRESS(header->base_offset);
+
+		dev_dbg(dev, "BARID base address 0x%lx\b", entry->base_addr);
 		break;
 	default:
 		dev_err(dev, "Unsupported access type %d\n",
@@ -206,6 +209,8 @@ static int intel_pmt_dev_register(struct intel_pmt_entry *entry,
 	if (ret)
 		return ret;
 
+	dev_dbg(parent, "%s: Create %s%d\n", __func__, ns->name, entry->devid);
+
 	dev = device_create(&intel_pmt_class, parent, MKDEV(0, 0), entry,
 			    "%s%d", ns->name, entry->devid);
 
@@ -234,12 +239,15 @@ static int intel_pmt_dev_register(struct intel_pmt_entry *entry,
 	res.flags = IORESOURCE_MEM;
 	res.name = NULL;
 
+	dev_dbg(parent, "%s: Mapping resource %pr\n", __func__, &res);
+
 	entry->base = devm_ioremap_resource(dev, &res);
 	if (IS_ERR(entry->base)) {
 		ret = PTR_ERR(entry->base);
 		goto fail_ioremap;
 	}
 
+	dev_dbg(parent, "%s: Base mapped to %px\n", __func__, entry->base);
 	sysfs_bin_attr_init(&entry->pmt_bin_attr);
 	entry->pmt_bin_attr.attr.name = ns->name;
 	entry->pmt_bin_attr.attr.mode = 0440;
diff --git a/drivers/platform/x86/intel/pmt/telemetry.c b/drivers/platform/x86/intel/pmt/telemetry.c
index 431d78838362..64a3b21b1207 100644
--- a/drivers/platform/x86/intel/pmt/telemetry.c
+++ b/drivers/platform/x86/intel/pmt/telemetry.c
@@ -98,8 +98,10 @@ static void pmt_telem_ep_release(struct kref *kref)
 {
 	struct telem_endpoint *ep;
 
+	pr_debug("%s: begin release kref\n", __func__);
 	ep = container_of(kref, struct telem_endpoint, kref);
 	kfree(ep);
+	pr_debug("%s: end release kref for %px\n", __func__, ep);
 }
 
 /*
@@ -139,6 +141,7 @@ struct telem_endpoint *pmt_telem_register_endpoint(int devid)
 
 	kref_get(&entry->ep->kref);
 
+	pr_debug("%s: kref for [%px] is now %d\n", __func__, entry, kref_read(&entry->ep->kref));
 	mutex_unlock(&list_lock);
 
 	return entry->ep;
@@ -148,6 +151,7 @@ EXPORT_SYMBOL_GPL(pmt_telem_register_endpoint);
 void pmt_telem_unregister_endpoint(struct telem_endpoint *ep)
 {
 	kref_put(&ep->kref, pmt_telem_ep_release);
+	pr_debug("%s: kref for [%px] is now %d\n", __func__, ep, kref_read(&ep->kref));
 }
 EXPORT_SYMBOL(pmt_telem_unregister_endpoint);
 
@@ -192,6 +196,9 @@ pmt_telem_read(struct telem_endpoint *ep, u32 id, u64 *data, u32 count)
 	if ((offset + NUM_BYTES_QWORD(count)) > size)
 		return -EINVAL;
 
+	pr_debug("%s: Reading id %d, offset 0x%x, count %d, base %px\n",
+		 __func__, id, SAMPLE_ID_OFFSET(id), count, ep->base);
+
 	pm_runtime_get_sync(ep->dev);
 	memcpy_fromio(data, ep->base + offset, NUM_BYTES_QWORD(count));
 	pm_runtime_mark_last_busy(ep->dev);
@@ -249,11 +256,14 @@ static void pmt_telem_remove(struct auxiliary_device *auxdev)
 	struct intel_pmt_entry *entry;
 	int i;
 
+	dev_dbg(&auxdev->dev, "%s\n", __func__);
+
 	for (i = 0, entry = priv->entry; i < priv->num_entries; i++, entry++) {
 		blocking_notifier_call_chain(&telem_notifier,
 					     PMT_TELEM_NOTIFY_REMOVE,
 					     &entry->devid);
 		kref_put(&priv->entry[i].ep->kref, pmt_telem_ep_release);
+		dev_dbg(&auxdev->dev, "kref count of ep #%d [%px] is %d\n", i, entry->ep, kref_read(&entry->ep->kref));
 		intel_pmt_dev_destroy(&priv->entry[i], &pmt_telem_ns);
 	}
 
@@ -277,6 +287,7 @@ static int pmt_telem_probe(struct auxiliary_device *auxdev, const struct auxilia
 	auxiliary_set_drvdata(auxdev, priv);
 
 	for (i = 0, entry = priv->entry; i < intel_vsec_dev->num_resources; i++, entry++) {
+		dev_dbg(&auxdev->dev, "Getting resource %d\n", i);
 		ret = intel_pmt_dev_create(entry, &pmt_telem_ns, intel_vsec_dev, i);
 		if (ret < 0)
 			goto abort_probe;
@@ -291,6 +302,8 @@ static int pmt_telem_probe(struct auxiliary_device *auxdev, const struct auxilia
 		ret = pmt_telem_add_endpoint(&auxdev->dev, priv, entry);
 		if (ret)
 			goto abort_probe;
+
+		dev_dbg(&auxdev->dev, "kref count of ep #%d [%px] is %d\n", i, entry->ep, kref_read(&entry->ep->kref));
 	}
 
 	pm_runtime_enable(&auxdev->dev);
-- 
2.32.0

