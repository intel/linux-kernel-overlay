From 86c431934ea752814c3be4ab867c26ed534c332c Mon Sep 17 00:00:00 2001
From: Ranjan Dutta <ranjan.dutta@intel.com>
Date: Sat, 14 May 2022 22:57:51 +0800
Subject: [PATCH 49/58] Revert "drm: bridge: adv7511: Fix ADV7535 HPD
 enablement"

This reverts commit fb2be762a49bea1fe5febfe8eb55167f205334b9.
---
 drivers/gpu/drm/bridge/adv7511/adv7511.h     |  1 -
 drivers/gpu/drm/bridge/adv7511/adv7511_drv.c | 29 +++++---------------
 2 files changed, 7 insertions(+), 23 deletions(-)

diff --git a/drivers/gpu/drm/bridge/adv7511/adv7511.h b/drivers/gpu/drm/bridge/adv7511/adv7511.h
index a0f6ee15c2485..a9bb734366ae6 100644
--- a/drivers/gpu/drm/bridge/adv7511/adv7511.h
+++ b/drivers/gpu/drm/bridge/adv7511/adv7511.h
@@ -169,7 +169,6 @@
 #define ADV7511_PACKET_ENABLE_SPARE2		BIT(1)
 #define ADV7511_PACKET_ENABLE_SPARE1		BIT(0)
 
-#define ADV7535_REG_POWER2_HPD_OVERRIDE		BIT(6)
 #define ADV7511_REG_POWER2_HPD_SRC_MASK		0xc0
 #define ADV7511_REG_POWER2_HPD_SRC_BOTH		0x00
 #define ADV7511_REG_POWER2_HPD_SRC_HPD		0x40
diff --git a/drivers/gpu/drm/bridge/adv7511/adv7511_drv.c b/drivers/gpu/drm/bridge/adv7511/adv7511_drv.c
index c6f059be4b897..a0d392c338da5 100644
--- a/drivers/gpu/drm/bridge/adv7511/adv7511_drv.c
+++ b/drivers/gpu/drm/bridge/adv7511/adv7511_drv.c
@@ -351,17 +351,11 @@ static void __adv7511_power_on(struct adv7511 *adv7511)
 	 * from standby or are enabled. When the HPD goes low the adv7511 is
 	 * reset and the outputs are disabled which might cause the monitor to
 	 * go to standby again. To avoid this we ignore the HPD pin for the
-	 * first few seconds after enabling the output. On the other hand
-	 * adv7535 require to enable HPD Override bit for proper HPD.
+	 * first few seconds after enabling the output.
 	 */
-	if (adv7511->type == ADV7535)
-		regmap_update_bits(adv7511->regmap, ADV7511_REG_POWER2,
-				   ADV7535_REG_POWER2_HPD_OVERRIDE,
-				   ADV7535_REG_POWER2_HPD_OVERRIDE);
-	else
-		regmap_update_bits(adv7511->regmap, ADV7511_REG_POWER2,
-				   ADV7511_REG_POWER2_HPD_SRC_MASK,
-				   ADV7511_REG_POWER2_HPD_SRC_NONE);
+	regmap_update_bits(adv7511->regmap, ADV7511_REG_POWER2,
+			   ADV7511_REG_POWER2_HPD_SRC_MASK,
+			   ADV7511_REG_POWER2_HPD_SRC_NONE);
 }
 
 static void adv7511_power_on(struct adv7511 *adv7511)
@@ -381,10 +375,6 @@ static void adv7511_power_on(struct adv7511 *adv7511)
 static void __adv7511_power_off(struct adv7511 *adv7511)
 {
 	/* TODO: setup additional power down modes */
-	if (adv7511->type == ADV7535)
-		regmap_update_bits(adv7511->regmap, ADV7511_REG_POWER2,
-				   ADV7535_REG_POWER2_HPD_OVERRIDE, 0);
-
 	regmap_update_bits(adv7511->regmap, ADV7511_REG_POWER,
 			   ADV7511_POWER_POWER_DOWN,
 			   ADV7511_POWER_POWER_DOWN);
@@ -682,14 +672,9 @@ adv7511_detect(struct adv7511 *adv7511, struct drm_connector *connector)
 			status = connector_status_disconnected;
 	} else {
 		/* Renable HPD sensing */
-		if (adv7511->type == ADV7535)
-			regmap_update_bits(adv7511->regmap, ADV7511_REG_POWER2,
-					   ADV7535_REG_POWER2_HPD_OVERRIDE,
-					   ADV7535_REG_POWER2_HPD_OVERRIDE);
-		else
-			regmap_update_bits(adv7511->regmap, ADV7511_REG_POWER2,
-					   ADV7511_REG_POWER2_HPD_SRC_MASK,
-					   ADV7511_REG_POWER2_HPD_SRC_BOTH);
+		regmap_update_bits(adv7511->regmap, ADV7511_REG_POWER2,
+				   ADV7511_REG_POWER2_HPD_SRC_MASK,
+				   ADV7511_REG_POWER2_HPD_SRC_BOTH);
 	}
 
 	adv7511->status = status;
-- 
2.27.0

