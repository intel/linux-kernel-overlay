From a7ebeeff39263b530bdbbc8067f2b4941e217030 Mon Sep 17 00:00:00 2001
From: Even Xu <even.xu@intel.com>
Date: Mon, 17 Jan 2022 13:41:22 +0800
Subject: [PATCH 4/9] hid: intel-ish-hid: ipc: fix S0ix cannot wakeup issue

After implementation RTD3 on EHL, IPC device will be put into D3,
so need to add wake capability from D3 to let IPC device can wake
system from S0ix.

Signed-off-by: Even Xu <even.xu@intel.com>
---
 drivers/hid/intel-ish-hid/ipc/ipc.c     | 10 ++++--
 drivers/hid/intel-ish-hid/ipc/pci-ish.c | 42 +++++++++++++++----------
 2 files changed, 34 insertions(+), 18 deletions(-)

diff --git a/drivers/hid/intel-ish-hid/ipc/ipc.c b/drivers/hid/intel-ish-hid/ipc/ipc.c
index ee721a8f9d27..41f7d5decdc0 100644
--- a/drivers/hid/intel-ish-hid/ipc/ipc.c
+++ b/drivers/hid/intel-ish-hid/ipc/ipc.c
@@ -1092,11 +1092,14 @@ int ish_notify_d0(struct ishtp_device *dev)
 
 	dev->d0_flag = POWER_NOTIFY_WAIT;
 
+wait:
 	ret = wait_event_interruptible_timeout(dev->d0_wait,
 			(dev->d0_flag != POWER_NOTIFY_WAIT),
 			msecs_to_jiffies(WAIT_FOR_D0_RTD3_ACK_MS));
+	if (ret < 0)
+		goto wait;
 
-	if (!ret || dev->d0_flag == POWER_NOTIFY_WAIT) {
+	if (dev->d0_flag == POWER_NOTIFY_WAIT) {
 		dev_err(dev->devc, "wait fw back to d0 timeout\n");
 		return -EBUSY;
 	} else if (dev->d0_flag == POWER_NOTIFY_NOT_READY) {
@@ -1117,11 +1120,14 @@ int ish_notify_rtd3(struct ishtp_device *dev)
 
 	dev->rtd3_flag = POWER_NOTIFY_WAIT;
 
+wait:
 	ret = wait_event_interruptible_timeout(dev->rtd3_wait,
 			(dev->rtd3_flag != POWER_NOTIFY_WAIT),
 			msecs_to_jiffies(WAIT_FOR_D0_RTD3_ACK_MS));
+	if (ret < 0)
+		goto wait;
 
-	if (!ret || dev->rtd3_flag == POWER_NOTIFY_WAIT) {
+	if (dev->rtd3_flag == POWER_NOTIFY_WAIT) {
 		dev_err(dev->devc, "wait fw enter RTD3 timeout\n");
 		return -EBUSY;
 	} else if (dev->rtd3_flag == POWER_NOTIFY_NOT_READY) {
diff --git a/drivers/hid/intel-ish-hid/ipc/pci-ish.c b/drivers/hid/intel-ish-hid/ipc/pci-ish.c
index 185fc5faee60..129feca0dbed 100644
--- a/drivers/hid/intel-ish-hid/ipc/pci-ish.c
+++ b/drivers/hid/intel-ish-hid/ipc/pci-ish.c
@@ -85,14 +85,10 @@ static int ish_init(struct ishtp_device *dev)
 {
 	int ret;
 
-	/* during initializaion, runtime suspend is forbidden */
-	pm_runtime_forbid(dev->devc);
-
 	/* Set the state of ISH HW to start */
 	ret = ish_hw_start(dev);
 	if (ret) {
 		dev_err(dev->devc, "ISH: hw start failed.\n");
-		pm_runtime_allow(dev->devc);
 		return ret;
 	}
 
@@ -100,12 +96,9 @@ static int ish_init(struct ishtp_device *dev)
 	ret = ishtp_start(dev);
 	if (ret) {
 		dev_err(dev->devc, "ISHTP: Protocol init failed.\n");
-		pm_runtime_allow(dev->devc);
 		return ret;
 	}
 
-	pm_runtime_allow(dev->devc);
-
 	return 0;
 }
 
@@ -233,8 +226,11 @@ static int ish_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	init_waitqueue_head(&ishtp->rtd3_wait);
 
 	/* Enable PME for EHL */
-	if (pdev->device == EHL_Ax_DEVICE_ID)
+	if (pdev->device == EHL_Ax_DEVICE_ID) {
+		pci_d3cold_disable(pdev);
+		device_init_wakeup(dev, true);
 		enable_pme_wake(pdev);
+	}
 
 	ret = ish_init(ishtp);
 	if (ret)
@@ -288,20 +284,25 @@ static void __maybe_unused ish_resume_handler(struct work_struct *work)
 	struct ishtp_device *dev = pci_get_drvdata(pdev);
 	uint32_t fwsts = dev->ops->get_fw_status(dev);
 
-	if (ish_should_leave_d0i3(pdev) && !dev->suspend_flag
-			&& IPC_IS_ISH_ILUP(fwsts)) {
+	if (ish_should_leave_d0i3(pdev) && !dev->suspend_flag) {
 		if (device_may_wakeup(&pdev->dev))
 			disable_irq_wake(pdev->irq);
 
 		ish_set_host_ready(dev);
 
-		ishtp_send_resume(dev);
+		/* Send D0 notify to call fw back */
+		if (dev->pdev->device == EHL_Ax_DEVICE_ID)
+			ish_notify_d0(dev);
 
-		/* Waiting to get resume response */
-		if (dev->resume_flag)
-			wait_event_interruptible_timeout(dev->resume_wait,
-				!dev->resume_flag,
-				msecs_to_jiffies(WAIT_FOR_RESUME_ACK_MS));
+		if (IPC_IS_ISH_ILUP(fwsts)) {
+			ishtp_send_resume(dev);
+
+			/* Waiting to get resume response */
+			if (dev->resume_flag)
+				wait_event_interruptible_timeout(dev->resume_wait,
+					!dev->resume_flag,
+					msecs_to_jiffies(WAIT_FOR_RESUME_ACK_MS));
+		}
 
 		/*
 		 * If the flag is not cleared, something is wrong with ISH FW.
@@ -362,6 +363,15 @@ static int __maybe_unused ish_suspend(struct device *device)
 			 */
 			if (dev->pdev->device != EHL_Ax_DEVICE_ID)
 				pci_save_state(pdev);
+			else {
+				/* For no Sx suspend case, need send RTD3 notify to keep
+				 * wake capability */
+				int ret = ish_notify_rtd3(dev);
+				if (ret)
+					return ret;
+
+				pci_wake_from_d3(pdev, true);
+			}
 
 			if (device_may_wakeup(&pdev->dev))
 				enable_irq_wake(pdev->irq);
-- 
2.25.1

