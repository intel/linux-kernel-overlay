From 6068f049fc8958b8fcab1f1c09b000caa20594b2 Mon Sep 17 00:00:00 2001
From: Even Xu <even.xu@intel.com>
Date: Mon, 17 Jan 2022 13:41:22 +0800
Subject: [PATCH 4/9] hid: intel-ish-hid: ipc: fix S0ix cannot wakeup issue

After implementation RTD3 on EHL, IPC device will be put into D3,
so need to add wake capability from D3 to let IPC device can wake
system from S0ix.

Signed-off-by: Even Xu <even.xu@intel.com>
---
 drivers/hid/intel-ish-hid/ipc/ipc.c     | 10 ++++--
 drivers/hid/intel-ish-hid/ipc/pci-ish.c | 42 +++++++++++++++----------
 2 files changed, 34 insertions(+), 18 deletions(-)

diff --git a/drivers/hid/intel-ish-hid/ipc/ipc.c b/drivers/hid/intel-ish-hid/ipc/ipc.c
index bae112d1e26e..2a9285ce8286 100644
--- a/drivers/hid/intel-ish-hid/ipc/ipc.c
+++ b/drivers/hid/intel-ish-hid/ipc/ipc.c
@@ -1081,11 +1081,14 @@ int ish_notify_d0(struct ishtp_device *dev)
 
 	dev->d0_flag = POWER_NOTIFY_WAIT;
 
+wait:
 	ret = wait_event_interruptible_timeout(dev->d0_wait,
 			(dev->d0_flag != POWER_NOTIFY_WAIT),
 			msecs_to_jiffies(WAIT_FOR_D0_RTD3_ACK_MS));
+	if (ret < 0)
+		goto wait;
 
-	if (!ret || dev->d0_flag == POWER_NOTIFY_WAIT) {
+	if (dev->d0_flag == POWER_NOTIFY_WAIT) {
 		dev_err(dev->devc, "wait fw back to d0 timeout\n");
 		return -EBUSY;
 	} else if (dev->d0_flag == POWER_NOTIFY_NOT_READY) {
@@ -1106,11 +1109,14 @@ int ish_notify_rtd3(struct ishtp_device *dev)
 
 	dev->rtd3_flag = POWER_NOTIFY_WAIT;
 
+wait:
 	ret = wait_event_interruptible_timeout(dev->rtd3_wait,
 			(dev->rtd3_flag != POWER_NOTIFY_WAIT),
 			msecs_to_jiffies(WAIT_FOR_D0_RTD3_ACK_MS));
+	if (ret < 0)
+		goto wait;
 
-	if (!ret || dev->rtd3_flag == POWER_NOTIFY_WAIT) {
+	if (dev->rtd3_flag == POWER_NOTIFY_WAIT) {
 		dev_err(dev->devc, "wait fw enter RTD3 timeout\n");
 		return -EBUSY;
 	} else if (dev->rtd3_flag == POWER_NOTIFY_NOT_READY) {
diff --git a/drivers/hid/intel-ish-hid/ipc/pci-ish.c b/drivers/hid/intel-ish-hid/ipc/pci-ish.c
index 0737d56b2d5e..cd12d65b8fb0 100644
--- a/drivers/hid/intel-ish-hid/ipc/pci-ish.c
+++ b/drivers/hid/intel-ish-hid/ipc/pci-ish.c
@@ -82,14 +82,10 @@ static int ish_init(struct ishtp_device *dev)
 {
 	int ret;
 
-	/* during initializaion, runtime suspend is forbidden */
-	pm_runtime_forbid(dev->devc);
-
 	/* Set the state of ISH HW to start */
 	ret = ish_hw_start(dev);
 	if (ret) {
 		dev_err(dev->devc, "ISH: hw start failed.\n");
-		pm_runtime_allow(dev->devc);
 		return ret;
 	}
 
@@ -97,12 +93,9 @@ static int ish_init(struct ishtp_device *dev)
 	ret = ishtp_start(dev);
 	if (ret) {
 		dev_err(dev->devc, "ISHTP: Protocol init failed.\n");
-		pm_runtime_allow(dev->devc);
 		return ret;
 	}
 
-	pm_runtime_allow(dev->devc);
-
 	return 0;
 }
 
@@ -230,8 +223,11 @@ static int ish_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	init_waitqueue_head(&ishtp->rtd3_wait);
 
 	/* Enable PME for EHL */
-	if (pdev->device == EHL_Ax_DEVICE_ID)
+	if (pdev->device == EHL_Ax_DEVICE_ID) {
+		pci_d3cold_disable(pdev);
+		device_init_wakeup(dev, true);
 		enable_pme_wake(pdev);
+	}
 
 	ret = ish_init(ishtp);
 	if (ret)
@@ -285,20 +281,25 @@ static void __maybe_unused ish_resume_handler(struct work_struct *work)
 	struct ishtp_device *dev = pci_get_drvdata(pdev);
 	uint32_t fwsts = dev->ops->get_fw_status(dev);
 
-	if (ish_should_leave_d0i3(pdev) && !dev->suspend_flag
-			&& IPC_IS_ISH_ILUP(fwsts)) {
+	if (ish_should_leave_d0i3(pdev) && !dev->suspend_flag) {
 		if (device_may_wakeup(&pdev->dev))
 			disable_irq_wake(pdev->irq);
 
 		ish_set_host_ready(dev);
 
-		ishtp_send_resume(dev);
+		/* Send D0 notify to call fw back */
+		if (dev->pdev->device == EHL_Ax_DEVICE_ID)
+			ish_notify_d0(dev);
 
-		/* Waiting to get resume response */
-		if (dev->resume_flag)
-			wait_event_interruptible_timeout(dev->resume_wait,
-				!dev->resume_flag,
-				msecs_to_jiffies(WAIT_FOR_RESUME_ACK_MS));
+		if (IPC_IS_ISH_ILUP(fwsts)) {
+			ishtp_send_resume(dev);
+
+			/* Waiting to get resume response */
+			if (dev->resume_flag)
+				wait_event_interruptible_timeout(dev->resume_wait,
+					!dev->resume_flag,
+					msecs_to_jiffies(WAIT_FOR_RESUME_ACK_MS));
+		}
 
 		/*
 		 * If the flag is not cleared, something is wrong with ISH FW.
@@ -359,6 +360,15 @@ static int __maybe_unused ish_suspend(struct device *device)
 			 */
 			if (dev->pdev->device != EHL_Ax_DEVICE_ID)
 				pci_save_state(pdev);
+			else {
+				/* For no Sx suspend case, need send RTD3 notify to keep
+				 * wake capability */
+				int ret = ish_notify_rtd3(dev);
+				if (ret)
+					return ret;
+
+				pci_wake_from_d3(pdev, true);
+			}
 
 			if (device_may_wakeup(&pdev->dev))
 				enable_irq_wake(pdev->irq);
-- 
2.25.1

