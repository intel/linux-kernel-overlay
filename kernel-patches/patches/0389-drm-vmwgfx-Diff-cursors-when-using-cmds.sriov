From 673bc52f2262c3d0243981fea5c18a8f8e85a573 Mon Sep 17 00:00:00 2001
From: Michael Banack <banackm@vmware.com>
Date: Sat, 22 Oct 2022 00:02:28 -0400
Subject: [PATCH 0389/2236] drm/vmwgfx: Diff cursors when using cmds

Extend the cursor diffing support to support the command-path.

Signed-off-by: Michael Banack <banackm@vmware.com>
Signed-off-by: Zack Rusin <zackr@vmware.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20221022040236.616490-10-zack@kde.org
---
 drivers/gpu/drm/vmwgfx/vmwgfx_kms.c | 120 ++++++++++++++--------------
 drivers/gpu/drm/vmwgfx/vmwgfx_kms.h |   2 +
 2 files changed, 62 insertions(+), 60 deletions(-)

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c
index 182b66e93f93..8a78380f8a8a 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c
@@ -53,8 +53,10 @@ void vmw_du_cleanup(struct vmw_display_unit *du)
  */
 
 static int vmw_du_cursor_plane_unmap_cm(struct vmw_plane_state *vps);
-static void vmw_cursor_write_mobid(struct vmw_private *dev_priv,
-				   struct vmw_plane_state *vps);
+static void vmw_cursor_update_mob(struct vmw_private *dev_priv,
+				  struct vmw_plane_state *vps,
+				  u32 *image, u32 width, u32 height,
+				  u32 hotspotX, u32 hotspotY);
 
 struct vmw_svga_fifo_cmd_define_cursor {
 	u32 cmd;
@@ -118,7 +120,10 @@ static void vmw_cursor_update_image(struct vmw_private *dev_priv,
 				    u32 hotspotX, u32 hotspotY)
 {
 	if (vps->cursor.bo)
-		vmw_cursor_write_mobid(dev_priv, vps);
+		vmw_cursor_update_mob(dev_priv, vps, image,
+				      vps->base.crtc_w, vps->base.crtc_h,
+				      hotspotX, hotspotY);
+
 	else
 		vmw_send_define_cursor_cmd(dev_priv, image, width, height,
 					   hotspotX, hotspotY);
@@ -163,61 +168,58 @@ static void vmw_cursor_update_mob(struct vmw_private *dev_priv,
 	alpha_header->height = height;
 
 	memcpy(header + 1, image, image_size);
-}
-
-
-/**
- * vmw_cursor_write_mobid - Update cursor via CursorMob mechanism
- *
- * Called from inside vmw_du_cursor_plane_atomic_update to actually
- * make the cursor-image live.
- *
- * @dev_priv: device to work with
- * @vps: DRM plane_state
- */
-static void vmw_cursor_write_mobid(struct vmw_private *dev_priv,
-				   struct vmw_plane_state *vps)
-{
 	vmw_write(dev_priv, SVGA_REG_CURSOR_MOBID,
 		  vps->cursor.bo->resource->start);
 }
 
+
 static u32 vmw_du_cursor_mob_size(u32 w, u32 h)
 {
 	return w * h * sizeof(u32) + sizeof(SVGAGBCursorHeader);
 }
 
-
-static bool vmw_du_cursor_plane_mob_has_changed(struct vmw_plane_state *old_vps,
-						struct vmw_plane_state *new_vps)
+/**
+ * vmw_du_cursor_plane_acquire_image -- Acquire the image data
+ * @vps: cursor plane state
+ */
+static u32 *vmw_du_cursor_plane_acquire_image(struct vmw_plane_state *vps)
 {
-	void *old_mob;
-	void *new_mob;
 	bool dummy;
-	u32 size;
-
-	// If either of them aren't using CursorMobs, assume changed.
-	if (!old_vps->cursor.bo || !new_vps->cursor.bo)
-		return true;
+	if (vps->surf) {
+		if (vps->surf_mapped)
+			return vmw_bo_map_and_cache(vps->surf->res.backup);
+		return vps->surf->snooper.image;
+	} else if (vps->bo)
+		return ttm_kmap_obj_virtual(&vps->bo->map, &dummy);
+	return NULL;
+}
 
-	// If either of them failed to map, assume changed.
-	if (!old_vps->cursor.mapped || !new_vps->cursor.mapped)
-		return true;
+static bool vmw_du_cursor_plane_has_changed(struct vmw_plane_state *old_vps,
+					    struct vmw_plane_state *new_vps)
+{
+	void *old_image;
+	void *new_image;
+	u32 size;
+	bool changed;
 
 	if (old_vps->base.crtc_w != new_vps->base.crtc_w ||
 	    old_vps->base.crtc_h != new_vps->base.crtc_h)
 	    return true;
 
-	size = vmw_du_cursor_mob_size(new_vps->base.crtc_w,
-				      new_vps->base.crtc_h);
+	if (old_vps->cursor.hotspot_x != new_vps->cursor.hotspot_x ||
+	    old_vps->cursor.hotspot_y != new_vps->cursor.hotspot_y)
+	    return true;
 
-	old_mob = ttm_kmap_obj_virtual(&old_vps->cursor.map, &dummy);
-	new_mob = ttm_kmap_obj_virtual(&new_vps->cursor.map, &dummy);
+	size = new_vps->base.crtc_w * new_vps->base.crtc_h * sizeof(u32);
 
-	if (memcmp(old_mob, new_mob, size) != 0)
-		return true;
+	old_image = vmw_du_cursor_plane_acquire_image(old_vps);
+	new_image = vmw_du_cursor_plane_acquire_image(new_vps);
 
-	return false;
+	changed = false;
+	if (old_image && new_image)
+		changed = memcmp(old_image, new_image, size) != 0;
+
+	return changed;
 }
 
 static void vmw_du_destroy_cursor_mob(struct ttm_buffer_object **bo)
@@ -746,6 +748,7 @@ vmw_du_cursor_plane_prepare_fb(struct drm_plane *plane,
 			return -ENOMEM;
 	} else if (vps->surf && !vps->bo && vps->surf->res.backup) {
 
+		WARN_ON(vps->surf->snooper.image);
 		ret = ttm_bo_reserve(&vps->surf->res.backup->base, true, false,
 				     NULL);
 		if (unlikely(ret != 0))
@@ -779,7 +782,6 @@ vmw_du_cursor_plane_atomic_update(struct drm_plane *plane,
 	struct vmw_plane_state *old_vps = vmw_plane_state_to_vps(old_state);
 	s32 hotspot_x, hotspot_y;
 	bool dummy;
-	void *image;
 
 	hotspot_x = du->hotspot_x;
 	hotspot_y = du->hotspot_y;
@@ -797,36 +799,34 @@ vmw_du_cursor_plane_atomic_update(struct drm_plane *plane,
 		return;
 	}
 
+	vps->cursor.hotspot_x = hotspot_x;
+	vps->cursor.hotspot_y = hotspot_y;
+
 	if (vps->surf) {
 		du->cursor_age = du->cursor_surface->snooper.age;
-		image = vps->surf->snooper.image;
-		if (vps->surf_mapped)
-			image = vmw_bo_map_and_cache(vps->surf->res.backup);
-	} else
-		image = ttm_kmap_obj_virtual(&vps->bo->map, &dummy);
-
-	if (vps->cursor.bo)
-		vmw_cursor_update_mob(dev_priv, vps, image,
-				      new_state->crtc_w,
-				      new_state->crtc_h,
-				      hotspot_x, hotspot_y);
+	}
 
-	if (!vmw_du_cursor_plane_mob_has_changed(old_vps, vps)) {
+	if (!vmw_du_cursor_plane_has_changed(old_vps, vps)) {
 		/*
 		 * If it hasn't changed, avoid making the device do extra
-		 * work by keeping the old mob active.
+		 * work by keeping the old cursor active.
 		 */
 		struct vmw_cursor_plane_state tmp = old_vps->cursor;
 		old_vps->cursor = vps->cursor;
 		vps->cursor = tmp;
-	} else if (image)
-		vmw_cursor_update_image(dev_priv, vps, image,
-					new_state->crtc_w,
-					new_state->crtc_h,
-					hotspot_x, hotspot_y);
-
-	if (image && vps->bo)
-		atomic_dec(&vps->bo->base_mapped_count);
+	} else {
+		void *image = vmw_du_cursor_plane_acquire_image(vps);
+		if (image)
+			vmw_cursor_update_image(dev_priv, vps, image,
+						new_state->crtc_w,
+						new_state->crtc_h,
+						hotspot_x, hotspot_y);
+	}
+
+	if (vps->bo) {
+		if (ttm_kmap_obj_virtual(&vps->bo->map, &dummy))
+			atomic_dec(&vps->bo->base_mapped_count);
+	}
 
 	du->cursor_x = new_state->crtc_x + du->set_gui_x;
 	du->cursor_y = new_state->crtc_y + du->set_gui_y;
diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
index c5e4665a956c..13a265ffd9f8 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
@@ -276,6 +276,8 @@ struct vmw_cursor_plane_state {
 	struct ttm_buffer_object *bo;
 	struct ttm_bo_kmap_obj map;
 	bool mapped;
+	s32 hotspot_x;
+	s32 hotspot_y;
 };
 
 /**
-- 
2.25.1

