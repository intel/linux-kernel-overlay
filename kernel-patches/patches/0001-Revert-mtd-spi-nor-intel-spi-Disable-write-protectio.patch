From 197e72a9d2e21080f9b240a3e47dd3ac3ae642f2 Mon Sep 17 00:00:00 2001
From: Ranjan Dutta <ranjan.dutta@intel.com>
Date: Thu, 29 Dec 2022 01:12:57 +0800
Subject: [PATCH] Revert "mtd: spi-nor: intel-spi: Disable write protection
 only if asked"

This reverts commit 23793518a7523887266769d9345c683e08c590e8.
---
 drivers/mfd/lpc_ich.c                         | 59 ++-----------------
 .../mtd/spi-nor/controllers/intel-spi-pci.c   | 29 ++++-----
 drivers/mtd/spi-nor/controllers/intel-spi.c   | 41 +++++++------
 include/linux/platform_data/intel-spi.h       |  6 +-
 4 files changed, 39 insertions(+), 96 deletions(-)

diff --git a/drivers/mfd/lpc_ich.c b/drivers/mfd/lpc_ich.c
index 2411b7a2e6f47..3bbb29a7e7a57 100644
--- a/drivers/mfd/lpc_ich.c
+++ b/drivers/mfd/lpc_ich.c
@@ -63,8 +63,6 @@
 #define SPIBASE_BYT		0x54
 #define SPIBASE_BYT_SZ		512
 #define SPIBASE_BYT_EN		BIT(1)
-#define BYT_BCR			0xfc
-#define BYT_BCR_WPD		BIT(0)
 
 #define SPIBASE_LPT		0x3800
 #define SPIBASE_LPT_SZ		512
@@ -1085,57 +1083,12 @@ static int lpc_ich_init_wdt(struct pci_dev *dev)
 	return ret;
 }
 
-static bool lpc_ich_byt_set_writeable(void __iomem *base, void *data)
-{
-	u32 val;
-
-	val = readl(base + BYT_BCR);
-	if (!(val & BYT_BCR_WPD)) {
-		val |= BYT_BCR_WPD;
-		writel(val, base + BYT_BCR);
-		val = readl(base + BYT_BCR);
-	}
-
-	return val & BYT_BCR_WPD;
-}
-
-static bool lpc_ich_lpt_set_writeable(void __iomem *base, void *data)
-{
-	struct pci_dev *pdev = data;
-	u32 bcr;
-
-	pci_read_config_dword(pdev, BCR, &bcr);
-	if (!(bcr & BCR_WPD)) {
-		bcr |= BCR_WPD;
-		pci_write_config_dword(pdev, BCR, bcr);
-		pci_read_config_dword(pdev, BCR, &bcr);
-	}
-
-	return bcr & BCR_WPD;
-}
-
-static bool lpc_ich_bxt_set_writeable(void __iomem *base, void *data)
-{
-	unsigned int spi = PCI_DEVFN(13, 2);
-	struct pci_bus *bus = data;
-	u32 bcr;
-
-	pci_bus_read_config_dword(bus, spi, BCR, &bcr);
-	if (!(bcr & BCR_WPD)) {
-		bcr |= BCR_WPD;
-		pci_bus_write_config_dword(bus, spi, BCR, bcr);
-		pci_bus_read_config_dword(bus, spi, BCR, &bcr);
-	}
-
-	return bcr & BCR_WPD;
-}
-
 static int lpc_ich_init_spi(struct pci_dev *dev)
 {
 	struct lpc_ich_priv *priv = pci_get_drvdata(dev);
 	struct resource *res = &intel_spi_res[0];
 	struct intel_spi_boardinfo *info;
-	u32 spi_base, rcba;
+	u32 spi_base, rcba, bcr;
 
 	info = devm_kzalloc(&dev->dev, sizeof(*info), GFP_KERNEL);
 	if (!info)
@@ -1149,8 +1102,6 @@ static int lpc_ich_init_spi(struct pci_dev *dev)
 		if (spi_base & SPIBASE_BYT_EN) {
 			res->start = spi_base & ~(SPIBASE_BYT_SZ - 1);
 			res->end = res->start + SPIBASE_BYT_SZ - 1;
-
-			info->set_writeable = lpc_ich_byt_set_writeable;
 		}
 		break;
 
@@ -1161,8 +1112,8 @@ static int lpc_ich_init_spi(struct pci_dev *dev)
 			res->start = spi_base + SPIBASE_LPT;
 			res->end = res->start + SPIBASE_LPT_SZ - 1;
 
-			info->set_writeable = lpc_ich_lpt_set_writeable;
-			info->data = dev;
+			pci_read_config_dword(dev, BCR, &bcr);
+			info->writeable = !!(bcr & BCR_WPD);
 		}
 		break;
 
@@ -1183,8 +1134,8 @@ static int lpc_ich_init_spi(struct pci_dev *dev)
 			res->start = spi_base & 0xfffffff0;
 			res->end = res->start + SPIBASE_APL_SZ - 1;
 
-			info->set_writeable = lpc_ich_bxt_set_writeable;
-			info->data = bus;
+			pci_bus_read_config_dword(bus, spi, BCR, &bcr);
+			info->writeable = !!(bcr & BCR_WPD);
 		}
 
 		pci_bus_write_config_byte(bus, p2sb, 0xe1, 0x1);
diff --git a/drivers/mtd/spi-nor/controllers/intel-spi-pci.c b/drivers/mtd/spi-nor/controllers/intel-spi-pci.c
index 8a3c1f3c2d2e8..555fe55d14aee 100644
--- a/drivers/mtd/spi-nor/controllers/intel-spi-pci.c
+++ b/drivers/mtd/spi-nor/controllers/intel-spi-pci.c
@@ -16,30 +16,12 @@
 #define BCR		0xdc
 #define BCR_WPD		BIT(0)
 
-static bool intel_spi_pci_set_writeable(void __iomem *base, void *data)
-{
-	struct pci_dev *pdev = data;
-	u32 bcr;
-
-	/* Try to make the chip read/write */
-	pci_read_config_dword(pdev, BCR, &bcr);
-	if (!(bcr & BCR_WPD)) {
-		bcr |= BCR_WPD;
-		pci_write_config_dword(pdev, BCR, bcr);
-		pci_read_config_dword(pdev, BCR, &bcr);
-	}
-
-	return bcr & BCR_WPD;
-}
-
 static const struct intel_spi_boardinfo bxt_info = {
 	.type = INTEL_SPI_BXT,
-	.set_writeable = intel_spi_pci_set_writeable,
 };
 
 static const struct intel_spi_boardinfo cnl_info = {
 	.type = INTEL_SPI_CNL,
-	.set_writeable = intel_spi_pci_set_writeable,
 };
 
 static int intel_spi_pci_probe(struct pci_dev *pdev,
@@ -47,6 +29,7 @@ static int intel_spi_pci_probe(struct pci_dev *pdev,
 {
 	struct intel_spi_boardinfo *info;
 	struct intel_spi *ispi;
+	u32 bcr;
 	int ret;
 
 	ret = pcim_enable_device(pdev);
@@ -58,7 +41,15 @@ static int intel_spi_pci_probe(struct pci_dev *pdev,
 	if (!info)
 		return -ENOMEM;
 
-	info->data = pdev;
+	/* Try to make the chip read/write */
+	pci_read_config_dword(pdev, BCR, &bcr);
+	if (!(bcr & BCR_WPD)) {
+		bcr |= BCR_WPD;
+		pci_write_config_dword(pdev, BCR, bcr);
+		pci_read_config_dword(pdev, BCR, &bcr);
+	}
+	info->writeable = !!(bcr & BCR_WPD);
+
 	ispi = intel_spi_probe(&pdev->dev, &pdev->resource[0], info);
 	if (IS_ERR(ispi))
 		return PTR_ERR(ispi);
diff --git a/drivers/mtd/spi-nor/controllers/intel-spi.c b/drivers/mtd/spi-nor/controllers/intel-spi.c
index 6c802db6b4af0..93cebae9acb6f 100644
--- a/drivers/mtd/spi-nor/controllers/intel-spi.c
+++ b/drivers/mtd/spi-nor/controllers/intel-spi.c
@@ -132,6 +132,7 @@
  * @sregs: Start of software sequencer registers
  * @nregions: Maximum number of regions
  * @pr_num: Maximum number of protected range registers
+ * @writeable: Is the chip writeable
  * @locked: Is SPI setting locked
  * @swseq_reg: Use SW sequencer in register reads/writes
  * @swseq_erase: Use SW sequencer in erase operation
@@ -149,6 +150,7 @@ struct intel_spi {
 	void __iomem *sregs;
 	size_t nregions;
 	size_t pr_num;
+	bool writeable;
 	bool locked;
 	bool swseq_reg;
 	bool swseq_erase;
@@ -303,14 +305,6 @@ static int intel_spi_wait_sw_busy(struct intel_spi *ispi)
 				  INTEL_SPI_TIMEOUT * 1000);
 }
 
-static bool intel_spi_set_writeable(struct intel_spi *ispi)
-{
-	if (!ispi->info->set_writeable)
-		return false;
-
-	return ispi->info->set_writeable(ispi->base, ispi->info->data);
-}
-
 static int intel_spi_init(struct intel_spi *ispi)
 {
 	u32 opmenu0, opmenu1, lvscc, uvscc, val;
@@ -323,6 +317,19 @@ static int intel_spi_init(struct intel_spi *ispi)
 		ispi->nregions = BYT_FREG_NUM;
 		ispi->pr_num = BYT_PR_NUM;
 		ispi->swseq_reg = true;
+
+		if (writeable) {
+			/* Disable write protection */
+			val = readl(ispi->base + BYT_BCR);
+			if (!(val & BYT_BCR_WPD)) {
+				val |= BYT_BCR_WPD;
+				writel(val, ispi->base + BYT_BCR);
+				val = readl(ispi->base + BYT_BCR);
+			}
+
+			ispi->writeable = !!(val & BYT_BCR_WPD);
+		}
+
 		break;
 
 	case INTEL_SPI_LPT:
@@ -352,12 +359,6 @@ static int intel_spi_init(struct intel_spi *ispi)
 		return -EINVAL;
 	}
 
-	/* Try to disable write protection if user asked to do so */
-	if (writeable && !intel_spi_set_writeable(ispi)) {
-		dev_warn(ispi->dev, "can't disable chip write protection\n");
-		writeable = false;
-	}
-
 	/* Disable #SMI generation from HW sequencer */
 	val = readl(ispi->base + HSFSTS_CTL);
 	val &= ~HSFSTS_CTL_FSMIE;
@@ -884,12 +885,9 @@ static void intel_spi_fill_partition(struct intel_spi *ispi,
 		/*
 		 * If any of the regions have protection bits set, make the
 		 * whole partition read-only to be on the safe side.
-		 *
-		 * Also if the user did not ask the chip to be writeable
-		 * mask the bit too.
 		 */
-		if (!writeable || intel_spi_is_protected(ispi, base, limit))
-			part->mask_flags |= MTD_WRITEABLE;
+		if (intel_spi_is_protected(ispi, base, limit))
+			ispi->writeable = false;
 
 		end = (limit << 12) + 4096;
 		if (end > part->size)
@@ -930,6 +928,7 @@ struct intel_spi *intel_spi_probe(struct device *dev,
 
 	ispi->dev = dev;
 	ispi->info = info;
+	ispi->writeable = info->writeable;
 
 	ret = intel_spi_init(ispi);
 	if (ret)
@@ -947,6 +946,10 @@ struct intel_spi *intel_spi_probe(struct device *dev,
 
 	intel_spi_fill_partition(ispi, &part);
 
+	/* Prevent writes if not explicitly enabled */
+	if (!ispi->writeable || !writeable)
+		ispi->nor.mtd.flags &= ~MTD_WRITEABLE;
+
 	ret = mtd_device_register(&ispi->nor.mtd, &part, 1);
 	if (ret)
 		return ERR_PTR(ret);
diff --git a/include/linux/platform_data/intel-spi.h b/include/linux/platform_data/intel-spi.h
index 7dda3f6904654..7f53a5c6f35e8 100644
--- a/include/linux/platform_data/intel-spi.h
+++ b/include/linux/platform_data/intel-spi.h
@@ -19,13 +19,11 @@ enum intel_spi_type {
 /**
  * struct intel_spi_boardinfo - Board specific data for Intel SPI driver
  * @type: Type which this controller is compatible with
- * @set_writeable: Try to make the chip writeable (optional)
- * @data: Data to be passed to @set_writeable can be %NULL
+ * @writeable: The chip is writeable
  */
 struct intel_spi_boardinfo {
 	enum intel_spi_type type;
-	bool (*set_writeable)(void __iomem *base, void *data);
-	void *data;
+	bool writeable;
 };
 
 #endif /* INTEL_SPI_PDATA_H */
-- 
2.25.1

