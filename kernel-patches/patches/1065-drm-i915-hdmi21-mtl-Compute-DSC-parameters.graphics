From 98beb72fb9856407391f4b917847b115f60fe272 Mon Sep 17 00:00:00 2001
From: Ankit Nautiyal <ankit.k.nautiyal@intel.com>
Date: Sat, 2 Apr 2022 12:22:13 +0530
Subject: [PATCH 1065/1096] drm/i915/hdmi21/mtl: Compute DSC parameters

Add support to compute all DSC parameters for given FRL rate and
compressed bpp.

v2: Used identifier i915 instead of dev_priv,
and fixed some formatting issues. (Uma)

Signed-off-by: Ankit Nautiyal <ankit.k.nautiyal@intel.com>
Reviewed-by: Uma Shankar <uma.shankar@intel.com>
---
 drivers/gpu/drm/i915/display/intel_hdmi.c | 95 +++++++++++++++++++++++
 1 file changed, 95 insertions(+)

diff --git a/drivers/gpu/drm/i915/display/intel_hdmi.c b/drivers/gpu/drm/i915/display/intel_hdmi.c
index 3785a1d4d540..c85f6cd9e085 100644
--- a/drivers/gpu/drm/i915/display/intel_hdmi.c
+++ b/drivers/gpu/drm/i915/display/intel_hdmi.c
@@ -33,6 +33,7 @@
 #include <linux/slab.h>
 #include <linux/string_helpers.h>
 
+#include <drm/display/drm_dsc_helper.h>
 #include <drm/display/drm_hdcp_helper.h>
 #include <drm/display/drm_hdmi_helper.h>
 #include <drm/display/drm_scdc_helper.h>
@@ -60,6 +61,7 @@
 #include "intel_lspcon.h"
 #include "intel_panel.h"
 #include "intel_snps_phy.h"
+#include "intel_vdsc.h"
 
 static int
 get_dsc_compressed_bpp(int num_slices, int slice_width, int hdmi_max_chunk_bytes,
@@ -2160,6 +2162,97 @@ static int intel_hdmi_compute_tmds_clock(struct intel_encoder *encoder,
 	return 0;
 }
 
+static bool intel_dsc_supports_ycbcr420(struct drm_i915_private *i915)
+{
+	if (DISPLAY_VER(i915) >= 14)
+		return true;
+
+	return false;
+}
+
+static void intel_hdmi_dsc_compute_config(struct intel_encoder *encoder,
+					  struct intel_crtc_state *pipe_config,
+					  struct drm_hdmi_frl_dfm *frl_dfm)
+{
+	struct drm_i915_private *i915 = to_i915(encoder->base.dev);
+	struct intel_hdmi *intel_hdmi = enc_to_intel_hdmi(encoder);
+	struct intel_connector *intel_connector = intel_hdmi->attached_connector;
+	struct drm_connector *connector = &intel_connector->base;
+	const struct drm_display_mode *adjusted_mode =
+		&pipe_config->hw.adjusted_mode;
+	struct drm_dsc_config *vdsc_cfg = &pipe_config->dsc.config;
+	int ret = 0;
+
+	/* HDMI2.1 supports VDSC 1.2 onwards */
+	if (!connector->display_info.hdmi.dsc_cap.v_1p2)
+		return;
+
+	if (!frl_dfm->config.target_bpp_16 || !frl_dfm->config.slice_width)
+		return;
+
+	pipe_config->dsc.compressed_bpp = frl_dfm->config.target_bpp_16;
+
+	pipe_config->dsc.slice_count = adjusted_mode->hdisplay / frl_dfm->config.slice_width;
+
+	/*
+	 * TODO : Common code for DP and HDMI Move out
+	 * VDSC engine operates at 1 Pixel per clock, so if peak pixel rate
+	 * is greater than the maximum Cdclock and if slice count is even
+	 * then we need to use 2 VDSC instances.
+	 */
+	if (adjusted_mode->crtc_clock > i915->display.cdclk.max_cdclk_freq ||
+	    pipe_config->bigjoiner_pipes) {
+		if (pipe_config->dsc.slice_count < 2) {
+			drm_dbg_kms(&i915->drm,
+				    "Cannot split stream to use 2 VDSC instances\n");
+			return;
+		}
+
+		pipe_config->dsc.dsc_split = true;
+	}
+
+	if (intel_dsc_supports_ycbcr420(i915) &&
+	    connector->display_info.hdmi.dsc_cap.native_420 &&
+	    pipe_config->output_format == INTEL_OUTPUT_FORMAT_YCBCR420) {
+		vdsc_cfg->convert_rgb = 0;
+		vdsc_cfg->native_420 = 1;
+	} else {
+		vdsc_cfg->convert_rgb = 1;
+		vdsc_cfg->native_420 = 0;
+	}
+
+	vdsc_cfg->slice_height = intel_hdmi_dsc_get_slice_height(adjusted_mode->vdisplay);
+	/*
+	 * Following PPS parameters are hard coded as per HDMI2.1 spec Table 7-25, 28-30
+	 */
+	vdsc_cfg->dsc_version_major = 1;
+	vdsc_cfg->dsc_version_minor = 2;
+	vdsc_cfg->line_buf_depth = 13;
+	vdsc_cfg->block_pred_enable = 1;
+	vdsc_cfg->rc_model_size = DSC_RC_MODEL_SIZE_CONST; //As per C-Model-AN
+
+	/* Fill remaining common DSC parameters */
+	ret = intel_dsc_compute_params(pipe_config);
+	if (ret < 0) {
+		drm_dbg_kms(&i915->drm,
+			    "Cannot compute valid DSC parameters for Input Bpp = %d Compressed BPP = %d\n",
+			    pipe_config->pipe_bpp,
+			    pipe_config->dsc.compressed_bpp);
+		return;
+	}
+
+	ret = drm_dsc_compute_rc_parameters(vdsc_cfg);
+	if (ret < 0)
+		return;
+
+	pipe_config->dsc.compression_enable = true;
+	drm_dbg_kms(&i915->drm,
+		    "HDMI DSC computed with Input Bpp = %d Compressed Bpp = %d Slice Count = %d\n",
+		    pipe_config->pipe_bpp,
+		    pipe_config->dsc.compressed_bpp,
+		    pipe_config->dsc.slice_count);
+}
+
 static u32
 get_drm_color_format(enum intel_output_format output_format)
 {
@@ -2377,6 +2470,8 @@ intel_hdmi_compute_frl_config(struct intel_encoder *encoder,
 		pipe_config->frl.hctotal_tb = frl_dfm.params.hcactive_target + frl_dfm.params.hcblank_target;
 		drm_dbg_kms(&dev_priv->drm, "FRL DFM DSC config: hcactive_tb = %d, hctotal_tb = %d\n",
 			    pipe_config->frl.hcactive_tb, pipe_config->frl.hctotal_tb);
+		/* Compute all DSC parameters */
+		intel_hdmi_dsc_compute_config(encoder, pipe_config, &frl_dfm);
 	}
 
 	return 0;
-- 
2.25.1

