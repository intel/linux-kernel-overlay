From a77c13f3f029261fb687ce795f3228e80b42bf47 Mon Sep 17 00:00:00 2001
From: Sohil Mehta <sohil.mehta@intel.com>
Date: Wed, 22 Jul 2020 16:34:16 -0700
Subject: [PATCH 49/94] x86/irq: Reserve a user IPI notification vector

A user interrupt notification vector is used on the receiver's cpu to
identify an interrupt as a user interrupt (and not a kernel interrupt).
Hardware uses the same notification vector to generate an IPI from a
sender's cpu core when the SENDUIPI instruction is executed.

Typically, the kernel shouldn't receive an interrupt with this vector.
However, there is a slight possibility that the kernel might receive
this vector.

Scenario that can cause the spurious interrupt:

Step	cpu 0 (receiver task)		cpu 1 (sender task)
----	---------------------		-------------------
1	task is running
2					executes SENDUIPI
3					IPI sent
4	context switched out
5	IPI delivered
	(kernel interrupt detected)

A kernel interrupt can be detected, if a receiver task gets scheduled
out after the SENDUIPI-based IPI was sent but before the IPI was
delivered.

The kernel doesn't need to do anything in this case other than receiving
the interrupt and clearing the local APIC. The user interrupt is always
stored in the receiver's UPID before the IPI is generated. When the
receiver gets scheduled back the interrupt would be delivered based on
its UPID.

Signed-off-by: Jacob Pan <jacob.jun.pan@linux.intel.com>
Signed-off-by: Sohil Mehta <sohil.mehta@intel.com>
---
 arch/x86/include/asm/hardirq.h     |  3 +++
 arch/x86/include/asm/idtentry.h    |  4 ++++
 arch/x86/include/asm/irq_vectors.h |  5 ++++-
 arch/x86/kernel/idt.c              |  3 +++
 arch/x86/kernel/irq.c              | 33 ++++++++++++++++++++++++++++++
 5 files changed, 47 insertions(+), 1 deletion(-)

Index: b/arch/x86/include/asm/hardirq.h
===================================================================
--- a/arch/x86/include/asm/hardirq.h	2021-07-07 16:56:45.615912407 +0800
+++ b/arch/x86/include/asm/hardirq.h	2021-07-07 16:56:45.611912407 +0800
@@ -20,6 +20,9 @@
 	unsigned int kvm_posted_intr_wakeup_ipis;
 	unsigned int kvm_posted_intr_nested_ipis;
 #endif
+#ifdef CONFIG_X86_USER_INTERRUPTS
+	unsigned int uintr_spurious_count;
+#endif
 	unsigned int x86_platform_ipis;	/* arch dependent */
 	unsigned int apic_perf_irqs;
 	unsigned int apic_irq_work_irqs;
Index: b/arch/x86/include/asm/idtentry.h
===================================================================
--- a/arch/x86/include/asm/idtentry.h	2021-07-07 16:56:45.615912407 +0800
+++ b/arch/x86/include/asm/idtentry.h	2021-07-07 16:56:45.611912407 +0800
@@ -688,6 +688,10 @@
 DECLARE_IDTENTRY_SYSVEC(POSTED_INTR_NESTED_VECTOR,	sysvec_kvm_posted_intr_nested_ipi);
 #endif
 
+#ifdef CONFIG_X86_USER_INTERRUPTS
+DECLARE_IDTENTRY_SYSVEC(UINTR_NOTIFICATION_VECTOR,	sysvec_uintr_spurious_interrupt);
+#endif
+
 #if IS_ENABLED(CONFIG_HYPERV)
 DECLARE_IDTENTRY_SYSVEC(HYPERVISOR_CALLBACK_VECTOR,	sysvec_hyperv_callback);
 DECLARE_IDTENTRY_SYSVEC(HYPERV_REENLIGHTENMENT_VECTOR,	sysvec_hyperv_reenlightenment);
Index: b/arch/x86/include/asm/irq_vectors.h
===================================================================
--- a/arch/x86/include/asm/irq_vectors.h	2021-07-07 16:56:45.615912407 +0800
+++ b/arch/x86/include/asm/irq_vectors.h	2021-07-07 16:57:40.395913342 +0800
@@ -109,7 +109,10 @@
 #define TDX_GUEST_EVENT_NOTIFY_VECTOR	0xec
 #endif
 
-#define LOCAL_TIMER_VECTOR		0xeb
+/* Vector for User interrupt notifications */
+#define UINTR_NOTIFICATION_VECTOR       0xeb
+
+#define LOCAL_TIMER_VECTOR		0xea
 
 #define NR_VECTORS			 256
 
Index: b/arch/x86/kernel/idt.c
===================================================================
--- a/arch/x86/kernel/idt.c	2021-07-07 16:56:45.615912407 +0800
+++ b/arch/x86/kernel/idt.c	2021-07-07 16:56:45.611912407 +0800
@@ -149,6 +149,9 @@
 	INTG(POSTED_INTR_WAKEUP_VECTOR,		asm_sysvec_kvm_posted_intr_wakeup_ipi),
 	INTG(POSTED_INTR_NESTED_VECTOR,		asm_sysvec_kvm_posted_intr_nested_ipi),
 # endif
+#ifdef CONFIG_X86_USER_INTERRUPTS
+	INTG(UINTR_NOTIFICATION_VECTOR,		asm_sysvec_uintr_spurious_interrupt),
+#endif
 # ifdef CONFIG_IRQ_WORK
 	INTG(IRQ_WORK_VECTOR,			asm_sysvec_irq_work),
 # endif
Index: b/arch/x86/kernel/irq.c
===================================================================
--- a/arch/x86/kernel/irq.c	2021-07-07 16:56:45.615912407 +0800
+++ b/arch/x86/kernel/irq.c	2021-07-07 16:56:45.611912407 +0800
@@ -182,6 +182,12 @@
 			   irq_stats(j)->kvm_posted_intr_wakeup_ipis);
 	seq_puts(p, "  Posted-interrupt wakeup event\n");
 #endif
+#ifdef CONFIG_X86_USER_INTERRUPTS
+	seq_printf(p, "%*s: ", prec, "UIS");
+	for_each_online_cpu(j)
+		seq_printf(p, "%10u ", irq_stats(j)->uintr_spurious_count);
+	seq_puts(p, "  User-interrupt spurious event\n");
+#endif
 
 #if IS_ENABLED(CONFIG_INTEL_TDX_GUEST)
 	seq_printf(p, "%*s: ", prec, "TGV");
@@ -338,6 +344,33 @@
 }
 #endif
 
+#ifdef CONFIG_X86_USER_INTERRUPTS
+/*
+ * Handler for UINTR_NOTIFICATION_VECTOR.
+ *
+ * The notification vector is used by the cpu to detect a User Interrupt. In
+ * the typical usage, the cpu would handle this interrupt and clear the local
+ * apic.
+ *
+ * However, there is a small possibility that the kernel might receive this
+ * vector. This can happen if the receiver thread was running when the
+ * interrupt was sent but it got scheduled out before the interrupt was
+ * delivered. The kernel doesn't need to do anything other than clearing the
+ * local APIC. A pending user interrupt is always saved in the receiver's UPID
+ * which can be referenced when the receiver gets scheduled back.
+ *
+ * If the kernel receives a storm of these, it could mean an issue with the
+ * kernel's saving and restoring of the User Interrupt MSR state; Specifically,
+ * the notification vector bits in the IA32_UINTR_MISC_MSR.
+ */
+DEFINE_IDTENTRY_SYSVEC_SIMPLE(sysvec_uintr_spurious_interrupt)
+{
+	/* TODO: Add entry-exit tracepoints */
+	ack_APIC_irq();
+	inc_irq_stat(uintr_spurious_count);
+}
+#endif
+
 
 #ifdef CONFIG_HOTPLUG_CPU
 /* A cpu has been removed from cpu_online_mask.  Reset irq affinities. */
