From 45228dfbc12d5731c4c4ec05263040d29e507cea Mon Sep 17 00:00:00 2001
From: Ranjan Dutta <ranjan.dutta@intel.com>
Date: Tue, 27 Jul 2021 00:06:38 +0800
Subject: [PATCH 38/77] Revert "drm/amd/display: Fix DCN 3.01 DSCCLK
 validation"

This reverts commit 57c63b47d6f188b44d93d1602bd24d8d9a9131f6.
---
 .../dc/dml/dcn30/display_mode_vba_30.c        | 64 +++++++++++++------
 1 file changed, 43 insertions(+), 21 deletions(-)

diff --git a/drivers/gpu/drm/amd/display/dc/dml/dcn30/display_mode_vba_30.c b/drivers/gpu/drm/amd/display/dc/dml/dcn30/display_mode_vba_30.c
index d66e89283c48..9e0ae18e71fa 100644
--- a/drivers/gpu/drm/amd/display/dc/dml/dcn30/display_mode_vba_30.c
+++ b/drivers/gpu/drm/amd/display/dc/dml/dcn30/display_mode_vba_30.c
@@ -64,7 +64,6 @@ typedef struct {
 #define BPP_INVALID 0
 #define BPP_BLENDED_PIPE 0xffffffff
 #define DCN30_MAX_DSC_IMAGE_WIDTH 5184
-#define DCN30_MAX_FMT_420_BUFFER_WIDTH 4096
 
 static void DisplayPipeConfiguration(struct display_mode_lib *mode_lib);
 static void DISPCLKDPPCLKDCFCLKDeepSleepPrefetchParametersWatermarksAndPerformanceCalculation(
@@ -3988,30 +3987,19 @@ void dml30_ModeSupportAndSystemConfigurationFull(struct display_mode_lib *mode_l
 				} else if (v->PlaneRequiredDISPCLKWithoutODMCombine > v->MaxDispclkRoundedDownToDFSGranularity) {
 					v->ODMCombineEnablePerState[i][k] = dm_odm_combine_mode_2to1;
 					v->PlaneRequiredDISPCLK = v->PlaneRequiredDISPCLKWithODMCombine2To1;
+				} else if (v->DSCEnabled[k] && (v->HActive[k] > DCN30_MAX_DSC_IMAGE_WIDTH)) {
+					v->ODMCombineEnablePerState[i][k] = dm_odm_combine_mode_2to1;
+					v->PlaneRequiredDISPCLK = v->PlaneRequiredDISPCLKWithODMCombine2To1;
 				} else {
 					v->ODMCombineEnablePerState[i][k] = dm_odm_combine_mode_disabled;
 					v->PlaneRequiredDISPCLK = v->PlaneRequiredDISPCLKWithoutODMCombine;
-				}
-				if (v->DSCEnabled[k] && v->HActive[k] > DCN30_MAX_DSC_IMAGE_WIDTH
-						&& v->ODMCombineEnablePerState[i][k] != dm_odm_combine_mode_4to1) {
-					if (v->HActive[k] / 2 > DCN30_MAX_DSC_IMAGE_WIDTH) {
-						v->ODMCombineEnablePerState[i][k] = dm_odm_combine_mode_4to1;
-						v->PlaneRequiredDISPCLK = v->PlaneRequiredDISPCLKWithODMCombine4To1;
-					} else {
-						v->ODMCombineEnablePerState[i][k] = dm_odm_combine_mode_2to1;
-						v->PlaneRequiredDISPCLK = v->PlaneRequiredDISPCLKWithODMCombine2To1;
-					}
-				}
-				if (v->OutputFormat[k] == dm_420 && v->HActive[k] > DCN30_MAX_FMT_420_BUFFER_WIDTH
-						&& v->ODMCombineEnablePerState[i][k] != dm_odm_combine_mode_4to1) {
-					if (v->HActive[k] / 2 > DCN30_MAX_FMT_420_BUFFER_WIDTH) {
-						v->ODMCombineEnablePerState[i][k] = dm_odm_combine_mode_4to1;
-						v->PlaneRequiredDISPCLK = v->PlaneRequiredDISPCLKWithODMCombine4To1;
-					} else {
+					/*420 format workaround*/
+					if (v->HActive[k] > 4096 && v->OutputFormat[k] == dm_420) {
 						v->ODMCombineEnablePerState[i][k] = dm_odm_combine_mode_2to1;
 						v->PlaneRequiredDISPCLK = v->PlaneRequiredDISPCLKWithODMCombine2To1;
 					}
 				}
+
 				if (v->ODMCombineEnablePerState[i][k] == dm_odm_combine_mode_4to1) {
 					v->MPCCombine[i][j][k] = false;
 					v->NoOfDPP[i][j][k] = 4;
@@ -4293,8 +4281,42 @@ void dml30_ModeSupportAndSystemConfigurationFull(struct display_mode_lib *mode_l
 		}
 	}
 
-	/* Skip dscclk validation: as long as dispclk is supported, dscclk is also implicitly supported */
-
+	for (i = 0; i < v->soc.num_states; i++) {
+		v->DSCCLKRequiredMoreThanSupported[i] = false;
+		for (k = 0; k <= v->NumberOfActivePlanes - 1; k++) {
+			if (v->BlendingAndTiming[k] == k) {
+				if (v->Output[k] == dm_dp || v->Output[k] == dm_edp) {
+					if (v->OutputFormat[k] == dm_420) {
+						v->DSCFormatFactor = 2;
+					} else if (v->OutputFormat[k] == dm_444) {
+						v->DSCFormatFactor = 1;
+					} else if (v->OutputFormat[k] == dm_n422) {
+						v->DSCFormatFactor = 2;
+					} else {
+						v->DSCFormatFactor = 1;
+					}
+					if (v->RequiresDSC[i][k] == true) {
+						if (v->ODMCombineEnablePerState[i][k] == dm_odm_combine_mode_4to1) {
+							if (v->PixelClockBackEnd[k] / 12.0 / v->DSCFormatFactor
+									> (1.0 - v->DISPCLKDPPCLKDSCCLKDownSpreading / 100.0) * v->MaxDSCCLK[i]) {
+								v->DSCCLKRequiredMoreThanSupported[i] = true;
+							}
+						} else if (v->ODMCombineEnablePerState[i][k] == dm_odm_combine_mode_2to1) {
+							if (v->PixelClockBackEnd[k] / 6.0 / v->DSCFormatFactor
+									> (1.0 - v->DISPCLKDPPCLKDSCCLKDownSpreading / 100.0) * v->MaxDSCCLK[i]) {
+								v->DSCCLKRequiredMoreThanSupported[i] = true;
+							}
+						} else {
+							if (v->PixelClockBackEnd[k] / 3.0 / v->DSCFormatFactor
+									> (1.0 - v->DISPCLKDPPCLKDSCCLKDownSpreading / 100.0) * v->MaxDSCCLK[i]) {
+								v->DSCCLKRequiredMoreThanSupported[i] = true;
+							}
+						}
+					}
+				}
+			}
+		}
+	}
 	for (i = 0; i < v->soc.num_states; i++) {
 		v->NotEnoughDSCUnits[i] = false;
 		v->TotalDSCUnitsRequired = 0.0;
@@ -5297,7 +5319,7 @@ void dml30_ModeSupportAndSystemConfigurationFull(struct display_mode_lib *mode_l
 		for (j = 0; j < 2; j++) {
 			if (v->ScaleRatioAndTapsSupport == 1 && v->SourceFormatPixelAndScanSupport == 1 && v->ViewportSizeSupport[i][j] == 1
 					&& v->DIOSupport[i] == 1 && v->ODMCombine4To1SupportCheckOK[i] == 1
-					&& v->NotEnoughDSCUnits[i] == 0
+					&& v->NotEnoughDSCUnits[i] == 0 && v->DSCCLKRequiredMoreThanSupported[i] == 0
 					&& v->DTBCLKRequiredMoreThanSupported[i] == 0
 					&& v->ROBSupport[i][j] == 1 && v->DISPCLK_DPPCLK_Support[i][j] == 1 && v->TotalAvailablePipesSupport[i][j] == 1
 					&& EnoughWritebackUnits == 1 && WritebackModeSupport == 1
-- 
2.25.1

