From 4eafbe20ce3746a44eb838b3d06320731b7a3350 Mon Sep 17 00:00:00 2001
From: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
Date: Mon, 17 Aug 2020 13:35:51 -0700
Subject: [PATCH 46/78] driver core: fail __device_attach() if device is not
 initialized

If the device is not initialized (device_add() failed scenario),
then attempting device_attach() on this device would lead to NULL
pointer exception due to (dev->p == NULL). So add additional check
for dev->p in __device_attach() function.

Above mentioned scenario is possible in platforms that supports
device filter feature. Device filter feature adds support for platform
to fail the device_add() call based on filtering using platform
specific allow list. For example, consider a case of an untrusted PCI
device in a platform which enables the device filter support. For such
untrusted PCI device, during device_add() call, PCI bus specific filter
function (pci_is_device_allowed()) will be triggered which will return
false and fail call to device_add() function. So attempting to attach
this device again via pci_legacy_init() leads to NULL pointer exception.

[    3.284093] BUG: kernel NULL pointer dereference, address: 00000000000000d0
[    3.284202] #PF: supervisor read access in kernel mode
[    3.284202] #PF: error_code(0x0000) - not-present page
[    3.284202] PGD 0 P4D 0
[    3.284202] Oops: 0000 [#1] SMP PTI
[    3.284202] CPU: 0 PID: 1 Comm: swapper/0 Not tainted 5.9.0-rc1+ #402
[    3.284202] RIP: 0010:__device_attach+0x36/0x140
[    3.284202] Code: 00 00 00 53 48 89 fb 45 31 e4 48 83 ec 18 48 89 ef 65 48 8b 04 25 28 00 00 00 48 89 44 24 10 31 c0 e8 9e d6 4b 00 48 8b 7b 48 <f6> 87 d0 00 00 00 01 75 1f 48 83 7b 68 00 74 5b 48 85 ff 74 3d 48
[    3.284202] RSP: 0000:ffffc9000001fde8 EFLAGS: 00010246
[    3.284202] RAX: 0000000000000000 RBX: ffff88817b3500b0 RCX: 0000000000000000
[    3.284202] RDX: ffff88817b150000 RSI: 0000000000000000 RDI: 0000000000000000
[    3.284202] RBP: ffff88817b350130 R08: 0000000000000125 R09: 000000000000004a
[    3.284202] R10: 00000000000000ff R11: 203a7365725f6e73 R12: 0000000000000000
[    3.284202] R13: 0000000000000000 R14: 0000000000000005 R15: ffffffff82a17644
[    3.284202] FS:  0000000000000000(0000) GS:ffff88817ba00000(0000) knlGS:0000000000000000
[    3.284202] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[    3.284202] CR2: 00000000000000d0 CR3: 0000000003a0a001 CR4: 00000000003706f0
[    3.284202] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
[    3.284202] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
[    3.284202] Call Trace:
[    3.284202]  pci_bus_add_device+0x45/0x70
[    3.284202]  pci_bus_add_devices+0x27/0x70
[    3.284202]  pcibios_scan_root+0x84/0xd0
[    3.284202]  ? pci_legacy_init+0x25/0x25
[    3.284202]  pci_legacy_init+0x22/0x25
[    3.284202]  pci_subsys_init+0x13/0x62
[    3.284202]  do_one_initcall+0x41/0x1df
[    3.284202]  kernel_init_freeable+0x1ad/0x1eb
[    3.284202]  ? rest_init+0xb0/0xb0
[    3.284202]  kernel_init+0x5/0x100
[    3.284202]  ret_from_fork+0x22/0x30

Reviewed-by: Andi Kleen <ak@linux.intel.com>
Signed-off-by: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
---
 drivers/base/dd.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index ecd7cf848daf..70906945011f 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -911,6 +911,12 @@ static int __device_attach(struct device *dev, bool allow_async)
 	int ret = 0;
 
 	device_lock(dev);
+
+	if (!dev->p) {
+		ret = -ENODEV;
+		goto out_unlock;
+	}
+
 	if (dev->p->dead) {
 		goto out_unlock;
 	} else if (dev->driver) {
-- 
2.27.0

