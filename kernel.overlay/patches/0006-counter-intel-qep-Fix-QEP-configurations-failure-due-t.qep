From 0d2b79562d292a00341792e19245083f8477b9ac Mon Sep 17 00:00:00 2001
From: "Tan, Raymond" <raymond.tan@intel.com>
Date: Tue, 19 Nov 2019 07:35:03 +0800
Subject: [PATCH 06/84] counter: intel-qep: Fix QEP configurations failure due
 to RPM

When the device is in runtime-pm, the MMIO register value will be invalid,
thus reading and writing will have no effect to the device. This patch adds
the pm_runtime_* calls to ensure the device is in correct power state
before any MMIO register programming.

Signed-off-by: Tan, Raymond <raymond.tan@intel.com>
---
 drivers/counter/intel-qep.c | 20 ++++++++++++++++++++
 1 file changed, 20 insertions(+)

diff --git a/drivers/counter/intel-qep.c b/drivers/counter/intel-qep.c
index 5c5435de1d27..5d803463abad 100644
--- a/drivers/counter/intel-qep.c
+++ b/drivers/counter/intel-qep.c
@@ -271,6 +271,8 @@ static int intel_qep_function_set(struct counter_device *counter,
 	struct intel_qep *qep = counter_to_qep(counter);
 	u32 reg;
 
+	pm_runtime_get_sync(qep->dev);
+
 	reg = intel_qep_readl(qep->regs, INTEL_QEPCON);
 	if (function == INTEL_QEP_ENCODER_MODE_SWAPPED)
 		reg |= INTEL_QEPCON_SWPAB;
@@ -278,6 +280,8 @@ static int intel_qep_function_set(struct counter_device *counter,
 		reg &= ~INTEL_QEPCON_SWPAB;
 	intel_qep_writel(qep->regs, INTEL_QEPCON, reg);
 
+	pm_runtime_put(qep->dev);
+
 	return 0;
 }
 
@@ -304,6 +308,8 @@ static int intel_qep_action_set(struct counter_device *counter,
 	struct intel_qep *qep = counter_to_qep(counter);
 	u32 reg;
 
+	pm_runtime_get_sync(qep->dev);
+
 	reg = intel_qep_readl(qep->regs, INTEL_QEPCON);
 
 	if (action == INTEL_QEP_SYNAPSE_ACTION_RISING_EDGE)
@@ -313,6 +319,8 @@ static int intel_qep_action_set(struct counter_device *counter,
 
 	intel_qep_writel(qep->regs, INTEL_QEPCON, reg);
 
+	pm_runtime_put(qep->dev);
+
 	return 0;
 }
 
@@ -383,8 +391,12 @@ static ssize_t ceiling_write(struct counter_device *counter,
 	if (ret < 0)
 		return ret;
 
+	pm_runtime_get_sync(qep->dev);
+
 	intel_qep_writel(qep->regs, INTEL_QEPMAX, max);
 
+	pm_runtime_put(qep->dev);
+
 	return len;
 }
 
@@ -484,6 +496,8 @@ static ssize_t noise_write(struct counter_device *counter, void *priv,
 	if (ret < 0)
 		return ret;
 
+	pm_runtime_get_sync(qep->dev);
+
 	if (max > 0x1fffff)
 		max = 0x1ffff;
 
@@ -498,6 +512,8 @@ static ssize_t noise_write(struct counter_device *counter, void *priv,
 
 	intel_qep_writel(qep->regs, INTEL_QEPCON, reg);
 
+	pm_runtime_put(qep->dev);
+
 	return len;
 }
 
@@ -529,6 +545,8 @@ static ssize_t preset_enable_write(struct counter_device *counter, void *priv,
 	if (ret < 0)
 		return ret;
 
+	pm_runtime_get_sync(qep->dev);
+
 	reg = intel_qep_readl(qep->regs, INTEL_QEPCON);
 
 	if (val)
@@ -538,6 +556,8 @@ static ssize_t preset_enable_write(struct counter_device *counter, void *priv,
 
 	intel_qep_writel(qep->regs, INTEL_QEPCON, reg);
 
+	pm_runtime_put(qep->dev);
+
 	return len;
 }
 
-- 
2.27.0

