From 21e42f4295c0cfcd361d50736df53ff403aabd67 Mon Sep 17 00:00:00 2001
From: Chen Yu <yu.c.chen@intel.com>
Date: Wed, 19 May 2021 16:46:24 +0800
Subject: [PATCH 56/80] x86/cpu: Restore MSR_IA32_HW_HRESET_ENABLE MSR on BSP
 during wakeup

The value of MSR_IA32_HW_HRESET_ENABLE is lost when suspending. Given that
HRESET is executed when switching to kernel mode and viceversa, a general
protection fault occurs when HRESET is executed for the first time after
waking up. Thus, restore such MSR when waking up. There is no need to
restore this MSR for APs because it will be restored during CPU hotplug
online.

[Ricardo edited the commit message for clarity.]

Reported-by: Wendy Wang <wendy.wang@intel.com>
Reported-by: kernel test robot <lkp@intel.com>
Co-developed-by: Archana Patni <archana.patni@intel.com>
Signed-off-by: Chen Yu <yu.c.chen@intel.com>
---
 arch/x86/include/asm/hreset.h | 6 ++++++
 arch/x86/kernel/cpu/common.c  | 6 ++++++
 arch/x86/power/cpu.c          | 2 ++
 3 files changed, 14 insertions(+)

diff --git a/arch/x86/include/asm/hreset.h b/arch/x86/include/asm/hreset.h
index 2232cbc7b49b..25454ab8add8 100644
--- a/arch/x86/include/asm/hreset.h
+++ b/arch/x86/include/asm/hreset.h
@@ -30,6 +30,12 @@
 
 #define __ASM_HRESET  .byte 0xf3, 0xf, 0x3a, 0xf0, 0xc0, 0x0
 
+#else /* __ASSEMBLY */
+
+#ifdef __KERNEL__
+extern void hreset_reload(void);
+#endif /* __KERNEL__ */
+
 #endif /* __ASSEMBLY */
 
 #endif /* _ASM_X86_HRESET_H */
diff --git a/arch/x86/kernel/cpu/common.c b/arch/x86/kernel/cpu/common.c
index 3a3f87e4f317..eddda5f5f014 100644
--- a/arch/x86/kernel/cpu/common.c
+++ b/arch/x86/kernel/cpu/common.c
@@ -364,6 +364,12 @@ static __always_inline void setup_hreset(struct cpuinfo_x86 *c)
 	pr_info_once("x86/cpu: Intel History Reset (HRESET) activated\n");
 }
 
+void hreset_reload(void)
+{
+	if (hreset_features)
+		wrmsrl(MSR_IA32_HW_HRESET_ENABLE, hreset_features);
+}
+
 /* These bits should not change their value after CPU init is finished. */
 static const unsigned long cr4_pinned_mask =
 	X86_CR4_SMEP | X86_CR4_SMAP | X86_CR4_UMIP | X86_CR4_FSGSBASE;
diff --git a/arch/x86/power/cpu.c b/arch/x86/power/cpu.c
index 3a070e7cdb8b..3a443ced84b2 100644
--- a/arch/x86/power/cpu.c
+++ b/arch/x86/power/cpu.c
@@ -25,6 +25,7 @@
 #include <asm/cpu.h>
 #include <asm/mmu_context.h>
 #include <asm/cpu_device_id.h>
+#include <asm/hreset.h>
 
 #ifdef CONFIG_X86_32
 __visible unsigned long saved_context_ebx;
@@ -259,6 +260,7 @@ static void notrace __restore_processor_state(struct saved_context *ctxt)
 	tsc_verify_tsc_adjust(true);
 	x86_platform.restore_sched_clock_state();
 	mtrr_bp_restore();
+	hreset_reload();
 	perf_restore_debug_store();
 	msr_restore_context(ctxt);
 
-- 
2.27.0

