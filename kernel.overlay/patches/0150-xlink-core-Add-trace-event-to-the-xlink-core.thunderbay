From bd9f3a7eb0c25379545d7109e28f2e38ae3454af Mon Sep 17 00:00:00 2001
From: Ravikumar PM <ravikumar.pm@intel.com>
Date: Tue, 9 Feb 2021 15:45:41 +0530
Subject: [PATCH 150/170] xlink-core: Add trace event to the xlink core

Trace events are added to record the entry and exit of the interface
functions.
Trace events are added to analyse xlink protocol transaction.
---
 drivers/misc/xlink-core/Makefile            |   4 +-
 drivers/misc/xlink-core/xlink-core.c        |  18 +
 drivers/misc/xlink-core/xlink-defs.h        |   1 +
 drivers/misc/xlink-core/xlink-dispatcher.c  |  20 +-
 drivers/misc/xlink-core/xlink-multiplexer.c |  28 ++
 drivers/misc/xlink-core/xlink-trace.c       |  15 +
 drivers/misc/xlink-core/xlink-trace.h       | 424 ++++++++++++++++++++
 7 files changed, 504 insertions(+), 6 deletions(-)
 create mode 100644 drivers/misc/xlink-core/xlink-trace.c
 create mode 100644 drivers/misc/xlink-core/xlink-trace.h

diff --git a/drivers/misc/xlink-core/Makefile b/drivers/misc/xlink-core/Makefile
index ee81f9d05f2b..bae4958a429d 100644
--- a/drivers/misc/xlink-core/Makefile
+++ b/drivers/misc/xlink-core/Makefile
@@ -1,5 +1,5 @@
 #
-# Makefile for Keem Bay xlink Linux driver
+# Makefile for xlink Linux driver
 #
 obj-$(CONFIG_XLINK_CORE) += xlink.o
-xlink-objs += xlink-core.o xlink-multiplexer.o xlink-dispatcher.o xlink-platform.o xlink-ioctl.o
+xlink-objs += xlink-core.o xlink-multiplexer.o xlink-dispatcher.o xlink-platform.o xlink-ioctl.o xlink-trace.o
diff --git a/drivers/misc/xlink-core/xlink-core.c b/drivers/misc/xlink-core/xlink-core.c
index 23c0025f6f0d..62e52af248f4 100644
--- a/drivers/misc/xlink-core/xlink-core.c
+++ b/drivers/misc/xlink-core/xlink-core.c
@@ -583,6 +583,8 @@ enum xlink_error xlink_open_channel(struct xlink_handle *handle,
 	int event_queued = 0;
 	enum xlink_error rc;
 
+	trace_xlink_open_channel(handle->sw_device_id, chan);
+
 	if (!xlink || !handle)
 		return X_LINK_ERROR;
 
@@ -599,6 +601,8 @@ enum xlink_error xlink_open_channel(struct xlink_handle *handle,
 	rc = xlink_multiplexer_tx(event, &event_queued);
 	if (!event_queued)
 		xlink_destroy_event(event);
+	trace_xlink_open_channel_completion(handle->sw_device_id, chan);
+
 	return rc;
 }
 EXPORT_SYMBOL_GPL(xlink_open_channel);
@@ -611,6 +615,7 @@ enum xlink_error xlink_close_channel(struct xlink_handle *handle,
 	enum xlink_error rc;
 	int event_queued = 0;
 
+	trace_xlink_close_channel(handle->sw_device_id, chan);
 	if (!xlink || !handle)
 		return X_LINK_ERROR;
 
@@ -626,6 +631,7 @@ enum xlink_error xlink_close_channel(struct xlink_handle *handle,
 	rc = xlink_multiplexer_tx(event, &event_queued);
 	if (!event_queued)
 		xlink_destroy_event(event);
+	trace_xlink_close_channel_completion(handle->sw_device_id, chan);
 
 	return rc;
 }
@@ -714,7 +720,10 @@ enum xlink_error xlink_write_data(struct xlink_handle *handle,
 {
 	enum xlink_error rc = 0;
 
+	trace_xlink_write_data(handle->sw_device_id, chan, size);
 	rc = do_xlink_write_data(handle, chan, pmessage, size, 0);
+	trace_xlink_write_data_completion(handle->sw_device_id, chan, size);
+
 	return rc;
 }
 EXPORT_SYMBOL_GPL(xlink_write_data);
@@ -724,7 +733,10 @@ enum xlink_error xlink_write_data_user(struct xlink_handle *handle,
 {
 	enum xlink_error rc = 0;
 
+	trace_xlink_write_data_user(handle->sw_device_id, chan, size);
 	rc = do_xlink_write_data(handle, chan, pmessage, size, 1);
+	trace_xlink_write_data_user_completion(handle->sw_device_id, chan, size);
+
 	return rc;
 }
 
@@ -737,6 +749,7 @@ enum xlink_error xlink_write_control_data(struct xlink_handle *handle,
 	int event_queued = 0;
 	enum xlink_error rc;
 
+	trace_xlink_write_control(handle->sw_device_id, chan, size);
 	if (!xlink || !handle)
 		return X_LINK_ERROR;
 	if (size > XLINK_MAX_CONTROL_DATA_SIZE)
@@ -752,6 +765,8 @@ enum xlink_error xlink_write_control_data(struct xlink_handle *handle,
 	rc = xlink_multiplexer_tx(event, &event_queued);
 	if (!event_queued)
 		xlink_destroy_event(event);
+	trace_xlink_write_control_completion(handle->sw_device_id, chan, size);
+
 	return rc;
 }
 EXPORT_SYMBOL_GPL(xlink_write_control_data);
@@ -829,6 +844,7 @@ enum xlink_error xlink_read_data(struct xlink_handle *handle,
 	int event_queued = 0;
 	enum xlink_error rc;
 
+	trace_xlink_read(handle->sw_device_id, chan, *size);
 	if (!xlink || !handle)
 		return X_LINK_ERROR;
 
@@ -846,6 +862,8 @@ enum xlink_error xlink_read_data(struct xlink_handle *handle,
 	rc = xlink_multiplexer_tx(event, &event_queued);
 	if (!event_queued)
 		xlink_destroy_event(event);
+	trace_xlink_read_data_completion(handle->sw_device_id, chan, *size);
+
 	return rc;
 }
 EXPORT_SYMBOL_GPL(xlink_read_data);
diff --git a/drivers/misc/xlink-core/xlink-defs.h b/drivers/misc/xlink-core/xlink-defs.h
index 81aa3bfffcd3..cbc92cd5aff7 100644
--- a/drivers/misc/xlink-core/xlink-defs.h
+++ b/drivers/misc/xlink-core/xlink-defs.h
@@ -10,6 +10,7 @@
 
 #include <linux/slab.h>
 #include <linux/xlink.h>
+#include "xlink-trace.h"
 
 #define XLINK_MAX_BUF_SIZE		128U
 #define XLINK_MAX_DATA_SIZE		(1024U * 1024U * 1024U)
diff --git a/drivers/misc/xlink-core/xlink-dispatcher.c b/drivers/misc/xlink-core/xlink-dispatcher.c
index f9b3a10e848e..a238e1561cee 100644
--- a/drivers/misc/xlink-core/xlink-dispatcher.c
+++ b/drivers/misc/xlink-core/xlink-dispatcher.c
@@ -69,14 +69,14 @@ static struct xlink_dispatcher *xlinkd;
  *
  */
 
-static int wait_tx_queue_empty(struct dispatcher* disp)
+static int wait_tx_queue_empty(struct dispatcher *disp)
 {
-	do{
+	do {
 		mutex_lock(&disp->queue.lock);
-		if(disp->queue.count == 0)
+		if (disp->queue.count == 0)
 			break;
 		mutex_unlock(&disp->queue.lock);
-	}while(1);
+	} while (1);
 	mutex_unlock(&disp->queue.lock);
 	return 0;
 }
@@ -154,6 +154,10 @@ static int dispatcher_event_send(struct xlink_event *event)
 	size_t event_header_size = sizeof(event->header);
 	int rc;
 
+	trace_xlink_dispatcher_header(event->handle->sw_device_id,
+				      event->header.chan,
+				      event->header.id,
+				      event_header_size);
 	rc = xlink_platform_write(event->interface,
 				  event->handle->sw_device_id, &event->header,
 				  &event_header_size, event->header.timeout, NULL);
@@ -168,6 +172,10 @@ static int dispatcher_event_send(struct xlink_event *event)
 					  event->handle->sw_device_id, event->data,
 					  &event->header.size, event->header.timeout,
 					  NULL);
+		trace_xlink_dispatcher_write(event->handle->sw_device_id,
+					     event->header.chan,
+					     event->header.id,
+					     event->header.size);
 		if (rc) {
 			pr_err("Write data failed %d\n", rc);
 			return rc;
@@ -214,6 +222,10 @@ static int xlink_dispatcher_rxthread(void *context)
 			continue;
 		if (is_valid_event_header(event)) {
 			event->link_id = disp->link_id;
+			trace_xlink_event_receive(event->handle->sw_device_id,
+						  event->header.chan,
+						  event->header.id,
+						  event->header.size);
 			rc = xlink_multiplexer_rx(event);
 			if (!rc) {
 				event = xlink_create_event(disp->link_id, 0,
diff --git a/drivers/misc/xlink-core/xlink-multiplexer.c b/drivers/misc/xlink-core/xlink-multiplexer.c
index e0edc537e7ec..de97c580c7aa 100644
--- a/drivers/misc/xlink-core/xlink-multiplexer.c
+++ b/drivers/misc/xlink-core/xlink-multiplexer.c
@@ -547,6 +547,10 @@ enum xlink_error xlink_multiplexer_tx(struct xlink_event *event,
 			if (rc == X_LINK_SUCCESS) {
 				opchan->tx_fill_level += event->header.size;
 				opchan->tx_packet_level++;
+				trace_xlink_write_message(event->handle->sw_device_id,
+							  event->header.chan,
+							  event->header.id,
+							  event->header.size);
 				xlink_dispatcher_event_add(EVENT_TX, event);
 				*event_queued = 1;
 				if (opchan->chan->mode == RXN_TXB ||
@@ -575,10 +579,18 @@ enum xlink_error xlink_multiplexer_tx(struct xlink_event *event,
 				mutex_lock(&opchan->lock);
 			}
 			if (rc == X_LINK_SUCCESS) {
+				trace_xlink_read_pkt_tx_available(event->handle->sw_device_id,
+								  event->header.chan,
+								  event->header.id,
+								  event->header.size);
 				pkt = get_packet_from_channel(&opchan->rx_queue);
 				if (pkt) {
 					*(u32 **)event->pdata = (u32 *)pkt->data;
 					*event->length = pkt->length;
+					trace_xlink_read_pkt_tx_consumed(event->handle->sw_device_id,
+									 event->header.chan,
+									 event->header.id,
+									 event->header.size);
 					xlink_dispatcher_event_add(EVENT_TX, event);
 					*event_queued = 1;
 				} else {
@@ -763,6 +775,10 @@ enum xlink_error xlink_multiplexer_rx(struct xlink_event *event)
 							 event->header.size,
 							 XLINK_PACKET_ALIGNMENT,
 							 XLINK_NORMAL_MEMORY);
+			trace_xlink_rx_read_of_write(event->handle->sw_device_id,
+						     event->header.chan,
+						     event->header.id,
+						     event->header.size);
 			if (buffer) {
 				size = event->header.size;
 				xlink_platform_read(event->interface,
@@ -818,6 +834,10 @@ enum xlink_error xlink_multiplexer_rx(struct xlink_event *event)
 				}
 				//complete regardless of mode/timeout
 				complete(&opchan->pkt_available);
+				trace_xlink_rx_read_pkt_data_arrived(event->handle->sw_device_id,
+								     event->header.chan,
+								     event->header.id,
+								     event->header.size);
 				// run callback
 				if (xmux->channels[link_id][chan].status == CHAN_OPEN &&
 				    chan_is_non_blocking_read(opchan) &&
@@ -866,6 +886,10 @@ enum xlink_error xlink_multiplexer_rx(struct xlink_event *event)
 				}
 				// channel blocking, notify waiting threads of available packet
 				complete(&opchan->pkt_available);
+				trace_xlink_rx_read_pkt_control_arrived(event->handle->sw_device_id,
+									event->header.chan,
+									event->header.id,
+									event->header.size);
 			} else {
 				// failed to allocate buffer
 				rc = X_LINK_ERROR;
@@ -884,6 +908,10 @@ enum xlink_error xlink_multiplexer_rx(struct xlink_event *event)
 		}
 		//complete regardless of mode/timeout
 		complete(&opchan->pkt_consumed);
+		trace_xlink_rx_read_consumed_arrived(event->handle->sw_device_id,
+						     event->header.chan,
+						     event->header.id,
+						     event->header.size);
 		// run callback
 		if (xmux->channels[link_id][chan].status == CHAN_OPEN &&
 		    chan_is_non_blocking_write(opchan) &&
diff --git a/drivers/misc/xlink-core/xlink-trace.c b/drivers/misc/xlink-core/xlink-trace.c
new file mode 100644
index 000000000000..53ceb6a7e5fe
--- /dev/null
+++ b/drivers/misc/xlink-core/xlink-trace.c
@@ -0,0 +1,15 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * xlink Core Driver.
+ *
+ * Copyright (C) 2018-2019 Intel Corporation
+ *
+ */
+
+#include <linux/module.h>
+
+#ifndef __CHECKER1__
+#define CREATE_TRACE_POINTS
+#include "xlink-trace.h"
+
+#endif
diff --git a/drivers/misc/xlink-core/xlink-trace.h b/drivers/misc/xlink-core/xlink-trace.h
new file mode 100644
index 000000000000..0284bc54c955
--- /dev/null
+++ b/drivers/misc/xlink-core/xlink-trace.h
@@ -0,0 +1,424 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * xlink Defines.
+ *
+ * Copyright (C) 2018-2019 Intel Corporation
+ *
+ */
+
+#undef TRACE_SYSTEM
+#define TRACE_SYSTEM xlink_trace
+
+#if !defined(_XLINK_TRACE_H) || defined(TRACE_HEADER_MULTI_READ)
+#define _XLINK_TRACE_H
+
+#include <linux/tracepoint.h>
+
+
+TRACE_EVENT(xlink_open_channel,
+		TP_PROTO(uint32_t swid, uint16_t chan),
+		TP_ARGS(swid, chan),
+		TP_STRUCT__entry(
+			__field(uint32_t, swid)
+			__field(uint16_t, chan)
+		),
+		TP_fast_assign(
+			__entry->swid = swid;
+			__entry->chan = chan;
+		),
+		TP_printk("swid=%d chan=%d", __entry->swid, __entry->chan)
+);
+TRACE_EVENT(xlink_open_channel_completion,
+		TP_PROTO(uint32_t swid, uint16_t chan),
+		TP_ARGS(swid, chan),
+		TP_STRUCT__entry(
+			__field(uint32_t, swid)
+			__field(uint16_t, chan)
+		),
+		TP_fast_assign(
+			__entry->swid = swid;
+			__entry->chan = chan;
+		),
+		TP_printk("swid=%d chan=%d", __entry->swid, __entry->chan)
+);
+
+TRACE_EVENT(xlink_close_channel,
+		TP_PROTO(uint32_t swid, uint16_t chan),
+		TP_ARGS(swid, chan),
+		TP_STRUCT__entry(
+			__field(uint32_t, swid)
+			__field(uint16_t, chan)
+		),
+		TP_fast_assign(
+			__entry->swid = swid;
+			__entry->chan = chan;
+		),
+		TP_printk("swid=%d chan=%d", __entry->swid, __entry->chan)
+);
+
+TRACE_EVENT(xlink_close_channel_completion,
+		TP_PROTO(uint32_t swid, uint16_t chan),
+		TP_ARGS(swid, chan),
+		TP_STRUCT__entry(
+			__field(uint32_t, swid)
+			__field(uint16_t, chan)
+		),
+		TP_fast_assign(
+			__entry->swid = swid;
+			__entry->chan = chan;
+		),
+		TP_printk("swid=%d chan=%d", __entry->swid, __entry->chan)
+);
+
+TRACE_EVENT(xlink_write_control,
+		TP_PROTO(uint32_t swid, uint16_t chan, uint32_t size),
+		TP_ARGS(swid, chan, size),
+		TP_STRUCT__entry(
+			__field(uint32_t, swid)
+			__field(uint16_t, chan)
+			__field(uint32_t, size)
+		),
+		TP_fast_assign(
+			__entry->swid = swid;
+			__entry->chan = chan;
+			__entry->size = size;
+		),
+		TP_printk("swid=%d chan=%d size=%d", __entry->swid, __entry->chan, __entry->size)
+);
+
+TRACE_EVENT(xlink_write_control_completion,
+		TP_PROTO(uint32_t swid, uint16_t chan, uint32_t size),
+		TP_ARGS(swid, chan, size),
+		TP_STRUCT__entry(
+			__field(uint32_t, swid)
+			__field(uint16_t, chan)
+			__field(uint32_t, size)
+		),
+		TP_fast_assign(
+			__entry->swid = swid;
+			__entry->chan = chan;
+			__entry->size = size;
+		),
+		TP_printk("swid=%d chan=%d size=%d", __entry->swid, __entry->chan, __entry->size)
+);
+TRACE_EVENT(xlink_write_data,
+		TP_PROTO(uint32_t swid, uint16_t chan, uint32_t size),
+		TP_ARGS(swid, chan, size),
+		TP_STRUCT__entry(
+			__field(uint32_t, swid)
+			__field(uint16_t, chan)
+			__field(uint32_t, size)
+		),
+		TP_fast_assign(
+			__entry->swid = swid;
+			__entry->chan = chan;
+			__entry->size = size;
+		),
+		TP_printk("swid=%d chan=%d size=%d", __entry->swid, __entry->chan, __entry->size)
+);
+TRACE_EVENT(xlink_write_data_completion,
+		TP_PROTO(uint32_t swid, uint16_t chan, uint32_t size),
+		TP_ARGS(swid, chan, size),
+		TP_STRUCT__entry(
+			__field(uint32_t, swid)
+			__field(uint16_t, chan)
+			__field(uint32_t, size)
+		),
+		TP_fast_assign(
+			__entry->swid = swid;
+			__entry->chan = chan;
+			__entry->size = size;
+		),
+		TP_printk("swid=%d chan=%d size=%d", __entry->swid, __entry->chan, __entry->size)
+);
+TRACE_EVENT(xlink_write_data_user,
+		TP_PROTO(uint32_t swid, uint16_t chan, uint32_t size),
+		TP_ARGS(swid, chan, size),
+		TP_STRUCT__entry(
+			__field(uint32_t, swid)
+			__field(uint16_t, chan)
+			__field(uint32_t, size)
+		),
+		TP_fast_assign(
+			__entry->swid = swid;
+			__entry->chan = chan;
+			__entry->size = size;
+		),
+		TP_printk("swid=%d chan=%d size=%d", __entry->swid, __entry->chan, __entry->size)
+);
+TRACE_EVENT(xlink_write_data_user_completion,
+		TP_PROTO(uint32_t swid, uint16_t chan, uint32_t size),
+		TP_ARGS(swid, chan, size),
+		TP_STRUCT__entry(
+			__field(uint32_t, swid)
+			__field(uint16_t, chan)
+			__field(uint32_t, size)
+		),
+		TP_fast_assign(
+			__entry->swid = swid;
+			__entry->chan = chan;
+			__entry->size = size;
+		),
+		TP_printk("swid=%d chan=%d size=%d", __entry->swid, __entry->chan, __entry->size)
+);
+
+TRACE_EVENT(xlink_read,
+		TP_PROTO(uint32_t swid, uint16_t chan, uint32_t size),
+		TP_ARGS(swid, chan, size),
+		TP_STRUCT__entry(
+			__field(uint32_t, swid)
+			__field(uint16_t, chan)
+			__field(uint32_t, size)
+		),
+		TP_fast_assign(
+			__entry->swid = swid;
+			__entry->chan = chan;
+			__entry->size = size;
+		),
+		TP_printk("swid=%d chan=%d size=%d", __entry->swid, __entry->chan, __entry->size)
+);
+TRACE_EVENT(xlink_read_mutex,
+		TP_PROTO(uint32_t swid, uint16_t chan, uint32_t size),
+		TP_ARGS(swid, chan, size),
+		TP_STRUCT__entry(
+			__field(uint32_t, swid)
+			__field(uint16_t, chan)
+			__field(uint32_t, size)
+		),
+		TP_fast_assign(
+			__entry->swid = swid;
+			__entry->chan = chan;
+			__entry->size = size;
+		),
+		TP_printk("swid=%d chan=%d size=%d", __entry->swid, __entry->chan, __entry->size)
+);
+TRACE_EVENT(xlink_read_alloc_event,
+		TP_PROTO(uint32_t swid, uint16_t chan, uint32_t size),
+		TP_ARGS(swid, chan, size),
+		TP_STRUCT__entry(
+			__field(uint32_t, swid)
+			__field(uint16_t, chan)
+			__field(uint32_t, size)
+		),
+		TP_fast_assign(
+			__entry->swid = swid;
+			__entry->chan = chan;
+			__entry->size = size;
+		),
+		TP_printk("swid=%d chan=%d size=%d", __entry->swid, __entry->chan, __entry->size)
+);
+TRACE_EVENT(xlink_read_channel_mutex,
+		TP_PROTO(uint32_t swid, uint16_t chan, uint32_t size),
+		TP_ARGS(swid, chan, size),
+		TP_STRUCT__entry(
+			__field(uint32_t, swid)
+			__field(uint16_t, chan)
+			__field(uint32_t, size)
+		),
+		TP_fast_assign(
+			__entry->swid = swid;
+			__entry->chan = chan;
+			__entry->size = size;
+		),
+		TP_printk("swid=%d chan=%d size=%d", __entry->swid, __entry->chan, __entry->size)
+);
+
+TRACE_EVENT(xlink_read_data_completion,
+		TP_PROTO(uint32_t swid, uint16_t chan, uint32_t size),
+		TP_ARGS(swid, chan, size),
+		TP_STRUCT__entry(
+			__field(uint32_t, swid)
+			__field(uint16_t, chan)
+			__field(uint32_t, size)
+		),
+		TP_fast_assign(
+			__entry->swid = swid;
+			__entry->chan = chan;
+			__entry->size = size;
+		),
+		TP_printk("swid=%d chan=%d size=%d", __entry->swid, __entry->chan, __entry->size)
+);
+
+/*tx and rx events*/
+TRACE_EVENT(xlink_write_message,
+		TP_PROTO(uint32_t swid, uint16_t chan, uint32_t id, uint32_t size),
+		TP_ARGS(swid, chan, id, size),
+		TP_STRUCT__entry(
+			__field(uint32_t, swid)
+			__field(uint16_t, chan)
+			__field(uint32_t, id)
+			__field(uint32_t, size)
+		),
+		TP_fast_assign(
+			__entry->swid = swid;
+			__entry->chan = chan;
+			__entry->size = id;
+			__entry->size = size;
+		),
+		TP_printk("swid=%d chan=%d size=%d id=%d", __entry->swid, __entry->chan, __entry->size, __entry->id)
+);
+TRACE_EVENT(xlink_read_pkt_tx_available,
+		TP_PROTO(uint32_t swid, uint16_t chan, uint32_t id, uint32_t size),
+		TP_ARGS(swid, chan, id, size),
+		TP_STRUCT__entry(
+			__field(uint32_t, swid)
+			__field(uint16_t, chan)
+			__field(uint32_t, id)
+			__field(uint32_t, size)
+		),
+		TP_fast_assign(
+			__entry->swid = swid;
+			__entry->chan = chan;
+			__entry->size = id;
+			__entry->size = size;
+		),
+		TP_printk("swid=%d chan=%d size=%d id=%d", __entry->swid, __entry->chan, __entry->size, __entry->id)
+);
+TRACE_EVENT(xlink_read_pkt_tx_consumed,
+		TP_PROTO(uint32_t swid, uint16_t chan, uint32_t id, uint32_t size),
+		TP_ARGS(swid, chan, id, size),
+		TP_STRUCT__entry(
+			__field(uint32_t, swid)
+			__field(uint16_t, chan)
+			__field(uint32_t, id)
+			__field(uint32_t, size)
+		),
+		TP_fast_assign(
+			__entry->swid = swid;
+			__entry->chan = chan;
+			__entry->size = id;
+			__entry->size = size;
+		),
+		TP_printk("swid=%d chan=%d size=%d id=%d", __entry->swid, __entry->chan, __entry->size, __entry->id)
+);
+TRACE_EVENT(xlink_rx_read_of_write,
+		TP_PROTO(uint32_t swid, uint16_t chan, uint32_t id, uint32_t size),
+		TP_ARGS(swid, chan, id, size),
+		TP_STRUCT__entry(
+			__field(uint32_t, swid)
+			__field(uint16_t, chan)
+			__field(uint32_t, id)
+			__field(uint32_t, size)
+		),
+		TP_fast_assign(
+			__entry->swid = swid;
+			__entry->chan = chan;
+			__entry->size = id;
+			__entry->size = size;
+		),
+		TP_printk("swid=%d chan=%d size=%d id=%d", __entry->swid, __entry->chan, __entry->size, __entry->id)
+);
+TRACE_EVENT(xlink_rx_read_pkt_data_arrived,
+		TP_PROTO(uint32_t swid, uint16_t chan, uint32_t id, uint32_t size),
+		TP_ARGS(swid, chan, id, size),
+		TP_STRUCT__entry(
+			__field(uint32_t, swid)
+			__field(uint16_t, chan)
+			__field(uint32_t, id)
+			__field(uint32_t, size)
+		),
+		TP_fast_assign(
+			__entry->swid = swid;
+			__entry->chan = chan;
+			__entry->size = id;
+			__entry->size = size;
+		),
+		TP_printk("swid=%d chan=%d size=%d id=%d", __entry->swid, __entry->chan, __entry->size, __entry->id)
+);
+TRACE_EVENT(xlink_rx_read_pkt_control_arrived,
+		TP_PROTO(uint32_t swid, uint16_t chan, uint32_t id, uint32_t size),
+		TP_ARGS(swid, chan, id, size),
+		TP_STRUCT__entry(
+			__field(uint32_t, swid)
+			__field(uint16_t, chan)
+			__field(uint32_t, id)
+			__field(uint32_t, size)
+		),
+		TP_fast_assign(
+			__entry->swid = swid;
+			__entry->chan = chan;
+			__entry->size = id;
+			__entry->size = size;
+		),
+		TP_printk("swid=%d chan=%d size=%d id=%d", __entry->swid, __entry->chan, __entry->size, __entry->id)
+);
+TRACE_EVENT(xlink_rx_read_consumed_arrived,
+		TP_PROTO(uint32_t swid, uint16_t chan, uint32_t id, uint32_t size),
+		TP_ARGS(swid, chan, id, size),
+		TP_STRUCT__entry(
+			__field(uint32_t, swid)
+			__field(uint16_t, chan)
+			__field(uint32_t, id)
+			__field(uint32_t, size)
+		),
+		TP_fast_assign(
+			__entry->swid = swid;
+			__entry->chan = chan;
+			__entry->size = id;
+			__entry->size = size;
+		),
+		TP_printk("swid=%d chan=%d size=%d id=%d", __entry->swid, __entry->chan, __entry->size, __entry->id)
+);
+/*dispatcher events*/
+TRACE_EVENT(xlink_dispatcher_header,
+		TP_PROTO(uint32_t swid, uint16_t chan, uint32_t id, uint32_t size),
+		TP_ARGS(swid, chan, id, size),
+		TP_STRUCT__entry(
+			__field(uint32_t, swid)
+			__field(uint16_t, chan)
+			__field(uint32_t, id)
+			__field(uint32_t, size)
+		),
+		TP_fast_assign(
+			__entry->swid = swid;
+			__entry->chan = chan;
+			__entry->size = id;
+			__entry->size = size;
+		),
+		TP_printk("swid=%d chan=%d size=%d id=%d", __entry->swid, __entry->chan, __entry->size, __entry->id)
+);
+TRACE_EVENT(xlink_dispatcher_write,
+		TP_PROTO(uint32_t swid, uint16_t chan, uint32_t id, uint32_t size),
+		TP_ARGS(swid, chan, id, size),
+		TP_STRUCT__entry(
+			__field(uint32_t, swid)
+			__field(uint16_t, chan)
+			__field(uint32_t, id)
+			__field(uint32_t, size)
+		),
+		TP_fast_assign(
+			__entry->swid = swid;
+			__entry->chan = chan;
+			__entry->size = id;
+			__entry->size = size;
+		),
+		TP_printk("swid=%d chan=%d size=%d id=%d", __entry->swid, __entry->chan, __entry->size, __entry->id)
+);
+TRACE_EVENT(xlink_event_receive,
+		TP_PROTO(uint32_t swid, uint16_t chan, uint32_t id, uint32_t size),
+		TP_ARGS(swid, chan, id, size),
+		TP_STRUCT__entry(
+			__field(uint32_t, swid)
+			__field(uint16_t, chan)
+			__field(uint32_t, id)
+			__field(uint32_t, size)
+		),
+		TP_fast_assign(
+			__entry->swid = swid;
+			__entry->chan = chan;
+			__entry->size = id;
+			__entry->size = size;
+		),
+		TP_printk("swid=%d chan=%d size=%d id=%d", __entry->swid, __entry->chan, __entry->size, __entry->id)
+);
+#endif /* _XLINK_TRACE_H */
+
+/* This part must be outside protection */
+#undef TRACE_INCLUDE_PATH
+#ifdef CONFIG_XLINK_LOCAL_HOST
+#define TRACE_INCLUDE_PATH	../../drivers/misc/xlink-core
+#else
+#define TRACE_INCLUDE_PATH	.
+#endif
+#define TRACE_INCLUDE_FILE xlink-trace
+#include <trace/define_trace.h>
-- 
2.27.0

