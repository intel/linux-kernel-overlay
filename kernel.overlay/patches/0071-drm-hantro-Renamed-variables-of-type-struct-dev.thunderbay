From 768cdbe71e740d5739b1851e4b4e5fb11d17eaa9 Mon Sep 17 00:00:00 2001
From: Hoe Sheng Yang <sheng.yang.hoe@intel.com>
Date: Thu, 25 Mar 2021 22:48:06 +0800
Subject: [PATCH 071/170] drm: hantro: Renamed variables of type struct
 device_info to pdevinfo

Signed-off-by: Hoe Sheng Yang <sheng.yang.hoe@intel.com>
---
 drivers/gpu/drm/hantro_driver/hantro_cache.c  |  36 ++---
 drivers/gpu/drm/hantro_driver/hantro_dec.c    | 146 +++++++++---------
 drivers/gpu/drm/hantro_driver/hantro_dec400.c |   2 +-
 drivers/gpu/drm/hantro_driver/hantro_device.h |  22 +--
 .../gpu/drm/hantro_driver/hantro_devicemgr.c  | 112 +++++++-------
 drivers/gpu/drm/hantro_driver/hantro_drm.c    |  64 ++++----
 drivers/gpu/drm/hantro_driver/hantro_drm.h    |   2 +-
 drivers/gpu/drm/hantro_driver/hantro_drv.c    |  72 ++++-----
 drivers/gpu/drm/hantro_driver/hantro_enc.c    |  84 +++++-----
 drivers/gpu/drm/hantro_driver/hantro_fs.c     |  68 ++++----
 drivers/gpu/drm/hantro_driver/hantro_priv.h   |   2 +-
 11 files changed, 305 insertions(+), 305 deletions(-)

diff --git a/drivers/gpu/drm/hantro_driver/hantro_cache.c b/drivers/gpu/drm/hantro_driver/hantro_cache.c
index e71673ef43b1..0727db061250 100644
--- a/drivers/gpu/drm/hantro_driver/hantro_cache.c
+++ b/drivers/gpu/drm/hantro_driver/hantro_cache.c
@@ -37,27 +37,27 @@ static irqreturn_t cache_isr(int irq, void *dev_id);
 /******************************************************************************/
 static int check_cache_irq(struct cache_dev_t *dev)
 {
-	struct device_info *parentdevice = getparentdevice(dev, CORE_CACHE);
+	struct device_info *pdevinfo = getparentdevice(dev, CORE_CACHE);
 	unsigned long flags;
 	int rdy = 0;
 
-	spin_lock_irqsave(&parentdevice->cache_owner_lock, flags);
+	spin_lock_irqsave(&pdevinfo->cache_owner_lock, flags);
 	if (dev->irq_received) {
 		/* reset the wait condition(s) */
 		dev->irq_received = 0;
 		rdy = 1;
 	}
 
-	spin_unlock_irqrestore(&parentdevice->cache_owner_lock, flags);
+	spin_unlock_irqrestore(&pdevinfo->cache_owner_lock, flags);
 
 	return rdy;
 }
 
 static unsigned int wait_cache_ready(struct cache_dev_t *dev)
 {
-	struct device_info *parentdevice = getparentdevice(dev, CORE_CACHE);
+	struct device_info *pdevinfo = getparentdevice(dev, CORE_CACHE);
 
-	if (wait_event_interruptible(parentdevice->cache_wait_queue,
+	if (wait_event_interruptible(pdevinfo->cache_wait_queue,
 				     check_cache_irq(dev))) {
 		PDEBUG("Cache wait_event_interruptible interrupted\n");
 		return -ERESTARTSYS;
@@ -68,18 +68,18 @@ static unsigned int wait_cache_ready(struct cache_dev_t *dev)
 
 static int check_core_occupation(struct cache_dev_t *dev, struct file *filp)
 {
-	struct device_info *parentdevice = getparentdevice(dev, CORE_CACHE);
+	struct device_info *pdevinfo = getparentdevice(dev, CORE_CACHE);
 	int ret = 0;
 	unsigned long flags;
 
-	spin_lock_irqsave(&parentdevice->cache_owner_lock, flags);
+	spin_lock_irqsave(&pdevinfo->cache_owner_lock, flags);
 	if (!dev->is_reserved) {
 		dev->is_reserved = 1;
 		dev->cacheowner = filp;
 		ret = 1;
 	}
 
-	spin_unlock_irqrestore(&parentdevice->cache_owner_lock, flags);
+	spin_unlock_irqrestore(&pdevinfo->cache_owner_lock, flags);
 	return ret;
 }
 
@@ -90,13 +90,13 @@ static int get_workable_core(struct cache_dev_t *dev, struct file *filp)
 
 static long reserve_core(struct cache_dev_t *dev, struct file *filp)
 {
-	struct device_info *parentdevice;
+	struct device_info *pdevinfo;
 	int ret = 0;
 
 	START_TIME;
-	parentdevice = getparentdevice(dev, CORE_CACHE);
+	pdevinfo = getparentdevice(dev, CORE_CACHE);
 	/* lock a core that has specified core id */
-	if (wait_event_interruptible(parentdevice->cache_hw_queue,
+	if (wait_event_interruptible(pdevinfo->cache_hw_queue,
 				     get_workable_core(dev, filp) != 0))
 		ret = -ERESTARTSYS;
 
@@ -107,10 +107,10 @@ static long reserve_core(struct cache_dev_t *dev, struct file *filp)
 static void release_core(struct cache_dev_t *dev)
 {
 	unsigned long flags;
-	struct device_info *parentdevice = getparentdevice(dev, CORE_CACHE);
+	struct device_info *pdevinfo = getparentdevice(dev, CORE_CACHE);
 
 	/* release specified core id */
-	spin_lock_irqsave(&parentdevice->cache_owner_lock, flags);
+	spin_lock_irqsave(&pdevinfo->cache_owner_lock, flags);
 	if (dev->is_reserved) {
 		dev->cacheowner = NULL;
 		dev->is_reserved = 0;
@@ -118,8 +118,8 @@ static void release_core(struct cache_dev_t *dev)
 
 	dev->irq_received = 0;
 	dev->irq_status = 0;
-	spin_unlock_irqrestore(&parentdevice->cache_owner_lock, flags);
-	wake_up_interruptible_all(&parentdevice->cache_hw_queue);
+	spin_unlock_irqrestore(&pdevinfo->cache_owner_lock, flags);
+	wake_up_interruptible_all(&pdevinfo->cache_hw_queue);
 	trace_cache_release(dev->deviceidx);
 }
 
@@ -356,16 +356,16 @@ int cache_probe(dtbnode *pnode)
 	}
 
 	pccore->core_cfg.parentaddr = pnode->parentaddr;
-	add_cachenode(pnode->pdevice, pccore);
+	add_cachenode(pnode->pdevinfo, pccore);
 	return 0;
 }
 
-void hantrocache_remove(struct device_info *pdevice)
+void hantrocache_remove(struct device_info *pdevinfo)
 {
 	struct cache_dev_t *pccore, *pnext;
 	int k;
 
-	pccore = get_cachenodes(pdevice->deviceid, 0);
+	pccore = get_cachenodes(pdevinfo->deviceid, 0);
 	while (pccore) {
 		pnext = pccore->next;
 		writel(0, pccore->hwregs + 0x04); /* disable HW */
diff --git a/drivers/gpu/drm/hantro_driver/hantro_dec.c b/drivers/gpu/drm/hantro_driver/hantro_dec.c
index 54e4a0a16847..96e91fe65012 100644
--- a/drivers/gpu/drm/hantro_driver/hantro_dec.c
+++ b/drivers/gpu/drm/hantro_driver/hantro_dec.c
@@ -86,13 +86,13 @@ static struct hantrodec_t *get_core_ctrl(u32 id)
 	return pcore;
 }
 
-u32 hantrodec_readbandwidth(struct device_info *pdevice, int is_read_bw)
+u32 hantrodec_readbandwidth(struct device_info *pdevinfo, int is_read_bw)
 {
 	int i, devcnt = get_devicecount();
 	u32 bandwidth = 0;
 	struct hantrodec_t *dev;
 
-	if (!pdevice) {
+	if (!pdevinfo) {
 		for (i = 0; i < devcnt; i++) {
 			dev = get_decnode_bydeviceid(i, 0);
 			while (dev) {
@@ -109,7 +109,7 @@ u32 hantrodec_readbandwidth(struct device_info *pdevice, int is_read_bw)
 			}
 		}
 	} else {
-		dev = get_decnode(pdevice, 0);
+		dev = get_decnode(pdevinfo, 0);
 		while (dev) {
 			if (is_read_bw)
 				bandwidth +=
@@ -369,13 +369,13 @@ static int get_dec_core(long core, struct hantrodec_t *dev, struct file *filp,
 {
 	int success = 0;
 	unsigned long flags;
-	struct device_info *parentdevice = getparentdevice(dev, CORE_DEC);
+	struct device_info *pdevinfo = getparentdevice(dev, CORE_DEC);
 
 	PDEBUG("hantrodec: %s\n", __func__);
-	spin_lock_irqsave(&parentdevice->owner_lock, flags);
+	spin_lock_irqsave(&pdevinfo->owner_lock, flags);
 	if (core_has_format(dev->cfg, format) && !dev->dec_owner) {
 		dev->dec_owner = filp;
-		((struct device_info *)(dev->parentdevice))->dec_irq &=
+		((struct device_info *)(dev->pdevinfo))->dec_irq &=
 			~(1 << core);
 		success = 1;
 		/*
@@ -399,7 +399,7 @@ static int get_dec_core(long core, struct hantrodec_t *dev, struct file *filp,
 			dev->its_main_core_id->cfg = (1 << format);
 	}
 
-	spin_unlock_irqrestore(&parentdevice->owner_lock, flags);
+	spin_unlock_irqrestore(&pdevinfo->owner_lock, flags);
 	return success;
 }
 
@@ -435,20 +435,20 @@ static int get_dec_coreid(struct hantrodec_t *dev, struct file *filp,
 	long c = 0;
 	unsigned long flags;
 	int core_id = -1;
-	struct device_info *parentdevice = getparentdevice(dev, CORE_DEC);
+	struct device_info *pdevinfo = getparentdevice(dev, CORE_DEC);
 
 	PDEBUG("hantrodec: %s\n", __func__);
 	while (dev) {
 		/* a core that has format */
-		spin_lock_irqsave(&parentdevice->owner_lock, flags);
+		spin_lock_irqsave(&pdevinfo->owner_lock, flags);
 		if (core_has_format(dev->cfg_backup, format)) {
 			core_id = c;
-			spin_unlock_irqrestore(&parentdevice->owner_lock,
+			spin_unlock_irqrestore(&pdevinfo->owner_lock,
 					       flags);
 			break;
 		}
 
-		spin_unlock_irqrestore(&parentdevice->owner_lock, flags);
+		spin_unlock_irqrestore(&pdevinfo->owner_lock, flags);
 		dev = dev->next;
 		c++;
 	}
@@ -460,38 +460,38 @@ static long reserve_decoder(struct hantrodec_t *dev, struct file *filp,
 			    unsigned long format)
 {
 	long core = -1;
-	struct device_info *parentdevice = getparentdevice(dev, CORE_DEC);
+	struct device_info *pdevinfo = getparentdevice(dev, CORE_DEC);
 	struct hantrodec_t *reserved_core = NULL;
 
 	START_TIME;
 	/* reserve a core */
-	if (down_interruptible(&parentdevice->dec_core_sem)) {
+	if (down_interruptible(&pdevinfo->dec_core_sem)) {
 		core = -ERESTARTSYS;
 		goto out;
 	}
 
 	/* lock a core that has specific format*/
-	if (wait_event_interruptible(parentdevice->hw_queue,
+	if (wait_event_interruptible(pdevinfo->hw_queue,
 				     get_dec_core_any(&core, dev, filp,
 						      format) != 0)) {
 		core = -ERESTARTSYS;
 		goto out;
 	}
 
-	reserved_core = get_decnode(parentdevice, KCORE(core));
+	reserved_core = get_decnode(pdevinfo, KCORE(core));
 	if (!reserved_core) {
 		pr_err("Core not found");
 		goto out;
 	}
 
 	if (reserved_core->dev_clk &&
-	    parentdevice->thermal_data.clk_freq != reserved_core->clk_freq) {
+	    pdevinfo->thermal_data.clk_freq != reserved_core->clk_freq) {
 		PDEBUG("Reserve decoder:  setting to %ld for device %d, core %ld\n",
-		       parentdevice->thermal_data.clk_freq,
-		       parentdevice->deviceid, core);
+		       pdevinfo->thermal_data.clk_freq,
+		       pdevinfo->deviceid, core);
 		clk_set_rate(reserved_core->dev_clk,
-			     parentdevice->thermal_data.clk_freq);
-		reserved_core->clk_freq = parentdevice->thermal_data.clk_freq;
+			     pdevinfo->thermal_data.clk_freq);
+		reserved_core->clk_freq = pdevinfo->thermal_data.clk_freq;
 	}
 
 	reserved_core->perf_data.last_resv = sched_clock();
@@ -504,11 +504,11 @@ static void release_decoder(struct hantrodec_t *dev, long core)
 {
 	u32 status;
 	unsigned long flags;
-	struct device_info *parentdevice = getparentdevice(dev, CORE_DEC);
+	struct device_info *pdevinfo = getparentdevice(dev, CORE_DEC);
 	struct hantrodec_t *reserved_core = NULL;
 
 	PDEBUG("hantrodec: %s\n", __func__);
-	reserved_core = get_decnode(parentdevice, KCORE(core));
+	reserved_core = get_decnode(pdevinfo, KCORE(core));
 	reserved_core->perf_data.count++;
 	reserved_core->perf_data.totaltime +=
 		(sched_clock() - (reserved_core->perf_data.last_resv == 0 ?
@@ -525,7 +525,7 @@ static void release_decoder(struct hantrodec_t *dev, long core)
 			  (void *)(dev->hwregs + HANTRODEC_IRQ_STAT_DEC_OFF));
 	}
 
-	spin_lock_irqsave(&parentdevice->owner_lock, flags);
+	spin_lock_irqsave(&pdevinfo->owner_lock, flags);
 	/* If aux core released, revert main core's config back */
 	if (dev->its_main_core_id)
 		dev->its_main_core_id->cfg = dev->its_main_core_id->cfg_backup;
@@ -535,9 +535,9 @@ static void release_decoder(struct hantrodec_t *dev, long core)
 		dev->its_aux_core_id->cfg = dev->its_aux_core_id->cfg_backup;
 
 	dev->dec_owner = NULL;
-	spin_unlock_irqrestore(&parentdevice->owner_lock, flags);
-	up(&parentdevice->dec_core_sem);
-	wake_up_interruptible_all(&parentdevice->hw_queue);
+	spin_unlock_irqrestore(&pdevinfo->owner_lock, flags);
+	up(&pdevinfo->dec_core_sem);
+	wake_up_interruptible_all(&pdevinfo->hw_queue);
 	trace_dec_release(dev->deviceidx, KCORE(core));
 }
 
@@ -545,24 +545,24 @@ static long reserve_post_processor(struct hantrodec_t *dev, struct file *filp)
 {
 	unsigned long flags;
 	long core = 0;
-	struct device_info *parentdevice = getparentdevice(dev, CORE_DEC);
+	struct device_info *pdevinfo = getparentdevice(dev, CORE_DEC);
 
 	/* single core PP only */
-	if (down_interruptible(&parentdevice->pp_core_sem))
+	if (down_interruptible(&pdevinfo->pp_core_sem))
 		return -ERESTARTSYS;
 
-	spin_lock_irqsave(&parentdevice->owner_lock, flags);
+	spin_lock_irqsave(&pdevinfo->owner_lock, flags);
 	if (dev)
 		dev->pp_owner = filp;
 
-	spin_unlock_irqrestore(&parentdevice->owner_lock, flags);
+	spin_unlock_irqrestore(&pdevinfo->owner_lock, flags);
 	return core;
 }
 
 static void release_post_processor(struct hantrodec_t *dev, long core)
 {
 	unsigned long flags;
-	struct device_info *parentdevice = getparentdevice(dev, CORE_DEC);
+	struct device_info *pdevinfo = getparentdevice(dev, CORE_DEC);
 
 	u32 status = ioread32((void *)(dev->hwregs + HANTRO_IRQ_STAT_PP_OFF));
 
@@ -576,10 +576,10 @@ static void release_post_processor(struct hantrodec_t *dev, long core)
 		iowrite32(0x10, (void *)(dev->hwregs + HANTRO_IRQ_STAT_PP_OFF));
 	}
 
-	spin_lock_irqsave(&parentdevice->owner_lock, flags);
+	spin_lock_irqsave(&pdevinfo->owner_lock, flags);
 	dev->pp_owner = NULL;
-	spin_unlock_irqrestore(&parentdevice->owner_lock, flags);
-	up(&parentdevice->pp_core_sem);
+	spin_unlock_irqrestore(&pdevinfo->owner_lock, flags);
+	up(&pdevinfo->pp_core_sem);
 }
 
 static long dec_flush_regs(struct hantrodec_t *dev, struct core_desc *core)
@@ -624,18 +624,18 @@ static int check_dec_irq(struct hantrodec_t *dev, int id)
 {
 	unsigned long flags;
 	int rdy = 0;
-	struct device_info *parentdevice = getparentdevice(dev, CORE_DEC);
+	struct device_info *pdevinfo = getparentdevice(dev, CORE_DEC);
 	const u32 irq_mask = (1 << id);
 
-	spin_lock_irqsave(&parentdevice->owner_lock, flags);
-	if (parentdevice->dec_irq & irq_mask) {
+	spin_lock_irqsave(&pdevinfo->owner_lock, flags);
+	if (pdevinfo->dec_irq & irq_mask) {
 		/* reset the wait condition(s) */
 		PDEBUG("hantrodec: %s\n", __func__);
-		parentdevice->dec_irq &= ~irq_mask;
+		pdevinfo->dec_irq &= ~irq_mask;
 		rdy = 1;
 	}
 
-	spin_unlock_irqrestore(&parentdevice->owner_lock, flags);
+	spin_unlock_irqrestore(&pdevinfo->owner_lock, flags);
 	return rdy;
 }
 
@@ -644,10 +644,10 @@ static long wait_dec_ready_and_refresh_regs(struct hantrodec_t *dev,
 {
 	u32 id = KCORE(core->id);
 	long ret;
-	struct device_info *parentdevice = getparentdevice(dev, CORE_DEC);
+	struct device_info *pdevinfo = getparentdevice(dev, CORE_DEC);
 
 	PDEBUG("wait_event_interruptible DEC[%d]\n", id);
-	ret = wait_event_interruptible_timeout(parentdevice->dec_wait_queue,
+	ret = wait_event_interruptible_timeout(pdevinfo->dec_wait_queue,
 					       check_dec_irq(dev, id),
 					       msecs_to_jiffies(10));
 	if (ret == -ERESTARTSYS) {
@@ -777,17 +777,17 @@ static int check_pp_irq(struct hantrodec_t *dev, int id)
 {
 	unsigned long flags;
 	int rdy = 0;
-	struct device_info *parentdevice = getparentdevice(dev, CORE_DEC);
+	struct device_info *pdevinfo = getparentdevice(dev, CORE_DEC);
 	const u32 irq_mask = (1 << id);
 
-	spin_lock_irqsave(&parentdevice->owner_lock, flags);
-	if (parentdevice->pp_irq & irq_mask) {
+	spin_lock_irqsave(&pdevinfo->owner_lock, flags);
+	if (pdevinfo->pp_irq & irq_mask) {
 		/* reset the wait condition(s) */
-		parentdevice->pp_irq &= ~irq_mask;
+		pdevinfo->pp_irq &= ~irq_mask;
 		rdy = 1;
 	}
 
-	spin_unlock_irqrestore(&parentdevice->owner_lock, flags);
+	spin_unlock_irqrestore(&pdevinfo->owner_lock, flags);
 	return rdy;
 }
 
@@ -795,10 +795,10 @@ static long wait_pp_ready_and_refresh_regs(struct hantrodec_t *dev,
 					   struct core_desc *core)
 {
 	u32 id = core->id;
-	struct device_info *parentdevice = getparentdevice(dev, CORE_DEC);
+	struct device_info *pdevinfo = getparentdevice(dev, CORE_DEC);
 
 	PDEBUG("wait_event_interruptible PP[%d]\n", id);
-	if (wait_event_interruptible(parentdevice->pp_wait_queue,
+	if (wait_event_interruptible(pdevinfo->pp_wait_queue,
 				     check_pp_irq(dev, id))) {
 		pr_err("PP[%d]  failed to wait_event_interruptible interrupted\n",
 		       id);
@@ -815,31 +815,31 @@ static int check_core_irq(struct hantrodec_t *dev, const struct file *filp,
 {
 	unsigned long flags;
 	int rdy = 0, n = 0;
-	struct device_info *parentdevice = getparentdevice(dev, CORE_DEC);
+	struct device_info *pdevinfo = getparentdevice(dev, CORE_DEC);
 
 	while (dev) {
 		u32 irq_mask = (1 << n);
 
-		spin_lock_irqsave(&parentdevice->owner_lock, flags);
-		if (parentdevice->dec_irq & irq_mask) {
+		spin_lock_irqsave(&pdevinfo->owner_lock, flags);
+		if (pdevinfo->dec_irq & irq_mask) {
 			if (*id == n) {
 				/* we have an IRQ for our client */
 				/* reset the wait condition(s) */
-				parentdevice->dec_irq &= ~irq_mask;
+				pdevinfo->dec_irq &= ~irq_mask;
 				/* signal ready Core no. for our client */
 				rdy = 1;
-				spin_unlock_irqrestore(&parentdevice->owner_lock, flags);
+				spin_unlock_irqrestore(&pdevinfo->owner_lock, flags);
 				break;
 			} else if (!dev->dec_owner) {
 				/* zombie IRQ */
 				pr_info("IRQ on Core[%d], but no owner!!!\n",
 					n);
 				/* reset the wait condition(s) */
-				parentdevice->dec_irq &= ~irq_mask;
+				pdevinfo->dec_irq &= ~irq_mask;
 			}
 		}
 
-		spin_unlock_irqrestore(&parentdevice->owner_lock, flags);
+		spin_unlock_irqrestore(&pdevinfo->owner_lock, flags);
 		n++; /* next Core */
 		dev = dev->next;
 	}
@@ -850,11 +850,11 @@ static int check_core_irq(struct hantrodec_t *dev, const struct file *filp,
 static long wait_core_ready(struct hantrodec_t *dev, const struct file *filp,
 			    u32 *id)
 {
-	struct device_info *parentdevice = getparentdevice(dev, CORE_DEC);
+	struct device_info *pdevinfo = getparentdevice(dev, CORE_DEC);
 
 	PDEBUG("wait_event_interruptible CORE\n");
 
-	if (wait_event_interruptible(parentdevice->dec_wait_queue,
+	if (wait_event_interruptible(pdevinfo->dec_wait_queue,
 				     check_core_irq(dev, filp, id))) {
 		pr_err("CORE  failed to wait_event_interruptible interrupted\n");
 		return -ERESTARTSYS;
@@ -1177,7 +1177,7 @@ long hantrodec_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 		return 0;
 	}
 	case _IOC_NR(HANTRODEC_DEBUG_STATUS): {
-		struct device_info *parentdevice;
+		struct device_info *pdevinfo;
 
 		PDEBUG("hantrodec: IRQs received/sent2user = %d / %d\n",
 		       atomic_read(&irq_rx), atomic_read(&irq_tx));
@@ -1187,11 +1187,11 @@ long hantrodec_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 			if (!pcore)
 				continue;
 
-			parentdevice = getparentdevice(pcore, CORE_DEC);
+			pdevinfo = getparentdevice(pcore, CORE_DEC);
 			PDEBUG("hantrodec: device %d dec_irq     = 0x%08x\n", i,
-			       parentdevice->dec_irq);
+			       pdevinfo->dec_irq);
 			PDEBUG("hantrodec: device %d pp_irq      = 0x%08x\n", i,
-			       parentdevice->pp_irq);
+			       pdevinfo->pp_irq);
 			id = 0;
 			while (pcore) {
 				PDEBUG("hantrodec: device %d dec_core[%i] %s\n",
@@ -1370,7 +1370,7 @@ static int init_dec_clock(struct hantrodec_t *pcore, dtbnode *pnode)
 	if (strlen(pnode->clock_name) == 0)
 		return 0;
 
-	pcore->dev_clk = clk_get(pnode->pdevice->dev, pnode->clock_name);
+	pcore->dev_clk = clk_get(pnode->pdevinfo->dev, pnode->clock_name);
 	if (IS_ERR(pcore->dev_clk) || !pcore->dev_clk) {
 		pr_err("%s: clock %s not found. err = %ld", __func__,
 		       pnode->clock_name, PTR_ERR(pcore->dev_clk));
@@ -1379,7 +1379,7 @@ static int init_dec_clock(struct hantrodec_t *pcore, dtbnode *pnode)
 	}
 
 	clk_prepare_enable(pcore->dev_clk);
-	pcore->clk_freq = pnode->pdevice->thermal_data.clk_freq;
+	pcore->clk_freq = pnode->pdevinfo->thermal_data.clk_freq;
 	clk_set_rate(pcore->dev_clk, pcore->clk_freq);
 	return 0;
 }
@@ -1453,20 +1453,20 @@ int hantrodec_probe(dtbnode *pnode)
 	}
 
 	init_dec_clock(pcore, pnode);
-	add_decnode(pnode->pdevice, pcore);
+	add_decnode(pnode->pdevinfo, pcore);
 	if (auxcore)
-		add_decnode(pnode->pdevice, auxcore);
+		add_decnode(pnode->pdevinfo, auxcore);
 
 	return 0;
 }
 
-void hantrodec_remove(struct device_info *pdevice)
+void hantrodec_remove(struct device_info *pdevinfo)
 {
 	struct hantrodec_t *dev, *next;
 	int i;
 
 	/* free the IRQ */
-	dev = get_decnode(pdevice, 0);
+	dev = get_decnode(pdevinfo, 0);
 	while (dev) {
 		/* reset hardware */
 		disable_dec_clock(dev);
@@ -1651,10 +1651,10 @@ static irqreturn_t hantrodec_isr(int irq, void *dev_id)
 	u8 *hwregs;
 	struct hantrodec_t *dev = (struct hantrodec_t *)dev_id;
 	u32 irq_status_dec;
-	struct device_info *parentdevice = getparentdevice(dev, CORE_DEC);
+	struct device_info *pdevinfo = getparentdevice(dev, CORE_DEC);
 
-	dev = getfirst_decnodes(parentdevice);
-	spin_lock_irqsave(&parentdevice->owner_lock, flags);
+	dev = getfirst_decnodes(pdevinfo);
+	spin_lock_irqsave(&pdevinfo->owner_lock, flags);
 	while (dev) {
 		u8 *hwregs = dev->hwregs;
 
@@ -1671,9 +1671,9 @@ static irqreturn_t hantrodec_isr(int irq, void *dev_id)
 
 			atomic_inc(&irq_rx);
 
-			parentdevice->dec_irq |= (1 << i);
+			pdevinfo->dec_irq |= (1 << i);
 
-			wake_up_interruptible_all(&parentdevice->dec_wait_queue);
+			wake_up_interruptible_all(&pdevinfo->dec_wait_queue);
 			handled++;
 		}
 
@@ -1681,7 +1681,7 @@ static irqreturn_t hantrodec_isr(int irq, void *dev_id)
 		dev = dev->next;
 	}
 
-	spin_unlock_irqrestore(&parentdevice->owner_lock, flags);
+	spin_unlock_irqrestore(&pdevinfo->owner_lock, flags);
 	if (!handled)
 		PDEBUG("IRQ received, but not hantrodec's!\n");
 
diff --git a/drivers/gpu/drm/hantro_driver/hantro_dec400.c b/drivers/gpu/drm/hantro_driver/hantro_dec400.c
index 6cbb38fa8df8..16139167dd59 100644
--- a/drivers/gpu/drm/hantro_driver/hantro_dec400.c
+++ b/drivers/gpu/drm/hantro_driver/hantro_dec400.c
@@ -242,7 +242,7 @@ int hantro_dec400_probe(dtbnode *pnode)
 	}
 
 	dec400_reset_asic(pdec400);
-	add_dec400node(pnode->pdevice, pdec400);
+	add_dec400node(pnode->pdevinfo, pdec400);
 	pr_info("hantrodec400: HW at base <0x%llx>\n",
 		pdec400->core_cfg.dec400corebase);
 	return 0;
diff --git a/drivers/gpu/drm/hantro_driver/hantro_device.h b/drivers/gpu/drm/hantro_driver/hantro_device.h
index ec0911606bd2..a793a40b69fa 100644
--- a/drivers/gpu/drm/hantro_driver/hantro_device.h
+++ b/drivers/gpu/drm/hantro_driver/hantro_device.h
@@ -67,7 +67,7 @@ struct cache_dev_t {
 	device_coretype parenttype;
 	u32 parentid; /* parent codec core's core_id */
 	void *parentcore; /* either struct hantroenc_t or struct hantrodec_t, or device itself */
-	void *parentdevice;
+	struct device_info *pdevinfo;
 	int deviceidx;
 	struct cache_dev_t *next;
 };
@@ -90,7 +90,7 @@ struct dec400_t {
 	device_coretype parenttype;
 	u32 parentid; /* parent codec core's core_id */
 	void *parentcore; /* either struct hantroenc_t or struct hantrodec_t, or device itself */
-	void *parentdevice;
+	struct device_info *pdevinfo;
 	struct dec400_t *next;
 };
 
@@ -123,7 +123,7 @@ struct hantroenc_t {
 	struct fasync_struct *async_queue;
 	int irqlist[4];
 	char irq_name[4][32];
-	void *parentdevice;
+	struct device_info *pdevinfo;
 	int deviceidx;
 	performance_data perf_data;
 	struct hantroenc_t *next;
@@ -167,7 +167,7 @@ struct hantrodec_t {
 	unsigned long clk_freq;
 	struct file *dec_owner;
 	struct file *pp_owner;
-	void *parentdevice;
+	struct device_info *pdevinfo;
 	u32 deviceidx;
 	performance_data perf_data;
 	struct hantrodec_t *next;
@@ -262,10 +262,10 @@ struct device_info {
 
 struct device_info *getdevicenode(u32 deviceid);
 int get_devicecorenum(u32 deviceindex, device_coretype type);
-struct hantrodec_t *get_decnode(struct device_info *pdevice, u32 nodeidx);
+struct hantrodec_t *get_decnode(struct device_info *pdevinfo, u32 nodeidx);
 struct hantrodec_t *get_decnode_bydeviceid(u32 deviceindex, u32 nodeidx);
-struct hantrodec_t *getfirst_decnodes(struct device_info *pdevice);
-struct hantroenc_t *get_encnode(struct device_info *pdevice, u32 nodeidx);
+struct hantrodec_t *getfirst_decnodes(struct device_info *pdevinfo);
+struct hantroenc_t *get_encnode(struct device_info *pdevinfo, u32 nodeidx);
 struct hantroenc_t *get_encnode_bydeviceid(u32 deviceid, u32 nodeidx);
 struct cache_dev_t *get_cachenodes(u32 deviceid, u32 nodeidx);
 struct cache_dev_t *get_cachenodebytype(u32 deviceid, u32 parenttype,
@@ -273,10 +273,10 @@ struct cache_dev_t *get_cachenodebytype(u32 deviceid, u32 parenttype,
 struct dec400_t *get_dec400nodes(u32 deviceid, u32 nodeidx);
 struct dec400_t *get_dec400nodebytype(u32 deviceid, u32 parenttype,
 				      u32 parentnodeidx);
-int add_decnode(struct device_info *pdevice, struct hantrodec_t *deccore);
-int add_encnode(struct device_info *pdevice, struct hantroenc_t *enccore);
-int add_dec400node(struct device_info *splice, struct dec400_t *dec400core);
-int add_cachenode(struct device_info *splice, struct cache_dev_t *cachecore);
+int add_decnode(struct device_info *pdevinfo, struct hantrodec_t *deccore);
+int add_encnode(struct device_info *pdevinfo, struct hantroenc_t *enccore);
+int add_dec400node(struct device_info *pdevinfo, struct dec400_t *dec400core);
+int add_cachenode(struct device_info *pdevinfo, struct cache_dev_t *cachecore);
 int get_devicecount(void);
 struct device_info *getparentdevice(void *node, int type);
 int device_remove(void);
diff --git a/drivers/gpu/drm/hantro_driver/hantro_devicemgr.c b/drivers/gpu/drm/hantro_driver/hantro_devicemgr.c
index e9f4a7bffd87..83cb368cd025 100644
--- a/drivers/gpu/drm/hantro_driver/hantro_devicemgr.c
+++ b/drivers/gpu/drm/hantro_driver/hantro_devicemgr.c
@@ -70,10 +70,10 @@ struct hantrodec_t *get_decnode_bydeviceid(u32 deviceid, u32 nodeidx)
 	return p;
 }
 
-struct hantrodec_t *getfirst_decnodes(struct device_info *pdevice)
+struct hantrodec_t *getfirst_decnodes(struct device_info *pdevinfo)
 {
-	if (pdevice) //atomic_read(&devicenum))
-		return pdevice->dechdr;
+	if (pdevinfo) //atomic_read(&devicenum))
+		return pdevinfo->dechdr;
 
 	return NULL;
 }
@@ -208,16 +208,16 @@ struct dec400_t *get_dec400nodebytype(u32 deviceid, u32 parenttype,
 	return p;
 }
 
-int add_decnode(struct device_info *pdevice, struct hantrodec_t *deccore)
+int add_decnode(struct device_info *pdevinfo, struct hantrodec_t *deccore)
 {
 	struct hantrodec_t *pdec;
 
-	if (!pdevice)
+	if (!pdevinfo)
 		return -EINVAL;
 
-	pdec = pdevice->dechdr;
+	pdec = pdevinfo->dechdr;
 	if (!pdec) {
-		pdevice->dechdr = deccore;
+		pdevinfo->dechdr = deccore;
 	} else {
 		while (pdec->next)
 			pdec = pdec->next;
@@ -226,26 +226,26 @@ int add_decnode(struct device_info *pdevice, struct hantrodec_t *deccore)
 	}
 
 	deccore->next = NULL;
-	pdevice->deccore_num++;
-	deccore->core_id = pdevice->deccore_num - 1;
-	deccore->deviceidx = pdevice->deviceid;
-	deccore->parentdevice = pdevice;
-	pdevice->config |= CONFIG_HWDEC;
+	pdevinfo->deccore_num++;
+	deccore->core_id = pdevinfo->deccore_num - 1;
+	deccore->deviceidx = pdevinfo->deviceid;
+	deccore->pdevinfo = pdevinfo;
+	pdevinfo->config |= CONFIG_HWDEC;
 
-	sema_init(&pdevice->dec_core_sem, pdevice->deccore_num);
+	sema_init(&pdevinfo->dec_core_sem, pdevinfo->deccore_num);
 	return 0;
 }
 
-int add_encnode(struct device_info *pdevice, struct hantroenc_t *enccore)
+int add_encnode(struct device_info *pdevinfo, struct hantroenc_t *enccore)
 {
 	struct hantroenc_t *penc;
 
-	if (!pdevice)
+	if (!pdevinfo)
 		return -EINVAL;
 
-	penc = pdevice->enchdr;
+	penc = pdevinfo->enchdr;
 	if (!penc) {
-		pdevice->enchdr = enccore;
+		pdevinfo->enchdr = enccore;
 	} else {
 		while (penc->next)
 			penc = penc->next;
@@ -254,26 +254,26 @@ int add_encnode(struct device_info *pdevice, struct hantroenc_t *enccore)
 	}
 
 	enccore->next = NULL;
-	pdevice->enccore_num++;
-	enccore->core_id = pdevice->enccore_num - 1;
-	enccore->core_cfg.deviceidx = pdevice->deviceid;
-	enccore->parentdevice = pdevice;
-	pdevice->config |= CONFIG_HWENC;
+	pdevinfo->enccore_num++;
+	enccore->core_id = pdevinfo->enccore_num - 1;
+	enccore->core_cfg.deviceidx = pdevinfo->deviceid;
+	enccore->pdevinfo = pdevinfo;
+	pdevinfo->config |= CONFIG_HWENC;
 	return 0;
 }
 
-int add_dec400node(struct device_info *pdevice, struct dec400_t *dec400core)
+int add_dec400node(struct device_info *pdevinfo, struct dec400_t *dec400core)
 {
 	struct dec400_t *pdec400;
 	struct hantrodec_t *pdec;
 	struct hantroenc_t *penc;
 
-	if (!pdevice)
+	if (!pdevinfo)
 		return -EINVAL;
 
-	pdec400 = pdevice->dec400hdr;
+	pdec400 = pdevinfo->dec400hdr;
 	if (!pdec400) {
-		pdevice->dec400hdr = dec400core;
+		pdevinfo->dec400hdr = dec400core;
 	} else {
 		while (pdec400->next)
 			pdec400 = pdec400->next;
@@ -282,22 +282,22 @@ int add_dec400node(struct device_info *pdevice, struct dec400_t *dec400core)
 	}
 
 	dec400core->next = NULL;
-	pdevice->dec400core_num++;
-	dec400core->core_id = pdevice->dec400core_num - 1;
-	pdevice->config |= CONFIG_DEC400;
-	dec400core->core_cfg.deviceidx = pdevice->deviceid;
+	pdevinfo->dec400core_num++;
+	dec400core->core_id = pdevinfo->dec400core_num - 1;
+	pdevinfo->config |= CONFIG_DEC400;
+	dec400core->core_cfg.deviceidx = pdevinfo->deviceid;
 	/* set default */
-	dec400core->parentcore = pdevice;
+	dec400core->parentcore = pdevinfo;
 	dec400core->parentid = CORE_DEVICE;
-	dec400core->parentdevice = pdevice;
+	dec400core->pdevinfo = pdevinfo;
 
-	if (dec400core->core_cfg.parentaddr == pdevice->rsvmem_addr) {
-		dec400core->parentcore = pdevice;
+	if (dec400core->core_cfg.parentaddr == pdevinfo->rsvmem_addr) {
+		dec400core->parentcore = pdevinfo;
 		dec400core->parenttype = CORE_DEVICE;
 		goto end;
 	}
 
-	penc = pdevice->enchdr;
+	penc = pdevinfo->enchdr;
 	while (penc) {
 		if ((unsigned long long)penc->core_cfg.base_addr ==
 		    dec400core->core_cfg.parentaddr) {
@@ -310,7 +310,7 @@ int add_dec400node(struct device_info *pdevice, struct dec400_t *dec400core)
 		penc = penc->next;
 	}
 
-	pdec = pdevice->dechdr;
+	pdec = pdevinfo->dechdr;
 	while (pdec) {
 		if ((unsigned long long)pdec->multicorebase ==
 		    dec400core->core_cfg.parentaddr) {
@@ -327,18 +327,18 @@ int add_dec400node(struct device_info *pdevice, struct dec400_t *dec400core)
 	return 0;
 }
 
-int add_cachenode(struct device_info *pdevice, struct cache_dev_t *cachecore)
+int add_cachenode(struct device_info *pdevinfo, struct cache_dev_t *cachecore)
 {
 	struct cache_dev_t *pcache;
 	struct hantrodec_t *pdec;
 	struct hantroenc_t *penc;
 
-	if (!pdevice)
+	if (!pdevinfo)
 		return -ENODEV;
 
-	pcache = pdevice->cachehdr;
+	pcache = pdevinfo->cachehdr;
 	if (!pcache) {
-		pdevice->cachehdr = cachecore;
+		pdevinfo->cachehdr = cachecore;
 	} else {
 		while (pcache->next)
 			pcache = pcache->next;
@@ -347,19 +347,19 @@ int add_cachenode(struct device_info *pdevice, struct cache_dev_t *cachecore)
 	}
 
 	cachecore->next = NULL;
-	pdevice->cachecore_num++;
-	cachecore->core_id = pdevice->cachecore_num - 1;
-	cachecore->core_cfg.deviceidx = pdevice->deviceid;
-	pdevice->config |= CONFIG_L2CACHE;
+	pdevinfo->cachecore_num++;
+	cachecore->core_id = pdevinfo->cachecore_num - 1;
+	cachecore->core_cfg.deviceidx = pdevinfo->deviceid;
+	pdevinfo->config |= CONFIG_L2CACHE;
 
 	/* set default */
-	cachecore->parentcore = pdevice;
-	cachecore->parentid = pdevice->deviceid;
+	cachecore->parentcore = pdevinfo;
+	cachecore->parentid = pdevinfo->deviceid;
 	cachecore->parenttype = CORE_DEVICE;
-	cachecore->parentdevice = pdevice;
+	cachecore->pdevinfo = pdevinfo;
 
 	if (cachecore->core_cfg.client == VC8000E) {
-		penc = pdevice->enchdr;
+		penc = pdevinfo->enchdr;
 		while (penc) {
 			if ((unsigned long long)penc->core_cfg.base_addr ==
 			    cachecore->core_cfg.parentaddr) {
@@ -372,7 +372,7 @@ int add_cachenode(struct device_info *pdevice, struct cache_dev_t *cachecore)
 			penc = penc->next;
 		}
 	} else {
-		pdec = pdevice->dechdr;
+		pdec = pdevinfo->dechdr;
 		while (pdec) {
 			if ((unsigned long long)pdec->multicorebase ==
 			    cachecore->core_cfg.parentaddr) {
@@ -401,19 +401,19 @@ struct device_info *getparentdevice(void *node, int type)
 	switch (type) {
 	case CORE_CACHE:
 		pdevice = (struct device_info *)((struct cache_dev_t *)node)
-				  ->parentdevice;
+				  ->pdevinfo;
 		break;
 	case CORE_DEC:
 		pdevice = (struct device_info *)((struct hantrodec_t *)node)
-				  ->parentdevice;
+				  ->pdevinfo;
 		break;
 	case CORE_ENC:
 		pdevice = (struct device_info *)((struct hantroenc_t *)node)
-				  ->parentdevice;
+				  ->pdevinfo;
 		break;
 	case CORE_DEC400:
 		pdevice = (struct device_info *)((struct dec400_t *)node)
-				  ->parentdevice;
+				  ->pdevinfo;
 		break;
 	default:
 		break;
@@ -435,7 +435,7 @@ void device_printdebug(void)
 {
 	struct hantrodec_t *pdec, *pdec2;
 	struct hantroenc_t *penc, *penc2;
-	struct device_info *pdevice;
+	struct device_info *pdevinfo;
 	struct cache_dev_t *pcache, *pcache2;
 	struct dec400_t *pdec400, *pdec400_2;
 	int i, n = get_devicecount(), k;
@@ -593,10 +593,10 @@ void device_printdebug(void)
 						pdec->multicorebase);
 					break;
 				case CORE_DEVICE:
-					pdevice = (struct device_info *)
+					pdevinfo = (struct device_info *)
 							  pdec400->parentcore;
 					pr_info("parent device addr %llx",
-						pdevice->rsvmem_addr);
+						pdevinfo->rsvmem_addr);
 					break;
 				default:
 					pr_info("error: dec400 parent type unknown");
diff --git a/drivers/gpu/drm/hantro_driver/hantro_drm.c b/drivers/gpu/drm/hantro_driver/hantro_drm.c
index cf5166bef4e0..38cfc2946e43 100644
--- a/drivers/gpu/drm/hantro_driver/hantro_drm.c
+++ b/drivers/gpu/drm/hantro_driver/hantro_drm.c
@@ -15,29 +15,29 @@
 extern const struct dma_buf_ops hantro_dmabuf_ops;
 static struct drm_gem_object_funcs hantro_gem_object_funcs;
 
-int hantro_recordmem(struct device_info *pdevice, void *obj, int size)
+int hantro_recordmem(struct device_info *pdevinfo, void *obj, int size)
 {
 	int ret;
 
-	mutex_lock(&pdevice->alloc_mutex);
-	ret = idr_alloc(&pdevice->allocations, obj, 1, 0, GFP_KERNEL);
-	mutex_unlock(&pdevice->alloc_mutex);
+	mutex_lock(&pdevinfo->alloc_mutex);
+	ret = idr_alloc(&pdevinfo->allocations, obj, 1, 0, GFP_KERNEL);
+	mutex_unlock(&pdevinfo->alloc_mutex);
 	return (ret > 0 ? 0 : -ENOMEM);
 }
 
-void hantro_unrecordmem(struct device_info *pdevice, void *obj)
+void hantro_unrecordmem(struct device_info *pdevinfo, void *obj)
 {
 	int id;
 	void *cma_obj;
 
-	mutex_lock(&pdevice->alloc_mutex);
-	idr_for_each_entry(&pdevice->allocations, cma_obj, id) {
+	mutex_lock(&pdevinfo->alloc_mutex);
+	idr_for_each_entry(&pdevinfo->allocations, cma_obj, id) {
 		if (cma_obj == obj) {
-			idr_remove(&pdevice->allocations, id);
+			idr_remove(&pdevinfo->allocations, id);
 			break;
 		}
 	}
-	mutex_unlock(&pdevice->alloc_mutex);
+	mutex_unlock(&pdevinfo->alloc_mutex);
 }
 
 static void hantro_drm_fb_destroy(struct drm_framebuffer *fb)
@@ -85,14 +85,14 @@ static int hantro_gem_dumb_create_internal(struct drm_file *file_priv,
 {
 	struct drm_gem_hantro_object *cma_obj = NULL;
 	struct drm_gem_object *obj;
-	struct device_info *pdevice;
+	struct device_info *pdevinfo;
 	int min_pitch = DIV_ROUND_UP(args->width * args->bpp, 8);
 	unsigned int deviceidx = (args->flags & 0xf);
 	unsigned int region = (args->flags >> 0x8) & 0xf;
 	int ret = 0;
 
-	pdevice = get_deviceinfo(deviceidx);
-	if (!pdevice)
+	pdevinfo = get_deviceinfo(deviceidx);
+	if (!pdevinfo)
 		return -EINVAL;
 
 	if (mutex_lock_interruptible(&dev->struct_mutex))
@@ -113,13 +113,13 @@ static int hantro_gem_dumb_create_internal(struct drm_file *file_priv,
 	obj->funcs = &hantro_gem_object_funcs;
 	cma_obj->dmapriv.self = cma_obj;
 	cma_obj->num_pages = args->size >> PAGE_SHIFT;
-	cma_obj->pdevice = pdevice;
+	cma_obj->pdevinfo = pdevinfo;
 
-	if (region == CODEC_RESERVED && pdevice->codec_rsvmem)
-		cma_obj->memdev = pdevice->codec_rsvmem;
+	if (region == CODEC_RESERVED && pdevinfo->codec_rsvmem)
+		cma_obj->memdev = pdevinfo->codec_rsvmem;
 
 	if (!cma_obj->memdev) {
-		cma_obj->memdev = pdevice->dev;
+		cma_obj->memdev = pdevinfo->dev;
 		region = PIXEL_CMA;
 	}
 
@@ -127,7 +127,7 @@ static int hantro_gem_dumb_create_internal(struct drm_file *file_priv,
 		dma_alloc_coherent(cma_obj->memdev, args->size, &cma_obj->paddr,
 				   GFP_KERNEL | GFP_DMA);
 	if (region == CODEC_RESERVED && !cma_obj->vaddr) {
-		cma_obj->memdev = pdevice->dev;
+		cma_obj->memdev = pdevinfo->dev;
 		region = PIXEL_CMA;
 		cma_obj->vaddr = dma_alloc_coherent(cma_obj->memdev, args->size,
 						    &cma_obj->paddr,
@@ -137,10 +137,10 @@ static int hantro_gem_dumb_create_internal(struct drm_file *file_priv,
 	if (!cma_obj->vaddr) {
 		int used_mem[2] = { 0 }, alloc_count[2] = { 0 };
 
-		mem_usage_internal(deviceidx, pdevice->dev, &used_mem[0],
+		mem_usage_internal(deviceidx, pdevinfo->dev, &used_mem[0],
 				   &alloc_count[0], NULL);
-		if (pdevice->codec_rsvmem)
-			mem_usage_internal(deviceidx, pdevice->codec_rsvmem,
+		if (pdevinfo->codec_rsvmem)
+			mem_usage_internal(deviceidx, pdevinfo->codec_rsvmem,
 					   &used_mem[1], &alloc_count[1], NULL);
 
 		__trace_hantro_err("Device %d out of memory; Requested region = %d;  CMA 0: %dK in %d allocations\n CMA 1: %dK in %d allocations",
@@ -167,7 +167,7 @@ static int hantro_gem_dumb_create_internal(struct drm_file *file_priv,
 	cma_obj->dmapriv.self = cma_obj;
 	cma_obj->file_priv = file_priv;
 
-	hantro_recordmem(pdevice, cma_obj, args->size);
+	hantro_recordmem(pdevinfo, cma_obj, args->size);
 	drm_gem_object_put(obj);
 	trace_gem_handle_create(args->handle);
 	trace_hantro_cma_alloc(deviceidx, region, (void *)cma_obj->paddr, args->handle,
@@ -364,7 +364,7 @@ static int hantro_gem_prime_mmap(struct drm_gem_object *obj,
 static void hantro_gem_free_object(struct drm_gem_object *gem_obj)
 {
 	struct drm_gem_hantro_object *cma_obj;
-	struct device_info *pdevice;
+	struct device_info *pdevinfo;
 	/*
 	 * dma buf imported from others,
 	 * release data structures allocated by ourselves
@@ -387,14 +387,14 @@ static void hantro_gem_free_object(struct drm_gem_object *gem_obj)
 
 		drm_prime_gem_destroy(gem_obj, cma_obj->sgt);
 	} else if (cma_obj->vaddr) {
-		pdevice = cma_obj->pdevice;
-		if (!pdevice)
+		pdevinfo = cma_obj->pdevinfo;
+		if (!pdevinfo)
 			return;
 
 		dma_free_coherent(cma_obj->memdev, cma_obj->base.size,
 				  cma_obj->vaddr, cma_obj->paddr);
-		hantro_unrecordmem(cma_obj->pdevice, cma_obj);
-		trace_hantro_cma_free(pdevice->deviceid, (void *)cma_obj->paddr,
+		hantro_unrecordmem(cma_obj->pdevinfo, cma_obj);
+		trace_hantro_cma_free(pdevinfo->deviceid, (void *)cma_obj->paddr,
 				      cma_obj->handle);
 	}
 
@@ -466,13 +466,13 @@ static int hantro_map_vaddr(struct drm_device *dev, void *data,
 static int hantro_get_hwcfg(struct drm_device *dev, void *data,
 			    struct drm_file *file_priv)
 {
-	struct device_info *pdevice;
+	struct device_info *pdevinfo;
 	u32 config = 0;
 	int i;
 
 	for (i = 0; i < get_devicecount(); i++) {
-		pdevice = get_deviceinfo(i);
-		config |= pdevice->config;
+		pdevinfo = get_deviceinfo(i);
+		config |= pdevinfo->config;
 	}
 
 	return config;
@@ -1433,7 +1433,7 @@ static int hantro_mmap(struct file *filp, struct vm_area_struct *vma)
 	int sgtidx = 0;
 	struct scatterlist *pscatter = NULL;
 	struct page **pages = NULL;
-	struct device_info *pdevice;
+	struct device_info *pdevinfo;
 	struct device *dev;
 
 	if (mutex_lock_interruptible(&hantro_drm.drm_dev->struct_mutex))
@@ -1463,8 +1463,8 @@ static int hantro_mmap(struct file *filp, struct vm_area_struct *vma)
 	}
 
 	if ((cma_obj->flag & HANTRO_GEM_FLAG_IMPORT) == 0) {
-		pdevice = cma_obj->pdevice;
-		if (!pdevice) {
+		pdevinfo = cma_obj->pdevinfo;
+		if (!pdevinfo) {
 			mutex_unlock(&hantro_drm.drm_dev->struct_mutex);
 			return -EINVAL;
 		}
diff --git a/drivers/gpu/drm/hantro_driver/hantro_drm.h b/drivers/gpu/drm/hantro_driver/hantro_drm.h
index d1226bc1e009..3dc8b2dc9d55 100644
--- a/drivers/gpu/drm/hantro_driver/hantro_drm.h
+++ b/drivers/gpu/drm/hantro_driver/hantro_drm.h
@@ -86,7 +86,7 @@ struct drm_gem_hantro_object {
 	unsigned int ctxno;
 	int handle;
 	int fd;
-	struct device_info *pdevice;
+	struct device_info *pdevinfo;
 	struct drm_file *file_priv;
 	int flag;
 	/* common meta information for dec400, MUST next to base */
diff --git a/drivers/gpu/drm/hantro_driver/hantro_drv.c b/drivers/gpu/drm/hantro_driver/hantro_drv.c
index 949f42a04b26..192c2f89db67 100644
--- a/drivers/gpu/drm/hantro_driver/hantro_drv.c
+++ b/drivers/gpu/drm/hantro_driver/hantro_drv.c
@@ -150,19 +150,19 @@ static int getclockname(dtbnode *pnode)
 	} else {
 		if (strstr(nodename, "decoderA") == nodename)
 			sprintf(pnode->clock_name, "vc8000da_aclk_computess%d",
-				pnode->pdevice->deviceid);
+				pnode->pdevinfo->deviceid);
 
 		if (strstr(nodename, "decoderB") == nodename)
 			sprintf(pnode->clock_name, "vc8000db_aclk_computess%d",
-				pnode->pdevice->deviceid);
+				pnode->pdevinfo->deviceid);
 
 		if (strstr(nodename, "encoderA") == nodename)
 			sprintf(pnode->clock_name, "vc8000ej_aclk_computess%d",
-				pnode->pdevice->deviceid);
+				pnode->pdevinfo->deviceid);
 
 		if (strstr(nodename, "encoderB") == nodename)
 			sprintf(pnode->clock_name, "vc8000e_aclk_computess%d",
-				pnode->pdevice->deviceid);
+				pnode->pdevinfo->deviceid);
 	}
 
 	return -EINVAL;
@@ -187,7 +187,7 @@ static int getnodetype(const char *name)
 
 static dtbnode *trycreatenode(struct platform_device *pdev,
 			      struct device_node *ofnode,
-			      struct device_info *pdevice, int parenttype,
+			      struct device_info *pdevinfo, int parenttype,
 			      phys_addr_t parentaddr)
 {
 	struct fwnode_handle *fwnode;
@@ -205,7 +205,7 @@ static dtbnode *trycreatenode(struct platform_device *pdev,
 	pnode->type = getnodetype(ofnode->name);
 	pnode->parentaddr = parentaddr;
 	pnode->parenttype = parenttype;
-	pnode->pdevice = pdevice;
+	pnode->pdevinfo = pdevinfo;
 	pnode->ofnode = ofnode;
 	fwnode = &ofnode->fwnode;
 	getclockname(pnode);
@@ -391,48 +391,48 @@ static int hantro_clock_control(struct device *dev, bool enable)
 static int hantro_cooling_get_max_state(struct thermal_cooling_device *cdev,
 					unsigned long *state)
 {
-	struct device_info *pdevice = cdev->devdata;
+	struct device_info *pdevinfo = cdev->devdata;
 
-	if (!pdevice)
+	if (!pdevinfo)
 		return -EINVAL;
 
-	*state = pdevice->thermal_data.media_clk_max_state;
+	*state = pdevinfo->thermal_data.media_clk_max_state;
 	return 0;
 }
 
 static int hantro_cooling_set_cur_state(struct thermal_cooling_device *cdev,
 					unsigned long state)
 {
-	struct device_info *pdevice = cdev->devdata;
+	struct device_info *pdevinfo = cdev->devdata;
 
-	if (!pdevice || state > pdevice->thermal_data.media_clk_max_state)
+	if (!pdevinfo || state > pdevinfo->thermal_data.media_clk_max_state)
 		return -EINVAL;
 
-	if (state == pdevice->thermal_data.media_clk_state ||
+	if (state == pdevinfo->thermal_data.media_clk_state ||
 	    state > 2) //only	3 states supported
 		return 0;
 
-	pdevice->thermal_data.media_clk_state = state;
+	pdevinfo->thermal_data.media_clk_state = state;
 
 	if (hantro_drm.device_type == DEVICE_KEEMBAY)
-		pdevice->thermal_data.clk_freq = kmb_freq_table[state];
+		pdevinfo->thermal_data.clk_freq = kmb_freq_table[state];
 	else if (hantro_drm.device_type == DEVICE_THUNDERBAY)
-		pdevice->thermal_data.clk_freq = tbh_freq_table[state];
+		pdevinfo->thermal_data.clk_freq = tbh_freq_table[state];
 
 	pr_info("set_cur_state: %ld for device %d\n",
-		pdevice->thermal_data.clk_freq, pdevice->deviceid);
+		pdevinfo->thermal_data.clk_freq, pdevinfo->deviceid);
 	return 0;
 }
 
 static int hantro_cooling_get_cur_state(struct thermal_cooling_device *cdev,
 					unsigned long *state)
 {
-	struct device_info *pdevice = cdev->devdata;
+	struct device_info *pdevinfo = cdev->devdata;
 
-	if (!pdevice)
+	if (!pdevinfo)
 		return -EINVAL;
 
-	*state = pdevice->thermal_data.media_clk_state;
+	*state = pdevinfo->thermal_data.media_clk_state;
 	return 0;
 }
 
@@ -442,32 +442,32 @@ static const struct thermal_cooling_device_ops hantro_cooling_ops = {
 	.set_cur_state = hantro_cooling_set_cur_state,
 };
 
-int setup_thermal_cooling(struct device_info *pdevice)
+int setup_thermal_cooling(struct device_info *pdevinfo)
 {
 	int result;
 	char thermal_str[64];
-	struct device_node *np = pdevice->dev->of_node;
+	struct device_node *np = pdevinfo->dev->of_node;
 
-	if (!pdevice) {
+	if (!pdevinfo) {
 		pr_warn("Device info NULL\n");
 		return -EINVAL;
 	}
 
-	pdevice->thermal_data.media_clk_max_state = 3;
+	pdevinfo->thermal_data.media_clk_max_state = 3;
 	if (hantro_drm.device_type == DEVICE_KEEMBAY)
-		pdevice->thermal_data.clk_freq = kmb_freq_table[0];
+		pdevinfo->thermal_data.clk_freq = kmb_freq_table[0];
 	else
-		pdevice->thermal_data.clk_freq = tbh_freq_table[0];
+		pdevinfo->thermal_data.clk_freq = tbh_freq_table[0];
 
-	sprintf(thermal_str, "media-cooling%d", pdevice->deviceid);
-	pdevice->thermal_data.cooling_dev = devm_thermal_of_cooling_device_register(pdevice->dev,
+	sprintf(thermal_str, "media-cooling%d", pdevinfo->deviceid);
+	pdevinfo->thermal_data.cooling_dev = devm_thermal_of_cooling_device_register(pdevinfo->dev,
 										    np,
 										    thermal_str,
-										    pdevice,
+										    pdevinfo,
 										    &hantro_cooling_ops);
-	if (IS_ERR(pdevice->thermal_data.cooling_dev)) {
-		result = PTR_ERR(pdevice->thermal_data.cooling_dev);
-		dev_err(pdevice->dev,
+	if (IS_ERR(pdevinfo->thermal_data.cooling_dev)) {
+		result = PTR_ERR(pdevinfo->thermal_data.cooling_dev);
+		dev_err(pdevinfo->dev,
 			"failed to register thermal zone device %d", result);
 	}
 
@@ -527,7 +527,7 @@ static int hantro_reset_control(struct platform_device *pdev, bool deassert)
 
 int hantro_analyze_subnode(struct platform_device *pdev,
 			   struct device_node *pofnode,
-			   struct device_info *pdevice)
+			   struct device_info *pdevinfo)
 {
 	dtbnode *head, *nhead, *newtail, *node;
 
@@ -538,7 +538,7 @@ int hantro_analyze_subnode(struct platform_device *pdev,
 	head->type = CORE_DEVICE;
 	head->parenttype = CORE_DEVICE;
 	head->ofnode = pofnode;
-	head->dev = pdevice->dev;
+	head->pdevinfo = pdevinfo;
 	head->ioaddr = -1;
 	head->iosize = 0;
 	head->next = NULL;
@@ -550,7 +550,7 @@ int hantro_analyze_subnode(struct platform_device *pdev,
 			struct device_node *child, *ofnode = head->ofnode;
 
 			for_each_child_of_node(ofnode, child) {
-				node = trycreatenode(pdev, child, pdevice,
+				node = trycreatenode(pdev, child, pdevinfo,
 						     head->type, head->ioaddr);
 				if (node) {
 					if (!nhead) {
@@ -923,9 +923,9 @@ int __init hantro_init(void)
 
 	init_fence_data();
 	for (i = 0; i < get_devicecount(); i++) {
-		struct device_info *pdevice = get_deviceinfo(i);
+		struct device_info *pdevinfo = get_deviceinfo(i);
 
-		hantro_drm.config |= pdevice->config;
+		hantro_drm.config |= pdevinfo->config;
 	}
 
 	hantrodec_init();
diff --git a/drivers/gpu/drm/hantro_driver/hantro_enc.c b/drivers/gpu/drm/hantro_driver/hantro_enc.c
index 595f7c1d75ab..b03feefee177 100644
--- a/drivers/gpu/drm/hantro_driver/hantro_enc.c
+++ b/drivers/gpu/drm/hantro_driver/hantro_enc.c
@@ -52,7 +52,7 @@ static int check_enc_irq(struct hantroenc_t *dev, u32 *core_info,
 	int rdy = 0;
 	u32 i = 0;
 	u8 core_mapping = 0;
-	struct device_info *parentdevice = getparentdevice(dev, CORE_ENC);
+	struct device_info *pdevinfo = getparentdevice(dev, CORE_ENC);
 
 	core_mapping = (u8)(*core_info & 0xFF);
 
@@ -61,7 +61,7 @@ static int check_enc_irq(struct hantroenc_t *dev, u32 *core_info,
 			if (i >= nodenum)
 				break;
 
-			spin_lock_irqsave(&parentdevice->enc_owner_lock, flags);
+			spin_lock_irqsave(&pdevinfo->enc_owner_lock, flags);
 
 			if (dev->irq_received) {
 				/* reset the wait condition(s) */
@@ -72,7 +72,7 @@ static int check_enc_irq(struct hantroenc_t *dev, u32 *core_info,
 				*irq_status = dev->irq_status;
 			}
 
-			spin_unlock_irqrestore(&parentdevice->enc_owner_lock,
+			spin_unlock_irqrestore(&pdevinfo->enc_owner_lock,
 					       flags);
 			break;
 		}
@@ -87,10 +87,10 @@ static int check_enc_irq(struct hantroenc_t *dev, u32 *core_info,
 static unsigned int wait_enc_ready(struct hantroenc_t *dev, u32 *core_info,
 				   u32 *irq_status, u32 nodenum)
 {
-	struct device_info *parentdevice = getparentdevice(dev, CORE_ENC);
+	struct device_info *pdevinfo = getparentdevice(dev, CORE_ENC);
 
 	PDEBUG("%s\n", __func__);
-	if (wait_event_interruptible(parentdevice->enc_wait_queue,
+	if (wait_event_interruptible(pdevinfo->enc_wait_queue,
 				     check_enc_irq(dev, core_info, irq_status,
 						   nodenum))) {
 		PDEBUG("ENC wait_event_interruptible interrupted\n");
@@ -101,13 +101,13 @@ static unsigned int wait_enc_ready(struct hantroenc_t *dev, u32 *core_info,
 	return 0;
 }
 
-u32 hantroenc_readbandwidth(struct device_info *pdevice, int is_read_bw)
+u32 hantroenc_readbandwidth(struct device_info *pdevinfo, int is_read_bw)
 {
 	int i, devcnt = get_devicecount();
 	u32 bandwidth = 0;
 	struct hantroenc_t *pcore;
 
-	if (!pdevice) {
+	if (!pdevinfo) {
 		for (i = 0; i < devcnt; i++) {
 			pcore = get_encnode_bydeviceid(i, 0);
 			while (pcore) {
@@ -135,7 +135,7 @@ u32 hantroenc_readbandwidth(struct device_info *pdevice, int is_read_bw)
 			}
 		}
 	} else {
-		pcore = get_encnode(pdevice, 0);
+		pcore = get_encnode(pdevinfo, 0);
 		while (pcore) {
 			if (is_read_bw) {
 				if (hantro_drm.device_type == DEVICE_KEEMBAY)
@@ -165,9 +165,9 @@ static int check_core_occupation(struct hantroenc_t *dev)
 {
 	int ret = 0;
 	unsigned long flags;
-	struct device_info *parentdevice = getparentdevice(dev, CORE_ENC);
+	struct device_info *pdevinfo = getparentdevice(dev, CORE_ENC);
 
-	spin_lock_irqsave(&parentdevice->enc_owner_lock, flags);
+	spin_lock_irqsave(&pdevinfo->enc_owner_lock, flags);
 	if (!dev->is_reserved) {
 		dev->is_reserved = 1;
 		dev->pid = current->pid;
@@ -175,7 +175,7 @@ static int check_core_occupation(struct hantroenc_t *dev)
 		PDEBUG("%s pid=%d\n", __func__, dev->pid);
 	}
 
-	spin_unlock_irqrestore(&parentdevice->enc_owner_lock, flags);
+	spin_unlock_irqrestore(&pdevinfo->enc_owner_lock, flags);
 	return ret;
 }
 
@@ -247,7 +247,7 @@ static int get_workable_core(struct hantroenc_t *dev, u32 *core_info,
 static long reserve_encoder(struct hantroenc_t *dev, u32 *core_info,
 			    u32 nodenum)
 {
-	struct device_info *parentdevice = getparentdevice(dev, CORE_ENC);
+	struct device_info *pdevinfo = getparentdevice(dev, CORE_ENC);
 	struct hantroenc_t *reserved_core = NULL;
 	u32 core_info_tmp = 0;
 	int ret = 0;
@@ -256,7 +256,7 @@ static long reserve_encoder(struct hantroenc_t *dev, u32 *core_info,
 	PDEBUG("hx280enc: %s\n", __func__);
 	/* If HW resources are shared inter cores, just make sure only one is using the HW */
 	if (resource_shared) {
-		if (down_interruptible(&parentdevice->enc_core_sem)) {
+		if (down_interruptible(&pdevinfo->enc_core_sem)) {
 			ret = -ERESTARTSYS;
 			nodenum = 0xffffffff;
 			goto out;
@@ -264,7 +264,7 @@ static long reserve_encoder(struct hantroenc_t *dev, u32 *core_info,
 	}
 
 	/* lock a core that has specified core id */
-	if (wait_event_interruptible(parentdevice->enc_hw_queue,
+	if (wait_event_interruptible(pdevinfo->enc_hw_queue,
 				     get_workable_core(dev, core_info,
 						       &core_info_tmp,
 						       nodenum) != 0)) {
@@ -273,17 +273,17 @@ static long reserve_encoder(struct hantroenc_t *dev, u32 *core_info,
 		goto out;
 	}
 
-	reserved_core = get_encnode(parentdevice, KCORE(*core_info) - 1);
+	reserved_core = get_encnode(pdevinfo, KCORE(*core_info) - 1);
 	if (!reserved_core) {
 		pr_debug("Core not found. Possibly Lookahead node");
 		goto out;
 	}
 
 	if (reserved_core->dev_clk &&
-	    parentdevice->thermal_data.clk_freq != reserved_core->clk_freq) {
+	    pdevinfo->thermal_data.clk_freq != reserved_core->clk_freq) {
 		clk_set_rate(reserved_core->dev_clk,
-			     parentdevice->thermal_data.clk_freq);
-		reserved_core->clk_freq = parentdevice->thermal_data.clk_freq;
+			     pdevinfo->thermal_data.clk_freq);
+		reserved_core->clk_freq = pdevinfo->thermal_data.clk_freq;
 	}
 
 	reserved_core->perf_data.last_resv = sched_clock();
@@ -300,11 +300,11 @@ static void release_encoder(struct hantroenc_t *dev, u32 *core_info,
 	u32 core_num = 0;
 	u32 i = 0, core_id;
 	u8 core_mapping = 0;
-	struct device_info *parentdevice = getparentdevice(dev, CORE_ENC);
+	struct device_info *pdevinfo = getparentdevice(dev, CORE_ENC);
 	struct hantroenc_t *reserved_core = NULL;
 
 	core_id = KCORE((*core_info));
-	reserved_core = get_encnode(parentdevice, core_id - 1);
+	reserved_core = get_encnode(pdevinfo, core_id - 1);
 	if (reserved_core) {
 		reserved_core->perf_data.count++;
 		reserved_core->perf_data.totaltime +=
@@ -325,7 +325,7 @@ static void release_encoder(struct hantroenc_t *dev, u32 *core_info,
 				break;
 
 			core_id = i;
-			spin_lock_irqsave(&parentdevice->enc_owner_lock, flags);
+			spin_lock_irqsave(&pdevinfo->enc_owner_lock, flags);
 			PDEBUG("dev[core_id].pid=%d,current->pid=%d\n",
 			       dev->pid, current->pid);
 			if (dev->is_reserved && dev->pid == current->pid) {
@@ -334,7 +334,7 @@ static void release_encoder(struct hantroenc_t *dev, u32 *core_info,
 				dev->irq_received = 0;
 				dev->irq_status = 0;
 			}
-			spin_unlock_irqrestore(&parentdevice->enc_owner_lock,
+			spin_unlock_irqrestore(&pdevinfo->enc_owner_lock,
 					       flags);
 		}
 
@@ -343,9 +343,9 @@ static void release_encoder(struct hantroenc_t *dev, u32 *core_info,
 		dev = dev->next;
 	}
 
-	wake_up_interruptible_all(&parentdevice->enc_hw_queue);
+	wake_up_interruptible_all(&pdevinfo->enc_hw_queue);
 	if (resource_shared)
-		up(&parentdevice->enc_core_sem);
+		up(&pdevinfo->enc_core_sem);
 
 	trace_enc_release(dev->deviceidx, KCORE((*core_info)));
 }
@@ -456,7 +456,7 @@ long hantroenc_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 
 int hantroenc_release(void)
 {
-	struct device_info *parentdevice;
+	struct device_info *pdevinfo;
 	int i, devicecnt = get_devicecount();
 	struct hantroenc_t *dev;
 	unsigned long flags;
@@ -469,9 +469,9 @@ int hantroenc_release(void)
 		if (!dev)
 			continue;
 
-		parentdevice = getparentdevice(dev, CORE_ENC);
+		pdevinfo = getparentdevice(dev, CORE_ENC);
 		while (dev) {
-			spin_lock_irqsave(&parentdevice->enc_owner_lock, flags);
+			spin_lock_irqsave(&pdevinfo->enc_owner_lock, flags);
 			if (dev->is_reserved == 1 && dev->pid == current->pid) {
 				dev->pid = -1;
 				dev->is_reserved = 0;
@@ -479,14 +479,14 @@ int hantroenc_release(void)
 				dev->irq_status = 0;
 				PDEBUG("release reserved core\n");
 			}
-			spin_unlock_irqrestore(&parentdevice->enc_owner_lock,
+			spin_unlock_irqrestore(&pdevinfo->enc_owner_lock,
 					       flags);
 			dev = dev->next;
 		}
 
-		wake_up_interruptible_all(&parentdevice->enc_hw_queue);
+		wake_up_interruptible_all(&pdevinfo->enc_hw_queue);
 		if (resource_shared)
-			up(&parentdevice->enc_core_sem);
+			up(&pdevinfo->enc_core_sem);
 	}
 
 	return 0;
@@ -576,7 +576,7 @@ static int init_enc_clock(struct hantroenc_t *pcore, dtbnode *pnode)
 	if (strlen(pnode->clock_name) == 0)
 		return 0;
 
-	pcore->dev_clk = clk_get(pnode->pdevice->dev, pnode->clock_name);
+	pcore->dev_clk = clk_get(pnode->pdevinfo->dev, pnode->clock_name);
 	if (IS_ERR(pcore->dev_clk) || !pcore->dev_clk) {
 		pr_err("%s: clock %s not found. err = %ld", __func__,
 		       pnode->clock_name, PTR_ERR(pcore->dev_clk));
@@ -585,7 +585,7 @@ static int init_enc_clock(struct hantroenc_t *pcore, dtbnode *pnode)
 	}
 
 	clk_prepare_enable(pcore->dev_clk);
-	pcore->clk_freq = pnode->pdevice->thermal_data.clk_freq;
+	pcore->clk_freq = pnode->pdevinfo->thermal_data.clk_freq;
 	clk_set_rate(pcore->dev_clk, pcore->clk_freq);
 	return 0;
 }
@@ -645,17 +645,17 @@ int hantroenc_probe(dtbnode *pnode)
 	}
 
 	init_enc_clock(pcore, pnode);
-	add_encnode(pnode->pdevice, pcore);
+	add_encnode(pnode->pdevinfo, pcore);
 	pr_info("hx280enc: module inserted. Major <%d>\n", hantroenc_major);
 	return 0;
 }
 
-void hantroenc_remove(struct device_info *pdevice)
+void hantroenc_remove(struct device_info *pdevinfo)
 {
 	int k;
 	struct hantroenc_t *pcore, *pnext;
 
-	pcore = get_encnode(pdevice, 0);
+	pcore = get_encnode(pdevinfo, 0);
 	while (pcore) {
 		u32 hwid = pcore->hw_id;
 		u32 major_id = (hwid & 0x0000FF00) >> 8;
@@ -728,13 +728,13 @@ static irqreturn_t hantroenc_isr(int irq, void *dev_id)
 	struct hantroenc_t *dev = (struct hantroenc_t *)dev_id;
 	u32 irq_status;
 	unsigned long flags;
-	struct device_info *parentdevice = getparentdevice(dev, CORE_ENC);
+	struct device_info *pdevinfo = getparentdevice(dev, CORE_ENC);
 
 	/*
 	 * If core is not reserved by any user, but irq is received, just
 	 * ignore it
 	 */
-	spin_lock_irqsave(&parentdevice->enc_owner_lock, flags);
+	spin_lock_irqsave(&pdevinfo->enc_owner_lock, flags);
 	if (!dev->is_reserved) {
 		PDEBUG("%s:received IRQ but core is not reserved!\n", __func__);
 		irq_status = (u32)ioread32((void *)(dev->hwregs + 0x04));
@@ -760,11 +760,11 @@ static irqreturn_t hantroenc_isr(int irq, void *dev_id)
 			iowrite32(wclr, (void *)(dev->hwregs + 0x04));
 		}
 
-		spin_unlock_irqrestore(&parentdevice->enc_owner_lock, flags);
+		spin_unlock_irqrestore(&pdevinfo->enc_owner_lock, flags);
 		return IRQ_HANDLED;
 	}
 
-	spin_unlock_irqrestore(&parentdevice->enc_owner_lock, flags);
+	spin_unlock_irqrestore(&pdevinfo->enc_owner_lock, flags);
 	irq_status = (u32)ioread32((void *)(dev->hwregs + 0x04));
 	if (irq_status & 0x01) {
 		/*
@@ -779,11 +779,11 @@ static irqreturn_t hantroenc_isr(int irq, void *dev_id)
 			iowrite32(0, (void *)(dev->hwregs + 0x14));
 
 		iowrite32(wclr, (void *)(dev->hwregs + 0x04));
-		spin_lock_irqsave(&parentdevice->enc_owner_lock, flags);
+		spin_lock_irqsave(&pdevinfo->enc_owner_lock, flags);
 		dev->irq_received = 1;
 		dev->irq_status = irq_status & (~0x01);
-		spin_unlock_irqrestore(&parentdevice->enc_owner_lock, flags);
-		wake_up_interruptible_all(&parentdevice->enc_wait_queue);
+		spin_unlock_irqrestore(&pdevinfo->enc_owner_lock, flags);
+		wake_up_interruptible_all(&pdevinfo->enc_wait_queue);
 		handled++;
 	}
 
diff --git a/drivers/gpu/drm/hantro_driver/hantro_fs.c b/drivers/gpu/drm/hantro_driver/hantro_fs.c
index 841217b1bb06..91d8476475ac 100644
--- a/drivers/gpu/drm/hantro_driver/hantro_fs.c
+++ b/drivers/gpu/drm/hantro_driver/hantro_fs.c
@@ -242,48 +242,48 @@ int mem_usage_internal(unsigned int deviceidx, struct device *memdev,
 ssize_t mem_usage_show(struct device *kdev, struct device_attribute *attr,
 		       char *buf)
 {
-	struct device_info *pdevice = dev_get_drvdata(kdev);
+	struct device_info *pdevinfo = dev_get_drvdata(kdev);
 	int deviceidx, bufsize = 0;
 
 	int used_mem0 = 0, alloc_count0 = 0;
 	int used_mem1 = 0, alloc_count1 = 0;
 
-	if (pdevice < 0)
+	if (pdevinfo < 0)
 		return 0;
 
-	deviceidx = pdevice->deviceid;
-	mem_usage_internal(deviceidx, pdevice->dev, &used_mem0, &alloc_count0,
+	deviceidx = pdevinfo->deviceid;
+	mem_usage_internal(deviceidx, pdevinfo->dev, &used_mem0, &alloc_count0,
 			   NULL);
-	if (pdevice->codec_rsvmem)
-		mem_usage_internal(deviceidx, pdevice->codec_rsvmem, &used_mem1,
+	if (pdevinfo->codec_rsvmem)
+		mem_usage_internal(deviceidx, pdevinfo->codec_rsvmem, &used_mem1,
 				   &alloc_count1, NULL);
 
 	bufsize += snprintf(buf + bufsize, PAGE_SIZE, "Device %d mem usage:\n",
 			    deviceidx);
 	bufsize += snprintf(buf + bufsize, PAGE_SIZE,
 		"\tCMA 0 : %lld MB - [0x%llx - 0x%llx]\n\t\t %dK in %d allocations\n\n",
-		resource_size(&pdevice->mem_res[0]) / (1024 * 1024),
-		pdevice->mem_res[0].start, pdevice->mem_res[0].end,
+		resource_size(&pdevinfo->mem_res[0]) / (1024 * 1024),
+		pdevinfo->mem_res[0].start, pdevinfo->mem_res[0].end,
 		used_mem0 / 1024, alloc_count0);
 	bufsize += snprintf(buf + bufsize, PAGE_SIZE,
 		"\tCMA 1 : %lld MB - [0x%llx - 0x%llx]\n\t\t %dK in %d allocations\n",
-		resource_size(&pdevice->mem_res[1]) / (1024 * 1024),
-		pdevice->mem_res[1].start, pdevice->mem_res[1].end,
+		resource_size(&pdevinfo->mem_res[1]) / (1024 * 1024),
+		pdevinfo->mem_res[1].start, pdevinfo->mem_res[1].end,
 		used_mem1 / 1024, alloc_count1);
 	return bufsize;
 }
 
 static void reset_perf_data(void)
 {
-	struct device_info *pdevice;
+	struct device_info *pdevinfo;
 	struct hantrodec_t *dechdr;
 	struct hantroenc_t *enchdr;
 	int i, devcnt;
 
 	devcnt = get_devicecount();
 	for (i = 0; i < devcnt; i++) {
-		pdevice = get_deviceinfo(i);
-		dechdr = pdevice->dechdr;
+		pdevinfo = get_deviceinfo(i);
+		dechdr = pdevinfo->dechdr;
 		while (dechdr) {
 			dechdr->perf_data.count = 0;
 			dechdr->perf_data.totaltime = 0;
@@ -291,7 +291,7 @@ static void reset_perf_data(void)
 			dechdr = dechdr->next;
 		}
 
-		enchdr = pdevice->enchdr;
+		enchdr = pdevinfo->enchdr;
 		while (enchdr) {
 			enchdr->perf_data.count = 0;
 			enchdr->perf_data.totaltime = 0;
@@ -304,7 +304,7 @@ static void reset_perf_data(void)
 static ssize_t fps_show(struct device *kdev, struct device_attribute *attr,
 			char *buf)
 {
-	struct device_info *pdevice;
+	struct device_info *pdevinfo;
 	struct hantrodec_t *dechdr;
 	struct hantroenc_t *enchdr;
 	int buf_size = 0, i, diff, devcnt, core;
@@ -319,10 +319,10 @@ static ssize_t fps_show(struct device *kdev, struct device_attribute *attr,
 	msleep(1000);
 	diff = (sched_clock() - start) / 1000000; // diff in ms
 	for (i = 0; i < devcnt; i++) {
-		pdevice = get_deviceinfo(i);
+		pdevinfo = get_deviceinfo(i);
 		buf_size +=
 			snprintf(buf + buf_size, PAGE_SIZE, "Device %d:\n", i);
-		dechdr = pdevice->dechdr;
+		dechdr = pdevinfo->dechdr;
 		core = 0;
 		totalfps = 0;
 		buf_size += snprintf(buf + buf_size, PAGE_SIZE, "\tDecode\n");
@@ -359,7 +359,7 @@ static ssize_t fps_show(struct device *kdev, struct device_attribute *attr,
 		core = 0;
 		totalfps = 0;
 		buf_size += snprintf(buf + buf_size, PAGE_SIZE, "\tEncode\n");
-		enchdr = pdevice->enchdr;
+		enchdr = pdevinfo->enchdr;
 		while (enchdr) {
 			fps = 0;
 			clk_freq = clk_get_rate(enchdr->dev_clk);
@@ -428,19 +428,19 @@ static const struct attribute_group hantro_attr_group = {
 //print mem_usage details through debugfs
 int mem_usage_debugfs_show(struct seq_file *s, void *v)
 {
-	struct device_info *pdevice = s->private;
-	int deviceidx = pdevice->deviceid;
+	struct device_info *pdevinfo = s->private;
+	int deviceidx = pdevinfo->deviceid;
 
 	seq_printf(s, "Memory usage for device %d:\n", deviceidx);
 	seq_printf(s, "Pixel CMA: %lld MB - [0x%llx - 0x%llx]\n",
-		   resource_size(&pdevice->mem_res[0]) / (1024 * 1024),
-		   pdevice->mem_res[0].start, pdevice->mem_res[0].end);
-	mem_usage_internal(deviceidx, pdevice->dev, NULL, NULL, s);
-	if (pdevice && pdevice->codec_rsvmem) {
+		   resource_size(&pdevinfo->mem_res[0]) / (1024 * 1024),
+		   pdevinfo->mem_res[0].start, pdevinfo->mem_res[0].end);
+	mem_usage_internal(deviceidx, pdevinfo->dev, NULL, NULL, s);
+	if (pdevinfo && pdevinfo->codec_rsvmem) {
 		seq_printf(s, "Codec CMA: %lld MB - [0x%llx - 0x%llx]\n",
-			   resource_size(&pdevice->mem_res[1]) / (1024 * 1024),
-			   pdevice->mem_res[1].start, pdevice->mem_res[1].end);
-		mem_usage_internal(deviceidx, pdevice->codec_rsvmem, NULL, NULL,
+			   resource_size(&pdevinfo->mem_res[1]) / (1024 * 1024),
+			   pdevinfo->mem_res[1].start, pdevinfo->mem_res[1].end);
+		mem_usage_internal(deviceidx, pdevinfo->codec_rsvmem, NULL, NULL,
 				   s);
 	}
 
@@ -449,24 +449,24 @@ int mem_usage_debugfs_show(struct seq_file *s, void *v)
 
 DEFINE_SHOW_ATTRIBUTE(mem_usage_debugfs);
 
-int create_sysfs(struct device_info *pdevice)
+int create_sysfs(struct device_info *pdevinfo)
 {
-	return devm_device_add_group(pdevice->dev, &hantro_attr_group);
+	return devm_device_add_group(pdevinfo->dev, &hantro_attr_group);
 }
 
-void remove_sysfs(struct device_info *pdevice)
+void remove_sysfs(struct device_info *pdevinfo)
 {
-	devm_device_remove_group(pdevice->dev, &hantro_attr_group);
+	devm_device_remove_group(pdevinfo->dev, &hantro_attr_group);
 }
 
-void create_debugfs(struct device_info *pdevice, bool has_codecmem)
+void create_debugfs(struct device_info *pdevinfo, bool has_codecmem)
 {
 	char filename[64];
 
 	if (!hantro_drm.debugfs_root)
 		return;
 
-	sprintf(filename, "mem_usage%d", pdevice->deviceid);
+	sprintf(filename, "mem_usage%d", pdevinfo->deviceid);
 	debugfs_create_file(filename, S_IFREG | 0444, hantro_drm.debugfs_root,
-			    pdevice, &mem_usage_debugfs_fops);
+			    pdevinfo, &mem_usage_debugfs_fops);
 }
diff --git a/drivers/gpu/drm/hantro_driver/hantro_priv.h b/drivers/gpu/drm/hantro_driver/hantro_priv.h
index 061401753a99..5ee60402853a 100644
--- a/drivers/gpu/drm/hantro_driver/hantro_priv.h
+++ b/drivers/gpu/drm/hantro_driver/hantro_priv.h
@@ -121,7 +121,7 @@ typedef struct dtbnode {
 	int parenttype;
 	phys_addr_t parentaddr;
 	int deviceidx;
-	struct device_info *pdevice;
+	struct device_info *pdevinfo;
 	struct dtbnode *next;
 	struct device *dev;
 } dtbnode;
-- 
2.27.0

