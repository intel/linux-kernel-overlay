From d51a0f433c82c067864f84979259062a79a1e8b6 Mon Sep 17 00:00:00 2001
From: kadarlax <raghuveerx.kadarla@intel.com>
Date: Fri, 16 Apr 2021 10:09:52 +0530
Subject: [PATCH 130/170] misc: xpcie: enable AER capability

Adding AER feature to handle pcie Advanced Error Reporting
for intel xpcie driver.

Signed-off-by: kadarlax <raghuveerx.kadarla@intel.com>
---
 drivers/misc/xlink-pcie/remote_host/main.c | 87 ++++++++++++++++++++++
 drivers/misc/xlink-pcie/remote_host/pci.c  | 13 ++++
 2 files changed, 100 insertions(+)

diff --git a/drivers/misc/xlink-pcie/remote_host/main.c b/drivers/misc/xlink-pcie/remote_host/main.c
index 028692799f91..2fed02a4dacb 100644
--- a/drivers/misc/xlink-pcie/remote_host/main.c
+++ b/drivers/misc/xlink-pcie/remote_host/main.c
@@ -7,6 +7,10 @@
  *
  ****************************************************************************/
 
+#ifdef XLINK_PCIE_RH_DRV_AER
+#include <linux/aer.h>
+#endif
+
 #include "pci.h"
 #include "../common/core.h"
 
@@ -22,6 +26,86 @@ static const struct pci_device_id xpcie_pci_table[] = {
 	{ 0 }
 };
 
+#ifdef XLINK_PCIE_RH_DRV_AER
+static pci_ers_result_t
+intel_xpcie_pci_err_detected(struct pci_dev *pdev, enum pci_channel_state err)
+{
+	/*
+	 * TODO:
+	 * This API will be called to warn that a PCIe error has been detected
+	 * on the channel. So, there should be mechanism to handle these errors
+	 * which is very specific to HW used.
+	 *
+	 * For now, this API does only print information on what error
+	 * has been detected and notify higher layers that error has been
+	 * recovered (= PCI_ERS_RESULT_RECOVERED).
+	 */
+
+	dev_info(&pdev->dev, "PCIe AER Error Channel IO: ");
+
+	switch (err) {
+	case pci_channel_io_normal:
+		dev_info(&pdev->dev, "NORMAL\n");
+		break;
+	case pci_channel_io_frozen:
+		dev_info(&pdev->dev, "FROZEN\n");
+		break;
+	case pci_channel_io_perm_failure:
+		dev_info(&pdev->dev, "PERMANENT FAILURE\n");
+		break;
+	}
+
+	return PCI_ERS_RESULT_RECOVERED;
+}
+
+static pci_ers_result_t intel_xpcie_pci_err_mmio_enabled(struct pci_dev *pdev)
+{
+	/*
+	 * TODO:
+	 * This API will be called if xxx_error_detected() returns
+	 * PCI_ERS_RESULT_CAN_RECOVER
+	 *
+	 * For time-being, treat that all the errors are recovered.
+	 */
+	dev_info(&pdev->dev, "PCIe AER MMIO Enabled callback\n");
+
+	return PCI_ERS_RESULT_RECOVERED;
+}
+
+static pci_ers_result_t intel_xpcie_pci_err_slot_reset(struct pci_dev *pdev)
+{
+	/*
+	 * TODO:
+	 * This API will be called after a PCIe slot reset to see
+	 * if it can recover from reset.
+	 *
+	 * Need to add specific implementation, if any, to check if
+	 * HW can recover from reset. For now, we report to higher
+	 * layers that it cannot be recovered from a slot reset.
+	 */
+	dev_info(&pdev->dev, "PCIe AER Error Slot Reset callback\n");
+
+	return PCI_ERS_RESULT_DISCONNECT;
+}
+
+static void intel_xpcie_pci_err_resume(struct pci_dev *pdev)
+{
+	/*
+	 * TODO:
+	 * This API will be called in a process to re-initialize HW
+	 * any, after reset has happened.
+	 */
+	dev_info(&pdev->dev, "PCIe AER Error Resume Callback\n");
+}
+
+static const struct pci_error_handlers intel_xpcie_pci_err_handler = {
+	.error_detected = intel_xpcie_pci_err_detected,
+	.mmio_enabled = intel_xpcie_pci_err_mmio_enabled,
+	.slot_reset = intel_xpcie_pci_err_slot_reset,
+	.resume = intel_xpcie_pci_err_resume
+};
+#endif
+
 static int intel_xpcie_probe(struct pci_dev *pdev,
 			     const struct pci_device_id *ent)
 {
@@ -90,6 +174,9 @@ static struct pci_driver xpcie_driver = {
 	.id_table = xpcie_pci_table,
 	.probe = intel_xpcie_probe,
 	.remove = intel_xpcie_remove
+#ifdef XLINK_PCIE_RH_DRV_AER
+	.err_handler = &intel_xpcie_pci_err_handler
+#endif
 };
 
 static int __init intel_xpcie_init_module(void)
diff --git a/drivers/misc/xlink-pcie/remote_host/pci.c b/drivers/misc/xlink-pcie/remote_host/pci.c
index 5bfe99f00b28..bd5298be34f7 100644
--- a/drivers/misc/xlink-pcie/remote_host/pci.c
+++ b/drivers/misc/xlink-pcie/remote_host/pci.c
@@ -12,6 +12,9 @@
 #include <linux/sched.h>
 #include <linux/wait.h>
 #include <linux/workqueue.h>
+#ifdef XLINK_PCIE_RH_DRV_AER
+#include <linux/aer.h>
+#endif
 
 #include "pci.h"
 
@@ -375,6 +378,13 @@ int intel_xpcie_pci_init(struct xpcie_dev *xdev, struct pci_dev *pdev)
 	if (!rc)
 		goto init_exit;
 
+#ifdef XLINK_PCIE_RH_DRV_AER
+	rc = pci_enable_pcie_error_reporting(xdev->pci);
+	if (rc)
+		dev_warn(&pdev->dev,
+			 "failed to configure AER with rc %d\n", rc);
+#endif
+
 #if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 	xdev->fl_vbuf = NULL;
 	xdev->fl_buf_size = 0;
@@ -422,6 +432,9 @@ int intel_xpcie_pci_cleanup(struct xpcie_dev *xdev)
 #endif
 	intel_xpcie_core_cleanup(&xdev->xpcie);
 
+#ifdef XLINK_PCIE_RH_DRV_AER
+	pci_disable_pcie_error_reporting(xdev->pci);
+#endif
 	intel_xpcie_pci_unmap_bar(xdev);
 	pci_release_regions(xdev->pci);
 	pci_disable_device(xdev->pci);
-- 
2.27.0

