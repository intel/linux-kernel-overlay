From 24a95379c5151888dc838aad5a4b5a3850fadab4 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Ville=20Syrj=C3=A4l=C3=A4?= <ville.syrjala@linux.intel.com>
Date: Tue, 11 May 2021 19:05:27 +0300
Subject: [PATCH 295/363] drm/i915: Extract intel_hdmi_bpc_possible()
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Extract intel_hdmi_bpc_possible() from intel_hdmi_deep_color_possible()
so that we can reuse it for mode validation.

Cc: Werner Sembach <wse@tuxedocomputers.com>
Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20210511160532.21446-2-ville.syrjala@linux.intel.com
Reviewed-by: José Roberto de Souza <jose.souza@intel.com>
---
 drivers/gpu/drm/i915/display/intel_hdmi.c | 46 +++++++++++++----------
 1 file changed, 27 insertions(+), 19 deletions(-)

diff --git a/drivers/gpu/drm/i915/display/intel_hdmi.c b/drivers/gpu/drm/i915/display/intel_hdmi.c
index 4a1b2d863b0c..df5fb0741c8e 100644
--- a/drivers/gpu/drm/i915/display/intel_hdmi.c
+++ b/drivers/gpu/drm/i915/display/intel_hdmi.c
@@ -1865,6 +1865,31 @@ static int intel_hdmi_port_clock(int clock, int bpc)
 	return clock * bpc / 8;
 }
 
+static bool intel_hdmi_bpc_possible(struct drm_connector *connector,
+				    int bpc, bool has_hdmi_sink, bool ycbcr420_output)
+{
+	const struct drm_display_info *info = &connector->display_info;
+	const struct drm_hdmi_info *hdmi = &info->hdmi;
+
+	switch (bpc) {
+	case 12:
+		if (ycbcr420_output)
+			return hdmi->y420_dc_modes & DRM_EDID_YCBCR420_DC_36;
+		else
+			return info->edid_hdmi_dc_modes & DRM_EDID_HDMI_DC_36;
+	case 10:
+		if (ycbcr420_output)
+			return hdmi->y420_dc_modes & DRM_EDID_YCBCR420_DC_30;
+		else
+			return info->edid_hdmi_dc_modes & DRM_EDID_HDMI_DC_30;
+	case 8:
+		return true;
+	default:
+		MISSING_CASE(bpc);
+		return false;
+	}
+}
+
 static enum drm_mode_status
 intel_hdmi_mode_clock_valid(struct intel_hdmi *hdmi, int clock, bool has_hdmi_sink)
 {
@@ -1954,28 +1979,11 @@ bool intel_hdmi_deep_color_possible(const struct intel_crtc_state *crtc_state,
 		return false;
 
 	for_each_new_connector_in_state(state, connector, connector_state, i) {
-		const struct drm_display_info *info = &connector->display_info;
-
 		if (connector_state->crtc != crtc_state->uapi.crtc)
 			continue;
 
-		if (ycbcr420_output) {
-			const struct drm_hdmi_info *hdmi = &info->hdmi;
-
-			if (bpc == 12 && !(hdmi->y420_dc_modes &
-					   DRM_EDID_YCBCR420_DC_36))
-				return false;
-			else if (bpc == 10 && !(hdmi->y420_dc_modes &
-						DRM_EDID_YCBCR420_DC_30))
-				return false;
-		} else {
-			if (bpc == 12 && !(info->edid_hdmi_dc_modes &
-					   DRM_EDID_HDMI_DC_36))
-				return false;
-			else if (bpc == 10 && !(info->edid_hdmi_dc_modes &
-						DRM_EDID_HDMI_DC_30))
-				return false;
-		}
+		if (!intel_hdmi_bpc_possible(connector, bpc, has_hdmi_sink, ycbcr420_output))
+			return false;
 	}
 
 	return true;
-- 
2.27.0

