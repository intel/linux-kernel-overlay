From e3bf3be8f7e22cebcc7ce116d62e64e4768bfc43 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Christian=20K=C3=B6nig?= <christian.koenig@amd.com>
Date: Thu, 17 Sep 2020 13:27:35 +0200
Subject: [PATCH 0017/1714] drm/ttm: remove persistent_swap_storage
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Not used any more. Cleanup the code as well while at it.

Signed-off-by: Christian KÃ¶nig <christian.koenig@amd.com>
Link: https://patchwork.freedesktop.org/patch/391079/?series=81804&rev=1
Reviewed-by: Dave Airlie <airlied@redhat.com>
---
 drivers/gpu/drm/ttm/ttm_bo.c |  2 +-
 drivers/gpu/drm/ttm/ttm_tt.c | 63 ++++++++++++++++--------------------
 include/drm/ttm/ttm_bo_api.h |  4 ---
 include/drm/ttm/ttm_tt.h     |  3 +-
 4 files changed, 30 insertions(+), 42 deletions(-)

diff --git a/drivers/gpu/drm/ttm/ttm_bo.c b/drivers/gpu/drm/ttm/ttm_bo.c
index 4ead5ebedd38..8b4eb2aea8b0 100644
--- a/drivers/gpu/drm/ttm/ttm_bo.c
+++ b/drivers/gpu/drm/ttm/ttm_bo.c
@@ -1583,7 +1583,7 @@ int ttm_bo_swapout(struct ttm_bo_global *glob, struct ttm_operation_ctx *ctx)
 	if (bo->bdev->driver->swap_notify)
 		bo->bdev->driver->swap_notify(bo);
 
-	ret = ttm_tt_swapout(bo->bdev, bo->ttm, bo->persistent_swap_storage);
+	ret = ttm_tt_swapout(bo->bdev, bo->ttm);
 out:
 
 	/**
diff --git a/drivers/gpu/drm/ttm/ttm_tt.c b/drivers/gpu/drm/ttm/ttm_tt.c
index 87dd887f7806..23e9604bc924 100644
--- a/drivers/gpu/drm/ttm/ttm_tt.c
+++ b/drivers/gpu/drm/ttm/ttm_tt.c
@@ -148,8 +148,7 @@ void ttm_tt_destroy_common(struct ttm_bo_device *bdev, struct ttm_tt *ttm)
 {
 	ttm_tt_unpopulate(bdev, ttm);
 
-	if (!(ttm->page_flags & TTM_PAGE_FLAG_PERSISTENT_SWAP) &&
-	    ttm->swap_storage)
+	if (ttm->swap_storage)
 		fput(ttm->swap_storage);
 
 	ttm->swap_storage = NULL;
@@ -249,71 +248,67 @@ int ttm_tt_swapin(struct ttm_tt *ttm)
 	struct file *swap_storage;
 	struct page *from_page;
 	struct page *to_page;
-	int i;
-	int ret = -ENOMEM;
+	gfp_t gfp_mask;
+	int i, ret;
 
 	swap_storage = ttm->swap_storage;
 	BUG_ON(swap_storage == NULL);
 
 	swap_space = swap_storage->f_mapping;
+	gfp_mask = mapping_gfp_mask(swap_space);
+	if (ttm->page_flags & TTM_PAGE_FLAG_NO_RETRY)
+		gfp_mask |= __GFP_RETRY_MAYFAIL;
 
 	for (i = 0; i < ttm->num_pages; ++i) {
-		gfp_t gfp_mask = mapping_gfp_mask(swap_space);
-
-		gfp_mask |= (ttm->page_flags & TTM_PAGE_FLAG_NO_RETRY ? __GFP_RETRY_MAYFAIL : 0);
-		from_page = shmem_read_mapping_page_gfp(swap_space, i, gfp_mask);
-
+		from_page = shmem_read_mapping_page_gfp(swap_space, i,
+							gfp_mask);
 		if (IS_ERR(from_page)) {
 			ret = PTR_ERR(from_page);
 			goto out_err;
 		}
 		to_page = ttm->pages[i];
-		if (unlikely(to_page == NULL))
+		if (unlikely(to_page == NULL)) {
+			ret = -ENOMEM;
 			goto out_err;
+		}
 
 		copy_highpage(to_page, from_page);
 		put_page(from_page);
 	}
 
-	if (!(ttm->page_flags & TTM_PAGE_FLAG_PERSISTENT_SWAP))
-		fput(swap_storage);
+	fput(swap_storage);
 	ttm->swap_storage = NULL;
 	ttm->page_flags &= ~TTM_PAGE_FLAG_SWAPPED;
 
 	return 0;
+
 out_err:
 	return ret;
 }
 
-int ttm_tt_swapout(struct ttm_bo_device *bdev,
-		   struct ttm_tt *ttm, struct file *persistent_swap_storage)
+int ttm_tt_swapout(struct ttm_bo_device *bdev, struct ttm_tt *ttm)
 {
 	struct address_space *swap_space;
 	struct file *swap_storage;
 	struct page *from_page;
 	struct page *to_page;
-	int i;
-	int ret = -ENOMEM;
-
-	if (!persistent_swap_storage) {
-		swap_storage = shmem_file_setup("ttm swap",
-						ttm->num_pages << PAGE_SHIFT,
-						0);
-		if (IS_ERR(swap_storage)) {
-			pr_err("Failed allocating swap storage\n");
-			return PTR_ERR(swap_storage);
-		}
-	} else {
-		swap_storage = persistent_swap_storage;
+	gfp_t gfp_mask;
+	int i, ret;
+
+	swap_storage = shmem_file_setup("ttm swap",
+					ttm->num_pages << PAGE_SHIFT,
+					0);
+	if (IS_ERR(swap_storage)) {
+		pr_err("Failed allocating swap storage\n");
+		return PTR_ERR(swap_storage);
 	}
 
 	swap_space = swap_storage->f_mapping;
+	gfp_mask = mapping_gfp_mask(swap_space);
+	if (ttm->page_flags & TTM_PAGE_FLAG_NO_RETRY)
+		gfp_mask |= __GFP_RETRY_MAYFAIL;
 
 	for (i = 0; i < ttm->num_pages; ++i) {
-		gfp_t gfp_mask = mapping_gfp_mask(swap_space);
-
-		gfp_mask |= (ttm->page_flags & TTM_PAGE_FLAG_NO_RETRY ? __GFP_RETRY_MAYFAIL : 0);
-
 		from_page = ttm->pages[i];
 		if (unlikely(from_page == NULL))
 			continue;
@@ -332,13 +327,11 @@ int ttm_tt_swapout(struct ttm_bo_device *bdev,
 	ttm_tt_unpopulate(bdev, ttm);
 	ttm->swap_storage = swap_storage;
 	ttm->page_flags |= TTM_PAGE_FLAG_SWAPPED;
-	if (persistent_swap_storage)
-		ttm->page_flags |= TTM_PAGE_FLAG_PERSISTENT_SWAP;
 
 	return 0;
+
 out_err:
-	if (!persistent_swap_storage)
-		fput(swap_storage);
+	fput(swap_storage);
 
 	return ret;
 }
diff --git a/include/drm/ttm/ttm_bo_api.h b/include/drm/ttm/ttm_bo_api.h
index 6f544b6d70a3..da837d22f78e 100644
--- a/include/drm/ttm/ttm_bo_api.h
+++ b/include/drm/ttm/ttm_bo_api.h
@@ -90,9 +90,6 @@ struct ttm_tt;
  * @kref: Reference count of this buffer object. When this refcount reaches
  * zero, the object is destroyed or put on the delayed delete list.
  * @mem: structure describing current placement.
- * @persistent_swap_storage: Usually the swap storage is deleted for buffers
- * pinned in physical memory. If this behaviour is not desired, this member
- * holds a pointer to a persistent shmem object.
  * @ttm: TTM structure holding system pages.
  * @evicted: Whether the object was evicted without user-space knowing.
  * @deleted: True if the object is only a zombie and already deleted.
@@ -139,7 +136,6 @@ struct ttm_buffer_object {
 	 */
 
 	struct ttm_resource mem;
-	struct file *persistent_swap_storage;
 	struct ttm_tt *ttm;
 	bool deleted;
 
diff --git a/include/drm/ttm/ttm_tt.h b/include/drm/ttm/ttm_tt.h
index 75208c0a0cac..91691240a509 100644
--- a/include/drm/ttm/ttm_tt.h
+++ b/include/drm/ttm/ttm_tt.h
@@ -36,7 +36,6 @@ struct ttm_operation_ctx;
 
 #define TTM_PAGE_FLAG_WRITE           (1 << 3)
 #define TTM_PAGE_FLAG_SWAPPED         (1 << 4)
-#define TTM_PAGE_FLAG_PERSISTENT_SWAP (1 << 5)
 #define TTM_PAGE_FLAG_ZERO_ALLOC      (1 << 6)
 #define TTM_PAGE_FLAG_DMA32           (1 << 7)
 #define TTM_PAGE_FLAG_SG              (1 << 8)
@@ -185,7 +184,7 @@ int ttm_tt_swapin(struct ttm_tt *ttm);
  * and cache flushes and potential page splitting / combining.
  */
 int ttm_tt_set_placement_caching(struct ttm_tt *ttm, uint32_t placement);
-int ttm_tt_swapout(struct ttm_bo_device *bdev, struct ttm_tt *ttm, struct file *persistent_swap_storage);
+int ttm_tt_swapout(struct ttm_bo_device *bdev, struct ttm_tt *ttm);
 
 /**
  * ttm_tt_populate - allocate pages for a ttm
-- 
2.25.1

