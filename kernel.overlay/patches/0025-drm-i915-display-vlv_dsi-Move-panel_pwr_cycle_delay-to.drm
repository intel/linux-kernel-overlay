From 30d9fc839f90e5e9f00f76293f995e5f504f6461 Mon Sep 17 00:00:00 2001
From: Hans de Goede <hdegoede@redhat.com>
Date: Thu, 25 Mar 2021 12:48:23 +0100
Subject: [PATCH 0025/1247] drm/i915/display/vlv_dsi: Move
 panel_pwr_cycle_delay to next panel-on
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Instead of sleeping panel_pwr_cycle_delay ms when turning the panel off,
record the time it is turned off and if necessary wait any (remaining)
time when the panel is turned on again.

Also sleep the remaining time on shutdown, because on reboot the
GOP will immediately turn on the panel again.

Cc: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
Signed-off-by: Hans de Goede <hdegoede@redhat.com>
Reviewed-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20210325114823.44922-2-hdegoede@redhat.com
---
 drivers/gpu/drm/i915/display/intel_dsi.h |  1 +
 drivers/gpu/drm/i915/display/vlv_dsi.c   | 25 ++++++++++++++++++------
 2 files changed, 20 insertions(+), 6 deletions(-)

diff --git a/drivers/gpu/drm/i915/display/intel_dsi.h b/drivers/gpu/drm/i915/display/intel_dsi.h
index 625f2f1ae061..50d6da0b2419 100644
--- a/drivers/gpu/drm/i915/display/intel_dsi.h
+++ b/drivers/gpu/drm/i915/display/intel_dsi.h
@@ -124,6 +124,7 @@ struct intel_dsi {
 	u16 panel_on_delay;
 	u16 panel_off_delay;
 	u16 panel_pwr_cycle_delay;
+	ktime_t panel_power_off_time;
 };
 
 struct intel_dsi_host {
diff --git a/drivers/gpu/drm/i915/display/vlv_dsi.c b/drivers/gpu/drm/i915/display/vlv_dsi.c
index f461a8f03e19..cf51860a1429 100644
--- a/drivers/gpu/drm/i915/display/vlv_dsi.c
+++ b/drivers/gpu/drm/i915/display/vlv_dsi.c
@@ -714,6 +714,19 @@ static void intel_dsi_port_disable(struct intel_encoder *encoder)
 	}
 }
 
+static void intel_dsi_wait_panel_power_cycle(struct intel_dsi *intel_dsi)
+{
+	ktime_t panel_power_on_time;
+	s64 panel_power_off_duration;
+
+	panel_power_on_time = ktime_get_boottime();
+	panel_power_off_duration = ktime_ms_delta(panel_power_on_time,
+						  intel_dsi->panel_power_off_time);
+
+	if (panel_power_off_duration < (s64)intel_dsi->panel_pwr_cycle_delay)
+		msleep(intel_dsi->panel_pwr_cycle_delay - panel_power_off_duration);
+}
+
 static void intel_dsi_prepare(struct intel_encoder *intel_encoder,
 			      const struct intel_crtc_state *pipe_config);
 static void intel_dsi_unprepare(struct intel_encoder *encoder);
@@ -775,6 +788,8 @@ static void intel_dsi_pre_enable(struct intel_atomic_state *state,
 
 	drm_dbg_kms(&dev_priv->drm, "\n");
 
+	intel_dsi_wait_panel_power_cycle(intel_dsi);
+
 	intel_set_cpu_fifo_underrun_reporting(dev_priv, pipe, true);
 
 	/*
@@ -989,18 +1004,14 @@ static void intel_dsi_post_disable(struct intel_atomic_state *state,
 	intel_dsi_msleep(intel_dsi, intel_dsi->panel_off_delay);
 	intel_dsi_vbt_exec_sequence(intel_dsi, MIPI_SEQ_POWER_OFF);
 
-	/*
-	 * FIXME As we do with eDP, just make a note of the time here
-	 * and perform the wait before the next panel power on.
-	 */
-	msleep(intel_dsi->panel_pwr_cycle_delay);
+	intel_dsi->panel_power_off_time = ktime_get_boottime();
 }
 
 static void intel_dsi_shutdown(struct intel_encoder *encoder)
 {
 	struct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);
 
-	msleep(intel_dsi->panel_pwr_cycle_delay);
+	intel_dsi_wait_panel_power_cycle(intel_dsi);
 }
 
 static bool intel_dsi_get_hw_state(struct intel_encoder *encoder,
@@ -1883,6 +1894,8 @@ void vlv_dsi_init(struct drm_i915_private *dev_priv)
 	else
 		intel_encoder->pipe_mask = BIT(PIPE_B);
 
+	intel_dsi->panel_power_off_time = ktime_get_boottime();
+
 	if (dev_priv->vbt.dsi.config->dual_link)
 		intel_dsi->ports = BIT(PORT_A) | BIT(PORT_C);
 	else
-- 
2.27.0

