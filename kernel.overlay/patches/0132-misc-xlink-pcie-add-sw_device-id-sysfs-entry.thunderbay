From 87b18f254e3aedf37681bf1ad17e69016db88213 Mon Sep 17 00:00:00 2001
From: kadarlax <raghuveerx.kadarla@intel.com>
Date: Fri, 16 Apr 2021 17:34:59 +0530
Subject: [PATCH 132/170] misc: xlink-pcie: add sw_device id sysfs entry

Added sysfs entry for sw_device id on successful detection of
xlink pcie function device.(HSD_1508757233)

Signed-off-by: kadarlax <raghuveerx.kadarla@intel.com>
---
 drivers/misc/xlink-pcie/common/xpcie.h    |  3 +
 drivers/misc/xlink-pcie/local_host/core.c | 20 -------
 drivers/misc/xlink-pcie/local_host/epf.c  | 69 ++++++++++++++++++++++-
 drivers/misc/xlink-pcie/local_host/epf.h  |  7 +++
 drivers/misc/xlink-pcie/remote_host/pci.c |  6 +-
 5 files changed, 80 insertions(+), 25 deletions(-)

diff --git a/drivers/misc/xlink-pcie/common/xpcie.h b/drivers/misc/xlink-pcie/common/xpcie.h
index 3d44325bd15b..d2f6d71ae06b 100644
--- a/drivers/misc/xlink-pcie/common/xpcie.h
+++ b/drivers/misc/xlink-pcie/common/xpcie.h
@@ -138,6 +138,9 @@ struct xpcie {
 	struct tasklet_struct rx_tasklet;
 	struct hrtimer free_rx_bd_timer;
 #endif
+	struct device_attribute swdev_id;
+	bool swdev_avail;
+
 };
 
 #endif /* XPCIE_HEADER_ */
diff --git a/drivers/misc/xlink-pcie/local_host/core.c b/drivers/misc/xlink-pcie/local_host/core.c
index fd894ca37884..ca1fe960e7d5 100644
--- a/drivers/misc/xlink-pcie/local_host/core.c
+++ b/drivers/misc/xlink-pcie/local_host/core.c
@@ -475,10 +475,6 @@ static irqreturn_t intel_xpcie_core_irq_cb(int irq, void *args)
 {
 	struct xpcie *xpcie = args;
 #if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
-	u16 phy_id = 0;
-	u8 max_functions = 0, func_no = 0;
-	struct xpcie_epf *xpcie_epf =
-		container_of(xpcie, struct xpcie_epf, xpcie);
 	/*clear the interrupt*/
 	writel(0x1, xpcie->doorbell_clear);
 #endif
@@ -491,22 +487,6 @@ static irqreturn_t intel_xpcie_core_irq_cb(int irq, void *args)
 		if (xpcie->tx_pending)
 			intel_xpcie_start_tx(xpcie, 0);
 	}
-#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
-	if (intel_xpcie_get_doorbell(xpcie, TO_DEVICE, PHY_ID_UPDATED)) {
-		intel_xpcie_set_doorbell(xpcie, TO_DEVICE, PHY_ID_UPDATED, 0);
-		if (!xpcie_epf->sw_dev_id_updated) {
-			phy_id = intel_xpcie_get_physical_device_id(xpcie);
-			max_functions = intel_xpcie_get_max_functions(xpcie);
-			func_no = xpcie_epf->epf->func_no;
-			xpcie_epf->sw_devid =
-				intel_xpcie_create_sw_device_id(func_no, phy_id, max_functions);
-			xpcie_epf->sw_dev_id_updated = true;
-			dev_info(xpcie_to_dev(xpcie),
-					"pcie: func_no=%x swid updated=%x phy_id=%x\n",
-					func_no, xpcie_epf->sw_devid, phy_id);
-		}
-	}
-#endif
 	if (intel_xpcie_get_doorbell(xpcie, TO_DEVICE,
 				     PARTIAL_DATA_RECEIVED)) {
 		intel_xpcie_set_doorbell(xpcie, TO_DEVICE,
diff --git a/drivers/misc/xlink-pcie/local_host/epf.c b/drivers/misc/xlink-pcie/local_host/epf.c
index 96fb070a1c54..c41700003bfa 100644
--- a/drivers/misc/xlink-pcie/local_host/epf.c
+++ b/drivers/misc/xlink-pcie/local_host/epf.c
@@ -179,7 +179,10 @@ static irqreturn_t intel_xpcie_host_interrupt(int irq, void *args)
 	struct xpcie_epf *xpcie_epf = container_of(xpcie,
 						   struct xpcie_epf, xpcie);
 	u8 event;
-#if (!IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
+#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
+	u16 phy_id = 0;
+	u8 max_functions = 0;
+#else
 	u32 val;
 
 	val = ioread32(xpcie_epf->apb_base + PCIE_REGS_PCIE_INTR_FLAGS);
@@ -196,8 +199,26 @@ static irqreturn_t intel_xpcie_host_interrupt(int irq, void *args)
 		return IRQ_HANDLED;
 	}
 
+#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
+	if (intel_xpcie_get_doorbell(xpcie, TO_DEVICE, PHY_ID_UPDATED)) {
+		intel_xpcie_set_doorbell(xpcie, TO_DEVICE, PHY_ID_UPDATED, 0);
+		if (!xpcie_epf->sw_dev_id_updated) {
+			phy_id = intel_xpcie_get_physical_device_id(xpcie);
+			max_functions = intel_xpcie_get_max_functions(xpcie);
+			xpcie_epf->sw_devid =
+				intel_xpcie_create_sw_device_id(xpcie_epf->epf->func_no, phy_id, max_functions);
+			xpcie_epf->sw_dev_id_updated = true;
+			dev_info(xpcie_to_dev(xpcie),
+				 "pcie: func_no=%x swid updated=%x phy_id=%x\n",
+				 xpcie_epf->epf->func_no,
+				 xpcie_epf->sw_devid, phy_id);
+		}
+	}
+#endif
 	if (likely(xpcie_epf->core_irq_callback))
 		xpcie_epf->core_irq_callback(irq, xpcie);
+	else
+		writel(0x1, xpcie->doorbell_clear); /* clearing the interrupt */
 
 	return IRQ_HANDLED;
 }
@@ -660,6 +681,47 @@ static int intel_xpcie_epf_get_platform_data(struct device *dev,
 }
 #endif
 
+static ssize_t swdev_id_show(struct device *dev,
+			     struct device_attribute *attr,
+			     char *buf)
+{
+	struct pci_epf *epf = container_of(dev, struct pci_epf, dev);
+	struct xpcie_epf *xpcie_epf = epf_get_drvdata(epf);
+	struct xpcie *xpcie = &xpcie_epf->xpcie;
+
+	if (xpcie->swdev_avail)
+		snprintf(buf, 4096, "%s\n", "okay");
+	else
+		snprintf(buf, 4096, "%s\n", "disabled");
+
+	return strlen(buf);
+}
+
+static ssize_t swdev_id_store(struct device *dev,
+			      struct device_attribute *attr,
+			      const char *buf, size_t count)
+{
+	return count;
+}
+
+static DEVICE_ATTR(swdev_id, S_IRWXU, swdev_id_show, swdev_id_store);
+
+void intel_xpcie_init_sysfs_swdev_id(struct xpcie *xpcie, struct device *dev)
+{
+	xpcie->swdev_id = dev_attr_swdev_id;
+	xpcie->swdev_avail = false;
+
+	device_create_file(dev, &xpcie->swdev_id);
+}
+
+void intel_xpcie_uninit_sysfs_swdev_id(struct xpcie *xpcie, struct device *dev)
+{
+	if (xpcie->swdev_avail) {
+		device_remove_file(dev, &xpcie->swdev_id);
+		xpcie->swdev_avail = false;
+	}
+}
+
 static int intel_xpcie_epf_bind(struct pci_epf *epf)
 {
 	struct xpcie_epf *xpcie_epf = epf_get_drvdata(epf);
@@ -771,6 +833,9 @@ static int intel_xpcie_epf_bind(struct pci_epf *epf)
 	memcpy(xpcie_epf->xpcie.io_comm + XPCIE_IO_COMM_MAGIC_OFF,
 	       XPCIE_BOOT_MAGIC_YOCTO, strlen(XPCIE_BOOT_MAGIC_YOCTO));
 
+	intel_xpcie_init_sysfs_swdev_id(&xpcie_epf->xpcie,
+					&xpcie_epf->epf->dev);
+
 	return 0;
 
 err_uninit_dma:
@@ -794,6 +859,8 @@ static void intel_xpcie_epf_unbind(struct pci_epf *epf)
 	intel_xpcie_core_cleanup(&xpcie_epf->xpcie);
 	intel_xpcie_set_device_status(&xpcie_epf->xpcie, XPCIE_STATUS_READY);
 
+	intel_xpcie_uninit_sysfs_swdev_id(&xpcie_epf->xpcie,
+					  &xpcie_epf->epf->dev);
 	intel_xpcie_ep_dma_uninit(epf);
 
 	pci_epc_stop(epc);
diff --git a/drivers/misc/xlink-pcie/local_host/epf.h b/drivers/misc/xlink-pcie/local_host/epf.h
index 4b2c1aeb25c6..916f38f20bb5 100644
--- a/drivers/misc/xlink-pcie/local_host/epf.h
+++ b/drivers/misc/xlink-pcie/local_host/epf.h
@@ -137,4 +137,11 @@ int intel_xpcie_copy_from_host_ll(struct xpcie *xpcie,
 				  int chan, int descs_num);
 int intel_xpcie_copy_to_host_ll(struct xpcie *xpcie,
 				int chan, int descs_num);
+
+/*
+ * Sysfs entry for sw device id.
+ */
+void intel_xpcie_init_sysfs_swdev_id(struct xpcie *xpcie, struct device *dev);
+void intel_xpcie_uninit_sysfs_swdev_id(struct xpcie *xpcie, struct device *dev);
+
 #endif /* XPCIE_EPF_HEADER_ */
diff --git a/drivers/misc/xlink-pcie/remote_host/pci.c b/drivers/misc/xlink-pcie/remote_host/pci.c
index 2a9eee08c09e..0cf6091d1221 100644
--- a/drivers/misc/xlink-pcie/remote_host/pci.c
+++ b/drivers/misc/xlink-pcie/remote_host/pci.c
@@ -282,14 +282,12 @@ static void xpcie_device_poll(struct work_struct *work)
 			 "sw_devid=%x, function idx=%d, max_functions=%d\n",
 			 xdev->sw_devid,
 			 PCI_FUNC(xdev->pci->devfn), max_functions);
+		intel_xpcie_pci_raise_irq(xdev, PHY_ID_UPDATED, 1);
 
-		intel_xpcie_set_doorbell(&xdev->xpcie, TO_DEVICE,
-					 PHY_ID_UPDATED, 1);
-		iowrite32(1, xdev->xpcie.doorbell_base);
 		return;
 #endif
 	}
-	schedule_delayed_work(&xdev->wait_event, msecs_to_jiffies(1000));
+	schedule_delayed_work(&xdev->wait_event, msecs_to_jiffies(2000));
 }
 
 static int intel_xpcie_pci_prepare_dev_reset(struct xpcie_dev *xdev,
-- 
2.27.0

