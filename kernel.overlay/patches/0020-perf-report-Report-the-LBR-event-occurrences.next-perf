From b1607f69fc8bce019c9084bfad8bc6d6c2bb7ffe Mon Sep 17 00:00:00 2001
From: Jin Yao <yao.jin@linux.intel.com>
Date: Tue, 11 May 2021 14:07:53 +0800
Subject: [PATCH 20/47] perf report: Report the LBR event occurrences

perf report has supported option '--total-cycles' to sort all LBR blocks
by 'Sampled Cycles%'. This is useful to concentrate on the globally hottest
blocks.

Following columns are supported in display:
  'Sampled Cycles%'
  'Sampled Cycles'
  'Avg Cycles%'
  'Avg Cycles'

Now we add new columns for events, which are the indications of precise
events occurrences in LBRs. The column name is the event name.

For example,

  perf record -b -e cpu/cpu-cycles/B,cpu/instructions/B -- ./triad_loop
  perf report --total-cycles --stdio

  # Total Lost Samples: 0
  #
  # Samples: 23K of event 'cycles'
  # Event count (approx.): 23680
  #
  # Sampled Cycles%  Sampled Cycles  Avg Cycles%  Avg Cycles  cpu/cpu-cycles/B  cpu/instructions/B  [Program Block Range]
  # ...............  ..............  ...........  ..........  ................  ..................  .....................
  #
             99.80%          189.1K        0.53%           4               ##+                   #
              0.06%             115       15.23%         115               ##+                   #
              0.03%              48        2.12%          16               ##+                   #
              0.01%              28        3.71%          28               ##+                   #
              0.01%              27        1.19%           9               ##+                   #
              0.01%              25        3.31%          25               ##+                   #
              0.01%              21        2.78%          21               ##+                   #
              0.01%              16        2.12%          16               ##+                   #
              0.01%              14        1.85%          14               ##+                   #
              0.00%               9        1.19%           9               ##+                   #

One '#' indicates the selected event occurred 1 time in average.
The '+' means we may lost some occurrences.

Note that, "##+" and "#" in above example are hardcoded.

Signed-off-by: Jin Yao <yao.jin@linux.intel.com>
---
 tools/perf/Documentation/perf-report.txt |   3 +
 tools/perf/builtin-report.c              |  10 --
 tools/perf/util/block-info.c             | 163 ++++++++++++++++++++---
 tools/perf/util/block-info.h             |  17 ++-
 4 files changed, 158 insertions(+), 35 deletions(-)

diff --git a/tools/perf/Documentation/perf-report.txt b/tools/perf/Documentation/perf-report.txt
index 24efc0583c93..f04fb4764609 100644
--- a/tools/perf/Documentation/perf-report.txt
+++ b/tools/perf/Documentation/perf-report.txt
@@ -570,6 +570,9 @@ include::itrace.txt[]
 	'Avg Cycles%'     - block average sampled cycles / sum of total block average
 			    sampled cycles
 	'Avg Cycles'      - block average sampled cycles
+	Event list	  - indications of precise event occurrences in LBRs
+			    one '#' indicates the selected event occurred 1 time in average.
+			    '+' means it may lost some occurrences.
 
 --skip-empty::
 	Do not print 0 results in the --stat output.
diff --git a/tools/perf/builtin-report.c b/tools/perf/builtin-report.c
index 308939502359..df807393aba9 100644
--- a/tools/perf/builtin-report.c
+++ b/tools/perf/builtin-report.c
@@ -995,18 +995,8 @@ static int __cmd_report(struct report *rep)
 	report__output_resort(rep);
 
 	if (rep->total_cycles_mode) {
-		int block_hpps[6] = {
-			PERF_HPP_REPORT__BLOCK_TOTAL_CYCLES_PCT,
-			PERF_HPP_REPORT__BLOCK_LBR_CYCLES,
-			PERF_HPP_REPORT__BLOCK_CYCLES_PCT,
-			PERF_HPP_REPORT__BLOCK_AVG_CYCLES,
-			PERF_HPP_REPORT__BLOCK_RANGE,
-			PERF_HPP_REPORT__BLOCK_DSO,
-		};
-
 		rep->block_reports = block_info__create_report(session->evlist,
 							       rep->total_cycles,
-							       block_hpps, 6,
 							       &rep->nr_block_reports);
 		if (!rep->block_reports)
 			return -1;
diff --git a/tools/perf/util/block-info.c b/tools/perf/util/block-info.c
index 5ecd4f401f32..33ccf80a7b03 100644
--- a/tools/perf/util/block-info.c
+++ b/tools/perf/util/block-info.c
@@ -11,6 +11,7 @@
 #include "srcline.h"
 #include "evlist.h"
 #include "hist.h"
+#include "strbuf.h"
 #include "ui/browsers/hists.h"
 
 static struct block_header_column {
@@ -40,7 +41,11 @@ static struct block_header_column {
 	[PERF_HPP_REPORT__BLOCK_DSO] = {
 		.name = "Shared Object",
 		.width = 20,
-	}
+	},
+	[PERF_HPP_REPORT__BLOCK_BRANCH_EVENT] = {
+		.name = "Unknown Event",
+		.width = 13,
+	},
 };
 
 struct block_info *block_info__get(struct block_info *bi)
@@ -96,6 +101,15 @@ int64_t block_info__cmp(struct perf_hpp_fmt *fmt __maybe_unused,
 	return __block_info__cmp(left, right);
 }
 
+static void init_branch_events(struct block_info *bi, struct cyc_hist *ch)
+{
+	for (int i = 0; i < PERF_MAX_BRANCH_EVENTS; i++) {
+		bi->event_occurs[i] = (u32)((float)ch->event_occurs[i] /
+					    (float)ch->num + 0.5);
+		bi->max_occurs[i] = ch->max_occurs[i];
+	}
+}
+
 static void init_block_info(struct block_info *bi, struct symbol *sym,
 			    struct cyc_hist *ch, int offset,
 			    u64 total_cycles)
@@ -108,6 +122,7 @@ static void init_block_info(struct block_info *bi, struct symbol *sym,
 	bi->num = ch->num;
 	bi->num_aggr = ch->num_aggr;
 	bi->total_cycles = total_cycles;
+	init_branch_events(bi, ch);
 
 	memcpy(bi->cycles_spark, ch->cycles_spark,
 	       NUM_SPARKS * sizeof(u64));
@@ -167,6 +182,12 @@ static int block_column_header(struct perf_hpp_fmt *fmt,
 			       int *span __maybe_unused)
 {
 	struct block_fmt *block_fmt = container_of(fmt, struct block_fmt, fmt);
+	struct evsel *evsel = block_fmt->evsel;
+
+	if (evsel) {
+		return scnprintf(hpp->buf, hpp->size, "%*s",
+				 block_fmt->width, evsel->name);
+	}
 
 	return scnprintf(hpp->buf, hpp->size, "%*s", block_fmt->width,
 			 block_fmt->header);
@@ -326,14 +347,53 @@ static int block_dso_entry(struct perf_hpp_fmt *fmt, struct perf_hpp *hpp,
 			 "[unknown]");
 }
 
+static int block_branch_event_entry(struct perf_hpp_fmt *fmt,
+                                   struct perf_hpp *hpp,
+                                   struct hist_entry *he)
+{
+	struct block_fmt *block_fmt = container_of(fmt, struct block_fmt, fmt);
+	struct block_info *bi = he->block_info;
+	struct evsel *evsel = block_fmt->evsel;
+	struct strbuf buf;
+	int ret;
+
+	if (evsel->idx >= PERF_MAX_BRANCH_EVENTS) {
+		return scnprintf(hpp->buf, hpp->size, "%*s",
+				 block_fmt->width, "n/a");
+	}
+
+	if (bi->event_occurs[evsel->idx] == 0) {
+		return scnprintf(hpp->buf, hpp->size, "%*s",
+				 block_fmt->width, "-");
+	}
+
+	if (strbuf_init(&buf, 64) < 0)
+		return -1;
+
+	for (unsigned int i = 0; i < bi->event_occurs[evsel->idx]; i++)
+		strbuf_addch(&buf, '#');
+
+	if (bi->max_occurs[evsel->idx])
+		strbuf_addch(&buf, '+');
+
+	ret = scnprintf(hpp->buf, hpp->size, "%*s", block_fmt->width, buf.buf);
+	strbuf_release(&buf);
+	return ret;
+}
+
 static void init_block_header(struct block_fmt *block_fmt)
 {
 	struct perf_hpp_fmt *fmt = &block_fmt->fmt;
+	struct evsel *evsel = block_fmt->evsel;
 
 	BUG_ON(block_fmt->idx >= PERF_HPP_REPORT__BLOCK_MAX_INDEX);
 
-	block_fmt->header = block_columns[block_fmt->idx].name;
-	block_fmt->width = block_columns[block_fmt->idx].width;
+	if (evsel && evsel->name) {
+		block_fmt->width = strlen(evsel->name);
+	} else {
+		block_fmt->header = block_columns[block_fmt->idx].name;
+		block_fmt->width = block_columns[block_fmt->idx].width;
+	}
 
 	fmt->header = block_column_header;
 	fmt->width = block_column_width;
@@ -369,6 +429,9 @@ static void hpp_register(struct block_fmt *block_fmt, int idx,
 	case PERF_HPP_REPORT__BLOCK_DSO:
 		fmt->entry = block_dso_entry;
 		break;
+	case PERF_HPP_REPORT__BLOCK_BRANCH_EVENT:
+		fmt->entry = block_branch_event_entry;
+		break;
 	default:
 		return;
 	}
@@ -379,40 +442,66 @@ static void hpp_register(struct block_fmt *block_fmt, int idx,
 
 static void register_block_columns(struct perf_hpp_list *hpp_list,
 				   struct block_fmt *block_fmts,
-				   int *block_hpps, int nr_hpps)
+				   int *block_hpps, int nr_hpps,
+				   struct evlist *evlist)
 {
-	for (int i = 0; i < nr_hpps; i++)
+	struct evsel *evsel;
+	int i;
+
+	for (i = 0; i < nr_hpps; i++) {
+		if (block_hpps[i] != PERF_HPP_REPORT__BLOCK_BRANCH_EVENT)
+			hpp_register(&block_fmts[i], block_hpps[i], hpp_list);
+		else
+			break;
+	}
+
+	while (i < nr_hpps) {
+		if (block_hpps[i] != PERF_HPP_REPORT__BLOCK_BRANCH_EVENT)
+			break;
+
+		evlist__for_each_entry(evlist, evsel) {
+			if (i >= nr_hpps)
+				break;
+
+			if (evsel->core.attr.branch_events) {
+				block_fmts[i].evsel = evsel;
+				hpp_register(&block_fmts[i], block_hpps[i], hpp_list);
+				i++;
+			}
+		}
+		break;
+	}
+
+	for (; i < nr_hpps; i++)
 		hpp_register(&block_fmts[i], block_hpps[i], hpp_list);
 }
 
 static void init_block_hist(struct block_hist *bh, struct block_fmt *block_fmts,
-			    int *block_hpps, int nr_hpps)
+			    int *block_hpps, int nr_hpps, struct evlist *evlist)
 {
 	__hists__init(&bh->block_hists, &bh->block_list);
 	perf_hpp_list__init(&bh->block_list);
 	bh->block_list.nr_header_lines = 1;
 
 	register_block_columns(&bh->block_list, block_fmts,
-			       block_hpps, nr_hpps);
+			       block_hpps, nr_hpps, evlist);
 
 	/* Sort by the first fmt */
 	perf_hpp_list__register_sort_field(&bh->block_list, &block_fmts[0].fmt);
 }
 
-static int process_block_report(struct hists *hists,
+static int process_block_report(struct evsel *evsel,
 				struct block_report *block_report,
 				u64 total_cycles, int *block_hpps,
-				int nr_hpps)
+				int nr_hpps, struct evlist *evlist)
 {
+	struct hists *hists = evsel__hists(evsel);
 	struct rb_node *next = rb_first_cached(&hists->entries);
 	struct block_hist *bh = &block_report->hist;
 	struct hist_entry *he;
 
-	if (nr_hpps > PERF_HPP_REPORT__BLOCK_MAX_INDEX)
-		return -1;
-
 	block_report->nr_fmts = nr_hpps;
-	init_block_hist(bh, block_report->fmts, block_hpps, nr_hpps);
+	init_block_hist(bh, block_report->fmts, block_hpps, nr_hpps, evlist);
 
 	while (next) {
 		he = rb_entry(next, struct hist_entry, rb_node);
@@ -430,24 +519,56 @@ static int process_block_report(struct hists *hists,
 	return 0;
 }
 
+static int block_hpps_init(int *block_hpps, int hpps_max, int hpps_nr,
+			   struct evlist *evlist)
+{
+	int branch_events_nr = 0, i;
+	struct evsel *pos;
+
+	evlist__for_each_entry(evlist, pos) {
+		if (pos->core.attr.branch_events)
+			branch_events_nr++;
+	}
+
+	/*
+	 * 2 hpps for PERF_HPP_REPORT__BLOCK_RANGE + PERF_HPP_REPORT__BLOCK_DSO
+	 */
+	if (hpps_nr + branch_events_nr + 2 > hpps_max)
+		return -1;
+
+	for (i = hpps_nr; i < hpps_nr + branch_events_nr; i++)
+		block_hpps[i] = PERF_HPP_REPORT__BLOCK_BRANCH_EVENT;
+
+	block_hpps[i] = PERF_HPP_REPORT__BLOCK_RANGE;
+	block_hpps[++i] = PERF_HPP_REPORT__BLOCK_DSO;
+	return i;
+}
+
 struct block_report *block_info__create_report(struct evlist *evlist,
-					       u64 total_cycles,
-					       int *block_hpps, int nr_hpps,
-					       int *nr_reps)
+					       u64 total_cycles, int *nr_reps)
 {
 	struct block_report *block_reports;
-	int nr_hists = evlist->core.nr_entries, i = 0;
+	int nr_hists = evlist->core.nr_entries, i = 0, nr_hpps;
 	struct evsel *pos;
+	int block_hpps[PERF_HPP_REPORT__BLOCK_MAX_INDEX] = {
+		PERF_HPP_REPORT__BLOCK_TOTAL_CYCLES_PCT,
+		PERF_HPP_REPORT__BLOCK_LBR_CYCLES,
+		PERF_HPP_REPORT__BLOCK_CYCLES_PCT,
+		PERF_HPP_REPORT__BLOCK_AVG_CYCLES,
+	};
+
+	nr_hpps = block_hpps_init(block_hpps, PERF_HPP_REPORT__BLOCK_MAX_INDEX,
+				  4, evlist);
+	if (nr_hpps <= 0)
+		return NULL;
 
 	block_reports = calloc(nr_hists, sizeof(struct block_report));
 	if (!block_reports)
 		return NULL;
 
 	evlist__for_each_entry(evlist, pos) {
-		struct hists *hists = evsel__hists(pos);
-
-		process_block_report(hists, &block_reports[i], total_cycles,
-				     block_hpps, nr_hpps);
+		process_block_report(pos, &block_reports[i], total_cycles,
+				     block_hpps, nr_hpps, evlist);
 		i++;
 	}
 
diff --git a/tools/perf/util/block-info.h b/tools/perf/util/block-info.h
index 42e9dcc4cf0a..b9a1e4e5f190 100644
--- a/tools/perf/util/block-info.h
+++ b/tools/perf/util/block-info.h
@@ -4,6 +4,7 @@
 
 #include <linux/types.h>
 #include <linux/refcount.h>
+#include <linux/perf_event.h>
 #include "hist.h"
 #include "symbol.h"
 #include "sort.h"
@@ -19,14 +20,20 @@ struct block_info {
 	u64			total_cycles;
 	int			num;
 	int			num_aggr;
+	int			branch_events;
+	u32			event_occurs[PERF_MAX_BRANCH_EVENTS];
+	u8			max_occurs[PERF_MAX_BRANCH_EVENTS];
 	refcount_t		refcnt;
 };
 
+struct evsel;
+
 struct block_fmt {
 	struct perf_hpp_fmt	fmt;
 	int			idx;
 	int			width;
 	const char		*header;
+	struct evsel		*evsel;
 	u64			total_cycles;
 	u64			block_cycles;
 };
@@ -38,9 +45,13 @@ enum {
 	PERF_HPP_REPORT__BLOCK_AVG_CYCLES,
 	PERF_HPP_REPORT__BLOCK_RANGE,
 	PERF_HPP_REPORT__BLOCK_DSO,
-	PERF_HPP_REPORT__BLOCK_MAX_INDEX
+	PERF_HPP_REPORT__BLOCK_FIX_MAX_INDEX,
+	PERF_HPP_REPORT__BLOCK_BRANCH_EVENT,
 };
 
+#define PERF_HPP_REPORT__BLOCK_MAX_INDEX \
+	(PERF_HPP_REPORT__BLOCK_FIX_MAX_INDEX + PERF_MAX_BRANCH_EVENTS)
+
 struct block_report {
 	struct block_hist	hist;
 	u64			cycles;
@@ -71,9 +82,7 @@ int block_info__process_sym(struct hist_entry *he, struct block_hist *bh,
 			    u64 *block_cycles_aggr, u64 total_cycles);
 
 struct block_report *block_info__create_report(struct evlist *evlist,
-					       u64 total_cycles,
-					       int *block_hpps, int nr_hpps,
-					       int *nr_reps);
+					       u64 total_cycles, int *nr_reps);
 
 void block_info__free_report(struct block_report *reps, int nr_reps);
 
-- 
2.27.0

