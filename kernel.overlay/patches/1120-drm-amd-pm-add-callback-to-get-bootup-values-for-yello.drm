From aabe27a00a282eb4aa95932c6d323da588c82084 Mon Sep 17 00:00:00 2001
From: Xiaomeng Hou <Xiaomeng.Hou@amd.com>
Date: Sun, 4 Apr 2021 11:10:02 +0800
Subject: [PATCH 1120/1247] drm/amd/pm: add callback to get bootup values for
 yellow carp

Add get_vbios_bootup_values function to get the bootup values for yellow
carp.

Signed-off-by: Xiaomeng Hou <Xiaomeng.Hou@amd.com>
Reviewed-by: Huang Rui <ray.huang@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
---
 drivers/gpu/drm/amd/pm/inc/smu_v13_0_1.h      |   2 +
 .../gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_1.c  | 136 ++++++++++++++++++
 .../drm/amd/pm/swsmu/smu13/yellow_carp_ppt.c  |   1 +
 3 files changed, 139 insertions(+)

diff --git a/drivers/gpu/drm/amd/pm/inc/smu_v13_0_1.h b/drivers/gpu/drm/amd/pm/inc/smu_v13_0_1.h
index 065f3d27b2b8..b6c976a4d578 100644
--- a/drivers/gpu/drm/amd/pm/inc/smu_v13_0_1.h
+++ b/drivers/gpu/drm/amd/pm/inc/smu_v13_0_1.h
@@ -46,6 +46,8 @@ int smu_v13_0_1_check_fw_version(struct smu_context *smu);
 
 int smu_v13_0_1_fini_smc_tables(struct smu_context *smu);
 
+int smu_v13_0_1_get_vbios_bootup_values(struct smu_context *smu);
+
 int smu_v13_0_1_set_default_dpm_tables(struct smu_context *smu);
 
 int smu_v13_0_1_set_driver_table_location(struct smu_context *smu);
diff --git a/drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_1.c b/drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_1.c
index dfbb527b25cb..61917b49f2bf 100644
--- a/drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_1.c
+++ b/drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_1.c
@@ -29,6 +29,10 @@
 #include "smu_v13_0_1.h"
 #include "soc15_common.h"
 #include "smu_cmn.h"
+#include "atomfirmware.h"
+#include "amdgpu_atomfirmware.h"
+#include "amdgpu_atombios.h"
+#include "atom.h"
 
 #include "asic_reg/mp/mp_13_0_1_offset.h"
 #include "asic_reg/mp/mp_13_0_1_sh_mask.h"
@@ -122,6 +126,138 @@ int smu_v13_0_1_fini_smc_tables(struct smu_context *smu)
 	return 0;
 }
 
+static int smu_v13_0_1_atom_get_smu_clockinfo(struct amdgpu_device *adev,
+						uint8_t clk_id,
+						uint8_t syspll_id,
+						uint32_t *clk_freq)
+{
+	struct atom_get_smu_clock_info_parameters_v3_1 input = {0};
+	struct atom_get_smu_clock_info_output_parameters_v3_1 *output;
+	int ret, index;
+
+	input.clk_id = clk_id;
+	input.syspll_id = syspll_id;
+	input.command = GET_SMU_CLOCK_INFO_V3_1_GET_CLOCK_FREQ;
+	index = get_index_into_master_table(atom_master_list_of_command_functions_v2_1,
+					    getsmuclockinfo);
+
+	ret = amdgpu_atom_execute_table(adev->mode_info.atom_context, index,
+					(uint32_t *)&input);
+	if (ret)
+		return -EINVAL;
+
+	output = (struct atom_get_smu_clock_info_output_parameters_v3_1 *)&input;
+	*clk_freq = le32_to_cpu(output->atom_smu_outputclkfreq.smu_clock_freq_hz) / 10000;
+
+	return 0;
+}
+
+int smu_v13_0_1_get_vbios_bootup_values(struct smu_context *smu)
+{
+	int ret, index;
+	uint16_t size;
+	uint8_t frev, crev;
+	struct atom_common_table_header *header;
+	struct atom_firmware_info_v3_4 *v_3_4;
+	struct atom_firmware_info_v3_3 *v_3_3;
+	struct atom_firmware_info_v3_1 *v_3_1;
+
+	index = get_index_into_master_table(atom_master_list_of_data_tables_v2_1,
+					    firmwareinfo);
+
+	ret = amdgpu_atombios_get_data_table(smu->adev, index, &size, &frev, &crev,
+					     (uint8_t **)&header);
+	if (ret)
+		return ret;
+
+	if (header->format_revision != 3) {
+		dev_err(smu->adev->dev, "unknown atom_firmware_info version! for smu13\n");
+		return -EINVAL;
+	}
+
+	switch (header->content_revision) {
+	case 0:
+	case 1:
+	case 2:
+		v_3_1 = (struct atom_firmware_info_v3_1 *)header;
+		smu->smu_table.boot_values.revision = v_3_1->firmware_revision;
+		smu->smu_table.boot_values.gfxclk = v_3_1->bootup_sclk_in10khz;
+		smu->smu_table.boot_values.uclk = v_3_1->bootup_mclk_in10khz;
+		smu->smu_table.boot_values.socclk = 0;
+		smu->smu_table.boot_values.dcefclk = 0;
+		smu->smu_table.boot_values.vddc = v_3_1->bootup_vddc_mv;
+		smu->smu_table.boot_values.vddci = v_3_1->bootup_vddci_mv;
+		smu->smu_table.boot_values.mvddc = v_3_1->bootup_mvddc_mv;
+		smu->smu_table.boot_values.vdd_gfx = v_3_1->bootup_vddgfx_mv;
+		smu->smu_table.boot_values.cooling_id = v_3_1->coolingsolution_id;
+		break;
+	case 3:
+		v_3_3 = (struct atom_firmware_info_v3_3 *)header;
+		smu->smu_table.boot_values.revision = v_3_3->firmware_revision;
+		smu->smu_table.boot_values.gfxclk = v_3_3->bootup_sclk_in10khz;
+		smu->smu_table.boot_values.uclk = v_3_3->bootup_mclk_in10khz;
+		smu->smu_table.boot_values.socclk = 0;
+		smu->smu_table.boot_values.dcefclk = 0;
+		smu->smu_table.boot_values.vddc = v_3_3->bootup_vddc_mv;
+		smu->smu_table.boot_values.vddci = v_3_3->bootup_vddci_mv;
+		smu->smu_table.boot_values.mvddc = v_3_3->bootup_mvddc_mv;
+		smu->smu_table.boot_values.vdd_gfx = v_3_3->bootup_vddgfx_mv;
+		smu->smu_table.boot_values.cooling_id = v_3_3->coolingsolution_id;
+		break;
+	case 4:
+	default:
+		v_3_4 = (struct atom_firmware_info_v3_4 *)header;
+		smu->smu_table.boot_values.revision = v_3_4->firmware_revision;
+		smu->smu_table.boot_values.gfxclk = v_3_4->bootup_sclk_in10khz;
+		smu->smu_table.boot_values.uclk = v_3_4->bootup_mclk_in10khz;
+		smu->smu_table.boot_values.socclk = 0;
+		smu->smu_table.boot_values.dcefclk = 0;
+		smu->smu_table.boot_values.vddc = v_3_4->bootup_vddc_mv;
+		smu->smu_table.boot_values.vddci = v_3_4->bootup_vddci_mv;
+		smu->smu_table.boot_values.mvddc = v_3_4->bootup_mvddc_mv;
+		smu->smu_table.boot_values.vdd_gfx = v_3_4->bootup_vddgfx_mv;
+		smu->smu_table.boot_values.cooling_id = v_3_4->coolingsolution_id;
+		break;
+	}
+
+	smu->smu_table.boot_values.format_revision = header->format_revision;
+	smu->smu_table.boot_values.content_revision = header->content_revision;
+
+	smu_v13_0_1_atom_get_smu_clockinfo(smu->adev,
+					(uint8_t)SMU11_SYSPLL0_SOCCLK_ID,
+					(uint8_t)0,
+					&smu->smu_table.boot_values.socclk);
+
+	smu_v13_0_1_atom_get_smu_clockinfo(smu->adev,
+					(uint8_t)SMU11_SYSPLL0_DCEFCLK_ID,
+					(uint8_t)0,
+					&smu->smu_table.boot_values.dcefclk);
+
+	smu_v13_0_1_atom_get_smu_clockinfo(smu->adev,
+					(uint8_t)SMU11_SYSPLL0_ECLK_ID,
+					(uint8_t)0,
+					&smu->smu_table.boot_values.eclk);
+
+	smu_v13_0_1_atom_get_smu_clockinfo(smu->adev,
+					(uint8_t)SMU11_SYSPLL0_VCLK_ID,
+					(uint8_t)0,
+					&smu->smu_table.boot_values.vclk);
+
+	smu_v13_0_1_atom_get_smu_clockinfo(smu->adev,
+					(uint8_t)SMU11_SYSPLL0_DCLK_ID,
+					(uint8_t)0,
+					&smu->smu_table.boot_values.dclk);
+
+	if ((smu->smu_table.boot_values.format_revision == 3) &&
+	    (smu->smu_table.boot_values.content_revision >= 2))
+		smu_v13_0_1_atom_get_smu_clockinfo(smu->adev,
+						(uint8_t)SMU11_SYSPLL1_0_FCLK_ID,
+						(uint8_t)SMU11_SYSPLL1_2_ID,
+						&smu->smu_table.boot_values.fclk);
+
+	return 0;
+}
+
 int smu_v13_0_1_set_default_dpm_tables(struct smu_context *smu)
 {
 	struct smu_table_context *smu_table = &smu->smu_table;
diff --git a/drivers/gpu/drm/amd/pm/swsmu/smu13/yellow_carp_ppt.c b/drivers/gpu/drm/amd/pm/swsmu/smu13/yellow_carp_ppt.c
index d9b3cb7d7ca5..bded5c297a08 100644
--- a/drivers/gpu/drm/amd/pm/swsmu/smu13/yellow_carp_ppt.c
+++ b/drivers/gpu/drm/amd/pm/swsmu/smu13/yellow_carp_ppt.c
@@ -820,6 +820,7 @@ static const struct pptable_funcs yellow_carp_ppt_funcs = {
 	.check_fw_version = smu_v13_0_1_check_fw_version,
 	.init_smc_tables = yellow_carp_init_smc_tables,
 	.fini_smc_tables = smu_v13_0_1_fini_smc_tables,
+	.get_vbios_bootup_values = smu_v13_0_1_get_vbios_bootup_values,
 	.system_features_control = yellow_carp_system_features_control,
 	.send_smc_msg_with_param = smu_cmn_send_smc_msg_with_param,
 	.send_smc_msg = smu_cmn_send_smc_msg,
-- 
2.27.0

