From c1510a8fee04097795d2f2824a8d014ec7530693 Mon Sep 17 00:00:00 2001
From: sandeep singh <sandeep1.singh@intel.com>
Date: Wed, 16 Dec 2020 17:06:02 +0530
Subject: [PATCH 047/170] Thunderbay Thermal Driver

Thermal Driver support is added for ThunderBay

Signed-off-by: sandeep singh <sandeep1.singh@intel.com>
---
 drivers/misc/hddl_device/hddl_device.c        |   8 +-
 drivers/misc/hddl_device/hddl_device_lh.c     |   4 +-
 drivers/misc/hddl_device/hddl_device_rh.c     |   3 +-
 drivers/misc/intel_tsens/Kconfig              |  10 +
 drivers/misc/intel_tsens/Makefile             |   1 +
 drivers/misc/intel_tsens/thunderbay_thermal.c | 182 ++++++++++++++++++
 6 files changed, 204 insertions(+), 4 deletions(-)
 create mode 100644 drivers/misc/intel_tsens/thunderbay_thermal.c

diff --git a/drivers/misc/hddl_device/hddl_device.c b/drivers/misc/hddl_device/hddl_device.c
index 1ae0cdefa929..76ca42dd7b21 100644
--- a/drivers/misc/hddl_device/hddl_device.c
+++ b/drivers/misc/hddl_device/hddl_device.c
@@ -213,8 +213,9 @@ struct intel_hddl_clients **
 		}
 		dev_info(dev, "HDDL:Device name: %x %s\n",
 			 c->xlink_dev.sw_device_id, device_name);
-		if (GET_INTERFACE_FROM_SW_DEVICE_ID(sw_device_id_list[i]) ==
-		    SW_DEVICE_ID_PCIE_INTERFACE) {
+		mutex_lock(lock);
+		if ((GET_INTERFACE_FROM_SW_DEVICE_ID(c->xlink_dev.sw_device_id) ==
+		    SW_DEVICE_ID_PCIE_INTERFACE) && !initialized) {
 			/*
 			 * Start kernel thread to initialize
 			 * xlink communication.
@@ -224,11 +225,14 @@ struct intel_hddl_clients **
 							       device_name);
 			if (!c->hddl_dev_connect_task) {
 				dev_err(dev, "failed to create thread\n");
+				mutex_unlock(lock);
 				return hddl_clients;
 			}
 			c->task = (void *)task;
+			initialized = 1;
 		}
 		hddl_clients[i] = c;
+		mutex_unlock(lock);
 	}
 
 	return hddl_clients;
diff --git a/drivers/misc/hddl_device/hddl_device_lh.c b/drivers/misc/hddl_device/hddl_device_lh.c
index 3d91c0ce57d8..3a5a89f76637 100644
--- a/drivers/misc/hddl_device/hddl_device_lh.c
+++ b/drivers/misc/hddl_device/hddl_device_lh.c
@@ -59,6 +59,7 @@ struct intel_hddl_client_priv {
 	struct intel_hddl_i2c_devs **i2c_devs;
 	struct intel_tsens **tsens;
 	struct intel_hddl_board_info board_info;
+	struct mutex lock;			/* Mutex Lock */
 };
 
 static struct intel_hddl_client_priv *g_priv;
@@ -399,7 +400,8 @@ static int intel_hddl_check_for_new_device(struct intel_hddl_client_priv *priv)
 		intel_hddl_setup_device(&priv->pdev->dev,
 					intel_hddl_device_connect_task,
 					&priv->n_hddl_devs, priv->hddl_client,
-					priv);
+					priv,
+					&priv->lock);
 	if (!hddl_clients) {
 		dev_err(&priv->pdev->dev,
 			"intel_hddl_setup_device returned NULL\n");
diff --git a/drivers/misc/hddl_device/hddl_device_rh.c b/drivers/misc/hddl_device/hddl_device_rh.c
index 47a9dac2b3b4..ee0ba561f92d 100644
--- a/drivers/misc/hddl_device/hddl_device_rh.c
+++ b/drivers/misc/hddl_device/hddl_device_rh.c
@@ -691,7 +691,8 @@ static int intel_hddl_check_for_new_device(struct intel_hddl_device_priv *priv)
 		intel_hddl_setup_device(&priv->pdev->dev,
 					intel_hddl_device_connect_task,
 					&priv->ndevs, priv->hddl_client,
-					priv);
+					priv,
+					&priv->lock);
 
 	if (!hddl_clients) {
 		dev_err(&priv->pdev->dev,
diff --git a/drivers/misc/intel_tsens/Kconfig b/drivers/misc/intel_tsens/Kconfig
index 456019ff2364..8066be0801ea 100644
--- a/drivers/misc/intel_tsens/Kconfig
+++ b/drivers/misc/intel_tsens/Kconfig
@@ -53,3 +53,13 @@ config INTEL_TSENS_IA_HOST
 	  used by thermal daemon in remote IA host
 	  Say Y if using a processor that includes the Intel VPU such as
 	  Keem Bay.  If unsure, say N.
+
+config THUNDERBAY_THERMAL
+	tristate "Temperature sensor driver for intel keembay"
+	depends on INTEL_TSENS_LOCAL_HOST && ARCH_THUNDERBAY
+	help
+	  Enable this option if you want to have support for thunderbay
+	  thermal management sensors.
+
+	  This driver is used for reading onchip temperature sensor
+	  values from thunderbay SoC.
diff --git a/drivers/misc/intel_tsens/Makefile b/drivers/misc/intel_tsens/Makefile
index 00f63c2d5b2f..89ff1c43cbd0 100644
--- a/drivers/misc/intel_tsens/Makefile
+++ b/drivers/misc/intel_tsens/Makefile
@@ -8,3 +8,4 @@ obj-$(CONFIG_INTEL_TSENS_LOCAL_HOST)	+= intel_tsens_thermal.o
 obj-$(CONFIG_INTEL_TSENS_I2C_SLAVE)	+= intel_tsens_i2c.o
 obj-$(CONFIG_INTEL_TSENS_IA_HOST)	+= intel_tsens_host.o
 obj-$(CONFIG_KEEMBAY_THERMAL)		+= keembay_thermal.o
+obj-$(CONFIG_THUNDERBAY_THERMAL)	+= thunderbay_thermal.o
diff --git a/drivers/misc/intel_tsens/thunderbay_thermal.c b/drivers/misc/intel_tsens/thunderbay_thermal.c
new file mode 100644
index 000000000000..86b93265f606
--- /dev/null
+++ b/drivers/misc/intel_tsens/thunderbay_thermal.c
@@ -0,0 +1,182 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Thunderbay-thermal.c - ThunderBay Thermal Driver.
+ *
+ * Copyright (C) 2019-2020 Intel Corporation
+ */
+
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/of.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/thermal.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/hddl_device.h>
+#include "thunderbay_tsens.h"
+
+struct thunderbay_thermal_priv {
+	const char *name;
+	void __iomem *base_addr;
+	spinlock_t lock;		/* Spinlock */
+	u32 current_temp[THUNDERBAY_SENSOR_MAX];
+	struct intel_tsens_plat_data *plat_data;
+};
+
+static int thb_sensor_read_temp(void __iomem *regs_val,
+				int offset,
+				int *temp)
+{
+	int reg_val, thb_raw_index;
+
+	reg_val = ioread32(regs_val + offset);
+	reg_val = (reg_val & 0xff);
+	thb_raw_index = reg_val - THUNDERBAY_SENSOR_BASE_TEMP;
+	if (thb_raw_index < 0)
+		reg_val = raw_thb[0];
+	else if	(thb_raw_index > (raw_thb_size - 1))
+		reg_val = raw_thb[raw_thb_size - 1];
+	else
+		reg_val = raw_thb[thb_raw_index];
+
+	*temp = reg_val;
+
+	return 0;
+}
+
+static int thunderbay_get_temp(struct platform_device *pdev, int type, int *temp)
+{
+	struct thunderbay_thermal_priv *priv = platform_get_drvdata(pdev);
+
+	spin_lock(&priv->lock);
+	switch (type) {
+	case CPUSS_SOUTH_NOC:
+		thb_sensor_read_temp(priv->base_addr, SAR_TEMP_DTS0_OFFSET, temp);
+		priv->current_temp[CPUSS_SOUTH_NOC] = *temp;
+		break;
+
+	case CPUSS_NORTH_NOC:
+		thb_sensor_read_temp(priv->base_addr, SAR_TEMP_DTS1_OFFSET, temp);
+		priv->current_temp[CPUSS_NORTH_NOC] = *temp;
+		break;
+
+	case PAR_VPU_0:
+		thb_sensor_read_temp(priv->base_addr, SAR_TEMP_DTS0_OFFSET, temp);
+		priv->current_temp[PAR_VPU_0] = *temp;
+		break;
+
+	case PAR_VPU_1:
+		thb_sensor_read_temp(priv->base_addr, SAR_TEMP_DTS0_OFFSET, temp);
+		priv->current_temp[PAR_VPU_1] = *temp;
+		break;
+
+	case PAR_VPU_2:
+		thb_sensor_read_temp(priv->base_addr, SAR_TEMP_DTS0_OFFSET, temp);
+		priv->current_temp[PAR_VPU_2] = *temp;
+		break;
+
+	case PAR_VPU_3:
+		thb_sensor_read_temp(priv->base_addr, SAR_TEMP_DTS0_OFFSET, temp);
+		priv->current_temp[PAR_VPU_3] = *temp;
+		break;
+
+	case PAR_MEDIA_0:
+		thb_sensor_read_temp(priv->base_addr, SAR_TEMP_DTS1_OFFSET, temp);
+		priv->current_temp[PAR_MEDIA_0] = *temp;
+		break;
+
+	case PAR_MEDIA_1:
+		thb_sensor_read_temp(priv->base_addr, SAR_TEMP_DTS1_OFFSET, temp);
+		priv->current_temp[PAR_MEDIA_1] = *temp;
+		break;
+
+	case PAR_MEDIA_2:
+		thb_sensor_read_temp(priv->base_addr, SAR_TEMP_DTS1_OFFSET, temp);
+		priv->current_temp[PAR_MEDIA_2] = *temp;
+		break;
+
+	case PAR_MEDIA_3:
+		thb_sensor_read_temp(priv->base_addr, SAR_TEMP_DTS1_OFFSET, temp);
+		priv->current_temp[PAR_MEDIA_3] = *temp;
+		break;
+
+	case NOC_VPU_DDR_0:
+		thb_sensor_read_temp(priv->base_addr, SAR_TEMP_DTS2_OFFSET, temp);
+		priv->current_temp[NOC_VPU_DDR_0] = *temp;
+		break;
+
+	case NOC_VPU_DDR_1:
+		thb_sensor_read_temp(priv->base_addr, SAR_TEMP_DTS2_OFFSET, temp);
+		priv->current_temp[NOC_VPU_DDR_1] = *temp;
+		break;
+
+	case NOC_VPU_DDR_2:
+		thb_sensor_read_temp(priv->base_addr, SAR_TEMP_DTS2_OFFSET, temp);
+		priv->current_temp[NOC_VPU_DDR_2] = *temp;
+		break;
+
+	case NOC_VPU_DDR_3:
+		thb_sensor_read_temp(priv->base_addr, SAR_TEMP_DTS2_OFFSET, temp);
+		priv->current_temp[NOC_VPU_DDR_3] = *temp;
+		break;
+
+	default:
+		break;
+	}
+	spin_unlock(&priv->lock);
+	return 0;
+}
+
+static int thunderbay_thermal_probe(struct platform_device *pdev)
+{
+	struct intel_tsens_plat_data *plat_data = NULL;
+	struct thunderbay_thermal_priv *priv;
+
+	plat_data = pdev->dev.platform_data;
+	if (!plat_data) {
+		dev_err(&pdev->dev, "Platform data not found\n");
+		return -EINVAL;
+	}
+	if (!plat_data->base_addr)
+		return -EINVAL;
+	priv = devm_kzalloc(&pdev->dev, sizeof(struct thunderbay_thermal_priv),	GFP_KERNEL);
+	if (!priv) {
+		dev_err(&pdev->dev, "No memory");
+		return -ENOMEM;
+	}
+	iowrite32(0x1c0, plat_data->base_addr + DTS_THD_SAR_PID_EN_ABORT);
+	priv->name = plat_data->name;
+	priv->base_addr = plat_data->base_addr;
+	priv->plat_data = plat_data;
+	plat_data->get_temp = thunderbay_get_temp;
+	spin_lock_init(&priv->lock);
+	platform_set_drvdata(pdev, priv);
+
+	dev_info(&pdev->dev, "Thermal driver loaded for %s\n", plat_data->name);
+	return 0;
+}
+
+static int thunderbay_thermal_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static struct platform_driver thunderbay_thermal_driver = {
+	.probe = thunderbay_thermal_probe,
+	.remove = thunderbay_thermal_remove,
+	.driver = {
+		.name = "intel,thunderbay_thermal",
+	},
+};
+
+module_platform_driver(thunderbay_thermal_driver);
+
+MODULE_DESCRIPTION("Thunderbay Thermal Driver");
+MODULE_AUTHOR("Sandeep Singh <sandeep1.singh@intel.com>");
+MODULE_AUTHOR("Raja Subramanian, Lakshmi Bai <lakshmi.bai.raja.subramanian@intel.com>");
+MODULE_AUTHOR("Udhayakumar C <udhayakumar.c@intel.com>");
+MODULE_LICENSE("GPL v2");
-- 
2.27.0

