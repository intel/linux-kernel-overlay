From 36c289bbbce93f8407fcafc85f9d989b2ffe3307 Mon Sep 17 00:00:00 2001
From: Jin Yao <yao.jin@linux.intel.com>
Date: Tue, 8 Jun 2021 10:00:08 +0800
Subject: [PATCH 17/19] perf list: Skip the invalid hybrid pmu

On hybrid platform, such as Alderlake, if atom CPUs are offlined,
the kernel still exports the sysfs path '/sys/devices/cpu_atom/' for
'cpu_atom' pmu but the file '/sys/devices/cpu_atom/cpus' is empty,
which indicates this is an invalid pmu.

The perf-list checks and skips the invalid hybrid pmu.

   # perf list
     ...
     branch-instructions OR cpu_core/branch-instructions/ [Kernel PMU event]
     branch-misses OR cpu_core/branch-misses/           [Kernel PMU event]
     bus-cycles OR cpu_core/bus-cycles/                 [Kernel PMU event]
     cache-misses OR cpu_core/cache-misses/             [Kernel PMU event]
     cache-references OR cpu_core/cache-references/     [Kernel PMU event]
     cpu-cycles OR cpu_core/cpu-cycles/                 [Kernel PMU event]
     instructions OR cpu_core/instructions/             [Kernel PMU event]
     mem-loads OR cpu_core/mem-loads/                   [Kernel PMU event]

Signed-off-by: Jin Yao <yao.jin@linux.intel.com>
---
 tools/perf/util/pmu-hybrid.c | 11 +++++++++++
 tools/perf/util/pmu-hybrid.h |  2 ++
 tools/perf/util/pmu.c        |  3 +++
 3 files changed, 16 insertions(+)

diff --git a/tools/perf/util/pmu-hybrid.c b/tools/perf/util/pmu-hybrid.c
index f51ccaac60ee..fcc1182f8fe5 100644
--- a/tools/perf/util/pmu-hybrid.c
+++ b/tools/perf/util/pmu-hybrid.c
@@ -87,3 +87,14 @@ char *perf_pmu__hybrid_type_to_pmu(const char *type)
 	free(pmu_name);
 	return NULL;
 }
+
+bool perf_pmu__is_invalid_hybrid(const char *name)
+{
+	if (strncmp(name, "cpu_", 4))
+		return false;
+
+	if (perf_pmu__hybrid_mounted(name))
+		return false;
+
+	return true;
+}
diff --git a/tools/perf/util/pmu-hybrid.h b/tools/perf/util/pmu-hybrid.h
index 2b186c26a43e..8261a312c854 100644
--- a/tools/perf/util/pmu-hybrid.h
+++ b/tools/perf/util/pmu-hybrid.h
@@ -30,4 +30,6 @@ static inline int perf_pmu__hybrid_pmu_num(void)
 	return num;
 }
 
+bool perf_pmu__is_invalid_hybrid(const char *name);
+
 #endif /* __PMU_HYBRID_H */
diff --git a/tools/perf/util/pmu.c b/tools/perf/util/pmu.c
index a77c4fc248c1..4f55190a7dd2 100644
--- a/tools/perf/util/pmu.c
+++ b/tools/perf/util/pmu.c
@@ -1617,6 +1617,9 @@ void print_pmu_events(const char *event_glob, bool name_only, bool quiet_flag,
 			continue;
 		}
 
+		if (perf_pmu__is_invalid_hybrid(pmu->name))
+			continue;
+
 		list_for_each_entry(alias, &pmu->aliases, list) {
 			char *name = alias->desc ? alias->name :
 				format_alias(buf, sizeof(buf), pmu, alias);
-- 
2.27.0

