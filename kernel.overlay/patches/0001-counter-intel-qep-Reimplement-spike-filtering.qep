From 6a6e6f9b1137281b5a12902c170e244012d46487 Mon Sep 17 00:00:00 2001
From: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date: Wed, 19 May 2021 16:57:49 +0300
Subject: [PATCH 1/4] counter: intel-qep: Reimplement spike filtering

Maintainer recommended in review to give a better name than "noise" to
this spike filtering. I proposed also should it be visible as
nanoseconds since plain register value is more or less guesswork for an
user.

While reimplementing I also noticed for HW point of view shortest spike
filter length wasn't able to set. Before value 0 disabled the filter
while HW point of view the shortest length is actually register value 0
with filter enabled.

This patch renames the sysfs "noise" as "spike_filter_ns" and changes
the code accordingly to input and output filter length as nanoseconds
instead of plain register value. Code takes into account filter length
is (MAX_COUNT + 2) * clock periods long when enabled.

Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
---
 drivers/counter/intel-qep.c | 48 ++++++++++++++++++++++++-------------
 1 file changed, 32 insertions(+), 16 deletions(-)

diff --git a/drivers/counter/intel-qep.c b/drivers/counter/intel-qep.c
index c78d974f8cfe..44e83d98761b 100644
--- a/drivers/counter/intel-qep.c
+++ b/drivers/counter/intel-qep.c
@@ -61,6 +61,8 @@
 
 #define INTEL_QEPINT_MASK_ALL		GENMASK(5, 0)
 
+#define INTEL_QEP_CLK_PERIOD_NS		10
+
 #define INTEL_QEP_COUNTER_EXT_RW(_name) \
 { \
 	.name = #_name, \
@@ -408,8 +410,8 @@ static struct counter_count intel_qep_counter_count[] = {
 	},
 };
 
-static ssize_t noise_read(struct counter_device *counter,
-			  void *priv, char *buf)
+static ssize_t spike_filter_ns_read(struct counter_device *counter,
+				    void *priv, char *buf)
 {
 	struct intel_qep *qep = counter->priv;
 	u32 reg;
@@ -420,24 +422,39 @@ static ssize_t noise_read(struct counter_device *counter,
 		pm_runtime_put(qep->dev);
 		return sysfs_emit(buf, "0\n");
 	}
-	reg = intel_qep_readl(qep, INTEL_QEPFLT);
+	reg = INTEL_QEPFLT_MAX_COUNT(intel_qep_readl(qep, INTEL_QEPFLT));
 	pm_runtime_put(qep->dev);
 
-	return sysfs_emit(buf, "%u\n", INTEL_QEPFLT_MAX_COUNT(reg));
+	return sysfs_emit(buf, "%u\n", (reg + 2) * INTEL_QEP_CLK_PERIOD_NS);
 }
 
-static ssize_t noise_write(struct counter_device *counter,
-			   void *priv, const char *buf, size_t len)
+static ssize_t spike_filter_ns_write(struct counter_device *counter,
+				     void *priv, const char *buf, size_t len)
 {
 	struct intel_qep *qep = counter->priv;
-	u32 reg;
-	u32 max;
+	u32 reg, length;
+	bool enable;
 	int ret;
 
-	ret = kstrtou32(buf, 0, &max);
+	ret = kstrtou32(buf, 0, &length);
 	if (ret < 0)
 		return ret;
-	if (max > INTEL_QEPFLT_MAX_COUNT(max))
+
+	/*
+	 * Spike filter length is (MAX_COUNT + 2) clock periods. Disable
+	 * filter when user space supplies shorter than 2 clock periods and
+	 * otherwise enable and set MAX_COUNT = clock periods - 2.
+	 */
+	length /= INTEL_QEP_CLK_PERIOD_NS;
+	if (length < 2) {
+		enable = false;
+		length = 0;
+	} else {
+		enable = true;
+		length -= 2;
+	}
+
+	if (length > INTEL_QEPFLT_MAX_COUNT(length))
 		return -EINVAL;
 
 	mutex_lock(&qep->lock);
@@ -448,12 +465,11 @@ static ssize_t noise_write(struct counter_device *counter,
 
 	pm_runtime_get_sync(qep->dev);
 	reg = intel_qep_readl(qep, INTEL_QEPCON);
-	if (max == 0) {
-		reg &= ~INTEL_QEPCON_FLT_EN;
-	} else {
+	if (enable)
 		reg |= INTEL_QEPCON_FLT_EN;
-		intel_qep_writel(qep, INTEL_QEPFLT, max);
-	}
+	else
+		reg &= ~INTEL_QEPCON_FLT_EN;
+	intel_qep_writel(qep, INTEL_QEPFLT, length);
 	intel_qep_writel(qep, INTEL_QEPCON, reg);
 	pm_runtime_put(qep->dev);
 	ret = len;
@@ -511,7 +527,7 @@ static ssize_t preset_enable_write(struct counter_device *counter,
 }
 
 static const struct counter_device_ext intel_qep_ext[] = {
-	INTEL_QEP_COUNTER_EXT_RW(noise),
+	INTEL_QEP_COUNTER_EXT_RW(spike_filter_ns),
 	INTEL_QEP_COUNTER_EXT_RW(preset_enable)
 };
 
-- 
2.25.1

