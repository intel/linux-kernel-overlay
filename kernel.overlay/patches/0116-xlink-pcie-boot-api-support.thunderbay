From 97b85a2c169ee21aa38ee4104d8c8901fb62e06a Mon Sep 17 00:00:00 2001
From: kadarlax <raghuveerx.kadarla@intel.com>
Date: Wed, 17 Feb 2021 14:39:00 +0530
Subject: [PATCH 116/170] xlink-pcie: boot api support

Adding boot api support for flash and boot.

Signed-off-by: kadarlax <raghuveerx.kadarla@intel.com>
---
 drivers/misc/xlink-pcie/common/boot.h        |  88 ++++++++
 drivers/misc/xlink-pcie/common/xpcie.h       |   2 +-
 drivers/misc/xlink-pcie/local_host/epf.c     |  13 +-
 drivers/misc/xlink-pcie/remote_host/Makefile |   3 +-
 drivers/misc/xlink-pcie/remote_host/boot.c   | 207 +++++++++++++++++++
 drivers/misc/xlink-pcie/remote_host/main.c   |   3 +
 drivers/misc/xlink-pcie/remote_host/pci.c    | 119 +++++++++--
 drivers/misc/xlink-pcie/remote_host/pci.h    |  13 ++
 8 files changed, 419 insertions(+), 29 deletions(-)
 create mode 100644 drivers/misc/xlink-pcie/common/boot.h
 create mode 100644 drivers/misc/xlink-pcie/remote_host/boot.c

diff --git a/drivers/misc/xlink-pcie/common/boot.h b/drivers/misc/xlink-pcie/common/boot.h
new file mode 100644
index 000000000000..e8be76c05163
--- /dev/null
+++ b/drivers/misc/xlink-pcie/common/boot.h
@@ -0,0 +1,88 @@
+/* SPDX-License-Identifier: GPL-2.0 only */
+/********************************************************************/
+/*
+ * Intel Keem Bay XLink PCIe Driver
+ *
+ * Copyright (C) 2019 Intel Corporation
+ */
+/********************************************************************/
+
+#ifndef XPCIE_BOOT_HEADER_
+#define XPCIE_BOOT_HEADER_
+
+#include <linux/types.h>
+
+#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#define XPCIE_BOOT_MAGIC_ROM "THBROM"
+#define XPCIE_BOOT_MAGIC_EMMC "THBEMMC"
+#else
+#define XPCIE_BOOT_MAGIC_ROM "VPUROM"
+#define XPCIE_BOOT_MAGIC_EMMC "VPUEMMC"
+#endif
+
+#define XPCIE_BOOT_MAGIC_BL2 "VPUBL2"
+#define XPCIE_BOOT_MAGIC_UBOOT "VPUUBOOT"
+#define XPCIE_BOOT_MAGIC_RECOV "VPURECOV"
+#define XPCIE_BOOT_MAGIC_YOCTO "VPUYOCTO"
+
+enum xpcie_stage {
+	STAGE_UNINIT,
+	STAGE_ROM,
+	STAGE_BL2,
+	STAGE_UBOOT,
+	STAGE_RECOV,
+	STAGE_OS
+};
+
+#define XPCIE_BOOT_FIP_ID (0xFFFFFFFF)
+#define XPCIE_BOOT_BOOT_ID (0xFFFFFF4F)
+#define XPCIE_BOOT_SYSTEM_ID (0xFFFFFF46)
+#define XPCIE_BOOT_RAW_ID (0xFFFFFF00)
+#define XPCIE_BOOT_ERASE_ID (0xFFFFFF01)
+#define XPCIE_BOOT_FLASH_ID (0xFFFFFF02)
+
+#define XPCIE_BOOT_STATUS_START (0x55555555)
+#define XPCIE_BOOT_STATUS_INVALID (0xDEADFFFF)
+#define XPCIE_BOOT_STATUS_DOWNLOADED (0xDDDDDDDD)
+#define XPCIE_BOOT_STATUS_ERROR (0xDEADAAAA)
+#define XPCIE_BOOT_STATUS_DONE (0xBBBBBBBB)
+
+#define XPCIE_INT_ENABLE (0x1)
+#define XPCIE_INT_MASK (0x1)
+
+#define XPCIE_BOOT_MAGIC_STRLEN (16)
+#define XPCIE_BOOT_DEST_STRLEN (128)
+
+#define XPCIE_IO_COMM_MAGIC_OFF (offsetof(struct xpcie_bootio, magic))
+#define XPCIE_IO_COMM_MF_READY_OFF (offsetof(struct xpcie_bootio, mf_ready))
+#define XPCIE_IO_COMM_MF_LEN_OFF (offsetof(struct xpcie_bootio, mf_len))
+#define XPCIE_IO_COMM_MF_START_OFF (offsetof(struct xpcie_bootio, mf_start))
+#define XPCIE_IO_COMM_INT_ENABLE_OFF (offsetof(struct xpcie_bootio, int_enable))
+#define XPCIE_IO_COMM_INT_MASK_OFF (offsetof(struct xpcie_bootio, int_mask))
+#define XPCIE_IO_COMM_INT_IDENTITY_OFF (offsetof(struct xpcie_bootio, int_identity))
+#define XPCIE_IO_COMM_MF_OFF (offsetof(struct xpcie_bootio, mf_offset))
+#define XPCIE_IO_COMM_MF_DEST_OFF (offsetof(struct xpcie_bootio, mf_dest))
+#define XPCIE_IO_COMM_DEV_ID_OFF (offsetof(struct xpcie_bootio, dev_id))
+
+/* Structure declarations */
+struct xpcie_bootio {
+	u8 magic[XPCIE_BOOT_MAGIC_STRLEN];
+	u32 mf_ready;
+	u32 mf_len;
+	u64 reserved1;
+	u64 mf_start;
+	u32 int_enable;
+	u32 int_mask;
+	u32 int_identity;
+	u32 reserved2;
+	u64 mf_offset;
+	u8 mf_dest[XPCIE_BOOT_DEST_STRLEN];
+	u64 dev_id;
+} __packed;
+
+/* function declarations */
+void xpcie_device_irq(struct work_struct *work);
+#if (IS_ENABLED(XLINK_PCIE_REMOTE))
+enum xpcie_stage intel_xpcie_check_magic(struct xpcie_dev *xdev);
+#endif
+#endif /* XPCIE_BOOT_HEADER_ */
diff --git a/drivers/misc/xlink-pcie/common/xpcie.h b/drivers/misc/xlink-pcie/common/xpcie.h
index b080ffed74d4..d7f0773358ad 100644
--- a/drivers/misc/xlink-pcie/common/xpcie.h
+++ b/drivers/misc/xlink-pcie/common/xpcie.h
@@ -63,7 +63,6 @@ struct xpcie_mmio {
 #endif
 	u8 reserved;
 	u32 cap_offset;
-	u8 magic[XPCIE_MAGIC_STRLEN];
 } __packed __aligned(8);
 
 #define XPCIE_MMIO_LEGACY_A0	(offsetof(struct xpcie_mmio, legacy_a0))
@@ -101,6 +100,7 @@ struct xpcie {
 	void *bar0;
 	void *mmio;
 	void *bar4;
+	void *io_comm;
 #if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
 	void __iomem *doorbell_base; /*IPC DoorBell address space*/
 	void __iomem *doorbell_clear; /*IPC DoorBell clear address space*/
diff --git a/drivers/misc/xlink-pcie/local_host/epf.c b/drivers/misc/xlink-pcie/local_host/epf.c
index c5ba52b9031e..df3e377dddd9 100644
--- a/drivers/misc/xlink-pcie/local_host/epf.c
+++ b/drivers/misc/xlink-pcie/local_host/epf.c
@@ -14,6 +14,7 @@
 #include <linux/of_reserved_mem.h>
 
 #include "epf.h"
+#include "../common/boot.h"
 
 #if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
 #define BAR0_MIN_SIZE			SZ_4K
@@ -271,6 +272,7 @@ static void intel_xpcie_cleanup_bars(struct pci_epf *epf)
 
 	intel_xpcie_cleanup_bar(epf, BAR_2);
 	intel_xpcie_cleanup_bar(epf, BAR_4);
+	xpcie_epf->xpcie.io_comm = NULL;
 	xpcie_epf->xpcie.mmio = NULL;
 	xpcie_epf->xpcie.bar4 = NULL;
 }
@@ -391,7 +393,8 @@ static int intel_xpcie_setup_bars(struct pci_epf *epf, size_t align)
 	}
 
 	xpcie_epf->comm_bar = BAR_2;
-	xpcie_epf->xpcie.mmio = (void *)xpcie_epf->vaddr[BAR_2] +
+	xpcie_epf->xpcie.io_comm = xpcie_epf->vaddr[BAR_2];
+	xpcie_epf->xpcie.mmio = (void *)xpcie_epf->xpcie.io_comm +
 				XPCIE_MMIO_OFFSET;
 
 	xpcie_epf->bar4 = BAR_4;
@@ -723,15 +726,15 @@ static int intel_xpcie_epf_bind(struct pci_epf *epf)
 	intel_xpcie_set_device_status(&xpcie_epf->xpcie, XPCIE_STATUS_RUN);
 	intel_xpcie_set_doorbell(&xpcie_epf->xpcie, FROM_DEVICE,
 				 DEV_EVENT, NO_OP);
-	memcpy(xpcie_epf->xpcie.mmio + XPCIE_MMIO_MAGIC_OFF, XPCIE_MAGIC_YOCTO,
-	       strlen(XPCIE_MAGIC_YOCTO));
+	memcpy(xpcie_epf->xpcie.io_comm + XPCIE_IO_COMM_MAGIC_OFF,
+	       XPCIE_BOOT_MAGIC_YOCTO, strlen(XPCIE_BOOT_MAGIC_YOCTO));
 
 	return 0;
 
 err_uninit_dma:
 	intel_xpcie_set_device_status(&xpcie_epf->xpcie, XPCIE_STATUS_ERROR);
-	memcpy(xpcie_epf->xpcie.mmio + XPCIE_MMIO_MAGIC_OFF, XPCIE_MAGIC_YOCTO,
-	       strlen(XPCIE_MAGIC_YOCTO));
+	memcpy(xpcie_epf->xpcie.io_comm + XPCIE_IO_COMM_MAGIC_OFF,
+	       XPCIE_BOOT_MAGIC_YOCTO, strlen(XPCIE_BOOT_MAGIC_YOCTO));
 
 	intel_xpcie_ep_dma_uninit(epf);
 
diff --git a/drivers/misc/xlink-pcie/remote_host/Makefile b/drivers/misc/xlink-pcie/remote_host/Makefile
index f6b09a93bb5f..23ef53e458ed 100644
--- a/drivers/misc/xlink-pcie/remote_host/Makefile
+++ b/drivers/misc/xlink-pcie/remote_host/Makefile
@@ -1,8 +1,9 @@
-ccflags-y += -DCONFIG_PCIE_TBH_EP=1
+ccflags-y += -DCONFIG_PCIE_TBH_EP=1 -DXLINK_PCIE_REMOTE=1
 
 obj-$(CONFIG_XLINK_PCIE_RH_DRIVER) += mxlk.o
 mxlk-objs := main.o
 mxlk-objs += pci.o
 mxlk-objs += core.o
+mxlk-objs += boot.o
 mxlk-objs += ../common/util.o
 mxlk-objs += ../common/interface.o
diff --git a/drivers/misc/xlink-pcie/remote_host/boot.c b/drivers/misc/xlink-pcie/remote_host/boot.c
new file mode 100644
index 000000000000..f481a72e6a61
--- /dev/null
+++ b/drivers/misc/xlink-pcie/remote_host/boot.c
@@ -0,0 +1,207 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*****************************************************************************
+ *
+ * Intel Keem Bay XLink PCIe Driver
+ *
+ * Copyright (C) 2020 Intel Corporation
+ *
+ ****************************************************************************/
+#include <linux/firmware.h>
+#include <linux/delay.h>
+#include <linux/mxlk_boot_inf.h>
+
+#include "pci.h"
+#include "../common/boot.h"
+#if 0
+static struct intel_xpcie *intel_xpcie_get_device_by_name(const char *name)
+{
+	struct intel_xpcie *p;
+	bool found = false;
+
+	mutex_lock(&dev_list_mutex);
+	list_for_each_entry(p, &dev_list, list) {
+		if (!strncmp(p->name, name, MXLK_MAX_NAME_LEN)) {
+			found = true;
+			break;
+		}
+	}
+	mutex_unlock(&dev_list_mutex);
+
+	if (!found)
+		p = NULL;
+
+	return p;
+}
+
+static struct intel_xpcie *intel_xpcie_get_device_by_phys_id(u32 phys_id)
+{
+	struct intel_xpcie *xdev;
+
+	mutex_lock(&dev_list_mutex);
+	list_for_each_entry(xdev, &dev_list, list) {
+		if (xdev->devid == phys_id)
+			break;
+	}
+	mutex_unlock(&dev_list_mutex);
+
+	return xdev;
+}
+#endif
+#define STR_EQUAL(a, b) !strncmp(a, b, strlen(b))
+
+enum xpcie_stage intel_xpcie_check_magic(struct xpcie_dev *xdev)
+{
+	char magic[XPCIE_BOOT_MAGIC_STRLEN];
+
+	memcpy_fromio(magic, xdev->xpcie.io_comm + XPCIE_IO_COMM_MAGIC_OFF,
+		      XPCIE_BOOT_MAGIC_STRLEN);
+
+	if (strlen(magic) == 0)
+		return STAGE_UNINIT;
+
+	if (STR_EQUAL(magic, XPCIE_BOOT_MAGIC_ROM))
+		return STAGE_ROM;
+
+	if (STR_EQUAL(magic, XPCIE_BOOT_MAGIC_EMMC))
+		return STAGE_ROM;
+
+	if (STR_EQUAL(magic, XPCIE_BOOT_MAGIC_BL2))
+		return STAGE_BL2;
+
+	if (STR_EQUAL(magic, XPCIE_BOOT_MAGIC_UBOOT))
+		return STAGE_UBOOT;
+
+	if (STR_EQUAL(magic, XPCIE_BOOT_MAGIC_RECOV))
+		return STAGE_RECOV;
+
+	if (STR_EQUAL(magic, XPCIE_BOOT_MAGIC_YOCTO))
+		return STAGE_OS;
+
+	return STAGE_UNINIT;
+}
+
+#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+void xpcie_device_irq(struct work_struct *work)
+{
+	struct xpcie_dev *xdev = container_of(work, struct xpcie_dev,
+			irq_event);
+
+	if (xdev->boot_notif_fn)
+		xdev->boot_notif_fn(xdev->devid);
+};
+
+int intel_xpcie_connect_boot_device(const char *dev_name, u32 *phys_dev_id,
+				    mxlk_pcie_boot_event notif_fn)
+{
+	struct xpcie_dev *xdev = intel_xpcie_get_device_by_name(dev_name);
+
+	if (!xdev) {
+		pr_err("Invalid dev_name %s\n", dev_name);
+		return -EINVAL;
+	}
+
+	if (PCI_FUNC(xdev->pci->devfn)) {
+		dev_err(&xdev->pci->dev,
+			"Invalid PCI function %s\n", dev_name);
+		return -EINVAL;
+	}
+
+	if (xdev->boot_dev_link) {
+		dev_err(&xdev->pci->dev,
+			"Already boot device connected for %s\n", dev_name);
+		return -EINVAL;
+	}
+
+	mutex_lock(&xdev->lock);
+	*phys_dev_id = xdev->devid;
+	xdev->boot_notif_fn = notif_fn;
+	xdev->boot_dev_link = true;
+	mutex_unlock(&xdev->lock);
+
+	dev_info(&xdev->pci->dev, "Boot device connected devid %x link %d\n",
+		 *phys_dev_id, xdev->boot_dev_link);
+	return 0;
+}
+EXPORT_SYMBOL(intel_xpcie_connect_boot_device);
+int intel_xpcie_boot_mmio_write(u32 phys_dev_id, u32 offset, void *data,
+				size_t size)
+{
+	struct xpcie_dev *xdev =
+			intel_xpcie_get_device_by_phys_id(phys_dev_id);
+
+	if (!xdev) {
+		pr_err("Invalid phys_dev_id %d\n", phys_dev_id);
+		return -EINVAL;
+	}
+
+	if (!xdev->boot_dev_link) {
+		dev_err(&xdev->pci->dev,
+			"No boot device connected for id %08x\n", phys_dev_id);
+		return -EINVAL;
+	}
+
+	mutex_lock(&xdev->lock);
+	memcpy_toio((void *)xdev->xpcie.io_comm + offset,
+		    data, size);
+	mutex_unlock(&xdev->lock);
+
+	return size;
+}
+EXPORT_SYMBOL(intel_xpcie_boot_mmio_write);
+
+int intel_xpcie_boot_mmio_read(u32 phys_dev_id, u32 offset, void *status,
+			       size_t size)
+{
+	struct xpcie_dev *xdev =
+			intel_xpcie_get_device_by_phys_id(phys_dev_id);
+
+	if (!xdev) {
+		pr_err("Invalid phys_dev_id %d\n", phys_dev_id);
+		return -EINVAL;
+	}
+
+	if (!xdev->boot_dev_link) {
+		dev_err(&xdev->pci->dev,
+			"No boot device connected for id %08x\n", phys_dev_id);
+		return -EINVAL;
+	}
+
+	mutex_lock(&xdev->lock);
+	memcpy_fromio(status, (void *)xdev->xpcie.io_comm + offset, size);
+	mutex_unlock(&xdev->lock);
+
+	return size;
+}
+EXPORT_SYMBOL(intel_xpcie_boot_mmio_read);
+
+int intel_xpcie_disconnect_boot_device(u32 phys_dev_id)
+{
+	struct xpcie_dev *xdev =
+			intel_xpcie_get_device_by_phys_id(phys_dev_id);
+
+	if (!xdev) {
+		dev_err(&xdev->pci->dev, "Invalid phys_dev_id %d\n",
+			phys_dev_id);
+		return -EINVAL;
+	}
+
+	if (!xdev->boot_dev_link) {
+		dev_err(&xdev->pci->dev,
+			"No boot device connected for id %08x\n", phys_dev_id);
+		return -EINVAL;
+	}
+
+	mutex_lock(&xdev->lock);
+	if (xdev->boot_notif_fn)
+		xdev->boot_notif_fn = NULL;
+
+	xdev->boot_dev_link = false;
+	mutex_unlock(&xdev->lock);
+
+	dev_info(&xdev->pci->dev,
+		 "Boot device disconnected devid %x link %d\n", phys_dev_id,
+		 xdev->boot_dev_link);
+	return 0;
+}
+EXPORT_SYMBOL(intel_xpcie_disconnect_boot_device);
+#endif
diff --git a/drivers/misc/xlink-pcie/remote_host/main.c b/drivers/misc/xlink-pcie/remote_host/main.c
index 1462bb695191..e7ec6efbb77a 100644
--- a/drivers/misc/xlink-pcie/remote_host/main.c
+++ b/drivers/misc/xlink-pcie/remote_host/main.c
@@ -79,6 +79,9 @@ static void intel_xpcie_remove(struct pci_dev *pdev)
 	if (xdev) {
 		intel_xpcie_pci_cleanup(xdev);
 		intel_xpcie_pci_notify_event(xdev, NOTIFY_DEVICE_DISCONNECTED);
+#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+		intel_xpcie_list_del_device(xdev);
+#endif
 		intel_xpcie_remove_device(xdev);
 	}
 }
diff --git a/drivers/misc/xlink-pcie/remote_host/pci.c b/drivers/misc/xlink-pcie/remote_host/pci.c
index fb54d357b44e..70f15c2a3058 100644
--- a/drivers/misc/xlink-pcie/remote_host/pci.c
+++ b/drivers/misc/xlink-pcie/remote_host/pci.c
@@ -122,11 +122,14 @@ static void intel_xpcie_pci_unmap_bar(struct xpcie_dev *xdev)
 #endif
 	}
 
-	if (xdev->xpcie.mmio) {
-		iounmap((void __iomem *)(xdev->xpcie.mmio - XPCIE_MMIO_OFFSET));
-		xdev->xpcie.mmio = NULL;
+	if (xdev->xpcie.io_comm) {
+		iounmap(xdev->xpcie.io_comm);
+		xdev->xpcie.io_comm = NULL;
 	}
 
+	if (xdev->xpcie.mmio)
+		xdev->xpcie.mmio = NULL;
+
 	if (xdev->xpcie.bar4) {
 		iounmap((void __iomem *)xdev->xpcie.bar4);
 		xdev->xpcie.bar4 = NULL;
@@ -148,8 +151,13 @@ static int intel_xpcie_pci_map_bar(struct xpcie_dev *xdev)
 #if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
 	xdev->xpcie.doorbell_base = xdev->xpcie.bar0;
 #endif
+	xdev->xpcie.io_comm = (void __force *)pci_ioremap_bar(xdev->pci, 2);
+	if (!xdev->xpcie.io_comm) {
+		dev_err(&xdev->pci->dev, "failed to ioremap BAR2\n");
+		goto bar_error;
+	}
 	xdev->xpcie.mmio = (void __force *)
-			   (pci_ioremap_bar(xdev->pci, 2) + XPCIE_MMIO_OFFSET);
+			   (xdev->xpcie.io_comm + XPCIE_MMIO_OFFSET);
 	if (!xdev->xpcie.mmio) {
 		dev_err(&xdev->pci->dev, "failed to ioremap BAR2\n");
 		goto bar_error;
@@ -168,6 +176,41 @@ static int intel_xpcie_pci_map_bar(struct xpcie_dev *xdev)
 	return -EIO;
 }
 
+static irqreturn_t intel_xpcie_core_interrupt(int irq, void *args)
+{
+	struct xpcie_dev *xdev = args;
+	enum xpcie_stage stage;
+	u8 event;
+
+#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+	stage = intel_xpcie_check_magic(xdev);
+	if (stage == STAGE_ROM || stage == STAGE_UBOOT || stage == STAGE_RECOV)
+		schedule_work(&xdev->irq_event);
+#endif
+
+	event = intel_xpcie_get_doorbell(&xdev->xpcie, FROM_DEVICE, DEV_EVENT);
+	if (event == DEV_SHUTDOWN || event == 0xFF) {
+		pr_info("%s: shutdown_event (event=0x%x)\n", __func__, event);
+		schedule_delayed_work(&xdev->shutdown_event, 0);
+		return IRQ_HANDLED;
+	}
+
+	if (likely(xdev->core_irq_callback))
+		return xdev->core_irq_callback(irq, args);
+
+	return IRQ_HANDLED;
+}
+
+int intel_xpcie_pci_register_irq(struct xpcie_dev *xdev, irq_handler_t irq_handler)
+{
+	if (xdev->xpcie.status != XPCIE_STATUS_READY)
+		return -EINVAL;
+
+	xdev->core_irq_callback = irq_handler;
+
+	return 0;
+}
+
 static void intel_xpcie_pci_irq_cleanup(struct xpcie_dev *xdev)
 {
 	int irq = pci_irq_vector(xdev->pci, 0);
@@ -180,8 +223,7 @@ static void intel_xpcie_pci_irq_cleanup(struct xpcie_dev *xdev)
 	pci_free_irq_vectors(xdev->pci);
 }
 
-static int intel_xpcie_pci_irq_init(struct xpcie_dev *xdev,
-				    irq_handler_t irq_handler)
+static int intel_xpcie_pci_irq_init(struct xpcie_dev *xdev)
 {
 	int rc, irq;
 
@@ -198,7 +240,7 @@ static int intel_xpcie_pci_irq_init(struct xpcie_dev *xdev,
 		rc = irq;
 		goto error_irq;
 	}
-	rc = request_irq(irq, irq_handler, 0,
+	rc = request_irq(irq, &intel_xpcie_core_interrupt, 0,
 			 XPCIE_DRIVER_NAME, xdev);
 	if (rc) {
 		dev_err(&xdev->pci->dev, "failed to request irq\n");
@@ -272,8 +314,16 @@ static void xpcie_device_shutdown(struct work_struct *work)
 
 static int xpcie_device_init(struct xpcie_dev *xdev)
 {
+	int rc;
+
 	INIT_DELAYED_WORK(&xdev->wait_event, xpcie_device_poll);
 	INIT_DELAYED_WORK(&xdev->shutdown_event, xpcie_device_shutdown);
+#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+	INIT_WORK(&xdev->irq_event, xpcie_device_irq);
+#endif
+	rc = intel_xpcie_pci_irq_init(xdev);
+	if (rc)
+		return rc;
 
 	pci_set_master(xdev->pci);
 
@@ -349,6 +399,9 @@ int intel_xpcie_pci_cleanup(struct xpcie_dev *xdev)
 
 	cancel_delayed_work(&xdev->wait_event);
 	cancel_delayed_work(&xdev->shutdown_event);
+#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+	cancel_work_sync(&xdev->irq_event);
+#endif
 	xdev->core_irq_callback = NULL;
 	intel_xpcie_pci_irq_cleanup(xdev);
 
@@ -366,21 +419,6 @@ int intel_xpcie_pci_cleanup(struct xpcie_dev *xdev)
 	return 0;
 }
 
-int intel_xpcie_pci_register_irq(struct xpcie_dev *xdev,
-				 irq_handler_t irq_handler)
-{
-	int rc;
-
-	if (xdev->xpcie.status != XPCIE_STATUS_READY)
-		return -EINVAL;
-
-	rc = intel_xpcie_pci_irq_init(xdev, irq_handler);
-	if (rc)
-		dev_warn(&xdev->pci->dev, "failed to initialize pci irq\n");
-
-	return rc;
-}
-
 int intel_xpcie_pci_raise_irq(struct xpcie_dev *xdev,
 			      enum xpcie_doorbell_type type,
 			      u8 value)
@@ -555,3 +593,40 @@ void intel_xpcie_pci_notify_event(struct xpcie_dev *xdev,
 	if (xdev->event_fn)
 		xdev->event_fn(xdev->devid, event_type);
 }
+
+
+#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+struct xpcie_dev *intel_xpcie_get_device_by_name(const char *name)
+{
+	struct xpcie_dev *p;
+	bool found = false;
+
+	mutex_lock(&dev_list_mutex);
+	list_for_each_entry(p, &dev_list, list) {
+		if (!strncmp(p->name, name, XPCIE_MAX_NAME_LEN)) {
+			found = true;
+			break;
+		}
+	}
+	mutex_unlock(&dev_list_mutex);
+
+	if (!found)
+		p = NULL;
+
+	return p;
+}
+
+struct xpcie_dev *intel_xpcie_get_device_by_phys_id(u32 phys_id)
+{
+	struct xpcie_dev *xdev;
+
+	mutex_lock(&dev_list_mutex);
+	list_for_each_entry(xdev, &dev_list, list) {
+		if (xdev->devid == phys_id)
+			break;
+	}
+	mutex_unlock(&dev_list_mutex);
+
+	return xdev;
+}
+#endif
diff --git a/drivers/misc/xlink-pcie/remote_host/pci.h b/drivers/misc/xlink-pcie/remote_host/pci.h
index e0b892752415..20c4b48d845f 100644
--- a/drivers/misc/xlink-pcie/remote_host/pci.h
+++ b/drivers/misc/xlink-pcie/remote_host/pci.h
@@ -17,6 +17,11 @@
 
 #include "../common/xpcie.h"
 #include "../common/util.h"
+#include "../common/boot.h"
+
+#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#include <linux/mxlk_boot_inf.h>
+#endif
 
 #define XPCIE_DRIVER_NAME "mxlk"
 #define XPCIE_DRIVER_DESC "Intel(R) XPCIe XLink PCIe driver"
@@ -43,6 +48,12 @@ struct xpcie_dev {
 
 	struct xpcie xpcie;
 	xlink_device_event event_fn;
+
+#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+	struct work_struct irq_event;
+	bool boot_dev_link;
+	mxlk_pcie_boot_event boot_notif_fn;
+#endif
 };
 
 static inline struct device *xpcie_to_dev(struct xpcie *xpcie)
@@ -68,4 +79,6 @@ void intel_xpcie_list_del_device(struct xpcie_dev *xdev);
 void intel_xpcie_pci_notify_event(struct xpcie_dev *xdev,
 				  enum xlink_device_event_type event_type);
 
+struct xpcie_dev *intel_xpcie_get_device_by_name(const char *name);
+struct xpcie_dev *intel_xpcie_get_device_by_phys_id(u32 phys_id);
 #endif /* XPCIE_PCI_HEADER_ */
-- 
2.27.0

