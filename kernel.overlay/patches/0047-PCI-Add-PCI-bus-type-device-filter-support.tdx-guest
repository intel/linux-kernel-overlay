From 5b889383e24344a6a7d218b3e1e44739b1751f77 Mon Sep 17 00:00:00 2001
From: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
Date: Thu, 3 Jun 2021 20:10:17 -0700
Subject: [PATCH 47/78] PCI: Add PCI bus type device filter support
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Device filter support enables bus drivers to register custom bus
specific device filter functions. For every new device registered
in a given bus, device filter framework will trigger the custom
filter function with platform specific allow list as argument to
verify whether a given device in the bus is allowed or not.

Custom filter is registered using struct bus_type.device_filter
member via bus_register() function.

For PCI bus, add a custom filter to allow or dis-allow the device
based on vendor and device ID. 

Reviewed-by: Andi Kleen <ak@linux.intel.com>
Signed-off-by: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
---
 drivers/pci/pci-driver.c | 43 ++++++++++++++++++++++++++++++++++++++++
 include/linux/pci.h      | 20 +++++++++++++++++++
 2 files changed, 63 insertions(+)

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index ec44a79e951a..aade1daf047b 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -20,6 +20,7 @@
 #include <linux/of_device.h>
 #include <linux/acpi.h>
 #include <linux/dma-map-ops.h>
+#include <linux/device/filter.h>
 #include "pci.h"
 #include "pcie/portdrv.h"
 
@@ -28,6 +29,47 @@ struct pci_dynid {
 	struct pci_device_id id;
 };
 
+/* pci_is_device_allowed() - Used to check whether given PCI
+ *			     device registration is allowed or
+ *			     not.
+ *
+ * This function will be called by device filter framework to
+ * check whether given device in PCI bus is allowed or blocked.
+ *
+ * Return true to allow device registration or false for
+ * blocking it.
+ */
+static bool pci_is_device_allowed(struct device *dev, void *data)
+{
+	struct pci_dev *pdev = to_pci_dev(dev);
+	struct pci_dev_filter_data *pdata = data;
+	bool status = false;
+	struct pci_filter_node *allow_list;
+	int i;
+
+	/* If PCI filter allow list does not exit, just return */
+	if (!pdata)
+		goto done;
+
+	allow_list = pdata->allow_list;
+
+	for (i = 0; i < pdata->len; i++) {
+		if ((allow_list[i].vendor == pdev->vendor ||
+		     allow_list[i].vendor == PCI_ANY_ID) &&
+		    (allow_list[i].device == pdev->device ||
+		     allow_list[i].device == PCI_ANY_ID)) {
+			status = true;
+			break;
+		}
+	}
+
+done:
+	pr_debug("PCI vendor:%x device:%x %s\n", pdev->vendor,
+		 pdev->device, status ? "allowed" : "blocked");
+
+	return status;
+}
+
 /**
  * pci_add_dynid - add a new PCI device ID to this driver and re-probe devices
  * @drv: target pci driver
@@ -1609,6 +1651,7 @@ struct bus_type pci_bus_type = {
 	.pm		= PCI_PM_OPS_PTR,
 	.num_vf		= pci_bus_num_vf,
 	.dma_configure	= pci_dma_configure,
+	.device_filter  = pci_is_device_allowed,
 };
 EXPORT_SYMBOL(pci_bus_type);
 
diff --git a/include/linux/pci.h b/include/linux/pci.h
index 24306504226a..05b1136b8140 100644
--- a/include/linux/pci.h
+++ b/include/linux/pci.h
@@ -970,6 +970,26 @@ enum {
 #define PCI_IRQ_MSIX		(1 << 2) /* Allow MSI-X interrupts */
 #define PCI_IRQ_AFFINITY	(1 << 3) /* Auto-assign affinity */
 
+/*
+ * struct pci_filter_node - PCI driver filter structure
+ * @vendor:	Device vendor ID
+ * @device:	Device ID
+ */
+struct pci_filter_node {
+	unsigned short vendor;
+	unsigned short device;
+};
+
+/*
+ * struct pci_dev_filter_data - PCI device filter data
+ * @allow_list: List of allowed PCI devices.
+ * @len: Length of allowed list.
+ */
+struct pci_dev_filter_data {
+	struct pci_filter_node *allow_list;
+	unsigned int len;
+};
+
 /* These external functions are only available when PCI support is enabled */
 #ifdef CONFIG_PCI
 
-- 
2.27.0

