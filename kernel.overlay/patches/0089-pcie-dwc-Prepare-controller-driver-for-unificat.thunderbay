From 26a59a3bbe01b657e943184a735b5112f07e46b9 Mon Sep 17 00:00:00 2001
From: Srikanth Thokala <srikanth.thokala@intel.com>
Date: Mon, 8 Feb 2021 14:59:26 +0530
Subject: [PATCH 089/170] pcie: dwc: Prepare controller driver for unification

Rename keembay to xbay

Signed-off-by: Srikanth Thokala <srikanth.thokala@intel.com>
---
 ...y-pcie-ep.yaml => intel,xbay-pcie-ep.yaml} |   0
 ...keembay-pcie.yaml => intel,xbay-pcie.yaml} |   0
 drivers/pci/controller/dwc/Kconfig            |  10 +-
 drivers/pci/controller/dwc/Makefile           |   2 +-
 .../dwc/{pcie-keembay.c => pcie-intel-xbay.c} | 126 +++++++++---------
 5 files changed, 69 insertions(+), 69 deletions(-)
 rename Documentation/devicetree/bindings/pci/{intel,keembay-pcie-ep.yaml => intel,xbay-pcie-ep.yaml} (100%)
 rename Documentation/devicetree/bindings/pci/{intel,keembay-pcie.yaml => intel,xbay-pcie.yaml} (100%)
 rename drivers/pci/controller/dwc/{pcie-keembay.c => pcie-intel-xbay.c} (72%)

diff --git a/Documentation/devicetree/bindings/pci/intel,keembay-pcie-ep.yaml b/Documentation/devicetree/bindings/pci/intel,xbay-pcie-ep.yaml
similarity index 100%
rename from Documentation/devicetree/bindings/pci/intel,keembay-pcie-ep.yaml
rename to Documentation/devicetree/bindings/pci/intel,xbay-pcie-ep.yaml
diff --git a/Documentation/devicetree/bindings/pci/intel,keembay-pcie.yaml b/Documentation/devicetree/bindings/pci/intel,xbay-pcie.yaml
similarity index 100%
rename from Documentation/devicetree/bindings/pci/intel,keembay-pcie.yaml
rename to Documentation/devicetree/bindings/pci/intel,xbay-pcie.yaml
diff --git a/drivers/pci/controller/dwc/Kconfig b/drivers/pci/controller/dwc/Kconfig
index 7558e81376d2..7cc130e11252 100644
--- a/drivers/pci/controller/dwc/Kconfig
+++ b/drivers/pci/controller/dwc/Kconfig
@@ -225,28 +225,28 @@ config PCIE_INTEL_GW
 	  The PCIe controller uses the DesignWare core plus Intel-specific
 	  hardware wrappers.
 
-config PCIE_KEEMBAY
+config PCIE_INTEL_XBAY
 	bool
 
-config PCIE_KEEMBAY_HOST
+config PCIE_INTEL_XBAY_HOST
 	bool "Intel Keem Bay PCIe controller - Host mode"
 	depends on ARCH_KEEMBAY || COMPILE_TEST
 	depends on PCI && PCI_MSI_IRQ_DOMAIN
 	select PCIE_DW_HOST
-	select PCIE_KEEMBAY
+	select PCIE_INTEL_XBAY
 	help
 	  Say 'Y' here to enable support for the PCIe controller in Keem Bay
 	  to work in host mode.
 	  The PCIe controller is based on Designware Hardware and uses
 	  DesignWare core functions.
 
-config PCIE_KEEMBAY_EP
+config PCIE_INTEL_XBAY_EP
 	bool "Intel Keem Bay PCIe controller - Endpoint mode"
 	depends on ARCH_KEEMBAY || COMPILE_TEST
 	depends on PCI && PCI_MSI_IRQ_DOMAIN
 	depends on PCI_ENDPOINT
 	select PCIE_DW_EP
-	select PCIE_KEEMBAY
+	select PCIE_INTEL_XBAY
 	help
 	  Say 'Y' here to enable support for the PCIe controller in Keem Bay
 	  to work in endpoint mode.
diff --git a/drivers/pci/controller/dwc/Makefile b/drivers/pci/controller/dwc/Makefile
index 8b3e7176b4bf..fc5a200fb5f6 100644
--- a/drivers/pci/controller/dwc/Makefile
+++ b/drivers/pci/controller/dwc/Makefile
@@ -15,7 +15,7 @@ obj-$(CONFIG_PCIE_QCOM) += pcie-qcom.o
 obj-$(CONFIG_PCIE_ARMADA_8K) += pcie-armada8k.o
 obj-$(CONFIG_PCIE_ARTPEC6) += pcie-artpec6.o
 obj-$(CONFIG_PCIE_INTEL_GW) += pcie-intel-gw.o
-obj-$(CONFIG_PCIE_KEEMBAY) += pcie-keembay.o
+obj-$(CONFIG_PCIE_INTEL_XBAY) += pcie-intel-xbay.o
 obj-$(CONFIG_PCIE_KIRIN) += pcie-kirin.o
 obj-$(CONFIG_PCIE_HISI_STB) += pcie-histb.o
 obj-$(CONFIG_PCI_MESON) += pci-meson.o
diff --git a/drivers/pci/controller/dwc/pcie-keembay.c b/drivers/pci/controller/dwc/pcie-intel-xbay.c
similarity index 72%
rename from drivers/pci/controller/dwc/pcie-keembay.c
rename to drivers/pci/controller/dwc/pcie-intel-xbay.c
index 1064e9649340..453678151f11 100644
--- a/drivers/pci/controller/dwc/pcie-keembay.c
+++ b/drivers/pci/controller/dwc/pcie-intel-xbay.c
@@ -54,7 +54,7 @@
 #define PERST_DELAY_US		1000
 #define AUX_CLK_RATE_HZ		24000000
 
-struct keembay_pcie {
+struct xbay_pcie {
 	struct dw_pcie		pci;
 	void __iomem		*apb_base;
 	enum dw_pcie_device_mode mode;
@@ -64,17 +64,17 @@ struct keembay_pcie {
 	struct gpio_desc	*reset;
 };
 
-struct keembay_pcie_of_data {
+struct xbay_pcie_of_data {
 	enum dw_pcie_device_mode mode;
 };
 
-static void keembay_ep_reset_assert(struct keembay_pcie *pcie)
+static void xbay_ep_reset_assert(struct xbay_pcie *pcie)
 {
 	gpiod_set_value_cansleep(pcie->reset, 1);
 	usleep_range(PERST_DELAY_US, PERST_DELAY_US + 500);
 }
 
-static void keembay_ep_reset_deassert(struct keembay_pcie *pcie)
+static void xbay_ep_reset_deassert(struct xbay_pcie *pcie)
 {
 	/*
 	 * Ensure that PERST# is asserted for a minimum of 100ms
@@ -88,7 +88,7 @@ static void keembay_ep_reset_deassert(struct keembay_pcie *pcie)
 	usleep_range(PERST_DELAY_US, PERST_DELAY_US + 500);
 }
 
-static void keembay_pcie_ltssm_enable(struct keembay_pcie *pcie, bool enable)
+static void xbay_pcie_ltssm_enable(struct xbay_pcie *pcie, bool enable)
 {
 	u32 val;
 
@@ -100,9 +100,9 @@ static void keembay_pcie_ltssm_enable(struct keembay_pcie *pcie, bool enable)
 	writel(val, pcie->apb_base + PCIE_REGS_PCIE_APP_CNTRL);
 }
 
-static int keembay_pcie_link_up(struct dw_pcie *pci)
+static int xbay_pcie_link_up(struct dw_pcie *pci)
 {
-	struct keembay_pcie *pcie = dev_get_drvdata(pci->dev);
+	struct xbay_pcie *pcie = dev_get_drvdata(pci->dev);
 	u32 val;
 
 	val = readl(pcie->apb_base + PCIE_REGS_PCIE_SII_PM_STATE);
@@ -110,16 +110,16 @@ static int keembay_pcie_link_up(struct dw_pcie *pci)
 	return (val & PCIE_REGS_PCIE_SII_LINK_UP) == PCIE_REGS_PCIE_SII_LINK_UP;
 }
 
-static int keembay_pcie_start_link(struct dw_pcie *pci)
+static int xbay_pcie_start_link(struct dw_pcie *pci)
 {
-	struct keembay_pcie *pcie = dev_get_drvdata(pci->dev);
+	struct xbay_pcie *pcie = dev_get_drvdata(pci->dev);
 	u32 val;
 	int ret;
 
 	if (pcie->mode == DW_PCIE_EP_TYPE)
 		return 0;
 
-	keembay_pcie_ltssm_enable(pcie, false);
+	xbay_pcie_ltssm_enable(pcie, false);
 
 	ret = readl_poll_timeout(pcie->apb_base + PCIE_REGS_PCIE_PHY_STAT,
 				 val, val & PHY0_MPLLA_STATE, 20,
@@ -129,25 +129,25 @@ static int keembay_pcie_start_link(struct dw_pcie *pci)
 		return ret;
 	}
 
-	keembay_pcie_ltssm_enable(pcie, true);
+	xbay_pcie_ltssm_enable(pcie, true);
 
 	return 0;
 }
 
-static void keembay_pcie_stop_link(struct dw_pcie *pci)
+static void xbay_pcie_stop_link(struct dw_pcie *pci)
 {
-	struct keembay_pcie *pcie = dev_get_drvdata(pci->dev);
+	struct xbay_pcie *pcie = dev_get_drvdata(pci->dev);
 
-	keembay_pcie_ltssm_enable(pcie, false);
+	xbay_pcie_ltssm_enable(pcie, false);
 }
 
-static const struct dw_pcie_ops keembay_pcie_ops = {
-	.link_up	= keembay_pcie_link_up,
-	.start_link	= keembay_pcie_start_link,
-	.stop_link	= keembay_pcie_stop_link,
+static const struct dw_pcie_ops xbay_pcie_ops = {
+	.link_up	= xbay_pcie_link_up,
+	.start_link	= xbay_pcie_start_link,
+	.stop_link	= xbay_pcie_stop_link,
 };
 
-static inline struct clk *keembay_pcie_probe_clock(struct device *dev,
+static inline struct clk *xbay_pcie_probe_clock(struct device *dev,
 						   const char *id, u64 rate)
 {
 	struct clk *clk;
@@ -176,17 +176,17 @@ static inline struct clk *keembay_pcie_probe_clock(struct device *dev,
 	return clk;
 }
 
-static int keembay_pcie_probe_clocks(struct keembay_pcie *pcie)
+static int xbay_pcie_probe_clocks(struct xbay_pcie *pcie)
 {
 	struct dw_pcie *pci = &pcie->pci;
 	struct device *dev = pci->dev;
 
-	pcie->clk_master = keembay_pcie_probe_clock(dev, "master", 0);
+	pcie->clk_master = xbay_pcie_probe_clock(dev, "master", 0);
 	if (IS_ERR(pcie->clk_master))
 		return dev_err_probe(dev, PTR_ERR(pcie->clk_master),
 				     "Failed to enable master clock");
 
-	pcie->clk_aux = keembay_pcie_probe_clock(dev, "aux", AUX_CLK_RATE_HZ);
+	pcie->clk_aux = xbay_pcie_probe_clock(dev, "aux", AUX_CLK_RATE_HZ);
 	if (IS_ERR(pcie->clk_aux))
 		return dev_err_probe(dev, PTR_ERR(pcie->clk_aux),
 				     "Failed to enable auxiliary clock");
@@ -200,7 +200,7 @@ static int keembay_pcie_probe_clocks(struct keembay_pcie *pcie)
  * (1) 6.4.6.1 PCIe Subsystem Example Initialization,
  * (2) 6.8 PCIe Low Jitter PLL for Ref Clk Generation.
  */
-static int keembay_pcie_pll_init(struct keembay_pcie *pcie)
+static int xbay_pcie_pll_init(struct xbay_pcie *pcie)
 {
 	struct dw_pcie *pci = &pcie->pci;
 	u32 val;
@@ -225,9 +225,9 @@ static int keembay_pcie_pll_init(struct keembay_pcie *pcie)
 	return ret;
 }
 
-static irqreturn_t keembay_pcie_irq_handler(int irq, void *arg)
+static irqreturn_t xbay_pcie_irq_handler(int irq, void *arg)
 {
-	struct keembay_pcie *pcie = arg;
+	struct xbay_pcie *pcie = arg;
 	struct dw_pcie *pci = &pcie->pci;
 	struct pcie_port *pp = &pci->pp;
 	u32 val, mask, status;
@@ -247,7 +247,7 @@ static irqreturn_t keembay_pcie_irq_handler(int irq, void *arg)
 	return IRQ_HANDLED;
 }
 
-static int keembay_pcie_setup_irq(struct keembay_pcie *pcie)
+static int xbay_pcie_setup_irq(struct xbay_pcie *pcie)
 {
 	struct dw_pcie *pci = &pcie->pci;
 	struct device *dev = pci->dev;
@@ -258,7 +258,7 @@ static int keembay_pcie_setup_irq(struct keembay_pcie *pcie)
 	if (irq < 0)
 		return irq;
 
-	ret = devm_request_irq(dev, irq, keembay_pcie_irq_handler,
+	ret = devm_request_irq(dev, irq, xbay_pcie_irq_handler,
 			       IRQF_SHARED | IRQF_NO_THREAD, "pcie", pcie);
 	if (ret)
 		dev_err(dev, "Failed to request IRQ: %d\n", ret);
@@ -266,15 +266,15 @@ static int keembay_pcie_setup_irq(struct keembay_pcie *pcie)
 	return ret;
 }
 
-static void keembay_pcie_ep_init(struct dw_pcie_ep *ep)
+static void xbay_pcie_ep_init(struct dw_pcie_ep *ep)
 {
 	struct dw_pcie *pci = to_dw_pcie_from_ep(ep);
-	struct keembay_pcie *pcie = dev_get_drvdata(pci->dev);
+	struct xbay_pcie *pcie = dev_get_drvdata(pci->dev);
 
 	writel(EDMA_INT_EN, pcie->apb_base + PCIE_REGS_INTERRUPT_ENABLE);
 }
 
-static int keembay_pcie_ep_raise_irq(struct dw_pcie_ep *ep, u8 func_no,
+static int xbay_pcie_ep_raise_irq(struct dw_pcie_ep *ep, u8 func_no,
 				     enum pci_epc_irq_type type,
 				     u16 interrupt_num)
 {
@@ -295,7 +295,7 @@ static int keembay_pcie_ep_raise_irq(struct dw_pcie_ep *ep, u8 func_no,
 	}
 }
 
-static const struct pci_epc_features keembay_pcie_epc_features = {
+static const struct pci_epc_features xbay_pcie_epc_features = {
 	.linkup_notifier	= false,
 	.msi_capable		= true,
 	.msix_capable		= true,
@@ -305,21 +305,21 @@ static const struct pci_epc_features keembay_pcie_epc_features = {
 };
 
 static const struct pci_epc_features *
-keembay_pcie_get_features(struct dw_pcie_ep *ep)
+xbay_pcie_get_features(struct dw_pcie_ep *ep)
 {
-	return &keembay_pcie_epc_features;
+	return &xbay_pcie_epc_features;
 }
 
-static const struct dw_pcie_ep_ops keembay_pcie_ep_ops = {
-	.ep_init	= keembay_pcie_ep_init,
-	.raise_irq	= keembay_pcie_ep_raise_irq,
-	.get_features	= keembay_pcie_get_features,
+static const struct dw_pcie_ep_ops xbay_pcie_ep_ops = {
+	.ep_init	= xbay_pcie_ep_init,
+	.raise_irq	= xbay_pcie_ep_raise_irq,
+	.get_features	= xbay_pcie_get_features,
 };
 
-static const struct dw_pcie_host_ops keembay_pcie_host_ops = {
+static const struct dw_pcie_host_ops xbay_pcie_host_ops = {
 };
 
-static int keembay_pcie_add_pcie_port(struct keembay_pcie *pcie,
+static int xbay_pcie_add_pcie_port(struct xbay_pcie *pcie,
 				      struct platform_device *pdev)
 {
 	struct dw_pcie *pci = &pcie->pci;
@@ -328,14 +328,14 @@ static int keembay_pcie_add_pcie_port(struct keembay_pcie *pcie,
 	u32 val;
 	int ret;
 
-	pp->ops = &keembay_pcie_host_ops;
+	pp->ops = &xbay_pcie_host_ops;
 	pp->msi_irq = -ENODEV;
 
 	pcie->reset = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
 	if (IS_ERR(pcie->reset))
 		return PTR_ERR(pcie->reset);
 
-	ret = keembay_pcie_probe_clocks(pcie);
+	ret = xbay_pcie_probe_clocks(pcie);
 	if (ret)
 		return ret;
 
@@ -345,17 +345,17 @@ static int keembay_pcie_add_pcie_port(struct keembay_pcie *pcie,
 
 	writel(PCIE_DEVICE_TYPE, pcie->apb_base + PCIE_REGS_PCIE_CFG);
 
-	ret = keembay_pcie_pll_init(pcie);
+	ret = xbay_pcie_pll_init(pcie);
 	if (ret)
 		return ret;
 
 	val = readl(pcie->apb_base + PCIE_REGS_PCIE_CFG);
 	writel(val | PCIE_RSTN, pcie->apb_base + PCIE_REGS_PCIE_CFG);
-	keembay_ep_reset_deassert(pcie);
+	xbay_ep_reset_deassert(pcie);
 
 	ret = dw_pcie_host_init(pp);
 	if (ret) {
-		keembay_ep_reset_assert(pcie);
+		xbay_ep_reset_assert(pcie);
 		dev_err(dev, "Failed to initialize host: %d\n", ret);
 		return ret;
 	}
@@ -368,11 +368,11 @@ static int keembay_pcie_add_pcie_port(struct keembay_pcie *pcie,
 	return 0;
 }
 
-static int keembay_pcie_probe(struct platform_device *pdev)
+static int xbay_pcie_probe(struct platform_device *pdev)
 {
-	const struct keembay_pcie_of_data *data;
+	const struct xbay_pcie_of_data *data;
 	struct device *dev = &pdev->dev;
-	struct keembay_pcie *pcie;
+	struct xbay_pcie *pcie;
 	struct dw_pcie *pci;
 	enum dw_pcie_device_mode mode;
 	int ret;
@@ -389,7 +389,7 @@ static int keembay_pcie_probe(struct platform_device *pdev)
 
 	pci = &pcie->pci;
 	pci->dev = dev;
-	pci->ops = &keembay_pcie_ops;
+	pci->ops = &xbay_pcie_ops;
 
 	pcie->mode = mode;
 
@@ -397,7 +397,7 @@ static int keembay_pcie_probe(struct platform_device *pdev)
 	if (IS_ERR(pcie->apb_base))
 		return PTR_ERR(pcie->apb_base);
 
-	ret = keembay_pcie_setup_irq(pcie);
+	ret = xbay_pcie_setup_irq(pcie);
 	if (ret)
 		return ret;
 
@@ -408,12 +408,12 @@ static int keembay_pcie_probe(struct platform_device *pdev)
 		if (!IS_ENABLED(CONFIG_PCIE_KEEMBAY_HOST))
 			return -ENODEV;
 
-		return keembay_pcie_add_pcie_port(pcie, pdev);
+		return xbay_pcie_add_pcie_port(pcie, pdev);
 	case DW_PCIE_EP_TYPE:
 		if (!IS_ENABLED(CONFIG_PCIE_KEEMBAY_EP))
 			return -ENODEV;
 
-		pci->ep.ops = &keembay_pcie_ep_ops;
+		pci->ep.ops = &xbay_pcie_ep_ops;
 		return dw_pcie_ep_init(&pci->ep);
 	default:
 		dev_err(dev, "Invalid device type %d\n", pcie->mode);
@@ -421,32 +421,32 @@ static int keembay_pcie_probe(struct platform_device *pdev)
 	}
 }
 
-static const struct keembay_pcie_of_data keembay_pcie_rc_of_data = {
+static const struct xbay_pcie_of_data xbay_pcie_rc_of_data = {
 	.mode = DW_PCIE_RC_TYPE,
 };
 
-static const struct keembay_pcie_of_data keembay_pcie_ep_of_data = {
+static const struct xbay_pcie_of_data xbay_pcie_ep_of_data = {
 	.mode = DW_PCIE_EP_TYPE,
 };
 
-static const struct of_device_id keembay_pcie_of_match[] = {
+static const struct of_device_id xbay_pcie_of_match[] = {
 	{
-		.compatible = "intel,keembay-pcie",
-		.data = &keembay_pcie_rc_of_data,
+		.compatible = "intel,xbay-pcie",
+		.data = &xbay_pcie_rc_of_data,
 	},
 	{
-		.compatible = "intel,keembay-pcie-ep",
-		.data = &keembay_pcie_ep_of_data,
+		.compatible = "intel,xbay-pcie-ep",
+		.data = &xbay_pcie_ep_of_data,
 	},
 	{}
 };
 
-static struct platform_driver keembay_pcie_driver = {
+static struct platform_driver xbay_pcie_driver = {
 	.driver = {
-		.name = "keembay-pcie",
-		.of_match_table = keembay_pcie_of_match,
+		.name = "xbay-pcie",
+		.of_match_table = xbay_pcie_of_match,
 		.suppress_bind_attrs = true,
 	},
-	.probe  = keembay_pcie_probe,
+	.probe  = xbay_pcie_probe,
 };
-builtin_platform_driver(keembay_pcie_driver);
+builtin_platform_driver(xbay_pcie_driver);
-- 
2.27.0

