From ea1232804260afaeab0983b7bfb7d4ca86a1517e Mon Sep 17 00:00:00 2001
From: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date: Tue, 22 Jun 2021 18:47:01 -0700
Subject: [PATCH 72/80] x86/hfi: Notify user space for HFI events

When HFI event is sent by the firmware, they may be to force move
workload away from some CPUs or for better performance on other CPUs.
When firmware is trying to avoid scheduling on a CPU, this is more
reactive measure. When too many such events are happening user space
can proactively adjust power limits of CPUs so that such events can be
avoided from the firmware in future. Also allows user space to adjust
interrupt affenities from CPUs which should stay idle to give better
performance on other CPUs.

When a HFI event is processed, also notify user space using the
existing thermal notification mechanism. To avoid excessive
notifications, it is rate limited to send one notification in a second.

Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
---
 drivers/thermal/intel/Kconfig     |  3 ++-
 drivers/thermal/intel/intel_hfi.c | 19 +++++++++++++++++++
 2 files changed, 21 insertions(+), 1 deletion(-)

diff --git a/drivers/thermal/intel/Kconfig b/drivers/thermal/intel/Kconfig
index 5edbc9a6ed64..ddb319b95a60 100644
--- a/drivers/thermal/intel/Kconfig
+++ b/drivers/thermal/intel/Kconfig
@@ -94,8 +94,9 @@ config INTEL_TCC_COOLING
 config INTEL_HFI
 	bool "Intel Hardware Feedback Interface"
 	depends on CPU_SUP_INTEL
-	depends on SCHED_MC && X86_THERMAL_VECTOR
+	depends on SCHED_MC && X86_THERMAL_VECTOR && IDLE_INJECT
 	select ENERGY_MODEL
+	select CONFIG_THERMAL_NETLINK
 	help
 	  Select this option to enable the Hardware Feedback Interface in
 	  Intel hybrid processors. If selected, hardware provides guidance to
diff --git a/drivers/thermal/intel/intel_hfi.c b/drivers/thermal/intel/intel_hfi.c
index 4a3215497160..9d96e0e16d1a 100644
--- a/drivers/thermal/intel/intel_hfi.c
+++ b/drivers/thermal/intel/intel_hfi.c
@@ -29,6 +29,8 @@
 
 #include <asm/hfi.h>
 
+#include "../thermal_core.h"
+
 #define THERM_STATUS_CLEAR_PKG_MASK (BIT(1) | BIT(3) | BIT(5) | BIT(7) | \
 				     BIT(9) | BIT(11) | BIT(26))
 
@@ -75,6 +77,7 @@ struct hfi_hdr {
  * @cpus:		CPUs represented in this HFI table instance
  * @hw_table:		Pointer to the HFI table of this instance
  * @update_work:	Delayed work to process HFI updates
+ * @thermal_work:	Delayed work for thermal notification
  * @hfi_event_lock:	Lock to protect HFI updates
  * @timestamp:		Time-stamp of the last HFI update
  * @initialized:	True if this HFI instance has bee initialized
@@ -92,6 +95,7 @@ struct hfi_params {
 	cpumask_var_t		cpus;
 	void			*hw_table;
 	struct delayed_work	update_work;
+	struct delayed_work	thermal_work;
 	raw_spinlock_t		hfi_event_lock;
 	u64			timestamp;
 	bool			initialized;
@@ -660,6 +664,16 @@ static void update_capabilities(struct hfi_params *params)
 	init_asym_capacity();
 }
 
+#define THERM_NOTIFY_INTERVAL	HZ
+
+static void hfi_thermal_notify_work_fn(struct work_struct *work)
+{
+	struct hfi_params *params = container_of(to_delayed_work(work),
+						 struct hfi_params, thermal_work);
+
+	thermal_notify_cpu_capacities_change(*params->ts_counter);
+}
+
 static void hfi_update_work_fn(struct work_struct *work)
 {
 	struct hfi_cpu_info *info = &per_cpu(hfi_cpu_info, smp_processor_id());
@@ -697,6 +711,9 @@ static void hfi_update_work_fn(struct work_struct *work)
 	raw_spin_lock_irqsave(&params->hfi_event_lock, flags);
 	params->processing_update = false;
 	raw_spin_unlock_irqrestore(&params->hfi_event_lock, flags);
+
+	schedule_delayed_work(&params->thermal_work, THERM_NOTIFY_INTERVAL);
+
 	hfi_debug("Done with HFI work in CPU%d\n", smp_processor_id());
 }
 
@@ -949,6 +966,7 @@ int enable_hfi(unsigned int cpu)
 	init_hfi_params(params);
 
 	INIT_DELAYED_WORK(&params->update_work, hfi_update_work_fn);
+	INIT_DELAYED_WORK(&params->thermal_work, hfi_thermal_notify_work_fn);
 	raw_spin_lock_init(&params->hfi_event_lock);
 
 	cpumask_set_cpu(cpu, params->cpus);
@@ -1024,6 +1042,7 @@ int disable_hfi(unsigned int cpu)
 		 * pointless to process the pending update.
 		 */
 		cancel_delayed_work_sync(&params->update_work);
+		cancel_delayed_work_sync(&params->thermal_work);
 		params->processing_update = false;
 
 		params->handling_cpu = nr_cpu_ids;
-- 
2.27.0

