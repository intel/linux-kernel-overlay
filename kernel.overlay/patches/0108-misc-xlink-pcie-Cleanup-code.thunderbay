From 3dc9136472ca3c019a0e639032c53c613ee068b3 Mon Sep 17 00:00:00 2001
From: Srikanth Thokala <srikanth.thokala@intel.com>
Date: Wed, 28 Oct 2020 17:48:01 +0530
Subject: [PATCH 108/170] misc: xlink-pcie: Cleanup code

- Fix sparse warnings
- Changes required to split into multiple patches for upstream branch

Signed-off-by: Srikanth Thokala <srikanth.thokala@intel.com>
---
 drivers/misc/xlink-pcie/Kconfig               |   4 +-
 drivers/misc/xlink-pcie/common/capabilities.h | 134 -----------
 drivers/misc/xlink-pcie/common/common.h       | 154 -------------
 drivers/misc/xlink-pcie/common/core.h         | 216 +++++++++++++++++-
 drivers/misc/xlink-pcie/common/interface.c    |   5 +-
 drivers/misc/xlink-pcie/common/util.c         | 152 ++++--------
 drivers/misc/xlink-pcie/common/util.h         |   6 +-
 drivers/misc/xlink-pcie/common/xpcie.h        | 160 ++++++-------
 drivers/misc/xlink-pcie/local_host/Makefile   |   4 +-
 drivers/misc/xlink-pcie/local_host/core.c     |  80 +++----
 drivers/misc/xlink-pcie/local_host/dma.c      | 123 +++++-----
 drivers/misc/xlink-pcie/local_host/dma.h      |  24 --
 drivers/misc/xlink-pcie/local_host/epf.c      | 205 ++++++++---------
 drivers/misc/xlink-pcie/local_host/epf.h      |  89 +++++++-
 drivers/misc/xlink-pcie/local_host/struct.h   |  81 -------
 drivers/misc/xlink-pcie/remote_host/Makefile  |   4 +-
 drivers/misc/xlink-pcie/remote_host/core.c    |  58 ++---
 drivers/misc/xlink-pcie/remote_host/main.c    |   4 +-
 drivers/misc/xlink-pcie/remote_host/pci.c     |  48 ++--
 drivers/misc/xlink-pcie/remote_host/pci.h     |   6 +-
 20 files changed, 649 insertions(+), 908 deletions(-)
 delete mode 100644 drivers/misc/xlink-pcie/common/capabilities.h
 delete mode 100644 drivers/misc/xlink-pcie/common/common.h
 delete mode 100644 drivers/misc/xlink-pcie/local_host/dma.h
 delete mode 100644 drivers/misc/xlink-pcie/local_host/struct.h

diff --git a/drivers/misc/xlink-pcie/Kconfig b/drivers/misc/xlink-pcie/Kconfig
index 5c5c1b65b725..448b9bfbdfa2 100644
--- a/drivers/misc/xlink-pcie/Kconfig
+++ b/drivers/misc/xlink-pcie/Kconfig
@@ -1,6 +1,6 @@
 config XLINK_PCIE_RH_DRIVER
 	tristate "XLink PCIe Remote Host driver"
-	depends on PCI && XLINK_PCIE_LH_DRIVER=n
+	depends on PCI && X86_64
 	help
 	  This option enables XLink PCIe Remote Host driver.
 
@@ -11,7 +11,7 @@ config XLINK_PCIE_RH_DRIVER
 
 config XLINK_PCIE_LH_DRIVER
 	tristate "XLink PCIe Local Host driver"
-	depends on PCI_ENDPOINT
+	depends on PCI_ENDPOINT && ARCH_KEEMBAY
 	help
 	  This option enables XLink PCIe Local Host driver.
 
diff --git a/drivers/misc/xlink-pcie/common/capabilities.h b/drivers/misc/xlink-pcie/common/capabilities.h
deleted file mode 100644
index e49c247a2de0..000000000000
--- a/drivers/misc/xlink-pcie/common/capabilities.h
+++ /dev/null
@@ -1,134 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0-only */
-/*****************************************************************************
- *
- * Intel Keem Bay XLink PCIe Driver
- *
- * Copyright (C) 2020 Intel Corporation
- *
- ****************************************************************************/
-
-#ifndef XPCIE_CAPABILITIES_HEADER_
-#define XPCIE_CAPABILITIES_HEADER_
-
-#include "xpcie.h"
-#include "common.h"
-
-#define XPCIE_CAP_TTL (32)
-
-static inline
-void *intel_xpcie_cap_find(struct xpcie *xpcie, u32 start, u16 id)
-{
-	int ttl = XPCIE_CAP_TTL;
-	struct xpcie_cap_hdr *hdr;
-	struct xpcie_cap_hdr cur_hdr;
-
-	/* If user didn't specify start, assume start of mmio */
-	if (!start)
-		start = intel_xpcie_ioread32(&xpcie->mmio->cap_offset);
-
-	/* Read header info */
-#ifdef XLINK_PCIE_REMOTE
-	hdr = (struct xpcie_cap_hdr *)((void __iomem *)xpcie->mmio + start);
-#else
-	hdr = (struct xpcie_cap_hdr *)((void *)xpcie->mmio + start);
-#endif
-	/* Check if we still have time to live */
-	while (ttl--) {
-#ifdef XLINK_PCIE_REMOTE
-		memcpy_fromio(&cur_hdr, hdr, sizeof(struct xpcie_cap_hdr));
-#else
-		cur_hdr = *hdr;
-#endif
-		/* If cap matches, return header */
-		if (cur_hdr.id == id)
-			return hdr;
-		/* If cap is NULL, we are at the end of the list */
-		else if (cur_hdr.id == XPCIE_CAP_NULL)
-			return NULL;
-		/* If no match and no end of list, traverse the linked list */
-		else
-#ifdef XLINK_PCIE_REMOTE
-			hdr = (struct xpcie_cap_hdr *)
-				((void __iomem *)xpcie->mmio + cur_hdr.next);
-#else
-			hdr = (struct xpcie_cap_hdr *)
-				((void *)xpcie->mmio + cur_hdr.next);
-#endif
-	}
-
-	/* If we reached here, the capability list is corrupted */
-	return NULL;
-}
-
-static inline
-void intel_xpcie_set_td_address(struct xpcie_transfer_desc *td, u64 address)
-{
-	intel_xpcie_iowrite64(address, &td->address);
-}
-
-static inline
-u64 intel_xpcie_get_td_address(struct xpcie_transfer_desc *td)
-{
-	return intel_xpcie_ioread64(&td->address);
-}
-
-static inline
-void intel_xpcie_set_td_length(struct xpcie_transfer_desc *td, u32 length)
-{
-	intel_xpcie_iowrite32(length, &td->length);
-}
-
-static inline
-u32 intel_xpcie_get_td_length(struct xpcie_transfer_desc *td)
-{
-	return intel_xpcie_ioread32(&td->length);
-}
-
-static inline
-void intel_xpcie_set_td_interface(struct xpcie_transfer_desc *td, u16 interface)
-{
-	intel_xpcie_iowrite16(interface, &td->interface);
-}
-
-static inline
-u16 intel_xpcie_get_td_interface(struct xpcie_transfer_desc *td)
-{
-	return intel_xpcie_ioread16(&td->interface);
-}
-
-static inline
-void intel_xpcie_set_td_status(struct xpcie_transfer_desc *td, u16 status)
-{
-	intel_xpcie_iowrite16(status, &td->status);
-}
-
-static inline
-u16 intel_xpcie_get_td_status(struct xpcie_transfer_desc *td)
-{
-	return intel_xpcie_ioread16(&td->status);
-}
-
-static inline
-void intel_xpcie_set_tdr_head(struct xpcie_pipe *p, u32 head)
-{
-	intel_xpcie_iowrite32(head, p->head);
-}
-
-static inline
-u32 intel_xpcie_get_tdr_head(struct xpcie_pipe *p)
-{
-	return intel_xpcie_ioread32(p->head);
-}
-
-static inline
-void intel_xpcie_set_tdr_tail(struct xpcie_pipe *p, u32 tail)
-{
-	intel_xpcie_iowrite32(tail, p->tail);
-}
-
-static inline
-u32 intel_xpcie_get_tdr_tail(struct xpcie_pipe *p)
-{
-	return intel_xpcie_ioread32(p->tail);
-}
-#endif /* XPCIE_CAPABILITIES_HEADER_ */
diff --git a/drivers/misc/xlink-pcie/common/common.h b/drivers/misc/xlink-pcie/common/common.h
deleted file mode 100644
index e6b0b3729695..000000000000
--- a/drivers/misc/xlink-pcie/common/common.h
+++ /dev/null
@@ -1,154 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0-only */
-/*****************************************************************************
- *
- * Intel Keem Bay XLink PCIe Driver
- *
- * Copyright (C) 2020 Intel Corporation
- *
- ****************************************************************************/
-
-#ifndef XPCIE_COMMON_HEADER_
-#define XPCIE_COMMON_HEADER_
-
-#include <linux/io.h>
-#include <linux/types.h>
-#include <linux/pci_ids.h>
-#include <linux/sizes.h>
-
-#ifndef PCI_DEVICE_ID_INTEL_KEEMBAY
-#define PCI_DEVICE_ID_INTEL_KEEMBAY 0x6240
-#endif
-
-/* Number of interfaces to statically allocate resources for */
-#define XPCIE_NUM_INTERFACES (1)
-
-#define XPCIE_FRAGMENT_SIZE SZ_128K
-#define XPCIE_NUM_TX_DESCS (64)
-#define XPCIE_NUM_RX_DESCS (64)
-
-/* Status encoding of the transfer descriptors */
-#define XPCIE_DESC_STATUS_SUCCESS (0)
-#define XPCIE_DESC_STATUS_ERROR (0xFFFF)
-
-/* Layout transfer descriptors used by device and host */
-struct xpcie_transfer_desc {
-	u64 address;
-	u32 length;
-	u16 status;
-	u16 interface;
-} __packed;
-
-#define XPCIE_IO_COMM_SIZE SZ_16K
-#define XPCIE_MMIO_OFFSET SZ_4K
-
-#define XPCIE_VERSION_MAJOR 0
-#define XPCIE_VERSION_MINOR 5
-#define XPCIE_VERSION_BUILD 0
-#define _TOSTR(X) #X
-#define _VERSION(A, B, C) _TOSTR(A) "." _TOSTR(B) "." _TOSTR(C)
-#define XPCIE_DRIVER_VERSION \
-	_VERSION(XPCIE_VERSION_MAJOR, XPCIE_VERSION_MINOR, XPCIE_VERSION_BUILD)
-
-struct xpcie_version {
-	u8 major;
-	u8 minor;
-	u16 build;
-} __packed;
-
-/* Status encoding of both device and host */
-#define XPCIE_STATUS_ERROR	(0xFFFFFFFF)
-#define XPCIE_STATUS_UNINIT	(0)
-#define XPCIE_STATUS_READY	(1)
-#define XPCIE_STATUS_RECOVERY	(2)
-#define XPCIE_STATUS_OFF	(3)
-#define XPCIE_STATUS_RUN	(4)
-
-#define XPCIE_MAGIC_STRLEN (16)
-#define XPCIE_MAGIC_YOCTO "VPUYOCTO"
-
-/* MMIO layout and offsets shared between device and host */
-struct xpcie_mmio {
-	struct xpcie_version version;
-	u32 device_status;
-	u32 host_status;
-	u8 legacy_a0;
-	u8 htod_tx_doorbell;
-	u8 htod_rx_doorbell;
-	u8 htod_event_doorbell;
-	u8 dtoh_tx_doorbell;
-	u8 dtoh_rx_doorbell;
-	u8 dtoh_event_doorbell;
-	u8 reserved;
-	u32 cap_offset;
-	u8 magic[XPCIE_MAGIC_STRLEN];
-} __packed;
-
-/* Defined capabilities located in mmio space */
-#define XPCIE_CAP_NULL (0)
-#define XPCIE_CAP_TXRX (1)
-
-/* Header at the beginning of each capability to define and link to next */
-struct xpcie_cap_hdr {
-	u16 id;
-	u16 next;
-} __packed;
-
-#define XPCIE_CAP_HDR_ID (offsetof(struct xpcie_cap_hdr, id))
-#define XPCIE_CAP_HDR_NEXT (offsetof(struct xpcie_cap_hdr, next))
-
-struct xpcie_cap_pipe {
-	u32 ring;
-	u32 ndesc;
-	u32 head;
-	u32 tail;
-} __packed;
-
-/* Transmit and Receive capability */
-struct xpcie_cap_txrx {
-	struct xpcie_cap_hdr hdr;
-	u32 fragment_size;
-	struct xpcie_cap_pipe tx;
-	struct xpcie_cap_pipe rx;
-} __packed;
-
-static inline u64 _ioread64(void __iomem *addr)
-{
-	u64 low, high;
-
-	low = ioread32(addr);
-	high = ioread32(addr + sizeof(u32));
-
-	return low | (high << 32);
-}
-
-static inline void _iowrite64(u64 value, void __iomem *addr)
-{
-	iowrite32(value, addr);
-	iowrite32(value >> 32, addr + sizeof(u32));
-}
-
-#ifdef XLINK_PCIE_REMOTE
-
-#define intel_xpcie_iowrite64	_iowrite64
-#define intel_xpcie_iowrite32	iowrite32
-#define intel_xpcie_iowrite16	iowrite16
-#define intel_xpcie_iowrite8	iowrite8
-#define intel_xpcie_ioread64	_ioread64
-#define intel_xpcie_ioread32	ioread32
-#define intel_xpcie_ioread16	ioread16
-#define intel_xpcie_ioread8	ioread8
-
-#else
-
-#define intel_xpcie_iowrite64(value, addr)	{ *(addr) = value; }
-#define intel_xpcie_iowrite32(value, addr)	{ *(addr) = value; }
-#define intel_xpcie_iowrite16(value, addr)	{ *(addr) = value; }
-#define intel_xpcie_iowrite8(value, addr)	{ *(addr) = value; }
-#define intel_xpcie_ioread64(addr)		(*(addr))
-#define intel_xpcie_ioread32(addr)		(*(addr))
-#define intel_xpcie_ioread16(addr)		(*(addr))
-#define intel_xpcie_ioread8(addr)		(*(addr))
-
-#endif /* XLINK_PCIE_REMOTE */
-
-#endif /* XPCIE_COMMON_HEADER_ */
diff --git a/drivers/misc/xlink-pcie/common/core.h b/drivers/misc/xlink-pcie/common/core.h
index 1c3d32ad4289..ca381336879f 100644
--- a/drivers/misc/xlink-pcie/common/core.h
+++ b/drivers/misc/xlink-pcie/common/core.h
@@ -10,12 +10,226 @@
 #ifndef XPCIE_CORE_HEADER_
 #define XPCIE_CORE_HEADER_
 
+#include <linux/io.h>
+#include <linux/types.h>
+#include <linux/workqueue.h>
+#include <linux/slab.h>
+#include <linux/mutex.h>
+#include <linux/mempool.h>
+#include <linux/dma-mapping.h>
+#include <linux/cache.h>
+#include <linux/wait.h>
+
 #include <linux/xlink_drv_inf.h>
-#include "xpcie.h"
+
+/* Number of interfaces to statically allocate resources for */
+#define XPCIE_NUM_INTERFACES (1)
 
 /* max should be always power of '2' */
 #define XPCIE_CIRCULAR_INC(val, max) (((val) + 1) & ((max) - 1))
 
+#define XPCIE_FRAGMENT_SIZE	SZ_128K
+
+/* Status encoding of the transfer descriptors */
+#define XPCIE_DESC_STATUS_SUCCESS	(0)
+#define XPCIE_DESC_STATUS_ERROR		(0xFFFF)
+
+/* Layout transfer descriptors used by device and host */
+struct xpcie_transfer_desc {
+	u64 address;
+	u32 length;
+	u16 status;
+	u16 interface;
+} __packed;
+
+struct xpcie_pipe {
+	u32 old;
+	u32 ndesc;
+	u32 *head;
+	u32 *tail;
+	struct xpcie_transfer_desc *tdr;
+};
+
+struct xpcie_buf_desc {
+	struct xpcie_buf_desc *next;
+	void *head;
+	dma_addr_t phys;
+	size_t true_len;
+	void *data;
+	size_t length;
+	int interface;
+	bool own_mem;
+};
+
+struct xpcie_stream {
+	size_t frag;
+	struct xpcie_pipe pipe;
+	struct xpcie_buf_desc **ddr;
+};
+
+struct xpcie_list {
+	spinlock_t lock; /* list lock */
+	size_t bytes;
+	size_t buffers;
+	struct xpcie_buf_desc *head;
+	struct xpcie_buf_desc *tail;
+};
+
+struct xpcie_interface {
+	int id;
+	struct xpcie *xpcie;
+	struct mutex rlock; /* read lock */
+	struct xpcie_list read;
+	struct xpcie_buf_desc *partial_read;
+	bool data_avail;
+	wait_queue_head_t rx_waitq;
+};
+
+struct xpcie_debug_stats {
+	struct {
+		size_t cnts;
+		size_t bytes;
+	} tx_krn, rx_krn, tx_usr, rx_usr;
+	size_t send_ints;
+	size_t interrupts;
+	size_t rx_event_runs;
+	size_t tx_event_runs;
+};
+
+/* Defined capabilities located in mmio space */
+#define XPCIE_CAP_NULL (0)
+#define XPCIE_CAP_TXRX (1)
+
+#define XPCIE_CAP_TTL (32)
+#define XPCIE_CAP_HDR_ID	(offsetof(struct xpcie_cap_hdr, id))
+#define XPCIE_CAP_HDR_NEXT	(offsetof(struct xpcie_cap_hdr, next))
+
+/* Header at the beginning of each capability to define and link to next */
+struct xpcie_cap_hdr {
+	u16 id;
+	u16 next;
+} __packed;
+
+struct xpcie_cap_pipe {
+	u32 ring;
+	u32 ndesc;
+	u32 head;
+	u32 tail;
+} __packed;
+
+/* Transmit and Receive capability */
+struct xpcie_cap_txrx {
+	struct xpcie_cap_hdr hdr;
+	u32 fragment_size;
+	struct xpcie_cap_pipe tx;
+	struct xpcie_cap_pipe rx;
+} __packed;
+
+static inline u64 _ioread64(void __iomem *addr)
+{
+	u64 low, high;
+
+	low = ioread32(addr);
+	high = ioread32(addr + sizeof(u32));
+
+	return low | (high << 32);
+}
+
+static inline void _iowrite64(u64 value, void __iomem *addr)
+{
+	iowrite32(value, addr);
+	iowrite32(value >> 32, addr + sizeof(u32));
+}
+
+#define intel_xpcie_iowrite64(value, addr) \
+			_iowrite64(value, (void __iomem *)addr)
+#define intel_xpcie_iowrite32(value, addr) \
+			iowrite32(value, (void __iomem *)addr)
+#define intel_xpcie_iowrite16(value, addr) \
+			iowrite16(value, (void __iomem *)addr)
+#define intel_xpcie_iowrite8(value, addr) \
+			iowrite8(value, (void __iomem *)addr)
+#define intel_xpcie_ioread64(addr) \
+			_ioread64((void __iomem *)addr)
+#define intel_xpcie_ioread32(addr) \
+			ioread32((void __iomem *)addr)
+#define intel_xpcie_ioread16(addr) \
+			ioread16((void __iomem *)addr)
+#define intel_xpcie_ioread8(addr) \
+			ioread8((void __iomem *)addr)
+
+static inline
+void intel_xpcie_set_td_address(struct xpcie_transfer_desc *td, u64 address)
+{
+	intel_xpcie_iowrite64(address, &td->address);
+}
+
+static inline
+u64 intel_xpcie_get_td_address(struct xpcie_transfer_desc *td)
+{
+	return intel_xpcie_ioread64(&td->address);
+}
+
+static inline
+void intel_xpcie_set_td_length(struct xpcie_transfer_desc *td, u32 length)
+{
+	intel_xpcie_iowrite32(length, &td->length);
+}
+
+static inline
+u32 intel_xpcie_get_td_length(struct xpcie_transfer_desc *td)
+{
+	return intel_xpcie_ioread32(&td->length);
+}
+
+static inline
+void intel_xpcie_set_td_interface(struct xpcie_transfer_desc *td, u16 interface)
+{
+	intel_xpcie_iowrite16(interface, &td->interface);
+}
+
+static inline
+u16 intel_xpcie_get_td_interface(struct xpcie_transfer_desc *td)
+{
+	return intel_xpcie_ioread16(&td->interface);
+}
+
+static inline
+void intel_xpcie_set_td_status(struct xpcie_transfer_desc *td, u16 status)
+{
+	intel_xpcie_iowrite16(status, &td->status);
+}
+
+static inline
+u16 intel_xpcie_get_td_status(struct xpcie_transfer_desc *td)
+{
+	return intel_xpcie_ioread16(&td->status);
+}
+
+static inline
+void intel_xpcie_set_tdr_head(struct xpcie_pipe *p, u32 head)
+{
+	intel_xpcie_iowrite32(head, p->head);
+}
+
+static inline
+u32 intel_xpcie_get_tdr_head(struct xpcie_pipe *p)
+{
+	return intel_xpcie_ioread32(p->head);
+}
+
+static inline
+void intel_xpcie_set_tdr_tail(struct xpcie_pipe *p, u32 tail)
+{
+	intel_xpcie_iowrite32(tail, p->tail);
+}
+
+static inline
+u32 intel_xpcie_get_tdr_tail(struct xpcie_pipe *p)
+{
+	return intel_xpcie_ioread32(p->tail);
+}
+
 int intel_xpcie_core_init(struct xpcie *xpcie);
 void intel_xpcie_core_cleanup(struct xpcie *xpcie);
 int intel_xpcie_core_read(struct xpcie *xpcie, void *buffer, size_t *length,
diff --git a/drivers/misc/xlink-pcie/common/interface.c b/drivers/misc/xlink-pcie/common/interface.c
index 6d7cda733fe4..bd0d27f70963 100644
--- a/drivers/misc/xlink-pcie/common/interface.c
+++ b/drivers/misc/xlink-pcie/common/interface.c
@@ -7,11 +7,10 @@
  *
  ****************************************************************************/
 
-#include <linux/errno.h>
-#include <linux/module.h>
 #include <linux/xlink_drv_inf.h>
 
 #include "core.h"
+#include "xpcie.h"
 
 /* Define xpcie driver interface API */
 int xlink_pcie_get_device_list(u32 *sw_device_id_list, u32 *num_devices)
@@ -32,8 +31,8 @@ EXPORT_SYMBOL(xlink_pcie_get_device_name);
 
 int xlink_pcie_get_device_status(u32 sw_device_id, u32 *device_status)
 {
-	int rc;
 	u32 status;
+	int rc;
 
 	rc = intel_xpcie_get_device_status_by_id(sw_device_id, &status);
 	if (rc)
diff --git a/drivers/misc/xlink-pcie/common/util.c b/drivers/misc/xlink-pcie/common/util.c
index 1526bb0a91b6..ec808b0cd72b 100644
--- a/drivers/misc/xlink-pcie/common/util.c
+++ b/drivers/misc/xlink-pcie/common/util.c
@@ -12,59 +12,61 @@
 void intel_xpcie_set_device_status(struct xpcie *xpcie, u32 status)
 {
 	xpcie->status = status;
-	intel_xpcie_iowrite32(status, &xpcie->mmio->device_status);
+	intel_xpcie_iowrite32(status, xpcie->mmio + XPCIE_MMIO_DEV_STATUS);
 }
 
 u32 intel_xpcie_get_device_status(struct xpcie *xpcie)
 {
-	return intel_xpcie_ioread32(&xpcie->mmio->device_status);
+	return intel_xpcie_ioread32(xpcie->mmio + XPCIE_MMIO_DEV_STATUS);
 }
 
-static u8 *intel_xpcie_doorbell_offset(struct xpcie *xpcie,
-				       enum xpcie_doorbell_direction dirt,
-				       enum xpcie_doorbell_type type)
+static size_t intel_xpcie_doorbell_offset(struct xpcie *xpcie,
+					  enum xpcie_doorbell_direction dirt,
+					  enum xpcie_doorbell_type type)
 {
 	if (dirt == TO_DEVICE && type == DATA_SENT)
-		return &xpcie->mmio->htod_tx_doorbell;
+		return XPCIE_MMIO_HTOD_TX_DOORBELL;
 	if (dirt == TO_DEVICE && type == DATA_RECEIVED)
-		return &xpcie->mmio->htod_rx_doorbell;
+		return XPCIE_MMIO_HTOD_RX_DOORBELL;
 	if (dirt == TO_DEVICE && type == DEV_EVENT)
-		return &xpcie->mmio->htod_event_doorbell;
+		return XPCIE_MMIO_HTOD_EVENT_DOORBELL;
 	if (dirt == FROM_DEVICE && type == DATA_SENT)
-		return &xpcie->mmio->dtoh_tx_doorbell;
+		return XPCIE_MMIO_DTOH_TX_DOORBELL;
 	if (dirt == FROM_DEVICE && type == DATA_RECEIVED)
-		return &xpcie->mmio->dtoh_rx_doorbell;
+		return XPCIE_MMIO_DTOH_RX_DOORBELL;
 	if (dirt == FROM_DEVICE && type == DEV_EVENT)
-		return &xpcie->mmio->dtoh_event_doorbell;
+		return XPCIE_MMIO_DTOH_EVENT_DOORBELL;
 
-	return NULL;
+	return 0;
 }
 
 void intel_xpcie_set_doorbell(struct xpcie *xpcie,
 			      enum xpcie_doorbell_direction dirt,
 			      enum xpcie_doorbell_type type, u8 value)
 {
-	intel_xpcie_iowrite8(value,
-			     intel_xpcie_doorbell_offset(xpcie, dirt, type));
+	size_t offset = intel_xpcie_doorbell_offset(xpcie, dirt, type);
+
+	intel_xpcie_iowrite8(value, xpcie->mmio + offset);
 }
 
 u8 intel_xpcie_get_doorbell(struct xpcie *xpcie,
 			    enum xpcie_doorbell_direction dirt,
 			    enum xpcie_doorbell_type type)
 {
-	return intel_xpcie_ioread8(intel_xpcie_doorbell_offset(xpcie,
-							       dirt, type));
+	size_t offset = intel_xpcie_doorbell_offset(xpcie, dirt, type);
+
+	return intel_xpcie_ioread8(xpcie->mmio + offset);
 }
 
 u32 intel_xpcie_get_host_status(struct xpcie *xpcie)
 {
-	return intel_xpcie_ioread32(&xpcie->mmio->host_status);
+	return intel_xpcie_ioread32(xpcie->mmio + XPCIE_MMIO_HOST_STATUS);
 }
 
 void intel_xpcie_set_host_status(struct xpcie *xpcie, u32 status)
 {
 	xpcie->status = status;
-	intel_xpcie_iowrite32(status, &xpcie->mmio->host_status);
+	intel_xpcie_iowrite32(status, xpcie->mmio + XPCIE_MMIO_HOST_STATUS);
 }
 
 struct xpcie_buf_desc *intel_xpcie_alloc_bd(size_t length)
@@ -156,6 +158,7 @@ int intel_xpcie_list_put(struct xpcie_list *list, struct xpcie_buf_desc *bd)
 		list->tail->next = bd;
 	else
 		list->head = bd;
+
 	while (bd) {
 		list->tail = bd;
 		list->bytes += bd->length;
@@ -338,90 +341,35 @@ void intel_xpcie_add_bd_to_interface(struct xpcie *xpcie,
 	wake_up_interruptible(&inf->rx_waitq);
 }
 
-#ifdef XLINK_PCIE_REMOTE
-#include "../remote_host/pci.h"
-#else
-#include "../local_host/struct.h"
-#endif
-
-static ssize_t debug_show(struct device *dev, struct device_attribute *attr,
-			  char *buf)
-{
-	size_t bytes, tx_list_num, rx_list_num, tx_pool_num, rx_pool_num;
-	struct xpcie *xpcie;
-
-	xpcie = intel_xpcie_dev_to_xpcie(dev);
-	if (!xpcie)
-		return -EINVAL;
-
-	if (!xpcie->debug_enable)
-		return 0;
-
-	intel_xpcie_list_info(&xpcie->write, &bytes, &tx_list_num);
-	intel_xpcie_list_info(&xpcie->interfaces[0].read, &bytes, &rx_list_num);
-	intel_xpcie_list_info(&xpcie->tx_pool, &bytes, &tx_pool_num);
-	intel_xpcie_list_info(&xpcie->rx_pool, &bytes, &rx_pool_num);
-
-	snprintf(buf, 4096,
-		 "tx_krn, cnts %zu bytes %zu\n"
-		 "tx_usr, cnts %zu bytes %zu\n"
-		 "rx_krn, cnts %zu bytes %zu\n"
-		 "rx_usr, cnts %zu bytes %zu\n"
-		 "tx_list %zu tx_pool %zu\n"
-		 "rx_list %zu rx_pool %zu\n"
-		 "interrupts %zu, send_ints %zu\n"
-		 "rx runs %zu tx runs %zu\n",
-		 xpcie->stats.tx_krn.cnts, xpcie->stats.tx_krn.bytes,
-		 xpcie->stats.tx_usr.cnts, xpcie->stats.tx_usr.bytes,
-		 xpcie->stats.rx_krn.cnts, xpcie->stats.rx_krn.bytes,
-		 xpcie->stats.rx_usr.cnts, xpcie->stats.rx_usr.bytes,
-		 tx_list_num, tx_pool_num, rx_list_num, rx_pool_num,
-		 xpcie->stats.interrupts, xpcie->stats.send_ints,
-		 xpcie->stats.rx_event_runs, xpcie->stats.tx_event_runs
-	 );
-
-	return strlen(buf);
-}
-
-static ssize_t debug_store(struct device *dev, struct device_attribute *attr,
-			   const char *buf, size_t count)
-{
-	struct xpcie *xpcie;
-	long value;
-	int rc;
-
-	xpcie = intel_xpcie_dev_to_xpcie(dev);
-	if (!xpcie)
-		return -EINVAL;
-
-	rc = kstrtol(buf, 10, &value);
-	if (rc)
-		return rc;
-
-	xpcie->debug_enable = value ? true : false;
-
-	if (!xpcie->debug_enable)
-		memset(&xpcie->stats, 0, sizeof(struct xpcie_debug_stats));
-
-	return count;
-}
-
-void intel_xpcie_init_debug(struct xpcie *xpcie, struct device *dev)
+void *intel_xpcie_cap_find(struct xpcie *xpcie, u32 start, u16 id)
 {
-	DEVICE_ATTR_RW(debug);
-	memset(&xpcie->stats, 0, sizeof(struct xpcie_debug_stats));
-	xpcie->debug = dev_attr_debug;
-	device_create_file(dev, &xpcie->debug);
-}
-
-void intel_xpcie_uninit_debug(struct xpcie *xpcie, struct device *dev)
-{
-	device_remove_file(dev, &xpcie->debug);
-	memset(&xpcie->stats, 0, sizeof(struct xpcie_debug_stats));
-}
+	int ttl = XPCIE_CAP_TTL;
+	void *hdr;
+	u16 id_out, next;
+
+	/* If user didn't specify start, assume start of mmio */
+	if (!start)
+		start = intel_xpcie_ioread32(xpcie->mmio + XPCIE_MMIO_CAP_OFF);
+
+	/* Read header info */
+	hdr = xpcie->mmio + start;
+
+	/* Check if we still have time to live */
+	while (ttl--) {
+		id_out = intel_xpcie_ioread16(hdr + XPCIE_CAP_HDR_ID);
+		next = intel_xpcie_ioread16(hdr + XPCIE_CAP_HDR_NEXT);
+
+		/* If cap matches, return header */
+		if (id_out == id)
+			return hdr;
+		/* If cap is NULL, we are at the end of the list */
+		else if (id_out == XPCIE_CAP_NULL)
+			return NULL;
+		/* If no match and no end of list, traverse the linked list */
+		else
+			hdr = xpcie->mmio + next;
+	}
 
-void intel_xpcie_debug_incr(struct xpcie *xpcie, size_t *attr, size_t v)
-{
-	if (unlikely(xpcie->debug_enable))
-		*attr += v;
+	/* If we reached here, the capability list is corrupted */
+	return NULL;
 }
diff --git a/drivers/misc/xlink-pcie/common/util.h b/drivers/misc/xlink-pcie/common/util.h
index db715279b2ce..908be897a61d 100644
--- a/drivers/misc/xlink-pcie/common/util.h
+++ b/drivers/misc/xlink-pcie/common/util.h
@@ -66,9 +66,5 @@ void intel_xpcie_interfaces_cleanup(struct xpcie *xpcie);
 int intel_xpcie_interfaces_init(struct xpcie *xpcie);
 void intel_xpcie_add_bd_to_interface(struct xpcie *xpcie,
 				     struct xpcie_buf_desc *bd);
-
-void intel_xpcie_init_debug(struct xpcie *xpcie, struct device *dev);
-void intel_xpcie_uninit_debug(struct xpcie *xpcie, struct device *dev);
-void intel_xpcie_debug_incr(struct xpcie *xpcie, size_t *attr, size_t v);
-struct xpcie *intel_xpcie_dev_to_xpcie(struct device *dev);
+void *intel_xpcie_cap_find(struct xpcie *xpcie, u32 start, u16 id);
 #endif /* XPCIE_UTIL_HEADER_ */
diff --git a/drivers/misc/xlink-pcie/common/xpcie.h b/drivers/misc/xlink-pcie/common/xpcie.h
index 8943cf1168f1..c62443d61865 100644
--- a/drivers/misc/xlink-pcie/common/xpcie.h
+++ b/drivers/misc/xlink-pcie/common/xpcie.h
@@ -12,97 +12,86 @@
 
 #include <linux/kernel.h>
 #include <linux/module.h>
-#include <linux/workqueue.h>
-#include <linux/stddef.h>
-#include <linux/init.h>
-#include <linux/pci.h>
-#include <linux/slab.h>
-#include <linux/mutex.h>
-#include <linux/version.h>
-#include <linux/mempool.h>
-#include <linux/dma-mapping.h>
-#include <linux/cache.h>
-#include <linux/wait.h>
-
-#include "common.h"
-
-#ifdef XLINK_PCIE_REMOTE
-#define XPCIE_DRIVER_NAME "mxlk"
-#define XPCIE_DRIVER_DESC "Intel(R) Keem Bay XLink PCIe driver"
-#else
-#define XPCIE_DRIVER_NAME "mxlk_pcie_epf"
-#define XPCIE_DRIVER_DESC "Intel(R) xLink PCIe endpoint function driver"
-#endif
-
-struct xpcie_pipe {
-	u32 old;
-	u32 ndesc;
-	u32 *head;
-	u32 *tail;
-	struct xpcie_transfer_desc *tdr;
-};
+#include <linux/pci_ids.h>
 
-struct xpcie_buf_desc {
-	struct xpcie_buf_desc *next;
-	void *head;
-	dma_addr_t phys;
-	size_t true_len;
-	void *data;
-	size_t length;
-	int interface;
-	bool own_mem;
-};
+#include "core.h"
 
-struct xpcie_stream {
-	size_t frag;
-	struct xpcie_pipe pipe;
-#ifdef XLINK_PCIE_REMOTE
-	struct xpcie_buf_desc **ddr;
+#ifndef PCI_DEVICE_ID_INTEL_KEEMBAY
+#define PCI_DEVICE_ID_INTEL_KEEMBAY 0x6240
 #endif
-};
 
-struct xpcie_list {
-	/* list lock */
-	spinlock_t lock;
-	size_t bytes;
-	size_t buffers;
-	struct xpcie_buf_desc *head;
-	struct xpcie_buf_desc *tail;
-};
-
-struct xpcie_interface {
-	int id;
-	struct xpcie *xpcie;
-	struct mutex rlock; /* Read lock */
-	struct xpcie_list read;
-	struct xpcie_buf_desc *partial_read;
-	bool data_avail;
-	wait_queue_head_t rx_waitq;
-};
-
-struct xpcie_debug_stats {
-	struct {
-		size_t cnts;
-		size_t bytes;
-	} tx_krn, rx_krn, tx_usr, rx_usr;
-	size_t send_ints;
-	size_t interrupts;
-	size_t rx_event_runs;
-	size_t tx_event_runs;
-};
+#define XPCIE_IO_COMM_SIZE SZ_16K
+#define XPCIE_MMIO_OFFSET SZ_4K
+
+#define XPCIE_VERSION_MAJOR 0
+#define XPCIE_VERSION_MINOR 5
+#define XPCIE_VERSION_BUILD 0
+#define _TOSTR(X) #X
+#define _VERSION(A, B, C) _TOSTR(A) "." _TOSTR(B) "." _TOSTR(C)
+#define XPCIE_DRIVER_VERSION \
+	_VERSION(XPCIE_VERSION_MAJOR, XPCIE_VERSION_MINOR, XPCIE_VERSION_BUILD)
+
+struct xpcie_version {
+	u8 major;
+	u8 minor;
+	u16 build;
+} __packed;
+
+/* Status encoding of both device and host */
+#define XPCIE_STATUS_ERROR	(0xFFFFFFFF)
+#define XPCIE_STATUS_UNINIT	(0)
+#define XPCIE_STATUS_READY	(1)
+#define XPCIE_STATUS_RECOVERY	(2)
+#define XPCIE_STATUS_OFF	(3)
+#define XPCIE_STATUS_RUN	(4)
+
+#define XPCIE_MAGIC_STRLEN	(16)
+#define XPCIE_MAGIC_YOCTO	"VPUYOCTO"
+
+/* MMIO layout and offsets shared between device and host */
+struct xpcie_mmio {
+	struct xpcie_version version;
+	u32 device_status;
+	u32 host_status;
+	u8 legacy_a0;
+	u8 htod_tx_doorbell;
+	u8 htod_rx_doorbell;
+	u8 htod_event_doorbell;
+	u8 dtoh_tx_doorbell;
+	u8 dtoh_rx_doorbell;
+	u8 dtoh_event_doorbell;
+	u8 reserved;
+	u32 cap_offset;
+	u8 magic[XPCIE_MAGIC_STRLEN];
+} __packed;
+
+#define XPCIE_MMIO_VERSION	(offsetof(struct xpcie_mmio, version))
+#define XPCIE_MMIO_LEGACY_A0	(offsetof(struct xpcie_mmio, legacy_a0))
+#define XPCIE_MMIO_DEV_STATUS	(offsetof(struct xpcie_mmio, device_status))
+#define XPCIE_MMIO_LEGACY_A0	(offsetof(struct xpcie_mmio, legacy_a0))
+#define XPCIE_MMIO_HOST_STATUS	(offsetof(struct xpcie_mmio, host_status))
+#define XPCIE_MMIO_LEGACY_A0	(offsetof(struct xpcie_mmio, legacy_a0))
+#define XPCIE_MMIO_HTOD_TX_DOORBELL \
+	(offsetof(struct xpcie_mmio, htod_tx_doorbell))
+#define XPCIE_MMIO_HTOD_RX_DOORBELL \
+	(offsetof(struct xpcie_mmio, htod_rx_doorbell))
+#define XPCIE_MMIO_HTOD_EVENT_DOORBELL \
+	(offsetof(struct xpcie_mmio, htod_event_doorbell))
+#define XPCIE_MMIO_DTOH_TX_DOORBELL \
+	(offsetof(struct xpcie_mmio, dtoh_tx_doorbell))
+#define XPCIE_MMIO_DTOH_RX_DOORBELL \
+	(offsetof(struct xpcie_mmio, dtoh_rx_doorbell))
+#define XPCIE_MMIO_DTOH_EVENT_DOORBELL \
+	(offsetof(struct xpcie_mmio, dtoh_event_doorbell))
+#define XPCIE_MMIO_CAP_OFF	(offsetof(struct xpcie_mmio, cap_offset))
+#define XPCIE_MMIO_MAGIC_OFF	(offsetof(struct xpcie_mmio, magic))
 
 struct xpcie {
 	u32 status;
 	bool legacy_a0;
-
-#ifdef XLINK_PCIE_REMOTE
-	void __iomem *bar0;
-	struct xpcie_mmio __iomem *mmio; /* XLink memory space */
-	void __iomem *bar4;
-#else
-	struct xpcie_mmio *mmio; /* XLink memory space */
+	void *bar0;
+	void *mmio;
 	void *bar4;
-#endif
 
 	struct workqueue_struct *rx_wq;
 	struct workqueue_struct *tx_wq;
@@ -114,8 +103,7 @@ struct xpcie {
 	struct xpcie_stream tx;
 	struct xpcie_stream rx;
 
-	/* Write Lock */
-	struct mutex wlock;
+	struct mutex wlock; /* write lock */
 	struct xpcie_list write;
 	bool no_tx_buffer;
 	wait_queue_head_t tx_waitq;
@@ -127,10 +115,6 @@ struct xpcie {
 
 	struct delayed_work rx_event;
 	struct delayed_work tx_event;
-
-	struct device_attribute debug;
-	bool debug_enable;
-	struct xpcie_debug_stats stats;
 };
 
 #endif /* XPCIE_HEADER_ */
diff --git a/drivers/misc/xlink-pcie/local_host/Makefile b/drivers/misc/xlink-pcie/local_host/Makefile
index 35f303179780..133530a3611c 100644
--- a/drivers/misc/xlink-pcie/local_host/Makefile
+++ b/drivers/misc/xlink-pcie/local_host/Makefile
@@ -2,7 +2,7 @@ ccflags-y += -Wall -Wno-unused-function -Werror
 
 obj-$(CONFIG_XLINK_PCIE_LH_DRIVER) += mxlk_ep.o
 mxlk_ep-objs := epf.o
-mxlk_ep-objs += core.o
 mxlk_ep-objs += dma.o
-mxlk_ep-objs += ../common/interface.o
+mxlk_ep-objs += core.o
 mxlk_ep-objs += ../common/util.o
+mxlk_ep-objs += ../common/interface.o
diff --git a/drivers/misc/xlink-pcie/local_host/core.c b/drivers/misc/xlink-pcie/local_host/core.c
index 3c9cffd0ed29..62a29a8c3477 100644
--- a/drivers/misc/xlink-pcie/local_host/core.c
+++ b/drivers/misc/xlink-pcie/local_host/core.c
@@ -9,13 +9,12 @@
 
 #include <linux/uaccess.h>
 #include <linux/delay.h>
+#include <linux/of_reserved_mem.h>
 #include <linux/interrupt.h>
 
+#include "epf.h"
 #include "../common/core.h"
 #include "../common/util.h"
-#include "../common/capabilities.h"
-#include "epf.h"
-#include "struct.h"
 
 static struct xpcie *global_xpcie;
 
@@ -72,18 +71,18 @@ static void intel_xpcie_unmap_dma(struct xpcie *xpcie,
 
 static void intel_xpcie_set_cap_txrx(struct xpcie *xpcie)
 {
-	size_t hdr_len = sizeof(struct xpcie_cap_txrx);
 	size_t tx_len = sizeof(struct xpcie_transfer_desc) *
 				XPCIE_NUM_TX_DESCS;
 	size_t rx_len = sizeof(struct xpcie_transfer_desc) *
 				XPCIE_NUM_RX_DESCS;
+	size_t hdr_len = sizeof(struct xpcie_cap_txrx);
 	u32 start = sizeof(struct xpcie_mmio);
 	struct xpcie_cap_txrx *cap;
 	struct xpcie_cap_hdr *hdr;
 	u16 next;
 
 	next = (u16)(start + hdr_len + tx_len + rx_len);
-	xpcie->mmio->cap_offset = start;
+	intel_xpcie_iowrite32(start, xpcie->mmio + XPCIE_MMIO_CAP_OFF);
 	cap = (void *)xpcie->mmio + start;
 	memset(cap, 0, sizeof(struct xpcie_cap_txrx));
 	cap->hdr.id = XPCIE_CAP_TXRX;
@@ -106,7 +105,7 @@ static int intel_xpcie_set_version(struct xpcie *xpcie)
 	version.minor = XPCIE_VERSION_MINOR;
 	version.build = XPCIE_VERSION_BUILD;
 
-	memcpy(&xpcie->mmio->version, &version, sizeof(version));
+	memcpy(xpcie->mmio + XPCIE_MMIO_VERSION, &version, sizeof(version));
 
 	dev_dbg(xpcie_to_dev(xpcie), "ver: device %u.%u.%u\n",
 		version.major, version.minor, version.build);
@@ -116,14 +115,14 @@ static int intel_xpcie_set_version(struct xpcie *xpcie)
 
 static void intel_xpcie_txrx_cleanup(struct xpcie *xpcie)
 {
-	int index;
-	struct xpcie_transfer_desc *td;
-	struct xpcie_stream *tx = &xpcie->tx;
-	struct xpcie_stream *rx = &xpcie->rx;
 	struct xpcie_epf *xpcie_epf = container_of(xpcie,
 						   struct xpcie_epf, xpcie);
 	struct device *dma_dev = xpcie_epf->epf->epc->dev.parent;
 	struct xpcie_interface *inf = &xpcie->interfaces[0];
+	struct xpcie_stream *tx = &xpcie->tx;
+	struct xpcie_stream *rx = &xpcie->rx;
+	struct xpcie_transfer_desc *td;
+	int index;
 
 	xpcie->stop_flag = true;
 	xpcie->no_tx_buffer = false;
@@ -174,7 +173,7 @@ static int intel_xpcie_txrx_init(struct xpcie *xpcie,
 	struct xpcie_stream *tx = &xpcie->tx;
 	struct xpcie_stream *rx = &xpcie->rx;
 	struct xpcie_buf_desc *bd;
-	int index, ndesc;
+	int index, ndesc, rc;
 
 	xpcie->txrx = cap;
 	xpcie->fragment_size = cap->fragment_size;
@@ -194,6 +193,13 @@ static int intel_xpcie_txrx_init(struct xpcie *xpcie,
 	rx_pool_size = roundup(rx_pool_size, xpcie->fragment_size);
 	ndesc = rx_pool_size / xpcie->fragment_size;
 
+	/* Initialize reserved memory resources */
+	rc = of_reserved_mem_device_init(dma_dev);
+	if (rc) {
+		dev_err(dma_dev, "Could not get reserved memory\n");
+		goto error;
+	}
+
 	if (rx_pool_coherent) {
 		xpcie_epf->rx_size = rx_pool_size;
 		xpcie_epf->rx_virt = dma_alloc_coherent(dma_dev,
@@ -310,12 +316,12 @@ static void intel_xpcie_rx_event_handler(struct work_struct *work)
 	struct xpcie_stream *rx = &xpcie->rx;
 	struct xpcie_dma_ll_desc *desc;
 	struct xpcie_transfer_desc *td;
-	int descs_num = 0, chan = 0, rc;
 	bool reset_work = false;
+	int descs_num = 0;
 	u16 interface;
+	int chan = 0;
 	u64 address;
-
-	intel_xpcie_debug_incr(xpcie, &xpcie->stats.rx_event_runs, 1);
+	int rc;
 
 	if (intel_xpcie_get_host_status(xpcie) != XPCIE_STATUS_RUN)
 		return;
@@ -398,12 +404,6 @@ static void intel_xpcie_rx_event_handler(struct work_struct *work)
 		bd->next = NULL;
 
 		if (likely(bd->interface < XPCIE_NUM_INTERFACES)) {
-			intel_xpcie_debug_incr(xpcie,
-					       &xpcie->stats.rx_krn.cnts, 1);
-			intel_xpcie_debug_incr(xpcie,
-					       &xpcie->stats.rx_krn.bytes,
-					       bd->length);
-
 			intel_xpcie_set_td_status(td,
 						  XPCIE_DESC_STATUS_SUCCESS);
 			intel_xpcie_add_bd_to_interface(xpcie, bd);
@@ -439,11 +439,12 @@ static void intel_xpcie_tx_event_handler(struct work_struct *work)
 	u32 head, tail, ndesc, initial_tail;
 	struct xpcie_dma_ll_desc *desc;
 	struct xpcie_transfer_desc *td;
-	size_t bytes = 0, buffers = 0;
-	int descs_num = 0, chan = 0, rc;
+	size_t buffers = 0;
+	int descs_num = 0;
+	size_t bytes = 0;
+	int chan = 0;
 	u64 address;
-
-	intel_xpcie_debug_incr(xpcie, &xpcie->stats.tx_event_runs, 1);
+	int rc;
 
 	if (intel_xpcie_get_host_status(xpcie) != XPCIE_STATUS_RUN)
 		return;
@@ -504,10 +505,6 @@ static void intel_xpcie_tx_event_handler(struct work_struct *work)
 			continue;
 		}
 
-		intel_xpcie_debug_incr(xpcie, &xpcie->stats.tx_krn.cnts, 1);
-		intel_xpcie_debug_incr(xpcie, &xpcie->stats.tx_krn.bytes,
-				       bd->length);
-
 		td = tx->pipe.tdr + tail;
 		intel_xpcie_set_td_status(td, XPCIE_DESC_STATUS_SUCCESS);
 		intel_xpcie_set_td_length(td, bd->length);
@@ -529,7 +526,6 @@ static void intel_xpcie_tx_event_handler(struct work_struct *work)
 	if (intel_xpcie_get_tdr_tail(&tx->pipe) != tail) {
 		intel_xpcie_set_tdr_tail(&tx->pipe, tail);
 		intel_xpcie_raise_irq(xpcie, DATA_SENT);
-		intel_xpcie_debug_incr(xpcie, &xpcie->stats.send_ints, 1);
 	}
 
 task_exit:
@@ -550,7 +546,6 @@ static irqreturn_t intel_xpcie_core_irq_cb(int irq, void *args)
 
 	if (intel_xpcie_get_doorbell(xpcie, TO_DEVICE, DATA_SENT)) {
 		intel_xpcie_set_doorbell(xpcie, TO_DEVICE, DATA_SENT, 0);
-		intel_xpcie_debug_incr(xpcie, &xpcie->stats.interrupts, 1);
 		intel_xpcie_start_rx(xpcie, 0);
 	}
 	if (intel_xpcie_get_doorbell(xpcie, TO_DEVICE, DATA_RECEIVED)) {
@@ -601,12 +596,8 @@ static void intel_xpcie_events_cleanup(struct xpcie *xpcie)
 
 int intel_xpcie_core_init(struct xpcie *xpcie)
 {
-	struct xpcie_epf *xpcie_epf = container_of(xpcie,
-						   struct xpcie_epf, xpcie);
 	int error;
 
-	intel_xpcie_init_debug(xpcie, &xpcie_epf->epf->dev);
-
 	global_xpcie = xpcie;
 
 	intel_xpcie_set_version(xpcie);
@@ -641,16 +632,11 @@ int intel_xpcie_core_init(struct xpcie *xpcie)
 
 void intel_xpcie_core_cleanup(struct xpcie *xpcie)
 {
-	struct xpcie_epf *xpcie_epf = container_of(xpcie,
-						   struct xpcie_epf, xpcie);
-
 	if (xpcie->status == XPCIE_STATUS_RUN) {
 		intel_xpcie_events_cleanup(xpcie);
 		intel_xpcie_interfaces_cleanup(xpcie);
 		intel_xpcie_txrx_cleanup(xpcie);
 	}
-
-	intel_xpcie_uninit_debug(xpcie, &xpcie_epf->epf->dev);
 }
 
 int intel_xpcie_core_read(struct xpcie *xpcie, void *buffer,
@@ -662,7 +648,7 @@ int intel_xpcie_core_read(struct xpcie *xpcie, void *buffer,
 	struct xpcie_buf_desc *bd;
 	long jiffies_passed = 0;
 	size_t len, remaining;
-	int ret = 0;
+	int ret;
 
 	len = *length;
 	remaining = len;
@@ -673,8 +659,6 @@ int intel_xpcie_core_read(struct xpcie *xpcie, void *buffer,
 	if (xpcie->status != XPCIE_STATUS_RUN)
 		return -ENODEV;
 
-	intel_xpcie_debug_incr(xpcie, &xpcie->stats.rx_usr.cnts, 1);
-
 	ret = mutex_lock_interruptible(&inf->rlock);
 	if (ret < 0)
 		return -EINTR;
@@ -717,10 +701,6 @@ int intel_xpcie_core_read(struct xpcie *xpcie, void *buffer,
 			bd->data += bcopy;
 			bd->length -= bcopy;
 
-			intel_xpcie_debug_incr(xpcie,
-					       &xpcie->stats.rx_usr.bytes,
-					       bcopy);
-
 			if (bd->length == 0) {
 				intel_xpcie_free_rx_bd(xpcie, bd);
 				bd = intel_xpcie_list_get(&inf->read);
@@ -767,8 +747,6 @@ int intel_xpcie_core_write(struct xpcie *xpcie, void *buffer,
 	if (intel_xpcie_get_host_status(xpcie) != XPCIE_STATUS_RUN)
 		return -ENODEV;
 
-	intel_xpcie_debug_incr(xpcie, &xpcie->stats.tx_usr.cnts, 1);
-
 	ret = mutex_lock_interruptible(&xpcie->wlock);
 	if (ret < 0)
 		return -EINTR;
@@ -813,10 +791,6 @@ int intel_xpcie_core_write(struct xpcie *xpcie, void *buffer,
 			bd->length = bcopy;
 			bd->interface = inf->id;
 
-			intel_xpcie_debug_incr(xpcie,
-					       &xpcie->stats.tx_usr.bytes,
-					       bcopy);
-
 			if (remaining) {
 				bd->next = intel_xpcie_alloc_tx_bd(xpcie);
 				bd = bd->next;
@@ -873,7 +847,7 @@ int intel_xpcie_get_device_name_by_id(u32 id,
 	memset(device_name, 0, name_size);
 	if (name_size > strlen(XPCIE_DRIVER_NAME))
 		name_size = strlen(XPCIE_DRIVER_NAME);
-	strncpy(device_name, XPCIE_DRIVER_NAME, name_size);
+	memcpy(device_name, XPCIE_DRIVER_NAME, name_size);
 
 	return 0;
 }
diff --git a/drivers/misc/xlink-pcie/local_host/dma.c b/drivers/misc/xlink-pcie/local_host/dma.c
index 5e12a984459b..ffb3cc48b85b 100644
--- a/drivers/misc/xlink-pcie/local_host/dma.c
+++ b/drivers/misc/xlink-pcie/local_host/dma.c
@@ -10,9 +10,7 @@
 #include <linux/wait.h>
 #include <linux/delay.h>
 
-#include "dma.h"
-#include "struct.h"
-#include "../common/xpcie.h"
+#include "epf.h"
 
 #define DMA_DBI_OFFSET			(0x380000)
 
@@ -88,8 +86,6 @@
 
 #define DMA_POLLING_TIMEOUT		1000000
 
-#define DMA_CHAN_NUM			(4)
-
 struct __packed pcie_dma_reg {
 	u32 dma_ctrl_data_arb_prior;
 	u32 reserved1;
@@ -170,19 +166,20 @@ static int intel_xpcie_ep_dma_disable(void __iomem *dma_base,
 				      enum xpcie_ep_engine_type rw)
 {
 	int i;
-	struct pcie_dma_reg *dma_reg = (struct pcie_dma_reg *)(dma_base);
-	void __iomem *engine_en = (rw == WRITE_ENGINE) ?
+	struct __iomem pcie_dma_reg * dma_reg =
+				(struct __iomem pcie_dma_reg *)dma_base;
+	void __iomem *engine_en = (void __iomem *)((rw == WRITE_ENGINE) ?
 					&dma_reg->dma_write_engine_en :
-					&dma_reg->dma_read_engine_en;
-	void __iomem *int_mask = (rw == WRITE_ENGINE) ?
+					&dma_reg->dma_read_engine_en);
+	void __iomem *int_mask = (void __iomem *)((rw == WRITE_ENGINE) ?
 					&dma_reg->dma_write_int_mask :
-					&dma_reg->dma_read_int_mask;
-	void __iomem *int_clear = (rw == WRITE_ENGINE) ?
+					&dma_reg->dma_read_int_mask);
+	void __iomem *int_clear = (void __iomem *)((rw == WRITE_ENGINE) ?
 					&dma_reg->dma_write_int_clear :
-					&dma_reg->dma_read_int_clear;
-	void __iomem *ll_err = (rw == WRITE_ENGINE) ?
+					&dma_reg->dma_read_int_clear);
+	void __iomem *ll_err = (void __iomem *)((rw == WRITE_ENGINE) ?
 					&dma_reg->dma_write_linked_list_err_en :
-					&dma_reg->dma_read_linked_list_err_en;
+					&dma_reg->dma_read_linked_list_err_en);
 
 	iowrite32(0x0, engine_en);
 
@@ -208,25 +205,26 @@ static int intel_xpcie_ep_dma_disable(void __iomem *dma_base,
 static void intel_xpcie_ep_dma_enable(void __iomem *dma_base,
 				      enum xpcie_ep_engine_type rw)
 {
-	struct pcie_dma_reg *dma_reg = (struct pcie_dma_reg *)(dma_base);
-	void __iomem *engine_en = (rw == WRITE_ENGINE) ?
+	struct __iomem pcie_dma_reg * dma_reg =
+				(struct __iomem pcie_dma_reg *)(dma_base);
+	void __iomem *engine_en = (void __iomem *)((rw == WRITE_ENGINE) ?
 					&dma_reg->dma_write_engine_en :
-					&dma_reg->dma_read_engine_en;
-	void __iomem *int_mask = (rw == WRITE_ENGINE) ?
+					&dma_reg->dma_read_engine_en);
+	void __iomem *int_mask = (void __iomem *)((rw == WRITE_ENGINE) ?
 					&dma_reg->dma_write_int_mask :
-					&dma_reg->dma_read_int_mask;
-	void __iomem *int_clear = (rw == WRITE_ENGINE) ?
+					&dma_reg->dma_read_int_mask);
+	void __iomem *int_clear = (void __iomem *)((rw == WRITE_ENGINE) ?
 					&dma_reg->dma_write_int_clear :
-					&dma_reg->dma_read_int_clear;
-	void __iomem *ll_err = (rw == WRITE_ENGINE) ?
+					&dma_reg->dma_read_int_clear);
+	void __iomem *ll_err = (void __iomem *)((rw == WRITE_ENGINE) ?
 					&dma_reg->dma_write_linked_list_err_en :
-					&dma_reg->dma_read_linked_list_err_en;
-	void __iomem *arb_weight = (rw == WRITE_ENGINE) ?
+					&dma_reg->dma_read_linked_list_err_en);
+	void __iomem *arb_weight = (void __iomem *)((rw == WRITE_ENGINE) ?
 				&dma_reg->dma_write_channel_arb_weight_low :
-				&dma_reg->dma_read_channel_arb_weight_low;
+				&dma_reg->dma_read_channel_arb_weight_low);
 	u32 weight = (rw == WRITE_ENGINE) ? DMA_CHAN_WRITE_ALL_MAX_WEIGHT :
 					    DMA_CHAN_READ_ALL_MAX_WEIGHT;
-	struct pcie_dma_chan *dma_chan;
+	struct __iomem pcie_dma_chan * dma_chan;
 	u32 offset;
 	int i;
 
@@ -247,8 +245,9 @@ static void intel_xpcie_ep_dma_enable(void __iomem *dma_base,
 	/* Enable linked list mode. */
 	for (i = 0; i < DMA_CHAN_NUM; i++) {
 		offset = dma_chan_offset[rw][i];
-		dma_chan = (struct pcie_dma_chan *)(dma_base + offset);
-		iowrite32(DMA_CH_CONTROL1_LLE_MASK, &dma_chan->dma_ch_control1);
+		dma_chan = (struct __iomem pcie_dma_chan *)(dma_base + offset);
+		iowrite32(DMA_CH_CONTROL1_LLE_MASK,
+			  (void __iomem *)&dma_chan->dma_ch_control1);
 	}
 }
 
@@ -308,13 +307,13 @@ static int intel_xpcie_ep_dma_rd_err_sts_h(void __iomem *err_status,
 	return 0;
 }
 
-static void intel_xpcie_ep_dma_setup_ll_descs(struct pcie_dma_chan *dma_chan,
-					      struct xpcie_dma_ll_desc_buf
-						*desc_buf,
-					      int descs_num)
+static void
+intel_xpcie_ep_dma_setup_ll_descs(struct __iomem pcie_dma_chan * dma_chan,
+				  struct xpcie_dma_ll_desc_buf *desc_buf,
+				  int descs_num)
 {
 	struct xpcie_dma_ll_desc *descs = desc_buf->virt;
-	int i = 0;
+	int i;
 
 	/* Setup linked list descriptors */
 	for (i = 0; i < descs_num - 1; i++)
@@ -327,9 +326,10 @@ static void intel_xpcie_ep_dma_setup_ll_descs(struct pcie_dma_chan *dma_chan,
 
 	/* Setup linked list settings */
 	iowrite32(DMA_CH_CONTROL1_LLE_MASK | DMA_CH_CONTROL1_CCS_MASK,
-		  &dma_chan->dma_ch_control1);
-	iowrite32((u32)desc_buf->phys, &dma_chan->dma_llp_low);
-	iowrite32((u64)desc_buf->phys >> 32, &dma_chan->dma_llp_high);
+		  (void __iomem *)&dma_chan->dma_ch_control1);
+	iowrite32((u32)desc_buf->phys, (void __iomem *)&dma_chan->dma_llp_low);
+	iowrite32((u64)desc_buf->phys >> 32,
+		  (void __iomem *)&dma_chan->dma_llp_high);
 }
 
 int intel_xpcie_ep_dma_write_ll(struct pci_epf *epf, int chan, int descs_num)
@@ -337,9 +337,10 @@ int intel_xpcie_ep_dma_write_ll(struct pci_epf *epf, int chan, int descs_num)
 	struct xpcie_epf *xpcie_epf = epf_get_drvdata(epf);
 	void __iomem *dma_base = xpcie_epf->dma_base;
 	struct xpcie_dma_ll_desc_buf *desc_buf;
-	struct pcie_dma_chan *dma_chan;
-	struct pcie_dma_reg *dma_reg;
-	int i, rc = 0;
+	struct __iomem pcie_dma_chan * dma_chan;
+	struct __iomem pcie_dma_reg * dma_reg =
+				(struct __iomem pcie_dma_reg *)(dma_base);
+	int i, rc;
 
 	if (descs_num <= 0 || descs_num > XPCIE_NUM_TX_DESCS)
 		return -EINVAL;
@@ -347,8 +348,7 @@ int intel_xpcie_ep_dma_write_ll(struct pci_epf *epf, int chan, int descs_num)
 	if (chan < 0 || chan >= DMA_CHAN_NUM)
 		return -EINVAL;
 
-	dma_reg = (struct pcie_dma_reg *)dma_base;
-	dma_chan = (struct pcie_dma_chan *)
+	dma_chan = (struct __iomem pcie_dma_chan *)
 		(dma_base + dma_chan_offset[WRITE_ENGINE][chan]);
 
 	desc_buf = &xpcie_epf->tx_desc_buf[chan];
@@ -357,6 +357,7 @@ int intel_xpcie_ep_dma_write_ll(struct pci_epf *epf, int chan, int descs_num)
 
 	/* Start DMA transfer. */
 	rc = intel_xpcie_ep_dma_doorbell(xpcie_epf, chan,
+					 (void __iomem *)
 					 &dma_reg->dma_write_doorbell);
 	if (rc)
 		return rc;
@@ -364,7 +365,7 @@ int intel_xpcie_ep_dma_write_ll(struct pci_epf *epf, int chan, int descs_num)
 	/* Wait for DMA transfer to complete. */
 	for (i = 0; i < DMA_POLLING_TIMEOUT; i++) {
 		usleep_range(5, 10);
-		if (ioread32(&dma_reg->dma_write_int_status) &
+		if (ioread32((void __iomem *)&dma_reg->dma_write_int_status) &
 		    (DMA_DONE_INTERRUPT_CH_MASK(chan) |
 		     DMA_ABORT_INTERRUPT_CH_MASK(chan)))
 			break;
@@ -375,14 +376,15 @@ int intel_xpcie_ep_dma_write_ll(struct pci_epf *epf, int chan, int descs_num)
 		goto cleanup;
 	}
 
-	rc = intel_xpcie_ep_dma_err_status(&dma_reg->dma_write_err_status,
+	rc = intel_xpcie_ep_dma_err_status((void __iomem *)
+					   &dma_reg->dma_write_err_status,
 					   chan);
 
 cleanup:
 	/* Clear the done/abort interrupt. */
 	iowrite32((DMA_DONE_INTERRUPT_CH_MASK(chan) |
 		   DMA_ABORT_INTERRUPT_CH_MASK(chan)),
-		  &dma_reg->dma_write_int_clear);
+		  (void __iomem *)&dma_reg->dma_write_int_clear);
 
 	if (rc) {
 		intel_xpcie_ep_dma_disable(dma_base, WRITE_ENGINE);
@@ -397,9 +399,10 @@ int intel_xpcie_ep_dma_read_ll(struct pci_epf *epf, int chan, int descs_num)
 	struct xpcie_epf *xpcie_epf = epf_get_drvdata(epf);
 	void __iomem *dma_base = xpcie_epf->dma_base;
 	struct xpcie_dma_ll_desc_buf *desc_buf;
-	struct pcie_dma_chan *dma_chan;
-	struct pcie_dma_reg *dma_reg;
-	int i, rc = 0;
+	struct __iomem pcie_dma_chan * dma_chan;
+	struct __iomem pcie_dma_reg * dma_reg =
+				(struct __iomem pcie_dma_reg *)(dma_base);
+	int i, rc;
 
 	if (descs_num <= 0 || descs_num > XPCIE_NUM_RX_DESCS)
 		return -EINVAL;
@@ -407,8 +410,7 @@ int intel_xpcie_ep_dma_read_ll(struct pci_epf *epf, int chan, int descs_num)
 	if (chan < 0 || chan >= DMA_CHAN_NUM)
 		return -EINVAL;
 
-	dma_reg = (struct pcie_dma_reg *)dma_base;
-	dma_chan = (struct pcie_dma_chan *)
+	dma_chan = (struct __iomem pcie_dma_chan *)
 		(dma_base + dma_chan_offset[READ_ENGINE][chan]);
 
 	desc_buf = &xpcie_epf->rx_desc_buf[chan];
@@ -417,6 +419,7 @@ int intel_xpcie_ep_dma_read_ll(struct pci_epf *epf, int chan, int descs_num)
 
 	/* Start DMA transfer. */
 	rc = intel_xpcie_ep_dma_doorbell(xpcie_epf, chan,
+					 (void __iomem *)
 					 &dma_reg->dma_read_doorbell);
 	if (rc)
 		return rc;
@@ -424,7 +427,7 @@ int intel_xpcie_ep_dma_read_ll(struct pci_epf *epf, int chan, int descs_num)
 	/* Wait for DMA transfer to complete. */
 	for (i = 0; i < DMA_POLLING_TIMEOUT; i++) {
 		usleep_range(5, 10);
-		if (ioread32(&dma_reg->dma_read_int_status) &
+		if (ioread32((void __iomem *)&dma_reg->dma_read_int_status) &
 		    (DMA_DONE_INTERRUPT_CH_MASK(chan) |
 		     DMA_ABORT_INTERRUPT_CH_MASK(chan)))
 			break;
@@ -435,18 +438,20 @@ int intel_xpcie_ep_dma_read_ll(struct pci_epf *epf, int chan, int descs_num)
 		goto cleanup;
 	}
 
-	rc = intel_xpcie_ep_dma_err_status(&dma_reg->dma_read_err_status_low,
+	rc = intel_xpcie_ep_dma_err_status((void __iomem *)
+					   &dma_reg->dma_read_err_status_low,
 					   chan);
 	if (!rc) {
 		rc =
-		intel_xpcie_ep_dma_rd_err_sts_h(&dma_reg->dma_rd_err_sts_h,
+		intel_xpcie_ep_dma_rd_err_sts_h((void __iomem *)
+						&dma_reg->dma_rd_err_sts_h,
 						chan);
 	}
 cleanup:
 	/* Clear the done/abort interrupt. */
 	iowrite32((DMA_DONE_INTERRUPT_CH_MASK(chan) |
 		   DMA_ABORT_INTERRUPT_CH_MASK(chan)),
-		  &dma_reg->dma_read_int_clear);
+		  (void __iomem *)&dma_reg->dma_read_int_clear);
 
 	if (rc) {
 		intel_xpcie_ep_dma_disable(dma_base, READ_ENGINE);
@@ -515,15 +520,15 @@ static int intel_xpcie_ep_dma_alloc_ll_descs_mem(struct xpcie_epf *xpcie_epf)
 	return 0;
 }
 
-bool intel_xpcie_ep_dma_enabled(struct pci_epf *epf)
+static bool intel_xpcie_ep_dma_enabled(struct pci_epf *epf)
 {
 	struct xpcie_epf *xpcie_epf = epf_get_drvdata(epf);
 	void __iomem *w_engine_en, *r_engine_en;
-	struct pcie_dma_reg *dma_reg;
+	struct __iomem pcie_dma_reg * dma_reg =
+			(struct __iomem pcie_dma_reg *)(xpcie_epf->dma_base);
 
-	dma_reg = (struct pcie_dma_reg *)xpcie_epf->dma_base;
-	r_engine_en = &dma_reg->dma_read_engine_en;
-	w_engine_en = &dma_reg->dma_write_engine_en;
+	r_engine_en = (void __iomem *)&dma_reg->dma_read_engine_en;
+	w_engine_en = (void __iomem *)&dma_reg->dma_write_engine_en;
 
 	return (ioread32(w_engine_en) & DMA_ENGINE_EN_MASK) &&
 		(ioread32(r_engine_en) & DMA_ENGINE_EN_MASK);
@@ -560,7 +565,7 @@ int intel_xpcie_ep_dma_uninit(struct pci_epf *epf)
 int intel_xpcie_ep_dma_init(struct pci_epf *epf)
 {
 	struct xpcie_epf *xpcie_epf = epf_get_drvdata(epf);
-	int rc = 0;
+	int rc;
 
 	xpcie_epf->dma_base = intel_xpcie_ep_get_dma_base(epf);
 
diff --git a/drivers/misc/xlink-pcie/local_host/dma.h b/drivers/misc/xlink-pcie/local_host/dma.h
deleted file mode 100644
index 5aed06d3bcb6..000000000000
--- a/drivers/misc/xlink-pcie/local_host/dma.h
+++ /dev/null
@@ -1,24 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0-only */
-/*****************************************************************************
- *
- * Intel Keem Bay XLink PCIe Driver
- *
- * Copyright (C) 2020 Intel Corporation
- *
- ****************************************************************************/
-
-#ifndef XPCIE_DMA_HEADER_
-#define XPCIE_DMA_HEADER_
-
-#include <linux/types.h>
-#include <linux/pci-epc.h>
-#include <linux/pci-epf.h>
-
-int intel_xpcie_ep_dma_init(struct pci_epf *epf);
-int intel_xpcie_ep_dma_uninit(struct pci_epf *epf);
-int intel_xpcie_ep_dma_read_ll(struct pci_epf *epf, int chan, int descs_num);
-int intel_xpcie_ep_dma_write_ll(struct pci_epf *epf, int chan, int descs_num);
-bool intel_xpcie_ep_dma_enabled(struct pci_epf *epf);
-int intel_xpcie_ep_dma_reset(struct pci_epf *epf);
-
-#endif /* XPCIE_DMA_HEADER_ */
diff --git a/drivers/misc/xlink-pcie/local_host/epf.c b/drivers/misc/xlink-pcie/local_host/epf.c
index 68b5a8c927a7..0d16bf6103c0 100644
--- a/drivers/misc/xlink-pcie/local_host/epf.c
+++ b/drivers/misc/xlink-pcie/local_host/epf.c
@@ -7,45 +7,27 @@
  *
  ****************************************************************************/
 
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/types.h>
-#include <linux/errno.h>
-#include <linux/jiffies.h>
-#include <linux/compiler.h>
-#include <linux/pci_ids.h>
-#include <linux/reboot.h>
 #include <linux/platform_device.h>
-#include <linux/xlink_drv_inf.h>
-#include <linux/err.h>
 #include <linux/of.h>
-#include <linux/of_address.h>
-#include <linux/of_irq.h>
-#include "../common/xpcie.h"
-#include "../common/core.h"
-#include "../common/util.h"
+#include <linux/reboot.h>
+
 #include "epf.h"
-#include "struct.h"
-#include "dma.h"
 
 #define BAR2_MIN_SIZE			SZ_16K
 #define BAR4_MIN_SIZE			SZ_16K
-#define KMB_EP_OUTBOUND_MAP_MIN_SIZE	SZ_16K
-
-#define PCIE_REGS_PCIE_SYS_CFG_CORE	0x7c
-#define PCIE_CFG_PBUS_NUM_OFFSET	8
-#define PCIE_CFG_PBUS_NUM_MASK		0xFF
-#define PCIE_CFG_PBUS_DEV_NUM_OFFSET	16
-#define PCIE_CFG_PBUS_DEV_NUM_MASK	0x1F
 
 #define PCIE_REGS_PCIE_INTR_ENABLE	0x18
-#define PCIE_REGS_PCIE_INTR_FLAGS	0x1c
+#define PCIE_REGS_PCIE_INTR_FLAGS	0x1C
 #define LBC_CII_EVENT_FLAG		BIT(18)
-#define PCIE_REGS_MEM_ACCESS_IRQ_VECTOR	0x180
 #define PCIE_REGS_PCIE_ERR_INTR_FLAGS	0x24
 #define LINK_REQ_RST_FLG		BIT(15)
 
+#define PCIE_REGS_PCIE_SYS_CFG_CORE	0x7C
+#define PCIE_CFG_PBUS_NUM_OFFSET	8
+#define PCIE_CFG_PBUS_NUM_MASK		0xFF
+#define PCIE_CFG_PBUS_DEV_NUM_OFFSET	16
+#define PCIE_CFG_PBUS_DEV_NUM_MASK	0x1F
+
 static struct pci_epf_header xpcie_header = {
 	.vendorid = PCI_VENDOR_ID_INTEL,
 	.deviceid = PCI_DEVICE_ID_INTEL_KEEMBAY,
@@ -64,6 +46,43 @@ static const struct pci_epf_device_id xpcie_epf_ids[] = {
 
 u32 xlink_sw_id;
 
+int intel_xpcie_copy_from_host_ll(struct xpcie *xpcie, int chan, int descs_num)
+{
+	struct xpcie_epf *xpcie_epf = container_of(xpcie,
+						   struct xpcie_epf, xpcie);
+	struct pci_epf *epf = xpcie_epf->epf;
+
+	return intel_xpcie_ep_dma_read_ll(epf, chan, descs_num);
+}
+
+int intel_xpcie_copy_to_host_ll(struct xpcie *xpcie, int chan, int descs_num)
+{
+	struct xpcie_epf *xpcie_epf = container_of(xpcie,
+						   struct xpcie_epf, xpcie);
+	struct pci_epf *epf = xpcie_epf->epf;
+
+	return intel_xpcie_ep_dma_write_ll(epf, chan, descs_num);
+}
+
+void intel_xpcie_register_host_irq(struct xpcie *xpcie, irq_handler_t func)
+{
+	struct xpcie_epf *xpcie_epf = container_of(xpcie,
+						   struct xpcie_epf, xpcie);
+
+	xpcie_epf->core_irq_callback = func;
+}
+
+int intel_xpcie_raise_irq(struct xpcie *xpcie, enum xpcie_doorbell_type type)
+{
+	struct xpcie_epf *xpcie_epf = container_of(xpcie,
+						   struct xpcie_epf, xpcie);
+	struct pci_epf *epf = xpcie_epf->epf;
+
+	intel_xpcie_set_doorbell(xpcie, FROM_DEVICE, type, 1);
+
+	return pci_epc_raise_irq(epf->epc, epf->func_no, PCI_EPC_IRQ_MSI, 1);
+}
+
 static irqreturn_t intel_xpcie_err_interrupt(int irq, void *args)
 {
 	struct xpcie_epf *xpcie_epf;
@@ -109,25 +128,6 @@ static irqreturn_t intel_xpcie_host_interrupt(int irq, void *args)
 	return IRQ_HANDLED;
 }
 
-void intel_xpcie_register_host_irq(struct xpcie *xpcie, irq_handler_t func)
-{
-	struct xpcie_epf *xpcie_epf = container_of(xpcie,
-						   struct xpcie_epf, xpcie);
-
-	xpcie_epf->core_irq_callback = func;
-}
-
-int intel_xpcie_raise_irq(struct xpcie *xpcie, enum xpcie_doorbell_type type)
-{
-	struct xpcie_epf *xpcie_epf = container_of(xpcie,
-						   struct xpcie_epf, xpcie);
-	struct pci_epf *epf = xpcie_epf->epf;
-
-	intel_xpcie_set_doorbell(xpcie, FROM_DEVICE, type, 1);
-
-	return pci_epc_raise_irq(epf->epc, epf->func_no, PCI_EPC_IRQ_MSI, 1);
-}
-
 static void __iomem *intel_xpcie_epc_alloc_addr(struct pci_epc *epc,
 						phys_addr_t *phys_addr,
 						size_t size)
@@ -153,32 +153,6 @@ static void intel_xpcie_epc_free_addr(struct pci_epc *epc,
 	spin_unlock_irqrestore(&epc->lock, flags);
 }
 
-int intel_xpcie_copy_from_host_ll(struct xpcie *xpcie, int chan, int descs_num)
-{
-	struct xpcie_epf *xpcie_epf = container_of(xpcie,
-						   struct xpcie_epf, xpcie);
-	struct pci_epf *epf = xpcie_epf->epf;
-
-	return intel_xpcie_ep_dma_read_ll(epf, chan, descs_num);
-}
-
-int intel_xpcie_copy_to_host_ll(struct xpcie *xpcie, int chan, int descs_num)
-{
-	struct xpcie_epf *xpcie_epf = container_of(xpcie,
-						   struct xpcie_epf, xpcie);
-	struct pci_epf *epf = xpcie_epf->epf;
-
-	return intel_xpcie_ep_dma_write_ll(epf, chan, descs_num);
-}
-
-struct xpcie *intel_xpcie_dev_to_xpcie(struct device *dev)
-{
-	struct pci_epf *epf = container_of(dev, struct pci_epf, dev);
-	struct xpcie_epf *xpcie_epf = epf_get_drvdata(epf);
-
-	return &xpcie_epf->xpcie;
-}
-
 static int intel_xpcie_check_bar(struct pci_epf *epf,
 				 struct pci_epf_bar *epf_bar,
 				 enum pci_barno barno,
@@ -263,7 +237,7 @@ static int intel_xpcie_setup_bar(struct pci_epf *epf, enum pci_barno barno,
 	struct xpcie_epf *xpcie_epf = epf_get_drvdata(epf);
 	struct pci_epf_bar *bar = &epf->bar[barno];
 	struct pci_epc *epc = epf->epc;
-	void *vaddr = NULL;
+	void *vaddr;
 	int ret;
 
 	bar->flags |= PCI_BASE_ADDRESS_MEM_TYPE_64;
@@ -361,7 +335,7 @@ static int intel_xpcie_epf_get_platform_data(struct device *dev,
 	if (IS_ERR(xpcie_epf->dbi_base))
 		return PTR_ERR(xpcie_epf->dbi_base);
 
-	strncpy(xpcie_epf->stepping, "B0", strlen("B0"));
+	memcpy(xpcie_epf->stepping, "B0", strlen("B0"));
 	soc_node = of_get_parent(pdev->dev.of_node);
 	if (soc_node) {
 		version_node = of_get_child_by_name(soc_node, "version-info");
@@ -369,7 +343,7 @@ static int intel_xpcie_epf_get_platform_data(struct device *dev,
 			prop = of_get_property(version_node, "stepping",
 					       &prop_size);
 			if (prop && prop_size <= KEEMBAY_XPCIE_STEPPING_MAXLEN)
-				strncpy(xpcie_epf->stepping, prop, prop_size);
+				memcpy(xpcie_epf->stepping, prop, prop_size);
 			of_node_put(version_node);
 		}
 		of_node_put(soc_node);
@@ -384,9 +358,8 @@ static int intel_xpcie_epf_bind(struct pci_epf *epf)
 	const struct pci_epc_features *features;
 	struct pci_epc *epc = epf->epc;
 	struct device *dev;
-	size_t align = 0;
-	u32 bus_num = 0;
-	u32 dev_num = 0;
+	size_t align;
+	u32 bus_num, dev_num;
 	int ret;
 
 	if (WARN_ON_ONCE(!epc))
@@ -414,16 +387,35 @@ static int intel_xpcie_epf_bind(struct pci_epf *epf)
 
 	if (!strcmp(xpcie_epf->stepping, "A0")) {
 		xpcie_epf->xpcie.legacy_a0 = true;
-		xpcie_epf->xpcie.mmio->legacy_a0 = 1;
+		intel_xpcie_iowrite32(1, xpcie_epf->xpcie.mmio +
+					 XPCIE_MMIO_LEGACY_A0);
 	} else {
 		xpcie_epf->xpcie.legacy_a0 = false;
-		xpcie_epf->xpcie.mmio->legacy_a0 = 0;
+		intel_xpcie_iowrite32(0, xpcie_epf->xpcie.mmio +
+					 XPCIE_MMIO_LEGACY_A0);
+	}
+
+	/* Enable interrupt */
+	writel(LBC_CII_EVENT_FLAG,
+	       xpcie_epf->apb_base + PCIE_REGS_PCIE_INTR_ENABLE);
+	ret = request_irq(xpcie_epf->irq, &intel_xpcie_host_interrupt,
+			  0, XPCIE_DRIVER_NAME, &xpcie_epf->xpcie);
+	if (ret) {
+		dev_err(&epf->dev, "failed to request irq\n");
+		goto err_cleanup_bars;
+	}
+
+	ret = request_irq(xpcie_epf->irq_err, &intel_xpcie_err_interrupt, 0,
+			  XPCIE_DRIVER_NAME, &xpcie_epf->xpcie);
+	if (ret) {
+		dev_err(&epf->dev, "failed to request error irq\n");
+		goto err_free_irq;
 	}
 
 	ret = intel_xpcie_ep_dma_init(epf);
 	if (ret) {
 		dev_err(&epf->dev, "DMA initialization failed\n");
-		goto bind_error;
+		goto err_free_err_irq;
 	}
 
 	intel_xpcie_set_device_status(&xpcie_epf->xpcie, XPCIE_STATUS_READY);
@@ -442,43 +434,34 @@ static int intel_xpcie_epf_bind(struct pci_epf *epf)
 	ret = intel_xpcie_core_init(&xpcie_epf->xpcie);
 	if (ret) {
 		dev_err(&epf->dev, "Core component configuration failed\n");
-		goto bind_error;
+		goto err_uninit_dma;
 	}
 
-	/* Enable interrupt */
-	writel(LBC_CII_EVENT_FLAG,
-	       xpcie_epf->apb_base + PCIE_REGS_PCIE_INTR_ENABLE);
-	ret = request_irq(xpcie_epf->irq, &intel_xpcie_host_interrupt,
-			  0, XPCIE_DRIVER_NAME, &xpcie_epf->xpcie);
-	if (ret) {
-		dev_err(&epf->dev, "failed to request irq\n");
-		goto bind_error;
-	}
-
-	ret = request_irq(xpcie_epf->irq_err, &intel_xpcie_err_interrupt, 0,
-			  XPCIE_DRIVER_NAME, &xpcie_epf->xpcie);
-	if (ret) {
-		dev_err(&epf->dev, "failed to request error irq\n");
-		free_irq(xpcie_epf->irq, &xpcie_epf->xpcie);
-		goto bind_error;
-	}
-
-	if (!intel_xpcie_ep_dma_enabled(xpcie_epf->epf))
-		intel_xpcie_ep_dma_reset(xpcie_epf->epf);
-
-	xpcie_epf->xpcie.mmio->host_status = XPCIE_STATUS_UNINIT;
+	intel_xpcie_iowrite32(XPCIE_STATUS_UNINIT,
+			      xpcie_epf->xpcie.mmio + XPCIE_MMIO_HOST_STATUS);
 	intel_xpcie_set_device_status(&xpcie_epf->xpcie, XPCIE_STATUS_RUN);
 	intel_xpcie_set_doorbell(&xpcie_epf->xpcie, FROM_DEVICE,
 				 DEV_EVENT, NO_OP);
-	strncpy(xpcie_epf->xpcie.mmio->magic, XPCIE_MAGIC_YOCTO,
-		strlen(XPCIE_MAGIC_YOCTO));
+	memcpy(xpcie_epf->xpcie.mmio + XPCIE_MMIO_MAGIC_OFF, XPCIE_MAGIC_YOCTO,
+	       strlen(XPCIE_MAGIC_YOCTO));
 
 	return 0;
 
-bind_error:
+err_uninit_dma:
 	intel_xpcie_set_device_status(&xpcie_epf->xpcie, XPCIE_STATUS_ERROR);
-	strncpy(xpcie_epf->xpcie.mmio->magic, XPCIE_MAGIC_YOCTO,
-		strlen(XPCIE_MAGIC_YOCTO));
+	memcpy(xpcie_epf->xpcie.mmio + XPCIE_MMIO_MAGIC_OFF, XPCIE_MAGIC_YOCTO,
+	       strlen(XPCIE_MAGIC_YOCTO));
+
+	intel_xpcie_ep_dma_uninit(epf);
+
+err_free_err_irq:
+	free_irq(xpcie_epf->irq_err, &xpcie_epf->xpcie);
+
+err_free_irq:
+	free_irq(xpcie_epf->irq, &xpcie_epf->xpcie);
+
+err_cleanup_bars:
+	intel_xpcie_cleanup_bars(epf);
 
 	return ret;
 }
@@ -509,7 +492,6 @@ static int intel_xpcie_epf_probe(struct pci_epf *epf)
 {
 	struct device *dev = &epf->dev;
 	struct xpcie_epf *xpcie_epf;
-	int ret = 0;
 
 	xpcie_epf = devm_kzalloc(dev, sizeof(*xpcie_epf), GFP_KERNEL);
 	if (!xpcie_epf)
@@ -519,7 +501,7 @@ static int intel_xpcie_epf_probe(struct pci_epf *epf)
 	xpcie_epf->epf = epf;
 	epf_set_drvdata(epf, xpcie_epf);
 
-	return ret;
+	return 0;
 }
 
 static void intel_xpcie_epf_shutdown(struct device *dev)
@@ -528,6 +510,7 @@ static void intel_xpcie_epf_shutdown(struct device *dev)
 	struct xpcie_epf *xpcie_epf;
 
 	xpcie_epf = epf_get_drvdata(epf);
+
 	/* Notify host in case PCIe hot plug not supported */
 	if (xpcie_epf && xpcie_epf->xpcie.status == XPCIE_STATUS_RUN) {
 		intel_xpcie_set_doorbell(&xpcie_epf->xpcie, FROM_DEVICE,
diff --git a/drivers/misc/xlink-pcie/local_host/epf.h b/drivers/misc/xlink-pcie/local_host/epf.h
index adf73d609200..9cfd96923c6f 100644
--- a/drivers/misc/xlink-pcie/local_host/epf.h
+++ b/drivers/misc/xlink-pcie/local_host/epf.h
@@ -10,26 +10,97 @@
 #ifndef XPCIE_EPF_HEADER_
 #define XPCIE_EPF_HEADER_
 
+#include <linux/pci-epc.h>
+#include <linux/pci-epf.h>
+
 #include "../common/xpcie.h"
 #include "../common/util.h"
 
+#define XPCIE_DRIVER_NAME "mxlk_pcie_epf"
+#define XPCIE_DRIVER_DESC "Intel(R) xLink PCIe endpoint function driver"
+
+#define KEEMBAY_XPCIE_STEPPING_MAXLEN 8
+
+#define DMA_CHAN_NUM		(4)
+
+#define XPCIE_NUM_TX_DESCS	(64)
+#define XPCIE_NUM_RX_DESCS	(64)
+
+extern bool dma_ll_mode;
 extern u32 xlink_sw_id;
 
+struct xpcie_dma_ll_desc {
+	u32 dma_ch_control1;
+	u32 dma_transfer_size;
+	union {
+		struct {
+			u32 dma_sar_low;
+			u32 dma_sar_high;
+		};
+		phys_addr_t src_addr;
+	};
+	union {
+		struct {
+			u32 dma_dar_low;
+			u32 dma_dar_high;
+		};
+		phys_addr_t dst_addr;
+	};
+} __packed;
+
+struct xpcie_dma_ll_desc_buf {
+	struct xpcie_dma_ll_desc *virt;
+	dma_addr_t phys;
+	size_t size;
+};
+
+struct xpcie_epf {
+	struct pci_epf *epf;
+	void *vaddr[BAR_5 + 1];
+	enum pci_barno comm_bar;
+	enum pci_barno bar4;
+	const struct pci_epc_features *epc_features;
+	struct xpcie xpcie;
+	int irq;
+	int irq_dma;
+	int irq_err;
+	void __iomem *apb_base;
+	void __iomem *dma_base;
+	void __iomem *dbi_base;
+	char stepping[KEEMBAY_XPCIE_STEPPING_MAXLEN];
+
+	irq_handler_t			core_irq_callback;
+	dma_addr_t			tx_phys;
+	void				*tx_virt;
+	size_t				tx_size;
+	dma_addr_t			rx_phys;
+	void				*rx_virt;
+	size_t				rx_size;
+
+	struct xpcie_dma_ll_desc_buf	tx_desc_buf[DMA_CHAN_NUM];
+	struct xpcie_dma_ll_desc_buf	rx_desc_buf[DMA_CHAN_NUM];
+};
+
+static inline struct device *xpcie_to_dev(struct xpcie *xpcie)
+{
+	struct xpcie_epf *xpcie_epf = container_of(xpcie,
+						   struct xpcie_epf, xpcie);
+
+	return &xpcie_epf->epf->dev;
+}
+
+int intel_xpcie_ep_dma_init(struct pci_epf *epf);
+int intel_xpcie_ep_dma_uninit(struct pci_epf *epf);
+int intel_xpcie_ep_dma_reset(struct pci_epf *epf);
+int intel_xpcie_ep_dma_read_ll(struct pci_epf *epf, int chan, int descs_num);
+int intel_xpcie_ep_dma_write_ll(struct pci_epf *epf, int chan, int descs_num);
+
 void intel_xpcie_register_host_irq(struct xpcie *xpcie,
 				   irq_handler_t func);
-
 int intel_xpcie_raise_irq(struct xpcie *xpcie,
 			  enum xpcie_doorbell_type type);
-
-/*
- * These two functions are for DMA linked list mode.
- *
- * Caller should set the dst/src addresses and length for DMA descriptors in
- * xpcie_epf.dma_ll_tx_descs/dma_ll_rx_descs.
- */
 int intel_xpcie_copy_from_host_ll(struct xpcie *xpcie,
 				  int chan, int descs_num);
 int intel_xpcie_copy_to_host_ll(struct xpcie *xpcie,
 				int chan, int descs_num);
-
 #endif /* XPCIE_EPF_HEADER_ */
diff --git a/drivers/misc/xlink-pcie/local_host/struct.h b/drivers/misc/xlink-pcie/local_host/struct.h
deleted file mode 100644
index 1d9b9bc780b9..000000000000
--- a/drivers/misc/xlink-pcie/local_host/struct.h
+++ /dev/null
@@ -1,81 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0-only */
-/*****************************************************************************
- *
- * Intel Keem Bay XLink PCIe Driver
- *
- * Copyright (C) 2020 Intel Corporation
- *
- ****************************************************************************/
-
-#ifndef XPCIE_STRUCT_HEADER_
-#define XPCIE_STRUCT_HEADER_
-
-#include <linux/pci-epc.h>
-#include <linux/pci-epf.h>
-#include "../common/xpcie.h"
-
-#define KEEMBAY_XPCIE_STEPPING_MAXLEN 8
-
-extern bool dma_ll_mode;
-
-struct xpcie_dma_ll_desc {
-	u32 dma_ch_control1;
-	u32 dma_transfer_size;
-	union {
-		struct {
-			u32 dma_sar_low;
-			u32 dma_sar_high;
-		};
-		phys_addr_t src_addr;
-	};
-	union {
-		struct {
-			u32 dma_dar_low;
-			u32 dma_dar_high;
-		};
-		phys_addr_t dst_addr;
-	};
-} __packed;
-
-struct xpcie_dma_ll_desc_buf {
-	struct xpcie_dma_ll_desc *virt;
-	dma_addr_t phys;
-	size_t size;
-};
-
-struct xpcie_epf {
-	struct pci_epf			*epf;
-	void				*vaddr[BAR_5 + 1];
-	enum pci_barno			comm_bar;
-	enum pci_barno			bar4;
-	const struct pci_epc_features	*epc_features;
-	struct xpcie			xpcie;
-	int				irq;
-	int				irq_dma;
-	int				irq_err;
-	void __iomem			*apb_base;
-	void __iomem			*dma_base;
-	void __iomem			*dbi_base;
-	char				stepping[KEEMBAY_XPCIE_STEPPING_MAXLEN];
-
-	irq_handler_t			core_irq_callback;
-	dma_addr_t			tx_phys;
-	void				*tx_virt;
-	size_t				tx_size;
-	dma_addr_t			rx_phys;
-	void				*rx_virt;
-	size_t				rx_size;
-
-	struct xpcie_dma_ll_desc_buf	tx_desc_buf[4];
-	struct xpcie_dma_ll_desc_buf	rx_desc_buf[4];
-};
-
-static inline struct device *xpcie_to_dev(struct xpcie *xpcie)
-{
-	struct xpcie_epf *xpcie_epf = container_of(xpcie,
-						   struct xpcie_epf, xpcie);
-
-	return &xpcie_epf->epf->dev;
-}
-
-#endif /* XPCIE_STRUCT_HEADER_ */
diff --git a/drivers/misc/xlink-pcie/remote_host/Makefile b/drivers/misc/xlink-pcie/remote_host/Makefile
index 3cba392d5fd0..0b6c0c32705f 100644
--- a/drivers/misc/xlink-pcie/remote_host/Makefile
+++ b/drivers/misc/xlink-pcie/remote_host/Makefile
@@ -1,8 +1,8 @@
-ccflags-y += -Wall -Wno-unused-function -Werror -DXLINK_PCIE_REMOTE=1
+ccflags-y += -Wall -Wno-unused-function -Werror
 
 obj-$(CONFIG_XLINK_PCIE_RH_DRIVER) += mxlk.o
 mxlk-objs := main.o
 mxlk-objs += pci.o
 mxlk-objs += core.o
-mxlk-objs += ../common/interface.o
 mxlk-objs += ../common/util.o
+mxlk-objs += ../common/interface.o
diff --git a/drivers/misc/xlink-pcie/remote_host/core.c b/drivers/misc/xlink-pcie/remote_host/core.c
index 1be04f8a2960..e7ecd20474cf 100644
--- a/drivers/misc/xlink-pcie/remote_host/core.c
+++ b/drivers/misc/xlink-pcie/remote_host/core.c
@@ -7,13 +7,10 @@
  *
  ****************************************************************************/
 
-#include <linux/uaccess.h>
-#include <linux/delay.h>
-
 #include "pci.h"
+
 #include "../common/core.h"
 #include "../common/util.h"
-#include "../common/capabilities.h"
 
 static int rx_pool_size = SZ_32M;
 module_param(rx_pool_size, int, 0664);
@@ -27,13 +24,15 @@ static int intel_xpcie_version_check(struct xpcie *xpcie)
 {
 	struct xpcie_version version;
 
-	memcpy_fromio(&version, &xpcie->mmio->version, sizeof(version));
+	memcpy_fromio(&version,
+		      (void __iomem *)(xpcie->mmio + XPCIE_MMIO_VERSION),
+		      sizeof(version));
 
 	dev_dbg(xpcie_to_dev(xpcie), "ver: device %u.%u.%u, host %u.%u.%u\n",
 		version.major, version.minor, version.build,
 		XPCIE_VERSION_MAJOR, XPCIE_VERSION_MINOR, XPCIE_VERSION_BUILD);
 
-	if (ioread8(&xpcie->mmio->legacy_a0))
+	if (intel_xpcie_ioread8(xpcie->mmio + XPCIE_MMIO_LEGACY_A0))
 		xpcie->legacy_a0 = true;
 
 	return 0;
@@ -123,14 +122,15 @@ static int intel_xpcie_txrx_init(struct xpcie *xpcie,
 	int rc, index, ndesc;
 
 	xpcie->txrx = cap;
-	xpcie->fragment_size = ioread32(&cap->fragment_size);
+	xpcie->fragment_size = intel_xpcie_ioread32(&cap->fragment_size);
 	xpcie->stop_flag = false;
 
-	tx->pipe.ndesc = ioread32(&cap->tx.ndesc);
+	tx->pipe.ndesc = intel_xpcie_ioread32(&cap->tx.ndesc);
 	tx->pipe.head = &cap->tx.head;
 	tx->pipe.tail = &cap->tx.tail;
-	tx->pipe.old = ioread32(&cap->tx.tail);
-	tx->pipe.tdr = (void __iomem *)xpcie->mmio + ioread32(&cap->tx.ring);
+	tx->pipe.old = intel_xpcie_ioread32(&cap->tx.tail);
+	tx->pipe.tdr = (struct xpcie_transfer_desc *)(xpcie->mmio +
+				intel_xpcie_ioread32(&cap->tx.ring));
 
 	tx->ddr = kcalloc(tx->pipe.ndesc, sizeof(struct xpcie_buf_desc *),
 			  GFP_KERNEL);
@@ -139,11 +139,12 @@ static int intel_xpcie_txrx_init(struct xpcie *xpcie,
 		goto error;
 	}
 
-	rx->pipe.ndesc = ioread32(&cap->rx.ndesc);
+	rx->pipe.ndesc = intel_xpcie_ioread32(&cap->rx.ndesc);
 	rx->pipe.head = &cap->rx.head;
 	rx->pipe.tail = &cap->rx.tail;
-	rx->pipe.old = ioread32(&cap->rx.head);
-	rx->pipe.tdr = (void __iomem *)xpcie->mmio + ioread32(&cap->rx.ring);
+	rx->pipe.old = intel_xpcie_ioread32(&cap->rx.head);
+	rx->pipe.tdr = (struct xpcie_transfer_desc *)(xpcie->mmio +
+				intel_xpcie_ioread32(&cap->rx.ring));
 
 	rx->ddr = kcalloc(rx->pipe.ndesc, sizeof(struct xpcie_buf_desc *),
 			  GFP_KERNEL);
@@ -244,8 +245,6 @@ static void intel_xpcie_rx_event_handler(struct work_struct *work)
 	u16 status, interface;
 	int rc;
 
-	intel_xpcie_debug_incr(xpcie, &xpcie->stats.rx_event_runs, 1);
-
 	if (intel_xpcie_get_device_status(xpcie) != XPCIE_STATUS_RUN)
 		return;
 
@@ -287,12 +286,6 @@ static void intel_xpcie_rx_event_handler(struct work_struct *work)
 			bd->length = length;
 			bd->next = NULL;
 
-			intel_xpcie_debug_incr(xpcie,
-					       &xpcie->stats.rx_krn.cnts, 1);
-			intel_xpcie_debug_incr(xpcie,
-					       &xpcie->stats.rx_krn.bytes,
-					       bd->length);
-
 			intel_xpcie_add_bd_to_interface(xpcie, bd);
 		}
 
@@ -322,8 +315,6 @@ static void intel_xpcie_tx_event_handler(struct work_struct *work)
 	size_t bytes, buffers;
 	u16 status;
 
-	intel_xpcie_debug_incr(xpcie, &xpcie->stats.tx_event_runs, 1);
-
 	if (intel_xpcie_get_device_status(xpcie) != XPCIE_STATUS_RUN)
 		return;
 
@@ -369,17 +360,12 @@ static void intel_xpcie_tx_event_handler(struct work_struct *work)
 		intel_xpcie_set_td_interface(td, bd->interface);
 		intel_xpcie_set_td_status(td, XPCIE_DESC_STATUS_ERROR);
 
-		intel_xpcie_debug_incr(xpcie, &xpcie->stats.tx_krn.cnts, 1);
-		intel_xpcie_debug_incr(xpcie, &xpcie->stats.tx_krn.bytes,
-				       bd->length);
-
 		tail = XPCIE_CIRCULAR_INC(tail, ndesc);
 	}
 
 	if (intel_xpcie_get_tdr_tail(&tx->pipe) != tail) {
 		intel_xpcie_set_tdr_tail(&tx->pipe, tail);
 		intel_xpcie_pci_raise_irq(xdev, DATA_SENT, 1);
-		intel_xpcie_debug_incr(xpcie, &xpcie->stats.send_ints, 1);
 	}
 
 	intel_xpcie_list_info(&xpcie->write, &bytes, &buffers);
@@ -399,8 +385,6 @@ static irqreturn_t intel_xpcie_interrupt(int irq, void *args)
 	if (intel_xpcie_get_doorbell(xpcie, FROM_DEVICE, DATA_SENT)) {
 		intel_xpcie_set_doorbell(xpcie, FROM_DEVICE, DATA_SENT, 0);
 		intel_xpcie_start_rx(xpcie, 0);
-
-		intel_xpcie_debug_incr(xpcie, &xdev->xpcie.stats.interrupts, 1);
 	}
 	if (intel_xpcie_get_doorbell(xpcie, FROM_DEVICE, DATA_RECEIVED)) {
 		intel_xpcie_set_doorbell(xpcie, FROM_DEVICE, DATA_RECEIVED, 0);
@@ -502,7 +486,7 @@ int intel_xpcie_core_read(struct xpcie *xpcie, void *buffer, size_t *length,
 	struct xpcie_buf_desc *bd;
 	size_t remaining, len;
 	long jiffies_passed = 0;
-	int ret = 0;
+	int ret;
 
 	len = *length;
 	remaining = len;
@@ -513,8 +497,6 @@ int intel_xpcie_core_read(struct xpcie *xpcie, void *buffer, size_t *length,
 	if (xpcie->status != XPCIE_STATUS_RUN)
 		return -ENODEV;
 
-	intel_xpcie_debug_incr(xpcie, &xpcie->stats.rx_usr.cnts, 1);
-
 	ret = mutex_lock_interruptible(&inf->rlock);
 	if (ret < 0)
 		return -EINTR;
@@ -555,10 +537,6 @@ int intel_xpcie_core_read(struct xpcie *xpcie, void *buffer, size_t *length,
 			bd->data += bcopy;
 			bd->length -= bcopy;
 
-			intel_xpcie_debug_incr(xpcie,
-					       &xpcie->stats.rx_usr.bytes,
-					       bcopy);
-
 			if (bd->length == 0) {
 				intel_xpcie_free_rx_bd(xpcie, bd);
 				bd = intel_xpcie_list_get(&inf->read);
@@ -602,8 +580,6 @@ int intel_xpcie_core_write(struct xpcie *xpcie, void *buffer, size_t *length,
 	if (xpcie->status != XPCIE_STATUS_RUN)
 		return -ENODEV;
 
-	intel_xpcie_debug_incr(xpcie, &xpcie->stats.tx_usr.cnts, 1);
-
 	ret = mutex_lock_interruptible(&xpcie->wlock);
 	if (ret < 0)
 		return -EINTR;
@@ -648,10 +624,6 @@ int intel_xpcie_core_write(struct xpcie *xpcie, void *buffer, size_t *length,
 			bd->length = bcopy;
 			bd->interface = inf->id;
 
-			intel_xpcie_debug_incr(xpcie,
-					       &xpcie->stats.tx_usr.bytes,
-					       bcopy);
-
 			if (remaining) {
 				bd->next = intel_xpcie_alloc_tx_bd(xpcie);
 				bd = bd->next;
diff --git a/drivers/misc/xlink-pcie/remote_host/main.c b/drivers/misc/xlink-pcie/remote_host/main.c
index 55f9c63bd1ad..22dfe6fd884e 100644
--- a/drivers/misc/xlink-pcie/remote_host/main.c
+++ b/drivers/misc/xlink-pcie/remote_host/main.c
@@ -20,10 +20,10 @@ static bool driver_unload;
 static int intel_xpcie_probe(struct pci_dev *pdev,
 			     const struct pci_device_id *ent)
 {
-	u32 hw_id = 0, sw_devid = 0;
 	bool new_device = false;
 	struct xpcie_dev *xdev;
-	int ret = 0;
+	u32 hw_id, sw_devid;
+	int ret;
 
 	hw_id = ((u16)pdev->bus->number << 8) | PCI_SLOT(pdev->devfn);
 
diff --git a/drivers/misc/xlink-pcie/remote_host/pci.c b/drivers/misc/xlink-pcie/remote_host/pci.c
index a9572918a502..1a537e62e7a4 100644
--- a/drivers/misc/xlink-pcie/remote_host/pci.c
+++ b/drivers/misc/xlink-pcie/remote_host/pci.c
@@ -7,15 +7,14 @@
  *
  ****************************************************************************/
 
-#include <linux/delay.h>
+#include <linux/mutex.h>
 #include <linux/pci.h>
-#include <linux/delay.h>
 #include <linux/sched.h>
-#include <linux/workqueue.h>
 #include <linux/wait.h>
-#include <linux/types.h>
-#include <linux/mutex.h>
+#include <linux/workqueue.h>
+
 #include "pci.h"
+
 #include "../common/core.h"
 #include "../common/util.h"
 
@@ -92,14 +91,6 @@ void intel_xpcie_list_del_device(struct xpcie_dev *xdev)
 	mutex_unlock(&dev_list_mutex);
 }
 
-struct xpcie *intel_xpcie_dev_to_xpcie(struct device *dev)
-{
-	struct pci_dev *pdev = container_of(dev, struct pci_dev, dev);
-	struct xpcie_dev *xdev = pci_get_drvdata(pdev);
-
-	return &xdev->xpcie;
-}
-
 static void intel_xpcie_pci_set_aspm(struct xpcie_dev *xdev, int aspm)
 {
 	u16 link_control;
@@ -122,17 +113,17 @@ static void intel_xpcie_pci_set_aspm(struct xpcie_dev *xdev, int aspm)
 static void intel_xpcie_pci_unmap_bar(struct xpcie_dev *xdev)
 {
 	if (xdev->xpcie.bar0) {
-		iounmap(xdev->xpcie.bar0);
+		iounmap((void __iomem *)xdev->xpcie.bar0);
 		xdev->xpcie.bar0 = NULL;
 	}
 
 	if (xdev->xpcie.mmio) {
-		iounmap(xdev->xpcie.mmio - XPCIE_MMIO_OFFSET);
+		iounmap((void __iomem *)(xdev->xpcie.mmio - XPCIE_MMIO_OFFSET));
 		xdev->xpcie.mmio = NULL;
 	}
 
 	if (xdev->xpcie.bar4) {
-		iounmap(xdev->xpcie.bar4);
+		iounmap((void __iomem *)xdev->xpcie.bar4);
 		xdev->xpcie.bar4 = NULL;
 	}
 }
@@ -144,19 +135,20 @@ static int intel_xpcie_pci_map_bar(struct xpcie_dev *xdev)
 		return -EIO;
 	}
 
-	xdev->xpcie.bar0 = pci_ioremap_bar(xdev->pci, 0);
+	xdev->xpcie.bar0 = (void __force *)pci_ioremap_bar(xdev->pci, 0);
 	if (!xdev->xpcie.bar0) {
 		dev_err(&xdev->pci->dev, "failed to ioremap BAR0\n");
 		goto bar_error;
 	}
 
-	xdev->xpcie.mmio = pci_ioremap_bar(xdev->pci, 2) + XPCIE_MMIO_OFFSET;
+	xdev->xpcie.mmio = (void __force *)
+			   (pci_ioremap_bar(xdev->pci, 2) + XPCIE_MMIO_OFFSET);
 	if (!xdev->xpcie.mmio) {
 		dev_err(&xdev->pci->dev, "failed to ioremap BAR2\n");
 		goto bar_error;
 	}
 
-	xdev->xpcie.bar4 = pci_ioremap_wc_bar(xdev->pci, 4);
+	xdev->xpcie.bar4 = (void __force *)pci_ioremap_wc_bar(xdev->pci, 4);
 	if (!xdev->xpcie.bar4) {
 		dev_err(&xdev->pci->dev, "failed to ioremap BAR4\n");
 		goto bar_error;
@@ -241,8 +233,6 @@ static int intel_xpcie_pci_prepare_dev_reset(struct xpcie_dev *xdev,
 
 	mutex_unlock(&xdev->lock);
 
-	intel_xpcie_pci_notify_event(xdev, NOTIFY_DEVICE_DISCONNECTED);
-
 	return 0;
 }
 
@@ -256,8 +246,6 @@ static void xpcie_device_shutdown(struct work_struct *work)
 
 static int xpcie_device_init(struct xpcie_dev *xdev)
 {
-	int rc = 0;
-
 	INIT_DELAYED_WORK(&xdev->wait_event, xpcie_device_poll);
 	INIT_DELAYED_WORK(&xdev->shutdown_event, xpcie_device_shutdown);
 
@@ -268,7 +256,7 @@ static int xpcie_device_init(struct xpcie_dev *xdev)
 	init_waitqueue_head(&xdev->waitqueue);
 	schedule_delayed_work(&xdev->wait_event, 0);
 
-	return rc;
+	return 0;
 }
 
 int intel_xpcie_pci_init(struct xpcie_dev *xdev, struct pci_dev *pdev)
@@ -305,8 +293,6 @@ int intel_xpcie_pci_init(struct xpcie_dev *xdev, struct pci_dev *pdev)
 
 	intel_xpcie_pci_set_aspm(xdev, aspm_enable);
 
-	intel_xpcie_init_debug(&xdev->xpcie, &xdev->pci->dev);
-
 	rc = xpcie_device_init(xdev);
 	if (!rc)
 		goto init_exit;
@@ -335,8 +321,6 @@ int intel_xpcie_pci_cleanup(struct xpcie_dev *xdev)
 	if (mutex_lock_interruptible(&xdev->lock))
 		return -EINTR;
 
-	intel_xpcie_uninit_debug(&xdev->xpcie, &xdev->pci->dev);
-
 	cancel_delayed_work(&xdev->wait_event);
 	cancel_delayed_work(&xdev->shutdown_event);
 	xdev->core_irq_callback = NULL;
@@ -370,9 +354,9 @@ int intel_xpcie_pci_register_irq(struct xpcie_dev *xdev,
 
 	rc = intel_xpcie_pci_irq_init(xdev, irq_handler);
 	if (rc)
-		return rc;
+		dev_warn(&xdev->pci->dev, "failed to initialize pci irq\n");
 
-	return 0;
+	return rc;
 }
 
 int intel_xpcie_pci_raise_irq(struct xpcie_dev *xdev,
@@ -422,7 +406,7 @@ int intel_xpcie_get_device_name_by_id(u32 id,
 
 	size = (name_size > XPCIE_MAX_NAME_LEN) ?
 		XPCIE_MAX_NAME_LEN : name_size;
-	strncpy(device_name, xdev->name, size);
+	memcpy(device_name, xdev->name, size);
 
 	mutex_unlock(&xdev->lock);
 
@@ -445,8 +429,8 @@ int intel_xpcie_get_device_status_by_id(u32 id, u32 *status)
 
 int intel_xpcie_pci_connect_device(u32 id)
 {
-	int rc = 0;
 	struct xpcie_dev *xdev;
+	int rc = 0;
 
 	xdev = intel_xpcie_get_device_by_id(id);
 	if (!xdev)
diff --git a/drivers/misc/xlink-pcie/remote_host/pci.h b/drivers/misc/xlink-pcie/remote_host/pci.h
index 0a42a792ad6b..0ca8a0bc82ec 100644
--- a/drivers/misc/xlink-pcie/remote_host/pci.h
+++ b/drivers/misc/xlink-pcie/remote_host/pci.h
@@ -10,12 +10,16 @@
 #ifndef XPCIE_PCI_HEADER_
 #define XPCIE_PCI_HEADER_
 
-#include <linux/list.h>
 #include <linux/interrupt.h>
+#include <linux/list.h>
+#include <linux/pci.h>
 #include <linux/xlink_drv_inf.h>
 #include "../common/xpcie.h"
 #include "../common/util.h"
 
+#define XPCIE_DRIVER_NAME "mxlk"
+#define XPCIE_DRIVER_DESC "Intel(R) Keem Bay XLink PCIe driver"
+
 #define XPCIE_MAX_NAME_LEN	(32)
 
 struct xpcie_dev {
-- 
2.27.0

