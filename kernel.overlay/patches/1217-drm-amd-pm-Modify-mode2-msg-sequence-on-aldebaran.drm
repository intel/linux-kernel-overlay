From 475fb4b06f75ca54e7028c50702bfb9cace398e9 Mon Sep 17 00:00:00 2001
From: Lijo Lazar <lijo.lazar@amd.com>
Date: Tue, 16 Mar 2021 19:19:09 +0800
Subject: [PATCH 1217/2740] drm/amd/pm: Modify mode2 msg sequence on aldebaran

v1: During mode2 reset, PCI space is lost after message is sent.
Restore PCI space before waiting for response from firmware.

v2: Move mode2 sequence to aldebaran and update PMFW version.
Handle generic sequence in smu13 without PMFW version check.

Signed-off-by: Lijo Lazar <lijo.lazar@amd.com>
Reviewed-by: Feifei Xu <Feifei.Xu@amd.com>
Reviewed-by: Hawking Zhang <Hawking.Zhang@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
---
 .../drm/amd/pm/swsmu/smu13/aldebaran_ppt.c    | 53 ++++++++++++++++++-
 .../gpu/drm/amd/pm/swsmu/smu13/smu_v13_0.c    | 15 +++---
 drivers/gpu/drm/amd/pm/swsmu/smu_cmn.c        |  2 +-
 drivers/gpu/drm/amd/pm/swsmu/smu_cmn.h        |  2 +
 4 files changed, 61 insertions(+), 11 deletions(-)

diff --git a/drivers/gpu/drm/amd/pm/swsmu/smu13/aldebaran_ppt.c b/drivers/gpu/drm/amd/pm/swsmu/smu13/aldebaran_ppt.c
index 7d38b92a78dc..ec485308b921 100644
--- a/drivers/gpu/drm/amd/pm/swsmu/smu13/aldebaran_ppt.c
+++ b/drivers/gpu/drm/amd/pm/swsmu/smu13/aldebaran_ppt.c
@@ -1432,6 +1432,57 @@ static ssize_t aldebaran_get_gpu_metrics(struct smu_context *smu,
 	return sizeof(struct gpu_metrics_v1_1);
 }
 
+int aldebaran_mode2_reset(struct smu_context *smu)
+{
+	u32 smu_version;
+	int ret = 0, index;
+	struct amdgpu_device *adev = smu->adev;
+	int timeout = 10;
+
+	smu_cmn_get_smc_version(smu, NULL, &smu_version);
+
+	index = smu_cmn_to_asic_specific_index(smu, CMN2ASIC_MAPPING_MSG,
+						SMU_MSG_GfxDeviceDriverReset);
+
+	mutex_lock(&smu->message_lock);
+	if (smu_version >= 0x00441400) {
+		ret = smu_cmn_send_msg_without_waiting(smu, (uint16_t)index, SMU_RESET_MODE_2);
+		/* This is similar to FLR, wait till max FLR timeout */
+		msleep(100);
+		dev_dbg(smu->adev->dev, "restore config space...\n");
+		/* Restore the config space saved during init */
+		amdgpu_device_load_pci_state(adev->pdev);
+
+		dev_dbg(smu->adev->dev, "wait for reset ack\n");
+		while (ret == -ETIME && timeout)  {
+			ret = smu_cmn_wait_for_response(smu);
+			/* Wait a bit more time for getting ACK */
+			if (ret == -ETIME) {
+				--timeout;
+				usleep_range(500, 1000);
+				continue;
+			}
+
+			if (ret != 1) {
+				dev_err(adev->dev, "failed to send mode2 message \tparam: 0x%08x response %#x\n",
+						SMU_RESET_MODE_2, ret);
+				goto out;
+			}
+		}
+
+	} else {
+		dev_err(adev->dev, "smu fw 0x%x does not support MSG_GfxDeviceDriverReset MSG\n",
+				smu_version);
+	}
+
+	if (ret == 1)
+		ret = 0;
+out:
+	mutex_unlock(&smu->message_lock);
+
+	return ret;
+}
+
 static bool aldebaran_is_mode1_reset_supported(struct smu_context *smu)
 {
 #if 0
@@ -1530,8 +1581,8 @@ static const struct pptable_funcs aldebaran_ppt_funcs = {
 	.mode1_reset_is_support = aldebaran_is_mode1_reset_supported,
 	.mode2_reset_is_support = aldebaran_is_mode2_reset_supported,
 	.mode1_reset = smu_v13_0_mode1_reset,
-	.mode2_reset = smu_v13_0_mode2_reset,
 	.set_mp1_state = aldebaran_set_mp1_state,
+	.mode2_reset = aldebaran_mode2_reset,
 };
 
 void aldebaran_set_ppt_funcs(struct smu_context *smu)
diff --git a/drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0.c b/drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0.c
index 2e296cb3bb04..8974cd55994b 100644
--- a/drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0.c
+++ b/drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0.c
@@ -1376,17 +1376,14 @@ int smu_v13_0_mode1_reset(struct smu_context *smu)
 
 int smu_v13_0_mode2_reset(struct smu_context *smu)
 {
-	u32 smu_version;
-	int ret = 0;
-	struct amdgpu_device *adev = smu->adev;
-	smu_cmn_get_smc_version(smu, NULL, &smu_version);
-	if (smu_version >= 0x00440700)
-		ret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_GfxDeviceDriverReset, SMU_RESET_MODE_2, NULL);
-	else
-		dev_err(adev->dev, "smu fw 0x%x does not support MSG_GfxDeviceDriverReset MSG\n", smu_version);
-	/*TODO: mode2 reset wait time should be shorter, will modify it later*/
+	int ret;
+
+	ret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_GfxDeviceDriverReset,
+			SMU_RESET_MODE_2, NULL);
+	/*TODO: mode2 reset wait time should be shorter, add ASIC specific func if required */
 	if (!ret)
 		msleep(SMU13_MODE1_RESET_WAIT_TIME_IN_MS);
+
 	return ret;
 }
 
diff --git a/drivers/gpu/drm/amd/pm/swsmu/smu_cmn.c b/drivers/gpu/drm/amd/pm/swsmu/smu_cmn.c
index 2d216f5b167d..b725f263092b 100644
--- a/drivers/gpu/drm/amd/pm/swsmu/smu_cmn.c
+++ b/drivers/gpu/drm/amd/pm/swsmu/smu_cmn.c
@@ -76,7 +76,7 @@ static void smu_cmn_read_arg(struct smu_context *smu,
 	*arg = RREG32_SOC15(MP1, 0, mmMP1_SMN_C2PMSG_82);
 }
 
-static int smu_cmn_wait_for_response(struct smu_context *smu)
+int smu_cmn_wait_for_response(struct smu_context *smu)
 {
 	struct amdgpu_device *adev = smu->adev;
 	uint32_t cur_value, i, timeout = adev->usec_timeout * 10;
diff --git a/drivers/gpu/drm/amd/pm/swsmu/smu_cmn.h b/drivers/gpu/drm/amd/pm/swsmu/smu_cmn.h
index 155e2a68fa1c..da6ff6f024f9 100644
--- a/drivers/gpu/drm/amd/pm/swsmu/smu_cmn.h
+++ b/drivers/gpu/drm/amd/pm/swsmu/smu_cmn.h
@@ -37,6 +37,8 @@ int smu_cmn_send_smc_msg(struct smu_context *smu,
 			 enum smu_message_type msg,
 			 uint32_t *read_arg);
 
+int smu_cmn_wait_for_response(struct smu_context *smu);
+
 int smu_cmn_to_asic_specific_index(struct smu_context *smu,
 				   enum smu_cmn2asic_mapping_type type,
 				   uint32_t index);
-- 
2.25.1

