From 392801559afce109426c580f62320bbe62e61704 Mon Sep 17 00:00:00 2001
From: "David E. Box" <david.e.box@linux.intel.com>
Date: Thu, 17 Jun 2021 10:21:30 -0700
Subject: [PATCH 14/16] PCI: Disable Downstream Port Containment during suspend

Per the implementation note in PCIe r5.0, sec 6.32.1, Device Readiness
Status (DRS) message that occur (legally) before the device has be
assigned a bud number bay be detected as ACS errors. This has been
observed on PCIE ports on several Intel desktop platform.

Signed-off-by: David E. Box <david.e.box@linux.intel.com>
---
 drivers/pci/pci.c      | 22 ++++++++++++++++++++++
 drivers/pci/pci.h      |  2 ++
 drivers/pci/pcie/dpc.c | 18 ++++++++++++++++++
 3 files changed, 42 insertions(+)

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 8d4ebe095d0c..9cb446aee443 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2642,6 +2642,17 @@ int pci_prepare_to_sleep(struct pci_dev *dev)
 	if (pci_pcie_type(dev) == PCI_EXP_TYPE_ROOT_PORT)
 		pci_disable_ptm(dev);
 
+	/*
+	 * Per the Implementation Note in PCIE Spec 5.0, 6.23.1 "Device
+	 * Readiness Status (DRS)", DRS messages from devices that have not
+	 * been fully initialized may be detected as ACS violation errors.
+	 * This has been reported and found to occur during resume between
+	 * the time platform firmware powers on the device and the time the
+	 * device state is restored. To avoid this scenario, disable the DPC
+	 * trigger on suspend
+	 */
+	pci_disable_dpc(dev);
+
 	pci_enable_wake(dev, target_state, wakeup);
 
 	error = pci_set_power_state(dev, target_state);
@@ -2697,6 +2708,17 @@ int pci_finish_runtime_suspend(struct pci_dev *dev)
 	if (pci_pcie_type(dev) == PCI_EXP_TYPE_ROOT_PORT)
 		pci_disable_ptm(dev);
 
+	/*
+	 * Per the Implementation Note in PCIE Spec 5.0, 6.23.1 "Device
+	 * Readiness Status (DRS)", DRS messages from devices that have not
+	 * been fully initialized may be detected as ACS violation errors.
+	 * This has been reported and found to occur during resume between
+	 * the time platform firmware powers on the device and the time the
+	 * device state is restored. To avoid this scenario, disable the DPC
+	 * trigger on suspend
+	 */
+	pci_disable_dpc(dev);
+
 	__pci_enable_wake(dev, target_state, pci_dev_run_wake(dev));
 
 	error = pci_set_power_state(dev, target_state);
diff --git a/drivers/pci/pci.h b/drivers/pci/pci.h
index 37c913bbc6e1..a2bb5f5f655f 100644
--- a/drivers/pci/pci.h
+++ b/drivers/pci/pci.h
@@ -436,12 +436,14 @@ struct rcec_ea {
 #ifdef CONFIG_PCIE_DPC
 void pci_save_dpc_state(struct pci_dev *dev);
 void pci_restore_dpc_state(struct pci_dev *dev);
+void pci_disable_dpc(struct pci_dev *pdev);
 void pci_dpc_init(struct pci_dev *pdev);
 void dpc_process_error(struct pci_dev *pdev);
 pci_ers_result_t dpc_reset_link(struct pci_dev *pdev);
 #else
 static inline void pci_save_dpc_state(struct pci_dev *dev) {}
 static inline void pci_restore_dpc_state(struct pci_dev *dev) {}
+static inline void pci_disable_dpc(struct pci_dev *pdev) {}
 static inline void pci_dpc_init(struct pci_dev *pdev) {}
 #endif
 
diff --git a/drivers/pci/pcie/dpc.c b/drivers/pci/pcie/dpc.c
index e05aba86a317..d4d1032cd18e 100644
--- a/drivers/pci/pcie/dpc.c
+++ b/drivers/pci/pcie/dpc.c
@@ -71,6 +71,24 @@ void pci_restore_dpc_state(struct pci_dev *dev)
 	pci_write_config_word(dev, dev->dpc_cap + PCI_EXP_DPC_CTL, *cap);
 }
 
+void pci_disable_dpc(struct pci_dev *pdev)
+{
+	int dpc;
+	u16 ctl;
+
+	if (!pci_is_pcie(pdev))
+		return;
+
+	dpc = pci_find_ext_capability(pdev, PCI_EXT_CAP_ID_DPC);
+	if (!dpc)
+		return;
+
+	pci_read_config_word(pdev, pdev->dpc_cap + PCI_EXP_DPC_CTL, &ctl);
+
+	ctl = ctl & ~PCI_EXP_DPC_CTL_EN_FATAL & ~PCI_EXP_DPC_CTL_INT_EN;
+	pci_write_config_word(pdev, pdev->dpc_cap + PCI_EXP_DPC_CTL, ctl);
+}
+
 static int dpc_wait_rp_inactive(struct pci_dev *pdev)
 {
 	unsigned long timeout = jiffies + HZ;
-- 
2.27.0

