From f5b73717cd7f37b832908c207d179d9439620232 Mon Sep 17 00:00:00 2001
From: "Chang S. Bae" <chang.seok.bae@intel.com>
Date: Thu, 3 Jun 2021 13:28:52 -0700
Subject: [PATCH 79/94] x86/fpu/xstate: Make xstate buffer for signal to be
 dynamic

Signal frame has xstate buffer where the kernel saves the states. It also
records the buffer size and indicates the features. Every task has the same
data so far. But dynamic user state does not need to be included when not
used.

Update the sigframe setup to dynamically update the xstate buffer
information.

Signal xstate buffer uses standard format. If a dynamic user state
positions before any non-dynamic state, it needs to be always included
regardless of its use. Otherwise, this dynamic size will work well.

Signed-off-by: Chang S. Bae <chang.seok.bae@intel.com>
---
 arch/x86/include/asm/fpu/internal.h |  2 +-
 arch/x86/include/asm/fpu/xstate.h   |  4 +-
 arch/x86/kernel/fpu/init.c          |  1 +
 arch/x86/kernel/fpu/signal.c        | 76 +++++++++++++++++++++--------
 arch/x86/kernel/fpu/xstate.c        | 46 ++++++++++++++++-
 5 files changed, 104 insertions(+), 25 deletions(-)

diff --git a/arch/x86/include/asm/fpu/internal.h b/arch/x86/include/asm/fpu/internal.h
index 80473ecdb2cc..20b41d0e8fd5 100644
--- a/arch/x86/include/asm/fpu/internal.h
+++ b/arch/x86/include/asm/fpu/internal.h
@@ -341,7 +341,7 @@ static inline void copy_kernel_to_xregs(struct xregs_state *xstate, u64 mask)
  */
 static inline int copy_xregs_to_user(struct xregs_state __user *buf)
 {
-	u64 mask = xfeatures_mask_user();
+	u64 mask = current->thread.fpu.state_mask;
 	u32 lmask = mask;
 	u32 hmask = mask >> 32;
 	int err;
diff --git a/arch/x86/include/asm/fpu/xstate.h b/arch/x86/include/asm/fpu/xstate.h
index c1d1452bbc16..6d7bcbe5b2a1 100644
--- a/arch/x86/include/asm/fpu/xstate.h
+++ b/arch/x86/include/asm/fpu/xstate.h
@@ -108,13 +108,15 @@ extern void __init update_regset_xstate_info(unsigned int size,
 enum xstate_config {
 	XSTATE_MIN_SIZE,
 	XSTATE_MAX_SIZE,
-	XSTATE_USER_SIZE
+	XSTATE_USER_SIZE,
+	XSTATE_USER_MINSIG_SIZE,
 };
 
 extern unsigned int get_xstate_config(enum xstate_config cfg);
 void set_xstate_config(enum xstate_config cfg, unsigned int value);
 
 void *get_xsave_addr(struct fpu *fpu, int xfeature_nr);
+unsigned int get_user_xstate_size(u64 mask);
 unsigned int get_xstate_size(u64 mask);
 int alloc_xstate_buffer(struct fpu *fpu, u64 mask);
 void free_xstate_buffer(struct fpu *fpu);
diff --git a/arch/x86/kernel/fpu/init.c b/arch/x86/kernel/fpu/init.c
index f2fcdcc979e7..cf115d18a1ab 100644
--- a/arch/x86/kernel/fpu/init.c
+++ b/arch/x86/kernel/fpu/init.c
@@ -210,6 +210,7 @@ static void __init fpu__init_system_xstate_size_legacy(void)
 	set_xstate_config(XSTATE_MIN_SIZE, size);
 	set_xstate_config(XSTATE_MAX_SIZE, size);
 	set_xstate_config(XSTATE_USER_SIZE, size);
+	set_xstate_config(XSTATE_USER_MINSIG_SIZE, size);
 }
 
 /*
diff --git a/arch/x86/kernel/fpu/signal.c b/arch/x86/kernel/fpu/signal.c
index cc87368548c9..7a6492a390f0 100644
--- a/arch/x86/kernel/fpu/signal.c
+++ b/arch/x86/kernel/fpu/signal.c
@@ -15,8 +15,24 @@
 #include <asm/sigframe.h>
 #include <asm/trace/fpu.h>
 
+/* Record the minimum signal xstate size and feature bits. See fpu__init_prepare_fx_sw_frame() */
 static struct _fpx_sw_bytes fx_sw_reserved, fx_sw_reserved_ia32;
 
+static unsigned int current_sigxstatesz(void)
+{
+	struct fpu *fpu = &current->thread.fpu;
+
+	if (!(fpu->state_mask & xfeatures_mask_user_dynamic))
+		return get_xstate_config(XSTATE_USER_MINSIG_SIZE);
+
+	return get_user_xstate_size(fpu->state_mask);
+}
+
+static inline int extend_sigxstatesz(unsigned int size)
+{
+	return use_xsave() ? size + FP_XSTATE_MAGIC2_SIZE : size;
+}
+
 /*
  * Check for the presence of extended state information in the
  * user fpstate pointer in the sigcontext.
@@ -35,7 +51,7 @@ static inline int check_for_xstate(struct fxregs_state __user *buf,
 	/* Check for the first magic field and other error scenarios. */
 	if (fx_sw->magic1 != FP_XSTATE_MAGIC1 ||
 	    fx_sw->xstate_size < min_xstate_size ||
-	    fx_sw->xstate_size > get_xstate_config(XSTATE_USER_SIZE) ||
+	    fx_sw->xstate_size > current_sigxstatesz() ||
 	    fx_sw->xstate_size > fx_sw->extended_size)
 		return -1;
 
@@ -85,20 +101,40 @@ static inline int save_fsave_header(struct task_struct *tsk, void __user *buf)
 
 static inline int save_xstate_epilog(void __user *buf, int ia32_frame)
 {
+	struct fpu *fpu = &current->thread.fpu;
 	struct xregs_state __user *x = buf;
-	struct _fpx_sw_bytes *sw_bytes;
+	unsigned int xstate_size = 0;
 	u32 xfeatures;
 	int err;
 
 	/* Setup the bytes not touched by the [f]xsave and reserved for SW. */
-	sw_bytes = ia32_frame ? &fx_sw_reserved_ia32 : &fx_sw_reserved;
-	err = __copy_to_user(&x->i387.sw_reserved, sw_bytes, sizeof(*sw_bytes));
+	if (fpu->state_mask & xfeatures_mask_user_dynamic) {
+		unsigned int minsz = get_xstate_config(XSTATE_USER_MINSIG_SIZE);
+		struct _fpx_sw_bytes sw_bytes;
+
+		xstate_size = get_user_xstate_size(fpu->state_mask);
+
+		/* Copy the initial data and adjust it. */
+		sw_bytes = ia32_frame ? fx_sw_reserved_ia32 : fx_sw_reserved;
+		sw_bytes.xfeatures = fpu->state_mask & xfeatures_mask_user();
+		sw_bytes.xstate_size = xstate_size;
+		sw_bytes.extended_size -= minsz;
+		sw_bytes.extended_size += xstate_size;
+
+		err = __copy_to_user(&x->i387.sw_reserved, &sw_bytes, sizeof(sw_bytes));
+	} else {
+		struct _fpx_sw_bytes *sw_bytes;
+
+		sw_bytes = ia32_frame ? &fx_sw_reserved_ia32 : &fx_sw_reserved;
+		err = __copy_to_user(&x->i387.sw_reserved, sw_bytes, sizeof(*sw_bytes));
+	}
 
 	if (!use_xsave())
 		return err;
 
-	err |= __put_user(FP_XSTATE_MAGIC2,
-			  (__u32 __user *)(buf + get_xstate_config(XSTATE_USER_SIZE)));
+	if (!xstate_size)
+		xstate_size = get_xstate_config(XSTATE_USER_MINSIG_SIZE);
+	err |= __put_user(FP_XSTATE_MAGIC2, (__u32 __user *)(buf + xstate_size));
 
 	/*
 	 * Read the xfeatures which we copied (directly from the cpu or
@@ -135,7 +171,7 @@ static inline int copy_fpregs_to_sigframe(struct xregs_state __user *buf)
 	else
 		err = copy_fregs_to_user((struct fregs_state __user *) buf);
 
-	if (unlikely(err) && __clear_user(buf, get_xstate_config(XSTATE_USER_SIZE)))
+	if (unlikely(err) && __clear_user(buf, current_sigxstatesz()))
 		err = -EFAULT;
 	return err;
 }
@@ -196,7 +232,7 @@ int copy_fpstate_to_sigframe(void __user *buf, void __user *buf_fx, int size)
 	fpregs_unlock();
 
 	if (ret) {
-		if (!fault_in_pages_writeable(buf_fx, get_xstate_config(XSTATE_USER_SIZE)))
+		if (!fault_in_pages_writeable(buf_fx, current_sigxstatesz()))
 			goto retry;
 		return -EFAULT;
 	}
@@ -326,7 +362,7 @@ static int __fpu__restore_sig(void __user *buf, void __user *buf_fx, int size)
 		}
 	} else {
 		/* The buffer cannot be dynamic without using XSAVE. */
-		state_size = get_xstate_config(XSTATE_MIN_SIZE);
+		state_size = get_xstate_config(XSTATE_USER_MINSIG_SIZE);
 	}
 
 	if ((unsigned long)buf_fx % 64)
@@ -476,20 +512,13 @@ static int __fpu__restore_sig(void __user *buf, void __user *buf_fx, int size)
 	return ret;
 }
 
-static inline int xstate_sigframe_size(void)
-{
-	int size = get_xstate_config(XSTATE_USER_SIZE);
-
-	return use_xsave() ? size + FP_XSTATE_MAGIC2_SIZE : size;
-}
-
 /*
  * Restore FPU state from a sigframe:
  */
 int fpu__restore_sig(void __user *buf, int ia32_frame)
 {
+	int size = extend_sigxstatesz(current_sigxstatesz());
 	void __user *buf_fx = buf;
-	int size = xstate_sigframe_size();
 
 	if (ia32_frame && use_fxsr()) {
 		buf_fx = buf + sizeof(struct fregs_state);
@@ -503,7 +532,7 @@ unsigned long
 fpu__alloc_mathframe(unsigned long sp, int ia32_frame,
 		     unsigned long *buf_fx, unsigned long *size)
 {
-	unsigned long frame_size = xstate_sigframe_size();
+	unsigned long frame_size = extend_sigxstatesz(current_sigxstatesz());
 
 	*buf_fx = sp = round_down(sp - frame_size, 64);
 	if (ia32_frame && use_fxsr()) {
@@ -516,9 +545,14 @@ fpu__alloc_mathframe(unsigned long sp, int ia32_frame,
 	return sp;
 }
 
+/**
+ * fpu__get_fpstate_size() - calculate the fpstate size reserved for signal frame.
+ *
+ * Returns:	The maximum possible fpstate size.
+ */
 unsigned long fpu__get_fpstate_size(void)
 {
-	unsigned long ret = xstate_sigframe_size();
+	unsigned long ret = extend_sigxstatesz(get_xstate_config(XSTATE_USER_SIZE));
 
 	/*
 	 * This space is needed on (most) 32-bit kernels, or when a 32-bit
@@ -543,12 +577,12 @@ unsigned long fpu__get_fpstate_size(void)
  */
 void fpu__init_prepare_fx_sw_frame(void)
 {
-	int xstate_size = get_xstate_config(XSTATE_USER_SIZE);
+	int xstate_size = get_xstate_config(XSTATE_USER_MINSIG_SIZE);
 	int ext_size = xstate_size + FP_XSTATE_MAGIC2_SIZE;
 
 	fx_sw_reserved.magic1 = FP_XSTATE_MAGIC1;
 	fx_sw_reserved.extended_size = ext_size;
-	fx_sw_reserved.xfeatures = xfeatures_mask_user();
+	fx_sw_reserved.xfeatures = xfeatures_mask_user() & ~(xfeatures_mask_user_dynamic);
 	fx_sw_reserved.xstate_size = xstate_size;
 
 	if (IS_ENABLED(CONFIG_IA32_EMULATION) ||
diff --git a/arch/x86/kernel/fpu/xstate.c b/arch/x86/kernel/fpu/xstate.c
index 693c478c1d86..c77da3466ab8 100644
--- a/arch/x86/kernel/fpu/xstate.c
+++ b/arch/x86/kernel/fpu/xstate.c
@@ -94,11 +94,14 @@ static bool xstate_aligns[XFEATURE_MAX] = { [ 0 ... XFEATURE_MAX - 1] = false};
  *				expanded to the max size.  The two sizes are the same when using the
  *				standard format.
  * @user_size:			The size of the userspace buffer. The buffer is always in the
- *				standard format. It is used for signal and ptrace frames.
+ *				standard format. It is used for signal (maximum size) and ptrace
+ *				frames.
+ * @user_minsig_size:		The minimum xstate buffer size for signal. This excludes large
+ *				states when they are located at the end in the format.
  */
 struct fpu_xstate_buffer_config {
 	unsigned int min_size, max_size;
-	unsigned int user_size;
+	unsigned int user_size, user_minsig_size;
 };
 
 static struct fpu_xstate_buffer_config buffer_config __read_mostly;
@@ -112,6 +115,8 @@ unsigned int get_xstate_config(enum xstate_config cfg)
 		return buffer_config.max_size;
 	case XSTATE_USER_SIZE:
 		return buffer_config.user_size;
+	case XSTATE_USER_MINSIG_SIZE:
+		return buffer_config.user_minsig_size;
 	default:
 		return 0;
 	}
@@ -129,6 +134,10 @@ void set_xstate_config(enum xstate_config cfg, unsigned int value)
 		break;
 	case XSTATE_USER_SIZE:
 		buffer_config.user_size = value;
+		break;
+	case XSTATE_USER_MINSIG_SIZE:
+		WARN_ON(value > SIGSTKSZ);
+		buffer_config.user_minsig_size = value;
 	}
 }
 
@@ -217,6 +226,27 @@ static unsigned int get_xstate_comp_offset(u64 mask, int feature_nr)
 	return offset;
 }
 
+/**
+ * get_user_xstate_size() - calculated an uncompacted XSAVE buffer size
+ *
+ * Filter out supervisor states from @mask.
+ *
+ * @mask:	This bitmap tells which components reserved in the buffer.
+ * Returns:	The buffer size
+ */
+unsigned int get_user_xstate_size(u64 mask)
+{
+	int nr;
+
+	mask &= xfeatures_mask_user();
+	if (!mask)
+		return 0;
+
+	nr = fls64(mask) - 1;
+
+	return xstate_offsets[nr] + xstate_sizes[nr];
+}
+
 /**
  * get_xstate_size() - calculate an xstate buffer size
  * @mask:	This bitmap tells which components reserved in the buffer.
@@ -974,6 +1004,18 @@ static int __init init_xstate_size(void)
 	 * User space is always in standard format.
 	 */
 	set_xstate_config(XSTATE_USER_SIZE, xsave_size);
+
+	/* The minimum signal xstate size excludes dynamic user states: */
+	if (xfeatures_mask_user_dynamic) {
+		int nr = fls64(xfeatures_mask_user() & ~(xfeatures_mask_user_dynamic)) - 1;
+		unsigned int size, offset, ecx, edx;
+
+		cpuid_count(XSTATE_CPUID, nr, &size, &offset, &ecx, &edx);
+		set_xstate_config(XSTATE_USER_MINSIG_SIZE, offset + size);
+	} else {
+		set_xstate_config(XSTATE_USER_MINSIG_SIZE, xsave_size);
+	}
+
 	return 0;
 }
 
-- 
2.27.0

