From 8e9a55cc3da70b328e8b0f52775f21d129c5e964 Mon Sep 17 00:00:00 2001
From: Jani Nikula <jani.nikula@intel.com>
Date: Wed, 17 Mar 2021 18:36:40 +0200
Subject: [PATCH 0924/2740] drm/i915/bios: mass convert dev_priv to i915
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Time to just yank out the bandage. No functional changes.

v2: Rebased

Cc: Lucas De Marchi <lucas.demarchi@intel.com>
Cc: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
Reviewed-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com> # v1
Signed-off-by: Jani Nikula <jani.nikula@intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/93fe9e8be2e6120b085d09e49aafdf52f5ccd725.1615998927.git.jani.nikula@intel.com
---
 drivers/gpu/drm/i915/display/intel_bios.c | 766 +++++++++++-----------
 1 file changed, 383 insertions(+), 383 deletions(-)

diff --git a/drivers/gpu/drm/i915/display/intel_bios.c b/drivers/gpu/drm/i915/display/intel_bios.c
index f3fa1441ce16..6e4650a7c604 100644
--- a/drivers/gpu/drm/i915/display/intel_bios.c
+++ b/drivers/gpu/drm/i915/display/intel_bios.c
@@ -211,7 +211,7 @@ get_lvds_fp_timing(const struct bdb_header *bdb,
 
 /* Parse general panel options */
 static void
-parse_panel_options(struct drm_i915_private *dev_priv,
+parse_panel_options(struct drm_i915_private *i915,
 		    const struct bdb_header *bdb)
 {
 	const struct bdb_lvds_options *lvds_options;
@@ -223,27 +223,27 @@ parse_panel_options(struct drm_i915_private *dev_priv,
 	if (!lvds_options)
 		return;
 
-	dev_priv->vbt.lvds_dither = lvds_options->pixel_dither;
+	i915->vbt.lvds_dither = lvds_options->pixel_dither;
 
-	ret = intel_opregion_get_panel_type(dev_priv);
+	ret = intel_opregion_get_panel_type(i915);
 	if (ret >= 0) {
-		drm_WARN_ON(&dev_priv->drm, ret > 0xf);
+		drm_WARN_ON(&i915->drm, ret > 0xf);
 		panel_type = ret;
-		drm_dbg_kms(&dev_priv->drm, "Panel type: %d (OpRegion)\n",
+		drm_dbg_kms(&i915->drm, "Panel type: %d (OpRegion)\n",
 			    panel_type);
 	} else {
 		if (lvds_options->panel_type > 0xf) {
-			drm_dbg_kms(&dev_priv->drm,
+			drm_dbg_kms(&i915->drm,
 				    "Invalid VBT panel type 0x%x\n",
 				    lvds_options->panel_type);
 			return;
 		}
 		panel_type = lvds_options->panel_type;
-		drm_dbg_kms(&dev_priv->drm, "Panel type: %d (VBT)\n",
+		drm_dbg_kms(&i915->drm, "Panel type: %d (VBT)\n",
 			    panel_type);
 	}
 
-	dev_priv->vbt.panel_type = panel_type;
+	i915->vbt.panel_type = panel_type;
 
 	drrs_mode = (lvds_options->dps_panel_type_bits
 				>> (panel_type * 2)) & MODE_MASK;
@@ -254,17 +254,17 @@ parse_panel_options(struct drm_i915_private *dev_priv,
 	 */
 	switch (drrs_mode) {
 	case 0:
-		dev_priv->vbt.drrs_type = STATIC_DRRS_SUPPORT;
-		drm_dbg_kms(&dev_priv->drm, "DRRS supported mode is static\n");
+		i915->vbt.drrs_type = STATIC_DRRS_SUPPORT;
+		drm_dbg_kms(&i915->drm, "DRRS supported mode is static\n");
 		break;
 	case 2:
-		dev_priv->vbt.drrs_type = SEAMLESS_DRRS_SUPPORT;
-		drm_dbg_kms(&dev_priv->drm,
+		i915->vbt.drrs_type = SEAMLESS_DRRS_SUPPORT;
+		drm_dbg_kms(&i915->drm,
 			    "DRRS supported mode is seamless\n");
 		break;
 	default:
-		dev_priv->vbt.drrs_type = DRRS_NOT_SUPPORTED;
-		drm_dbg_kms(&dev_priv->drm,
+		i915->vbt.drrs_type = DRRS_NOT_SUPPORTED;
+		drm_dbg_kms(&i915->drm,
 			    "DRRS not supported (VBT input)\n");
 		break;
 	}
@@ -272,7 +272,7 @@ parse_panel_options(struct drm_i915_private *dev_priv,
 
 /* Try to find integrated panel timing data */
 static void
-parse_lfp_panel_dtd(struct drm_i915_private *dev_priv,
+parse_lfp_panel_dtd(struct drm_i915_private *i915,
 		    const struct bdb_header *bdb)
 {
 	const struct bdb_lvds_lfp_data *lvds_lfp_data;
@@ -280,7 +280,7 @@ parse_lfp_panel_dtd(struct drm_i915_private *dev_priv,
 	const struct lvds_dvo_timing *panel_dvo_timing;
 	const struct lvds_fp_timing *fp_timing;
 	struct drm_display_mode *panel_fixed_mode;
-	int panel_type = dev_priv->vbt.panel_type;
+	int panel_type = i915->vbt.panel_type;
 
 	lvds_lfp_data = find_section(bdb, BDB_LVDS_LFP_DATA);
 	if (!lvds_lfp_data)
@@ -300,9 +300,9 @@ parse_lfp_panel_dtd(struct drm_i915_private *dev_priv,
 
 	fill_detail_timing_data(panel_fixed_mode, panel_dvo_timing);
 
-	dev_priv->vbt.lfp_lvds_vbt_mode = panel_fixed_mode;
+	i915->vbt.lfp_lvds_vbt_mode = panel_fixed_mode;
 
-	drm_dbg_kms(&dev_priv->drm,
+	drm_dbg_kms(&i915->drm,
 		    "Found panel mode in BIOS VBT legacy lfp table:\n");
 	drm_mode_debug_printmodeline(panel_fixed_mode);
 
@@ -313,16 +313,16 @@ parse_lfp_panel_dtd(struct drm_i915_private *dev_priv,
 		/* check the resolution, just to be sure */
 		if (fp_timing->x_res == panel_fixed_mode->hdisplay &&
 		    fp_timing->y_res == panel_fixed_mode->vdisplay) {
-			dev_priv->vbt.bios_lvds_val = fp_timing->lvds_reg_val;
-			drm_dbg_kms(&dev_priv->drm,
+			i915->vbt.bios_lvds_val = fp_timing->lvds_reg_val;
+			drm_dbg_kms(&i915->drm,
 				    "VBT initial LVDS value %x\n",
-				    dev_priv->vbt.bios_lvds_val);
+				    i915->vbt.bios_lvds_val);
 		}
 	}
 }
 
 static void
-parse_generic_dtd(struct drm_i915_private *dev_priv,
+parse_generic_dtd(struct drm_i915_private *i915,
 		  const struct bdb_header *bdb)
 {
 	const struct bdb_generic_dtd *generic_dtd;
@@ -335,26 +335,26 @@ parse_generic_dtd(struct drm_i915_private *dev_priv,
 		return;
 
 	if (generic_dtd->gdtd_size < sizeof(struct generic_dtd_entry)) {
-		drm_err(&dev_priv->drm, "GDTD size %u is too small.\n",
+		drm_err(&i915->drm, "GDTD size %u is too small.\n",
 			generic_dtd->gdtd_size);
 		return;
 	} else if (generic_dtd->gdtd_size !=
 		   sizeof(struct generic_dtd_entry)) {
-		drm_err(&dev_priv->drm, "Unexpected GDTD size %u\n",
+		drm_err(&i915->drm, "Unexpected GDTD size %u\n",
 			generic_dtd->gdtd_size);
 		/* DTD has unknown fields, but keep going */
 	}
 
 	num_dtd = (get_blocksize(generic_dtd) -
 		   sizeof(struct bdb_generic_dtd)) / generic_dtd->gdtd_size;
-	if (dev_priv->vbt.panel_type >= num_dtd) {
-		drm_err(&dev_priv->drm,
+	if (i915->vbt.panel_type >= num_dtd) {
+		drm_err(&i915->drm,
 			"Panel type %d not found in table of %d DTD's\n",
-			dev_priv->vbt.panel_type, num_dtd);
+			i915->vbt.panel_type, num_dtd);
 		return;
 	}
 
-	dtd = &generic_dtd->dtd[dev_priv->vbt.panel_type];
+	dtd = &generic_dtd->dtd[i915->vbt.panel_type];
 
 	panel_fixed_mode = kzalloc(sizeof(*panel_fixed_mode), GFP_KERNEL);
 	if (!panel_fixed_mode)
@@ -393,15 +393,15 @@ parse_generic_dtd(struct drm_i915_private *dev_priv,
 	else
 		panel_fixed_mode->flags |= DRM_MODE_FLAG_NVSYNC;
 
-	drm_dbg_kms(&dev_priv->drm,
+	drm_dbg_kms(&i915->drm,
 		    "Found panel mode in BIOS VBT generic dtd table:\n");
 	drm_mode_debug_printmodeline(panel_fixed_mode);
 
-	dev_priv->vbt.lfp_lvds_vbt_mode = panel_fixed_mode;
+	i915->vbt.lfp_lvds_vbt_mode = panel_fixed_mode;
 }
 
 static void
-parse_panel_dtd(struct drm_i915_private *dev_priv,
+parse_panel_dtd(struct drm_i915_private *i915,
 		const struct bdb_header *bdb)
 {
 	/*
@@ -413,18 +413,18 @@ parse_panel_dtd(struct drm_i915_private *dev_priv,
 	 * back to trying the old LFP block if that fails.
 	 */
 	if (bdb->version >= 229)
-		parse_generic_dtd(dev_priv, bdb);
-	if (!dev_priv->vbt.lfp_lvds_vbt_mode)
-		parse_lfp_panel_dtd(dev_priv, bdb);
+		parse_generic_dtd(i915, bdb);
+	if (!i915->vbt.lfp_lvds_vbt_mode)
+		parse_lfp_panel_dtd(i915, bdb);
 }
 
 static void
-parse_lfp_backlight(struct drm_i915_private *dev_priv,
+parse_lfp_backlight(struct drm_i915_private *i915,
 		    const struct bdb_header *bdb)
 {
 	const struct bdb_lfp_backlight_data *backlight_data;
 	const struct lfp_backlight_data_entry *entry;
-	int panel_type = dev_priv->vbt.panel_type;
+	int panel_type = i915->vbt.panel_type;
 	u16 level;
 
 	backlight_data = find_section(bdb, BDB_LVDS_BACKLIGHT);
@@ -432,7 +432,7 @@ parse_lfp_backlight(struct drm_i915_private *dev_priv,
 		return;
 
 	if (backlight_data->entry_size != sizeof(backlight_data->data[0])) {
-		drm_dbg_kms(&dev_priv->drm,
+		drm_dbg_kms(&i915->drm,
 			    "Unsupported backlight data entry size %u\n",
 			    backlight_data->entry_size);
 		return;
@@ -440,26 +440,26 @@ parse_lfp_backlight(struct drm_i915_private *dev_priv,
 
 	entry = &backlight_data->data[panel_type];
 
-	dev_priv->vbt.backlight.present = entry->type == BDB_BACKLIGHT_TYPE_PWM;
-	if (!dev_priv->vbt.backlight.present) {
-		drm_dbg_kms(&dev_priv->drm,
+	i915->vbt.backlight.present = entry->type == BDB_BACKLIGHT_TYPE_PWM;
+	if (!i915->vbt.backlight.present) {
+		drm_dbg_kms(&i915->drm,
 			    "PWM backlight not present in VBT (type %u)\n",
 			    entry->type);
 		return;
 	}
 
-	dev_priv->vbt.backlight.type = INTEL_BACKLIGHT_DISPLAY_DDI;
+	i915->vbt.backlight.type = INTEL_BACKLIGHT_DISPLAY_DDI;
 	if (bdb->version >= 191 &&
 	    get_blocksize(backlight_data) >= sizeof(*backlight_data)) {
 		const struct lfp_backlight_control_method *method;
 
 		method = &backlight_data->backlight_control[panel_type];
-		dev_priv->vbt.backlight.type = method->type;
-		dev_priv->vbt.backlight.controller = method->controller;
+		i915->vbt.backlight.type = method->type;
+		i915->vbt.backlight.controller = method->controller;
 	}
 
-	dev_priv->vbt.backlight.pwm_freq_hz = entry->pwm_freq_hz;
-	dev_priv->vbt.backlight.active_low_pwm = entry->active_low_pwm;
+	i915->vbt.backlight.pwm_freq_hz = entry->pwm_freq_hz;
+	i915->vbt.backlight.active_low_pwm = entry->active_low_pwm;
 
 	if (bdb->version >= 234) {
 		u16 min_level;
@@ -477,37 +477,37 @@ parse_lfp_backlight(struct drm_i915_private *dev_priv,
 			min_level = min_level / 255;
 
 		if (min_level > 255) {
-			drm_warn(&dev_priv->drm, "Brightness min level > 255\n");
+			drm_warn(&i915->drm, "Brightness min level > 255\n");
 			level = 255;
 		}
-		dev_priv->vbt.backlight.min_brightness = min_level;
+		i915->vbt.backlight.min_brightness = min_level;
 	} else {
 		level = backlight_data->level[panel_type];
-		dev_priv->vbt.backlight.min_brightness = entry->min_brightness;
+		i915->vbt.backlight.min_brightness = entry->min_brightness;
 	}
 
-	drm_dbg_kms(&dev_priv->drm,
+	drm_dbg_kms(&i915->drm,
 		    "VBT backlight PWM modulation frequency %u Hz, "
 		    "active %s, min brightness %u, level %u, controller %u\n",
-		    dev_priv->vbt.backlight.pwm_freq_hz,
-		    dev_priv->vbt.backlight.active_low_pwm ? "low" : "high",
-		    dev_priv->vbt.backlight.min_brightness,
+		    i915->vbt.backlight.pwm_freq_hz,
+		    i915->vbt.backlight.active_low_pwm ? "low" : "high",
+		    i915->vbt.backlight.min_brightness,
 		    level,
-		    dev_priv->vbt.backlight.controller);
+		    i915->vbt.backlight.controller);
 }
 
 /* Try to find sdvo panel data */
 static void
-parse_sdvo_panel_data(struct drm_i915_private *dev_priv,
+parse_sdvo_panel_data(struct drm_i915_private *i915,
 		      const struct bdb_header *bdb)
 {
 	const struct bdb_sdvo_panel_dtds *dtds;
 	struct drm_display_mode *panel_fixed_mode;
 	int index;
 
-	index = dev_priv->params.vbt_sdvo_panel_type;
+	index = i915->params.vbt_sdvo_panel_type;
 	if (index == -2) {
-		drm_dbg_kms(&dev_priv->drm,
+		drm_dbg_kms(&i915->drm,
 			    "Ignore SDVO panel mode from BIOS VBT tables.\n");
 		return;
 	}
@@ -532,17 +532,17 @@ parse_sdvo_panel_data(struct drm_i915_private *dev_priv,
 
 	fill_detail_timing_data(panel_fixed_mode, &dtds->dtds[index]);
 
-	dev_priv->vbt.sdvo_lvds_vbt_mode = panel_fixed_mode;
+	i915->vbt.sdvo_lvds_vbt_mode = panel_fixed_mode;
 
-	drm_dbg_kms(&dev_priv->drm,
+	drm_dbg_kms(&i915->drm,
 		    "Found SDVO panel mode in BIOS VBT tables:\n");
 	drm_mode_debug_printmodeline(panel_fixed_mode);
 }
 
-static int intel_bios_ssc_frequency(struct drm_i915_private *dev_priv,
+static int intel_bios_ssc_frequency(struct drm_i915_private *i915,
 				    bool alternate)
 {
-	switch (INTEL_GEN(dev_priv)) {
+	switch (INTEL_GEN(i915)) {
 	case 2:
 		return alternate ? 66667 : 48000;
 	case 3:
@@ -554,7 +554,7 @@ static int intel_bios_ssc_frequency(struct drm_i915_private *dev_priv,
 }
 
 static void
-parse_general_features(struct drm_i915_private *dev_priv,
+parse_general_features(struct drm_i915_private *i915,
 		       const struct bdb_header *bdb)
 {
 	const struct bdb_general_features *general;
@@ -563,31 +563,31 @@ parse_general_features(struct drm_i915_private *dev_priv,
 	if (!general)
 		return;
 
-	dev_priv->vbt.int_tv_support = general->int_tv_support;
+	i915->vbt.int_tv_support = general->int_tv_support;
 	/* int_crt_support can't be trusted on earlier platforms */
 	if (bdb->version >= 155 &&
-	    (HAS_DDI(dev_priv) || IS_VALLEYVIEW(dev_priv)))
-		dev_priv->vbt.int_crt_support = general->int_crt_support;
-	dev_priv->vbt.lvds_use_ssc = general->enable_ssc;
-	dev_priv->vbt.lvds_ssc_freq =
-		intel_bios_ssc_frequency(dev_priv, general->ssc_freq);
-	dev_priv->vbt.display_clock_mode = general->display_clock_mode;
-	dev_priv->vbt.fdi_rx_polarity_inverted = general->fdi_rx_polarity_inverted;
+	    (HAS_DDI(i915) || IS_VALLEYVIEW(i915)))
+		i915->vbt.int_crt_support = general->int_crt_support;
+	i915->vbt.lvds_use_ssc = general->enable_ssc;
+	i915->vbt.lvds_ssc_freq =
+		intel_bios_ssc_frequency(i915, general->ssc_freq);
+	i915->vbt.display_clock_mode = general->display_clock_mode;
+	i915->vbt.fdi_rx_polarity_inverted = general->fdi_rx_polarity_inverted;
 	if (bdb->version >= 181) {
-		dev_priv->vbt.orientation = general->rotate_180 ?
+		i915->vbt.orientation = general->rotate_180 ?
 			DRM_MODE_PANEL_ORIENTATION_BOTTOM_UP :
 			DRM_MODE_PANEL_ORIENTATION_NORMAL;
 	} else {
-		dev_priv->vbt.orientation = DRM_MODE_PANEL_ORIENTATION_UNKNOWN;
+		i915->vbt.orientation = DRM_MODE_PANEL_ORIENTATION_UNKNOWN;
 	}
-	drm_dbg_kms(&dev_priv->drm,
+	drm_dbg_kms(&i915->drm,
 		    "BDB_GENERAL_FEATURES int_tv_support %d int_crt_support %d lvds_use_ssc %d lvds_ssc_freq %d display_clock_mode %d fdi_rx_polarity_inverted %d\n",
-		    dev_priv->vbt.int_tv_support,
-		    dev_priv->vbt.int_crt_support,
-		    dev_priv->vbt.lvds_use_ssc,
-		    dev_priv->vbt.lvds_ssc_freq,
-		    dev_priv->vbt.display_clock_mode,
-		    dev_priv->vbt.fdi_rx_polarity_inverted);
+		    i915->vbt.int_tv_support,
+		    i915->vbt.int_crt_support,
+		    i915->vbt.lvds_use_ssc,
+		    i915->vbt.lvds_ssc_freq,
+		    i915->vbt.display_clock_mode,
+		    i915->vbt.fdi_rx_polarity_inverted);
 }
 
 static const struct child_device_config *
@@ -597,7 +597,7 @@ child_device_ptr(const struct bdb_general_definitions *defs, int i)
 }
 
 static void
-parse_sdvo_device_mapping(struct drm_i915_private *dev_priv, u8 bdb_version)
+parse_sdvo_device_mapping(struct drm_i915_private *i915, u8 bdb_version)
 {
 	struct sdvo_device_mapping *mapping;
 	const struct display_device_data *devdata;
@@ -608,12 +608,12 @@ parse_sdvo_device_mapping(struct drm_i915_private *dev_priv, u8 bdb_version)
 	 * Only parse SDVO mappings on gens that could have SDVO. This isn't
 	 * accurate and doesn't have to be, as long as it's not too strict.
 	 */
-	if (!IS_GEN_RANGE(dev_priv, 3, 7)) {
-		drm_dbg_kms(&dev_priv->drm, "Skipping SDVO device mapping\n");
+	if (!IS_GEN_RANGE(i915, 3, 7)) {
+		drm_dbg_kms(&i915->drm, "Skipping SDVO device mapping\n");
 		return;
 	}
 
-	list_for_each_entry(devdata, &dev_priv->vbt.display_devices, node) {
+	list_for_each_entry(devdata, &i915->vbt.display_devices, node) {
 		child = &devdata->child;
 
 		if (child->slave_addr != SLAVE_ADDR1 &&
@@ -627,17 +627,17 @@ parse_sdvo_device_mapping(struct drm_i915_private *dev_priv, u8 bdb_version)
 		if (child->dvo_port != DEVICE_PORT_DVOB &&
 		    child->dvo_port != DEVICE_PORT_DVOC) {
 			/* skip the incorrect SDVO port */
-			drm_dbg_kms(&dev_priv->drm,
+			drm_dbg_kms(&i915->drm,
 				    "Incorrect SDVO port. Skip it\n");
 			continue;
 		}
-		drm_dbg_kms(&dev_priv->drm,
+		drm_dbg_kms(&i915->drm,
 			    "the SDVO device with slave addr %2x is found on"
 			    " %s port\n",
 			    child->slave_addr,
 			    (child->dvo_port == DEVICE_PORT_DVOB) ?
 			    "SDVOB" : "SDVOC");
-		mapping = &dev_priv->vbt.sdvo_mappings[child->dvo_port - 1];
+		mapping = &i915->vbt.sdvo_mappings[child->dvo_port - 1];
 		if (!mapping->initialized) {
 			mapping->dvo_port = child->dvo_port;
 			mapping->slave_addr = child->slave_addr;
@@ -645,20 +645,20 @@ parse_sdvo_device_mapping(struct drm_i915_private *dev_priv, u8 bdb_version)
 			mapping->ddc_pin = child->ddc_pin;
 			mapping->i2c_pin = child->i2c_pin;
 			mapping->initialized = 1;
-			drm_dbg_kms(&dev_priv->drm,
+			drm_dbg_kms(&i915->drm,
 				    "SDVO device: dvo=%x, addr=%x, wiring=%d, ddc_pin=%d, i2c_pin=%d\n",
 				    mapping->dvo_port, mapping->slave_addr,
 				    mapping->dvo_wiring, mapping->ddc_pin,
 				    mapping->i2c_pin);
 		} else {
-			drm_dbg_kms(&dev_priv->drm,
+			drm_dbg_kms(&i915->drm,
 				    "Maybe one SDVO port is shared by "
 				    "two SDVO device.\n");
 		}
 		if (child->slave2_addr) {
 			/* Maybe this is a SDVO device with multiple inputs */
 			/* And the mapping info is not added */
-			drm_dbg_kms(&dev_priv->drm,
+			drm_dbg_kms(&i915->drm,
 				    "there exists the slave2_addr. Maybe this"
 				    " is a SDVO device with multiple inputs.\n");
 		}
@@ -667,13 +667,13 @@ parse_sdvo_device_mapping(struct drm_i915_private *dev_priv, u8 bdb_version)
 
 	if (!count) {
 		/* No SDVO device info is found */
-		drm_dbg_kms(&dev_priv->drm,
+		drm_dbg_kms(&i915->drm,
 			    "No SDVO device info is found in VBT\n");
 	}
 }
 
 static void
-parse_driver_features(struct drm_i915_private *dev_priv,
+parse_driver_features(struct drm_i915_private *i915,
 		      const struct bdb_header *bdb)
 {
 	const struct bdb_driver_features *driver;
@@ -682,14 +682,14 @@ parse_driver_features(struct drm_i915_private *dev_priv,
 	if (!driver)
 		return;
 
-	if (INTEL_GEN(dev_priv) >= 5) {
+	if (INTEL_GEN(i915) >= 5) {
 		/*
 		 * Note that we consider BDB_DRIVER_FEATURE_INT_SDVO_LVDS
 		 * to mean "eDP". The VBT spec doesn't agree with that
 		 * interpretation, but real world VBTs seem to.
 		 */
 		if (driver->lvds_config != BDB_DRIVER_FEATURE_INT_LVDS)
-			dev_priv->vbt.int_lvds_support = 0;
+			i915->vbt.int_lvds_support = 0;
 	} else {
 		/*
 		 * FIXME it's not clear which BDB version has the LVDS config
@@ -705,11 +705,11 @@ parse_driver_features(struct drm_i915_private *dev_priv,
 		if (bdb->version >= 134 &&
 		    driver->lvds_config != BDB_DRIVER_FEATURE_INT_LVDS &&
 		    driver->lvds_config != BDB_DRIVER_FEATURE_INT_SDVO_LVDS)
-			dev_priv->vbt.int_lvds_support = 0;
+			i915->vbt.int_lvds_support = 0;
 	}
 
 	if (bdb->version < 228) {
-		drm_dbg_kms(&dev_priv->drm, "DRRS State Enabled:%d\n",
+		drm_dbg_kms(&i915->drm, "DRRS State Enabled:%d\n",
 			    driver->drrs_enabled);
 		/*
 		 * If DRRS is not supported, drrs_type has to be set to 0.
@@ -718,18 +718,18 @@ parse_driver_features(struct drm_i915_private *dev_priv,
 		 * driver->drrs_enabled=false
 		 */
 		if (!driver->drrs_enabled)
-			dev_priv->vbt.drrs_type = DRRS_NOT_SUPPORTED;
+			i915->vbt.drrs_type = DRRS_NOT_SUPPORTED;
 
-		dev_priv->vbt.psr.enable = driver->psr_enabled;
+		i915->vbt.psr.enable = driver->psr_enabled;
 	}
 }
 
 static void
-parse_power_conservation_features(struct drm_i915_private *dev_priv,
+parse_power_conservation_features(struct drm_i915_private *i915,
 				  const struct bdb_header *bdb)
 {
 	const struct bdb_lfp_power *power;
-	u8 panel_type = dev_priv->vbt.panel_type;
+	u8 panel_type = i915->vbt.panel_type;
 
 	if (bdb->version < 228)
 		return;
@@ -738,7 +738,7 @@ parse_power_conservation_features(struct drm_i915_private *dev_priv,
 	if (!power)
 		return;
 
-	dev_priv->vbt.psr.enable = power->psr & BIT(panel_type);
+	i915->vbt.psr.enable = power->psr & BIT(panel_type);
 
 	/*
 	 * If DRRS is not supported, drrs_type has to be set to 0.
@@ -747,19 +747,19 @@ parse_power_conservation_features(struct drm_i915_private *dev_priv,
 	 * power->drrs & BIT(panel_type)=false
 	 */
 	if (!(power->drrs & BIT(panel_type)))
-		dev_priv->vbt.drrs_type = DRRS_NOT_SUPPORTED;
+		i915->vbt.drrs_type = DRRS_NOT_SUPPORTED;
 
 	if (bdb->version >= 232)
-		dev_priv->vbt.edp.hobl = power->hobl & BIT(panel_type);
+		i915->vbt.edp.hobl = power->hobl & BIT(panel_type);
 }
 
 static void
-parse_edp(struct drm_i915_private *dev_priv, const struct bdb_header *bdb)
+parse_edp(struct drm_i915_private *i915, const struct bdb_header *bdb)
 {
 	const struct bdb_edp *edp;
 	const struct edp_power_seq *edp_pps;
 	const struct edp_fast_link_params *edp_link_params;
-	int panel_type = dev_priv->vbt.panel_type;
+	int panel_type = i915->vbt.panel_type;
 
 	edp = find_section(bdb, BDB_EDP);
 	if (!edp)
@@ -767,13 +767,13 @@ parse_edp(struct drm_i915_private *dev_priv, const struct bdb_header *bdb)
 
 	switch ((edp->color_depth >> (panel_type * 2)) & 3) {
 	case EDP_18BPP:
-		dev_priv->vbt.edp.bpp = 18;
+		i915->vbt.edp.bpp = 18;
 		break;
 	case EDP_24BPP:
-		dev_priv->vbt.edp.bpp = 24;
+		i915->vbt.edp.bpp = 24;
 		break;
 	case EDP_30BPP:
-		dev_priv->vbt.edp.bpp = 30;
+		i915->vbt.edp.bpp = 30;
 		break;
 	}
 
@@ -781,17 +781,17 @@ parse_edp(struct drm_i915_private *dev_priv, const struct bdb_header *bdb)
 	edp_pps = &edp->power_seqs[panel_type];
 	edp_link_params = &edp->fast_link_params[panel_type];
 
-	dev_priv->vbt.edp.pps = *edp_pps;
+	i915->vbt.edp.pps = *edp_pps;
 
 	switch (edp_link_params->rate) {
 	case EDP_RATE_1_62:
-		dev_priv->vbt.edp.rate = DP_LINK_BW_1_62;
+		i915->vbt.edp.rate = DP_LINK_BW_1_62;
 		break;
 	case EDP_RATE_2_7:
-		dev_priv->vbt.edp.rate = DP_LINK_BW_2_7;
+		i915->vbt.edp.rate = DP_LINK_BW_2_7;
 		break;
 	default:
-		drm_dbg_kms(&dev_priv->drm,
+		drm_dbg_kms(&i915->drm,
 			    "VBT has unknown eDP link rate value %u\n",
 			     edp_link_params->rate);
 		break;
@@ -799,16 +799,16 @@ parse_edp(struct drm_i915_private *dev_priv, const struct bdb_header *bdb)
 
 	switch (edp_link_params->lanes) {
 	case EDP_LANE_1:
-		dev_priv->vbt.edp.lanes = 1;
+		i915->vbt.edp.lanes = 1;
 		break;
 	case EDP_LANE_2:
-		dev_priv->vbt.edp.lanes = 2;
+		i915->vbt.edp.lanes = 2;
 		break;
 	case EDP_LANE_4:
-		dev_priv->vbt.edp.lanes = 4;
+		i915->vbt.edp.lanes = 4;
 		break;
 	default:
-		drm_dbg_kms(&dev_priv->drm,
+		drm_dbg_kms(&i915->drm,
 			    "VBT has unknown eDP lane count value %u\n",
 			    edp_link_params->lanes);
 		break;
@@ -816,19 +816,19 @@ parse_edp(struct drm_i915_private *dev_priv, const struct bdb_header *bdb)
 
 	switch (edp_link_params->preemphasis) {
 	case EDP_PREEMPHASIS_NONE:
-		dev_priv->vbt.edp.preemphasis = DP_TRAIN_PRE_EMPH_LEVEL_0;
+		i915->vbt.edp.preemphasis = DP_TRAIN_PRE_EMPH_LEVEL_0;
 		break;
 	case EDP_PREEMPHASIS_3_5dB:
-		dev_priv->vbt.edp.preemphasis = DP_TRAIN_PRE_EMPH_LEVEL_1;
+		i915->vbt.edp.preemphasis = DP_TRAIN_PRE_EMPH_LEVEL_1;
 		break;
 	case EDP_PREEMPHASIS_6dB:
-		dev_priv->vbt.edp.preemphasis = DP_TRAIN_PRE_EMPH_LEVEL_2;
+		i915->vbt.edp.preemphasis = DP_TRAIN_PRE_EMPH_LEVEL_2;
 		break;
 	case EDP_PREEMPHASIS_9_5dB:
-		dev_priv->vbt.edp.preemphasis = DP_TRAIN_PRE_EMPH_LEVEL_3;
+		i915->vbt.edp.preemphasis = DP_TRAIN_PRE_EMPH_LEVEL_3;
 		break;
 	default:
-		drm_dbg_kms(&dev_priv->drm,
+		drm_dbg_kms(&i915->drm,
 			    "VBT has unknown eDP pre-emphasis value %u\n",
 			    edp_link_params->preemphasis);
 		break;
@@ -836,19 +836,19 @@ parse_edp(struct drm_i915_private *dev_priv, const struct bdb_header *bdb)
 
 	switch (edp_link_params->vswing) {
 	case EDP_VSWING_0_4V:
-		dev_priv->vbt.edp.vswing = DP_TRAIN_VOLTAGE_SWING_LEVEL_0;
+		i915->vbt.edp.vswing = DP_TRAIN_VOLTAGE_SWING_LEVEL_0;
 		break;
 	case EDP_VSWING_0_6V:
-		dev_priv->vbt.edp.vswing = DP_TRAIN_VOLTAGE_SWING_LEVEL_1;
+		i915->vbt.edp.vswing = DP_TRAIN_VOLTAGE_SWING_LEVEL_1;
 		break;
 	case EDP_VSWING_0_8V:
-		dev_priv->vbt.edp.vswing = DP_TRAIN_VOLTAGE_SWING_LEVEL_2;
+		i915->vbt.edp.vswing = DP_TRAIN_VOLTAGE_SWING_LEVEL_2;
 		break;
 	case EDP_VSWING_1_2V:
-		dev_priv->vbt.edp.vswing = DP_TRAIN_VOLTAGE_SWING_LEVEL_3;
+		i915->vbt.edp.vswing = DP_TRAIN_VOLTAGE_SWING_LEVEL_3;
 		break;
 	default:
-		drm_dbg_kms(&dev_priv->drm,
+		drm_dbg_kms(&i915->drm,
 			    "VBT has unknown eDP voltage swing value %u\n",
 			    edp_link_params->vswing);
 		break;
@@ -858,53 +858,53 @@ parse_edp(struct drm_i915_private *dev_priv, const struct bdb_header *bdb)
 		u8 vswing;
 
 		/* Don't read from VBT if module parameter has valid value*/
-		if (dev_priv->params.edp_vswing) {
-			dev_priv->vbt.edp.low_vswing =
-				dev_priv->params.edp_vswing == 1;
+		if (i915->params.edp_vswing) {
+			i915->vbt.edp.low_vswing =
+				i915->params.edp_vswing == 1;
 		} else {
 			vswing = (edp->edp_vswing_preemph >> (panel_type * 4)) & 0xF;
-			dev_priv->vbt.edp.low_vswing = vswing == 0;
+			i915->vbt.edp.low_vswing = vswing == 0;
 		}
 	}
 }
 
 static void
-parse_psr(struct drm_i915_private *dev_priv, const struct bdb_header *bdb)
+parse_psr(struct drm_i915_private *i915, const struct bdb_header *bdb)
 {
 	const struct bdb_psr *psr;
 	const struct psr_table *psr_table;
-	int panel_type = dev_priv->vbt.panel_type;
+	int panel_type = i915->vbt.panel_type;
 
 	psr = find_section(bdb, BDB_PSR);
 	if (!psr) {
-		drm_dbg_kms(&dev_priv->drm, "No PSR BDB found.\n");
+		drm_dbg_kms(&i915->drm, "No PSR BDB found.\n");
 		return;
 	}
 
 	psr_table = &psr->psr_table[panel_type];
 
-	dev_priv->vbt.psr.full_link = psr_table->full_link;
-	dev_priv->vbt.psr.require_aux_wakeup = psr_table->require_aux_to_wakeup;
+	i915->vbt.psr.full_link = psr_table->full_link;
+	i915->vbt.psr.require_aux_wakeup = psr_table->require_aux_to_wakeup;
 
 	/* Allowed VBT values goes from 0 to 15 */
-	dev_priv->vbt.psr.idle_frames = psr_table->idle_frames < 0 ? 0 :
+	i915->vbt.psr.idle_frames = psr_table->idle_frames < 0 ? 0 :
 		psr_table->idle_frames > 15 ? 15 : psr_table->idle_frames;
 
 	switch (psr_table->lines_to_wait) {
 	case 0:
-		dev_priv->vbt.psr.lines_to_wait = PSR_0_LINES_TO_WAIT;
+		i915->vbt.psr.lines_to_wait = PSR_0_LINES_TO_WAIT;
 		break;
 	case 1:
-		dev_priv->vbt.psr.lines_to_wait = PSR_1_LINE_TO_WAIT;
+		i915->vbt.psr.lines_to_wait = PSR_1_LINE_TO_WAIT;
 		break;
 	case 2:
-		dev_priv->vbt.psr.lines_to_wait = PSR_4_LINES_TO_WAIT;
+		i915->vbt.psr.lines_to_wait = PSR_4_LINES_TO_WAIT;
 		break;
 	case 3:
-		dev_priv->vbt.psr.lines_to_wait = PSR_8_LINES_TO_WAIT;
+		i915->vbt.psr.lines_to_wait = PSR_8_LINES_TO_WAIT;
 		break;
 	default:
-		drm_dbg_kms(&dev_priv->drm,
+		drm_dbg_kms(&i915->drm,
 			    "VBT has unknown PSR lines to wait %u\n",
 			    psr_table->lines_to_wait);
 		break;
@@ -915,50 +915,50 @@ parse_psr(struct drm_i915_private *dev_priv, const struct bdb_header *bdb)
 	 * Old decimal value is wake up time in multiples of 100 us.
 	 */
 	if (bdb->version >= 205 &&
-	    (IS_GEN9_BC(dev_priv) || IS_GEMINILAKE(dev_priv) ||
-	     INTEL_GEN(dev_priv) >= 10)) {
+	    (IS_GEN9_BC(i915) || IS_GEMINILAKE(i915) ||
+	     INTEL_GEN(i915) >= 10)) {
 		switch (psr_table->tp1_wakeup_time) {
 		case 0:
-			dev_priv->vbt.psr.tp1_wakeup_time_us = 500;
+			i915->vbt.psr.tp1_wakeup_time_us = 500;
 			break;
 		case 1:
-			dev_priv->vbt.psr.tp1_wakeup_time_us = 100;
+			i915->vbt.psr.tp1_wakeup_time_us = 100;
 			break;
 		case 3:
-			dev_priv->vbt.psr.tp1_wakeup_time_us = 0;
+			i915->vbt.psr.tp1_wakeup_time_us = 0;
 			break;
 		default:
-			drm_dbg_kms(&dev_priv->drm,
+			drm_dbg_kms(&i915->drm,
 				    "VBT tp1 wakeup time value %d is outside range[0-3], defaulting to max value 2500us\n",
 				    psr_table->tp1_wakeup_time);
 			fallthrough;
 		case 2:
-			dev_priv->vbt.psr.tp1_wakeup_time_us = 2500;
+			i915->vbt.psr.tp1_wakeup_time_us = 2500;
 			break;
 		}
 
 		switch (psr_table->tp2_tp3_wakeup_time) {
 		case 0:
-			dev_priv->vbt.psr.tp2_tp3_wakeup_time_us = 500;
+			i915->vbt.psr.tp2_tp3_wakeup_time_us = 500;
 			break;
 		case 1:
-			dev_priv->vbt.psr.tp2_tp3_wakeup_time_us = 100;
+			i915->vbt.psr.tp2_tp3_wakeup_time_us = 100;
 			break;
 		case 3:
-			dev_priv->vbt.psr.tp2_tp3_wakeup_time_us = 0;
+			i915->vbt.psr.tp2_tp3_wakeup_time_us = 0;
 			break;
 		default:
-			drm_dbg_kms(&dev_priv->drm,
+			drm_dbg_kms(&i915->drm,
 				    "VBT tp2_tp3 wakeup time value %d is outside range[0-3], defaulting to max value 2500us\n",
 				    psr_table->tp2_tp3_wakeup_time);
 			fallthrough;
 		case 2:
-			dev_priv->vbt.psr.tp2_tp3_wakeup_time_us = 2500;
+			i915->vbt.psr.tp2_tp3_wakeup_time_us = 2500;
 		break;
 		}
 	} else {
-		dev_priv->vbt.psr.tp1_wakeup_time_us = psr_table->tp1_wakeup_time * 100;
-		dev_priv->vbt.psr.tp2_tp3_wakeup_time_us = psr_table->tp2_tp3_wakeup_time * 100;
+		i915->vbt.psr.tp1_wakeup_time_us = psr_table->tp1_wakeup_time * 100;
+		i915->vbt.psr.tp2_tp3_wakeup_time_us = psr_table->tp2_tp3_wakeup_time * 100;
 	}
 
 	if (bdb->version >= 226) {
@@ -980,74 +980,74 @@ parse_psr(struct drm_i915_private *dev_priv, const struct bdb_header *bdb)
 			wakeup_time = 2500;
 			break;
 		}
-		dev_priv->vbt.psr.psr2_tp2_tp3_wakeup_time_us = wakeup_time;
+		i915->vbt.psr.psr2_tp2_tp3_wakeup_time_us = wakeup_time;
 	} else {
 		/* Reusing PSR1 wakeup time for PSR2 in older VBTs */
-		dev_priv->vbt.psr.psr2_tp2_tp3_wakeup_time_us = dev_priv->vbt.psr.tp2_tp3_wakeup_time_us;
+		i915->vbt.psr.psr2_tp2_tp3_wakeup_time_us = i915->vbt.psr.tp2_tp3_wakeup_time_us;
 	}
 }
 
-static void parse_dsi_backlight_ports(struct drm_i915_private *dev_priv,
+static void parse_dsi_backlight_ports(struct drm_i915_private *i915,
 				      u16 version, enum port port)
 {
-	if (!dev_priv->vbt.dsi.config->dual_link || version < 197) {
-		dev_priv->vbt.dsi.bl_ports = BIT(port);
-		if (dev_priv->vbt.dsi.config->cabc_supported)
-			dev_priv->vbt.dsi.cabc_ports = BIT(port);
+	if (!i915->vbt.dsi.config->dual_link || version < 197) {
+		i915->vbt.dsi.bl_ports = BIT(port);
+		if (i915->vbt.dsi.config->cabc_supported)
+			i915->vbt.dsi.cabc_ports = BIT(port);
 
 		return;
 	}
 
-	switch (dev_priv->vbt.dsi.config->dl_dcs_backlight_ports) {
+	switch (i915->vbt.dsi.config->dl_dcs_backlight_ports) {
 	case DL_DCS_PORT_A:
-		dev_priv->vbt.dsi.bl_ports = BIT(PORT_A);
+		i915->vbt.dsi.bl_ports = BIT(PORT_A);
 		break;
 	case DL_DCS_PORT_C:
-		dev_priv->vbt.dsi.bl_ports = BIT(PORT_C);
+		i915->vbt.dsi.bl_ports = BIT(PORT_C);
 		break;
 	default:
 	case DL_DCS_PORT_A_AND_C:
-		dev_priv->vbt.dsi.bl_ports = BIT(PORT_A) | BIT(PORT_C);
+		i915->vbt.dsi.bl_ports = BIT(PORT_A) | BIT(PORT_C);
 		break;
 	}
 
-	if (!dev_priv->vbt.dsi.config->cabc_supported)
+	if (!i915->vbt.dsi.config->cabc_supported)
 		return;
 
-	switch (dev_priv->vbt.dsi.config->dl_dcs_cabc_ports) {
+	switch (i915->vbt.dsi.config->dl_dcs_cabc_ports) {
 	case DL_DCS_PORT_A:
-		dev_priv->vbt.dsi.cabc_ports = BIT(PORT_A);
+		i915->vbt.dsi.cabc_ports = BIT(PORT_A);
 		break;
 	case DL_DCS_PORT_C:
-		dev_priv->vbt.dsi.cabc_ports = BIT(PORT_C);
+		i915->vbt.dsi.cabc_ports = BIT(PORT_C);
 		break;
 	default:
 	case DL_DCS_PORT_A_AND_C:
-		dev_priv->vbt.dsi.cabc_ports =
+		i915->vbt.dsi.cabc_ports =
 					BIT(PORT_A) | BIT(PORT_C);
 		break;
 	}
 }
 
 static void
-parse_mipi_config(struct drm_i915_private *dev_priv,
+parse_mipi_config(struct drm_i915_private *i915,
 		  const struct bdb_header *bdb)
 {
 	const struct bdb_mipi_config *start;
 	const struct mipi_config *config;
 	const struct mipi_pps_data *pps;
-	int panel_type = dev_priv->vbt.panel_type;
+	int panel_type = i915->vbt.panel_type;
 	enum port port;
 
 	/* parse MIPI blocks only if LFP type is MIPI */
-	if (!intel_bios_is_dsi_present(dev_priv, &port))
+	if (!intel_bios_is_dsi_present(i915, &port))
 		return;
 
 	/* Initialize this to undefined indicating no generic MIPI support */
-	dev_priv->vbt.dsi.panel_id = MIPI_DSI_UNDEFINED_PANEL_ID;
+	i915->vbt.dsi.panel_id = MIPI_DSI_UNDEFINED_PANEL_ID;
 
 	/* Block #40 is already parsed and panel_fixed_mode is
-	 * stored in dev_priv->lfp_lvds_vbt_mode
+	 * stored in i915->lfp_lvds_vbt_mode
 	 * resuse this when needed
 	 */
 
@@ -1056,11 +1056,11 @@ parse_mipi_config(struct drm_i915_private *dev_priv,
 	 */
 	start = find_section(bdb, BDB_MIPI_CONFIG);
 	if (!start) {
-		drm_dbg_kms(&dev_priv->drm, "No MIPI config BDB found");
+		drm_dbg_kms(&i915->drm, "No MIPI config BDB found");
 		return;
 	}
 
-	drm_dbg(&dev_priv->drm, "Found MIPI Config block, panel index = %d\n",
+	drm_dbg(&i915->drm, "Found MIPI Config block, panel index = %d\n",
 		panel_type);
 
 	/*
@@ -1071,17 +1071,17 @@ parse_mipi_config(struct drm_i915_private *dev_priv,
 	pps = &start->pps[panel_type];
 
 	/* store as of now full data. Trim when we realise all is not needed */
-	dev_priv->vbt.dsi.config = kmemdup(config, sizeof(struct mipi_config), GFP_KERNEL);
-	if (!dev_priv->vbt.dsi.config)
+	i915->vbt.dsi.config = kmemdup(config, sizeof(struct mipi_config), GFP_KERNEL);
+	if (!i915->vbt.dsi.config)
 		return;
 
-	dev_priv->vbt.dsi.pps = kmemdup(pps, sizeof(struct mipi_pps_data), GFP_KERNEL);
-	if (!dev_priv->vbt.dsi.pps) {
-		kfree(dev_priv->vbt.dsi.config);
+	i915->vbt.dsi.pps = kmemdup(pps, sizeof(struct mipi_pps_data), GFP_KERNEL);
+	if (!i915->vbt.dsi.pps) {
+		kfree(i915->vbt.dsi.config);
 		return;
 	}
 
-	parse_dsi_backlight_ports(dev_priv, bdb->version, port);
+	parse_dsi_backlight_ports(i915, bdb->version, port);
 
 	/* FIXME is the 90 vs. 270 correct? */
 	switch (config->rotation) {
@@ -1090,25 +1090,25 @@ parse_mipi_config(struct drm_i915_private *dev_priv,
 		 * Most (all?) VBTs claim 0 degrees despite having
 		 * an upside down panel, thus we do not trust this.
 		 */
-		dev_priv->vbt.dsi.orientation =
+		i915->vbt.dsi.orientation =
 			DRM_MODE_PANEL_ORIENTATION_UNKNOWN;
 		break;
 	case ENABLE_ROTATION_90:
-		dev_priv->vbt.dsi.orientation =
+		i915->vbt.dsi.orientation =
 			DRM_MODE_PANEL_ORIENTATION_RIGHT_UP;
 		break;
 	case ENABLE_ROTATION_180:
-		dev_priv->vbt.dsi.orientation =
+		i915->vbt.dsi.orientation =
 			DRM_MODE_PANEL_ORIENTATION_BOTTOM_UP;
 		break;
 	case ENABLE_ROTATION_270:
-		dev_priv->vbt.dsi.orientation =
+		i915->vbt.dsi.orientation =
 			DRM_MODE_PANEL_ORIENTATION_LEFT_UP;
 		break;
 	}
 
 	/* We have mandatory mipi config blocks. Initialize as generic panel */
-	dev_priv->vbt.dsi.panel_id = MIPI_DSI_GENERIC_PANEL_ID;
+	i915->vbt.dsi.panel_id = MIPI_DSI_GENERIC_PANEL_ID;
 }
 
 /* Find the sequence block and size for the given panel. */
@@ -1271,13 +1271,13 @@ static int goto_next_sequence_v3(const u8 *data, int index, int total)
  * Get len of pre-fixed deassert fragment from a v1 init OTP sequence,
  * skip all delay + gpio operands and stop at the first DSI packet op.
  */
-static int get_init_otp_deassert_fragment_len(struct drm_i915_private *dev_priv)
+static int get_init_otp_deassert_fragment_len(struct drm_i915_private *i915)
 {
-	const u8 *data = dev_priv->vbt.dsi.sequence[MIPI_SEQ_INIT_OTP];
+	const u8 *data = i915->vbt.dsi.sequence[MIPI_SEQ_INIT_OTP];
 	int index, len;
 
-	if (drm_WARN_ON(&dev_priv->drm,
-			!data || dev_priv->vbt.dsi.seq_version != 1))
+	if (drm_WARN_ON(&i915->drm,
+			!data || i915->vbt.dsi.seq_version != 1))
 		return 0;
 
 	/* index = 1 to skip sequence byte */
@@ -1305,55 +1305,55 @@ static int get_init_otp_deassert_fragment_len(struct drm_i915_private *dev_priv)
  * these devices we split the init OTP sequence into a deassert sequence and
  * the actual init OTP part.
  */
-static void fixup_mipi_sequences(struct drm_i915_private *dev_priv)
+static void fixup_mipi_sequences(struct drm_i915_private *i915)
 {
 	u8 *init_otp;
 	int len;
 
 	/* Limit this to VLV for now. */
-	if (!IS_VALLEYVIEW(dev_priv))
+	if (!IS_VALLEYVIEW(i915))
 		return;
 
 	/* Limit this to v1 vid-mode sequences */
-	if (dev_priv->vbt.dsi.config->is_cmd_mode ||
-	    dev_priv->vbt.dsi.seq_version != 1)
+	if (i915->vbt.dsi.config->is_cmd_mode ||
+	    i915->vbt.dsi.seq_version != 1)
 		return;
 
 	/* Only do this if there are otp and assert seqs and no deassert seq */
-	if (!dev_priv->vbt.dsi.sequence[MIPI_SEQ_INIT_OTP] ||
-	    !dev_priv->vbt.dsi.sequence[MIPI_SEQ_ASSERT_RESET] ||
-	    dev_priv->vbt.dsi.sequence[MIPI_SEQ_DEASSERT_RESET])
+	if (!i915->vbt.dsi.sequence[MIPI_SEQ_INIT_OTP] ||
+	    !i915->vbt.dsi.sequence[MIPI_SEQ_ASSERT_RESET] ||
+	    i915->vbt.dsi.sequence[MIPI_SEQ_DEASSERT_RESET])
 		return;
 
 	/* The deassert-sequence ends at the first DSI packet */
-	len = get_init_otp_deassert_fragment_len(dev_priv);
+	len = get_init_otp_deassert_fragment_len(i915);
 	if (!len)
 		return;
 
-	drm_dbg_kms(&dev_priv->drm,
+	drm_dbg_kms(&i915->drm,
 		    "Using init OTP fragment to deassert reset\n");
 
 	/* Copy the fragment, update seq byte and terminate it */
-	init_otp = (u8 *)dev_priv->vbt.dsi.sequence[MIPI_SEQ_INIT_OTP];
-	dev_priv->vbt.dsi.deassert_seq = kmemdup(init_otp, len + 1, GFP_KERNEL);
-	if (!dev_priv->vbt.dsi.deassert_seq)
+	init_otp = (u8 *)i915->vbt.dsi.sequence[MIPI_SEQ_INIT_OTP];
+	i915->vbt.dsi.deassert_seq = kmemdup(init_otp, len + 1, GFP_KERNEL);
+	if (!i915->vbt.dsi.deassert_seq)
 		return;
-	dev_priv->vbt.dsi.deassert_seq[0] = MIPI_SEQ_DEASSERT_RESET;
-	dev_priv->vbt.dsi.deassert_seq[len] = MIPI_SEQ_ELEM_END;
+	i915->vbt.dsi.deassert_seq[0] = MIPI_SEQ_DEASSERT_RESET;
+	i915->vbt.dsi.deassert_seq[len] = MIPI_SEQ_ELEM_END;
 	/* Use the copy for deassert */
-	dev_priv->vbt.dsi.sequence[MIPI_SEQ_DEASSERT_RESET] =
-		dev_priv->vbt.dsi.deassert_seq;
+	i915->vbt.dsi.sequence[MIPI_SEQ_DEASSERT_RESET] =
+		i915->vbt.dsi.deassert_seq;
 	/* Replace the last byte of the fragment with init OTP seq byte */
 	init_otp[len - 1] = MIPI_SEQ_INIT_OTP;
 	/* And make MIPI_MIPI_SEQ_INIT_OTP point to it */
-	dev_priv->vbt.dsi.sequence[MIPI_SEQ_INIT_OTP] = init_otp + len - 1;
+	i915->vbt.dsi.sequence[MIPI_SEQ_INIT_OTP] = init_otp + len - 1;
 }
 
 static void
-parse_mipi_sequence(struct drm_i915_private *dev_priv,
+parse_mipi_sequence(struct drm_i915_private *i915,
 		    const struct bdb_header *bdb)
 {
-	int panel_type = dev_priv->vbt.panel_type;
+	int panel_type = i915->vbt.panel_type;
 	const struct bdb_mipi_sequence *sequence;
 	const u8 *seq_data;
 	u32 seq_size;
@@ -1361,25 +1361,25 @@ parse_mipi_sequence(struct drm_i915_private *dev_priv,
 	int index = 0;
 
 	/* Only our generic panel driver uses the sequence block. */
-	if (dev_priv->vbt.dsi.panel_id != MIPI_DSI_GENERIC_PANEL_ID)
+	if (i915->vbt.dsi.panel_id != MIPI_DSI_GENERIC_PANEL_ID)
 		return;
 
 	sequence = find_section(bdb, BDB_MIPI_SEQUENCE);
 	if (!sequence) {
-		drm_dbg_kms(&dev_priv->drm,
+		drm_dbg_kms(&i915->drm,
 			    "No MIPI Sequence found, parsing complete\n");
 		return;
 	}
 
 	/* Fail gracefully for forward incompatible sequence block. */
 	if (sequence->version >= 4) {
-		drm_err(&dev_priv->drm,
+		drm_err(&i915->drm,
 			"Unable to parse MIPI Sequence Block v%u\n",
 			sequence->version);
 		return;
 	}
 
-	drm_dbg(&dev_priv->drm, "Found MIPI sequence block v%u\n",
+	drm_dbg(&i915->drm, "Found MIPI sequence block v%u\n",
 		sequence->version);
 
 	seq_data = find_panel_sequence_block(sequence, panel_type, &seq_size);
@@ -1397,41 +1397,41 @@ parse_mipi_sequence(struct drm_i915_private *dev_priv,
 			break;
 
 		if (seq_id >= MIPI_SEQ_MAX) {
-			drm_err(&dev_priv->drm, "Unknown sequence %u\n",
+			drm_err(&i915->drm, "Unknown sequence %u\n",
 				seq_id);
 			goto err;
 		}
 
 		/* Log about presence of sequences we won't run. */
 		if (seq_id == MIPI_SEQ_TEAR_ON || seq_id == MIPI_SEQ_TEAR_OFF)
-			drm_dbg_kms(&dev_priv->drm,
+			drm_dbg_kms(&i915->drm,
 				    "Unsupported sequence %u\n", seq_id);
 
-		dev_priv->vbt.dsi.sequence[seq_id] = data + index;
+		i915->vbt.dsi.sequence[seq_id] = data + index;
 
 		if (sequence->version >= 3)
 			index = goto_next_sequence_v3(data, index, seq_size);
 		else
 			index = goto_next_sequence(data, index, seq_size);
 		if (!index) {
-			drm_err(&dev_priv->drm, "Invalid sequence %u\n",
+			drm_err(&i915->drm, "Invalid sequence %u\n",
 				seq_id);
 			goto err;
 		}
 	}
 
-	dev_priv->vbt.dsi.data = data;
-	dev_priv->vbt.dsi.size = seq_size;
-	dev_priv->vbt.dsi.seq_version = sequence->version;
+	i915->vbt.dsi.data = data;
+	i915->vbt.dsi.size = seq_size;
+	i915->vbt.dsi.seq_version = sequence->version;
 
-	fixup_mipi_sequences(dev_priv);
+	fixup_mipi_sequences(i915);
 
-	drm_dbg(&dev_priv->drm, "MIPI related VBT parsing complete\n");
+	drm_dbg(&i915->drm, "MIPI related VBT parsing complete\n");
 	return;
 
 err:
 	kfree(data);
-	memset(dev_priv->vbt.dsi.sequence, 0, sizeof(dev_priv->vbt.dsi.sequence));
+	memset(i915->vbt.dsi.sequence, 0, sizeof(i915->vbt.dsi.sequence));
 }
 
 static void
@@ -1515,18 +1515,18 @@ static enum port get_port_by_ddc_pin(struct drm_i915_private *i915, u8 ddc_pin)
 	return PORT_NONE;
 }
 
-static void sanitize_ddc_pin(struct drm_i915_private *dev_priv,
+static void sanitize_ddc_pin(struct drm_i915_private *i915,
 			     enum port port)
 {
-	struct ddi_vbt_port_info *info = &dev_priv->vbt.ddi_port_info[port];
+	struct ddi_vbt_port_info *info = &i915->vbt.ddi_port_info[port];
 	enum port p;
 
 	if (!info->alternate_ddc_pin)
 		return;
 
-	p = get_port_by_ddc_pin(dev_priv, info->alternate_ddc_pin);
+	p = get_port_by_ddc_pin(i915, info->alternate_ddc_pin);
 	if (p != PORT_NONE) {
-		drm_dbg_kms(&dev_priv->drm,
+		drm_dbg_kms(&i915->drm,
 			    "port %c trying to use the same DDC pin (0x%x) as port %c, "
 			    "disabling port %c DVI/HDMI support\n",
 			    port_name(port), info->alternate_ddc_pin,
@@ -1544,7 +1544,7 @@ static void sanitize_ddc_pin(struct drm_i915_private *dev_priv,
 		 * port A and port E with the same AUX ch and
 		 * we must pick port E :(
 		 */
-		info = &dev_priv->vbt.ddi_port_info[p];
+		info = &i915->vbt.ddi_port_info[p];
 
 		info->supports_dvi = false;
 		info->supports_hdmi = false;
@@ -1567,18 +1567,18 @@ static enum port get_port_by_aux_ch(struct drm_i915_private *i915, u8 aux_ch)
 	return PORT_NONE;
 }
 
-static void sanitize_aux_ch(struct drm_i915_private *dev_priv,
+static void sanitize_aux_ch(struct drm_i915_private *i915,
 			    enum port port)
 {
-	struct ddi_vbt_port_info *info = &dev_priv->vbt.ddi_port_info[port];
+	struct ddi_vbt_port_info *info = &i915->vbt.ddi_port_info[port];
 	enum port p;
 
 	if (!info->alternate_aux_channel)
 		return;
 
-	p = get_port_by_aux_ch(dev_priv, info->alternate_aux_channel);
+	p = get_port_by_aux_ch(i915, info->alternate_aux_channel);
 	if (p != PORT_NONE) {
-		drm_dbg_kms(&dev_priv->drm,
+		drm_dbg_kms(&i915->drm,
 			    "port %c trying to use the same AUX CH (0x%x) as port %c, "
 			    "disabling port %c DP support\n",
 			    port_name(port), info->alternate_aux_channel,
@@ -1596,7 +1596,7 @@ static void sanitize_aux_ch(struct drm_i915_private *dev_priv,
 		 * port A and port E with the same AUX ch and
 		 * we must pick port E :(
 		 */
-		info = &dev_priv->vbt.ddi_port_info[p];
+		info = &i915->vbt.ddi_port_info[p];
 
 		info->supports_dp = false;
 		info->alternate_aux_channel = 0;
@@ -1644,26 +1644,26 @@ static const u8 gen9bc_tgp_ddc_pin_map[] = {
 	[DDC_BUS_DDI_D] = GMBUS_PIN_10_TC2_ICP,
 };
 
-static u8 map_ddc_pin(struct drm_i915_private *dev_priv, u8 vbt_pin)
+static u8 map_ddc_pin(struct drm_i915_private *i915, u8 vbt_pin)
 {
 	const u8 *ddc_pin_map;
 	int n_entries;
 
-	if (HAS_PCH_ADP(dev_priv)) {
+	if (HAS_PCH_ADP(i915)) {
 		ddc_pin_map = adls_ddc_pin_map;
 		n_entries = ARRAY_SIZE(adls_ddc_pin_map);
-	} else if (INTEL_PCH_TYPE(dev_priv) >= PCH_DG1) {
+	} else if (INTEL_PCH_TYPE(i915) >= PCH_DG1) {
 		return vbt_pin;
-	} else if (IS_ROCKETLAKE(dev_priv) && INTEL_PCH_TYPE(dev_priv) == PCH_TGP) {
+	} else if (IS_ROCKETLAKE(i915) && INTEL_PCH_TYPE(i915) == PCH_TGP) {
 		ddc_pin_map = rkl_pch_tgp_ddc_pin_map;
 		n_entries = ARRAY_SIZE(rkl_pch_tgp_ddc_pin_map);
-	} else if (HAS_PCH_TGP(dev_priv) && IS_GEN9_BC(dev_priv)) {
+	} else if (HAS_PCH_TGP(i915) && IS_GEN9_BC(i915)) {
 		ddc_pin_map = gen9bc_tgp_ddc_pin_map;
 		n_entries = ARRAY_SIZE(gen9bc_tgp_ddc_pin_map);
-	} else if (INTEL_PCH_TYPE(dev_priv) >= PCH_ICP) {
+	} else if (INTEL_PCH_TYPE(i915) >= PCH_ICP) {
 		ddc_pin_map = icp_ddc_pin_map;
 		n_entries = ARRAY_SIZE(icp_ddc_pin_map);
-	} else if (HAS_PCH_CNP(dev_priv)) {
+	} else if (HAS_PCH_CNP(i915)) {
 		ddc_pin_map = cnp_ddc_pin_map;
 		n_entries = ARRAY_SIZE(cnp_ddc_pin_map);
 	} else {
@@ -1674,7 +1674,7 @@ static u8 map_ddc_pin(struct drm_i915_private *dev_priv, u8 vbt_pin)
 	if (vbt_pin < n_entries && ddc_pin_map[vbt_pin] != 0)
 		return ddc_pin_map[vbt_pin];
 
-	drm_dbg_kms(&dev_priv->drm,
+	drm_dbg_kms(&i915->drm,
 		    "Ignoring alternate pin: VBT claims DDC pin %d, which is not valid for this platform\n",
 		    vbt_pin);
 	return 0;
@@ -1699,7 +1699,7 @@ static enum port __dvo_port_to_port(int n_ports, int n_dvo,
 	return PORT_NONE;
 }
 
-static enum port dvo_port_to_port(struct drm_i915_private *dev_priv,
+static enum port dvo_port_to_port(struct drm_i915_private *i915,
 				  u8 dvo_port)
 {
 	/*
@@ -1742,12 +1742,12 @@ static enum port dvo_port_to_port(struct drm_i915_private *dev_priv,
 		[PORT_TC4] = { DVO_PORT_HDMIE, DVO_PORT_DPE, -1 },
 	};
 
-	if (IS_ALDERLAKE_S(dev_priv))
+	if (IS_ALDERLAKE_S(i915))
 		return __dvo_port_to_port(ARRAY_SIZE(adls_port_mapping),
 					  ARRAY_SIZE(adls_port_mapping[0]),
 					  adls_port_mapping,
 					  dvo_port);
-	else if (IS_DG1(dev_priv) || IS_ROCKETLAKE(dev_priv))
+	else if (IS_DG1(i915) || IS_ROCKETLAKE(i915))
 		return __dvo_port_to_port(ARRAY_SIZE(rkl_port_mapping),
 					  ARRAY_SIZE(rkl_port_mapping[0]),
 					  rkl_port_mapping,
@@ -1797,7 +1797,7 @@ static int parse_bdb_216_dp_max_link_rate(const int vbt_max_link_rate)
 	}
 }
 
-static void parse_ddi_port(struct drm_i915_private *dev_priv,
+static void parse_ddi_port(struct drm_i915_private *i915,
 			   struct display_device_data *devdata,
 			   u8 bdb_version)
 {
@@ -1806,14 +1806,14 @@ static void parse_ddi_port(struct drm_i915_private *dev_priv,
 	bool is_dvi, is_hdmi, is_dp, is_edp, is_crt;
 	enum port port;
 
-	port = dvo_port_to_port(dev_priv, child->dvo_port);
+	port = dvo_port_to_port(i915, child->dvo_port);
 	if (port == PORT_NONE)
 		return;
 
-	info = &dev_priv->vbt.ddi_port_info[port];
+	info = &i915->vbt.ddi_port_info[port];
 
 	if (info->child) {
-		drm_dbg_kms(&dev_priv->drm,
+		drm_dbg_kms(&i915->drm,
 			    "More than one child device for port %c in VBT, using the first.\n",
 			    port_name(port));
 		return;
@@ -1825,8 +1825,8 @@ static void parse_ddi_port(struct drm_i915_private *dev_priv,
 	is_hdmi = is_dvi && (child->device_type & DEVICE_TYPE_NOT_HDMI_OUTPUT) == 0;
 	is_edp = is_dp && (child->device_type & DEVICE_TYPE_INTERNAL_CONNECTOR);
 
-	if (port == PORT_A && is_dvi && INTEL_GEN(dev_priv) < 12) {
-		drm_dbg_kms(&dev_priv->drm,
+	if (port == PORT_A && is_dvi && INTEL_GEN(i915) < 12) {
+		drm_dbg_kms(&i915->drm,
 			    "VBT claims port A supports DVI%s, ignoring\n",
 			    is_hdmi ? "/HDMI" : "");
 		is_dvi = false;
@@ -1844,22 +1844,22 @@ static void parse_ddi_port(struct drm_i915_private *dev_priv,
 	if (bdb_version >= 209)
 		info->supports_tbt = child->tbt;
 
-	drm_dbg_kms(&dev_priv->drm,
+	drm_dbg_kms(&i915->drm,
 		    "Port %c VBT info: CRT:%d DVI:%d HDMI:%d DP:%d eDP:%d LSPCON:%d USB-Type-C:%d TBT:%d DSC:%d\n",
 		    port_name(port), is_crt, is_dvi, is_hdmi, is_dp, is_edp,
-		    HAS_LSPCON(dev_priv) && child->lspcon,
+		    HAS_LSPCON(i915) && child->lspcon,
 		    info->supports_typec_usb, info->supports_tbt,
 		    devdata->dsc != NULL);
 
 	if (is_dvi) {
 		u8 ddc_pin;
 
-		ddc_pin = map_ddc_pin(dev_priv, child->ddc_pin);
-		if (intel_gmbus_is_valid_pin(dev_priv, ddc_pin)) {
+		ddc_pin = map_ddc_pin(i915, child->ddc_pin);
+		if (intel_gmbus_is_valid_pin(i915, ddc_pin)) {
 			info->alternate_ddc_pin = ddc_pin;
-			sanitize_ddc_pin(dev_priv, port);
+			sanitize_ddc_pin(i915, port);
 		} else {
-			drm_dbg_kms(&dev_priv->drm,
+			drm_dbg_kms(&i915->drm,
 				    "Port %c has invalid DDC pin %d, "
 				    "sticking to defaults\n",
 				    port_name(port), ddc_pin);
@@ -1869,13 +1869,13 @@ static void parse_ddi_port(struct drm_i915_private *dev_priv,
 	if (is_dp) {
 		info->alternate_aux_channel = child->aux_channel;
 
-		sanitize_aux_ch(dev_priv, port);
+		sanitize_aux_ch(i915, port);
 	}
 
 	if (bdb_version >= 158) {
 		/* The VBT HDMI level shift values match the table we have. */
 		u8 hdmi_level_shift = child->hdmi_level_shifter_value;
-		drm_dbg_kms(&dev_priv->drm,
+		drm_dbg_kms(&i915->drm,
 			    "Port %c VBT HDMI level shift: %d\n",
 			    port_name(port),
 			    hdmi_level_shift);
@@ -1902,7 +1902,7 @@ static void parse_ddi_port(struct drm_i915_private *dev_priv,
 		}
 
 		if (max_tmds_clock)
-			drm_dbg_kms(&dev_priv->drm,
+			drm_dbg_kms(&i915->drm,
 				    "Port %c VBT HDMI max TMDS clock: %d kHz\n",
 				    port_name(port), max_tmds_clock);
 		info->max_tmds_clock = max_tmds_clock;
@@ -1911,11 +1911,11 @@ static void parse_ddi_port(struct drm_i915_private *dev_priv,
 	/* Parse the I_boost config for SKL and above */
 	if (bdb_version >= 196 && child->iboost) {
 		info->dp_boost_level = translate_iboost(child->dp_iboost_level);
-		drm_dbg_kms(&dev_priv->drm,
+		drm_dbg_kms(&i915->drm,
 			    "Port %c VBT (e)DP boost level: %d\n",
 			    port_name(port), info->dp_boost_level);
 		info->hdmi_boost_level = translate_iboost(child->hdmi_iboost_level);
-		drm_dbg_kms(&dev_priv->drm,
+		drm_dbg_kms(&i915->drm,
 			    "Port %c VBT HDMI boost level: %d\n",
 			    port_name(port), info->hdmi_boost_level);
 	}
@@ -1927,7 +1927,7 @@ static void parse_ddi_port(struct drm_i915_private *dev_priv,
 		else
 			info->dp_max_link_rate = parse_bdb_216_dp_max_link_rate(child->dp_max_link_rate);
 
-		drm_dbg_kms(&dev_priv->drm,
+		drm_dbg_kms(&i915->drm,
 			    "Port %c VBT DP max link rate: %d\n",
 			    port_name(port), info->dp_max_link_rate);
 	}
@@ -1935,22 +1935,22 @@ static void parse_ddi_port(struct drm_i915_private *dev_priv,
 	info->child = child;
 }
 
-static void parse_ddi_ports(struct drm_i915_private *dev_priv, u8 bdb_version)
+static void parse_ddi_ports(struct drm_i915_private *i915, u8 bdb_version)
 {
 	struct display_device_data *devdata;
 
-	if (!HAS_DDI(dev_priv) && !IS_CHERRYVIEW(dev_priv))
+	if (!HAS_DDI(i915) && !IS_CHERRYVIEW(i915))
 		return;
 
 	if (bdb_version < 155)
 		return;
 
-	list_for_each_entry(devdata, &dev_priv->vbt.display_devices, node)
-		parse_ddi_port(dev_priv, devdata, bdb_version);
+	list_for_each_entry(devdata, &i915->vbt.display_devices, node)
+		parse_ddi_port(i915, devdata, bdb_version);
 }
 
 static void
-parse_general_definitions(struct drm_i915_private *dev_priv,
+parse_general_definitions(struct drm_i915_private *i915,
 			  const struct bdb_header *bdb)
 {
 	const struct bdb_general_definitions *defs;
@@ -1963,23 +1963,23 @@ parse_general_definitions(struct drm_i915_private *dev_priv,
 
 	defs = find_section(bdb, BDB_GENERAL_DEFINITIONS);
 	if (!defs) {
-		drm_dbg_kms(&dev_priv->drm,
+		drm_dbg_kms(&i915->drm,
 			    "No general definition block is found, no devices defined.\n");
 		return;
 	}
 
 	block_size = get_blocksize(defs);
 	if (block_size < sizeof(*defs)) {
-		drm_dbg_kms(&dev_priv->drm,
+		drm_dbg_kms(&i915->drm,
 			    "General definitions block too small (%u)\n",
 			    block_size);
 		return;
 	}
 
 	bus_pin = defs->crt_ddc_gmbus_pin;
-	drm_dbg_kms(&dev_priv->drm, "crt_ddc_bus_pin: %d\n", bus_pin);
-	if (intel_gmbus_is_valid_pin(dev_priv, bus_pin))
-		dev_priv->vbt.crt_ddc_pin = bus_pin;
+	drm_dbg_kms(&i915->drm, "crt_ddc_bus_pin: %d\n", bus_pin);
+	if (intel_gmbus_is_valid_pin(i915, bus_pin))
+		i915->vbt.crt_ddc_pin = bus_pin;
 
 	if (bdb->version < 106) {
 		expected_size = 22;
@@ -1996,20 +1996,20 @@ parse_general_definitions(struct drm_i915_private *dev_priv,
 	} else {
 		expected_size = sizeof(*child);
 		BUILD_BUG_ON(sizeof(*child) < 39);
-		drm_dbg(&dev_priv->drm,
+		drm_dbg(&i915->drm,
 			"Expected child device config size for VBT version %u not known; assuming %u\n",
 			bdb->version, expected_size);
 	}
 
 	/* Flag an error for unexpected size, but continue anyway. */
 	if (defs->child_dev_size != expected_size)
-		drm_err(&dev_priv->drm,
+		drm_err(&i915->drm,
 			"Unexpected child device config size %u (expected %u for VBT version %u)\n",
 			defs->child_dev_size, expected_size, bdb->version);
 
 	/* The legacy sized child device config is the minimum we need. */
 	if (defs->child_dev_size < LEGACY_CHILD_DEVICE_CONFIG_SIZE) {
-		drm_dbg_kms(&dev_priv->drm,
+		drm_dbg_kms(&i915->drm,
 			    "Child device config size %u is too small.\n",
 			    defs->child_dev_size);
 		return;
@@ -2023,7 +2023,7 @@ parse_general_definitions(struct drm_i915_private *dev_priv,
 		if (!child->device_type)
 			continue;
 
-		drm_dbg_kms(&dev_priv->drm,
+		drm_dbg_kms(&i915->drm,
 			    "Found VBT child device with type 0x%x\n",
 			    child->device_type);
 
@@ -2039,64 +2039,64 @@ parse_general_definitions(struct drm_i915_private *dev_priv,
 		memcpy(&devdata->child, child,
 		       min_t(size_t, defs->child_dev_size, sizeof(*child)));
 
-		list_add_tail(&devdata->node, &dev_priv->vbt.display_devices);
+		list_add_tail(&devdata->node, &i915->vbt.display_devices);
 	}
 
-	if (list_empty(&dev_priv->vbt.display_devices))
-		drm_dbg_kms(&dev_priv->drm,
+	if (list_empty(&i915->vbt.display_devices))
+		drm_dbg_kms(&i915->drm,
 			    "no child dev is parsed from VBT\n");
 }
 
 /* Common defaults which may be overridden by VBT. */
 static void
-init_vbt_defaults(struct drm_i915_private *dev_priv)
+init_vbt_defaults(struct drm_i915_private *i915)
 {
-	dev_priv->vbt.crt_ddc_pin = GMBUS_PIN_VGADDC;
+	i915->vbt.crt_ddc_pin = GMBUS_PIN_VGADDC;
 
 	/* Default to having backlight */
-	dev_priv->vbt.backlight.present = true;
+	i915->vbt.backlight.present = true;
 
 	/* LFP panel data */
-	dev_priv->vbt.lvds_dither = 1;
+	i915->vbt.lvds_dither = 1;
 
 	/* SDVO panel data */
-	dev_priv->vbt.sdvo_lvds_vbt_mode = NULL;
+	i915->vbt.sdvo_lvds_vbt_mode = NULL;
 
 	/* general features */
-	dev_priv->vbt.int_tv_support = 1;
-	dev_priv->vbt.int_crt_support = 1;
+	i915->vbt.int_tv_support = 1;
+	i915->vbt.int_crt_support = 1;
 
 	/* driver features */
-	dev_priv->vbt.int_lvds_support = 1;
+	i915->vbt.int_lvds_support = 1;
 
 	/* Default to using SSC */
-	dev_priv->vbt.lvds_use_ssc = 1;
+	i915->vbt.lvds_use_ssc = 1;
 	/*
 	 * Core/SandyBridge/IvyBridge use alternative (120MHz) reference
 	 * clock for LVDS.
 	 */
-	dev_priv->vbt.lvds_ssc_freq = intel_bios_ssc_frequency(dev_priv,
-			!HAS_PCH_SPLIT(dev_priv));
-	drm_dbg_kms(&dev_priv->drm, "Set default to SSC at %d kHz\n",
-		    dev_priv->vbt.lvds_ssc_freq);
+	i915->vbt.lvds_ssc_freq = intel_bios_ssc_frequency(i915,
+							   !HAS_PCH_SPLIT(i915));
+	drm_dbg_kms(&i915->drm, "Set default to SSC at %d kHz\n",
+		    i915->vbt.lvds_ssc_freq);
 }
 
 /* Defaults to initialize only if there is no VBT. */
 static void
-init_vbt_missing_defaults(struct drm_i915_private *dev_priv)
+init_vbt_missing_defaults(struct drm_i915_private *i915)
 {
 	enum port port;
 
 	for_each_port(port) {
 		struct ddi_vbt_port_info *info =
-			&dev_priv->vbt.ddi_port_info[port];
-		enum phy phy = intel_port_to_phy(dev_priv, port);
+			&i915->vbt.ddi_port_info[port];
+		enum phy phy = intel_port_to_phy(i915, port);
 
 		/*
 		 * VBT has the TypeC mode (native,TBT/USB) and we don't want
 		 * to detect it.
 		 */
-		if (intel_phy_is_tc(dev_priv, phy))
+		if (intel_phy_is_tc(i915, phy))
 			continue;
 
 		info->supports_dvi = (port != PORT_A && port != PORT_E);
@@ -2162,9 +2162,9 @@ bool intel_bios_is_valid_vbt(const void *buf, size_t size)
 	return vbt;
 }
 
-static struct vbt_header *oprom_get_vbt(struct drm_i915_private *dev_priv)
+static struct vbt_header *oprom_get_vbt(struct drm_i915_private *i915)
 {
-	struct pci_dev *pdev = to_pci_dev(dev_priv->drm.dev);
+	struct pci_dev *pdev = to_pci_dev(i915->drm.dev);
 	void __iomem *p = NULL, *oprom;
 	struct vbt_header *vbt;
 	u16 vbt_size;
@@ -2188,13 +2188,13 @@ static struct vbt_header *oprom_get_vbt(struct drm_i915_private *dev_priv)
 		goto err_unmap_oprom;
 
 	if (sizeof(struct vbt_header) > size) {
-		drm_dbg(&dev_priv->drm, "VBT header incomplete\n");
+		drm_dbg(&i915->drm, "VBT header incomplete\n");
 		goto err_unmap_oprom;
 	}
 
 	vbt_size = ioread16(p + offsetof(struct vbt_header, vbt_size));
 	if (vbt_size > size) {
-		drm_dbg(&dev_priv->drm,
+		drm_dbg(&i915->drm,
 			"VBT incomplete (vbt_size overflows)\n");
 		goto err_unmap_oprom;
 	}
@@ -2223,71 +2223,71 @@ static struct vbt_header *oprom_get_vbt(struct drm_i915_private *dev_priv)
 
 /**
  * intel_bios_init - find VBT and initialize settings from the BIOS
- * @dev_priv: i915 device instance
+ * @i915: i915 device instance
  *
  * Parse and initialize settings from the Video BIOS Tables (VBT). If the VBT
  * was not found in ACPI OpRegion, try to find it in PCI ROM first. Also
  * initialize some defaults if the VBT is not present at all.
  */
-void intel_bios_init(struct drm_i915_private *dev_priv)
+void intel_bios_init(struct drm_i915_private *i915)
 {
-	const struct vbt_header *vbt = dev_priv->opregion.vbt;
+	const struct vbt_header *vbt = i915->opregion.vbt;
 	struct vbt_header *oprom_vbt = NULL;
 	const struct bdb_header *bdb;
 
-	INIT_LIST_HEAD(&dev_priv->vbt.display_devices);
+	INIT_LIST_HEAD(&i915->vbt.display_devices);
 
-	if (!HAS_DISPLAY(dev_priv)) {
-		drm_dbg_kms(&dev_priv->drm,
+	if (!HAS_DISPLAY(i915)) {
+		drm_dbg_kms(&i915->drm,
 			    "Skipping VBT init due to disabled display.\n");
 		return;
 	}
 
-	init_vbt_defaults(dev_priv);
+	init_vbt_defaults(i915);
 
 	/* If the OpRegion does not have VBT, look in PCI ROM. */
 	if (!vbt) {
-		oprom_vbt = oprom_get_vbt(dev_priv);
+		oprom_vbt = oprom_get_vbt(i915);
 		if (!oprom_vbt)
 			goto out;
 
 		vbt = oprom_vbt;
 
-		drm_dbg_kms(&dev_priv->drm, "Found valid VBT in PCI ROM\n");
+		drm_dbg_kms(&i915->drm, "Found valid VBT in PCI ROM\n");
 	}
 
 	bdb = get_bdb_header(vbt);
 
-	drm_dbg_kms(&dev_priv->drm,
+	drm_dbg_kms(&i915->drm,
 		    "VBT signature \"%.*s\", BDB version %d\n",
 		    (int)sizeof(vbt->signature), vbt->signature, bdb->version);
 
 	/* Grab useful general definitions */
-	parse_general_features(dev_priv, bdb);
-	parse_general_definitions(dev_priv, bdb);
-	parse_panel_options(dev_priv, bdb);
-	parse_panel_dtd(dev_priv, bdb);
-	parse_lfp_backlight(dev_priv, bdb);
-	parse_sdvo_panel_data(dev_priv, bdb);
-	parse_driver_features(dev_priv, bdb);
-	parse_power_conservation_features(dev_priv, bdb);
-	parse_edp(dev_priv, bdb);
-	parse_psr(dev_priv, bdb);
-	parse_mipi_config(dev_priv, bdb);
-	parse_mipi_sequence(dev_priv, bdb);
+	parse_general_features(i915, bdb);
+	parse_general_definitions(i915, bdb);
+	parse_panel_options(i915, bdb);
+	parse_panel_dtd(i915, bdb);
+	parse_lfp_backlight(i915, bdb);
+	parse_sdvo_panel_data(i915, bdb);
+	parse_driver_features(i915, bdb);
+	parse_power_conservation_features(i915, bdb);
+	parse_edp(i915, bdb);
+	parse_psr(i915, bdb);
+	parse_mipi_config(i915, bdb);
+	parse_mipi_sequence(i915, bdb);
 
 	/* Depends on child device list */
-	parse_compression_parameters(dev_priv, bdb);
+	parse_compression_parameters(i915, bdb);
 
 	/* Further processing on pre-parsed data */
-	parse_sdvo_device_mapping(dev_priv, bdb->version);
-	parse_ddi_ports(dev_priv, bdb->version);
+	parse_sdvo_device_mapping(i915, bdb->version);
+	parse_ddi_ports(i915, bdb->version);
 
 out:
 	if (!vbt) {
-		drm_info(&dev_priv->drm,
+		drm_info(&i915->drm,
 			 "Failed to find VBIOS tables (VBT)\n");
-		init_vbt_missing_defaults(dev_priv);
+		init_vbt_missing_defaults(i915);
 	}
 
 	kfree(oprom_vbt);
@@ -2295,51 +2295,51 @@ void intel_bios_init(struct drm_i915_private *dev_priv)
 
 /**
  * intel_bios_driver_remove - Free any resources allocated by intel_bios_init()
- * @dev_priv: i915 device instance
+ * @i915: i915 device instance
  */
-void intel_bios_driver_remove(struct drm_i915_private *dev_priv)
+void intel_bios_driver_remove(struct drm_i915_private *i915)
 {
 	struct display_device_data *devdata, *n;
 
-	list_for_each_entry_safe(devdata, n, &dev_priv->vbt.display_devices, node) {
+	list_for_each_entry_safe(devdata, n, &i915->vbt.display_devices, node) {
 		list_del(&devdata->node);
 		kfree(devdata->dsc);
 		kfree(devdata);
 	}
 
-	kfree(dev_priv->vbt.sdvo_lvds_vbt_mode);
-	dev_priv->vbt.sdvo_lvds_vbt_mode = NULL;
-	kfree(dev_priv->vbt.lfp_lvds_vbt_mode);
-	dev_priv->vbt.lfp_lvds_vbt_mode = NULL;
-	kfree(dev_priv->vbt.dsi.data);
-	dev_priv->vbt.dsi.data = NULL;
-	kfree(dev_priv->vbt.dsi.pps);
-	dev_priv->vbt.dsi.pps = NULL;
-	kfree(dev_priv->vbt.dsi.config);
-	dev_priv->vbt.dsi.config = NULL;
-	kfree(dev_priv->vbt.dsi.deassert_seq);
-	dev_priv->vbt.dsi.deassert_seq = NULL;
+	kfree(i915->vbt.sdvo_lvds_vbt_mode);
+	i915->vbt.sdvo_lvds_vbt_mode = NULL;
+	kfree(i915->vbt.lfp_lvds_vbt_mode);
+	i915->vbt.lfp_lvds_vbt_mode = NULL;
+	kfree(i915->vbt.dsi.data);
+	i915->vbt.dsi.data = NULL;
+	kfree(i915->vbt.dsi.pps);
+	i915->vbt.dsi.pps = NULL;
+	kfree(i915->vbt.dsi.config);
+	i915->vbt.dsi.config = NULL;
+	kfree(i915->vbt.dsi.deassert_seq);
+	i915->vbt.dsi.deassert_seq = NULL;
 }
 
 /**
  * intel_bios_is_tv_present - is integrated TV present in VBT
- * @dev_priv:	i915 device instance
+ * @i915: i915 device instance
  *
  * Return true if TV is present. If no child devices were parsed from VBT,
  * assume TV is present.
  */
-bool intel_bios_is_tv_present(struct drm_i915_private *dev_priv)
+bool intel_bios_is_tv_present(struct drm_i915_private *i915)
 {
 	const struct display_device_data *devdata;
 	const struct child_device_config *child;
 
-	if (!dev_priv->vbt.int_tv_support)
+	if (!i915->vbt.int_tv_support)
 		return false;
 
-	if (list_empty(&dev_priv->vbt.display_devices))
+	if (list_empty(&i915->vbt.display_devices))
 		return true;
 
-	list_for_each_entry(devdata, &dev_priv->vbt.display_devices, node) {
+	list_for_each_entry(devdata, &i915->vbt.display_devices, node) {
 		child = &devdata->child;
 
 		/*
@@ -2365,21 +2365,21 @@ bool intel_bios_is_tv_present(struct drm_i915_private *dev_priv)
 
 /**
  * intel_bios_is_lvds_present - is LVDS present in VBT
- * @dev_priv:	i915 device instance
+ * @i915:	i915 device instance
  * @i2c_pin:	i2c pin for LVDS if present
  *
  * Return true if LVDS is present. If no child devices were parsed from VBT,
  * assume LVDS is present.
  */
-bool intel_bios_is_lvds_present(struct drm_i915_private *dev_priv, u8 *i2c_pin)
+bool intel_bios_is_lvds_present(struct drm_i915_private *i915, u8 *i2c_pin)
 {
 	const struct display_device_data *devdata;
 	const struct child_device_config *child;
 
-	if (list_empty(&dev_priv->vbt.display_devices))
+	if (list_empty(&i915->vbt.display_devices))
 		return true;
 
-	list_for_each_entry(devdata, &dev_priv->vbt.display_devices, node) {
+	list_for_each_entry(devdata, &i915->vbt.display_devices, node) {
 		child = &devdata->child;
 
 		/* If the device type is not LFP, continue.
@@ -2390,7 +2390,7 @@ bool intel_bios_is_lvds_present(struct drm_i915_private *dev_priv, u8 *i2c_pin)
 		    child->device_type != DEVICE_TYPE_LFP)
 			continue;
 
-		if (intel_gmbus_is_valid_pin(dev_priv, child->i2c_pin))
+		if (intel_gmbus_is_valid_pin(i915, child->i2c_pin))
 			*i2c_pin = child->i2c_pin;
 
 		/* However, we cannot trust the BIOS writers to populate
@@ -2406,7 +2406,7 @@ bool intel_bios_is_lvds_present(struct drm_i915_private *dev_priv, u8 *i2c_pin)
 		 * additional data.  Trust that if the VBT was written into
 		 * the OpRegion then they have validated the LVDS's existence.
 		 */
-		if (dev_priv->opregion.vbt)
+		if (i915->opregion.vbt)
 			return true;
 	}
 
@@ -2415,12 +2415,12 @@ bool intel_bios_is_lvds_present(struct drm_i915_private *dev_priv, u8 *i2c_pin)
 
 /**
  * intel_bios_is_port_present - is the specified digital port present
- * @dev_priv:	i915 device instance
+ * @i915:	i915 device instance
  * @port:	port to check
  *
  * Return true if the device in %port is present.
  */
-bool intel_bios_is_port_present(struct drm_i915_private *dev_priv, enum port port)
+bool intel_bios_is_port_present(struct drm_i915_private *i915, enum port port)
 {
 	const struct display_device_data *devdata;
 	const struct child_device_config *child;
@@ -2434,19 +2434,19 @@ bool intel_bios_is_port_present(struct drm_i915_private *dev_priv, enum port por
 		[PORT_F] = { DVO_PORT_DPF, DVO_PORT_HDMIF, },
 	};
 
-	if (HAS_DDI(dev_priv)) {
+	if (HAS_DDI(i915)) {
 		const struct ddi_vbt_port_info *port_info =
-			&dev_priv->vbt.ddi_port_info[port];
+			&i915->vbt.ddi_port_info[port];
 
 		return port_info->child;
 	}
 
 	/* FIXME maybe deal with port A as well? */
-	if (drm_WARN_ON(&dev_priv->drm,
+	if (drm_WARN_ON(&i915->drm,
 			port == PORT_A) || port >= ARRAY_SIZE(port_mapping))
 		return false;
 
-	list_for_each_entry(devdata, &dev_priv->vbt.display_devices, node) {
+	list_for_each_entry(devdata, &i915->vbt.display_devices, node) {
 		child = &devdata->child;
 
 		if ((child->dvo_port == port_mapping[port].dp ||
@@ -2461,12 +2461,12 @@ bool intel_bios_is_port_present(struct drm_i915_private *dev_priv, enum port por
 
 /**
  * intel_bios_is_port_edp - is the device in given port eDP
- * @dev_priv:	i915 device instance
+ * @i915:	i915 device instance
  * @port:	port to check
  *
  * Return true if the device in %port is eDP.
  */
-bool intel_bios_is_port_edp(struct drm_i915_private *dev_priv, enum port port)
+bool intel_bios_is_port_edp(struct drm_i915_private *i915, enum port port)
 {
 	const struct display_device_data *devdata;
 	const struct child_device_config *child;
@@ -2478,10 +2478,10 @@ bool intel_bios_is_port_edp(struct drm_i915_private *dev_priv, enum port port)
 		[PORT_F] = DVO_PORT_DPF,
 	};
 
-	if (HAS_DDI(dev_priv))
-		return dev_priv->vbt.ddi_port_info[port].supports_edp;
+	if (HAS_DDI(i915))
+		return i915->vbt.ddi_port_info[port].supports_edp;
 
-	list_for_each_entry(devdata, &dev_priv->vbt.display_devices, node) {
+	list_for_each_entry(devdata, &i915->vbt.display_devices, node) {
 		child = &devdata->child;
 
 		if (child->dvo_port == port_mapping[port] &&
@@ -2528,12 +2528,12 @@ static bool child_dev_is_dp_dual_mode(const struct child_device_config *child,
 	return false;
 }
 
-bool intel_bios_is_port_dp_dual_mode(struct drm_i915_private *dev_priv,
+bool intel_bios_is_port_dp_dual_mode(struct drm_i915_private *i915,
 				     enum port port)
 {
 	const struct display_device_data *devdata;
 
-	list_for_each_entry(devdata, &dev_priv->vbt.display_devices, node) {
+	list_for_each_entry(devdata, &i915->vbt.display_devices, node) {
 		if (child_dev_is_dp_dual_mode(&devdata->child, port))
 			return true;
 	}
@@ -2543,19 +2543,19 @@ bool intel_bios_is_port_dp_dual_mode(struct drm_i915_private *dev_priv,
 
 /**
  * intel_bios_is_dsi_present - is DSI present in VBT
- * @dev_priv:	i915 device instance
+ * @i915:	i915 device instance
  * @port:	port for DSI if present
  *
  * Return true if DSI is present, and return the port in %port.
  */
-bool intel_bios_is_dsi_present(struct drm_i915_private *dev_priv,
+bool intel_bios_is_dsi_present(struct drm_i915_private *i915,
 			       enum port *port)
 {
 	const struct display_device_data *devdata;
 	const struct child_device_config *child;
 	u8 dvo_port;
 
-	list_for_each_entry(devdata, &dev_priv->vbt.display_devices, node) {
+	list_for_each_entry(devdata, &i915->vbt.display_devices, node) {
 		child = &devdata->child;
 
 		if (!(child->device_type & DEVICE_TYPE_MIPI_OUTPUT))
@@ -2564,15 +2564,15 @@ bool intel_bios_is_dsi_present(struct drm_i915_private *dev_priv,
 		dvo_port = child->dvo_port;
 
 		if (dvo_port == DVO_PORT_MIPIA ||
-		    (dvo_port == DVO_PORT_MIPIB && INTEL_GEN(dev_priv) >= 11) ||
-		    (dvo_port == DVO_PORT_MIPIC && INTEL_GEN(dev_priv) < 11)) {
+		    (dvo_port == DVO_PORT_MIPIB && INTEL_GEN(i915) >= 11) ||
+		    (dvo_port == DVO_PORT_MIPIC && INTEL_GEN(i915) < 11)) {
 			if (port)
 				*port = dvo_port - DVO_PORT_MIPIA;
 			return true;
 		} else if (dvo_port == DVO_PORT_MIPIB ||
 			   dvo_port == DVO_PORT_MIPIC ||
 			   dvo_port == DVO_PORT_MIPID) {
-			drm_dbg_kms(&dev_priv->drm,
+			drm_dbg_kms(&i915->drm,
 				    "VBT has unsupported DSI port %c\n",
 				    port_name(dvo_port - DVO_PORT_MIPIA));
 		}
@@ -2728,17 +2728,17 @@ intel_bios_is_lane_reversal_needed(const struct drm_i915_private *i915,
 	return child && child->lane_reversal;
 }
 
-enum aux_ch intel_bios_port_aux_ch(struct drm_i915_private *dev_priv,
+enum aux_ch intel_bios_port_aux_ch(struct drm_i915_private *i915,
 				   enum port port)
 {
 	const struct ddi_vbt_port_info *info =
-		&dev_priv->vbt.ddi_port_info[port];
+		&i915->vbt.ddi_port_info[port];
 	enum aux_ch aux_ch;
 
 	if (!info->alternate_aux_channel) {
 		aux_ch = (enum aux_ch)port;
 
-		drm_dbg_kms(&dev_priv->drm,
+		drm_dbg_kms(&i915->drm,
 			    "using AUX %c for port %c (platform default)\n",
 			    aux_ch_name(aux_ch), port_name(port));
 		return aux_ch;
@@ -2756,29 +2756,29 @@ enum aux_ch intel_bios_port_aux_ch(struct drm_i915_private *dev_priv,
 		aux_ch = AUX_CH_A;
 		break;
 	case DP_AUX_B:
-		if (IS_ALDERLAKE_S(dev_priv))
+		if (IS_ALDERLAKE_S(i915))
 			aux_ch = AUX_CH_USBC1;
 		else
 			aux_ch = AUX_CH_B;
 		break;
 	case DP_AUX_C:
-		if (IS_ALDERLAKE_S(dev_priv))
+		if (IS_ALDERLAKE_S(i915))
 			aux_ch = AUX_CH_USBC2;
-		else if (IS_DG1(dev_priv) || IS_ROCKETLAKE(dev_priv))
+		else if (IS_DG1(i915) || IS_ROCKETLAKE(i915))
 			aux_ch = AUX_CH_USBC1;
 		else
 			aux_ch = AUX_CH_C;
 		break;
 	case DP_AUX_D:
-		if (IS_ALDERLAKE_S(dev_priv))
+		if (IS_ALDERLAKE_S(i915))
 			aux_ch = AUX_CH_USBC3;
-		else if (IS_DG1(dev_priv) || IS_ROCKETLAKE(dev_priv))
+		else if (IS_DG1(i915) || IS_ROCKETLAKE(i915))
 			aux_ch = AUX_CH_USBC2;
 		else
 			aux_ch = AUX_CH_D;
 		break;
 	case DP_AUX_E:
-		if (IS_ALDERLAKE_S(dev_priv))
+		if (IS_ALDERLAKE_S(i915))
 			aux_ch = AUX_CH_USBC4;
 		else
 			aux_ch = AUX_CH_E;
@@ -2801,7 +2801,7 @@ enum aux_ch intel_bios_port_aux_ch(struct drm_i915_private *dev_priv,
 		break;
 	}
 
-	drm_dbg_kms(&dev_priv->drm, "using AUX %c for port %c (VBT)\n",
+	drm_dbg_kms(&i915->drm, "using AUX %c for port %c (VBT)\n",
 		    aux_ch_name(aux_ch), port_name(port));
 
 	return aux_ch;
-- 
2.25.1

