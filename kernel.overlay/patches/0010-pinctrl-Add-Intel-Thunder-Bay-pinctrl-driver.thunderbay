From bef95eb58fda40501b90bfe0579f3c8087e8c1ae Mon Sep 17 00:00:00 2001
From: "D, Lakshmi Sowjanya" <lakshmi.sowjanya.d@intel.com>
Date: Wed, 19 May 2021 21:51:22 +0530
Subject: [PATCH 010/170] pinctrl: Add Intel Thunder Bay pinctrl driver

Add pinctrl driver to enable pin control support in the Intel Thunder Bay
SoC.

Signed-off-by: D, Lakshmi Sowjanya <lakshmi.sowjanya.d@intel.com>
---
 drivers/pinctrl/Kconfig              |   19 +
 drivers/pinctrl/Makefile             |    1 +
 drivers/pinctrl/pinctrl-thunderbay.c | 1789 ++++++++++++++++++++++++++
 3 files changed, 1809 insertions(+)
 create mode 100644 drivers/pinctrl/pinctrl-thunderbay.c

diff --git a/drivers/pinctrl/Kconfig b/drivers/pinctrl/Kconfig
index c2c7e7963ed0..2ed45396a490 100644
--- a/drivers/pinctrl/Kconfig
+++ b/drivers/pinctrl/Kconfig
@@ -459,4 +459,23 @@ config PINCTRL_EQUILIBRIUM
 	  pin functions, configure GPIO attributes for LGM SoC pins. Pinmux and
 	  pinconf settings are retrieved from device tree.
 
+config PINCTRL_THUNDERBAY
+	tristate "Generic pinctrl and GPIO driver for Intel Thunderbay SoC"
+	depends on ARM64 && COMPILE_TEST
+	depends on HAS_IOMEM
+	select PINMUX
+	select PINCONF
+	select GENERIC_PINCONF
+	select GENERIC_PINCTRL_GROUPS
+	select GENERIC_PINMUX_FUNCTIONS
+	select GPIOLIB
+	select GPIOLIB_IRQCHIP
+	select GPIO_GENERIC
+	help
+	  This selects pin control driver for the Intel Thunderbay SoC.
+	  It provides pin config functions such as pullup, pulldown,
+	  interrupt, drive strength, sec lock, schmitt trigger, slew
+	  rate control and direction control. This module will be
+	  called as pinctrl-thunderbay.
+
 endif
diff --git a/drivers/pinctrl/Makefile b/drivers/pinctrl/Makefile
index 5ef5334a797f..ac72ff9bf393 100644
--- a/drivers/pinctrl/Makefile
+++ b/drivers/pinctrl/Makefile
@@ -47,6 +47,7 @@ obj-$(CONFIG_PINCTRL_OCELOT)	+= pinctrl-ocelot.o
 obj-$(CONFIG_PINCTRL_MICROCHIP_SGPIO)	+= pinctrl-microchip-sgpio.o
 obj-$(CONFIG_PINCTRL_EQUILIBRIUM)   += pinctrl-equilibrium.o
 obj-$(CONFIG_PINCTRL_K210)	+= pinctrl-k210.o
+obj-$(CONFIG_PINCTRL_THUNDERBAY) += pinctrl-thunderbay.o
 
 obj-y				+= actions/
 obj-$(CONFIG_ARCH_ASPEED)	+= aspeed/
diff --git a/drivers/pinctrl/pinctrl-thunderbay.c b/drivers/pinctrl/pinctrl-thunderbay.c
new file mode 100644
index 000000000000..a4976f4981d2
--- /dev/null
+++ b/drivers/pinctrl/pinctrl-thunderbay.c
@@ -0,0 +1,1789 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Intel Thunderbay SOC pinctrl/GPIO driver
+ *
+ * Copyright (C) 2020 Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/gpio/driver.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_irq.h>
+#include <linux/pinctrl/pinconf.h>
+#include <linux/pinctrl/pinconf-generic.h>
+#include <linux/pinctrl/pinctrl.h>
+#include <linux/pinctrl/pinmux.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+
+#include "core.h"
+#include "pinconf.h"
+#include "pinctrl-utils.h"
+#include "pinmux.h"
+
+/* Bit 0:2 and 4:6 should be used for mode selection */
+#define THB_GPIO_PINMUX_MODE_0 (0x00)
+#define THB_GPIO_PINMUX_MODE_1 (0x11)
+#define THB_GPIO_PINMUX_MODE_2 (0x22)
+#define THB_GPIO_PINMUX_MODE_3 (0x33)
+
+/* GPIO direct control */
+#define THB_GPIO_PINMUX_MODE_4 (0x44)
+
+/* bit 8 - PS: Port Select */
+#define THB_GPIO_PORT_SELECT_MASK (0x100)
+
+/* bit 10 - DP: Direction of Pad*/
+#define THB_GPIO_PAD_DIRECTION_MASK (0x400)
+
+/* bit 11 - SPU: Strong Pull function of pad */
+#define THB_GPIO_SPU_MASK (0x800)
+
+/* bit 12 - PPEN: Pull Enable function of pad  */
+#define THB_GPIO_PULL_ENABLE_MASK (0x1000)
+
+/* bit 13 - PUQ: Pull Up function of Pad */
+#define THB_GPIO_PULL_UP_MASK (0x2000)
+
+/* bit 14 - PD: Pull Down function of Pad */
+#define THB_GPIO_PULL_DOWN_MASK (0x4000)
+
+/* bit 15 - ENAQ: Output function of Pad */
+#define THB_GPIO_ENAQ_MASK (0x8000)
+
+/* bit 16-19: Drive Strength for the Pad */
+#define THB_GPIO_DRIVE_STRENGTH_MASK (0xF0000)
+
+/* bit 20 - Slew rate for the pad */
+#define THB_GPIO_SLEW_RATE_MASK (0x100000)
+
+/* bit 21 - Schmitt-Trigger  the pad */
+#define THB_GPIO_SCHMITT_TRIGGER_MASK (0x200000)
+
+/* calculate register offset */
+#define THB_GPIO_REG_OFFSET(pin_num) ((pin_num) * (0x4))
+
+/* Max number of modes supported */
+#define THB_MAX_MODE_SUPPORTED (5u)
+
+/* Max number of pins supported */
+#define THB_MAX_NPINS_SUPPORTED (67u)
+
+/* THB Board specific requirements handle */
+#define THB_BOARD_SPECIFIC_GPIO_REQUIREMENTS_HANDLE (1u)
+
+/* store Pin status */
+static u32 thb_pinx_status[THB_MAX_NPINS_SUPPORTED] = { 0u };
+
+struct thunderbay_mux_desc {
+	u8 mode;
+	const char *name;
+};
+
+#define THUNDERBAY_PIN_DESC(pin_number, pin_name, ...) {        \
+	.number = pin_number,                           \
+	.name = pin_name,                               \
+	.drv_data = &(struct thunderbay_mux_desc[]) {   \
+			__VA_ARGS__, { } },             \
+}
+
+#define THUNDERBAY_MUX(pin_mode, pin_function) {                \
+	.mode = pin_mode,                               \
+	.name = pin_function,                           \
+}
+
+struct thunderbay_pin_soc {
+	const struct pinctrl_pin_desc           *pins;
+	unsigned int                            npins;
+};
+
+/**
+ * struct thunderbay_pinctrl - Intel Thunderbay pinctrl structure
+ * @pctrl: Pointer to the pin controller device
+ * @base0: First register base address
+ * @dev: Pointer to the device structure
+ * @chip: GPIO chip used by this pin controller
+ * @soc: Pin control configuration data based on SoC
+ * @ngroups: Number of pin groups available
+ * @nfuncs: Number of pin functions available
+ */
+struct thunderbay_pinctrl {
+	struct pinctrl_dev              *pctrl;
+	void __iomem                    *base0;
+	struct device                   *dev;
+	struct gpio_chip                chip;
+	const struct thunderbay_pin_soc *soc;
+	unsigned int                    ngroups;
+	unsigned int                    nfuncs;
+};
+
+/*********************************************************************************
+ * Private structures
+ ********************************************************************************/
+static const struct pinctrl_pin_desc thunderbay_pins[] = {
+	THUNDERBAY_PIN_DESC(0, "GPIO0",
+			    THUNDERBAY_MUX(0X0, "I2C0_M0"),		/* I2C0_SCL */
+			    THUNDERBAY_MUX(0X1, "EMPTY_M1"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X2, "EMPTY_M2"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X3, "EMPTY_M3"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(1, "GPIO1",
+			    THUNDERBAY_MUX(0X0, "I2C0_M0"),		/* I2C0_SDA */
+			    THUNDERBAY_MUX(0X1, "EMPTY_M1"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X2, "EMPTY_M2"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X3, "EMPTY_M3"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(2, "GPIO2",
+			    THUNDERBAY_MUX(0X0, "I2C1_M0"),		/* I2C1_SCL */
+			    THUNDERBAY_MUX(0X1, "EMPTY_M1"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X2, "EMPTY_M2"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X3, "EMPTY_M3"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(3, "GPIO3",
+			    THUNDERBAY_MUX(0X0, "I2C1_M0"),		/* I2C1_SDA */
+			    THUNDERBAY_MUX(0X1, "EMPTY_M1"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X2, "EMPTY_M2"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X3, "EMPTY_M3"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(4, "GPIO4",
+			    THUNDERBAY_MUX(0X0, "I2C2_M0"),		/* I2C2_SCL */
+			    THUNDERBAY_MUX(0X1, "EMPTY_M1"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X2, "EMPTY_M2"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X3, "EMPTY_M3"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(5, "GPIO5",
+			    THUNDERBAY_MUX(0X0, "I2C2_M0"),		/* I2C2_SDA */
+			    THUNDERBAY_MUX(0X1, "EMPTY_M1"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X2, "EMPTY_M2"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X3, "EMPTY_M3"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(6, "GPIO6",
+			    THUNDERBAY_MUX(0X0, "I2C3_M0"),		/* I2C3_SCL */
+			    THUNDERBAY_MUX(0X1, "EMPTY_M1"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X2, "EMPTY_M2"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X3, "EMPTY_M3"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(7, "GPIO7",
+			    THUNDERBAY_MUX(0X0, "I2C3_M0"),		/* I2C3_SDA */
+			    THUNDERBAY_MUX(0X1, "EMPTY_M1"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X2, "EMPTY_M2"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X3, "EMPTY_M3"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(8, "GPIO8",
+			    THUNDERBAY_MUX(0X0, "I2C4_M0"),		/* I2C4_SCL */
+			    THUNDERBAY_MUX(0X1, "EMPTY_M1"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X2, "EMPTY_M2"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X3, "EMPTY_M3"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(9, "GPIO9",
+			    THUNDERBAY_MUX(0X0, "I2C4_M0"),		/* I2C4_SDA */
+			    THUNDERBAY_MUX(0X1, "EMPTY_M1"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X2, "EMPTY_M2"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X3, "EMPTY_M3"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(10, "GPIO10",
+			    THUNDERBAY_MUX(0X0, "UART0_M0"),		/* UART0_SOUT */
+			    THUNDERBAY_MUX(0X1, "RT0_DSU_M1"),		/* RT0_DSU_ACTIVE */
+			    THUNDERBAY_MUX(0X2, "EMPTY_M2"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X3, "EMPTY_M3"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(11, "GPIO11",
+			    THUNDERBAY_MUX(0X0, "UART0_M0"),		/* UART0_SIN */
+			    THUNDERBAY_MUX(0X1, "RT0_DSU_M1"),		/* RT0_DSU_TSTOP */
+			    THUNDERBAY_MUX(0X2, "EMPTY_M2"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X3, "EMPTY_M3"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(12, "GPIO12",
+			    THUNDERBAY_MUX(0X0, "UART0_M0"),		/* UART0_CTS_N */
+			    THUNDERBAY_MUX(0X1, "RT1_DSU_M1"),		/* RT1_DSU_ACTIVE */
+			    THUNDERBAY_MUX(0X2, "EMPTY_M2"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X3, "EMPTY_M3"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(13, "GPIO13",
+			    THUNDERBAY_MUX(0X0, "UART0_M0"),		/* UART0_RTS_N */
+			    THUNDERBAY_MUX(0X1, "RT1_DSU_M1"),		/* RT1_DSU_TSTOP */
+			    THUNDERBAY_MUX(0X2, "EMPTY_M2"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X3, "EMPTY_M3"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(14, "GPIO14",
+			    THUNDERBAY_MUX(0X0, "UART1_M0"),		/* UART1_SOUT */
+			    THUNDERBAY_MUX(0X1, "RT2_DSU_M1"),		/* RT2_DSU_ACTIVE */
+			    THUNDERBAY_MUX(0X2, "EMPTY_M2"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X3, "TRIGGER_M3"),		/* TRIGGER_OUT */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(15, "GPIO15",
+			    THUNDERBAY_MUX(0X0, "UART1_M0"),		/* UART1_SIN */
+			    THUNDERBAY_MUX(0X1, "RT2_DSU_M1"),		/* RT2_DSU_TSTOP */
+			    THUNDERBAY_MUX(0X2, "EMPTY_M2"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X3, "TRIGGER_M3"),		/* TRIGGER_IN */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(16, "GPIO16",
+			    THUNDERBAY_MUX(0X0, "UART1_M0"),		/* UART1_CTS_N */
+			    THUNDERBAY_MUX(0X1, "RT3_DSU_M1"),		/* RT3_DSU_ACTIVE */
+			    THUNDERBAY_MUX(0X2, "EMPTY_M2"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X3, "EMPTY_M3"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(17, "GPIO17",
+			    THUNDERBAY_MUX(0X0, "UART1_M0"),		/* UART1_RTS_N */
+			    THUNDERBAY_MUX(0X1, "RT3_DSU_M1"),		/* RT3_DSU_TSTOP */
+			    THUNDERBAY_MUX(0X2, "EMPTY_M2"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X3, "EMPTY_M3"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(18, "GPIO18",
+			    THUNDERBAY_MUX(0X0, "SPI0_M0"),		/* SPI0_SCLK */
+			    THUNDERBAY_MUX(0X1, "EMPTY_M1"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X2, "EMPTY_M2"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X3, "EMPTY_M3"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(19, "GPIO19",
+			    THUNDERBAY_MUX(0X0, "SPI0_M0"),		/* SPI0_SS_0 */
+			    THUNDERBAY_MUX(0X1, "EMPTY_M1"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X2, "EMPTY_M2"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X3, "EMPTY_M3"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(20, "GPIO20",
+			    THUNDERBAY_MUX(0X0, "SPI0_M0"),		/* SPI0_DIO_0_MOSI */
+			    THUNDERBAY_MUX(0X1, "EMPTY_M1"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X2, "TPIU_TRACE_M2"),	/* TPIU_TRACECLK */
+			    THUNDERBAY_MUX(0X3, "EMPTY_M3"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(21, "GPIO21",
+			    THUNDERBAY_MUX(0X0, "SPI0_M0"),		/* SPI0_DIO_1_MISO */
+			    THUNDERBAY_MUX(0X1, "EMPTY_M1"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X2, "TPIU_TRACE_M2"),	/* TPIU_TRACECTL */
+			    THUNDERBAY_MUX(0X3, "EMPTY_M3"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(22, "GPIO22",
+			    THUNDERBAY_MUX(0X0, "SPI1_M0"),		/* SPI1_SCLK */
+			    THUNDERBAY_MUX(0X1, "EMPTY_M0"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X2, "EMPTY_M2"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X3, "EMPTY_M3"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(23, "GPIO23",
+			    THUNDERBAY_MUX(0X0, "SPI1_M0"),		/* SPI1_SS_0 */
+			    THUNDERBAY_MUX(0X1, "EMPTY_M1"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X2, "EMPTY_M2"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X3, "EMPTY_M3"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(24, "GPIO24",
+			    THUNDERBAY_MUX(0X0, "SPI1_M0"),		/* SPI1_DIO_0_MOSI */
+			    THUNDERBAY_MUX(0X1, "TPIU_TRACE_M1"),	/* TPIU_TRACECLK */
+			    THUNDERBAY_MUX(0X2, "EMPTY_M2"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X3, "EMPTY_M3"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(25, "GPIO25",
+			    THUNDERBAY_MUX(0X0, "SPI1_M0"),		/* SPI1_DIO_1_MISO */
+			    THUNDERBAY_MUX(0X1, "TPIU_TRACE_M1"),	/* TPIU_TRACECTL */
+			    THUNDERBAY_MUX(0X2, "EMPTY_M2"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X3, "EMPTY_M3"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(26, "GPIO26",
+			    THUNDERBAY_MUX(0X0, "ETHER0_M0"),		/* ETHER0_PHY_TXEN */
+			    THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"),	/* TPIU_DATA0 */
+			    THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"),	/* TPIU_DATA16 */
+			    THUNDERBAY_MUX(0X3, "DEBUG_M3"),		/* DEBUG_0 */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(27, "GPIO27",
+			    THUNDERBAY_MUX(0X0, "ETHER0_M0"),		/* ETHER0_GMII_CLK_TX */
+			    THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"),	/* TPIU_DATA1 */
+			    THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"),	/* TPIU_DATA17 */
+			    THUNDERBAY_MUX(0X3, "DEBUG_M3"),		/* DEBUG_1 */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(28, "GPIO28",
+			    THUNDERBAY_MUX(0X0, "ETHER0_M0"),		/* ETHER0_PHY_TXD_0 */
+			    THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"),	/* TPIU_DATA2 */
+			    THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"),	/* TPIU_DATA18 */
+			    THUNDERBAY_MUX(0X3, "DEBUG_M3"),		/* DEBUG_2 */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(29, "GPIO29",
+			    THUNDERBAY_MUX(0X0, "ETHER0_M0"),		/* ETHER0_PHY_TXD_1 */
+			    THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"),	/* TPIU_DATA3 */
+			    THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"),	/* TPIU_DATA19 */
+			    THUNDERBAY_MUX(0X3, "DEBUG_M3"),		/* DEBUG_3 */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(30, "GPIO30",
+			    THUNDERBAY_MUX(0X0, "ETHER0_M0"),		/* ETHER0_PHY_TXD_2 */
+			    THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"),	/* TPIU_DATA4 */
+			    THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"),	/* TPIU_DATA20 */
+			    THUNDERBAY_MUX(0X3, "DEBUG_M3"),		/* DEBUG_4 */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(31, "GPIO31",
+			    THUNDERBAY_MUX(0X0, "ETHER0_M0"),		/* ETHER0_PHY_TXD_3 */
+			    THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"),	/* TPIU_DATA5 */
+			    THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"),	/* TPIU_DATA21 */
+			    THUNDERBAY_MUX(0X3, "DEBUG_M3"),		/* DEBUG_5 */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(32, "GPIO32",
+			    THUNDERBAY_MUX(0X0, "ETHER0_M0"),		/* ETHER0_PHY_RXDV */
+			    THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"),	/* TPIU_DATA6 */
+			    THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"),	/* TPIU_DATA22 */
+			    THUNDERBAY_MUX(0X3, "DEBUG_M3"),		/* DEBUG_6 */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(33, "GPIO33",
+			    THUNDERBAY_MUX(0X0, "ETHER0_M0"),		/* ETHER0_GMII_CLK_RX */
+			    THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"),	/* TPIU_DATA7 */
+			    THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"),	/* TPIU_DATA23 */
+			    THUNDERBAY_MUX(0X3, "DEBUG_M3"),		/* DEBUG_7 */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(34, "GPIO34",
+			    THUNDERBAY_MUX(0X0, "ETHER0_M0"),		/* ETHER0_PHY_RXD_0 */
+			    THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"),	/* TPIU_DATA8 */
+			    THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"),	/* TPIU_DATA24 */
+			    THUNDERBAY_MUX(0X3, "DIG_VIEW_0"),		/* DIG_VIEW_0 */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(35, "GPIO35",
+			    THUNDERBAY_MUX(0X0, "ETHER0_M0"),		/* ETHER0_PHY_RXD_1 */
+			    THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"),	/* TPIU_DATA9 */
+			    THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"),	/* TPIU_DATA25 */
+			    THUNDERBAY_MUX(0X3, "DIG_VIEW_1"),		/* DIG_VIEW_1 */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(36, "GPIO36",
+			    THUNDERBAY_MUX(0X0, "ETHER0_M0"),		/* ETHER0_PHY_RXD_2 */
+			    THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"),	/* TPIU_DATA10 */
+			    THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"),	/* TPIU_DATA26 */
+			    THUNDERBAY_MUX(0X3, "CPR_IO_OUT_CLK_0"),	/* CPR_IO_OUT_CLK_0 */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(37, "GPIO37",
+			    THUNDERBAY_MUX(0X0, "ETHER0_M0"),		/* ETHER0_PHY_RXD_3 */
+			    THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"),	/* TPIU_DATA11 */
+			    THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"),	/* TPIU_DATA27 */
+			    THUNDERBAY_MUX(0X3, "CPR_IO_OUT_CLK_1"),	/* CPR_IO_OUT_CLK_1 */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(38, "GPIO38",
+			    THUNDERBAY_MUX(0X0, "ETHER0_M0"),		/* ETHER0_GMII_MDC */
+			    THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"),	/* TPIU_DATA12 */
+			    THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"),	/* TPIU_DATA28 */
+			    THUNDERBAY_MUX(0X3, "CPR_IO_OUT_CLK_2"),	/* CPR_IO_OUT_CLK_2 */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(39, "GPIO39",
+			    THUNDERBAY_MUX(0X0, "ETHER0_M0"),		/* ETHER0_GMII_MDIO */
+			    THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"),	/* TPIU_DATA13 */
+			    THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"),	/* TPIU_DATA29 */
+			    THUNDERBAY_MUX(0X3, "CPR_IO_OUT_CLK_3"),	/* CPR_IO_OUT_CLK_3 */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(40, "GPIO40",
+			    THUNDERBAY_MUX(0X0, "ETHER0_M0"),		/* ETHER0_PHY_INTR */
+			    THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"),	/* TPIU_DATA14 */
+			    THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"),	/* TPIU_DATA30 */
+			    THUNDERBAY_MUX(0X3, "EMPTY_M3"),		/* EMPTY_M3 */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(41, "GPIO41",
+			    THUNDERBAY_MUX(0X0, "POWER_INTERRUPT_MAX_PLATFORM_POWER_M0"),
+							/* POWER_INTERRUPT_MAX_PLATFORM_POWER */
+			    THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"),	/* TPIU_DATA15 */
+			    THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"),	/* TPIU_DATA31 */
+			    THUNDERBAY_MUX(0X3, "EMPTY_M3"),		/* EMPTY_M3 */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(42, "GPIO42",
+			    THUNDERBAY_MUX(0X0, "ETHER1_M0"),		/* ETHER1_PHY_TXEN */
+			    THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"),	/* TPIU_DATA16 */
+			    THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"),	/* TPIU_DATA0 */
+			    THUNDERBAY_MUX(0X3, "DEBUG_M3"),		/* DEBUG_0 */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(43, "GPIO43",
+			    THUNDERBAY_MUX(0X0, "ETHER1_M0"),		/* ETHER1_GMII_CLK_TX */
+			    THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"),	/* TPIU_DATA17 */
+			    THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"),	/* TPIU_DATA1 */
+			    THUNDERBAY_MUX(0X3, "DEBUG_M3"),		/* DEBUG_1 */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(44, "GPIO44",
+			    THUNDERBAY_MUX(0X0, "ETHER1_M0"),		/* ETHER1_PHY_TXD_0 */
+			    THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"),	/* TPIU_DATA18 */
+			    THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"),	/* TPIU_DATA2 */
+			    THUNDERBAY_MUX(0X3, "DEBUG_M3"),		/* DEBUG_2 */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(45, "GPIO45",
+			    THUNDERBAY_MUX(0X0, "ETHER1_M0"),		/* ETHER1_PHY_TXD_1 */
+			    THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"),	/* TPIU_DATA19 */
+			    THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"),	/* TPIU_DATA3 */
+			    THUNDERBAY_MUX(0X3, "DEBUG_M3"),		/* DEBUG_3 */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(46, "GPIO46",
+			    THUNDERBAY_MUX(0X0, "ETHER1_M0"),		/* ETHER1_PHY_TXD_2 */
+			    THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"),	/* TPIU_DATA20 */
+			    THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"),	/* TPIU_DATA4 */
+			    THUNDERBAY_MUX(0X3, "DEBUG_M3"),		/* DEBUG_4 */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(47, "GPIO47",
+			    THUNDERBAY_MUX(0X0, "ETHER1_M0"),		/* ETHER1_PHY_TXD_3 */
+			    THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"),	/* TPIU_DATA21 */
+			    THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"),	/* TPIU_DATA5 */
+			    THUNDERBAY_MUX(0X3, "DEBUG_M3"),		/* DEBUG_5 */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(48, "GPIO48",
+			    THUNDERBAY_MUX(0X0, "ETHER1_M0"),		/* ETHER1_PHY_RXDV */
+			    THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"),	/* TPIU_DATA22 */
+			    THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"),	/* TPIU_DATA6 */
+			    THUNDERBAY_MUX(0X3, "DEBUG_M3"),		/* DEBUG_6 */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(49, "GPIO49",
+			    THUNDERBAY_MUX(0X0, "ETHER1_M0"),		/* ETHER1_GMII_CLK_RX */
+			    THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"),	/* TPIU_DATA23 */
+			    THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"),	/* TPIU_DATA7 */
+			    THUNDERBAY_MUX(0X3, "DEBUG_M3"),		/* DEBUG_7 */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(50, "GPIO50",
+			    THUNDERBAY_MUX(0X0, "ETHER1_M0"),		/* ETHER1_PHY_RXD_0 */
+			    THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"),	/* TPIU_DATA24 */
+			    THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"),	/* TPIU_DATA8 */
+			    THUNDERBAY_MUX(0X3, "DIG_VIEW_0"),		/* DIG_VIEW_0 */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(51, "GPIO51",
+			    THUNDERBAY_MUX(0X0, "ETHER1_M0"),		/* ETHER1_PHY_RXD_1 */
+			    THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"),	/* TPIU_DATA25 */
+			    THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"),	/* TPIU_DATA9 */
+			    THUNDERBAY_MUX(0X3, "DIG_VIEW_1"),		/* DIG_VIEW_1 */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(52, "GPIO52",
+			    THUNDERBAY_MUX(0X0, "ETHER1_M0"),		/* ETHER1_PHY_RXD_2 */
+			    THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"),	/* TPIU_DATA26 */
+			    THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"),	/* TPIU_DATA10 */
+			    THUNDERBAY_MUX(0X3, "CPR_IO_OUT_CLK_0"),	/* CPR_IO_OUT_CLK_0 */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(53, "GPIO53",
+			    THUNDERBAY_MUX(0X0, "ETHER1_M0"),		/* ETHER1_PHY_RXD_3 */
+			    THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"),	/* TPIU_DATA27 */
+			    THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"),	/* TPIU_DATA11 */
+			    THUNDERBAY_MUX(0X3, "CPR_IO_OUT_CLK_1"),	/* CPR_IO_OUT_CLK_1 */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(54, "GPIO54",
+			    THUNDERBAY_MUX(0X0, "ETHER1_M0"),		/* ETHER1_GMII_MDC */
+			    THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"),	/* TPIU_DATA28 */
+			    THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"),	/* TPIU_DATA12 */
+			    THUNDERBAY_MUX(0X3, "CPR_IO_OUT_CLK_2"),	/* CPR_IO_OUT_CLK_2 */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(55, "GPIO55",
+			    THUNDERBAY_MUX(0X0, "ETHER1_M0"),		/* ETHER1_GMII_MDIO */
+			    THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"),	/* TPIU_DATA29 */
+			    THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"),	/* TPIU_DATA13 */
+			    THUNDERBAY_MUX(0X3, "CPR_IO_OUT_CLK_3"),	/* CPR_IO_OUT_CLK_3 */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(56, "GPIO56",
+			    THUNDERBAY_MUX(0X0, "ETHER1_M0"),		/* ETHER1_PHY_INTR */
+			    THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"),	/* TPIU_DATA30 */
+			    THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"),	/* TPIU_DATA14 */
+			    THUNDERBAY_MUX(0X3, "POWER_INTERRUPT_ICCMAX_VDDD_M3"),
+								/* POWER_INTERRUPT_ICCMAX_VDDD */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(57, "GPIO57",
+			    THUNDERBAY_MUX(0X0, "POWER_INTERRUPT_ICCMAX_VPU_M0"),
+								/* POWER_INTERRUPT_ICCMAX_VPU */
+			    THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"),	/* TPIU_DATA31 */
+			    THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"),	/* TPIU_DATA15 */
+			    THUNDERBAY_MUX(0X3, "EMPTY_M3"),		/* EMPTY_M3 */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(58, "GPIO58",
+			    THUNDERBAY_MUX(0X0, "THERMTRIP_M0"),	/* THERMTRIP_IN */
+			    THUNDERBAY_MUX(0X1, "EMPTY_M1"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X2, "EMPTY_M2"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X3, "EMPTY_M3"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(59, "GPIO59",
+			    THUNDERBAY_MUX(0X0, "THERMTRIP_M0"),	/* THERMTRIP_OUT */
+			    THUNDERBAY_MUX(0X1, "EMPTY_M1"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X2, "EMPTY_M2"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X3, "EMPTY_M3"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(60, "GPIO60",
+			    THUNDERBAY_MUX(0X0, "SMBUS_M0"),		/* SMBUS_SCL */
+			    THUNDERBAY_MUX(0X1, "EMPTY_M1"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X2, "EMPTY_M2"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X3, "EMPTY_M3"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(61, "GPIO61",
+			    THUNDERBAY_MUX(0X0, "SMBUS_M0"),		/* SMBUS_SDA */
+			    THUNDERBAY_MUX(0X1, "EMPTY_M1"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X2, "EMPTY_M2"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X3, "POWER_INTERRUPT_ICCMAX_VDDD_M3"),
+								/* POWER_INTERRUPT_ICCMAX_VDDD */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(62, "GPIO62",
+			    THUNDERBAY_MUX(0X0, "PLATFORM_RESET_M0"),	/* PLATFORM_RESET_IN */
+			    THUNDERBAY_MUX(0X1, "EMPTY_M1"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X2, "EMPTY_M2"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X3, "EMPTY_M3"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(63, "GPIO63",
+			    THUNDERBAY_MUX(0X0, "PLATFORM_RESET_M0"),	/* PLATFORM_RESET_OUT */
+			    THUNDERBAY_MUX(0X1, "EMPTY_M1"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X2, "EMPTY_M2"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X3, "EMPTY_M3"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(64, "GPIO64",
+			    THUNDERBAY_MUX(0X0, "PLATFORM_SHUTDOWN_M0"),/* PLATFORM_SHUTDOWN_IN */
+			    THUNDERBAY_MUX(0X1, "EMPTY_M1"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X2, "EMPTY_M2"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X3, "EMPTY_M3"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(65, "GPIO65",
+			    THUNDERBAY_MUX(0X0, "PLATFORM_SHUTDOWN_M0"),/* PLATFORM_SHUTDOWN_OUT */
+			    THUNDERBAY_MUX(0X1, "EMPTY_M1"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X2, "EMPTY_M2"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X3, "EMPTY_M3"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+	THUNDERBAY_PIN_DESC(66, "GPIO66",
+			    THUNDERBAY_MUX(0X0, "POWER_INTERRUPT_ICCMAX_MEDIA_M0"),
+								/* POWER_INTERRUPT_ICCMAX_MEDIA */
+			    THUNDERBAY_MUX(0X1, "EMPTY_M1"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X2, "EMPTY_M2"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X3, "EMPTY_M3"),		/* EMPTY */
+			    THUNDERBAY_MUX(0X4, "GPIO_M4")),		/* CPU_DIRECT_CONTROL */
+};
+
+static const struct thunderbay_pin_soc thunderbay_data = {
+	.pins	= thunderbay_pins,
+	.npins  = ARRAY_SIZE(thunderbay_pins),
+};
+
+/***************************************************************************************
+ * Private functions
+ *******************************************************************************/
+
+/*******************************************************************************
+ * Function name: thb_gpio_read_reg
+ * Description: Reads gpio configuration register
+ * Arg[0]: thunderbay specific gpio_chip structure address
+ * Arg[1]: pin number (0-66)
+ * Return value: gpio configuration register value
+ *******************************************************************************/
+static u32 thb_gpio_read_reg(struct gpio_chip *chip, unsigned int pinnr)
+{
+	struct thunderbay_pinctrl *tpc = gpiochip_get_data(chip);
+
+	return readl(tpc->base0 + THB_GPIO_REG_OFFSET(pinnr));
+}
+
+/*******************************************************************************
+ * Function name: thb_gpio_write_reg
+ * Description: Writes/updates gpio configuration register
+ * Arg[0]: thunderbay specific gpio_chip structure address
+ * Arg[1]: pin number (0-66)
+ * ARg[2]: Value to be updated in register
+ * Return value: 0u for success/ Negative value for failure
+ *******************************************************************************/
+static u32 thb_gpio_write_reg(struct gpio_chip *chip, unsigned int pinnr, u32 value)
+{
+	struct thunderbay_pinctrl *tpc = gpiochip_get_data(chip);
+
+	writel(value, (tpc->base0 + THB_GPIO_REG_OFFSET(pinnr)));
+
+	return 0;
+}
+
+/*******************************************************************************
+ * Function name: thb_read_gpio_data
+ * Description: Reads GPIO Data IN/OUT register
+ * Arg[0]: thunderbay specific gpio_chip structure address
+ * Arg[1]: pin number (0-66)
+ * ARg[2]: gpio pad direction (0-in; 1-out)
+ * Return value: GPIO Data IN/OUT register value
+ *******************************************************************************/
+static int thb_read_gpio_data(struct gpio_chip *chip, unsigned int offset, unsigned int pad_dir)
+{
+	int data_offset = 0x2000u;
+	int ret = -EINVAL;
+	u32 data_reg;
+
+	/* as per GPIO Spec = pad_dir 0:input, 1:output */
+	data_offset = ((pad_dir == 0u) ?
+			(data_offset + 0x4 + (offset / 32)) : (data_offset + (offset / 32)));
+
+	data_reg = thb_gpio_read_reg(chip, data_offset);
+
+	ret = (((data_reg & BIT(offset % 32)) > 0) ? 1 : 0);
+
+	return ret;
+}
+
+/*******************************************************************************
+ * Function name: thb_write_gpio_data
+ * Description: writes/updates GPIO Data IN/OUT register
+ * Arg[0]: thunderbay specific gpio_chip structure address
+ * Arg[1]: pin number (0-66)
+ * ARg[2]: Value to be updated in register
+ * Return value: 0u for success/Negative value for failure
+ *******************************************************************************/
+static int thb_write_gpio_data(struct gpio_chip *chip, unsigned int offset, unsigned int value)
+{
+	int data_offset = 0x2000u;
+	int ret = -EINVAL;
+	u32 data_reg;
+
+	data_offset += (offset / 32);
+
+	data_reg = thb_gpio_read_reg(chip, data_offset);
+
+	data_reg = ((value > 0u) ?
+			(data_reg | BIT(offset % 32)) : (data_reg & (~(BIT(offset % 32)))));
+
+	ret = thb_gpio_write_reg(chip, data_offset, data_reg);
+
+	return ret;
+}
+
+#if (THB_BOARD_SPECIFIC_GPIO_REQUIREMENTS_HANDLE)
+
+/*******************************************************************************
+ * Function name: thb_gpio_board_requirements_handle
+ * Description: updates required configurations based on THB Board need.
+ * Arg[0]: thunderbay specific gpio_chip structure address
+ * Return value: 0 - success / negative value for any error
+ *******************************************************************************/
+static u32 thb_gpio_board_requirements_handle(struct gpio_chip *chip)
+{
+	int eth_val = 0x001f0000;
+	u32 offset, reg = 0u;
+	int ret = -EINVAL;
+	int eth0_pin = 26;
+	int eth1_pin = 42;
+
+	/* 0x43 = register Offset for gpio_power_int_setup/4u */
+	offset = 0x43;
+	reg = thb_gpio_read_reg(chip, offset);
+
+	/* Keeping all power interrupts to Level-High triggered as suggested by HW team */
+	reg |= 0x1E;
+	ret = thb_gpio_write_reg(chip, offset, reg);
+
+	/* TODO: Once DTB supports Pinconfig entry, below code should be removed
+	 * Updating Drive-Strength for Ethernet pins
+	 */
+	for (eth0_pin = 26; eth0_pin < 32; eth0_pin++)
+		ret = thb_gpio_write_reg(chip, eth0_pin, eth_val);
+
+	for (eth1_pin = 42; eth1_pin < 48; eth1_pin++)
+		ret = thb_gpio_write_reg(chip, eth1_pin, eth_val);
+	return ret;
+}
+
+#endif
+
+/***********************************************************************************
+ * THB - GPIO Driver : Call back functions
+ ********************************************************************************/
+
+/*******************************************************************************
+ * Function name: thunderbay_gpio_get_direction
+ * Description: provides GPIO pad direction
+ * Arg[0]: thunderbay specific gpio_chip structure address
+ * Arg[1]: pin number (0-66)
+ * Return value: If pin is configured as GPIO : Return GPIO Pad direction
+ *               If pin is configured as PORT : Return Negative error
+ *******************************************************************************/
+static int thunderbay_gpio_get_direction(struct gpio_chip *chip, unsigned int offset)
+{
+	u32 reg = thb_gpio_read_reg(chip, offset);
+	int ret = -EINVAL;
+
+	/* Return direction only if configured as GPIO else negative error */
+	if (reg & THB_GPIO_PORT_SELECT_MASK)
+		ret = ((reg & THB_GPIO_PAD_DIRECTION_MASK) == 0) ? 1 : 0;
+	return ret;
+}
+
+/*******************************************************************************
+ * Function name: thunderbay_gpio_set_direction_input
+ * Description: update GPIO pad direction as INPUT
+ * Arg[0]: thunderbay specific gpio_chip structure address
+ * Arg[1]: pin number (0-66)
+ * Return value: If pin is configured as GPIO : Return 0u
+ *               If pin is configured as PORT : Negative error
+ *******************************************************************************/
+static int thunderbay_gpio_set_direction_input(struct gpio_chip *chip, unsigned int offset)
+{
+	u32 reg = thb_gpio_read_reg(chip, offset);
+	int ret = -EINVAL;
+
+	/* set pin as input only if it is GPIO else error */
+	if (reg & THB_GPIO_PORT_SELECT_MASK) {
+		reg &= (~THB_GPIO_PAD_DIRECTION_MASK);
+		thb_gpio_write_reg(chip, offset, reg);
+		ret = 0;
+	}
+	return ret;
+}
+
+/*******************************************************************************
+ * Function name: thunderbay_gpio_set_value
+ * Description: update GPIO DATA OUT value
+ * Arg[0]: thunderbay specific gpio_chip structure address
+ * Arg[1]: pin number (0-66)
+ * Arg[2]: output value (0/1)
+ * Return value: void
+ *******************************************************************************/
+static void thunderbay_gpio_set_value(struct gpio_chip *chip, unsigned int offset, int value)
+{
+	u32 reg = thb_gpio_read_reg(chip, offset);
+
+	/* update pin value only if it is GPIO-output else error */
+	if ((reg & THB_GPIO_PORT_SELECT_MASK) && (reg & THB_GPIO_PAD_DIRECTION_MASK))
+		thb_write_gpio_data(chip, offset, value);
+}
+
+/*******************************************************************************
+ * Function name: thunderbay_gpio_set_direction_output
+ * Description: update GPIO pad direction as output and its value
+ * Arg[0]: thunderbay specific gpio_chip structure address
+ * Arg[1]: pin number (0-66)
+ * Arg[2]: output value (0/1)
+ * Return value: If pin is configured as GPIO : Return 0u
+ *               If pin is configured as PORT : Negative error
+ *******************************************************************************/
+static int thunderbay_gpio_set_direction_output(struct gpio_chip *chip,
+						unsigned int offset, int value)
+{
+	u32 reg = thb_gpio_read_reg(chip, offset);
+	int ret = -EINVAL;
+
+	/* set pin as output only if it is GPIO else error */
+	if (reg & THB_GPIO_PORT_SELECT_MASK) {
+		reg |= THB_GPIO_PAD_DIRECTION_MASK;
+		thb_gpio_write_reg(chip, offset, reg);
+		thunderbay_gpio_set_value(chip, offset, value);
+		ret = 0;
+	}
+	return ret;
+}
+
+/*******************************************************************************
+ * Function name: thunderbay_gpio_get_value
+ * Description: provides GPIO DATA OUT/IN value
+ * Arg[0]: thunderbay specific gpio_chip structure address
+ * Arg[1]: pin number (0-66)
+ * Return value: If pin is configured as GPIO : Return GPIO DATA OUT/IN value (0/1)
+ *               If pin is configured as PORT : Return Negative error
+ *******************************************************************************/
+static int thunderbay_gpio_get_value(struct gpio_chip *chip, unsigned int offset)
+{
+	u32 reg = thb_gpio_read_reg(chip, offset);
+	int ret = -EINVAL;
+	int gpio_dir = 0;
+
+	/* Read pin value only if it is GPIO else error */
+	if (reg & THB_GPIO_PORT_SELECT_MASK) {
+		/* 0=in, 1=out */
+		gpio_dir = ((reg & THB_GPIO_PAD_DIRECTION_MASK) > 0) ? 1 : 0;
+		ret = thb_read_gpio_data(chip, offset, gpio_dir);
+	}
+	return ret;
+}
+
+/*******************************************************************************
+ * Function name: thunderbay_gpiochip_probe
+ * Description: gpio probe/init function to register THB gpio chip and
+ *              required call back functions with standard linux frame work.
+ * Arg[0]: thunderbay GPIO specific structure address
+ * Return value: 0u -> success / Negative value for any failure
+ *******************************************************************************/
+static int thunderbay_gpiochip_probe(struct thunderbay_pinctrl *tpc)
+{
+	struct gpio_chip *chip = &tpc->chip;
+	int ret;
+
+	chip->label		= dev_name(tpc->dev);
+	chip->parent		= tpc->dev;
+	chip->request		= gpiochip_generic_request;
+	chip->free		= gpiochip_generic_free;
+	chip->get_direction	= thunderbay_gpio_get_direction;
+	chip->direction_input	= thunderbay_gpio_set_direction_input;
+	chip->direction_output  = thunderbay_gpio_set_direction_output;
+	chip->get		= thunderbay_gpio_get_value;
+	chip->set               = thunderbay_gpio_set_value;
+	/* identifies the first GPIO number handled by this chip; or,
+	 * if negative during registration, requests dynamic ID allocation.
+	 * DEPRECATION: providing anything non-negative and nailing the
+	 * base offset of GPIO chips is deprecated.
+	 * Please pass -1 as base to let gpiolib select the chip base in all possible cases.
+	 * We want to get rid of the static GPIO number space in the long run.
+	 */
+	chip->base		= -1;
+	/* Number of GPIOs handled by this controller; the last GPIO handled is (base + ngpio - 1)*/
+	chip->ngpio		= THB_MAX_NPINS_SUPPORTED;
+
+	/* Register/add thb gpio chip with linux framework */
+	ret = gpiochip_add_data(chip, tpc);
+	if (ret) {
+		dev_err(tpc->dev, "Failed to add gpiochip\n");
+		return ret;
+	}
+
+	/* Register pin mapping between GPIO and PinControl */
+	ret = gpiochip_add_pin_range(chip, dev_name(tpc->dev), 0, 0, chip->ngpio);
+	if (ret) {
+		dev_err(tpc->dev, "Failed to add gpiochip pin range\n");
+		return ret;
+	}
+
+#if (THB_BOARD_SPECIFIC_GPIO_REQUIREMENTS_HANDLE)
+	/* function to handle THB board specific requirements */
+	ret = thb_gpio_board_requirements_handle(chip);
+#endif
+	return ret;
+}
+
+/************************************************************************************
+ * THB - PinCtrl Driver - PinMux : Call back functions
+ ********************************************************************************/
+
+/*******************************************************************************
+ * Function name: thunderbay_request_gpio
+ * Description: updates pin status as busy and keep pin in mode-4 (GPIO operation)
+ * Arg[0]: thunderbay specific pinctrl_dev structure address
+ * Arg[1]: pin range
+ * Arg[2]: pin number (0-66)
+ * Return value: 0u - for Success,
+ *               Negative value for any error.
+ *******************************************************************************/
+static int thunderbay_request_gpio(struct pinctrl_dev *pctldev,
+				   struct pinctrl_gpio_range *range,
+				   unsigned int pin)
+{
+	/* TODO: Proper usecase to be verified for conditions check
+	 * Low poer mode setup
+	 */
+
+	struct thunderbay_pinctrl *tpc = pinctrl_dev_get_drvdata(pctldev);
+	struct gpio_chip *chip = &tpc->chip;
+	int ret = -EINVAL;
+	u32 reg = 0;
+
+	if (thb_pinx_status[pin] == 0u) {
+		reg = thb_gpio_read_reg(chip, pin);
+		/* Updates PIN configuration as GPIO */
+		/* set the GPIO to MODE-4 */
+		reg |= (THB_GPIO_PORT_SELECT_MASK | THB_GPIO_PINMUX_MODE_4);
+
+	ret = thb_gpio_write_reg(chip, pin, reg);
+
+		if (~ret) {
+			/* update pin status as busy */
+			thb_pinx_status[pin] = 1u;
+		}
+	}
+	return ret;
+}
+
+/*******************************************************************************
+ * Function name: thunderbay_free_gpio
+ * Description: updates pin status as free and keep pin in mode-0 (default mode/Port function)
+ * Arg[0]: thunderbay specific pinctrl_dev structure address
+ * Arg[1]: pin range
+ * Arg[2]: pin number (0-66)
+ * Return value: 0u - for Success,
+ *               Negative value for any error.
+ *******************************************************************************/
+static void thunderbay_free_gpio(struct pinctrl_dev *pctldev,
+				 struct pinctrl_gpio_range *range,
+				 unsigned int pin)
+{
+	struct thunderbay_pinctrl *tpc = pinctrl_dev_get_drvdata(pctldev);
+	struct gpio_chip *chip = &tpc->chip;
+	int ret_val = -EINVAL;
+	u32 reg = 0;
+
+	if (thb_pinx_status[pin] == 1u) {
+		reg = thb_gpio_read_reg(chip, pin);
+
+		/* Updates PIN configuration from GPIO to PORT */
+		reg &= (~THB_GPIO_PORT_SELECT_MASK);
+
+		/* Change Port/gpio mode to default mode-0 */
+		reg &= (~THB_GPIO_PINMUX_MODE_4);
+
+		ret_val = thb_gpio_write_reg(chip, pin, reg);
+
+		if (~ret_val) {
+			/* update pin status as free */
+			thb_pinx_status[pin] = 0u;
+		}
+	}
+}
+
+/*******************************************************************************
+ * Function name: thb_pinctrl_set_mux
+ * Description: Configures pin for required port function/pin mux
+ * Arg[0]: thunderbay specific pinctrl_dev structure address
+ * Arg[1]: mux function selector
+ * Arg[2]: mux group selector
+ * Return value: 0u - for Success,
+ *               Negative value for any error.
+ *******************************************************************************/
+static int thb_pinctrl_set_mux(struct pinctrl_dev *pctldev,
+			       unsigned int func_select, unsigned int group_select)
+{
+	struct thunderbay_pinctrl *tpc = pinctrl_dev_get_drvdata(pctldev);
+	struct gpio_chip *chip = &tpc->chip;
+	struct function_desc *function;
+	unsigned int i, pin_mode;
+	struct group_desc *group;
+	int ret = -EINVAL;
+	u32 reg = 0u;
+
+	group = pinctrl_generic_get_group(pctldev, group_select);
+	if (!group)
+		return -EINVAL;
+
+	function = pinmux_generic_get_function(pctldev, func_select);
+	if (!function)
+		return -EINVAL;
+
+	pin_mode = *(unsigned int *)(function->data);
+
+	/* Change modes for pins in the selected group */
+	for (i = 0; i < group->num_pins; i++) {
+		reg = thb_gpio_read_reg(chip, group->pins[i]);
+
+		switch (pin_mode) {
+		case 0u:
+			reg |= THB_GPIO_PINMUX_MODE_0;
+			break;
+		case 1u:
+			reg |= THB_GPIO_PINMUX_MODE_1;
+			break;
+		case 2u:
+			reg |= THB_GPIO_PINMUX_MODE_2;
+			break;
+		case 3u:
+			reg |= THB_GPIO_PINMUX_MODE_3;
+			break;
+		case 4u:
+			reg |= THB_GPIO_PINMUX_MODE_4;
+			break;
+		default:
+			return -EINVAL;
+		}
+
+		ret = thb_gpio_write_reg(chip, group->pins[i], reg);
+
+		if (~ret) {
+			/* update pin status as busy */
+			thb_pinx_status[group->pins[i]] = 1u;
+		}
+	}
+	return ret;
+}
+
+/*******************************************************************************
+ * Function name: thunderbay_build_groups
+ * Description: add group of pins to support port function with generic framework
+ * Arg[0]: thunderbay specific pinctrl_dev structure address
+ * Return value: 0u - for Success,
+ *               Negative value for any error.
+ *******************************************************************************/
+static int thunderbay_build_groups(struct thunderbay_pinctrl *tpc)
+{
+	struct group_desc *thunderbay_groups;
+	int i;
+
+	tpc->ngroups = tpc->soc->npins;
+	thunderbay_groups = devm_kcalloc(tpc->dev, tpc->ngroups,
+					 sizeof(*thunderbay_groups), GFP_KERNEL);
+	if (!thunderbay_groups)
+		return -ENOMEM;
+
+	for (i = 0; i < tpc->ngroups; i++) {
+		struct group_desc *group = thunderbay_groups + i;
+		const struct pinctrl_pin_desc *pin_info = thunderbay_pins + i;
+
+		group->name = pin_info->name;
+		group->pins = (int *)&pin_info->number;
+		pinctrl_generic_add_group(tpc->pctrl, group->name,
+					  group->pins, 1, NULL);
+	}
+	return 0;
+}
+
+/*******************************************************************************
+ * Function name: thunderbay_add_functions
+ * Description: add group of functions supported with generic framework
+ * Arg[0]: thunderbay specific pinctrl_dev structure address
+ * Return value: 0u - for Success,
+ *               Negative value for any error.
+ *******************************************************************************/
+static int thunderbay_add_functions(struct thunderbay_pinctrl *tpc, struct function_desc *funcs)
+{
+	struct function_desc *function = funcs;
+	int i;
+
+	/* Assign the groups for each function */
+	for (i = 0; i < tpc->soc->npins; i++) {
+		const struct pinctrl_pin_desc *pin_info = thunderbay_pins + i;
+		struct thunderbay_mux_desc *pin_mux = pin_info->drv_data;
+
+		while (pin_mux->name) {
+			const char **grp;
+			int j, grp_num, match = 0;
+			size_t grp_size;
+			struct function_desc *func;
+
+			for (j = 0; j < tpc->nfuncs; j++) {
+				if (!strcmp(pin_mux->name, function[j].name)) {
+					match = 1;
+					break;
+				}
+			}
+
+			if (!match)
+				return -EINVAL;
+
+			func = function + j;
+			grp_num = func->num_group_names;
+			grp_size = sizeof(*func->group_names);
+
+			if (!func->group_names) {
+				func->group_names = devm_kcalloc(tpc->dev,
+								 grp_num,
+								 grp_size,
+								 GFP_KERNEL);
+				if (!func->group_names) {
+					kfree(func);
+					return -ENOMEM;
+				}
+			}
+
+			grp = func->group_names;
+			while (*grp)
+				grp++;
+
+			*grp = pin_info->name;
+			pin_mux++;
+		}
+	}
+
+	/* Add all functions */
+	for (i = 0; i < tpc->nfuncs; i++) {
+		pinmux_generic_add_function(tpc->pctrl,
+					    function[i].name,
+					    function[i].group_names,
+					    function[i].num_group_names,
+					    function[i].data);
+	}
+	return 0;
+}
+
+/*******************************************************************************
+ * Function name: thunderbay_build_functions
+ * Description: add group of functions supported with generic framework
+ * Arg[0]: thunderbay specific thunderbay_pinctrl structure address
+ * Return value: 0u - for Success,
+ *               Negative value for any error.
+ *******************************************************************************/
+static int thunderbay_build_functions(struct thunderbay_pinctrl *tpc)
+{
+	struct function_desc *thunderbay_funcs;
+	int i, err;
+	void *ptr;
+
+	/* Total number of functions is unknown at this point. Allocate first. */
+	tpc->nfuncs = 0;
+	thunderbay_funcs = kcalloc(tpc->soc->npins * 8,
+				   sizeof(*thunderbay_funcs), GFP_KERNEL);
+	if (!thunderbay_funcs)
+		return -ENOMEM;
+
+	/* Find total number of functions and each's properties */
+	for (i = 0; i < tpc->soc->npins; i++) {
+		const struct pinctrl_pin_desc *pin_info = thunderbay_pins + i;
+		struct thunderbay_mux_desc *pin_mux = pin_info->drv_data;
+
+		while (pin_mux->name) {
+			struct function_desc *func = thunderbay_funcs;
+
+			while (func->name) {
+				if (!strcmp(pin_mux->name, func->name)) {
+					func->num_group_names++;
+					break;
+				}
+
+				func++;
+			}
+
+			if (!func->name) {
+				func->name = pin_mux->name;
+				func->num_group_names = 1;
+				func->data = (int *)&pin_mux->mode;
+				tpc->nfuncs++;
+			}
+
+			pin_mux++;
+		}
+	}
+
+	/* Reallocate memory based on actual number of functions */
+	ptr = krealloc(thunderbay_funcs,
+		       tpc->nfuncs * sizeof(*thunderbay_funcs), GFP_KERNEL);
+	if (!ptr)
+		return -ENOMEM;
+
+	thunderbay_funcs = ptr;
+
+	err = thunderbay_add_functions(tpc, thunderbay_funcs);
+	if (err)
+		return -ENOMEM;
+
+	return 0;
+}
+
+/***********************************************************************************
+ * THB - PinCtrl Driver - PinConfig : Call back functions
+ ************************************************************************************/
+
+/*******************************************************************************
+ * Function name: thunderbay_pinconf_set_tristate
+ * Description: set pin to tri-state
+ * Arg[0]: thunderbay specific structure thunderbay_pinctrl address
+ * Arg[1]: pin number
+ * Arg[2]: required pin configuration
+ * Return value: 0u - for Success,
+ *               Negative value for any error.
+ *******************************************************************************/
+
+static int thunderbay_pinconf_set_tristate(struct thunderbay_pinctrl *tpc,
+					   unsigned int pin, u32 config)
+{
+	/* TODO: update with pre-Conditions to be checked
+	 * How/when to disable Tri-state
+	 */
+	struct gpio_chip *chip = &tpc->chip;
+	int ret = -EINVAL;
+	u32 reg = 0;
+
+	reg = thb_gpio_read_reg(chip, pin);
+	reg = (config > 0) ? (reg | THB_GPIO_ENAQ_MASK) : (reg & (~(THB_GPIO_ENAQ_MASK)));
+	ret = thb_gpio_write_reg(chip, pin, reg);
+
+	return ret;
+}
+
+/*******************************************************************************
+ * Function name: thunderbay_pinconf_get_tristate
+ * Description: provides pin tri-state status
+ * Arg[0]: thunderbay specific structure thunderbay_pinctrl address
+ * Arg[1]: pin number
+ * Arg[2]: address to update pin configuration
+ * Return value: 0u - for Success,
+ *               Negative value for any error.
+ *******************************************************************************/
+static int thunderbay_pinconf_get_tristate(struct thunderbay_pinctrl *tpc,
+					   unsigned int pin, u32 *config)
+{
+	/* TODO: update with pre-Conditions to be checked */
+	struct gpio_chip *chip = &tpc->chip;
+	u32 reg = 0;
+
+	reg = thb_gpio_read_reg(chip, pin);
+	*config = ((reg & THB_GPIO_ENAQ_MASK) > 0) ? 1 : 0;
+
+	return 0;
+}
+
+/*******************************************************************************
+ * Function name: thunderbay_pinconf_set_pulldown
+ * Description: Set pin pull-down
+ * Arg[0]: thunderbay specific structure thunderbay_pinctrl address
+ * Arg[1]: pin number
+ * Arg[2]: required pin configuration
+ * Return value: 0u - for Success,
+ *               Negative value for any error.
+ *******************************************************************************/
+static int thunderbay_pinconf_set_pulldown(struct thunderbay_pinctrl *tpc,
+					   unsigned int pin, u32 config)
+{
+	/* TODO: update with pre-Conditions to be checked
+	 * How/when to disable pulldown
+	 */
+	struct gpio_chip *chip = &tpc->chip;
+	int ret = -EINVAL;
+	u32 reg = 0;
+
+	reg = thb_gpio_read_reg(chip, pin);
+	reg = (config > 0) ? (reg | THB_GPIO_PULL_DOWN_MASK) : (reg & (~(THB_GPIO_PULL_DOWN_MASK)));
+	ret = thb_gpio_write_reg(chip, pin, reg);
+
+	return ret;
+}
+
+/*******************************************************************************
+ * Function name: thunderbay_pinconf_get_pulldown
+ * Description: Provides pin pull-down status
+ * Arg[0]: thunderbay specific structure thunderbay_pinctrl address
+ * Arg[1]: pin number
+ * Arg[2]: address to update pin configuration
+ * Return value: 0u - for Success,
+ *               Negative value for any error.
+ *******************************************************************************/
+static int thunderbay_pinconf_get_pulldown(struct thunderbay_pinctrl *tpc,
+					   unsigned int pin, u32 *config)
+{
+	/* TODO: update with pre-Conditions to be checked */
+	struct gpio_chip *chip = &tpc->chip;
+	u32 reg = 0;
+
+	reg = thb_gpio_read_reg(chip, pin);
+	*config = ((reg & THB_GPIO_PULL_DOWN_MASK) > 0) ? 1 : 0;
+
+	return 0;
+}
+
+/*******************************************************************************
+ * Function name: thunderbay_pinconf_set_pullup
+ * Description: Set pin pull-up
+ * Arg[0]: thunderbay specific structure thunderbay_pinctrl address
+ * Arg[1]: pin number
+ * Arg[2]: required pin configuration
+ * Return value: 0u - for Success,
+ *               Negative value for any error.
+ *******************************************************************************/
+static int thunderbay_pinconf_set_pullup(struct thunderbay_pinctrl *tpc,
+					 unsigned int pin, u32 config)
+{
+	/* TODO: update with pre-Conditions to be checked
+	 * How/when to disable pullup
+	 */
+	struct gpio_chip *chip = &tpc->chip;
+	int ret = -EINVAL;
+	u32 reg = 0;
+
+	reg = thb_gpio_read_reg(chip, pin);
+	reg = (config > 0) ? (reg & (~(THB_GPIO_PULL_UP_MASK))) : (reg | THB_GPIO_PULL_UP_MASK);
+	ret = thb_gpio_write_reg(chip, pin, reg);
+
+	return ret;
+}
+
+/*******************************************************************************
+ * Function name: thunderbay_pinconf_get_pullup
+ * Description: Provides pin pull-up status
+ * Arg[0]: thunderbay specific structure thunderbay_pinctrl address
+ * Arg[1]: pin number
+ * Arg[2]: address to update pin configuration
+ * Return value: 0u - for Success,
+ *               Negative value for any error.
+ *******************************************************************************/
+static int thunderbay_pinconf_get_pullup(struct thunderbay_pinctrl *tpc,
+					 unsigned int pin, u32 *config)
+{
+	/* TODO: update with pre-Conditions to be checked */
+	struct gpio_chip *chip = &tpc->chip;
+	u32 reg = 0;
+
+	reg = thb_gpio_read_reg(chip, pin);
+	*config = ((reg & THB_GPIO_PULL_UP_MASK) == 0) ? 1 : 0;
+
+	return 0;
+}
+
+/*******************************************************************************
+ * Function name: thunderbay_pinconf_set_opendrain
+ * Description: Set pin open-drain
+ * Arg[0]: thunderbay specific structure thunderbay_pinctrl address
+ * Arg[1]: pin number
+ * Arg[2]: required pin configuration
+ * Return value: 0u - for Success,
+ *               Negative value for any error.
+ *******************************************************************************/
+static int thunderbay_pinconf_set_opendrain(struct thunderbay_pinctrl *tpc,
+					    unsigned int pin, u32 config)
+{
+	/* TODO: update with pre-Conditions to be checked
+	 * How/when to disable opendrain
+	 */
+	struct gpio_chip *chip = &tpc->chip;
+	int ret = -EINVAL;
+	u32 reg = 0;
+
+	reg = thb_gpio_read_reg(chip, pin);
+
+	reg = (config > 0) ?
+		(reg & (~(THB_GPIO_PULL_ENABLE_MASK))) : (reg | THB_GPIO_PULL_ENABLE_MASK);
+
+	ret = thb_gpio_write_reg(chip, pin, reg);
+
+	return ret;
+}
+
+/*******************************************************************************
+ * Function name: thunderbay_pinconf_get_opendrain
+ * Description: Provides pin open-drain status
+ * Arg[0]: thunderbay specific structure thunderbay_pinctrl address
+ * Arg[1]: pin number
+ * Arg[2]: address to update pin configuration
+ * Return value: 0u - for Success,
+ *               Negative value for any error.
+ *******************************************************************************/
+static int thunderbay_pinconf_get_opendrain(struct thunderbay_pinctrl *tpc,
+					    unsigned int pin, u32 *config)
+{
+	/* TODO: update with pre-Conditions to be checked */
+	struct gpio_chip *chip = &tpc->chip;
+	u32 reg = 0;
+
+	reg = thb_gpio_read_reg(chip, pin);
+	*config = ((reg & THB_GPIO_PULL_ENABLE_MASK) == 0) ? 1 : 0;
+
+	return 0;
+}
+
+/*******************************************************************************
+ * Function name: thunderbay_pinconf_set_pushpull
+ * Description: Set pin push-pull
+ * Arg[0]: thunderbay specific structure thunderbay_pinctrl address
+ * Arg[1]: pin number
+ * Arg[2]: required pin configuration
+ * Return value: 0u - for Success,
+ *               Negative value for any error.
+ *******************************************************************************/
+static int thunderbay_pinconf_set_pushpull(struct thunderbay_pinctrl *tpc,
+					   unsigned int pin, u32 config)
+{
+	/* TODO: update with pre-Conditions to be checked
+	 * How/when to disable pushpull
+	 */
+	struct gpio_chip *chip = &tpc->chip;
+	int ret = -EINVAL;
+	u32 reg = 0;
+
+	reg = thb_gpio_read_reg(chip, pin);
+	reg = (config > 0) ?
+		(reg | THB_GPIO_PULL_ENABLE_MASK) : (reg & (~(THB_GPIO_PULL_ENABLE_MASK)));
+
+	ret = thb_gpio_write_reg(chip, pin, reg);
+
+	return ret;
+}
+
+/*******************************************************************************
+ * Function name: thunderbay_pinconf_get_opendrain
+ * Description: Provides pin push-pull status
+ * Arg[0]: thunderbay specific structure thunderbay_pinctrl address
+ * Arg[1]: pin number
+ * Arg[2]: address to update pin configuration
+ * Return value: 0u - for Success,
+ *               Negative value for any error.
+ *******************************************************************************/
+static int thunderbay_pinconf_get_pushpull(struct thunderbay_pinctrl *tpc,
+					   unsigned int pin, u32 *config)
+{
+	/* TODO: update with pre-Conditions to be checked */
+	struct gpio_chip *chip = &tpc->chip;
+	u32 reg = 0;
+
+	reg = thb_gpio_read_reg(chip, pin);
+	*config = ((reg & THB_GPIO_PULL_ENABLE_MASK) > 0) ? 1 : 0;
+
+	return 0;
+}
+
+/*******************************************************************************
+ * Function name: thunderbay_pinconf_set_drivestrength
+ * Description: Set pin drive-strength
+ * Arg[0]: thunderbay specific structure thunderbay_pinctrl address
+ * Arg[1]: pin number
+ * Arg[2]: required pin configuration
+ * Return value: 0u - for Success,
+ *               Negative value for any error.
+ *******************************************************************************/
+static int thunderbay_pinconf_set_drivestrength(struct thunderbay_pinctrl *tpc,
+						unsigned int pin, u32 config)
+{
+	/* TODO: update with pre-Conditions to be checked
+	 * How/when to disable drivestrength
+	 */
+	struct gpio_chip *chip = &tpc->chip;
+	int ret = -EINVAL;
+	u32 reg = 0;
+
+	reg = thb_gpio_read_reg(chip, pin);
+
+	if (config <= 0xF) {
+		reg = (reg | config);
+		ret = thb_gpio_write_reg(chip, pin, reg);
+	}
+
+	return ret;
+}
+
+/*******************************************************************************
+ * Function name: thunderbay_pinconf_get_drivestrength
+ * Description: Provides pin drive-strength status
+ * Arg[0]: thunderbay specific structure thunderbay_pinctrl address
+ * Arg[1]: pin number
+ * Arg[2]: address to update pin configuration
+ * Return value: 0u - for Success,
+ *               Negative value for any error.
+ *******************************************************************************/
+static int thunderbay_pinconf_get_drivestrength(struct thunderbay_pinctrl *tpc,
+						unsigned int pin, u32 *config)
+{
+	/* TODO: update with pre-Conditions to be checked */
+	struct gpio_chip *chip = &tpc->chip;
+	u32 reg = 0;
+
+	reg = thb_gpio_read_reg(chip, pin);
+	reg = (reg & THB_GPIO_DRIVE_STRENGTH_MASK) >> 16;
+	*config = (reg > 0) ? reg : 0;
+
+	return 0;
+}
+
+/*******************************************************************************
+ * Function name: thunderbay_pinconf_set_schmitt
+ * Description: Set pin schmitt-trigger
+ * Arg[0]: thunderbay specific structure thunderbay_pinctrl address
+ * Arg[1]: pin number
+ * Arg[2]: required pin configuration
+ * Return value: 0u - for Success,
+ *               Negative value for any error.
+ *******************************************************************************/
+static int thunderbay_pinconf_set_schmitt(struct thunderbay_pinctrl *tpc,
+					  unsigned int pin, u32 config)
+{
+	/* TODO: update with pre-Conditions to be checked
+	 * How/when to disable schmitt trigger
+	 */
+	struct gpio_chip *chip = &tpc->chip;
+	int ret = -EINVAL;
+	u32 reg = 0;
+
+	reg = thb_gpio_read_reg(chip, pin);
+	reg = (config > 0) ? (reg | THB_GPIO_SCHMITT_TRIGGER_MASK) :
+				(reg & (~(THB_GPIO_SCHMITT_TRIGGER_MASK)));
+	ret = thb_gpio_write_reg(chip, pin, reg);
+
+	return ret;
+}
+
+/*******************************************************************************
+ * Function name: thunderbay_pinconf_get_schmitt
+ * Description: Provides pin schmitt-trigger status
+ * Arg[0]: thunderbay specific structure thunderbay_pinctrl address
+ * Arg[1]: pin number
+ * Arg[2]: address to update pin configuration
+ * Return value: 0u - for Success,
+ *               Negative value for any error.
+ *******************************************************************************/
+static int thunderbay_pinconf_get_schmitt(struct thunderbay_pinctrl *tpc,
+					  unsigned int pin, u32 *config)
+{
+	/* TODO: update with pre-Conditions to be checked */
+	struct gpio_chip *chip = &tpc->chip;
+	u32 reg = 0;
+
+	reg = thb_gpio_read_reg(chip, pin);
+	*config = ((reg & THB_GPIO_SCHMITT_TRIGGER_MASK) > 0) ? 1 : 0;
+
+	return 0;
+}
+
+/*******************************************************************************
+ * Function name: thunderbay_pinconf_set_slew_rate
+ * Description: Set pin slewrate
+ * Arg[0]: thunderbay specific structure thunderbay_pinctrl address
+ * Arg[1]: pin number
+ * Arg[2]: required pin configuration
+ * Return value: 0u - for Success,
+ *               Negative value for any error.
+ *******************************************************************************/
+static int thunderbay_pinconf_set_slew_rate(struct thunderbay_pinctrl *tpc,
+					    unsigned int pin, u32 config)
+{
+	/* TODO: update with pre-Conditions to be checked
+	 * How/when to disable slew_rate
+	 */
+	struct gpio_chip *chip = &tpc->chip;
+	int ret = -EINVAL;
+	u32 reg = 0;
+
+	reg = thb_gpio_read_reg(chip, pin);
+	reg = (config > 0) ? (reg | THB_GPIO_SLEW_RATE_MASK) : (reg & (~(THB_GPIO_SLEW_RATE_MASK)));
+	ret = thb_gpio_write_reg(chip, pin, reg);
+
+	return ret;
+}
+
+/*******************************************************************************
+ * Function name: thunderbay_pinconf_get_slew_rate
+ * Description: Provides pin slewrate status
+ * Arg[0]: thunderbay specific structure thunderbay_pinctrl address
+ * Arg[1]: pin number
+ * Arg[2]: address to update pin configuration
+ * Return value: 0u - for Success,
+ *               Negative value for any error.
+ *******************************************************************************/
+static int thunderbay_pinconf_get_slew_rate(struct thunderbay_pinctrl *tpc,
+					    unsigned int pin, u32 *config)
+{
+	/* TODO: update with pre-Conditions to be checked */
+	struct gpio_chip *chip = &tpc->chip;
+	u32 reg = 0;
+
+	reg = thb_gpio_read_reg(chip, pin);
+	*config = ((reg & THB_GPIO_SLEW_RATE_MASK) > 0) ? 1 : 0;
+
+	return 0;
+}
+
+/*******************************************************************************
+ * Function name: thunderbay_pinconf_get
+ * Description: Provides required pin configuration status
+ * Arg[0]: thunderbay specific structure pinctrl_dev address
+ * Arg[1]: pin number
+ * Arg[2]: address to update pin configuration
+ * Return value: 0u - for Success,
+ *               Negative value for any error.
+ *******************************************************************************/
+static int thunderbay_pinconf_get(struct pinctrl_dev *pctldev, unsigned int pin,
+				  unsigned long *config)
+{
+	struct thunderbay_pinctrl *tpc = pinctrl_dev_get_drvdata(pctldev);
+	enum pin_config_param param = pinconf_to_config_param(*config);
+	u32 arg;
+	int ret;
+
+	switch (param) {
+	case PIN_CONFIG_BIAS_HIGH_IMPEDANCE:
+		ret = thunderbay_pinconf_get_tristate(tpc, pin, &arg);
+		break;
+
+	case PIN_CONFIG_BIAS_PULL_DOWN:
+		ret = thunderbay_pinconf_get_pulldown(tpc, pin, &arg);
+		break;
+
+	case PIN_CONFIG_BIAS_PULL_UP:
+		ret = thunderbay_pinconf_get_pullup(tpc, pin, &arg);
+		break;
+
+	case PIN_CONFIG_DRIVE_OPEN_DRAIN:
+		ret = thunderbay_pinconf_get_opendrain(tpc, pin, &arg);
+		break;
+
+	case PIN_CONFIG_DRIVE_PUSH_PULL:
+		ret = thunderbay_pinconf_get_pushpull(tpc, pin, &arg);
+		break;
+
+	case PIN_CONFIG_DRIVE_STRENGTH:
+		ret = thunderbay_pinconf_get_drivestrength(tpc, pin, &arg);
+		break;
+
+	case PIN_CONFIG_INPUT_SCHMITT_ENABLE:
+		ret = thunderbay_pinconf_get_schmitt(tpc, pin, &arg);
+		break;
+
+	case PIN_CONFIG_SLEW_RATE:
+		ret = thunderbay_pinconf_get_slew_rate(tpc, pin, &arg);
+		break;
+
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	*config = pinconf_to_config_packed(param, arg);
+
+	return ret;
+}
+
+/*******************************************************************************
+ * Function name: thunderbay_pinconf_set
+ * Description: Set required pin configuration
+ * Arg[0]: thunderbay specific structure pinctrl_dev address
+ * Arg[1]: pin number
+ * Arg[2]: address to update pin configuration
+ * Arg[3]: number of configurations
+ * Return value: 0u - for Success,
+ *               Negative value for any error.
+ *******************************************************************************/
+static int thunderbay_pinconf_set(struct pinctrl_dev *pctldev, unsigned int pin,
+				  unsigned long *configs, unsigned int num_configs)
+{
+	struct thunderbay_pinctrl *tpc = pinctrl_dev_get_drvdata(pctldev);
+	enum pin_config_param param;
+	unsigned int pinconf;
+	int ret = 0;
+	u32 arg;
+
+	for (pinconf = 0; pinconf < num_configs; pinconf++) {
+		param = pinconf_to_config_param(configs[pinconf]);
+		arg = pinconf_to_config_argument(configs[pinconf]);
+
+		switch (param) {
+		case PIN_CONFIG_BIAS_HIGH_IMPEDANCE:
+			ret = thunderbay_pinconf_set_tristate(tpc, pin, arg);
+			break;
+
+		case PIN_CONFIG_BIAS_PULL_DOWN:
+			ret = thunderbay_pinconf_set_pulldown(tpc, pin, arg);
+			break;
+
+		case PIN_CONFIG_BIAS_PULL_UP:
+			ret = thunderbay_pinconf_set_pullup(tpc, pin, arg);
+			break;
+
+		case PIN_CONFIG_DRIVE_OPEN_DRAIN:
+			ret = thunderbay_pinconf_set_opendrain(tpc, pin, arg);
+			break;
+
+		case PIN_CONFIG_DRIVE_PUSH_PULL:
+			ret = thunderbay_pinconf_set_pushpull(tpc, pin, arg);
+			break;
+
+		case PIN_CONFIG_DRIVE_STRENGTH:
+			ret = thunderbay_pinconf_set_drivestrength(tpc, pin, arg);
+			break;
+
+		case PIN_CONFIG_INPUT_SCHMITT_ENABLE:
+			ret = thunderbay_pinconf_set_schmitt(tpc, pin, arg);
+			break;
+
+		case PIN_CONFIG_SLEW_RATE:
+			ret = thunderbay_pinconf_set_slew_rate(tpc, pin, arg);
+			break;
+
+		default:
+			return -EOPNOTSUPP;
+		}
+	}
+	return ret;
+}
+
+/***********************************************************************************
+ * Register/assign pin control operations
+ *********************************************************************************/
+
+static const struct pinctrl_ops thunderbay_pctlops = {
+	.get_groups_count = pinctrl_generic_get_group_count,
+	.get_group_name   = pinctrl_generic_get_group_name,
+	.get_group_pins   = pinctrl_generic_get_group_pins,
+	.dt_node_to_map   = pinconf_generic_dt_node_to_map_all,
+	.dt_free_map	  = pinconf_generic_dt_free_map,
+};
+
+static const struct pinmux_ops thunderbay_pmxops = {
+	.get_functions_count	= pinmux_generic_get_function_count,
+	.get_function_name	= pinmux_generic_get_function_name,
+	.get_function_groups	= pinmux_generic_get_function_groups,
+	.set_mux		= thb_pinctrl_set_mux,
+	.gpio_request_enable	= thunderbay_request_gpio,
+	.gpio_disable_free	= thunderbay_free_gpio,
+};
+
+static const struct pinconf_ops thunderbay_confops = {
+	.is_generic		= true,
+	.pin_config_get		= thunderbay_pinconf_get,
+	.pin_config_set		= thunderbay_pinconf_set,
+};
+
+static struct pinctrl_desc thunderbay_pinctrl_desc = {
+	.name		= "thunderbay-pinmux",
+	.pctlops	= &thunderbay_pctlops,
+	.pmxops		= &thunderbay_pmxops,
+	.confops	= &thunderbay_confops,
+	.owner		= THIS_MODULE,
+};
+
+static const struct of_device_id thunderbay_pinctrl_match[] = {
+{	.compatible = "intel,thunderbay-pinctrl",
+	.data = &thunderbay_data},
+	{},
+};
+
+/*******************************************************************************
+ * Function name: thunderbay_pinctrl_probe
+ * Description: Pinctrl probe/init function to register THB pincontrol chip and
+ *              required call back functions with standard linux frame work.
+ * Arg[0]: thunderbay specific structure platform_device address
+ * Return value: 0u -> success / Negative value for any failure
+ *******************************************************************************/
+static int thunderbay_pinctrl_probe(struct platform_device *pdev)
+{
+	const struct of_device_id *of_id;
+	struct device *dev = &pdev->dev;
+	struct thunderbay_pinctrl *tpc;
+	struct resource *iomem;
+	int ret;
+
+	of_id = of_match_node(thunderbay_pinctrl_match, pdev->dev.of_node);
+	if (!of_id)
+		return -ENODEV;
+
+	tpc = devm_kzalloc(dev, sizeof(*tpc), GFP_KERNEL);
+	if (!tpc)
+		return -ENOMEM;
+
+	tpc->dev = dev;
+	tpc->soc = of_id->data;
+
+	iomem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!iomem)
+		return -ENXIO;
+
+	tpc->base0 =  devm_ioremap_resource(dev, iomem);
+	if (IS_ERR(tpc->base0))
+		return PTR_ERR(tpc->base0);
+
+	thunderbay_pinctrl_desc.pins = tpc->soc->pins;
+	thunderbay_pinctrl_desc.npins = tpc->soc->npins;
+
+	/* Register pinctrl */
+	tpc->pctrl = devm_pinctrl_register(dev, &thunderbay_pinctrl_desc, tpc);
+	if (IS_ERR(tpc->pctrl))
+		return PTR_ERR(tpc->pctrl);
+
+	/* Setup pinmux groups */
+	ret = thunderbay_build_groups(tpc);
+	if (ret)
+		return ret;
+
+	/* Setup pinmux functions */
+	ret = thunderbay_build_functions(tpc);
+	if (ret)
+		return ret;
+
+	/* Setup GPIO */
+	ret = thunderbay_gpiochip_probe(tpc);
+	if (ret < 0)
+		return ret;
+
+	platform_set_drvdata(pdev, tpc);
+
+	return 0;
+}
+
+/**********************************************************************
+ * Function: thunderbay_pinctrl_remove
+ * Arg-0: pdev - Platform device instance
+ * Arg-1: NA
+ * Return: 0 Always
+ * Description: Thunderbay pinctrl driver removal/exit.
+ **********************************************************************/
+static int thunderbay_pinctrl_remove(struct platform_device *pdev)
+{
+	/* thunderbay_pinctrl_remove function to clear the assigned memory */
+	return 0;
+}
+
+static struct platform_driver thunderbay_pinctrl_driver = {
+	.driver = {
+		.name = "thunderbay-pinctrl",
+		.of_match_table = thunderbay_pinctrl_match,
+	},
+	.probe = thunderbay_pinctrl_probe,
+	.remove = thunderbay_pinctrl_remove,
+};
+
+builtin_platform_driver(thunderbay_pinctrl_driver);
+
+MODULE_AUTHOR("D, Lakshmi Sowjanya <lakshmi.sowjanya.d@intel.com>");
+MODULE_AUTHOR("S, Kiran Kumar <kiran.kumar1.s@intel.com>");
+MODULE_DESCRIPTION("Intel Thunderbay PinCtrl/Gpio Driver");
+MODULE_LICENSE("GPL v2");
-- 
2.27.0

