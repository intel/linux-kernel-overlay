From bed0a49a4c0016eaa4b19a7cb510cc7bdd96f48a Mon Sep 17 00:00:00 2001
From: Huang Rui <ray.huang@amd.com>
Date: Fri, 15 Jan 2021 15:59:08 +0800
Subject: [PATCH 0977/1087] drm/amdgpu: fix build error without x86 kconfig
 (v2)

This patch is to fix below build error while we are using the kconfig
without x86.

drivers/gpu/drm/amd/amdgpu/../pm/swsmu/smu11/vangogh_ppt.c: In function
'vangogh_get_smu_metrics_data':
drivers/gpu/drm/amd/amdgpu/../pm/swsmu/smu11/vangogh_ppt.c:300:10:
error: 'boot_cpu_data' undeclared (first use in this function); did you
mean 'boot_cpuid'?
  300 |          boot_cpu_data.x86_max_cores * sizeof(uint16_t));
      |          ^~~~~~~~~~~~~
      |          boot_cpuid
drivers/gpu/drm/amd/amdgpu/../pm/swsmu/smu11/vangogh_ppt.c: In function
'vangogh_read_sensor':
drivers/gpu/drm/amd/amdgpu/../pm/swsmu/smu11/vangogh_ppt.c:1320:11:
error: 'boot_cpu_data' undeclared (first use in this function); did you
mean 'boot_cpuid'?
 1320 |   *size = boot_cpu_data.x86_max_cores * sizeof(uint16_t);
      |           ^~~~~~~~~~~~~
      |           boot_cpuid
drivers/gpu/drm/amd/amdgpu/../pm/swsmu/smu11/vangogh_ppt.c: In function
'vangogh_od_edit_dpm_table':
drivers/gpu/drm/amd/amdgpu/../pm/swsmu/smu11/vangogh_ppt.c:1460:19:
error: 'boot_cpu_data' undeclared (first use in this function); did you
mean 'boot_cpuid'?
 1460 |   if (input[0] >= boot_cpu_data.x86_max_cores) {
      |                   ^~~~~~~~~~~~~
      |                   boot_cpuid

v2: fix #ifdef and add comment for APU only

Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
Signed-off-by: Huang Rui <ray.huang@amd.com>
Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
---
 drivers/gpu/drm/amd/pm/amdgpu_pm.c              |  4 ++--
 drivers/gpu/drm/amd/pm/inc/amdgpu_smu.h         |  2 ++
 .../gpu/drm/amd/pm/swsmu/smu11/vangogh_ppt.c    | 17 ++++++++++++-----
 3 files changed, 16 insertions(+), 7 deletions(-)

diff --git a/drivers/gpu/drm/amd/pm/amdgpu_pm.c b/drivers/gpu/drm/amd/pm/amdgpu_pm.c
index 80d6298912aa..e9b569b76716 100644
--- a/drivers/gpu/drm/amd/pm/amdgpu_pm.c
+++ b/drivers/gpu/drm/amd/pm/amdgpu_pm.c
@@ -3633,12 +3633,12 @@ static void amdgpu_debugfs_prints_cpu_info(struct seq_file *m,
 	int i;
 
 	if (is_support_cclk_dpm(adev)) {
-		p_val = kcalloc(boot_cpu_data.x86_max_cores, sizeof(uint16_t),
+		p_val = kcalloc(adev->smu.cpu_core_num, sizeof(uint16_t),
 				GFP_KERNEL);
 
 		if (!amdgpu_dpm_read_sensor(adev, AMDGPU_PP_SENSOR_CPU_CLK,
 					    (void *)p_val, &size)) {
-			for (i = 0; i < boot_cpu_data.x86_max_cores; i++)
+			for (i = 0; i < adev->smu.cpu_core_num; i++)
 				seq_printf(m, "\t%u MHz (CPU%d)\n",
 					   *(p_val + i), i);
 		}
diff --git a/drivers/gpu/drm/amd/pm/inc/amdgpu_smu.h b/drivers/gpu/drm/amd/pm/inc/amdgpu_smu.h
index 25ee9f51813b..a087e00382e6 100644
--- a/drivers/gpu/drm/amd/pm/inc/amdgpu_smu.h
+++ b/drivers/gpu/drm/amd/pm/inc/amdgpu_smu.h
@@ -466,11 +466,13 @@ struct smu_context
 	uint32_t gfx_actual_hard_min_freq;
 	uint32_t gfx_actual_soft_max_freq;
 
+	/* APU only */
 	uint32_t cpu_default_soft_min_freq;
 	uint32_t cpu_default_soft_max_freq;
 	uint32_t cpu_actual_soft_min_freq;
 	uint32_t cpu_actual_soft_max_freq;
 	uint32_t cpu_core_id_select;
+	uint16_t cpu_core_num;
 };
 
 struct i2c_adapter;
diff --git a/drivers/gpu/drm/amd/pm/swsmu/smu11/vangogh_ppt.c b/drivers/gpu/drm/amd/pm/swsmu/smu11/vangogh_ppt.c
index 2f0cb0ea243b..dc41abe7b1d3 100644
--- a/drivers/gpu/drm/amd/pm/swsmu/smu11/vangogh_ppt.c
+++ b/drivers/gpu/drm/amd/pm/swsmu/smu11/vangogh_ppt.c
@@ -297,7 +297,7 @@ static int vangogh_get_smu_metrics_data(struct smu_context *smu,
 		break;
 	case METRICS_AVERAGE_CPUCLK:
 		memcpy(value, &metrics->CoreFrequency[0],
-		       boot_cpu_data.x86_max_cores * sizeof(uint16_t));
+		       smu->cpu_core_num * sizeof(uint16_t));
 		break;
 	default:
 		*value = UINT_MAX;
@@ -335,6 +335,13 @@ static int vangogh_init_smc_tables(struct smu_context *smu)
 	if (ret)
 		return ret;
 
+#ifdef CONFIG_X86
+	/* AMD x86 APU only */
+	smu->cpu_core_num = boot_cpu_data.x86_max_cores;
+#else
+	smu->cpu_core_num = 4;
+#endif
+
 	return smu_v11_0_init_smc_tables(smu);
 }
 
@@ -1317,7 +1324,7 @@ static int vangogh_read_sensor(struct smu_context *smu,
 		ret = vangogh_get_smu_metrics_data(smu,
 						   METRICS_AVERAGE_CPUCLK,
 						   (uint32_t *)data);
-		*size = boot_cpu_data.x86_max_cores * sizeof(uint16_t);
+		*size = smu->cpu_core_num * sizeof(uint16_t);
 		break;
 	default:
 		ret = -EOPNOTSUPP;
@@ -1457,9 +1464,9 @@ static int vangogh_od_edit_dpm_table(struct smu_context *smu, enum PP_OD_DPM_TAB
 			dev_err(smu->adev->dev, "Input parameter number not correct (should be 4 for processor)\n");
 			return -EINVAL;
 		}
-		if (input[0] >= boot_cpu_data.x86_max_cores) {
+		if (input[0] >= smu->cpu_core_num) {
 			dev_err(smu->adev->dev, "core index is overflow, should be less than %d\n",
-				boot_cpu_data.x86_max_cores);
+				smu->cpu_core_num);
 		}
 		smu->cpu_core_id_select = input[0];
 		if (input[1] == 0) {
@@ -1535,7 +1542,7 @@ static int vangogh_od_edit_dpm_table(struct smu_context *smu, enum PP_OD_DPM_TAB
 				break;
 			}
 
-			for (i = 0; i < boot_cpu_data.x86_max_cores; i++) {
+			for (i = 0; i < smu->cpu_core_num; i++) {
 				ret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_SetSoftMinCclk,
 								      (i << 20) | smu->cpu_actual_soft_min_freq,
 								      NULL);
-- 
2.17.1

