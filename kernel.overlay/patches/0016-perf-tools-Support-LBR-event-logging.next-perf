From 4d0e7497464c624492f47ae148422ac7e81d77a5 Mon Sep 17 00:00:00 2001
From: Jin Yao <yao.jin@linux.intel.com>
Date: Tue, 11 May 2021 13:47:47 +0800
Subject: [PATCH 16/47] perf tools: Support LBR event logging

(
TODO:
- Split the patch
- For a :B group, the tool will force the first 4 members on the first 4
counters.
- Error handling
)

This is based on Kan's patch in perf-intel-next:
commit: 0dc6d165afe7("perf tools: Support LBR event logging")

Just rebase it to 5.13-rc1.

Signed-off-by: Jin Yao <yao.jin@linux.intel.com>
---
 tools/include/uapi/linux/perf_event.h     |  7 +++++--
 tools/perf/Documentation/perf-list.txt    |  1 +
 tools/perf/builtin-script.c               | 19 +++++++++++++------
 tools/perf/util/branch.h                  |  3 ++-
 tools/perf/util/evsel.h                   |  1 +
 tools/perf/util/parse-events.c            |  6 ++++++
 tools/perf/util/perf_event_attr_fprintf.c |  1 +
 tools/perf/util/session.c                 |  3 ++-
 8 files changed, 31 insertions(+), 10 deletions(-)

diff --git a/tools/include/uapi/linux/perf_event.h b/tools/include/uapi/linux/perf_event.h
index f92880a15645..2f19aa16b843 100644
--- a/tools/include/uapi/linux/perf_event.h
+++ b/tools/include/uapi/linux/perf_event.h
@@ -409,7 +409,8 @@ struct perf_event_attr {
 				inherit_thread :  1, /* children only inherit if cloned with CLONE_THREAD */
 				remove_on_exec :  1, /* event is removed from task on exec */
 				sigtrap        :  1, /* send synchronous SIGTRAP on event */
-				__reserved_1   : 26;
+				branch_events  :  1, /* include branch events */
+				__reserved_1   : 25;
 
 	union {
 		__u32		wakeup_events;	  /* wakeup every n events */
@@ -1310,6 +1311,7 @@ union perf_mem_data_src {
 #define PERF_MEM_S(a, s) \
 	(((__u64)PERF_MEM_##a##_##s) << PERF_MEM_##a##_SHIFT)
 
+#define PERF_MAX_BRANCH_EVENTS	4
 /*
  * single taken branch record layout:
  *
@@ -1335,7 +1337,8 @@ struct perf_branch_entry {
 		abort:1,    /* transaction abort */
 		cycles:16,  /* cycle count to last branch */
 		type:4,     /* branch type */
-		reserved:40;
+		events:8,   /* TODO: */
+		reserved:32;
 };
 
 union perf_sample_weight {
diff --git a/tools/perf/Documentation/perf-list.txt b/tools/perf/Documentation/perf-list.txt
index 4c7db1da8fcc..c5a7deb2fa89 100644
--- a/tools/perf/Documentation/perf-list.txt
+++ b/tools/perf/Documentation/perf-list.txt
@@ -59,6 +59,7 @@ counted. The following modifiers exist:
  D - pin the event to the PMU
  W - group is weak and will fallback to non-group if not schedulable,
  e - group or event are exclusive and do not share the PMU
+ B - Record LBR event log
 
 The 'p' modifier can be used for specifying how precise the instruction
 address should be. The 'p' modifier can be specified multiple times:
diff --git a/tools/perf/builtin-script.c b/tools/perf/builtin-script.c
index 1280cbfad4db..4cb875410644 100644
--- a/tools/perf/builtin-script.c
+++ b/tools/perf/builtin-script.c
@@ -881,11 +881,12 @@ static int perf_sample__fprintf_brstack(struct perf_sample *sample,
 			printed += fprintf(fp, ")");
 		}
 
-		printed += fprintf(fp, "/%c/%c/%c/%d ",
+		printed += fprintf(fp, "/%c/%c/%c/%d/0x%x ",
 			mispred_str(entries + i),
 			entries[i].flags.in_tx ? 'X' : '-',
 			entries[i].flags.abort ? 'A' : '-',
-			entries[i].flags.cycles);
+			entries[i].flags.cycles,
+			entries[i].flags.events);
 	}
 
 	return printed;
@@ -927,11 +928,12 @@ static int perf_sample__fprintf_brstacksym(struct perf_sample *sample,
 			printed += map__fprintf_dsoname(alt.map, fp);
 			printed += fprintf(fp, ")");
 		}
-		printed += fprintf(fp, "/%c/%c/%c/%d ",
+		printed += fprintf(fp, "/%c/%c/%c/%d/0x%x ",
 			mispred_str(entries + i),
 			entries[i].flags.in_tx ? 'X' : '-',
 			entries[i].flags.abort ? 'A' : '-',
-			entries[i].flags.cycles);
+			entries[i].flags.cycles,
+			entries[i].flags.events);
 	}
 
 	return printed;
@@ -977,11 +979,12 @@ static int perf_sample__fprintf_brstackoff(struct perf_sample *sample,
 			printed += map__fprintf_dsoname(alt.map, fp);
 			printed += fprintf(fp, ")");
 		}
-		printed += fprintf(fp, "/%c/%c/%c/%d ",
+		printed += fprintf(fp, "/%c/%c/%c/%d/0x%x ",
 			mispred_str(entries + i),
 			entries[i].flags.in_tx ? 'X' : '-',
 			entries[i].flags.abort ? 'A' : '-',
-			entries[i].flags.cycles);
+			entries[i].flags.cycles,
+			entries[i].flags.events);
 	}
 
 	return printed;
@@ -1122,6 +1125,10 @@ static int ip__fprintf_jump(uint64_t ip, struct branch_entry *en,
 		if (insn)
 			printed += fprintf(fp, " %.2f IPC", (float)insn / en->flags.cycles);
 	}
+
+	if (en->flags.events)
+		printed += fprintf(fp, " events log 0x%x", en->flags.events);
+
 	return printed + fprintf(fp, "\n");
 }
 
diff --git a/tools/perf/util/branch.h b/tools/perf/util/branch.h
index 17b2ccc61094..2feab4d86f7d 100644
--- a/tools/perf/util/branch.h
+++ b/tools/perf/util/branch.h
@@ -24,7 +24,8 @@ struct branch_flags {
 			u64 abort:1;
 			u64 cycles:16;
 			u64 type:4;
-			u64 reserved:40;
+			u64 events:8;
+			u64 reserved:32;
 		};
 	};
 };
diff --git a/tools/perf/util/evsel.h b/tools/perf/util/evsel.h
index bdad52a06438..f22fe037a2a9 100644
--- a/tools/perf/util/evsel.h
+++ b/tools/perf/util/evsel.h
@@ -82,6 +82,7 @@ struct evsel {
 		bool			auto_merge_stats;
 		bool			collect_stat;
 		bool			weak_group;
+		bool			branch_events;
 		bool			bpf_counter;
 		bool			use_config_name;
 		int			bpf_fd;
diff --git a/tools/perf/util/parse-events.c b/tools/perf/util/parse-events.c
index 84108c17f48d..1b48dd310236 100644
--- a/tools/perf/util/parse-events.c
+++ b/tools/perf/util/parse-events.c
@@ -1866,6 +1866,7 @@ struct event_modifier {
 	int weak;
 	int exclusive;
 	int bpf_counter;
+	int branch_events;
 };
 
 static int get_event_modifier(struct event_modifier *mod, char *str,
@@ -1887,6 +1888,7 @@ static int get_event_modifier(struct event_modifier *mod, char *str,
 	int exclude_GH = evsel ? evsel->exclude_GH : 0;
 	int weak = 0;
 	int bpf_counter = 0;
+	int branch_events = 0;
 
 	memset(mod, 0, sizeof(*mod));
 
@@ -1932,6 +1934,8 @@ static int get_event_modifier(struct event_modifier *mod, char *str,
 			weak = 1;
 		} else if (*str == 'b') {
 			bpf_counter = 1;
+		} else if (*str == 'B') {
+			branch_events = 1;
 		} else
 			break;
 
@@ -1965,6 +1969,7 @@ static int get_event_modifier(struct event_modifier *mod, char *str,
 	mod->weak = weak;
 	mod->bpf_counter = bpf_counter;
 	mod->exclusive = exclusive;
+	mod->branch_events = branch_events;
 
 	return 0;
 }
@@ -2020,6 +2025,7 @@ int parse_events__modifier_event(struct list_head *list, char *str, bool add)
 		evsel->precise_max         = mod.precise_max;
 		evsel->weak_group	   = mod.weak;
 		evsel->bpf_counter	   = mod.bpf_counter;
+		evsel->branch_events	   = mod.branch_events;
 
 		if (evsel__is_group_leader(evsel)) {
 			evsel->core.attr.pinned = mod.pinned;
diff --git a/tools/perf/util/perf_event_attr_fprintf.c b/tools/perf/util/perf_event_attr_fprintf.c
index 30481825515b..faeff8d0c531 100644
--- a/tools/perf/util/perf_event_attr_fprintf.c
+++ b/tools/perf/util/perf_event_attr_fprintf.c
@@ -151,6 +151,7 @@ int perf_event_attr__fprintf(FILE *fp, struct perf_event_attr *attr,
 	PRINT_ATTRf(sample_max_stack, p_unsigned);
 	PRINT_ATTRf(aux_sample_size, p_unsigned);
 	PRINT_ATTRf(text_poke, p_unsigned);
+	PRINT_ATTRf(branch_events, p_unsigned);
 
 	return ret;
 }
diff --git a/tools/perf/util/session.c b/tools/perf/util/session.c
index e59242c361ce..3af8852a8a2c 100644
--- a/tools/perf/util/session.c
+++ b/tools/perf/util/session.c
@@ -1144,13 +1144,14 @@ static void branch_stack__printf(struct perf_sample *sample, bool callstack)
 		struct branch_entry *e = &entries[i];
 
 		if (!callstack) {
-			printf("..... %2"PRIu64": %016" PRIx64 " -> %016" PRIx64 " %hu cycles %s%s%s%s %x\n",
+			printf("..... %2"PRIu64": %016" PRIx64 " -> %016" PRIx64 " %hu cycles %s%s%s%s0x%x %x\n",
 				i, e->from, e->to,
 				(unsigned short)e->flags.cycles,
 				e->flags.mispred ? "M" : " ",
 				e->flags.predicted ? "P" : " ",
 				e->flags.abort ? "A" : " ",
 				e->flags.in_tx ? "T" : " ",
+				e->flags.events,
 				(unsigned)e->flags.reserved);
 		} else {
 			printf("..... %2"PRIu64": %016" PRIx64 "\n",
-- 
2.27.0

