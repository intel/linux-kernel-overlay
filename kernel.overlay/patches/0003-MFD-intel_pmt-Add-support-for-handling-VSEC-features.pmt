From 1cdee1c24a00011d3e3aa9d917f93cd6128f956e Mon Sep 17 00:00:00 2001
From: "David E. Box" <david.e.box@linux.intel.com>
Date: Sun, 7 Mar 2021 17:31:16 -0800
Subject: [PATCH 3/3] MFD: intel_pmt: Add support for handling VSEC features

PCIe Vendor Specific Extended Capabiliy (VSEC or VNDR) is also used by
Intel to describe support for extended features. VSEC features can also
reside on the same PCI device as DVSEC features. Adds supports generic
platform device support.

Signed-off-by: David E. Box <david.e.box@linux.intel.com>
---
 drivers/mfd/intel_pmt.c | 86 ++++++++++++++++++++++++++++++++---------
 1 file changed, 68 insertions(+), 18 deletions(-)

diff --git a/drivers/mfd/intel_pmt.c b/drivers/mfd/intel_pmt.c
index e3583ba4c4ed..e2a48d98e16d 100644
--- a/drivers/mfd/intel_pmt.c
+++ b/drivers/mfd/intel_pmt.c
@@ -26,13 +26,14 @@
 #define INTEL_DVSEC_TABLE_OFFSET(x)	((x) & GENMASK(31, 3))
 
 /* Intel Extended Features */
-#define DVSEC_INTEL_ID_TELEMETRY	2
-#define DVSEC_INTEL_ID_WATCHER		3
-#define DVSEC_INTEL_ID_CRASHLOG		4
+#define INTEL_EXT_ID_TELEMETRY		2
+#define INTEL_EXT_ID_WATCHER		3
+#define INTEL_EXT_ID_CRASHLOG		4
 
 #define FEATURE_ID_NAME_LENGTH		16
 
-struct intel_dvsec_header {
+struct intel_ext_header {
+	bool	is_vsec;
 	u8	rev;
 	u16	length;
 	u16	id;
@@ -43,9 +44,9 @@ struct intel_dvsec_header {
 };
 
 static int intel_ext_feature_allow_list[] = {
-	DVSEC_INTEL_ID_TELEMETRY,
-	DVSEC_INTEL_ID_WATCHER,
-	DVSEC_INTEL_ID_CRASHLOG,
+	INTEL_EXT_ID_TELEMETRY,
+	INTEL_EXT_ID_WATCHER,
+	INTEL_EXT_ID_CRASHLOG,
 };
 
 enum pmt_quirks {
@@ -64,7 +65,7 @@ enum pmt_quirks {
 
 struct pmt_platform_info {
 	unsigned long quirks;
-	struct intel_dvsec_header **capabilities;
+	struct intel_ext_header **capabilities;
 };
 
 static const struct pmt_platform_info tgl_info = {
@@ -73,7 +74,7 @@ static const struct pmt_platform_info tgl_info = {
 };
 
 /* DG1 Platform with DVSEC quirk*/
-static struct intel_dvsec_header dg1_telemetry = {
+static struct intel_ext_header dg1_telemetry = {
 	.length = 0x10,
 	.id = 2,
 	.num_entries = 1,
@@ -82,7 +83,7 @@ static struct intel_dvsec_header dg1_telemetry = {
 	.offset = 0x466000,
 };
 
-static struct intel_dvsec_header *dg1_capabilities[] = {
+static struct intel_ext_header *dg1_capabilities[] = {
 	&dg1_telemetry,
 	NULL
 };
@@ -97,12 +98,12 @@ static bool pmt_feature_disabled(u16 id, unsigned long quirks)
 	bool ret;
 
 	switch (id) {
-	case DVSEC_INTEL_ID_WATCHER:
+	case INTEL_EXT_ID_WATCHER:
 		if (quirks & PMT_QUIRK_NO_WATCHER)
 			ret = true;
 		break;
 
-	case DVSEC_INTEL_ID_CRASHLOG:
+	case INTEL_EXT_ID_CRASHLOG:
 		if (quirks & PMT_QUIRK_NO_CRASHLOG)
 			ret = true;
 		break;
@@ -126,13 +127,14 @@ static bool intel_ext_feature_allowed(u16 id)
 	return false;
 }
 
-static int pmt_add_dev(struct pci_dev *pdev, struct intel_dvsec_header *header,
+static int pmt_add_dev(struct pci_dev *pdev, struct intel_ext_header *header,
 		       unsigned long quirks)
 {
 	struct device *dev = &pdev->dev;
 	struct resource *res, *tmp;
 	struct mfd_cell *cell;
 	char feature_id_name[FEATURE_ID_NAME_LENGTH];
+	const char *cap_name;
 	int count = header->num_entries;
 	int size = header->entry_size;
 	int id = header->id;
@@ -144,7 +146,9 @@ static int pmt_add_dev(struct pci_dev *pdev, struct intel_dvsec_header *header,
 	if (pmt_feature_disabled(id, quirks))
 		return -EINVAL;
 
-	snprintf(feature_id_name, sizeof(feature_id_name), "intel-dvsec-%d", id);
+	cap_name = header->is_vsec ? "vsec" : "dvsec";
+	snprintf(feature_id_name, sizeof(feature_id_name), "intel-%s-%d",
+		 cap_name, id);
 
 	if (!header->num_entries || !header->entry_size) {
 		dev_err(dev, "Invalid count or size for %s header\n", feature_id_name);
@@ -188,7 +192,7 @@ static int pmt_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	struct pmt_platform_info *info;
 	unsigned long quirks = 0;
 	bool found_devices = false;
-	int ret, pos = 0;
+	int ret, pos;
 
 	ret = pcim_enable_device(pdev);
 	if (ret)
@@ -200,7 +204,7 @@ static int pmt_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 		quirks = info->quirks;
 
 	if (info && (info->quirks & PMT_QUIRK_NO_DVSEC)) {
-		struct intel_dvsec_header **header;
+		struct intel_ext_header **header;
 
 		header = info->capabilities;
 		while (*header) {
@@ -215,8 +219,10 @@ static int pmt_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 			++header;
 		}
 	} else {
+		/* Find DVSEC features */
+		pos = 0;
 		do {
-			struct intel_dvsec_header header;
+			struct intel_ext_header header;
 			u32 table, hdr;
 			u16 vid;
 
@@ -228,11 +234,12 @@ static int pmt_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 			vid = PCI_DVSEC_HEADER_VID(hdr);
 			if (vid != PCI_VENDOR_ID_INTEL)
 				continue;
+			header.is_vsec = false;
 
 			pci_read_config_word(pdev, pos + PCI_DVSEC_HEADER2, &header.id);
 
 			/* Support only revision 1 */
-			header.rev = PCI_VNDR_HEADER_REV(hdr);
+			header.rev = PCI_DVSEC_HEADER_REV(hdr);
 			if (header.rev != 1) {
 				dev_warn(&pdev->dev, "Unsupported DVSEC revision %d\n",
 					 header.rev);
@@ -257,6 +264,49 @@ static int pmt_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 
 			found_devices = true;
 		} while (true);
+
+		/* Find VSEC features */
+		pos = 0;
+		do {
+			struct intel_ext_header header;
+			u32 table, hdr;
+
+			pos = pci_find_next_ext_capability(pdev, pos, PCI_EXT_CAP_ID_VNDR);
+			if (!pos)
+				break;
+			header.is_vsec = true;
+
+			pci_read_config_dword(pdev, pos + PCI_VNDR_HEADER, &hdr);
+
+			/* Support only revision 1 */
+			header.rev = PCI_VNDR_HEADER_REV(hdr);
+			if (header.rev != 1) {
+				dev_warn(&pdev->dev, "Unsupported VSEC revision %d\n",
+					 header.rev);
+				continue;
+			}
+
+			header.id = PCI_VNDR_HEADER_ID(hdr);
+			header.length = PCI_VNDR_HEADER_LEN(hdr);
+
+			/* entry, size, and table offset are the same as DVSEC */
+			pci_read_config_byte(pdev, pos + INTEL_DVSEC_ENTRIES,
+					     &header.num_entries);
+			pci_read_config_byte(pdev, pos + INTEL_DVSEC_SIZE,
+					     &header.entry_size);
+			pci_read_config_dword(pdev, pos + INTEL_DVSEC_TABLE,
+					      &table);
+
+			header.tbir = INTEL_DVSEC_TABLE_BAR(table);
+			header.offset = INTEL_DVSEC_TABLE_OFFSET(table);
+
+			ret = pmt_add_dev(pdev, &header, quirks);
+			if (ret)
+				continue;
+
+			found_devices = true;
+		} while (true);
+
 	}
 
 	if (!found_devices)
-- 
2.27.0

