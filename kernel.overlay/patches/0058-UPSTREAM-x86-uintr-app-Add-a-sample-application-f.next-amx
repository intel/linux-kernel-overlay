From 37d52f7fa9bb5e07bb8e85b89ef5eb58309be00a Mon Sep 17 00:00:00 2001
From: Sohil Mehta <sohil.mehta@intel.com>
Date: Mon, 23 Nov 2020 14:17:59 -0800
Subject: [PATCH 58/94] !UPSTREAM: x86/uintr/app: Add a sample application for
 user IPI

Add a sample application to showcase user IPI usage.

<This sample is also included in the manpage for uintr related syscalls.
Eventually planning to move this to /samples.>

Signed-off-by: Sohil Mehta <sohil.mehta@intel.com>
---
 tools/uintr/Makefile      | 22 +++++++++
 tools/uintr/README        |  9 ++++
 tools/uintr/uipi_sample.c | 94 +++++++++++++++++++++++++++++++++++++++
 3 files changed, 125 insertions(+)
 create mode 100644 tools/uintr/Makefile
 create mode 100644 tools/uintr/README
 create mode 100644 tools/uintr/uipi_sample.c

diff --git a/tools/uintr/Makefile b/tools/uintr/Makefile
new file mode 100644
index 000000000000..2dbe1e5f412a
--- /dev/null
+++ b/tools/uintr/Makefile
@@ -0,0 +1,22 @@
+CC		= $(CROSS_COMPILE)gcc
+BUILD_OUTPUT	:= $(CURDIR)
+PREFIX		?= /usr
+DESTDIR		?=
+
+ifeq ("$(origin O)", "command line")
+	BUILD_OUTPUT := $(O)
+endif
+
+uipi_sample : uipi_sample.c
+
+CFLAGS +=       -Wall -g -O0 -ggdb -static -muintr -mgeneral-regs-only -minline-all-stringops
+LDFLAGS +=      -lpthread
+%: %.c
+	@mkdir -p $(BUILD_OUTPUT)
+	$(CC) $(CFLAGS) $< $(LDFLAGS) -o $(BUILD_OUTPUT)/$@
+
+all: uipi_sample
+
+.PHONY : clean
+clean :
+	@rm -f $(BUILD_OUTPUT)/uipi_sample
diff --git a/tools/uintr/README b/tools/uintr/README
new file mode 100644
index 000000000000..33216939c156
--- /dev/null
+++ b/tools/uintr/README
@@ -0,0 +1,9 @@
+====Build====
+Need custom gcc and binutils with user interrupt support
+
+====Run====
+$./uipi_sample
+Receiver enabled interrupts
+Sending IPI from sender thread
+        -- User Interrupt handler --
+Success
diff --git a/tools/uintr/uipi_sample.c b/tools/uintr/uipi_sample.c
new file mode 100644
index 000000000000..41f605d74b93
--- /dev/null
+++ b/tools/uintr/uipi_sample.c
@@ -0,0 +1,94 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (c) 2020, Intel Corporation.
+ *
+ * Sohil Mehta <sohil.mehta@intel.com>
+ */
+#define _GNU_SOURCE
+#include <pthread.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <syscall.h>
+#include <unistd.h>
+#include <x86gprintrin.h>
+
+#define __NR_uintr_register_handler	447
+#define __NR_uintr_unregister_handler	448
+#define __NR_uintr_create_fd		449
+#define __NR_uintr_register_sender	450
+#define __NR_uintr_unregister_sender	451
+
+/* For simiplicity, until glibc support is added */
+#define uintr_register_handler(handler, flags)	syscall(__NR_uintr_register_handler, handler, flags)
+#define uintr_unregister_handler(flags)		syscall(__NR_uintr_unregister_handler, flags)
+#define uintr_create_fd(vector, flags)		syscall(__NR_uintr_create_fd, vector, flags)
+#define uintr_register_sender(fd, flags)	syscall(__NR_uintr_register_sender, fd, flags)
+#define uintr_unregister_sender(fd, flags)	syscall(__NR_uintr_unregister_sender, fd, flags)
+
+unsigned int uintr_received;
+unsigned int uintr_fd;
+
+void __attribute__ ((interrupt)) uintr_handler(struct __uintr_frame *ui_frame,
+					       unsigned long long vector)
+{
+	static const char print[] = "\t-- User Interrupt handler --\n";
+
+	write(STDOUT_FILENO, print, sizeof(print) - 1);
+	uintr_received = 1;
+}
+
+void *sender_thread(void *arg)
+{
+	int uipi_index;
+
+	uipi_index = uintr_register_sender(uintr_fd, 0);
+	if (uipi_index < 0) {
+		printf("Sender register error\n");
+		exit(EXIT_FAILURE);
+	}
+
+	printf("Sending IPI from sender thread\n");
+	_senduipi(uipi_index);
+
+	uintr_unregister_sender(uintr_fd, 0);
+
+	return NULL;
+}
+
+int main(int argc, char *argv[])
+{
+	pthread_t pt;
+	int ret;
+
+	if (uintr_register_handler(uintr_handler, 0)) {
+		printf("Interrupt handler register error\n");
+		exit(EXIT_FAILURE);
+	}
+
+	ret = uintr_create_fd(0, 0);
+	if (ret < 0) {
+		printf("Interrupt vector allocation error\n");
+		exit(EXIT_FAILURE);
+	}
+
+	uintr_fd = ret;
+
+	_stui();
+	printf("Receiver enabled interrupts\n");
+
+	if (pthread_create(&pt, NULL, &sender_thread, NULL)) {
+		printf("Error creating sender thread\n");
+		exit(EXIT_FAILURE);
+	}
+
+	/* Do some other work */
+	while (!uintr_received)
+		usleep(1);
+
+	pthread_join(pt, NULL);
+	close(uintr_fd);
+	uintr_unregister_handler(0);
+
+	printf("Success\n");
+	exit(EXIT_SUCCESS);
+}
-- 
2.27.0

