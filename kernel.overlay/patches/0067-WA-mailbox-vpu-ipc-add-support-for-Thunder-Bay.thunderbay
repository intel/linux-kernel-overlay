From a981babd2f5c73855ac4433e02087042f0663fd5 Mon Sep 17 00:00:00 2001
From: "Pan, Kris" <kris.pan@intel.com>
Date: Thu, 10 Jun 2021 17:01:10 +0800
Subject: [PATCH 067/170] [WA] mailbox & vpu-ipc: add support for Thunder Bay

Signed-off-by: Pan, Kris <kris.pan@intel.com>
---
 drivers/mailbox/Kconfig                  |  2 +-
 drivers/soc/intel/Kconfig                |  2 +-
 drivers/soc/intel/keembay-vpu-ipc-core.c | 74 +++++++++++++++---------
 3 files changed, 48 insertions(+), 30 deletions(-)

diff --git a/drivers/mailbox/Kconfig b/drivers/mailbox/Kconfig
index ad340008544f..0cfd28e0dd13 100644
--- a/drivers/mailbox/Kconfig
+++ b/drivers/mailbox/Kconfig
@@ -42,7 +42,7 @@ config INTEL_KEEMBAY_IPC_MBOX
 	tristate "Intel Keem Bay IPC Mailbox"
 	depends on HAS_IOMEM
 	depends on OF || COMPILE_TEST
-	depends on ARCH_KEEMBAY || COMPILE_TEST
+	depends on ARCH_KEEMBAY || ARCH_THUNDERBAY || COMPILE_TEST
 	help
 	  Mailbox implementation for enabling inter-processor communication
 	  between the application processor and the VPU on the Intel Keem Bay
diff --git a/drivers/soc/intel/Kconfig b/drivers/soc/intel/Kconfig
index 0e6c3eb3699b..f706e8ccbc2e 100644
--- a/drivers/soc/intel/Kconfig
+++ b/drivers/soc/intel/Kconfig
@@ -8,7 +8,7 @@ menu "Intel SoC drivers"
 config KEEMBAY_VPU_IPC
 	tristate "Intel Keem Bay VPU IPC Driver"
 	depends on INTEL_KEEMBAY_IPC_MBOX
-	depends on ARCH_KEEMBAY || (ARM64 && COMPILE_TEST)
+	depends on ARCH_KEEMBAY || ARCH_THUNDERBAY || (ARM64 && COMPILE_TEST)
 	depends on HAVE_ARM_SMCCC
 	help
 	  This option enables support for loading and communicating with
diff --git a/drivers/soc/intel/keembay-vpu-ipc-core.c b/drivers/soc/intel/keembay-vpu-ipc-core.c
index 027c54a4520b..75a249bff531 100644
--- a/drivers/soc/intel/keembay-vpu-ipc-core.c
+++ b/drivers/soc/intel/keembay-vpu-ipc-core.c
@@ -345,6 +345,9 @@ struct vpu_ipc_dev {
 	struct clk			*pll[NUM_PLLS][NUM_PLL_OUTPUTS];
 	int				nce_irq;
 	int				mss_irq;
+	u32 nce_wdt_redirect;
+	u32 mss_wdt_redirect;
+	u32 imr;
 	u32				vpu_id;
 	void __iomem			*nce_wdt_reg;
 	void __iomem			*nce_tim_cfg_reg;
@@ -420,10 +423,6 @@ enum keembay_vpu_event {
  * @vpu_id:		VPU ID to be used
  */
 struct vpu_boot_ta_shmem {
-	u64 vpu_mem_addr;
-	u64 vpu_mem_size;
-	u64 x509_mem_addr;
-	u64 x509_mem_size;
 	u64 fw_header_addr;
 	u64 fw_header_size;
 	u64 fw_version_addr;
@@ -899,6 +898,22 @@ static int setup_watchdog_resources(struct vpu_ipc_dev *vpu_dev)
 		return rc;
 	}
 
+	/* Request interrupt re-direct numbers */
+	rc = of_property_read_u32(dev->of_node,
+				  "intel,keembay-vpu-ipc-nce-wdt-redirect",
+				  &vpu_dev->nce_wdt_redirect);
+	if (rc) {
+		dev_err(dev, "failed to get NCE WDT redirect number.\n");
+		return rc;
+	}
+	rc = of_property_read_u32(dev->of_node,
+				  "intel,keembay-vpu-ipc-mss-wdt-redirect",
+				  &vpu_dev->mss_wdt_redirect);
+	if (rc) {
+		dev_err(dev, "failed to get MSS WDT redirect number.\n");
+		return rc;
+	}
+
 	return 0;
 }
 
@@ -942,11 +957,9 @@ static int setup_boot_parameters(struct vpu_ipc_dev *vpu_dev)
 
 	/* Fill in IRQ re-direct request information */
 	vpu_dev->boot_params->mss_wdt_to_irq_a53_redir =
-			irqd_to_hwirq(irq_get_irq_data(vpu_dev->mss_irq)) -
-			GIC_SPI_HWIRQ_OFFSET;
+			vpu_dev->mss_wdt_redirect;
 	vpu_dev->boot_params->nce_wdt_to_irq_a53_redir =
-			irqd_to_hwirq(irq_get_irq_data(vpu_dev->nce_irq)) -
-			GIC_SPI_HWIRQ_OFFSET;
+			vpu_dev->nce_wdt_redirect;
 
 	/* Setup A53SS_VERSION_ID */
 	vpu_dev->boot_params->a53ss_version_id = vpu_ipc_soc_info->hardware_id;
@@ -1006,21 +1019,17 @@ static int request_vpu_boot(struct vpu_ipc_dev *vpu_dev)
 
 	memset(vpu_boot_ta_args, 0, sizeof(*vpu_boot_ta_args));
 
-	vpu_boot_ta_args->vpu_mem_addr = vpu_dev->reserved_mem.paddr;
-	vpu_boot_ta_args->vpu_mem_size = vpu_dev->reserved_mem.size;
-	vpu_boot_ta_args->x509_mem_addr = vpu_dev->x509_mem.paddr;
-	vpu_boot_ta_args->x509_mem_size = vpu_dev->x509_mem.size;
 	vpu_boot_ta_args->fw_header_addr = vpu_dev->x509_mem.paddr +
 					   vpu_dev->x509_size;
 	vpu_boot_ta_args->fw_header_size = MAX_HEADER_SIZE;
-	vpu_boot_ta_args->fw_load_addr = vpu_dev->fw_res.start;
+	vpu_boot_ta_args->fw_load_addr = dma_to_phys(dev, vpu_dev->fw_res.start);
 	vpu_boot_ta_args->fw_load_size = resource_size(&vpu_dev->fw_res);
 	vpu_boot_ta_args->fw_version_addr = vpu_boot_ta_args->fw_load_addr -
 					    MAX_FIRMWARE_VERSION_SIZE;
 	vpu_boot_ta_args->fw_version_size = MAX_FIRMWARE_VERSION_SIZE;
 	vpu_boot_ta_args->x509_addr = vpu_dev->x509_mem.paddr;
 	vpu_boot_ta_args->x509_size = vpu_dev->x509_size;
-	vpu_boot_ta_args->fw_entry_addr = vpu_dev->boot_vec_paddr;
+	vpu_boot_ta_args->fw_entry_addr = dma_to_phys(dev, vpu_dev->boot_vec_paddr);
 	vpu_boot_ta_args->vpu_id = vpu_dev->vpu_id;
 
 	ret = tee_client_invoke_func(vpu_dev->tee_ctx, &inv_arg, param);
@@ -1254,7 +1263,7 @@ static int parse_fw_header(struct vpu_ipc_dev *vpu_dev,
 	       fw_header->image_size);
 
 	/* Save off boot parameters region vaddr */
-	vpu_dev->boot_params = config_region;
+	vpu_dev->boot_params = (struct boot_parameters *)config_region;
 
 	/* Save off boot vector physical address */
 	vpu_dev->boot_vec_paddr = fw_header->entry_point;
@@ -1560,7 +1569,7 @@ int intel_keembay_vpu_ipc_open_channel(struct device *dev, u8 node_id,
 		return rc;
 	return keembay_ipc_open_channel(vpu_dev->kmb_ipc, chan_id);
 }
-EXPORT_SYMBOL_GPL(intel_keembay_vpu_ipc_open_channel);
+EXPORT_SYMBOL(intel_keembay_vpu_ipc_open_channel);
 
 /**
  * intel_keembay_vpu_ipc_close_channel() - Close an IPC channel.
@@ -1585,7 +1594,7 @@ int intel_keembay_vpu_ipc_close_channel(struct device *dev, u8 node_id,
 
 	return keembay_ipc_close_channel(vpu_dev->kmb_ipc, chan_id);
 }
-EXPORT_SYMBOL_GPL(intel_keembay_vpu_ipc_close_channel);
+EXPORT_SYMBOL(intel_keembay_vpu_ipc_close_channel);
 
 /**
  * intel_keembay_vpu_ipc_send() - Send data via IPC.
@@ -1611,7 +1620,7 @@ int intel_keembay_vpu_ipc_send(struct device *dev, u8 node_id, u16 chan_id,
 
 	return keembay_ipc_send(vpu_dev->kmb_ipc, chan_id, vpu_addr, size);
 }
-EXPORT_SYMBOL_GPL(intel_keembay_vpu_ipc_send);
+EXPORT_SYMBOL(intel_keembay_vpu_ipc_send);
 
 /**
  * intel_keembay_vpu_ipc_recv() - Read data via IPC
@@ -1641,7 +1650,7 @@ int intel_keembay_vpu_ipc_recv(struct device *dev, u8 node_id, u16 chan_id,
 	return keembay_ipc_recv(vpu_dev->kmb_ipc, chan_id, vpu_addr, size,
 				timeout);
 }
-EXPORT_SYMBOL_GPL(intel_keembay_vpu_ipc_recv);
+EXPORT_SYMBOL(intel_keembay_vpu_ipc_recv);
 
 /**
  * intel_keembay_vpu_startup() - Boot the VPU
@@ -1683,7 +1692,7 @@ int intel_keembay_vpu_startup(struct device *dev, const char *firmware_name)
 
 	return do_boot_sequence(vpu_dev);
 }
-EXPORT_SYMBOL_GPL(intel_keembay_vpu_startup);
+EXPORT_SYMBOL(intel_keembay_vpu_startup);
 
 /**
  * intel_keembay_vpu_reset() - Reset the VPU
@@ -1711,7 +1720,7 @@ int intel_keembay_vpu_reset(struct device *dev)
 
 	return do_boot_sequence(vpu_dev);
 }
-EXPORT_SYMBOL_GPL(intel_keembay_vpu_reset);
+EXPORT_SYMBOL(intel_keembay_vpu_reset);
 
 /**
  * intel_keembay_vpu_stop() - Stop the VPU
@@ -1760,7 +1769,7 @@ int intel_keembay_vpu_stop(struct device *dev)
 
 	return rc;
 }
-EXPORT_SYMBOL_GPL(intel_keembay_vpu_stop);
+EXPORT_SYMBOL(intel_keembay_vpu_stop);
 
 /**
  * intel_keembay_vpu_status() - Get the VPU state.
@@ -1779,7 +1788,7 @@ enum intel_keembay_vpu_state intel_keembay_vpu_status(struct device *dev)
 
 	return vpu_dev->state;
 }
-EXPORT_SYMBOL_GPL(intel_keembay_vpu_status);
+EXPORT_SYMBOL(intel_keembay_vpu_status);
 
 /**
  * intel_keembay_vpu_get_wdt_count() - Get the WDT count
@@ -1810,7 +1819,7 @@ int intel_keembay_vpu_get_wdt_count(struct device *dev,
 	}
 	return rc;
 }
-EXPORT_SYMBOL_GPL(intel_keembay_vpu_get_wdt_count);
+EXPORT_SYMBOL(intel_keembay_vpu_get_wdt_count);
 
 /**
  * intel_keembay_vpu_wait_for_ready() - Sleep until VPU is READY
@@ -1855,7 +1864,7 @@ int intel_keembay_vpu_wait_for_ready(struct device *dev, u32 timeout)
 
 	return rc;
 }
-EXPORT_SYMBOL_GPL(intel_keembay_vpu_wait_for_ready);
+EXPORT_SYMBOL(intel_keembay_vpu_wait_for_ready);
 
 /**
  * intel_keembay_vpu_register_for_events() - Register callback for event notification
@@ -1885,7 +1894,7 @@ int intel_keembay_vpu_register_for_events(struct device *dev,
 
 	return 0;
 }
-EXPORT_SYMBOL_GPL(intel_keembay_vpu_register_for_events);
+EXPORT_SYMBOL(intel_keembay_vpu_register_for_events);
 
 /**
  * intel_keembay_vpu_unregister_for_events() - Unregister callback for event notification
@@ -1904,7 +1913,7 @@ int intel_keembay_vpu_unregister_for_events(struct device *dev)
 
 	return 0;
 }
-EXPORT_SYMBOL_GPL(intel_keembay_vpu_unregister_for_events);
+EXPORT_SYMBOL(intel_keembay_vpu_unregister_for_events);
 
 /* Probe() function for the VPU IPC platform driver. */
 static int keembay_vpu_ipc_probe(struct platform_device *pdev)
@@ -1949,6 +1958,14 @@ static int keembay_vpu_ipc_probe(struct platform_device *pdev)
 		goto probe_fail_post_resmem_setup;
 	}
 
+	/* Request the IMR number to be used */
+	rc = of_property_read_u32(dev->of_node, "intel,keembay-vpu-ipc-imr",
+				  &vpu_dev->imr);
+	if (rc) {
+		dev_err(dev, "failed to get IMR number.\n");
+		goto probe_fail_post_resmem_setup;
+	}
+
 	/* Get VPU ID. */
 	rc = of_property_read_u32(dev->of_node, "intel,keembay-vpu-ipc-id",
 				  &vpu_dev->vpu_id);
@@ -1990,7 +2007,8 @@ static int keembay_vpu_ipc_probe(struct platform_device *pdev)
 
 	/* Allocate dynamic shared memory for VPU boot params */
 	vpu_dev->shm = tee_shm_alloc(vpu_dev->tee_ctx,
-				     sizeof(struct vpu_boot_ta_shmem),
+				     (sizeof(struct vpu_boot_ta_shmem) +
+				     MAX_HEADER_SIZE),
 				     (TEE_SHM_MAPPED | TEE_SHM_DMA_BUF));
 
 	if (IS_ERR(vpu_dev->shm)) {
-- 
2.27.0

