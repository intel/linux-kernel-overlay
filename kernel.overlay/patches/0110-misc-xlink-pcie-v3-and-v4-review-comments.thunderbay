From c9a5d3b2940d9910d640a21f776b0340eb66a523 Mon Sep 17 00:00:00 2001
From: Srikanth Thokala <srikanth.thokala@intel.com>
Date: Fri, 13 Nov 2020 23:57:18 +0530
Subject: [PATCH 110/170] misc: xlink-pcie: v3 and v4 review comments

Signed-off-by: Srikanth Thokala <srikanth.thokala@intel.com>
---
 drivers/misc/xlink-pcie/common/interface.c | 18 +++++++++++
 drivers/misc/xlink-pcie/local_host/core.c  | 35 ++++++++++++----------
 drivers/misc/xlink-pcie/local_host/dma.c   | 14 ++++-----
 drivers/misc/xlink-pcie/local_host/epf.c   | 32 ++++++++------------
 drivers/misc/xlink-pcie/remote_host/core.c | 18 ++++++-----
 drivers/misc/xlink-pcie/remote_host/pci.c  |  6 +---
 drivers/misc/xlink-pcie/remote_host/pci.h  |  3 --
 7 files changed, 68 insertions(+), 58 deletions(-)

diff --git a/drivers/misc/xlink-pcie/common/interface.c b/drivers/misc/xlink-pcie/common/interface.c
index bd0d27f70963..4ad291ff97c8 100644
--- a/drivers/misc/xlink-pcie/common/interface.c
+++ b/drivers/misc/xlink-pcie/common/interface.c
@@ -15,6 +15,9 @@
 /* Define xpcie driver interface API */
 int xlink_pcie_get_device_list(u32 *sw_device_id_list, u32 *num_devices)
 {
+	if (!sw_device_id_list || !num_devices)
+		return -EINVAL;
+
 	*num_devices = intel_xpcie_get_device_num(sw_device_id_list);
 
 	return 0;
@@ -24,6 +27,9 @@ EXPORT_SYMBOL(xlink_pcie_get_device_list);
 int xlink_pcie_get_device_name(u32 sw_device_id, char *device_name,
 			       size_t name_size)
 {
+	if (!device_name)
+		return -EINVAL;
+
 	return intel_xpcie_get_device_name_by_id(sw_device_id,
 						 device_name, name_size);
 }
@@ -34,6 +40,9 @@ int xlink_pcie_get_device_status(u32 sw_device_id, u32 *device_status)
 	u32 status;
 	int rc;
 
+	if (!device_status)
+		return -EINVAL;
+
 	rc = intel_xpcie_get_device_status_by_id(sw_device_id, &status);
 	if (rc)
 		return rc;
@@ -76,6 +85,9 @@ EXPORT_SYMBOL(xlink_pcie_connect);
 int xlink_pcie_read(u32 sw_device_id, void *data, size_t *const size,
 		    u32 timeout)
 {
+	if (!data || !size)
+		return -EINVAL;
+
 	return intel_xpcie_pci_read(sw_device_id, data, size, timeout);
 }
 EXPORT_SYMBOL(xlink_pcie_read);
@@ -83,6 +95,9 @@ EXPORT_SYMBOL(xlink_pcie_read);
 int xlink_pcie_write(u32 sw_device_id, void *data, size_t *const size,
 		     u32 timeout)
 {
+	if (!data || !size)
+		return -EINVAL;
+
 	return intel_xpcie_pci_write(sw_device_id, data, size, timeout);
 }
 EXPORT_SYMBOL(xlink_pcie_write);
@@ -96,6 +111,9 @@ EXPORT_SYMBOL(xlink_pcie_reset_device);
 int xlink_pcie_register_device_event(u32 sw_device_id,
 				     xlink_device_event event_notif_fn)
 {
+	if (!event_notif_fn)
+		return -EINVAL;
+
 	return intel_xpcie_pci_register_device_event(sw_device_id,
 						     event_notif_fn);
 }
diff --git a/drivers/misc/xlink-pcie/local_host/core.c b/drivers/misc/xlink-pcie/local_host/core.c
index b99ed8596a02..628c383113ca 100644
--- a/drivers/misc/xlink-pcie/local_host/core.c
+++ b/drivers/misc/xlink-pcie/local_host/core.c
@@ -291,6 +291,12 @@ static int intel_xpcie_discover_txrx(struct xpcie *xpcie)
 
 static void intel_xpcie_start_tx(struct xpcie *xpcie, unsigned long delay)
 {
+	/*
+	 * Use only one WQ for both Rx and Tx
+	 *
+	 * Synchronous Read and Writes to DDR is found to result in memory
+	 * mismatch errors in stability tests due to silicon bug in A0 SoC.
+	 */
 	if (xpcie->legacy_a0)
 		queue_delayed_work(xpcie->rx_wq, &xpcie->tx_event, delay);
 	else
@@ -311,14 +317,12 @@ static void intel_xpcie_rx_event_handler(struct work_struct *work)
 	u32 head, tail, ndesc, length, initial_head;
 	unsigned long delay = msecs_to_jiffies(1);
 	struct xpcie_stream *rx = &xpcie->rx;
+	int descs_num = 0, chan = 0, rc;
 	struct xpcie_dma_ll_desc *desc;
 	struct xpcie_transfer_desc *td;
 	bool reset_work = false;
-	int descs_num = 0;
 	u16 interface;
-	int chan = 0;
 	u64 address;
-	int rc;
 
 	if (intel_xpcie_get_host_status(xpcie) != XPCIE_STATUS_RUN)
 		return;
@@ -436,12 +440,9 @@ static void intel_xpcie_tx_event_handler(struct work_struct *work)
 	u32 head, tail, ndesc, initial_tail;
 	struct xpcie_dma_ll_desc *desc;
 	struct xpcie_transfer_desc *td;
-	size_t buffers = 0;
-	int descs_num = 0;
-	size_t bytes = 0;
-	int chan = 0;
+	int descs_num = 0, chan = 0, rc;
+	size_t buffers = 0, bytes = 0;
 	u64 address;
-	int rc;
 
 	if (intel_xpcie_get_host_status(xpcie) != XPCIE_STATUS_RUN)
 		return;
@@ -647,15 +648,16 @@ int intel_xpcie_core_read(struct xpcie *xpcie, void *buffer,
 	size_t len, remaining;
 	int ret;
 
-	len = *length;
-	remaining = len;
-	*length = 0;
-	if (len == 0)
+	if (*length == 0)
 		return -EINVAL;
 
 	if (xpcie->status != XPCIE_STATUS_RUN)
 		return -ENODEV;
 
+	len = *length;
+	remaining = len;
+	*length = 0;
+
 	ret = mutex_lock_interruptible(&inf->rlock);
 	if (ret < 0)
 		return -EINTR;
@@ -732,10 +734,7 @@ int intel_xpcie_core_write(struct xpcie *xpcie, void *buffer,
 	size_t remaining, len;
 	int ret;
 
-	len = *length;
-	remaining = len;
-	*length = 0;
-	if (len == 0)
+	if (*length == 0)
 		return -EINVAL;
 
 	if (xpcie->status != XPCIE_STATUS_RUN)
@@ -744,6 +743,10 @@ int intel_xpcie_core_write(struct xpcie *xpcie, void *buffer,
 	if (intel_xpcie_get_host_status(xpcie) != XPCIE_STATUS_RUN)
 		return -ENODEV;
 
+	len = *length;
+	remaining = len;
+	*length = 0;
+
 	ret = mutex_lock_interruptible(&xpcie->wlock);
 	if (ret < 0)
 		return -EINTR;
diff --git a/drivers/misc/xlink-pcie/local_host/dma.c b/drivers/misc/xlink-pcie/local_host/dma.c
index 58693c4d92d5..811e5eebb7ab 100644
--- a/drivers/misc/xlink-pcie/local_host/dma.c
+++ b/drivers/misc/xlink-pcie/local_host/dma.c
@@ -86,6 +86,7 @@
 
 #define DMA_POLLING_TIMEOUT		1000000
 #define DMA_ENABLE_TIMEOUT		1000
+#define DMA_PCIE_PM_L1_TIMEOUT		20
 
 struct __packed pcie_dma_reg {
 	u32 dma_ctrl_data_arb_prior;
@@ -166,11 +167,11 @@ static void __iomem *intel_xpcie_ep_get_dma_base(struct pci_epf *epf)
 static int intel_xpcie_ep_dma_disable(void __iomem *dma_base,
 				      enum xpcie_ep_engine_type rw)
 {
-	int i;
 	struct __iomem pcie_dma_reg * dma_reg =
 				(struct __iomem pcie_dma_reg *)dma_base;
-	void __iomem *engine_en, *ll_err;
 	void __iomem *int_mask, *int_clear;
+	void __iomem *engine_en, *ll_err;
+	int i;
 
 	if (rw == WRITE_ENGINE) {
 		engine_en = (void __iomem *)&dma_reg->dma_write_engine_en;
@@ -211,8 +212,8 @@ static void intel_xpcie_ep_dma_enable(void __iomem *dma_base,
 	struct __iomem pcie_dma_reg * dma_reg =
 				(struct __iomem pcie_dma_reg *)(dma_base);
 	void __iomem *engine_en, *ll_err, *arb_weight;
-	void __iomem *int_mask, *int_clear;
 	struct __iomem pcie_dma_chan * dma_chan;
+	void __iomem *int_mask, *int_clear;
 	u32 offset, weight;
 	int i;
 
@@ -265,9 +266,8 @@ static void intel_xpcie_ep_dma_enable(void __iomem *dma_base,
 static int intel_xpcie_ep_dma_doorbell(struct xpcie_epf *xpcie_epf, int chan,
 				       void __iomem *doorbell)
 {
+	int i = DMA_PCIE_PM_L1_TIMEOUT, rc = 0;
 	u32 val, pm_val;
-	int rc = 0;
-	int i = 20;
 
 	val = ioread32(xpcie_epf->apb_base + PCIE_REGS_PCIE_APP_CNTRL);
 	iowrite32(val | APP_XFER_PENDING,
@@ -342,8 +342,8 @@ int intel_xpcie_ep_dma_write_ll(struct pci_epf *epf, int chan, int descs_num)
 {
 	struct xpcie_epf *xpcie_epf = epf_get_drvdata(epf);
 	void __iomem *dma_base = xpcie_epf->dma_base;
-	struct xpcie_dma_ll_desc_buf *desc_buf;
 	struct __iomem pcie_dma_chan * dma_chan;
+	struct xpcie_dma_ll_desc_buf *desc_buf;
 	struct __iomem pcie_dma_reg * dma_reg =
 				(struct __iomem pcie_dma_reg *)(dma_base);
 	int i, rc;
@@ -409,9 +409,9 @@ int intel_xpcie_ep_dma_read_ll(struct pci_epf *epf, int chan, int descs_num)
 	struct xpcie_epf *xpcie_epf = epf_get_drvdata(epf);
 	void __iomem *dma_base = xpcie_epf->dma_base;
 	struct xpcie_dma_ll_desc_buf *desc_buf;
-	struct __iomem pcie_dma_chan * dma_chan;
 	struct __iomem pcie_dma_reg * dma_reg =
 				(struct __iomem pcie_dma_reg *)(dma_base);
+	struct __iomem pcie_dma_chan * dma_chan;
 	int i, rc;
 
 	if (descs_num <= 0 || descs_num > XPCIE_NUM_RX_DESCS)
diff --git a/drivers/misc/xlink-pcie/local_host/epf.c b/drivers/misc/xlink-pcie/local_host/epf.c
index cf0e7788c612..7d24829dad42 100644
--- a/drivers/misc/xlink-pcie/local_host/epf.c
+++ b/drivers/misc/xlink-pcie/local_host/epf.c
@@ -152,8 +152,7 @@ static int intel_xpcie_configure_bar(struct pci_epf *epf,
 {
 	struct pci_epf_bar *epf_bar;
 	bool bar_fixed_64bit;
-	int ret;
-	int i;
+	int ret, i;
 
 	for (i = BAR_0; i <= BAR_5; i++) {
 		epf_bar = &epf->bar[i];
@@ -354,8 +353,10 @@ static int intel_xpcie_epf_bind(struct pci_epf *epf)
 	}
 
 	ret = intel_xpcie_epf_get_platform_data(dev, xpcie_epf);
-	if (ret != 0)
+	if (ret) {
+		dev_err(&epf->dev, "Unable to get platform data\n");
 		return -EINVAL;
+	}
 
 	if (!strcmp(xpcie_epf->stepping, "A0")) {
 		xpcie_epf->xpcie.legacy_a0 = true;
@@ -370,24 +371,26 @@ static int intel_xpcie_epf_bind(struct pci_epf *epf)
 	/* Enable interrupt */
 	writel(LBC_CII_EVENT_FLAG,
 	       xpcie_epf->apb_base + PCIE_REGS_PCIE_INTR_ENABLE);
-	ret = request_irq(xpcie_epf->irq, &intel_xpcie_host_interrupt,
-			  0, XPCIE_DRIVER_NAME, &xpcie_epf->xpcie);
+	ret = devm_request_irq(&epf->dev, xpcie_epf->irq,
+			       &intel_xpcie_host_interrupt, 0,
+			       XPCIE_DRIVER_NAME, &xpcie_epf->xpcie);
 	if (ret) {
 		dev_err(&epf->dev, "failed to request irq\n");
 		goto err_cleanup_bars;
 	}
 
-	ret = request_irq(xpcie_epf->irq_err, &intel_xpcie_err_interrupt, 0,
-			  XPCIE_DRIVER_NAME, &xpcie_epf->xpcie);
+	ret = devm_request_irq(&epf->dev, xpcie_epf->irq_err,
+			       &intel_xpcie_err_interrupt, 0,
+			       XPCIE_DRIVER_NAME, &xpcie_epf->xpcie);
 	if (ret) {
 		dev_err(&epf->dev, "failed to request error irq\n");
-		goto err_free_irq;
+		goto err_cleanup_bars;
 	}
 
 	ret = intel_xpcie_ep_dma_init(epf);
 	if (ret) {
 		dev_err(&epf->dev, "DMA initialization failed\n");
-		goto err_free_err_irq;
+		goto err_cleanup_bars;
 	}
 
 	intel_xpcie_set_device_status(&xpcie_epf->xpcie, XPCIE_STATUS_READY);
@@ -398,7 +401,7 @@ static int intel_xpcie_epf_bind(struct pci_epf *epf)
 			PCIE_CFG_PBUS_DEV_NUM_MASK;
 
 	xlink_sw_id = FIELD_PREP(XLINK_DEV_INF_TYPE_MASK,
-			      XLINK_DEV_INF_PCIE) |
+				 XLINK_DEV_INF_PCIE) |
 		      FIELD_PREP(XLINK_DEV_PHYS_ID_MASK,
 				 bus_num << 8 | dev_num) |
 		      FIELD_PREP(XLINK_DEV_TYPE_MASK, XLINK_DEV_TYPE_KMB) |
@@ -428,12 +431,6 @@ static int intel_xpcie_epf_bind(struct pci_epf *epf)
 
 	intel_xpcie_ep_dma_uninit(epf);
 
-err_free_err_irq:
-	free_irq(xpcie_epf->irq_err, &xpcie_epf->xpcie);
-
-err_free_irq:
-	free_irq(xpcie_epf->irq, &xpcie_epf->xpcie);
-
 err_cleanup_bars:
 	intel_xpcie_cleanup_bars(epf);
 
@@ -445,9 +442,6 @@ static void intel_xpcie_epf_unbind(struct pci_epf *epf)
 	struct xpcie_epf *xpcie_epf = epf_get_drvdata(epf);
 	struct pci_epc *epc = epf->epc;
 
-	free_irq(xpcie_epf->irq, &xpcie_epf->xpcie);
-	free_irq(xpcie_epf->irq_err, &xpcie_epf->xpcie);
-
 	intel_xpcie_core_cleanup(&xpcie_epf->xpcie);
 	intel_xpcie_set_device_status(&xpcie_epf->xpcie, XPCIE_STATUS_READY);
 
diff --git a/drivers/misc/xlink-pcie/remote_host/core.c b/drivers/misc/xlink-pcie/remote_host/core.c
index e7ecd20474cf..668fded17e9c 100644
--- a/drivers/misc/xlink-pcie/remote_host/core.c
+++ b/drivers/misc/xlink-pcie/remote_host/core.c
@@ -488,15 +488,16 @@ int intel_xpcie_core_read(struct xpcie *xpcie, void *buffer, size_t *length,
 	long jiffies_passed = 0;
 	int ret;
 
-	len = *length;
-	remaining = len;
-	*length = 0;
-	if (len == 0)
+	if (*length == 0)
 		return -EINVAL;
 
 	if (xpcie->status != XPCIE_STATUS_RUN)
 		return -ENODEV;
 
+	len = *length;
+	remaining = len;
+	*length = 0;
+
 	ret = mutex_lock_interruptible(&inf->rlock);
 	if (ret < 0)
 		return -EINTR;
@@ -571,15 +572,16 @@ int intel_xpcie_core_write(struct xpcie *xpcie, void *buffer, size_t *length,
 	size_t remaining, len;
 	int ret;
 
-	len = *length;
-	remaining = len;
-	*length = 0;
-	if (len == 0)
+	if (*length == 0)
 		return -EINVAL;
 
 	if (xpcie->status != XPCIE_STATUS_RUN)
 		return -ENODEV;
 
+	len = *length;
+	remaining = len;
+	*length = 0;
+
 	ret = mutex_lock_interruptible(&xpcie->wlock);
 	if (ret < 0)
 		return -EINTR;
diff --git a/drivers/misc/xlink-pcie/remote_host/pci.c b/drivers/misc/xlink-pcie/remote_host/pci.c
index 1a537e62e7a4..0046bff5f604 100644
--- a/drivers/misc/xlink-pcie/remote_host/pci.c
+++ b/drivers/misc/xlink-pcie/remote_host/pci.c
@@ -194,7 +194,7 @@ static int intel_xpcie_pci_irq_init(struct xpcie_dev *xdev,
 	rc = request_irq(irq, irq_handler, 0,
 			 XPCIE_DRIVER_NAME, xdev);
 	if (rc) {
-		dev_err(&xdev->pci->dev, "failed to request irqs\n");
+		dev_err(&xdev->pci->dev, "failed to request irq\n");
 		goto error_irq;
 	}
 
@@ -326,10 +326,6 @@ int intel_xpcie_pci_cleanup(struct xpcie_dev *xdev)
 	xdev->core_irq_callback = NULL;
 	intel_xpcie_pci_irq_cleanup(xdev);
 
-	kfree(xdev->dma_buf);
-	xdev->dma_buf = NULL;
-	xdev->dma_buf_offset = 0;
-
 	intel_xpcie_core_cleanup(&xdev->xpcie);
 
 	intel_xpcie_pci_unmap_bar(xdev);
diff --git a/drivers/misc/xlink-pcie/remote_host/pci.h b/drivers/misc/xlink-pcie/remote_host/pci.h
index 0ca8a0bc82ec..a05dedf36a12 100644
--- a/drivers/misc/xlink-pcie/remote_host/pci.h
+++ b/drivers/misc/xlink-pcie/remote_host/pci.h
@@ -37,9 +37,6 @@ struct xpcie_dev {
 	bool irq_enabled;
 	irq_handler_t core_irq_callback;
 
-	void *dma_buf;
-	size_t dma_buf_offset;
-
 	struct xpcie xpcie;
 	xlink_device_event event_fn;
 };
-- 
2.27.0

