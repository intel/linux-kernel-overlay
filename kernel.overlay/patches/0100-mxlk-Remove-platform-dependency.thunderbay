From ec9bdc8f660ecf16afccfc728e4f97354d0a12e7 Mon Sep 17 00:00:00 2001
From: kadarlax <raghuveerx.kadarla@intel.com>
Date: Wed, 16 Sep 2020 14:12:41 +0530
Subject: [PATCH 100/170] mxlk: Remove platform dependency

Signed-off-by: kadarlax <raghuveerx.kadarla@intel.com>
---
 drivers/misc/xlink-pcie/local_host/epf.c    | 79 ++++++++++++++++++---
 drivers/misc/xlink-pcie/local_host/struct.h |  3 +
 2 files changed, 72 insertions(+), 10 deletions(-)

diff --git a/drivers/misc/xlink-pcie/local_host/epf.c b/drivers/misc/xlink-pcie/local_host/epf.c
index 83e48d42d917..47a69c71d74f 100644
--- a/drivers/misc/xlink-pcie/local_host/epf.c
+++ b/drivers/misc/xlink-pcie/local_host/epf.c
@@ -17,6 +17,10 @@
 #include <linux/pci_ids.h>
 #include <linux/reboot.h>
 #include <linux/xlink_drv_inf.h>
+#include <linux/err.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
 #include "../common/xpcie.h"
 #include "../common/core.h"
 #include "../common/util.h"
@@ -305,13 +309,63 @@ static int intel_xpcie_setup_bars(struct pci_epf *epf, size_t align)
 	return 0;
 }
 
+static int intel_xpcie_epf_get_platform_data(struct device *dev,
+					     struct xpcie_epf *xpcie_epf)
+{
+	struct resource *res;
+	struct platform_device *pdev = to_platform_device(dev);
+	struct device_node *soc_node, *version_node;
+	const char *prop;
+	int prop_size;
+
+	xpcie_epf->irq_dma = platform_get_irq_byname(pdev, "intr");
+	if (xpcie_epf->irq_dma < 0) {
+		dev_err(&xpcie_epf->epf->dev, "failed to get IRQ: %d\n",
+			xpcie_epf->irq_dma);
+		return -EINVAL;
+	}
+
+	xpcie_epf->irq_err = platform_get_irq_byname(pdev, "err_intr");
+	if (xpcie_epf->irq_err < 0) {
+		dev_err(&xpcie_epf->epf->dev, "failed to get erroe IRQ: %d\n",
+			xpcie_epf->irq_err);
+		return -EINVAL;
+	}
+
+	xpcie_epf->irq = platform_get_irq_byname(pdev, "ev_intr");
+	if (xpcie_epf->irq < 0) {
+		dev_err(&xpcie_epf->epf->dev, "failed to get event IRQ: %d\n",
+			xpcie_epf->irq);
+		return -EINVAL;
+	}
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "apb");
+	xpcie_epf->apb_base =
+		devm_ioremap(dev, res->start, resource_size(res));
+	if (IS_ERR(xpcie_epf->apb_base))
+		return PTR_ERR(xpcie_epf->apb_base);
+
+	strncpy(xpcie_epf->stepping, "B0", strlen("B0"));
+	soc_node = of_get_parent(pdev->dev.of_node);
+	if (soc_node) {
+		version_node = of_get_child_by_name(soc_node, "version-info");
+		if (version_node) {
+			prop = of_get_property(version_node, "stepping",
+					       &prop_size);
+			if (prop && prop_size <= KEEMBAY_XPCIE_STEPPING_MAXLEN)
+				strncpy(xpcie_epf->stepping, prop, prop_size);
+			of_node_put(version_node);
+		}
+		of_node_put(soc_node);
+	}
+
+	return 0;
+}
+
 static int intel_xpcie_epf_bind(struct pci_epf *epf)
 {
 	struct pci_epc *epc = epf->epc;
 	struct xpcie_epf *xpcie_epf = epf_get_drvdata(epf);
-	struct dw_pcie_ep *ep = epc_get_drvdata(epc);
-	struct dw_pcie *pci = to_dw_pcie_from_ep(ep);
-	struct keembay_pcie *keembay = to_keembay_pcie(pci);
 	const struct pci_epc_features *features;
 	bool msi_capable = true;
 	size_t align = 0;
@@ -319,6 +373,10 @@ static int intel_xpcie_epf_bind(struct pci_epf *epf)
 	u32 bus_num = 0;
 	u32 dev_num = 0;
 
+	struct dw_pcie_ep *ep = epc_get_drvdata(epc);
+	struct dw_pcie *pci = to_dw_pcie_from_ep(ep);
+	struct device *dev = pci->dev;
+
 	if (WARN_ON_ONCE(!epc))
 		return -EINVAL;
 
@@ -338,11 +396,11 @@ static int intel_xpcie_epf_bind(struct pci_epf *epf)
 		return ret;
 	}
 
-	xpcie_epf->irq = keembay->ev_irq;
-	xpcie_epf->irq_dma = keembay->irq;
-	xpcie_epf->irq_err = keembay->err_irq;
-	xpcie_epf->apb_base = keembay->base;
-	if (!strcmp(keembay->stepping, "A0")) {
+	ret = intel_xpcie_epf_get_platform_data(dev, xpcie_epf);
+	if (ret != 0)
+		return -EINVAL;
+
+	if (!strcmp(xpcie_epf->stepping, "A0")) {
 		xpcie_epf->xpcie.legacy_a0 = true;
 		xpcie_epf->xpcie.mmio->legacy_a0 = 1;
 	} else {
@@ -375,6 +433,7 @@ static int intel_xpcie_epf_bind(struct pci_epf *epf)
 		goto bind_error;
 	}
 
+	dev_info(&epf->dev, "xlink_sw_id 0x%x\n", xlink_sw_id);
 	/* Enable interrupt */
 	writel(LBC_CII_EVENT_FLAG,
 	       xpcie_epf->apb_base + PCIE_REGS_PCIE_INTR_ENABLE);
@@ -439,6 +498,7 @@ static int intel_xpcie_epf_probe(struct pci_epf *epf)
 {
 	struct xpcie_epf *xpcie_epf;
 	struct device *dev = &epf->dev;
+	int ret = 0;
 
 	xpcie_epf = devm_kzalloc(dev, sizeof(*xpcie_epf), GFP_KERNEL);
 	if (!xpcie_epf)
@@ -446,10 +506,9 @@ static int intel_xpcie_epf_probe(struct pci_epf *epf)
 
 	epf->header = &xpcie_header;
 	xpcie_epf->epf = epf;
-
 	epf_set_drvdata(epf, xpcie_epf);
 
-	return 0;
+	return ret;
 }
 
 static void intel_xpcie_epf_shutdown(struct device *dev)
diff --git a/drivers/misc/xlink-pcie/local_host/struct.h b/drivers/misc/xlink-pcie/local_host/struct.h
index 6dc067a7b4cb..bd2127a13754 100644
--- a/drivers/misc/xlink-pcie/local_host/struct.h
+++ b/drivers/misc/xlink-pcie/local_host/struct.h
@@ -15,6 +15,8 @@
 #include <pcie-keembay.h>
 #include "../common/xpcie.h"
 
+#define KEEMBAY_XPCIE_STEPPING_MAXLEN 8
+
 extern bool dma_ll_mode;
 
 struct xpcie_dma_ll_desc {
@@ -54,6 +56,7 @@ struct xpcie_epf {
 	int				irq_err;
 	void __iomem			*apb_base;
 	void __iomem			*dma_base;
+	char				stepping[KEEMBAY_XPCIE_STEPPING_MAXLEN];
 
 	irq_handler_t			core_irq_callback;
 	dma_addr_t			tx_phys;
-- 
2.27.0

