From d67a75edf36ee3c28adb455276578049d193cbe1 Mon Sep 17 00:00:00 2001
From: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date: Tue, 27 Apr 2021 18:19:16 +0300
Subject: [PATCH 62/69] counter: intel-qep: Rework enable_write()

Maintainer asked if logic can be made clearer by first avaluating does
value change followed by register read, modify, write. Also asymmetric
pm_runtime_get_sync()/pm_runtime_put() usage was unclear. It was
asymmetric since runtime PM must be always on when peripheral is enabled
in order to able to count.

Therefore rework this function and logic. Now runtime PM use is
symmetric and always on/let idle is achieved by
incrementing/decrementing runtime PM usage counter and commenting it in
the code.

Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
---
 drivers/counter/intel-qep.c | 30 ++++++++++++++++++------------
 1 file changed, 18 insertions(+), 12 deletions(-)

diff --git a/drivers/counter/intel-qep.c b/drivers/counter/intel-qep.c
index 8be0263ead9a..e62973fffd23 100644
--- a/drivers/counter/intel-qep.c
+++ b/drivers/counter/intel-qep.c
@@ -345,7 +345,7 @@ static ssize_t enable_write(struct counter_device *counter,
 {
 	struct intel_qep *qep = counter->priv;
 	u32 reg;
-	bool val;
+	bool val, changed;
 	int ret;
 
 	ret = kstrtobool(buf, &val);
@@ -353,21 +353,27 @@ static ssize_t enable_write(struct counter_device *counter,
 		return ret;
 
 	mutex_lock(&qep->lock);
-	if (val && !qep->enabled) {
-		pm_runtime_get_sync(qep->dev);
-		reg = intel_qep_readl(qep, INTEL_QEPCON);
+	changed = val ^ qep->enabled;
+	if (!changed)
+		goto out;
+
+	pm_runtime_get_sync(qep->dev);
+	reg = intel_qep_readl(qep, INTEL_QEPCON);
+	if (val) {
+		/* Enable peripheral and keep runtime PM always on */
 		reg |= INTEL_QEPCON_EN;
-		intel_qep_writel(qep, INTEL_QEPCON, reg);
-		qep->enabled = true;
-	} else if (!val && qep->enabled) {
-		reg = intel_qep_readl(qep, INTEL_QEPCON);
+		pm_runtime_get_noresume(qep->dev);
+	} else {
+		/* Let runtime PM be idle and disable peripheral */
+		pm_runtime_put_noidle(qep->dev);
 		reg &= ~INTEL_QEPCON_EN;
-		intel_qep_writel(qep, INTEL_QEPCON, reg);
-		qep->enabled = false;
-		pm_runtime_put(qep->dev);
 	}
-	mutex_unlock(&qep->lock);
+	intel_qep_writel(qep, INTEL_QEPCON, reg);
+	pm_runtime_put(qep->dev);
+	qep->enabled = val;
 
+out:
+	mutex_unlock(&qep->lock);
 	return len;
 }
 
-- 
2.27.0

