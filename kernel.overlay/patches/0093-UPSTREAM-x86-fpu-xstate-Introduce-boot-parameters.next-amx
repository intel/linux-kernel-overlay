From cf24726e5733c801059def6247a899ff5786e610 Mon Sep 17 00:00:00 2001
From: "Chang S. Bae" <chang.seok.bae@intel.com>
Date: Wed, 30 Sep 2020 09:21:55 -0700
Subject: [PATCH 93/94] !UPSTREAM: x86/fpu/xstate: Introduce boot-parameters to
 control AMX

amx=disable:   for admin to be able to permanently disable AMX on a booted
               kernel.
amx=on:        the deafult -- a debug option to allow all processes to
               access AMX state without invoking the system call.
amx=off:       an experimental option -- AMX is enabled for a process
               that successfully invokes the system call.

Signed-off-by: Chang S. Bae <chang.seok.bae@intel.com>
---
 .../admin-guide/kernel-parameters.txt         | 11 ++++++
 arch/x86/include/asm/fpu/xstate.h             |  1 +
 arch/x86/kernel/fpu/init.c                    | 34 +++++++++++++++++--
 arch/x86/kernel/fpu/regset.c                  |  2 +-
 arch/x86/kernel/fpu/xstate.c                  |  2 +-
 arch/x86/kernel/traps.c                       |  2 +-
 6 files changed, 46 insertions(+), 6 deletions(-)

diff --git a/Documentation/admin-guide/kernel-parameters.txt b/Documentation/admin-guide/kernel-parameters.txt
index 71f9125db3c1..cc7fb08ec1ad 100644
--- a/Documentation/admin-guide/kernel-parameters.txt
+++ b/Documentation/admin-guide/kernel-parameters.txt
@@ -322,6 +322,17 @@
 			Format: <a>,<b>
 			See also Documentation/input/joydev/joystick.rst
 
+	amx=		[X86-64]
+			disable     - for admin to be able to permanently
+			              diable AMX on a booted kernel.
+			on          - a debug option to allow all processes
+			              to access AMX state without invoking
+			              the system call.
+			off         - the default -- AMX is enabled, but it
+			              is of by default for all processes,
+			              until they successfully invoke the
+			              system call.
+
 	analog.map=	[HW,JOY] Analog joystick and gamepad support
 			Specifies type or capabilities of an analog joystick
 			connected to one of 16 gameports
diff --git a/arch/x86/include/asm/fpu/xstate.h b/arch/x86/include/asm/fpu/xstate.h
index b86ab3023152..fd81be78a950 100644
--- a/arch/x86/include/asm/fpu/xstate.h
+++ b/arch/x86/include/asm/fpu/xstate.h
@@ -129,6 +129,7 @@ void free_xstate_buffer(struct fpu *fpu);
 
 long set_process_dynamicstate_perm(struct task_struct *task);
 void reset_task_dynamicstate_perm(struct task_struct *task);
+int check_task_dynamicstate_perm(struct task_struct *task);
 
 const void *get_xsave_field_ptr(int xfeature_nr);
 int using_compacted_format(void);
diff --git a/arch/x86/kernel/fpu/init.c b/arch/x86/kernel/fpu/init.c
index 6fa29e2607ac..ad1e1c0b5eea 100644
--- a/arch/x86/kernel/fpu/init.c
+++ b/arch/x86/kernel/fpu/init.c
@@ -5,6 +5,7 @@
 #include <asm/fpu/internal.h>
 #include <asm/tlbflush.h>
 #include <asm/setup.h>
+#include <asm/cmdline.h>
 
 #include <linux/sched.h>
 #include <linux/sched/task.h>
@@ -216,14 +217,26 @@ static void __init fpu__init_system_xstate_size_legacy(void)
 /*
  * Find supported xfeatures based on cpu features and command-line input.
  * This must be called after fpu__init_parse_early_param() is called and
- * xfeatures_mask is enumerated.
+ * xfeatures_mask_all is enumerated.
  */
+
+bool amx_enable = true;
+bool amx_abi = false;
+
+int check_task_dynamicstate_perm(struct task_struct *task)
+{
+	if (!amx_abi)
+		return 1;
+	return test_tsk_thread_flag(task, TIF_DYNAMIC_XSTATE);
+}
+
 u64 __init fpu__get_supported_xfeatures_mask(void)
 {
 	u64 mask = XFEATURE_MASK_USER_SUPPORTED | XFEATURE_MASK_SUPERVISOR_SUPPORTED;
 
-	if (!IS_ENABLED(CONFIG_X86_64))
-		mask &= ~(XFEATURE_MASK_XTILE);
+	if (!IS_ENABLED(CONFIG_X86_64) || !amx_enable) {
+		mask  &= ~(XFEATURE_MASK_XTILE);
+	}
 
 	return mask;
 }
@@ -237,12 +250,27 @@ static void __init fpu__init_system_ctx_switch(void)
 	on_boot_cpu = 0;
 }
 
+static void __init fpu__init_parse_early_param(void)
+{
+	char arg[20];
+
+	if (cmdline_find_option(boot_command_line, "amx", arg, sizeof(arg))) {
+		if (!strcmp(arg, "off"))
+			amx_abi = true;
+		else if (!strcmp(arg, "on"))
+			amx_abi = false;
+		else if (!strcmp(arg, "disable"))
+			amx_enable = false;
+	}
+}
+
 /*
  * Called on the boot CPU once per system bootup, to set up the initial
  * FPU state that is later cloned into all processes:
  */
 void __init fpu__init_system(struct cpuinfo_x86 *c)
 {
+	fpu__init_parse_early_param();
 	fpu__init_system_early_generic(c);
 
 	/*
diff --git a/arch/x86/kernel/fpu/regset.c b/arch/x86/kernel/fpu/regset.c
index 94a9d1487fdb..c9be13055791 100644
--- a/arch/x86/kernel/fpu/regset.c
+++ b/arch/x86/kernel/fpu/regset.c
@@ -128,7 +128,7 @@ int xstateregs_set(struct task_struct *target, const struct user_regset *regset,
 	 *
 	 * Check if the expansion is possibly needed.
 	 */
-	if (xfeatures_mask_user_dynamic && test_tsk_thread_flag(target, TIF_DYNAMIC_XSTATE) &&
+	if (xfeatures_mask_user_dynamic && check_task_dynamicstate_perm(target) &&
 	    ((fpu->state_mask & xfeatures_mask_user_dynamic) != xfeatures_mask_user_dynamic)) {
 		unsigned int offset, size;
 		u64 state_mask;
diff --git a/arch/x86/kernel/fpu/xstate.c b/arch/x86/kernel/fpu/xstate.c
index f7d6c0b89c29..785eedfc46cf 100644
--- a/arch/x86/kernel/fpu/xstate.c
+++ b/arch/x86/kernel/fpu/xstate.c
@@ -1530,7 +1530,7 @@ long set_process_dynamicstate_perm(struct task_struct *task)
 	if (!xfeatures_mask_user_dynamic)
 		return -EINVAL;
 
-	if (test_tsk_thread_flag(task, TIF_DYNAMIC_XSTATE))
+	if (check_task_dynamicstate_perm(task))
 		return 0;
 
 	for_each_thread(task, t)
diff --git a/arch/x86/kernel/traps.c b/arch/x86/kernel/traps.c
index b7d686ca94e5..23981a624eef 100644
--- a/arch/x86/kernel/traps.c
+++ b/arch/x86/kernel/traps.c
@@ -1190,7 +1190,7 @@ DEFINE_IDTENTRY(exc_device_not_available)
 			 * Make sure the feature bit, the dynamic expansion is permitted and
 			 * finally not in interrupt context as handling a trap from userspace.
 			 */
-			if (!WARN_ON(!xfd_event) && test_thread_flag(TIF_DYNAMIC_XSTATE) &&
+			if (!WARN_ON(!xfd_event) && check_task_dynamicstate_perm(current) &&
 			    !WARN_ON(in_interrupt())) {
 				struct fpu *fpu = &current->thread.fpu;
 				int err;
-- 
2.27.0

