From 1b9cf0b084e2536117fb0dd08d69a3e89f382e7d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Ville=20Syrj=C3=A4l=C3=A4?= <ville.syrjala@linux.intel.com>
Date: Fri, 30 Apr 2021 17:39:45 +0300
Subject: [PATCH 172/363] drm/i915: Include intel_de_{read,write}_fw() in
 i915_reg_rw traces
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

We lost the i915_reg_rw tracepoint for a lot of display registers
when we switched from the heavyweight normal register accessors to
the lightweight _fw() variants. See eg. commit dd584fc0711a
("drm/i915: Use I915_READ_FW for plane updates").

Put the tracepoints back so that the register traces might
actually be useful. Hopefully these should be close to free
when the tracepoint is not enabled and thus not slow down
our vblank critical sections significantly.

v2: Copy paste the same-cacheline-hang warning from
    intel_uncore.h (Anshuman)

Cc: Cooper Chiou <cooper.chiou@intel.com>
Reviewed-by: Anshuman Gupta <anshuman.gupta@intel.com>
Reviewed-by: Jani Nikula <jani.nikula@intel.com>
Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20210430143945.6776-2-ville.syrjala@linux.intel.com
---
 drivers/gpu/drm/i915/display/intel_de.h | 41 ++++++++++++++++---------
 1 file changed, 27 insertions(+), 14 deletions(-)

diff --git a/drivers/gpu/drm/i915/display/intel_de.h b/drivers/gpu/drm/i915/display/intel_de.h
index 00da10bf35f5..9d8c177aa228 100644
--- a/drivers/gpu/drm/i915/display/intel_de.h
+++ b/drivers/gpu/drm/i915/display/intel_de.h
@@ -8,6 +8,7 @@
 
 #include "i915_drv.h"
 #include "i915_reg.h"
+#include "i915_trace.h"
 #include "intel_uncore.h"
 
 static inline u32
@@ -22,26 +23,12 @@ intel_de_posting_read(struct drm_i915_private *i915, i915_reg_t reg)
 	intel_uncore_posting_read(&i915->uncore, reg);
 }
 
-/* Note: read the warnings for intel_uncore_*_fw() functions! */
-static inline u32
-intel_de_read_fw(struct drm_i915_private *i915, i915_reg_t reg)
-{
-	return intel_uncore_read_fw(&i915->uncore, reg);
-}
-
 static inline void
 intel_de_write(struct drm_i915_private *i915, i915_reg_t reg, u32 val)
 {
 	intel_uncore_write(&i915->uncore, reg, val);
 }
 
-/* Note: read the warnings for intel_uncore_*_fw() functions! */
-static inline void
-intel_de_write_fw(struct drm_i915_private *i915, i915_reg_t reg, u32 val)
-{
-	intel_uncore_write_fw(&i915->uncore, reg, val);
-}
-
 static inline void
 intel_de_rmw(struct drm_i915_private *i915, i915_reg_t reg, u32 clear, u32 set)
 {
@@ -69,4 +56,30 @@ intel_de_wait_for_clear(struct drm_i915_private *i915, i915_reg_t reg,
 	return intel_de_wait_for_register(i915, reg, mask, 0, timeout);
 }
 
+/*
+ * Unlocked mmio-accessors, think carefully before using these.
+ *
+ * Certain architectures will die if the same cacheline is concurrently accessed
+ * by different clients (e.g. on Ivybridge). Access to registers should
+ * therefore generally be serialised, by either the dev_priv->uncore.lock or
+ * a more localised lock guarding all access to that bank of registers.
+ */
+static inline u32
+intel_de_read_fw(struct drm_i915_private *i915, i915_reg_t reg)
+{
+	u32 val;
+
+	val = intel_uncore_read_fw(&i915->uncore, reg);
+	trace_i915_reg_rw(false, reg, val, sizeof(val), true);
+
+	return val;
+}
+
+static inline void
+intel_de_write_fw(struct drm_i915_private *i915, i915_reg_t reg, u32 val)
+{
+	trace_i915_reg_rw(true, reg, val, sizeof(val), true);
+	intel_uncore_write_fw(&i915->uncore, reg, val);
+}
+
 #endif /* __INTEL_DE_H__ */
-- 
2.27.0

