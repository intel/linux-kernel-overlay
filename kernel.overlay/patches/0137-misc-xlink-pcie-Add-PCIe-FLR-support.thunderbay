From 5f8c23e8fbe6a4a58203858c0dbaffe9c8f01b14 Mon Sep 17 00:00:00 2001
From: Srikanth Thokala <srikanth.thokala@intel.com>
Date: Mon, 24 May 2021 18:39:08 +0530
Subject: [PATCH 137/170] misc: xlink-pcie: Add PCIe FLR support

Add PCIe FLR support

Signed-off-by: Srikanth Thokala <srikanth.thokala@intel.com>
---
 drivers/misc/xlink-pcie/common/core.h      |   2 +
 drivers/misc/xlink-pcie/common/interface.c |  12 +++
 drivers/misc/xlink-pcie/common/util.h      |   5 +-
 drivers/misc/xlink-pcie/local_host/core.c  |  28 ++----
 drivers/misc/xlink-pcie/local_host/dma.c   |  57 ++++++++----
 drivers/misc/xlink-pcie/local_host/epf.c   | 101 +++++++++++++++++++--
 drivers/misc/xlink-pcie/local_host/epf.h   |  14 ++-
 drivers/misc/xlink-pcie/remote_host/pci.c  |  57 +++++++++++-
 drivers/misc/xlink-pcie/remote_host/pci.h  |   1 +
 include/linux/xlink_drv_inf.h              |   2 +
 10 files changed, 225 insertions(+), 54 deletions(-)

diff --git a/drivers/misc/xlink-pcie/common/core.h b/drivers/misc/xlink-pcie/common/core.h
index 5d73793b6268..b97202036c6e 100644
--- a/drivers/misc/xlink-pcie/common/core.h
+++ b/drivers/misc/xlink-pcie/common/core.h
@@ -254,4 +254,6 @@ int intel_xpcie_pci_reset_device(u32 id);
 int intel_xpcie_pci_register_device_event(u32 sw_device_id,
 					  xlink_device_event event_notif_fn);
 int intel_xpcie_pci_unregister_device_event(u32 sw_device_id);
+int intel_xpcie_pci_flr_reset(u32 id);
+int intel_xpcie_pci_ack_flr_reset(u32 id);
 #endif /* XPCIE_CORE_HEADER_ */
diff --git a/drivers/misc/xlink-pcie/common/interface.c b/drivers/misc/xlink-pcie/common/interface.c
index b4d6b827bed8..493c35985173 100644
--- a/drivers/misc/xlink-pcie/common/interface.c
+++ b/drivers/misc/xlink-pcie/common/interface.c
@@ -124,3 +124,15 @@ int xlink_pcie_unregister_device_event(u32 sw_device_id)
 	return intel_xpcie_pci_unregister_device_event(sw_device_id);
 }
 EXPORT_SYMBOL(xlink_pcie_unregister_device_event);
+
+int xlink_pcie_flr_reset(uint32_t sw_device_id)
+{
+	return intel_xpcie_pci_flr_reset(sw_device_id);
+}
+EXPORT_SYMBOL(xlink_pcie_flr_reset);
+
+int xlink_pcie_ack_flr_reset(uint32_t sw_device_id)
+{
+	return intel_xpcie_pci_ack_flr_reset(sw_device_id);
+}
+EXPORT_SYMBOL(xlink_pcie_ack_flr_reset);
diff --git a/drivers/misc/xlink-pcie/common/util.h b/drivers/misc/xlink-pcie/common/util.h
index 59a81460cc5e..2a5ae0312f78 100644
--- a/drivers/misc/xlink-pcie/common/util.h
+++ b/drivers/misc/xlink-pcie/common/util.h
@@ -30,7 +30,10 @@ enum xpcie_doorbell_type {
 enum xpcie_event_type {
 	NO_OP,
 	REQUEST_RESET,
-	DEV_SHUTDOWN
+	DEV_SHUTDOWN,
+	PREP_FLR_RESET,
+	PREP_FLR_RESET_ACK,
+	FLR_RESET_ACK
 };
 
 void intel_xpcie_set_doorbell(struct xpcie *xpcie,
diff --git a/drivers/misc/xlink-pcie/local_host/core.c b/drivers/misc/xlink-pcie/local_host/core.c
index 19febec664f9..d00f50a989b5 100644
--- a/drivers/misc/xlink-pcie/local_host/core.c
+++ b/drivers/misc/xlink-pcie/local_host/core.c
@@ -76,9 +76,6 @@ static void intel_xpcie_set_cap_txrx(struct xpcie *xpcie)
 
 static void intel_xpcie_txrx_cleanup(struct xpcie *xpcie)
 {
-	struct xpcie_epf *xpcie_epf = container_of(xpcie,
-						   struct xpcie_epf, xpcie);
-	struct device *dma_dev = xpcie_epf->epf->epc->dev.parent;
 	struct xpcie_interface *inf = &xpcie->interfaces[0];
 	struct xpcie_stream *tx = &xpcie->tx;
 	struct xpcie_stream *rx = &xpcie->rx;
@@ -107,11 +104,6 @@ static void intel_xpcie_txrx_cleanup(struct xpcie *xpcie)
 	intel_xpcie_list_cleanup(&xpcie->tx_pool);
 	intel_xpcie_list_cleanup(&xpcie->rx_pool);
 
-	if (xpcie_epf->tx_virt) {
-		dma_free_coherent(dma_dev, xpcie_epf->tx_size,
-				  xpcie_epf->tx_virt, xpcie_epf->tx_phys);
-	}
-
 	mutex_unlock(&inf->rlock);
 	mutex_unlock(&xpcie->wlock);
 }
@@ -177,13 +169,13 @@ static int intel_xpcie_txrx_init(struct xpcie *xpcie,
 	tx_pool_size = roundup(SZ_32M, xpcie->fragment_size);
 	ndesc = tx_pool_size / xpcie->fragment_size;
 
-	xpcie_epf->tx_size = tx_pool_size;
-	xpcie_epf->tx_virt = dma_alloc_coherent(dma_dev,
-						xpcie_epf->tx_size,
-						&xpcie_epf->tx_phys,
-						GFP_KERNEL);
-	if (!xpcie_epf->tx_virt)
-		goto error;
+	if (!xpcie_epf->tx_virt) {
+		xpcie_epf->tx_size = tx_pool_size;
+		xpcie_epf->tx_virt = dma_alloc_coherent(dma_dev,
+							xpcie_epf->tx_size,
+							&xpcie_epf->tx_phys,
+							GFP_KERNEL);
+	}
 
 	for (index = 0; index < ndesc; index++) {
 		bd = intel_xpcie_alloc_bd_reuse(xpcie->fragment_size,
@@ -346,7 +338,7 @@ static void intel_xpcie_rx_event_handler(struct work_struct *work)
 
 	if (head != initial_head) {
 		intel_xpcie_set_tdr_head(&rx->pipe, head);
-		intel_xpcie_raise_irq(xpcie, DATA_RECEIVED);
+		intel_xpcie_raise_irq(xpcie, DATA_RECEIVED, 1);
 	}
 
 task_exit:
@@ -445,7 +437,7 @@ static void intel_xpcie_tx_event_handler(struct work_struct *work)
 
 	if (intel_xpcie_get_tdr_tail(&tx->pipe) != tail) {
 		intel_xpcie_set_tdr_tail(&tx->pipe, tail);
-		intel_xpcie_raise_irq(xpcie, DATA_SENT);
+		intel_xpcie_raise_irq(xpcie, DATA_SENT, 1);
 	}
 
 task_exit:
@@ -483,7 +475,7 @@ static irqreturn_t intel_xpcie_core_irq_cb(int irq, void *args)
 		if (xpcie->tx_pending)
 			intel_xpcie_start_tx(xpcie, 0);
 		else
-			intel_xpcie_raise_irq(xpcie, DATA_SENT);
+			intel_xpcie_raise_irq(xpcie, DATA_SENT, 1);
 	}
 
 	return IRQ_HANDLED;
diff --git a/drivers/misc/xlink-pcie/local_host/dma.c b/drivers/misc/xlink-pcie/local_host/dma.c
index e8106a0ce861..e841c7f6a29d 100644
--- a/drivers/misc/xlink-pcie/local_host/dma.c
+++ b/drivers/misc/xlink-pcie/local_host/dma.c
@@ -545,27 +545,24 @@ static void intel_xpcie_ep_dma_free_ll_descs_mem(struct xpcie_epf *xpcie_epf)
 #else
 	struct device *dma_dev = xpcie_epf->epf->epc->dev.parent;
 #endif
-	int i;
-
-	for (i = 0; i < DMA_CHAN_NUM; i++) {
-		if (xpcie_epf->tx_desc_buf.virt) {
-			dma_free_coherent(dma_dev,
-					  xpcie_epf->tx_desc_buf.size,
-					  xpcie_epf->tx_desc_buf.virt,
-					  xpcie_epf->tx_desc_buf.phys);
-		}
-		if (xpcie_epf->rx_desc_buf.virt) {
-			dma_free_coherent(dma_dev,
-					  xpcie_epf->rx_desc_buf.size,
-					  xpcie_epf->rx_desc_buf.virt,
-					  xpcie_epf->rx_desc_buf.phys);
-		}
 
-		memset(&xpcie_epf->tx_desc_buf, 0,
-		       sizeof(struct xpcie_dma_ll_desc_buf));
-		memset(&xpcie_epf->rx_desc_buf, 0,
-		       sizeof(struct xpcie_dma_ll_desc_buf));
+	if (xpcie_epf->tx_desc_buf.virt) {
+		dma_free_coherent(dma_dev,
+				  xpcie_epf->tx_desc_buf.size,
+				  xpcie_epf->tx_desc_buf.virt,
+				  xpcie_epf->tx_desc_buf.phys);
+	}
+	if (xpcie_epf->rx_desc_buf.virt) {
+		dma_free_coherent(dma_dev,
+				  xpcie_epf->rx_desc_buf.size,
+				  xpcie_epf->rx_desc_buf.virt,
+				  xpcie_epf->rx_desc_buf.phys);
 	}
+
+	memset(&xpcie_epf->tx_desc_buf, 0,
+	       sizeof(struct xpcie_dma_ll_desc_buf));
+	memset(&xpcie_epf->rx_desc_buf, 0,
+	       sizeof(struct xpcie_dma_ll_desc_buf));
 }
 
 static int intel_xpcie_ep_dma_alloc_ll_descs_mem(struct xpcie_epf *xpcie_epf)
@@ -601,6 +598,28 @@ static int intel_xpcie_ep_dma_alloc_ll_descs_mem(struct xpcie_epf *xpcie_epf)
 	return 0;
 }
 
+void intel_xpcie_ep_stop_dma(struct pci_epf *epf)
+{
+	struct xpcie_epf *xpcie_epf = epf_get_drvdata(epf);
+	void __iomem *dma_base = xpcie_epf->dma_base;
+	struct pcie_dma_reg *dma_reg = (struct pcie_dma_reg *)dma_base;
+	int chan;
+
+	chan = xpcie_epf->epf->func_no;
+	chan = chan | (1 << 31);
+	iowrite32((u32)chan, &dma_reg->dma_write_doorbell);
+	iowrite32((u32)chan, &dma_reg->dma_read_doorbell);
+
+	intel_xpcie_ep_dma_free_ll_descs_mem(xpcie_epf);
+}
+
+void intel_xpcie_ep_start_dma(struct pci_epf *epf)
+{
+	struct xpcie_epf *xpcie_epf = epf_get_drvdata(epf);
+
+	intel_xpcie_ep_dma_alloc_ll_descs_mem(xpcie_epf);
+}
+
 int intel_xpcie_ep_dma_reset(struct pci_epf *epf)
 {
 	struct xpcie_epf *xpcie_epf = epf_get_drvdata(epf);
diff --git a/drivers/misc/xlink-pcie/local_host/epf.c b/drivers/misc/xlink-pcie/local_host/epf.c
index c3a7ec0539c5..132d808704ef 100644
--- a/drivers/misc/xlink-pcie/local_host/epf.c
+++ b/drivers/misc/xlink-pcie/local_host/epf.c
@@ -7,6 +7,7 @@
  *
  ****************************************************************************/
 
+#include <linux/delay.h>
 #include <linux/of.h>
 #include <linux/platform_device.h>
 #include <linux/reboot.h>
@@ -144,13 +145,13 @@ void intel_xpcie_register_host_irq(struct xpcie *xpcie, irq_handler_t func)
 	xpcie_epf->core_irq_callback = func;
 }
 
-int intel_xpcie_raise_irq(struct xpcie *xpcie, enum xpcie_doorbell_type type)
+int intel_xpcie_raise_irq(struct xpcie *xpcie, enum xpcie_doorbell_type type, u8 value)
 {
 	struct xpcie_epf *xpcie_epf = container_of(xpcie,
 						   struct xpcie_epf, xpcie);
 	struct pci_epf *epf = xpcie_epf->epf;
 
-	intel_xpcie_set_doorbell(xpcie, FROM_DEVICE, type, 1);
+	intel_xpcie_set_doorbell(xpcie, FROM_DEVICE, type, value);
 
 	return pci_epc_raise_irq(epf->epc, epf->func_no, PCI_EPC_IRQ_MSI, 1);
 }
@@ -173,6 +174,16 @@ static irqreturn_t intel_xpcie_err_interrupt(int irq, void *args)
 }
 #endif
 
+void intel_xpcie_pci_notify_event(struct xpcie_epf *xdev,
+				  enum xlink_device_event_type event_type)
+{
+	if (event_type >= NUM_EVENT_TYPE)
+		return;
+
+	if (xdev->event_fn)
+		xdev->event_fn(xdev->sw_devid, event_type);
+}
+
 static irqreturn_t intel_xpcie_host_interrupt(int irq, void *args)
 {
 	struct xpcie *xpcie = args;
@@ -196,6 +207,12 @@ static irqreturn_t intel_xpcie_host_interrupt(int irq, void *args)
 		intel_xpcie_set_doorbell(xpcie, TO_DEVICE, DEV_EVENT, NO_OP);
 		if (event == REQUEST_RESET)
 			orderly_reboot();
+
+		if (event == PREP_FLR_RESET) {
+			writel(0x1, xpcie->doorbell_clear);
+			schedule_work(&xpcie_epf->flr_irq_event);
+		}
+
 		return IRQ_HANDLED;
 	}
 
@@ -206,7 +223,8 @@ static irqreturn_t intel_xpcie_host_interrupt(int irq, void *args)
 			phy_id = intel_xpcie_get_physical_device_id(xpcie);
 			max_functions = intel_xpcie_get_max_functions(xpcie);
 			xpcie_epf->sw_devid =
-				intel_xpcie_create_sw_device_id(xpcie_epf->epf->func_no, phy_id, max_functions);
+			intel_xpcie_create_sw_device_id(xpcie_epf->epf->func_no,
+							phy_id, max_functions);
 			xpcie_epf->sw_dev_id_updated = true;
 			dev_info(xpcie_to_dev(xpcie),
 				 "pcie: func_no=%x swid updated=%x phy_id=%x\n",
@@ -225,6 +243,59 @@ static irqreturn_t intel_xpcie_host_interrupt(int irq, void *args)
 	return IRQ_HANDLED;
 }
 
+static void intel_xpcie_handle_flr_work(struct work_struct *work)
+{
+	struct xpcie_epf *xpcie_epf = container_of(work, struct xpcie_epf,
+						   flr_irq_event);
+	struct xpcie *xpcie = &xpcie_epf->xpcie;
+
+	intel_xpcie_pci_notify_event(xpcie_epf, NOTIFY_DEVICE_DISCONNECTED);
+	intel_xpcie_core_cleanup(&xpcie_epf->xpcie);
+	intel_xpcie_ep_stop_dma(xpcie_epf->epf);
+	intel_xpcie_set_device_status(&xpcie_epf->xpcie, XPCIE_STATUS_OFF);
+	intel_xpcie_raise_irq(xpcie, DEV_EVENT, PREP_FLR_RESET_ACK);
+	dev_info(&xpcie_epf->epf->dev, "FLR Initiated ..\n");
+}
+
+static irqreturn_t intel_xpcie_flr_interrupt(int irq_flr, void *args)
+{
+	struct xpcie *xpcie = args;
+	struct xpcie_epf *xpcie_epf = container_of(xpcie, struct xpcie_epf, xpcie);
+	struct pci_epf *epf = xpcie_epf->epf;
+
+	if (!xpcie_epf->apb_base)
+		return IRQ_HANDLED;
+
+	writel(1 << (epf->func_no), xpcie_epf->apb_base + 0x20);
+	readl(xpcie_epf->apb_base + 0x20);
+	schedule_work(&xpcie_epf->flr_irq_event);
+
+	return IRQ_HANDLED;
+}
+
+int intel_xpcie_pci_flr_reset(u32 id)
+{
+	return 0;
+}
+
+int intel_xpcie_pci_ack_flr_reset(u32 id)
+{
+	struct xpcie_epf *xpcie_epf = intel_xpcie_get_device_by_id(id);
+	struct xpcie *xpcie = &xpcie_epf->xpcie;
+
+	if (intel_xpcie_get_device_status(xpcie) == XPCIE_STATUS_OFF) {
+		msleep(1000);
+		intel_xpcie_ep_start_dma(xpcie_epf->epf);
+		intel_xpcie_core_init(xpcie);
+		intel_xpcie_set_device_status(xpcie, XPCIE_STATUS_RUN);
+		intel_xpcie_raise_irq(xpcie, DEV_EVENT, FLR_RESET_ACK);
+		intel_xpcie_pci_notify_event(xpcie_epf, NOTIFY_DEVICE_CONNECTED);
+		dev_info(&xpcie_epf->epf->dev, "FLR Reset Successful\n");
+	}
+
+	return 0;
+}
+
 static int intel_xpcie_check_bar(struct pci_epf *epf,
 				 struct pci_epf_bar *epf_bar,
 				 enum pci_barno barno,
@@ -311,9 +382,6 @@ static int intel_xpcie_setup_bar(struct pci_epf *epf, enum pci_barno barno,
 	struct pci_epc *epc = epf->epc;
 	struct xpcie_epf *xpcie_epf = epf_get_drvdata(epf);
 	struct pci_epf_bar *bar = &epf->bar[barno];
-	//struct dw_pcie_ep *ep = epc_get_drvdata(epc);
-	//struct dw_pcie *pci = to_dw_pcie_from_ep(ep);
-	//struct thunderbay_pcie *thunderbay = to_thunderbay_pcie(pci);
 
 	bar->flags |= PCI_BASE_ADDRESS_MEM_TYPE_64;
 	bar->size = size;
@@ -565,13 +633,19 @@ static void intel_xpcie_enable_multi_functions(struct pci_epf *epf)
 				ioremap(doorbell_clr_addr, doorbell_clr_size);
 	intel_xpcie_set_max_functions(&xpcie_epf->xpcie, epc->max_functions);
 	list_add_tail(&xpcie_epf->list, &dev_list);
-	snprintf(xpcie_epf->name, MXLK_MAX_NAME_LEN, "%s_func%x", epf->name,
+	snprintf(xpcie_epf->name, XPCIE_MAX_NAME_LEN, "%s_func%x", epf->name,
 		 epf->func_no);
 	ret = request_irq(xpcie_epf->irq_doorbell,
 			  &intel_xpcie_host_interrupt, 0, XPCIE_DRIVER_NAME,
 			  &xpcie_epf->xpcie);
 	if (ret)
 		dev_err(&epf->dev, "failed to request irq\n");
+
+	ret = request_irq(xpcie_epf->irq_flr, &intel_xpcie_flr_interrupt, 0,
+			  XPCIE_DRIVER_NAME, &xpcie_epf->xpcie);
+	if (ret)
+		dev_err(&epf->dev, "failed to request FLR irq\n");
+	INIT_WORK(&xpcie_epf->flr_irq_event, intel_xpcie_handle_flr_work);
 }
 
 static int intel_xpcie_epf_get_platform_data(struct device *dev,
@@ -590,12 +664,20 @@ static int intel_xpcie_epf_get_platform_data(struct device *dev,
 	if (IS_ERR(xpcie_epf->dbi_base))
 		return PTR_ERR(xpcie_epf->dbi_base);
 
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "apb");
+	xpcie_epf->apb_base =
+		devm_ioremap(dev, res->start, resource_size(res));
+	if (IS_ERR(xpcie_epf->apb_base))
+		return PTR_ERR(xpcie_epf->apb_base);
+
 	xpcie_epf->irq_doorbell = irq_of_parse_and_map(pdev->dev.of_node,
 						       epf->func_no + 2);
 	xpcie_epf->irq_wdma = irq_of_parse_and_map(pdev->dev.of_node,
 						   epf->func_no + 10);
 	xpcie_epf->irq_rdma = irq_of_parse_and_map(pdev->dev.of_node,
 						   epf->func_no + 18);
+	xpcie_epf->irq_flr = irq_of_parse_and_map(pdev->dev.of_node,
+						  epf->func_no + 26);
 
 	xpcie_epf->doorbell_base = platform_get_resource_byname(pdev,
 								IORESOURCE_MEM,
@@ -620,7 +702,7 @@ static int intel_xpcie_epf_get_platform_data(struct device *dev,
 	else if (epc->max_functions == 4)
 		xpcie_epf->tbh_half = 1;
 
-	return 0;
+	return ret;
 }
 #else
 static int intel_xpcie_epf_get_platform_data(struct device *dev,
@@ -705,7 +787,6 @@ static ssize_t swdev_id_store(struct device *dev,
 {
 	return count;
 }
-
 static DEVICE_ATTR(swdev_id, S_IRWXU, swdev_id_show, swdev_id_store);
 
 void intel_xpcie_init_sysfs_swdev_id(struct xpcie *xpcie, struct device *dev)
@@ -790,7 +871,7 @@ static int intel_xpcie_epf_bind(struct pci_epf *epf)
 	}
 
 	ret = devm_request_irq(&epf->dev, xpcie_epf->irq_err,
-			       &(intel_xpcie_err_interrupt), 0,
+			       &intel_xpcie_err_interrupt, 0,
 			       XPCIE_DRIVER_NAME, &xpcie_epf->xpcie);
 	if (ret) {
 		dev_err(&epf->dev, "failed to request error irq\n");
diff --git a/drivers/misc/xlink-pcie/local_host/epf.h b/drivers/misc/xlink-pcie/local_host/epf.h
index 916f38f20bb5..a31a429f3c23 100644
--- a/drivers/misc/xlink-pcie/local_host/epf.h
+++ b/drivers/misc/xlink-pcie/local_host/epf.h
@@ -16,7 +16,7 @@
 #include "../common/xpcie.h"
 #include "../common/util.h"
 
-#define XPCIE_DRIVER_NAME "mxlk_pcie_epf"
+#define XPCIE_DRIVER_NAME "intel_xpcie_pcie_epf"
 #define XPCIE_DRIVER_DESC "Intel(R) xLink PCIe endpoint function driver"
 
 #define KEEMBAY_XPCIE_STEPPING_MAXLEN 8
@@ -73,6 +73,7 @@ struct xpcie_epf {
 	int                             irq_doorbell;
 	int                             irq_rdma;
 	int                             irq_wdma;
+	int				irq_flr;
 	wait_queue_head_t		dma_rd_wq;
 	bool				dma_rd_done;
 	wait_queue_head_t		dma_wr_wq;
@@ -109,6 +110,9 @@ struct xpcie_epf {
 	u32                             sw_devid;
 	bool                            sw_dev_id_updated;
 	struct list_head                list;
+	xlink_device_event event_fn;
+
+	struct work_struct flr_irq_event;
 #endif
 };
 
@@ -128,11 +132,14 @@ int intel_xpcie_ep_dma_uninit(struct pci_epf *epf);
 int intel_xpcie_ep_dma_reset(struct pci_epf *epf);
 int intel_xpcie_ep_dma_read_ll(struct pci_epf *epf, int chan, int descs_num);
 int intel_xpcie_ep_dma_write_ll(struct pci_epf *epf, int chan, int descs_num);
+void intel_xpcie_ep_stop_dma(struct pci_epf *epf);
+void intel_xpcie_ep_start_dma(struct pci_epf *epf);
 
 void intel_xpcie_register_host_irq(struct xpcie *xpcie,
 				   irq_handler_t func);
 int intel_xpcie_raise_irq(struct xpcie *xpcie,
-			  enum xpcie_doorbell_type type);
+			  enum xpcie_doorbell_type type,
+			  u8 value);
 int intel_xpcie_copy_from_host_ll(struct xpcie *xpcie,
 				  int chan, int descs_num);
 int intel_xpcie_copy_to_host_ll(struct xpcie *xpcie,
@@ -144,4 +151,7 @@ int intel_xpcie_copy_to_host_ll(struct xpcie *xpcie,
 void intel_xpcie_init_sysfs_swdev_id(struct xpcie *xpcie, struct device *dev);
 void intel_xpcie_uninit_sysfs_swdev_id(struct xpcie *xpcie, struct device *dev);
 
+void intel_xpcie_pci_notify_event(struct xpcie_epf *xdev,
+				  enum xlink_device_event_type event_type);
+
 #endif /* XPCIE_EPF_HEADER_ */
diff --git a/drivers/misc/xlink-pcie/remote_host/pci.c b/drivers/misc/xlink-pcie/remote_host/pci.c
index 0cf6091d1221..11a46313b55d 100644
--- a/drivers/misc/xlink-pcie/remote_host/pci.c
+++ b/drivers/misc/xlink-pcie/remote_host/pci.c
@@ -196,6 +196,10 @@ static irqreturn_t intel_xpcie_core_interrupt(int irq, void *args)
 		schedule_delayed_work(&xdev->shutdown_event, 0);
 		return IRQ_HANDLED;
 	}
+	if (event == PREP_FLR_RESET_ACK || event == FLR_RESET_ACK) {
+		schedule_work(&xdev->flr_event);
+		return IRQ_HANDLED;
+	}
 
 	if (likely(xdev->core_irq_callback))
 		return xdev->core_irq_callback(irq, args);
@@ -291,7 +295,8 @@ static void xpcie_device_poll(struct work_struct *work)
 }
 
 static int intel_xpcie_pci_prepare_dev_reset(struct xpcie_dev *xdev,
-					     bool notify)
+					     bool notify,
+					     enum xpcie_event_type type)
 {
 	if (mutex_lock_interruptible(&xdev->lock))
 		return -EINTR;
@@ -302,7 +307,7 @@ static int intel_xpcie_pci_prepare_dev_reset(struct xpcie_dev *xdev,
 	}
 	xdev->xpcie.status = XPCIE_STATUS_OFF;
 	if (notify)
-		intel_xpcie_pci_raise_irq(xdev, DEV_EVENT, REQUEST_RESET);
+		intel_xpcie_pci_raise_irq(xdev, DEV_EVENT, type);
 
 	mutex_unlock(&xdev->lock);
 
@@ -314,7 +319,29 @@ static void xpcie_device_shutdown(struct work_struct *work)
 	struct xpcie_dev *xdev = container_of(work, struct xpcie_dev,
 					      shutdown_event.work);
 
-	intel_xpcie_pci_prepare_dev_reset(xdev, false);
+	intel_xpcie_pci_prepare_dev_reset(xdev, false, REQUEST_RESET);
+}
+
+static void intel_xpcie_handle_flr_work(struct work_struct *work)
+{
+	struct xpcie_dev *xdev = container_of(work, struct xpcie_dev,
+					      flr_event);
+	u8 event;
+
+	event = intel_xpcie_get_doorbell(&xdev->xpcie, FROM_DEVICE, DEV_EVENT);
+	if (event == PREP_FLR_RESET_ACK) {
+		pr_info("FLR Reset Initiated ...\n");
+		intel_xpcie_set_doorbell(&xdev->xpcie, FROM_DEVICE,
+					 DEV_EVENT, NO_OP);
+		pci_reset_function(xdev->pci);
+	}
+	if (event == FLR_RESET_ACK) {
+		intel_xpcie_set_doorbell(&xdev->xpcie, FROM_DEVICE,
+					 DEV_EVENT, NO_OP);
+		xdev->xpcie.status = XPCIE_STATUS_READY;
+		pr_info("FLR Reset Successful\n");
+		intel_xpcie_pci_notify_event(xdev, NOTIFY_DEVICE_CONNECTED);
+	}
 }
 
 static int xpcie_device_init(struct xpcie_dev *xdev)
@@ -325,6 +352,7 @@ static int xpcie_device_init(struct xpcie_dev *xdev)
 	INIT_DELAYED_WORK(&xdev->shutdown_event, xpcie_device_shutdown);
 #if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 	INIT_WORK(&xdev->irq_event, xpcie_device_irq);
+	INIT_WORK(&xdev->flr_event, intel_xpcie_handle_flr_work);
 #endif
 	rc = intel_xpcie_pci_irq_init(xdev);
 	if (rc)
@@ -584,7 +612,7 @@ int intel_xpcie_pci_reset_device(u32 id)
 	if (!xdev)
 		return -ENOMEM;
 
-	return intel_xpcie_pci_prepare_dev_reset(xdev, true);
+	return intel_xpcie_pci_prepare_dev_reset(xdev, true, REQUEST_RESET);
 }
 
 int intel_xpcie_pci_register_device_event(u32 sw_device_id,
@@ -628,6 +656,27 @@ void intel_xpcie_pci_notify_event(struct xpcie_dev *xdev,
 }
 
 #if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
+
+int intel_xpcie_pci_flr_reset(u32 id)
+{
+	struct xpcie_dev *xdev = intel_xpcie_get_device_by_id(id);
+	int rc;
+
+	if (!xdev)
+		return -ENOMEM;
+
+	rc = intel_xpcie_pci_prepare_dev_reset(xdev, true, PREP_FLR_RESET);
+	if (!rc)
+		intel_xpcie_pci_notify_event(xdev, NOTIFY_DEVICE_DISCONNECTED);
+
+	return rc;
+}
+
+int intel_xpcie_pci_ack_flr_reset(u32 id)
+{
+	return 0;
+}
+
 struct xpcie_dev *intel_xpcie_get_device_by_name(const char *name)
 {
 	struct xpcie_dev *p;
diff --git a/drivers/misc/xlink-pcie/remote_host/pci.h b/drivers/misc/xlink-pcie/remote_host/pci.h
index 1eb370695c27..0de7ff2655a4 100644
--- a/drivers/misc/xlink-pcie/remote_host/pci.h
+++ b/drivers/misc/xlink-pcie/remote_host/pci.h
@@ -52,6 +52,7 @@ struct xpcie_dev {
 
 #if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 	struct work_struct irq_event;
+	struct work_struct flr_event;
 	bool boot_dev_link;
 	mxlk_pcie_boot_event boot_notif_fn;
 
diff --git a/include/linux/xlink_drv_inf.h b/include/linux/xlink_drv_inf.h
index 180ec038eb62..8826c4c1a811 100644
--- a/include/linux/xlink_drv_inf.h
+++ b/include/linux/xlink_drv_inf.h
@@ -85,4 +85,6 @@ int xlink_pcie_reset_device(u32 sw_device_id);
 int xlink_pcie_register_device_event(u32 sw_device_id,
 				     xlink_device_event event_notif_fn);
 int xlink_pcie_unregister_device_event(u32 sw_device_id);
+int xlink_pcie_flr_reset(u32 sw_device_id);
+int xlink_pcie_ack_flr_reset(u32 sw_device_id);
 #endif
-- 
2.27.0

