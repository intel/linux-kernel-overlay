From ae6dacbcbf4c58477d010a0fbb95e996231eef2d Mon Sep 17 00:00:00 2001
From: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
Date: Tue, 21 Jul 2020 21:49:26 -0700
Subject: [PATCH 42/82] driver: base: Add driver filter support
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Intel's Trust Domain Extensions (TDX) is a new Intel technology that
adds support for VMs to work with untrusted VMM. So, for such a type
of VM guest, since VMM is an untrusted entity, any device driver
that consume data from VMM had to be audited and hardened against
attack from the host. But, it is not feasible to do this hardening for
all drivers in the tree, and also not useful since nearly all of them
will never be virtualized. So, in TDX, to prevent a malicious VMM
cherry-picking a vulnerable driver and triggers its load by presenting
its PCI IDs in config space, only permit driverÂ registration
for drivers that have been allow-listed.

Driver filter framework adds a hook (is_driver_pg_trusted()) in
driver_register() interface. It will called for every driver registered
in the kernel, which will in turn be used to allow or dis-allow the
given driver based on platform specific driver allow list. If the
driver is not-allowed, it will fail the driver_register() and return
-EACCESS error.

Current driver filter policy is to block all drivers unless platform
allow it based on the filter list.

Another way to prevent probes of untrusted drivers is to use a custom
kernel config for TDX. But this approach will not work for all TDX
guest with standard distribution kernels that have all drivers enabled.

Per driver opt-in model is also considered as an alternative design
choice, but it seems safer to have a central allow list, instead of a
"driver self serve" that might be abused by mistake by driver authors
cutting and pasting the code.

Per device id based filter is originally considered as an alternative
filter choice, but switched to blocking (or rather allowing) per
device driver because our goal is to allow only audited drivers.

Since the default filter policy is BLOCK_ALL, some generic safe drivers
will also be blocked until it is explicitly allowed. Since there is
easy way to identify these drivers, it is all blocked for now. So
far no breakages have been noticed due to these blocked drivers.

Some examples of blocked drivers are,

filter: bus:platform driver:reg-dummy blocked
filter: bus:platform driver:alarmtimer blocked
filter: bus:platform driver:dw-pcie blocked
filter: bus:platform driver:vesa-framebuffer blocked
filter: bus:platform driver:efi-framebuffer blocked
filter: bus:platform driver:acpi-ged blocked
filter: bus:platform driver:gpio-clk blocked
filter: bus:platform driver:clk-pmc-atom blocked

NOTE: This driver filter only covers drivers that are using the
standard driver registration mechanism. Other drivers will need to be
handled separately through other mechanisms.

Details about TDX technology can be found in following link:

https://software.intel.com/content/www/br/pt/develop/articles/intel-trust-domain-extensions.html

Reviewed-by: Andi Kleen <ak@linux.intel.com>
Signed-off-by: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
---
 drivers/base/Makefile           |   2 +-
 drivers/base/base.h             |   2 +
 drivers/base/driver.c           |   3 +
 drivers/base/filter.c           | 103 ++++++++++++++++++++++++++++++++
 include/linux/device/filter.h   |  49 +++++++++++++++
 include/linux/protected_guest.h |   2 +
 6 files changed, 160 insertions(+), 1 deletion(-)
 create mode 100644 drivers/base/filter.c
 create mode 100644 include/linux/device/filter.h

diff --git a/drivers/base/Makefile b/drivers/base/Makefile
index 8b93a7f291ec..9e63bd7ecb1d 100644
--- a/drivers/base/Makefile
+++ b/drivers/base/Makefile
@@ -6,7 +6,7 @@ obj-y			:= component.o core.o bus.o dd.o syscore.o \
 			   cpu.o firmware.o init.o map.o devres.o \
 			   attribute_container.o transport_class.o \
 			   topology.o container.o property.o cacheinfo.o \
-			   swnode.o
+			   swnode.o filter.o
 obj-$(CONFIG_AUXILIARY_BUS) += auxiliary.o
 obj-$(CONFIG_DEVTMPFS)	+= devtmpfs.o
 obj-y			+= power/
diff --git a/drivers/base/base.h b/drivers/base/base.h
index e5f9b7e656c3..ebdaad816633 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -203,3 +203,5 @@ int devtmpfs_delete_node(struct device *dev);
 static inline int devtmpfs_create_node(struct device *dev) { return 0; }
 static inline int devtmpfs_delete_node(struct device *dev) { return 0; }
 #endif
+
+bool is_driver_pg_trusted(struct device_driver *drv);
diff --git a/drivers/base/driver.c b/drivers/base/driver.c
index 8c0d33e182fd..608904cd0e7d 100644
--- a/drivers/base/driver.c
+++ b/drivers/base/driver.c
@@ -168,6 +168,9 @@ int driver_register(struct device_driver *drv)
 		return -EBUSY;
 	}
 
+	if (!is_driver_pg_trusted(drv))
+		return -EACCES;
+
 	ret = bus_add_driver(drv);
 	if (ret)
 		return ret;
diff --git a/drivers/base/filter.c b/drivers/base/filter.c
new file mode 100644
index 000000000000..0b6bd0e60b57
--- /dev/null
+++ b/drivers/base/filter.c
@@ -0,0 +1,103 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * filter.c - Add driver filter framework.
+ *
+ * Implements APIs required for registering platform specific
+ * driver filter.
+ *
+ * Copyright (c) 2020 Intel Corporation
+ *
+ * Author: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
+ */
+#include <linux/init.h>
+#include <linux/device/filter.h>
+#include <linux/acpi.h>
+#include <linux/protected_guest.h>
+
+#include "base.h"
+
+/* List of filter allow list */
+static LIST_HEAD(driver_filter_list);
+
+/* Protects driver_filter_list add/read operations*/
+static DEFINE_SPINLOCK(driver_filter_lock);
+
+/*
+ * Compares the driver name with given filter node allow list.
+ *
+ * Return true if driver name matches with allow list.
+ */
+static bool is_driver_allowed(struct device_driver *drv,
+			      struct drv_filter_node *node)
+{
+	char **allow_list;
+	int i;
+
+	if (!drv || !node)
+		return false;
+
+	/*
+	 * Make sure driver bus name matches with filter node.
+	 */
+	if (!drv->bus || strcmp(drv->bus->name, node->bus_name))
+		return false;
+
+	/* If allow list is not given, return default filter status */
+	if (!node->allow_list)
+		return node->default_status;
+
+	allow_list = node->allow_list;
+
+	for (i = 0; i < node->len; i++)
+		if (!strncmp(allow_list[i], drv->name, strlen(allow_list[i])))
+			return true;
+
+	return false;
+}
+
+/*
+ * is_driver_pg_trusted() - Check whether given driver is trusted
+ *			    or not based on platform specific driver
+ *			    filter list.
+ *
+ * This filter is currently only enabled for protected guests.
+ *
+ */
+bool is_driver_pg_trusted(struct device_driver *drv)
+{
+	bool status = false;
+	struct drv_filter_node *node;
+
+	/* If platform does not support driver filter, allow all */
+	if (!prot_guest_has(PR_GUEST_DRIVER_FILTER))
+		return true;
+
+	spin_lock(&driver_filter_lock);
+
+	/*
+	 * Check whether the driver is allowed using platform
+	 * registered filter lists.
+	 */
+	list_for_each_entry(node, &driver_filter_list, list) {
+		if (is_driver_allowed(drv, node)) {
+			status = true;
+			break;
+		}
+	}
+
+	pr_filter_dbg("bus:%s driver:%s %s\n",
+		      drv->bus ? drv->bus->name : "null",
+		      drv->name,
+		      status ? "allowed" : "blocked");
+
+	spin_unlock(&driver_filter_lock);
+
+	return status;
+}
+
+void register_drv_filter(struct drv_filter_node *node)
+{
+	spin_lock(&driver_filter_lock);
+	list_add_tail(&node->list, &driver_filter_list);
+	spin_unlock(&driver_filter_lock);
+}
diff --git a/include/linux/device/filter.h b/include/linux/device/filter.h
new file mode 100644
index 000000000000..628d32d8aa29
--- /dev/null
+++ b/include/linux/device/filter.h
@@ -0,0 +1,49 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * filter.h - Driver filter specific header
+ *
+ * Copyright (c) 2020 Intel Corporation
+ *
+ * Author: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
+ */
+
+#ifndef _DEVICE_FILTER_H_
+#define _DEVICE_FILTER_H_
+
+#include <linux/device/bus.h>
+#include <linux/device/driver.h>
+#include <linux/device.h>
+
+#define FILTER_TAG	"filter: "
+
+#define pr_filter_dbg(fmt, ...) \
+	pr_debug(FILTER_TAG fmt, ##__VA_ARGS__)
+#define pr_filter_info(fmt, ...) \
+	pr_info(FILTER_TAG fmt, ##__VA_ARGS__)
+#define pr_filter_crit(fmt, ...) \
+	pr_crit(FILTER_TAG fmt, ##__VA_ARGS__)
+
+enum filter_policy {
+	BLOCK_ALL = 0, /* Block all drivers */
+	ALLOW_ALL = 1  /* Allow all drivers */
+};
+
+/**
+ * struct drv_filter_node - driver filter node
+ *
+ * @bus_name		: Name of the bus.
+ * @allow_list		: Driver name based allow list.
+ * @len:		: Length of the allow list.
+ * @default_status	: Default status if allow list is empty.
+ */
+struct drv_filter_node {
+	char *bus_name;
+	char **allow_list;
+	unsigned int len;
+	bool default_status;
+	struct list_head list;
+};
+
+/* Register platform specific filter allow list */
+void register_drv_filter(struct drv_filter_node *node);
+#endif
diff --git a/include/linux/protected_guest.h b/include/linux/protected_guest.h
index c5b7547e5a68..805b79a70543 100644
--- a/include/linux/protected_guest.h
+++ b/include/linux/protected_guest.h
@@ -20,6 +20,8 @@
 #define PR_GUEST_HOST_MEM_ENCRYPT		0x1003
 /* Support for shared mapping initialization (after early init) */
 #define PR_GUEST_SHARED_MAPPING_INIT		0x1004
+/* Support for driver filter */
+#define PR_GUEST_DRIVER_FILTER			0x1005
 
 #ifdef CONFIG_ARCH_HAS_PROTECTED_GUEST
 #include <asm/protected_guest.h>
-- 
2.27.0

