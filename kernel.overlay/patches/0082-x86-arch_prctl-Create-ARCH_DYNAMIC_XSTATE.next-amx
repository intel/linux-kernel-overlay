From a4adc32d381809f13c63363fa2c64ba7c4ba2776 Mon Sep 17 00:00:00 2001
From: "Chang S. Bae" <chang.seok.bae@intel.com>
Date: Wed, 14 Apr 2021 15:43:20 -0700
Subject: [PATCH 82/94] x86/arch_prctl: Create ARCH_DYNAMIC_XSTATE

N.B. This interface is currently under active discussion on LKML. This v2
proposal implements a per-process system call without PUT semantics.

arch_prctl(ARCH_DYNAMIC_XSTATE)
    Each user process requests access to the hardware features the use of
    which is detectable and controllable by the kernel.
    Child process inherits the parent's permission but it is reset when
    executing a file.
    Return codes:
        0: success (including repeated calls)
        EINVAL: no hardware feature for the request

The permission is now checked whenever the kernel needs to expand the
xstate per-task buffer.

Signed-off-by: Chang S. Bae <chang.seok.bae@intel.com>
---
Changes from v5:
* Switched to per-process permission. (Multiple folks)
---
 arch/x86/include/asm/fpu/xstate.h  |  3 +++
 arch/x86/include/asm/thread_info.h |  2 ++
 arch/x86/include/uapi/asm/prctl.h  |  2 ++
 arch/x86/kernel/fpu/regset.c       |  4 +--
 arch/x86/kernel/fpu/xstate.c       | 43 ++++++++++++++++++++++++++++++
 arch/x86/kernel/process.c          |  2 ++
 arch/x86/kernel/process_64.c       |  6 +++++
 arch/x86/kernel/traps.c            |  3 ++-
 8 files changed, 62 insertions(+), 3 deletions(-)

diff --git a/arch/x86/include/asm/fpu/xstate.h b/arch/x86/include/asm/fpu/xstate.h
index 6d7bcbe5b2a1..93f950fe6d49 100644
--- a/arch/x86/include/asm/fpu/xstate.h
+++ b/arch/x86/include/asm/fpu/xstate.h
@@ -121,6 +121,9 @@ unsigned int get_xstate_size(u64 mask);
 int alloc_xstate_buffer(struct fpu *fpu, u64 mask);
 void free_xstate_buffer(struct fpu *fpu);
 
+long set_process_dynamicstate_perm(struct task_struct *task);
+void reset_task_dynamicstate_perm(struct task_struct *task);
+
 const void *get_xsave_field_ptr(int xfeature_nr);
 int using_compacted_format(void);
 int xfeature_size(int xfeature_nr);
diff --git a/arch/x86/include/asm/thread_info.h b/arch/x86/include/asm/thread_info.h
index de406d93b515..bbc6497855f7 100644
--- a/arch/x86/include/asm/thread_info.h
+++ b/arch/x86/include/asm/thread_info.h
@@ -93,6 +93,7 @@ struct thread_info {
 #define TIF_MEMDIE		20	/* is terminating due to OOM killer */
 #define TIF_POLLING_NRFLAG	21	/* idle is polling for TIF_NEED_RESCHED */
 #define TIF_IO_BITMAP		22	/* uses I/O bitmap */
+#define TIF_DYNAMIC_XSTATE	23	/* allow a process to dynamically expand user xstate */
 #define TIF_FORCED_TF		24	/* true if TF in eflags artificially */
 #define TIF_BLOCKSTEP		25	/* set when we want DEBUGCTLMSR_BTF */
 #define TIF_LAZY_MMU_UPDATES	27	/* task is updating the mmu lazily */
@@ -115,6 +116,7 @@ struct thread_info {
 #define _TIF_SLD		(1 << TIF_SLD)
 #define _TIF_POLLING_NRFLAG	(1 << TIF_POLLING_NRFLAG)
 #define _TIF_IO_BITMAP		(1 << TIF_IO_BITMAP)
+#define _TIF_DYNAMIC_XSTATE	(1 << TIF_DYNAMIC_XSTATE)
 #define _TIF_FORCED_TF		(1 << TIF_FORCED_TF)
 #define _TIF_BLOCKSTEP		(1 << TIF_BLOCKSTEP)
 #define _TIF_LAZY_MMU_UPDATES	(1 << TIF_LAZY_MMU_UPDATES)
diff --git a/arch/x86/include/uapi/asm/prctl.h b/arch/x86/include/uapi/asm/prctl.h
index d962f0ec9ccf..7581d4d50969 100644
--- a/arch/x86/include/uapi/asm/prctl.h
+++ b/arch/x86/include/uapi/asm/prctl.h
@@ -10,6 +10,8 @@
 #define ARCH_GET_CPUID		0x1011
 #define ARCH_SET_CPUID		0x1012
 
+#define ARCH_DYNAMIC_XSTATE	0x1020
+
 #define ARCH_MAP_VDSO_X32	0x2001
 #define ARCH_MAP_VDSO_32	0x2002
 #define ARCH_MAP_VDSO_64	0x2003
diff --git a/arch/x86/kernel/fpu/regset.c b/arch/x86/kernel/fpu/regset.c
index 89040b6e2ee5..94a9d1487fdb 100644
--- a/arch/x86/kernel/fpu/regset.c
+++ b/arch/x86/kernel/fpu/regset.c
@@ -124,11 +124,11 @@ int xstateregs_set(struct task_struct *target, const struct user_regset *regset,
 
 	/*
 	 * When a ptracer attempts to write any dynamic user state in the target buffer but not
-	 * sufficiently allocated, it dynamically expands the buffer.
+	 * sufficiently allocated, it dynamically expands the buffer if permitted.
 	 *
 	 * Check if the expansion is possibly needed.
 	 */
-	if (xfeatures_mask_user_dynamic &&
+	if (xfeatures_mask_user_dynamic && test_tsk_thread_flag(target, TIF_DYNAMIC_XSTATE) &&
 	    ((fpu->state_mask & xfeatures_mask_user_dynamic) != xfeatures_mask_user_dynamic)) {
 		unsigned int offset, size;
 		u64 state_mask;
diff --git a/arch/x86/kernel/fpu/xstate.c b/arch/x86/kernel/fpu/xstate.c
index b08b97a14fb3..9f72c4b6f27b 100644
--- a/arch/x86/kernel/fpu/xstate.c
+++ b/arch/x86/kernel/fpu/xstate.c
@@ -1433,6 +1433,49 @@ int alloc_xstate_buffer(struct fpu *fpu, u64 mask)
 	return 0;
 }
 
+/**
+ * set_process_dynamicstate_perm() - Set a per-process permission to use dynamic user xstates.
+ * @task:	A struct task_struct * pointer
+ * Return:	0 if successful; otherwise, return a relevant error code.
+ */
+long set_process_dynamicstate_perm(struct task_struct *task)
+{
+	struct task_struct *t;
+
+	if (!xfeatures_mask_user_dynamic)
+		return -EINVAL;
+
+	if (test_tsk_thread_flag(task, TIF_DYNAMIC_XSTATE))
+		return 0;
+
+	for_each_thread(task, t)
+		set_tsk_thread_flag(t, TIF_DYNAMIC_XSTATE);
+	return 0;
+}
+
+/**
+ * reset_task_dynamicstate_perm() - Reset a task's permission to use dynamic user xstates.
+ * @task:       A struct task_struct * pointer
+ * Return:	None
+ */
+void reset_task_dynamicstate_perm(struct task_struct *task)
+{
+	struct fpu *fpu = &task->thread.fpu;
+
+	if (!xfeatures_mask_user_dynamic)
+		return;
+
+	fpu->state_mask = (xfeatures_mask_all & ~xfeatures_mask_user_dynamic);
+	free_xstate_buffer(fpu);
+	fpu->state = &fpu->__default_state;
+	if (using_compacted_format())
+		fpstate_init_xstate(&fpu->state->xsave, fpu->state_mask);
+
+	xfd_write(xfd_capable() ^ (fpu->state_mask & xfd_capable()));
+
+	clear_tsk_thread_flag(task, TIF_DYNAMIC_XSTATE);
+}
+
 static void fill_gap(struct membuf *to, unsigned *last, unsigned offset)
 {
 	if (*last >= offset)
diff --git a/arch/x86/kernel/process.c b/arch/x86/kernel/process.c
index b217a26864e2..3cbb0309e48a 100644
--- a/arch/x86/kernel/process.c
+++ b/arch/x86/kernel/process.c
@@ -1020,6 +1020,8 @@ long do_arch_prctl_common(struct task_struct *task, int option,
 		return get_cpuid_mode();
 	case ARCH_SET_CPUID:
 		return set_cpuid_mode(task, arg2);
+	case ARCH_DYNAMIC_XSTATE:
+		return set_process_dynamicstate_perm(task);
 	}
 
 	return prctl_cet(option, arg2);
diff --git a/arch/x86/kernel/process_64.c b/arch/x86/kernel/process_64.c
index bb45afad088a..fc9f4b94d356 100644
--- a/arch/x86/kernel/process_64.c
+++ b/arch/x86/kernel/process_64.c
@@ -656,6 +656,9 @@ void set_personality_64bit(void)
 	   so it's not too bad. The main problem is just that
 	   32bit children are affected again. */
 	current->personality &= ~READ_IMPLIES_EXEC;
+
+	/* Make sure to reset the dynamic state permission. */
+	reset_task_dynamicstate_perm(current);
 }
 
 static void __set_personality_x32(void)
@@ -701,6 +704,9 @@ void set_personality_ia32(bool x32)
 	/* Make sure to be in 32bit mode */
 	set_thread_flag(TIF_ADDR32);
 
+	/* Make sure to reset the dynamic state permission. */
+	reset_task_dynamicstate_perm(current);
+
 	if (x32)
 		__set_personality_x32();
 	else
diff --git a/arch/x86/kernel/traps.c b/arch/x86/kernel/traps.c
index a24c8e07f225..b7d686ca94e5 100644
--- a/arch/x86/kernel/traps.c
+++ b/arch/x86/kernel/traps.c
@@ -1190,7 +1190,8 @@ DEFINE_IDTENTRY(exc_device_not_available)
 			 * Make sure the feature bit, the dynamic expansion is permitted and
 			 * finally not in interrupt context as handling a trap from userspace.
 			 */
-			if (!WARN_ON(!xfd_event) && !WARN_ON(in_interrupt())) {
+			if (!WARN_ON(!xfd_event) && test_thread_flag(TIF_DYNAMIC_XSTATE) &&
+			    !WARN_ON(in_interrupt())) {
 				struct fpu *fpu = &current->thread.fpu;
 				int err;
 
-- 
2.27.0

