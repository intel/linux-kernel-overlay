From a9b409d764035d5457d89ed442f3b00558261bcc Mon Sep 17 00:00:00 2001
From: Ravikumar PM <ravikumar.pm@intel.com>
Date: Thu, 4 Feb 2021 16:01:26 +0530
Subject: [PATCH 148/170] xlink-core: Xlink adaptaions for the Simics.

---
 drivers/misc/xlink-core/xlink-dispatcher.c  | 13 +++++++++++++
 drivers/misc/xlink-core/xlink-multiplexer.c | 17 ++++++++++-------
 2 files changed, 23 insertions(+), 7 deletions(-)

diff --git a/drivers/misc/xlink-core/xlink-dispatcher.c b/drivers/misc/xlink-core/xlink-dispatcher.c
index bc2f184488ac..f9b3a10e848e 100644
--- a/drivers/misc/xlink-core/xlink-dispatcher.c
+++ b/drivers/misc/xlink-core/xlink-dispatcher.c
@@ -69,6 +69,18 @@ static struct xlink_dispatcher *xlinkd;
  *
  */
 
+static int wait_tx_queue_empty(struct dispatcher* disp)
+{
+	do{
+		mutex_lock(&disp->queue.lock);
+		if(disp->queue.count == 0)
+			break;
+		mutex_unlock(&disp->queue.lock);
+	}while(1);
+	mutex_unlock(&disp->queue.lock);
+	return 0;
+}
+
 static struct dispatcher *get_dispatcher_by_id(u32 id)
 {
 	if (!xlinkd)
@@ -363,6 +375,7 @@ enum xlink_error xlink_dispatcher_stop(int id)
 		goto r_error;
 
 	if (disp->rxthread) {
+		wait_tx_queue_empty(disp);
 		// stop dispatcher rx thread
 		send_sig(SIGTERM, disp->rxthread, 0);
 		rc = kthread_stop(disp->rxthread);
diff --git a/drivers/misc/xlink-core/xlink-multiplexer.c b/drivers/misc/xlink-core/xlink-multiplexer.c
index e09458b62c45..62e30c9f1081 100644
--- a/drivers/misc/xlink-core/xlink-multiplexer.c
+++ b/drivers/misc/xlink-core/xlink-multiplexer.c
@@ -35,7 +35,7 @@
 #define THR_LWR 80
 
 // timeout used for open channel
-#define OPEN_CHANNEL_TIMEOUT_MSEC 5000
+#define OPEN_CHANNEL_TIMEOUT_MSEC 50000
 
 /* Channel mapping table. */
 struct xlink_channel_type {
@@ -431,13 +431,20 @@ enum xlink_error xlink_multiplexer_connect(u32 link_id)
 enum xlink_error xlink_multiplexer_disconnect(u32 link_id)
 {
 	int i;
+	struct open_channel *opchan;
 
 	if (!xmux)
 		return X_LINK_ERROR;
 
 	for (i = 0; i < NMB_CHANNELS; i++) {
-		if (xmux->channels[link_id][i].opchan)
-			multiplexer_close_channel(xmux->channels[link_id][i].opchan);
+		if (xmux->channels[link_id][i].opchan) {
+			opchan = get_channel(link_id, i);
+			if (opchan->chan->status == CHAN_OPEN_PEER) {
+				release_channel(opchan);
+				continue;
+			}
+		multiplexer_close_channel(xmux->channels[link_id][i].opchan);
+		}
 	}
 	return X_LINK_SUCCESS;
 }
@@ -465,15 +472,11 @@ static int compl_wait(struct completion *compl, struct open_channel *opchan)
 	unsigned long tout = msecs_to_jiffies(opchan->chan->timeout);
 
 	if (opchan->chan->timeout == 0) {
-		mutex_unlock(&opchan->lock);
 		rc = wait_for_completion_interruptible(compl);
-		mutex_lock(&opchan->lock);
 		if (rc < 0)	// wait interrupted
 			rc = X_LINK_ERROR;
 	} else {
-		mutex_unlock(&opchan->lock);
 		rc = wait_for_completion_interruptible_timeout(compl, tout);
-		mutex_lock(&opchan->lock);
 		if (rc == 0)
 			rc = X_LINK_TIMEOUT;
 		else if (rc < 0)	// wait interrupted
-- 
2.27.0

