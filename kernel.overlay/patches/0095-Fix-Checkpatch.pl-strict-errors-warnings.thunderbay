From 43bfe56c0eaa8d1a3aec97dc8e35d9a3f0dd2455 Mon Sep 17 00:00:00 2001
From: Srikanth Thokala <srikanth.thokala@intel.com>
Date: Mon, 7 Sep 2020 19:59:38 +0530
Subject: [PATCH 095/170] Fix Checkpatch.pl strict errors/warnings

Signed-off-by: Srikanth Thokala <srikanth.thokala@intel.com>
---
 drivers/misc/xlink-pcie/common/boot.h         |   2 +-
 drivers/misc/xlink-pcie/common/capabilities.h |  16 +--
 drivers/misc/xlink-pcie/common/common.h       |  84 ++++++-------
 drivers/misc/xlink-pcie/common/core.h         |   8 +-
 drivers/misc/xlink-pcie/common/util.c         |  27 +++--
 drivers/misc/xlink-pcie/common/util.h         |   4 +-
 drivers/misc/xlink-pcie/common/xpcie.h        |  12 +-
 drivers/misc/xlink-pcie/local_host/core.c     | 113 +++++++++++-------
 drivers/misc/xlink-pcie/local_host/dma.c      |  24 ++--
 drivers/misc/xlink-pcie/local_host/dma.h      |   2 +-
 drivers/misc/xlink-pcie/local_host/epf.c      |  20 ++--
 drivers/misc/xlink-pcie/local_host/epf.h      |  18 +--
 drivers/misc/xlink-pcie/local_host/if.c       |  22 ++--
 drivers/misc/xlink-pcie/local_host/struct.h   |   2 +-
 drivers/misc/xlink-pcie/remote_host/core.c    |  68 ++++++-----
 drivers/misc/xlink-pcie/remote_host/if.c      |  22 ++--
 drivers/misc/xlink-pcie/remote_host/pci.c     |  92 ++++----------
 drivers/misc/xlink-pcie/remote_host/pci.h     |   4 +-
 include/linux/xlink_drv_inf.h                 |  24 ++--
 19 files changed, 272 insertions(+), 292 deletions(-)

diff --git a/drivers/misc/xlink-pcie/common/boot.h b/drivers/misc/xlink-pcie/common/boot.h
index 6d81ec484fe9..0cfb4373c47a 100644
--- a/drivers/misc/xlink-pcie/common/boot.h
+++ b/drivers/misc/xlink-pcie/common/boot.h
@@ -62,4 +62,4 @@ struct xpcie_bootio {
 	u64 dev_id;
 } __packed;
 
-#endif // XPCIE_BOOT_HEADER_
+#endif /* XPCIE_BOOT_HEADER_ */
diff --git a/drivers/misc/xlink-pcie/common/capabilities.h b/drivers/misc/xlink-pcie/common/capabilities.h
index 81e25bbc4f43..e49c247a2de0 100644
--- a/drivers/misc/xlink-pcie/common/capabilities.h
+++ b/drivers/misc/xlink-pcie/common/capabilities.h
@@ -22,30 +22,30 @@ void *intel_xpcie_cap_find(struct xpcie *xpcie, u32 start, u16 id)
 	struct xpcie_cap_hdr *hdr;
 	struct xpcie_cap_hdr cur_hdr;
 
-	// If user didn't specify start, assume start of mmio
+	/* If user didn't specify start, assume start of mmio */
 	if (!start)
 		start = intel_xpcie_ioread32(&xpcie->mmio->cap_offset);
 
-	// Read header info
+	/* Read header info */
 #ifdef XLINK_PCIE_REMOTE
 	hdr = (struct xpcie_cap_hdr *)((void __iomem *)xpcie->mmio + start);
 #else
 	hdr = (struct xpcie_cap_hdr *)((void *)xpcie->mmio + start);
 #endif
-	// Check if we still have time to live
+	/* Check if we still have time to live */
 	while (ttl--) {
 #ifdef XLINK_PCIE_REMOTE
 		memcpy_fromio(&cur_hdr, hdr, sizeof(struct xpcie_cap_hdr));
 #else
 		cur_hdr = *hdr;
 #endif
-		// If cap matches, return header
+		/* If cap matches, return header */
 		if (cur_hdr.id == id)
 			return hdr;
-		// If cap is NULL, we are at the end of the list
+		/* If cap is NULL, we are at the end of the list */
 		else if (cur_hdr.id == XPCIE_CAP_NULL)
 			return NULL;
-		// If no match and no end of list, traverse the linked list
+		/* If no match and no end of list, traverse the linked list */
 		else
 #ifdef XLINK_PCIE_REMOTE
 			hdr = (struct xpcie_cap_hdr *)
@@ -56,7 +56,7 @@ void *intel_xpcie_cap_find(struct xpcie *xpcie, u32 start, u16 id)
 #endif
 	}
 
-	// If we reached here, the capability list is corrupted
+	/* If we reached here, the capability list is corrupted */
 	return NULL;
 }
 
@@ -131,4 +131,4 @@ u32 intel_xpcie_get_tdr_tail(struct xpcie_pipe *p)
 {
 	return intel_xpcie_ioread32(p->tail);
 }
-#endif // XPCIE_CAPABILITIES_HEADER_
+#endif /* XPCIE_CAPABILITIES_HEADER_ */
diff --git a/drivers/misc/xlink-pcie/common/common.h b/drivers/misc/xlink-pcie/common/common.h
index 774f4d391414..c224f4ac1426 100644
--- a/drivers/misc/xlink-pcie/common/common.h
+++ b/drivers/misc/xlink-pcie/common/common.h
@@ -19,29 +19,23 @@
 #define PCI_DEVICE_ID_INTEL_KEEMBAY 0x6240
 #endif
 
-/*
- * Number of interfaces to statically allocate resources for
- */
+/* Number of interfaces to statically allocate resources for */
 #define XPCIE_NUM_INTERFACES (1)
 
 #define XPCIE_FRAGMENT_SIZE SZ_128K
 #define XPCIE_NUM_TX_DESCS (64)
 #define XPCIE_NUM_RX_DESCS (64)
 
-/*
- * Status encoding of the transfer descriptors
- */
+/* Status encoding of the transfer descriptors */
 #define XPCIE_DESC_STATUS_SUCCESS (0)
 #define XPCIE_DESC_STATUS_ERROR (0xFFFF)
 
-/*
- * Layout transfer descriptors used by device and host
- */
+/* Layout transfer descriptors used by device and host */
 struct xpcie_transfer_desc {
-	uint64_t address;
-	uint32_t length;
-	uint16_t status;
-	uint16_t interface;
+	u64 address;
+	u32 length;
+	u16 status;
+	u16 interface;
 } __packed;
 
 #define XPCIE_IO_COMM_SIZE SZ_16K
@@ -56,14 +50,12 @@ struct xpcie_transfer_desc {
 	_VERSION(XPCIE_VERSION_MAJOR, XPCIE_VERSION_MINOR, XPCIE_VERSION_BUILD)
 
 struct xpcie_version {
-	uint8_t major;
-	uint8_t minor;
-	uint16_t build;
+	u8 major;
+	u8 minor;
+	u16 build;
 } __packed;
 
-/*
- * Status encoding of both device and host
- */
+/* Status encoding of both device and host */
 #define XPCIE_STATUS_ERROR (0xFFFFFFFF)
 #define XPCIE_STATUS_UNINIT (0)
 #define XPCIE_STATUS_BOOT_FW (1)
@@ -74,51 +66,43 @@ struct xpcie_version {
 #define XPCIE_STATUS_OFF (6)
 #define XPCIE_STATUS_BOOT_PRE_OS (7)
 
-/*
- * MMIO layout and offsets shared between device and host
- */
+/* MMIO layout and offsets shared between device and host */
 struct xpcie_mmio {
 	struct xpcie_version version;
-	uint32_t device_status;
-	uint32_t host_status;
-	uint8_t legacy_a0;
-	uint8_t htod_tx_doorbell;
-	uint8_t htod_rx_doorbell;
-	uint8_t htod_event_doorbell;
-	uint8_t dtoh_tx_doorbell;
-	uint8_t dtoh_rx_doorbell;
-	uint8_t dtoh_event_doorbell;
-	uint8_t reserved;
-	uint32_t cap_offset;
+	u32 device_status;
+	u32 host_status;
+	u8 legacy_a0;
+	u8 htod_tx_doorbell;
+	u8 htod_rx_doorbell;
+	u8 htod_event_doorbell;
+	u8 dtoh_tx_doorbell;
+	u8 dtoh_rx_doorbell;
+	u8 dtoh_event_doorbell;
+	u8 reserved;
+	u32 cap_offset;
 } __packed;
 
-/*
- * Defined capabilities located in mmio space
- */
+/* Defined capabilities located in mmio space */
 #define XPCIE_CAP_NULL (0)
 #define XPCIE_CAP_TXRX (1)
 
-/*
- * Header at the beginning of each capability to define and link to next
- */
+/* Header at the beginning of each capability to define and link to next */
 struct xpcie_cap_hdr {
-	uint16_t id;
-	uint16_t next;
+	u16 id;
+	u16 next;
 } __packed;
 
 #define XPCIE_CAP_HDR_ID (offsetof(struct xpcie_cap_hdr, id))
 #define XPCIE_CAP_HDR_NEXT (offsetof(struct xpcie_cap_hdr, next))
 
 struct xpcie_cap_pipe {
-	uint32_t ring;
-	uint32_t ndesc;
-	uint32_t head;
-	uint32_t tail;
+	u32 ring;
+	u32 ndesc;
+	u32 head;
+	u32 tail;
 } __packed;
 
-/*
- * Transmit and Receive capability
- */
+/* Transmit and Receive capability */
 struct xpcie_cap_txrx {
 	struct xpcie_cap_hdr hdr;
 	u32 fragment_size;
@@ -164,6 +148,6 @@ static inline void _iowrite64(u64 value, void __iomem *addr)
 #define intel_xpcie_ioread16(addr) (*(addr))
 #define intel_xpcie_ioread8(addr)  (*(addr))
 
-#endif // XLINK_PCIE_REMOTE
+#endif /* XLINK_PCIE_REMOTE */
 
-#endif
+#endif /* XPCIE_COMMON_HEADER_ */
diff --git a/drivers/misc/xlink-pcie/common/core.h b/drivers/misc/xlink-pcie/common/core.h
index 2f375edde465..4a6fdce14d86 100644
--- a/drivers/misc/xlink-pcie/common/core.h
+++ b/drivers/misc/xlink-pcie/common/core.h
@@ -30,7 +30,7 @@ void intel_xpcie_core_cleanup(struct xpcie *xpcie);
  *              -EINTR - interrupted
  */
 int intel_xpcie_core_read(struct xpcie *xpcie, void *buffer, size_t *length,
-		   uint32_t timeout_ms);
+			  u32 timeout_ms);
 
 /*
  * @brief Writes buffer to xpcie. Function will block when no buffer.
@@ -47,10 +47,10 @@ int intel_xpcie_core_read(struct xpcie *xpcie, void *buffer, size_t *length,
  *              -EINTR - interrupted
  */
 int intel_xpcie_core_write(struct xpcie *xpcie, void *buffer, size_t *length,
-		    uint32_t timeout_ms);
+			   u32 timeout_ms);
 
 #ifdef XLINK_PCIE_LOCAL
-struct xpcie *intel_xpcie_core_get_by_id(uint32_t sw_device_id);
+struct xpcie *intel_xpcie_core_get_by_id(u32 sw_device_id);
 #endif
 
-#endif
+#endif /* XPCIE_CORE_HEADER_ */
diff --git a/drivers/misc/xlink-pcie/common/util.c b/drivers/misc/xlink-pcie/common/util.c
index a638c08cf94e..87ea700c82a6 100644
--- a/drivers/misc/xlink-pcie/common/util.c
+++ b/drivers/misc/xlink-pcie/common/util.c
@@ -21,8 +21,8 @@ u32 intel_xpcie_get_device_status(struct xpcie *xpcie)
 }
 
 static u8 *intel_xpcie_doorbell_offset(struct xpcie *xpcie,
-				enum xpcie_doorbell_direction dirt,
-				enum xpcie_doorbell_type type)
+				       enum xpcie_doorbell_direction dirt,
+				       enum xpcie_doorbell_type type)
 {
 	if (dirt == TO_DEVICE && type == DATA_SENT)
 		return &xpcie->mmio->htod_tx_doorbell;
@@ -82,7 +82,8 @@ struct xpcie_buf_desc *intel_xpcie_alloc_bd(size_t length)
 	}
 
 	bd->data = bd->head;
-	bd->length = bd->true_len = length;
+	bd->length = length;
+	bd->true_len = length;
 	bd->next = NULL;
 	bd->own_mem = true;
 
@@ -90,7 +91,7 @@ struct xpcie_buf_desc *intel_xpcie_alloc_bd(size_t length)
 }
 
 struct xpcie_buf_desc *intel_xpcie_alloc_bd_reuse(size_t length, void *virt,
-					  dma_addr_t phys)
+						  dma_addr_t phys)
 {
 	struct xpcie_buf_desc *bd;
 
@@ -101,7 +102,8 @@ struct xpcie_buf_desc *intel_xpcie_alloc_bd_reuse(size_t length, void *virt,
 	bd->head = virt;
 	bd->phys = phys;
 	bd->data = bd->head;
-	bd->length = bd->true_len = length;
+	bd->length = length;
+	bd->true_len = length;
 	bd->next = NULL;
 	bd->own_mem = false;
 
@@ -139,7 +141,8 @@ void intel_xpcie_list_cleanup(struct xpcie_list *list)
 		intel_xpcie_free_bd(bd);
 	}
 
-	list->head = list->tail = NULL;
+	list->head = NULL;
+	list->tail = NULL;
 	spin_unlock(&list->lock);
 }
 
@@ -264,7 +267,7 @@ void intel_xpcie_free_tx_bd(struct xpcie *xpcie, struct xpcie_buf_desc *bd)
 	intel_xpcie_list_put(&xpcie->tx_pool, bd);
 
 	xpcie->no_tx_buffer = false;
-	wake_up_interruptible(&xpcie->tx_waitqueue);
+	wake_up_interruptible(&xpcie->tx_waitq);
 }
 
 int intel_xpcie_interface_init(struct xpcie *xpcie, int id)
@@ -277,8 +280,8 @@ int intel_xpcie_interface_init(struct xpcie *xpcie, int id)
 	inf->partial_read = NULL;
 	intel_xpcie_list_init(&inf->read);
 	mutex_init(&inf->rlock);
-	inf->data_available = false;
-	init_waitqueue_head(&inf->rx_waitqueue);
+	inf->data_avail = false;
+	init_waitqueue_head(&inf->rx_waitq);
 
 	return 0;
 }
@@ -311,7 +314,7 @@ int intel_xpcie_interfaces_init(struct xpcie *xpcie)
 
 	mutex_init(&xpcie->wlock);
 	intel_xpcie_list_init(&xpcie->write);
-	init_waitqueue_head(&xpcie->tx_waitqueue);
+	init_waitqueue_head(&xpcie->tx_waitq);
 	xpcie->no_tx_buffer = false;
 
 	for (index = 0; index < XPCIE_NUM_INTERFACES; index++)
@@ -330,9 +333,9 @@ void intel_xpcie_add_bd_to_interface(struct xpcie *xpcie,
 	intel_xpcie_list_put(&inf->read, bd);
 
 	mutex_lock(&inf->rlock);
-	inf->data_available = true;
+	inf->data_avail = true;
 	mutex_unlock(&inf->rlock);
-	wake_up_interruptible(&inf->rx_waitqueue);
+	wake_up_interruptible(&inf->rx_waitq);
 }
 
 #ifdef XLINK_PCIE_REMOTE
diff --git a/drivers/misc/xlink-pcie/common/util.h b/drivers/misc/xlink-pcie/common/util.h
index 4b766fe284d4..663ca0ec4b91 100644
--- a/drivers/misc/xlink-pcie/common/util.h
+++ b/drivers/misc/xlink-pcie/common/util.h
@@ -43,7 +43,7 @@ void intel_xpcie_set_host_status(struct xpcie *xpcie, u32 status);
 
 struct xpcie_buf_desc *intel_xpcie_alloc_bd(size_t length);
 struct xpcie_buf_desc *intel_xpcie_alloc_bd_reuse(size_t length, void *virt,
-					  dma_addr_t phys);
+						  dma_addr_t phys);
 void intel_xpcie_free_bd(struct xpcie_buf_desc *bd);
 
 int intel_xpcie_list_init(struct xpcie_list *list);
@@ -71,4 +71,4 @@ void intel_xpcie_init_debug(struct xpcie *xpcie, struct device *dev);
 void intel_xpcie_uninit_debug(struct xpcie *xpcie, struct device *dev);
 void intel_xpcie_debug_incr(struct xpcie *xpcie, size_t *attr, size_t v);
 
-#endif // XPCIE_UTIL_HEADER_
+#endif /* XPCIE_UTIL_HEADER_ */
diff --git a/drivers/misc/xlink-pcie/common/xpcie.h b/drivers/misc/xlink-pcie/common/xpcie.h
index 45a62fa69231..d2764d80d532 100644
--- a/drivers/misc/xlink-pcie/common/xpcie.h
+++ b/drivers/misc/xlink-pcie/common/xpcie.h
@@ -63,6 +63,7 @@ struct xpcie_stream {
 };
 
 struct xpcie_list {
+	/* list lock */
 	spinlock_t lock;
 	size_t bytes;
 	size_t buffers;
@@ -73,11 +74,11 @@ struct xpcie_list {
 struct xpcie_interface {
 	int id;
 	struct xpcie *xpcie;
-	struct mutex rlock;
+	struct mutex rlock; /* Read lock */
 	struct xpcie_list read;
 	struct xpcie_buf_desc *partial_read;
-	bool data_available;
-	wait_queue_head_t rx_waitqueue;
+	bool data_avail;
+	wait_queue_head_t rx_waitq;
 };
 
 struct xpcie_debug_stats {
@@ -116,10 +117,11 @@ struct xpcie {
 	struct xpcie_stream tx;
 	struct xpcie_stream rx;
 
+	/* Write Lock */
 	struct mutex wlock;
 	struct xpcie_list write;
 	bool no_tx_buffer;
-	wait_queue_head_t tx_waitqueue;
+	wait_queue_head_t tx_waitq;
 	bool tx_pending;
 	bool stop_flag;
 
@@ -134,4 +136,4 @@ struct xpcie {
 	struct xpcie_debug_stats stats;
 };
 
-#endif
+#endif /* XPCIE_HEADER_ */
diff --git a/drivers/misc/xlink-pcie/local_host/core.c b/drivers/misc/xlink-pcie/local_host/core.c
index 85b127bc396c..dd6b79e770b5 100644
--- a/drivers/misc/xlink-pcie/local_host/core.c
+++ b/drivers/misc/xlink-pcie/local_host/core.c
@@ -19,7 +19,7 @@
 
 static struct xpcie *global_xpcie;
 
-#define XPCIE_CIRCULAR_INC(val, max) (((val) + 1) & (max - 1))
+#define XPCIE_CIRCULAR_INC(val, max) (((val) + 1) & ((max) - 1))
 
 static int rx_pool_size = SZ_32M;
 module_param(rx_pool_size, int, 0664);
@@ -44,7 +44,7 @@ MODULE_PARM_DESC(rx_pool_coherent,
 		 "receiving pool using coherent memory (default false)");
 
 static int intel_xpcie_map_dma(struct xpcie *xpcie, struct xpcie_buf_desc *bd,
-			int direction)
+			       int direction)
 {
 	struct xpcie_epf *xpcie_epf = container_of(xpcie,
 						   struct xpcie_epf, xpcie);
@@ -71,13 +71,13 @@ static void intel_xpcie_set_cap_txrx(struct xpcie *xpcie)
 {
 	struct xpcie_cap_txrx *cap;
 	struct xpcie_cap_hdr *hdr;
-	uint32_t start = sizeof(struct xpcie_mmio);
+	u32 start = sizeof(struct xpcie_mmio);
 	size_t hdr_len = sizeof(struct xpcie_cap_txrx);
 	size_t tx_len = sizeof(struct xpcie_transfer_desc) *
 				XPCIE_NUM_TX_DESCS;
 	size_t rx_len = sizeof(struct xpcie_transfer_desc) *
 				XPCIE_NUM_RX_DESCS;
-	uint16_t next = (uint16_t)(start + hdr_len + tx_len + rx_len);
+	u16 next = (u16)(start + hdr_len + tx_len + rx_len);
 
 	xpcie->mmio->cap_offset = start;
 	cap = (void *)xpcie->mmio + start;
@@ -123,9 +123,9 @@ static void intel_xpcie_txrx_cleanup(struct xpcie *xpcie)
 
 	xpcie->stop_flag = true;
 	xpcie->no_tx_buffer = false;
-	inf->data_available = true;
-	wake_up_interruptible(&xpcie->tx_waitqueue);
-	wake_up_interruptible(&inf->rx_waitqueue);
+	inf->data_avail = true;
+	wake_up_interruptible(&xpcie->tx_waitq);
+	wake_up_interruptible(&inf->rx_waitq);
 	mutex_lock(&xpcie->wlock);
 	mutex_lock(&inf->rlock);
 
@@ -158,7 +158,8 @@ static void intel_xpcie_txrx_cleanup(struct xpcie *xpcie)
 }
 
 /*
- * The RX/TX are named for Remote Host, in Local Host RX/TX is reversed.
+ * The RX/TX are named for Remote Host, in Local Host
+ * RX/TX is reversed.
  */
 static int intel_xpcie_txrx_init(struct xpcie *xpcie,
 				 struct xpcie_cap_txrx *cap)
@@ -193,16 +194,23 @@ static int intel_xpcie_txrx_init(struct xpcie *xpcie,
 	if (rx_pool_coherent) {
 		xpcie_epf->rx_size = rx_pool_size;
 		xpcie_epf->rx_virt = dma_alloc_coherent(dma_dev,
-			xpcie_epf->rx_size, &xpcie_epf->rx_phys, GFP_KERNEL);
+							xpcie_epf->rx_size,
+							&xpcie_epf->rx_phys,
+							GFP_KERNEL);
 		if (!xpcie_epf->rx_virt)
 			goto error;
 	}
 
 	for (index = 0; index < ndesc; index++) {
 		if (rx_pool_coherent) {
-			bd = intel_xpcie_alloc_bd_reuse(xpcie->fragment_size,
-			xpcie_epf->rx_virt + index * xpcie->fragment_size,
-			xpcie_epf->rx_phys + index * xpcie->fragment_size);
+			bd =
+			intel_xpcie_alloc_bd_reuse(xpcie->fragment_size,
+						   xpcie_epf->rx_virt +
+						   (index *
+							xpcie->fragment_size),
+						   xpcie_epf->rx_phys +
+						   (index *
+							xpcie->fragment_size));
 		} else {
 			bd = intel_xpcie_alloc_bd(xpcie->fragment_size);
 		}
@@ -222,16 +230,23 @@ static int intel_xpcie_txrx_init(struct xpcie *xpcie,
 	if (tx_pool_coherent) {
 		xpcie_epf->tx_size = tx_pool_size;
 		xpcie_epf->tx_virt = dma_alloc_coherent(dma_dev,
-			xpcie_epf->tx_size, &xpcie_epf->tx_phys, GFP_KERNEL);
+							xpcie_epf->tx_size,
+							&xpcie_epf->tx_phys,
+							GFP_KERNEL);
 		if (!xpcie_epf->tx_virt)
 			goto error;
 	}
 
 	for (index = 0; index < ndesc; index++) {
 		if (tx_pool_coherent) {
-			bd = intel_xpcie_alloc_bd_reuse(xpcie->fragment_size,
-			xpcie_epf->tx_virt + index * xpcie->fragment_size,
-			xpcie_epf->tx_phys + index * xpcie->fragment_size);
+			bd =
+			intel_xpcie_alloc_bd_reuse(xpcie->fragment_size,
+						   xpcie_epf->tx_virt +
+						   (index *
+							xpcie->fragment_size),
+						   xpcie_epf->tx_phys +
+						   (index *
+							xpcie->fragment_size));
 		} else {
 			bd = intel_xpcie_alloc_bd(xpcie->fragment_size);
 		}
@@ -306,10 +321,12 @@ static void intel_xpcie_rx_event_handler(struct work_struct *work)
 	if (intel_xpcie_get_host_status(xpcie) != XPCIE_STATUS_RUN)
 		return;
 
-	bd_head = bd_tail = NULL;
+	bd_head = NULL;
+	bd_tail = NULL;
 	ndesc = rx->pipe.ndesc;
 	tail = intel_xpcie_get_tdr_tail(&rx->pipe);
-	initial_head = head = intel_xpcie_get_tdr_head(&rx->pipe);
+	initial_head = intel_xpcie_get_tdr_head(&rx->pipe);
+	head = initial_head;
 
 	while (head != tail) {
 		td = rx->pipe.tdr + head;
@@ -436,12 +453,14 @@ static void intel_xpcie_tx_event_handler(struct work_struct *work)
 	if (intel_xpcie_get_host_status(xpcie) != XPCIE_STATUS_RUN)
 		return;
 
-	bd_head = bd_tail = NULL;
+	bd_head = NULL;
+	bd_tail = NULL;
 	ndesc = tx->pipe.ndesc;
-	initial_tail = tail = intel_xpcie_get_tdr_tail(&tx->pipe);
+	initial_tail = intel_xpcie_get_tdr_tail(&tx->pipe);
+	tail = initial_tail;
 	head = intel_xpcie_get_tdr_head(&tx->pipe);
 
-	// add new entries
+	/* add new entries */
 	while (XPCIE_CIRCULAR_INC(tail, ndesc) != head) {
 		bd = intel_xpcie_list_get(&xpcie->write);
 		if (!bd)
@@ -450,7 +469,7 @@ static void intel_xpcie_tx_event_handler(struct work_struct *work)
 		if (!tx_pool_coherent) {
 			if (intel_xpcie_map_dma(xpcie, bd, DMA_TO_DEVICE)) {
 				dev_err(xpcie_to_dev(xpcie),
-				"dma mapping error bd addr %p, size %zu\n",
+					"dma map error bd addr %p, size %zu\n",
 				bd->data, bd->length);
 				intel_xpcie_list_put_head(&xpcie->write, bd);
 				break;
@@ -551,7 +570,7 @@ static irqreturn_t intel_xpcie_core_irq_cb(int irq, void *args)
 static int intel_xpcie_events_init(struct xpcie *xpcie)
 {
 	xpcie->rx_wq = alloc_ordered_workqueue(XPCIE_DRIVER_NAME,
-					      WQ_MEM_RECLAIM | WQ_HIGHPRI);
+					       WQ_MEM_RECLAIM | WQ_HIGHPRI);
 	if (!xpcie->rx_wq) {
 		dev_err(xpcie_to_dev(xpcie), "failed to allocate workqueue\n");
 		return -ENOMEM;
@@ -559,7 +578,8 @@ static int intel_xpcie_events_init(struct xpcie *xpcie)
 
 	if (!xpcie->legacy_a0) {
 		xpcie->tx_wq = alloc_ordered_workqueue(XPCIE_DRIVER_NAME,
-					      WQ_MEM_RECLAIM | WQ_HIGHPRI);
+						       WQ_MEM_RECLAIM |
+						       WQ_HIGHPRI);
 		if (!xpcie->tx_wq) {
 			dev_err(xpcie_to_dev(xpcie),
 				"failed to allocate workqueue\n");
@@ -639,7 +659,7 @@ void intel_xpcie_core_cleanup(struct xpcie *xpcie)
 }
 
 int intel_xpcie_core_read(struct xpcie *xpcie, void *buffer, size_t *length,
-		   unsigned int timeout_ms)
+			  u32 timeout_ms)
 {
 	int ret = 0;
 	struct xpcie_interface *inf = &xpcie->interfaces[0];
@@ -664,16 +684,18 @@ int intel_xpcie_core_read(struct xpcie *xpcie, void *buffer, size_t *length,
 		return -EINTR;
 
 	do {
-		while (!inf->data_available) {
+		while (!inf->data_avail) {
 			mutex_unlock(&inf->rlock);
 			if (timeout_ms == 0) {
-				ret = wait_event_interruptible(
-					inf->rx_waitqueue,
-					inf->data_available);
+				ret =
+				wait_event_interruptible(inf->rx_waitq,
+							 inf->data_avail);
 			} else {
-				ret = wait_event_interruptible_timeout(
-					inf->rx_waitqueue, inf->data_available,
-					jiffies_timeout - jiffies_passed);
+				ret =
+			wait_event_interruptible_timeout(inf->rx_waitq,
+							 inf->data_avail,
+							 jiffies_timeout -
+							  jiffies_passed);
 				if (ret == 0)
 					return -ETIME;
 			}
@@ -713,7 +735,7 @@ int intel_xpcie_core_read(struct xpcie *xpcie, void *buffer, size_t *length,
 		inf->partial_read = bd;
 
 		if (!bd)
-			inf->data_available = false;
+			inf->data_avail = false;
 
 		*length = len - remaining;
 
@@ -727,7 +749,7 @@ int intel_xpcie_core_read(struct xpcie *xpcie, void *buffer, size_t *length,
 }
 
 int intel_xpcie_core_write(struct xpcie *xpcie, void *buffer, size_t *length,
-		    unsigned int timeout_ms)
+			   u32 timeout_ms)
 {
 	int ret;
 	size_t len = *length;
@@ -755,18 +777,20 @@ int intel_xpcie_core_write(struct xpcie *xpcie, void *buffer, size_t *length,
 		return -EINTR;
 
 	do {
-		bd = head = intel_xpcie_alloc_tx_bd(xpcie);
+		bd = intel_xpcie_alloc_tx_bd(xpcie);
+		head = bd;
 		while (!head) {
 			mutex_unlock(&xpcie->wlock);
 			if (timeout_ms == 0) {
-				ret = wait_event_interruptible(
-						xpcie->tx_waitqueue,
-						!xpcie->no_tx_buffer);
+				ret =
+				wait_event_interruptible(xpcie->tx_waitq,
+							 !xpcie->no_tx_buffer);
 			} else {
-				ret = wait_event_interruptible_timeout(
-					xpcie->tx_waitqueue,
-					!xpcie->no_tx_buffer,
-					jiffies_timeout - jiffies_passed);
+				ret =
+			wait_event_interruptible_timeout(xpcie->tx_waitq,
+							 !xpcie->no_tx_buffer,
+							 jiffies_timeout -
+							 jiffies_passed);
 				if (ret == 0)
 					return -ETIME;
 			}
@@ -777,7 +801,8 @@ int intel_xpcie_core_write(struct xpcie *xpcie, void *buffer, size_t *length,
 			if (ret < 0)
 				return -EINTR;
 
-			bd = head = intel_xpcie_alloc_tx_bd(xpcie);
+			bd = intel_xpcie_alloc_tx_bd(xpcie);
+			head = bd;
 		}
 
 		while (remaining && bd) {
@@ -815,7 +840,7 @@ int intel_xpcie_core_write(struct xpcie *xpcie, void *buffer, size_t *length,
 	return 0;
 }
 
-struct xpcie *intel_xpcie_core_get_by_id(uint32_t sw_device_id)
+struct xpcie *intel_xpcie_core_get_by_id(u32 sw_device_id)
 {
 	return (sw_device_id == xlink_sw_id) ? global_xpcie : NULL;
 }
diff --git a/drivers/misc/xlink-pcie/local_host/dma.c b/drivers/misc/xlink-pcie/local_host/dma.c
index 86da4c5deb51..424a62a21770 100644
--- a/drivers/misc/xlink-pcie/local_host/dma.c
+++ b/drivers/misc/xlink-pcie/local_host/dma.c
@@ -123,7 +123,7 @@ struct __packed pcie_dma_reg {
 	u32 dma_read_int_clear;
 	u32 reserved10;
 	u32 dma_read_err_status_low;
-	u32 dma_read_err_status_high;
+	u32 dma_rd_err_sts_h;
 	u32 reserved11[2];
 	u32 dma_read_linked_list_err_en;
 	u32 reserved12;
@@ -168,7 +168,7 @@ static void __iomem *intel_xpcie_ep_get_dma_base(struct pci_epf *epf)
 }
 
 static int intel_xpcie_ep_dma_disable(void __iomem *dma_base,
-			       enum xpcie_ep_engine_type rw)
+				      enum xpcie_ep_engine_type rw)
 {
 	int i;
 	struct pcie_dma_reg *dma_reg = (struct pcie_dma_reg *)(dma_base);
@@ -207,7 +207,7 @@ static int intel_xpcie_ep_dma_disable(void __iomem *dma_base,
 }
 
 static void intel_xpcie_ep_dma_enable(void __iomem *dma_base,
-			       enum xpcie_ep_engine_type rw)
+				      enum xpcie_ep_engine_type rw)
 {
 	int i;
 	u32 offset;
@@ -231,7 +231,6 @@ static void intel_xpcie_ep_dma_enable(void __iomem *dma_base,
 	u32 weight = (rw == WRITE_ENGINE) ? DMA_CHAN_WRITE_ALL_MAX_WEIGHT :
 					    DMA_CHAN_READ_ALL_MAX_WEIGHT;
 
-
 	iowrite32(DMA_ENGINE_EN_MASK, engine_en);
 
 	/* Unmask all interrupts, so that the interrupt line gets asserted. */
@@ -260,7 +259,7 @@ static void intel_xpcie_ep_dma_enable(void __iomem *dma_base,
  * same time as controller is transitioning to L1.
  */
 static int intel_xpcie_ep_dma_doorbell(struct xpcie_epf *xpcie_epf, int chan,
-				void __iomem *doorbell)
+				       void __iomem *doorbell)
 {
 	int rc = 0;
 	int i = 20;
@@ -297,8 +296,8 @@ static int intel_xpcie_ep_dma_err_status(void __iomem *err_status, int chan)
 	return 0;
 }
 
-static int intel_xpcie_ep_dma_rd_err_status_high(void __iomem *err_status,
-						 int chan)
+static int intel_xpcie_ep_dma_rd_err_sts_h(void __iomem *err_status,
+					   int chan)
 {
 	if (ioread32(err_status) &
 	    (DMA_UNREQ_ERROR_CH_MASK(chan) |
@@ -311,8 +310,9 @@ static int intel_xpcie_ep_dma_rd_err_status_high(void __iomem *err_status,
 }
 
 static void intel_xpcie_ep_dma_setup_ll_descs(struct pcie_dma_chan *dma_chan,
-				       struct xpcie_dma_ll_desc_buf *desc_buf,
-				       int descs_num)
+					      struct xpcie_dma_ll_desc_buf
+						*desc_buf,
+					      int descs_num)
 {
 	int i = 0;
 	struct xpcie_dma_ll_desc *descs = desc_buf->virt;
@@ -330,7 +330,6 @@ static void intel_xpcie_ep_dma_setup_ll_descs(struct pcie_dma_chan *dma_chan,
 		  &dma_chan->dma_ch_control1);
 	iowrite32((u32)desc_buf->phys, &dma_chan->dma_llp_low);
 	iowrite32((u64)desc_buf->phys >> 32, &dma_chan->dma_llp_high);
-
 }
 
 int intel_xpcie_ep_dma_write_ll(struct pci_epf *epf, int chan, int descs_num)
@@ -432,8 +431,9 @@ int intel_xpcie_ep_dma_read_ll(struct pci_epf *epf, int chan, int descs_num)
 	rc = intel_xpcie_ep_dma_err_status(&dma_reg->dma_read_err_status_low,
 					   chan);
 	if (!rc) {
-		rc = intel_xpcie_ep_dma_rd_err_status_high(
-			&dma_reg->dma_read_err_status_high, chan);
+		rc =
+		intel_xpcie_ep_dma_rd_err_sts_h(&dma_reg->dma_rd_err_sts_h,
+						chan);
 	}
 cleanup:
 	/* Clear the done/abort interrupt. */
diff --git a/drivers/misc/xlink-pcie/local_host/dma.h b/drivers/misc/xlink-pcie/local_host/dma.h
index 5ed65053fcd2..5aed06d3bcb6 100644
--- a/drivers/misc/xlink-pcie/local_host/dma.h
+++ b/drivers/misc/xlink-pcie/local_host/dma.h
@@ -21,4 +21,4 @@ int intel_xpcie_ep_dma_write_ll(struct pci_epf *epf, int chan, int descs_num);
 bool intel_xpcie_ep_dma_enabled(struct pci_epf *epf);
 int intel_xpcie_ep_dma_reset(struct pci_epf *epf);
 
-#endif // XPCIE_DMA_HEADER_
+#endif /* XPCIE_DMA_HEADER_ */
diff --git a/drivers/misc/xlink-pcie/local_host/epf.c b/drivers/misc/xlink-pcie/local_host/epf.c
index 04d9b08228ba..6bef79461da5 100644
--- a/drivers/misc/xlink-pcie/local_host/epf.c
+++ b/drivers/misc/xlink-pcie/local_host/epf.c
@@ -124,7 +124,8 @@ int intel_xpcie_raise_irq(struct xpcie *xpcie, enum xpcie_doorbell_type type)
 }
 
 static void __iomem *intel_xpcie_epc_alloc_addr(struct pci_epc *epc,
-					 phys_addr_t *phys_addr, size_t size)
+						phys_addr_t *phys_addr,
+						size_t size)
 {
 	void __iomem *virt_addr;
 	unsigned long flags;
@@ -184,7 +185,8 @@ static int intel_xpcie_check_bar(struct pci_epf *epf,
 }
 
 static int intel_xpcie_configure_bar(struct pci_epf *epf,
-			      const struct pci_epc_features *epc_features)
+				     const struct pci_epc_features
+					*epc_features)
 {
 	struct pci_epf_bar *epf_bar;
 	bool bar_fixed_64bit;
@@ -201,16 +203,16 @@ static int intel_xpcie_configure_bar(struct pci_epf *epf,
 
 		if (i == BAR_2) {
 			ret = intel_xpcie_check_bar(epf, epf_bar, BAR_2,
-					     BAR2_MIN_SIZE,
-					     epc_features->reserved_bar);
+						    BAR2_MIN_SIZE,
+						    epc_features->reserved_bar);
 			if (ret)
 				return ret;
 		}
 
 		if (i == BAR_4) {
 			ret = intel_xpcie_check_bar(epf, epf_bar, BAR_4,
-					     BAR4_MIN_SIZE,
-					     epc_features->reserved_bar);
+						    BAR4_MIN_SIZE,
+						    epc_features->reserved_bar);
 			if (ret)
 				return ret;
 		}
@@ -244,7 +246,7 @@ static void intel_xpcie_cleanup_bars(struct pci_epf *epf)
 }
 
 static int intel_xpcie_setup_bar(struct pci_epf *epf, enum pci_barno barno,
-			  size_t min_size, size_t align)
+				 size_t min_size, size_t align)
 {
 	int ret;
 	void *vaddr = NULL;
@@ -458,9 +460,7 @@ static void intel_xpcie_epf_shutdown(struct device *dev)
 	struct pci_epf *epf = to_pci_epf(dev);
 	struct xpcie_epf *xpcie_epf = epf_get_drvdata(epf);
 
-	/*
-	 * Notify host in case PCIe hot plug not supported
-	 */
+	/* Notify host in case PCIe hot plug not supported */
 	if (xpcie_epf && xpcie_epf->xpcie.status == XPCIE_STATUS_RUN) {
 		intel_xpcie_set_doorbell(&xpcie_epf->xpcie, FROM_DEVICE,
 					 DEV_EVENT, DEV_SHUTDOWN);
diff --git a/drivers/misc/xlink-pcie/local_host/epf.h b/drivers/misc/xlink-pcie/local_host/epf.h
index 84ea60d4bc63..adf73d609200 100644
--- a/drivers/misc/xlink-pcie/local_host/epf.h
+++ b/drivers/misc/xlink-pcie/local_host/epf.h
@@ -15,11 +15,11 @@
 
 extern u32 xlink_sw_id;
 
-extern void intel_xpcie_register_host_irq(struct xpcie *xpcie,
-					  irq_handler_t func);
+void intel_xpcie_register_host_irq(struct xpcie *xpcie,
+				   irq_handler_t func);
 
-extern int intel_xpcie_raise_irq(struct xpcie *xpcie,
-				 enum xpcie_doorbell_type type);
+int intel_xpcie_raise_irq(struct xpcie *xpcie,
+			  enum xpcie_doorbell_type type);
 
 /*
  * These two functions are for DMA linked list mode.
@@ -27,9 +27,9 @@ extern int intel_xpcie_raise_irq(struct xpcie *xpcie,
  * Caller should set the dst/src addresses and length for DMA descriptors in
  * xpcie_epf.dma_ll_tx_descs/dma_ll_rx_descs.
  */
-extern int intel_xpcie_copy_from_host_ll(struct xpcie *xpcie,
-					 int chan, int descs_num);
-extern int intel_xpcie_copy_to_host_ll(struct xpcie *xpcie,
-				       int chan, int descs_num);
+int intel_xpcie_copy_from_host_ll(struct xpcie *xpcie,
+				  int chan, int descs_num);
+int intel_xpcie_copy_to_host_ll(struct xpcie *xpcie,
+				int chan, int descs_num);
 
-#endif // XPCIE_EPF_HEADER_
+#endif /* XPCIE_EPF_HEADER_ */
diff --git a/drivers/misc/xlink-pcie/local_host/if.c b/drivers/misc/xlink-pcie/local_host/if.c
index d8cae7f4af01..b7559744be6e 100644
--- a/drivers/misc/xlink-pcie/local_host/if.c
+++ b/drivers/misc/xlink-pcie/local_host/if.c
@@ -13,8 +13,8 @@
 #include "../common/core.h"
 #include "epf.h"
 
-int xlink_pcie_get_device_list(uint32_t *sw_device_id_list,
-			       uint32_t *num_devices)
+int xlink_pcie_get_device_list(u32 *sw_device_id_list,
+			       u32 *num_devices)
 {
 	if (xlink_sw_id != 0) {
 		*num_devices = 1;
@@ -27,7 +27,7 @@ int xlink_pcie_get_device_list(uint32_t *sw_device_id_list,
 }
 EXPORT_SYMBOL(xlink_pcie_get_device_list);
 
-int xlink_pcie_get_device_name(uint32_t sw_device_id, char *device_name,
+int xlink_pcie_get_device_name(u32 sw_device_id, char *device_name,
 			       size_t name_size)
 {
 	struct xpcie *xpcie = intel_xpcie_core_get_by_id(sw_device_id);
@@ -44,7 +44,7 @@ int xlink_pcie_get_device_name(uint32_t sw_device_id, char *device_name,
 }
 EXPORT_SYMBOL(xlink_pcie_get_device_name);
 
-int xlink_pcie_get_device_status(uint32_t sw_device_id, uint32_t *device_status)
+int xlink_pcie_get_device_status(u32 sw_device_id, u32 *device_status)
 {
 	struct xpcie *xpcie = intel_xpcie_core_get_by_id(sw_device_id);
 
@@ -68,13 +68,13 @@ int xlink_pcie_get_device_status(uint32_t sw_device_id, uint32_t *device_status)
 }
 EXPORT_SYMBOL(xlink_pcie_get_device_status);
 
-int xlink_pcie_boot_device(uint32_t sw_device_id, const char *binary_name)
+int xlink_pcie_boot_device(u32 sw_device_id, const char *binary_name)
 {
 	return 0;
 }
 EXPORT_SYMBOL(xlink_pcie_boot_device);
 
-int xlink_pcie_connect(uint32_t sw_device_id)
+int xlink_pcie_connect(u32 sw_device_id)
 {
 	struct xpcie *xpcie = intel_xpcie_core_get_by_id(sw_device_id);
 
@@ -88,8 +88,8 @@ int xlink_pcie_connect(uint32_t sw_device_id)
 }
 EXPORT_SYMBOL(xlink_pcie_connect);
 
-int xlink_pcie_read(uint32_t sw_device_id, void *data, size_t *const size,
-		    uint32_t timeout)
+int xlink_pcie_read(u32 sw_device_id, void *data, size_t *const size,
+		    u32 timeout)
 {
 	struct xpcie *xpcie = intel_xpcie_core_get_by_id(sw_device_id);
 
@@ -100,8 +100,8 @@ int xlink_pcie_read(uint32_t sw_device_id, void *data, size_t *const size,
 }
 EXPORT_SYMBOL(xlink_pcie_read);
 
-int xlink_pcie_write(uint32_t sw_device_id, void *data, size_t *const size,
-		     uint32_t timeout)
+int xlink_pcie_write(u32 sw_device_id, void *data, size_t *const size,
+		     u32 timeout)
 {
 	struct xpcie *xpcie = intel_xpcie_core_get_by_id(sw_device_id);
 
@@ -112,7 +112,7 @@ int xlink_pcie_write(uint32_t sw_device_id, void *data, size_t *const size,
 }
 EXPORT_SYMBOL(xlink_pcie_write);
 
-int xlink_pcie_reset_device(uint32_t sw_device_id)
+int xlink_pcie_reset_device(u32 sw_device_id)
 {
 	return 0;
 }
diff --git a/drivers/misc/xlink-pcie/local_host/struct.h b/drivers/misc/xlink-pcie/local_host/struct.h
index 7a45d76199a7..6dc067a7b4cb 100644
--- a/drivers/misc/xlink-pcie/local_host/struct.h
+++ b/drivers/misc/xlink-pcie/local_host/struct.h
@@ -75,4 +75,4 @@ static inline struct device *xpcie_to_dev(struct xpcie *xpcie)
 	return &xpcie_epf->epf->dev;
 }
 
-#endif // XPCIE_STRUCT_HEADER_
+#endif /* XPCIE_STRUCT_HEADER_ */
diff --git a/drivers/misc/xlink-pcie/remote_host/core.c b/drivers/misc/xlink-pcie/remote_host/core.c
index 2c405400b17a..fe2a8fe0d9fe 100644
--- a/drivers/misc/xlink-pcie/remote_host/core.c
+++ b/drivers/misc/xlink-pcie/remote_host/core.c
@@ -15,7 +15,7 @@
 #include "../common/util.h"
 #include "../common/capabilities.h"
 
-#define XPCIE_CIRCULAR_INC(val, max) (((val) + 1) & (max - 1))
+#define XPCIE_CIRCULAR_INC(val, max) (((val) + 1) & ((max) - 1))
 
 static int rx_pool_size = SZ_32M;
 module_param(rx_pool_size, int, 0664);
@@ -42,7 +42,7 @@ static int intel_xpcie_version_check(struct xpcie *xpcie)
 }
 
 static int intel_xpcie_map_dma(struct xpcie *xpcie, struct xpcie_buf_desc *bd,
-			int direction)
+			       int direction)
 {
 	struct xpcie_dev *xdev = container_of(xpcie, struct xpcie_dev, xpcie);
 	struct device *dev = &xdev->pci->dev;
@@ -72,9 +72,9 @@ static void intel_xpcie_txrx_cleanup(struct xpcie *xpcie)
 
 	xpcie->stop_flag = true;
 	xpcie->no_tx_buffer = false;
-	inf->data_available = true;
-	wake_up_interruptible(&xpcie->tx_waitqueue);
-	wake_up_interruptible(&inf->rx_waitqueue);
+	inf->data_avail = true;
+	wake_up_interruptible(&xpcie->tx_waitq);
+	wake_up_interruptible(&inf->rx_waitq);
 	mutex_lock(&xpcie->wlock);
 	mutex_lock(&inf->rlock);
 
@@ -284,7 +284,7 @@ static void intel_xpcie_rx_event_handler(struct work_struct *work)
 		if (unlikely(status != XPCIE_DESC_STATUS_SUCCESS) ||
 		    unlikely(interface >= XPCIE_NUM_INTERFACES)) {
 			dev_err(xpcie_to_dev(xpcie),
-			"detected rx desc failure, status(%u), interface(%u)\n",
+				"rx desc failure, status(%u), interface(%u)\n",
 			status, interface);
 			intel_xpcie_free_rx_bd(xpcie, bd);
 		} else {
@@ -338,7 +338,7 @@ static void intel_xpcie_tx_event_handler(struct work_struct *work)
 	tail = intel_xpcie_get_tdr_tail(&tx->pipe);
 	head = intel_xpcie_get_tdr_head(&tx->pipe);
 
-	// clean old entries first
+	/* clean old entries first */
 	while (old != head) {
 		bd = tx->ddr[old];
 		td = tx->pipe.tdr + old;
@@ -418,14 +418,14 @@ static irqreturn_t intel_xpcie_interrupt(int irq, void *args)
 static int intel_xpcie_events_init(struct xpcie *xpcie)
 {
 	xpcie->rx_wq = alloc_ordered_workqueue(XPCIE_DRIVER_NAME,
-					      WQ_MEM_RECLAIM | WQ_HIGHPRI);
+					       WQ_MEM_RECLAIM | WQ_HIGHPRI);
 	if (!xpcie->rx_wq) {
 		dev_err(xpcie_to_dev(xpcie), "failed to allocate workqueue\n");
 		return -ENOMEM;
 	}
 
 	xpcie->tx_wq = alloc_ordered_workqueue(XPCIE_DRIVER_NAME,
-					      WQ_MEM_RECLAIM | WQ_HIGHPRI);
+					       WQ_MEM_RECLAIM | WQ_HIGHPRI);
 	if (!xpcie->tx_wq) {
 		dev_err(xpcie_to_dev(xpcie), "failed to allocate workqueue\n");
 		destroy_workqueue(xpcie->rx_wq);
@@ -499,7 +499,7 @@ void intel_xpcie_core_cleanup(struct xpcie *xpcie)
 }
 
 int intel_xpcie_core_read(struct xpcie *xpcie, void *buffer, size_t *length,
-		   uint32_t timeout_ms)
+			  uint32_t timeout_ms)
 {
 	int ret = 0;
 	struct xpcie_interface *inf = &xpcie->interfaces[0];
@@ -524,15 +524,17 @@ int intel_xpcie_core_read(struct xpcie *xpcie, void *buffer, size_t *length,
 		return -EINTR;
 
 	do {
-		while (!inf->data_available) {
+		while (!inf->data_avail) {
 			mutex_unlock(&inf->rlock);
 			if (timeout_ms == 0) {
-				ret = wait_event_interruptible(
-					inf->rx_waitqueue, inf->data_available);
+				ret = wait_event_interruptible(inf->rx_waitq,
+							       inf->data_avail);
 			} else {
-				ret = wait_event_interruptible_timeout(
-					inf->rx_waitqueue, inf->data_available,
-					jiffies_timeout - jiffies_passed);
+				ret =
+			wait_event_interruptible_timeout(inf->rx_waitq,
+							 inf->data_avail,
+							 jiffies_timeout -
+							 jiffies_passed);
 				if (ret == 0)
 					return -ETIME;
 			}
@@ -557,7 +559,9 @@ int intel_xpcie_core_read(struct xpcie *xpcie, void *buffer, size_t *length,
 			bd->data += bcopy;
 			bd->length -= bcopy;
 
-			intel_xpcie_debug_incr(xpcie, &xpcie->stats.rx_usr.bytes, bcopy);
+			intel_xpcie_debug_incr(xpcie,
+					       &xpcie->stats.rx_usr.bytes,
+					       bcopy);
 
 			if (bd->length == 0) {
 				intel_xpcie_free_rx_bd(xpcie, bd);
@@ -565,11 +569,11 @@ int intel_xpcie_core_read(struct xpcie *xpcie, void *buffer, size_t *length,
 			}
 		}
 
-		// save for next time
+		/* save for next time */
 		inf->partial_read = bd;
 
 		if (!bd)
-			inf->data_available = false;
+			inf->data_avail = false;
 
 		*length = len - remaining;
 
@@ -583,7 +587,7 @@ int intel_xpcie_core_read(struct xpcie *xpcie, void *buffer, size_t *length,
 }
 
 int intel_xpcie_core_write(struct xpcie *xpcie, void *buffer, size_t *length,
-		    uint32_t timeout_ms)
+			   uint32_t timeout_ms)
 {
 	int ret;
 	size_t len = *length;
@@ -608,17 +612,20 @@ int intel_xpcie_core_write(struct xpcie *xpcie, void *buffer, size_t *length,
 		return -EINTR;
 
 	do {
-		bd = head = intel_xpcie_alloc_tx_bd(xpcie);
+		bd = intel_xpcie_alloc_tx_bd(xpcie);
+		head = bd;
 		while (!head) {
 			mutex_unlock(&xpcie->wlock);
 			if (timeout_ms == 0) {
-				ret = wait_event_interruptible(
-					xpcie->tx_waitqueue,
-					!xpcie->no_tx_buffer);
+				ret =
+				wait_event_interruptible(xpcie->tx_waitq,
+							 !xpcie->no_tx_buffer);
 			} else {
-				ret = wait_event_interruptible_timeout(
-					xpcie->tx_waitqueue, !xpcie->no_tx_buffer,
-					jiffies_timeout - jiffies_passed);
+				ret =
+			wait_event_interruptible_timeout(xpcie->tx_waitq,
+							 !xpcie->no_tx_buffer,
+							 jiffies_timeout -
+							 jiffies_passed);
 				if (ret == 0)
 					return -ETIME;
 			}
@@ -629,7 +636,8 @@ int intel_xpcie_core_write(struct xpcie *xpcie, void *buffer, size_t *length,
 			if (ret < 0)
 				return -EINTR;
 
-			bd = head = intel_xpcie_alloc_tx_bd(xpcie);
+			bd = intel_xpcie_alloc_tx_bd(xpcie);
+			head = bd;
 		}
 
 		while (remaining && bd) {
@@ -643,7 +651,9 @@ int intel_xpcie_core_write(struct xpcie *xpcie, void *buffer, size_t *length,
 			bd->length = bcopy;
 			bd->interface = inf->id;
 
-			intel_xpcie_debug_incr(xpcie, &xpcie->stats.tx_usr.bytes, bcopy);
+			intel_xpcie_debug_incr(xpcie,
+					       &xpcie->stats.tx_usr.bytes,
+					       bcopy);
 
 			if (remaining) {
 				bd->next = intel_xpcie_alloc_tx_bd(xpcie);
diff --git a/drivers/misc/xlink-pcie/remote_host/if.c b/drivers/misc/xlink-pcie/remote_host/if.c
index f14b914ebcb2..dfb2d7d8bc61 100644
--- a/drivers/misc/xlink-pcie/remote_host/if.c
+++ b/drivers/misc/xlink-pcie/remote_host/if.c
@@ -12,8 +12,8 @@
 #include <linux/xlink_drv_inf.h>
 #include "pci.h"
 
-int xlink_pcie_get_device_list(uint32_t *sw_device_id_list,
-			       uint32_t *num_devices)
+int xlink_pcie_get_device_list(u32 *sw_device_id_list,
+			       u32 *num_devices)
 {
 	*num_devices = intel_xpcie_get_device_num(sw_device_id_list);
 
@@ -21,7 +21,7 @@ int xlink_pcie_get_device_list(uint32_t *sw_device_id_list,
 }
 EXPORT_SYMBOL(xlink_pcie_get_device_list);
 
-int xlink_pcie_get_device_name(uint32_t sw_device_id, char *device_name,
+int xlink_pcie_get_device_name(u32 sw_device_id, char *device_name,
 			       size_t name_size)
 {
 	return intel_xpcie_get_device_name_by_id(sw_device_id,
@@ -29,7 +29,7 @@ int xlink_pcie_get_device_name(uint32_t sw_device_id, char *device_name,
 }
 EXPORT_SYMBOL(xlink_pcie_get_device_name);
 
-int xlink_pcie_get_device_status(uint32_t sw_device_id, uint32_t *device_status)
+int xlink_pcie_get_device_status(u32 sw_device_id, u32 *device_status)
 {
 	int rc;
 	u32 status;
@@ -61,33 +61,33 @@ int xlink_pcie_get_device_status(uint32_t sw_device_id, uint32_t *device_status)
 }
 EXPORT_SYMBOL(xlink_pcie_get_device_status);
 
-int xlink_pcie_boot_device(uint32_t sw_device_id, const char *binary_name)
+int xlink_pcie_boot_device(u32 sw_device_id, const char *binary_name)
 {
 	return intel_xpcie_pci_boot_device(sw_device_id, binary_name);
 }
 EXPORT_SYMBOL(xlink_pcie_boot_device);
 
-int xlink_pcie_connect(uint32_t sw_device_id)
+int xlink_pcie_connect(u32 sw_device_id)
 {
 	return intel_xpcie_pci_connect_device(sw_device_id);
 }
 EXPORT_SYMBOL(xlink_pcie_connect);
 
-int xlink_pcie_read(uint32_t sw_device_id, void *data, size_t *const size,
-		    uint32_t timeout)
+int xlink_pcie_read(u32 sw_device_id, void *data, size_t *const size,
+		    u32 timeout)
 {
 	return intel_xpcie_pci_read(sw_device_id, data, size, timeout);
 }
 EXPORT_SYMBOL(xlink_pcie_read);
 
-int xlink_pcie_write(uint32_t sw_device_id, void *data, size_t *const size,
-		     uint32_t timeout)
+int xlink_pcie_write(u32 sw_device_id, void *data, size_t *const size,
+		     u32 timeout)
 {
 	return intel_xpcie_pci_write(sw_device_id, data, size, timeout);
 }
 EXPORT_SYMBOL(xlink_pcie_write);
 
-int xlink_pcie_reset_device(uint32_t sw_device_id)
+int xlink_pcie_reset_device(u32 sw_device_id)
 {
 	return intel_xpcie_pci_reset_device(sw_device_id);
 }
diff --git a/drivers/misc/xlink-pcie/remote_host/pci.c b/drivers/misc/xlink-pcie/remote_host/pci.c
index f6ba994a55f5..93ff5018e14b 100644
--- a/drivers/misc/xlink-pcie/remote_host/pci.c
+++ b/drivers/misc/xlink-pcie/remote_host/pci.c
@@ -62,7 +62,7 @@ struct xpcie_dev *intel_xpcie_get_device_by_id(u32 id)
 struct xpcie_dev *intel_xpcie_create_device(u32 sw_device_id,
 					    struct pci_dev *pdev)
 {
-	struct xpcie_dev *xdev = kzalloc(sizeof(struct xpcie_dev), GFP_KERNEL);
+	struct xpcie_dev *xdev = kzalloc(sizeof(*xdev), GFP_KERNEL);
 
 	if (!xdev)
 		return NULL;
@@ -239,58 +239,14 @@ static irqreturn_t intel_xpcie_interrupt(int irq, void *args)
 
 static void intel_xpcie_pci_irq_cleanup(struct xpcie_dev *xdev)
 {
-#if KERNEL_VERSION(4, 8, 0) <= LINUX_VERSION_CODE
-	int irq = pci_irq_vector(xdev->pci, 0);
-
-	if (irq < 0)
-		return;
-
-	synchronize_irq(irq);
-	free_irq(irq, xdev);
-	pci_free_irq_vectors(xdev->pci);
-#else
 	if (!pci_msi_enabled())
 		return;
 
 	synchronize_irq(xdev->pci->irq);
 	free_irq(xdev->pci->irq, xdev);
 	pci_disable_msi(xdev->pci);
-#endif
 }
 
-#if KERNEL_VERSION(4, 8, 0) <= LINUX_VERSION_CODE
-static int intel_xpcie_pci_irq_init(struct xpcie_dev *xdev)
-{
-	int irq;
-	int rc;
-
-	rc = pci_alloc_irq_vectors(xdev->pci, 1, 1, PCI_IRQ_MSI);
-	if (rc < 0) {
-		dev_err(&xdev->pci->dev,
-			"failed to allocate %d MSI vectors\n", 1);
-		return rc;
-	}
-
-	irq = pci_irq_vector(xdev->pci, 0);
-	if (irq < 0) {
-		dev_err(&xdev->pci->dev, "failed to get irq\n");
-		rc = irq;
-		goto error_irq;
-	}
-	rc = request_irq(irq, &intel_xpcie_interrupt, 0,
-			 XPCIE_DRIVER_NAME, xdev);
-	if (rc) {
-		dev_err(&xdev->pci->dev, "failed to request irqs\n");
-		goto error_irq;
-	}
-
-	return 0;
-
-error_irq:
-	pci_free_irq_vectors(xdev->pci);
-	return rc;
-}
-#else
 static int intel_xpcie_pci_irq_init(struct xpcie_dev *xdev)
 {
 	int rc;
@@ -302,7 +258,7 @@ static int intel_xpcie_pci_irq_init(struct xpcie_dev *xdev)
 	}
 
 	rc = request_irq(xdev->pci->irq, &intel_xpcie_interrupt, 0,
-			    XPCIE_DRIVER_NAME, xdev);
+			 XPCIE_DRIVER_NAME, xdev);
 	if (rc) {
 		dev_err(&xdev->pci->dev, "failed to request irqs\n");
 		goto error_irq;
@@ -314,10 +270,9 @@ static int intel_xpcie_pci_irq_init(struct xpcie_dev *xdev)
 	pci_disable_msi(xdev->pci);
 	return rc;
 }
-#endif
 
 static int xpcie_device_wait_status(struct xpcie_dev *xdev, u32 image_id,
-				   u32 timeout_ms)
+				    u32 timeout_ms)
 {
 	u32 status = XPCIE_BOOT_STATUS_START;
 	int count = 0;
@@ -354,7 +309,7 @@ static int xpcie_device_wait_status(struct xpcie_dev *xdev, u32 image_id,
 }
 
 static int xpcie_device_transfer(struct xpcie_dev *xdev, u32 image_id,
-				dma_addr_t addr, size_t size)
+				 dma_addr_t addr, size_t size)
 {
 	int rc;
 
@@ -373,8 +328,8 @@ static int xpcie_device_transfer(struct xpcie_dev *xdev, u32 image_id,
 }
 
 static int xpcie_device_download_common(struct xpcie_dev *xdev, u32 image_id,
-				       const void *buf, size_t buf_size,
-				       bool no_copy)
+					const void *buf, size_t buf_size,
+					bool no_copy)
 {
 	int rc = 0;
 	size_t size;
@@ -408,7 +363,7 @@ static int xpcie_device_download_common(struct xpcie_dev *xdev, u32 image_id,
 }
 
 static int xpcie_device_download_firmware(struct xpcie_dev *xdev, u32 image_id,
-					 const char *fw_image)
+					  const char *fw_image)
 {
 	const struct firmware *firmware;
 	struct device *dev = &xdev->pci->dev;
@@ -439,7 +394,7 @@ static int xpcie_device_download_firmware(struct xpcie_dev *xdev, u32 image_id,
 	}
 
 	rc = xpcie_device_download_common(xdev, image_id, firmware->data,
-					 firmware->size, false);
+					  firmware->size, false);
 
 	kfree(xdev->dma_buf);
 	xdev->dma_buf = NULL;
@@ -453,7 +408,7 @@ static int xpcie_device_download_firmware(struct xpcie_dev *xdev, u32 image_id,
 static int xpcie_device_flashless_boot(struct xpcie_dev *xdev)
 {
 	if (xpcie_device_download_firmware(xdev, XPCIE_BOOT_BOOT_ID,
-					  xdev->fw_name)) {
+					   xdev->fw_name)) {
 		dev_err(&xdev->pci->dev, "failed to download boot image\n");
 		return -EIO;
 	}
@@ -466,7 +421,7 @@ static int xpcie_device_flashless_boot(struct xpcie_dev *xdev)
 static int xpcie_device_fip(struct xpcie_dev *xdev)
 {
 	if (xpcie_device_download_firmware(xdev, XPCIE_BOOT_FIP_ID,
-					  xdev->fw_name)) {
+					   xdev->fw_name)) {
 		dev_err(&xdev->pci->dev, "failed to download FIP image\n");
 		return -EIO;
 	}
@@ -792,7 +747,8 @@ int intel_xpcie_pci_boot_device(u32 id, const char *binary_name)
 	}
 
 	rc = intel_xpcie_wait_event((xdev->xpcie.status == expected) ||
-			     (xdev->xpcie.status == XPCIE_STATUS_RECOVERY));
+				    (xdev->xpcie.status ==
+				     XPCIE_STATUS_RECOVERY));
 
 	if (xdev->xpcie.status == XPCIE_STATUS_RECOVERY)
 		rc = -EIO;
@@ -915,7 +871,7 @@ static int intel_xpcie_recovery_send_left(struct xpcie_dev *xdev,
 	int rc;
 
 	rc = xpcie_device_download_common(xdev, XPCIE_BOOT_RAW_ID, NULL,
-			xdev->dma_buf_offset, true);
+					  xdev->dma_buf_offset, true);
 	xdev->dma_buf_offset = 0;
 	if (reset_offset)
 		xdev->partition_offset = 0;
@@ -945,7 +901,7 @@ static int intel_xpcie_pci_flash_gpt_table(struct xpcie_dev *xdev)
 }
 
 static int intel_xpcie_pci_erase_partition(struct xpcie_dev *xdev,
-				    const char *partition, size_t len)
+					   const char *partition, size_t len)
 {
 	int rc = 0;
 
@@ -969,8 +925,8 @@ static int intel_xpcie_pci_erase_partition(struct xpcie_dev *xdev,
 }
 
 static int intel_xpcie_pci_flash_partition_start(struct xpcie_dev *xdev,
-					  const char *partition,
-					  size_t name_len)
+						 const char *partition,
+						 size_t name_len)
 {
 	int rc = 0;
 
@@ -986,7 +942,7 @@ static int intel_xpcie_pci_flash_partition_start(struct xpcie_dev *xdev,
 
 	memset(xdev->partition_name, 0, XPCIE_BOOT_DEST_STRLEN);
 	memcpy(xdev->partition_name, partition,
-		(name_len >= XPCIE_BOOT_DEST_STRLEN) ?
+	       (name_len >= XPCIE_BOOT_DEST_STRLEN) ?
 			(XPCIE_BOOT_DEST_STRLEN - 1) : name_len);
 	xdev->partition_offset = 0;
 
@@ -999,7 +955,7 @@ static int intel_xpcie_pci_flash_partition_start(struct xpcie_dev *xdev,
 }
 
 static int intel_xpcie_pci_flash_partition_send(struct xpcie_dev *xdev,
-					 const void *data, size_t size)
+						const void *data, size_t size)
 {
 	int rc = 0;
 	int size_left = size;
@@ -1021,7 +977,7 @@ static int intel_xpcie_pci_flash_partition_send(struct xpcie_dev *xdev,
 		size = (size > (SECTION_SIZE - xdev->dma_buf_offset)) ?
 			(SECTION_SIZE - xdev->dma_buf_offset) : size;
 		memcpy(xdev->dma_buf + xdev->dma_buf_offset,
-			data, size);
+		       data, size);
 		xdev->dma_buf_offset += size;
 		size_left -= size;
 		data += size;
@@ -1061,8 +1017,8 @@ static int intel_xpcie_pci_flash_done(struct xpcie_dev *xdev)
 }
 
 static ssize_t partition_store(struct device *dev,
-				struct device_attribute *attr,
-				const char *buf, size_t count)
+			       struct device_attribute *attr,
+			       const char *buf, size_t count)
 {
 	int rc;
 
@@ -1103,8 +1059,8 @@ static ssize_t create_partitions_store(struct device *dev,
 static DEVICE_ATTR_WO(create_partitions);
 
 static ssize_t erase_partition_store(struct device *dev,
-				    struct device_attribute *attr,
-				    const char *buf, size_t count)
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
 {
 	int rc;
 	long value;
@@ -1116,7 +1072,7 @@ static ssize_t erase_partition_store(struct device *dev,
 
 	if (value) {
 		rc = intel_xpcie_pci_erase_partition(xdev, xdev->partition_name,
-					      XPCIE_BOOT_DEST_STRLEN);
+						     XPCIE_BOOT_DEST_STRLEN);
 		if (rc) {
 			dev_err(dev, "failed to erase partition\n");
 			return rc;
diff --git a/drivers/misc/xlink-pcie/remote_host/pci.h b/drivers/misc/xlink-pcie/remote_host/pci.h
index 4208141f34f6..b72b7d3dd67d 100644
--- a/drivers/misc/xlink-pcie/remote_host/pci.h
+++ b/drivers/misc/xlink-pcie/remote_host/pci.h
@@ -21,7 +21,7 @@
 
 struct xpcie_dev {
 	struct list_head list;
-	struct mutex lock;
+	struct mutex lock; /* Device Lock */
 
 	struct pci_dev *pci;
 	char name[XPCIE_MAX_NAME_LEN];
@@ -76,4 +76,4 @@ int intel_xpcie_pci_reset_device(u32 id);
 
 u64 intel_xpcie_pci_hw_dev_id(struct xpcie_dev *xdev);
 
-#endif
+#endif /* XPCIE_PCI_HEADER_ */
diff --git a/include/linux/xlink_drv_inf.h b/include/linux/xlink_drv_inf.h
index f33a8cd3c77d..980b9bbb1688 100644
--- a/include/linux/xlink_drv_inf.h
+++ b/include/linux/xlink_drv_inf.h
@@ -47,17 +47,17 @@ enum _xlink_device_status {
 	_XLINK_DEV_READY
 };
 
-int xlink_pcie_get_device_list(uint32_t *sw_device_id_list,
-			       uint32_t *num_devices);
-int xlink_pcie_get_device_name(uint32_t sw_device_id, char *device_name,
+int xlink_pcie_get_device_list(u32 *sw_device_id_list,
+			       u32 *num_devices);
+int xlink_pcie_get_device_name(u32 sw_device_id, char *device_name,
 			       size_t name_size);
-int xlink_pcie_get_device_status(uint32_t sw_device_id,
-				 uint32_t *device_status);
-int xlink_pcie_boot_device(uint32_t sw_device_id, const char *binary_name);
-int xlink_pcie_connect(uint32_t sw_device_id);
-int xlink_pcie_read(uint32_t sw_device_id, void *data, size_t *const size,
-		    uint32_t timeout);
-int xlink_pcie_write(uint32_t sw_device_id, void *data, size_t *const size,
-		     uint32_t timeout);
-int xlink_pcie_reset_device(uint32_t sw_device_id);
+int xlink_pcie_get_device_status(u32 sw_device_id,
+				 u32 *device_status);
+int xlink_pcie_boot_device(u32 sw_device_id, const char *binary_name);
+int xlink_pcie_connect(u32 sw_device_id);
+int xlink_pcie_read(u32 sw_device_id, void *data, size_t *const size,
+		    u32 timeout);
+int xlink_pcie_write(u32 sw_device_id, void *data, size_t *const size,
+		     u32 timeout);
+int xlink_pcie_reset_device(u32 sw_device_id);
 #endif
-- 
2.27.0

