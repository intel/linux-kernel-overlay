From fcebb78b7ded78e6b5d7ebd47f9e934062f1935b Mon Sep 17 00:00:00 2001
From: Srikanth Thokala <srikanth.thokala@intel.com>
Date: Fri, 11 Jun 2021 18:15:45 +0530
Subject: [PATCH 140/170] misc: xlink-pcie: Acknowledge sw_devid event from
 local host

Added ack notify at local host on recieving the sw_devid from
remote host.

Signed-off-by: Srikanth Thokala <srikanth.thokala@intel.com>
---
 drivers/misc/xlink-pcie/common/util.c     |  8 +--
 drivers/misc/xlink-pcie/common/util.h     |  7 +--
 drivers/misc/xlink-pcie/common/xpcie.h    |  6 +--
 drivers/misc/xlink-pcie/local_host/epf.c  | 20 +++----
 drivers/misc/xlink-pcie/local_host/epf.h  | 12 ++---
 drivers/misc/xlink-pcie/remote_host/pci.c | 64 +++++++++++++++++------
 6 files changed, 72 insertions(+), 45 deletions(-)

diff --git a/drivers/misc/xlink-pcie/common/util.c b/drivers/misc/xlink-pcie/common/util.c
index d1b4c521a193..09101e94ab58 100644
--- a/drivers/misc/xlink-pcie/common/util.c
+++ b/drivers/misc/xlink-pcie/common/util.c
@@ -186,14 +186,14 @@ u8 intel_xpcie_get_max_functions(struct xpcie *xpcie)
 	return intel_xpcie_ioread8(xpcie->mmio + XPCIE_MMIO_MAX_FUNCTIONS);
 }
 
-void intel_xpcie_set_physical_device_id(struct xpcie *xpcie, u16 phys_id)
+void intel_xpcie_set_sw_device_id(struct xpcie *xpcie, u32 sw_devid)
 {
-	intel_xpcie_iowrite16(phys_id, xpcie->mmio + XPCIE_MMIO_PHY_DEV_ID);
+	intel_xpcie_iowrite32(sw_devid, xpcie->mmio + XPCIE_MMIO_SW_DEVID);
 }
 
-u16 intel_xpcie_get_physical_device_id(struct xpcie *xpcie)
+u32 intel_xpcie_get_sw_device_id(struct xpcie *xpcie)
 {
-	return intel_xpcie_ioread16(xpcie->mmio + XPCIE_MMIO_PHY_DEV_ID);
+	return intel_xpcie_ioread32(xpcie->mmio + XPCIE_MMIO_SW_DEVID);
 }
 #endif
 
diff --git a/drivers/misc/xlink-pcie/common/util.h b/drivers/misc/xlink-pcie/common/util.h
index 2a5ae0312f78..27fc9cb90d52 100644
--- a/drivers/misc/xlink-pcie/common/util.h
+++ b/drivers/misc/xlink-pcie/common/util.h
@@ -33,7 +33,8 @@ enum xpcie_event_type {
 	DEV_SHUTDOWN,
 	PREP_FLR_RESET,
 	PREP_FLR_RESET_ACK,
-	FLR_RESET_ACK
+	FLR_RESET_ACK,
+	PHY_ID_RECIEVED_ACK
 };
 
 void intel_xpcie_set_doorbell(struct xpcie *xpcie,
@@ -61,8 +62,8 @@ void intel_xpcie_set_host_status(struct xpcie *xpcie, u32 status);
 void intel_xpcie_set_max_functions(struct xpcie *xpcie, u8 max_functions);
 u8 intel_xpcie_get_max_functions(struct xpcie *xpcie);
 u32 intel_xpcie_create_sw_device_id(u8 func_no, u16 phy_id, u8 max_functions);
-void intel_xpcie_set_physical_device_id(struct xpcie *xpcie, u16 phys_id);
-u16 intel_xpcie_get_physical_device_id(struct xpcie *xpcie);
+void intel_xpcie_set_sw_device_id(struct xpcie *xpcie, u32 sw_devid);
+u32 intel_xpcie_get_sw_device_id(struct xpcie *xpcie);
 #endif
 
 struct xpcie_buf_desc *intel_xpcie_alloc_bd(size_t length);
diff --git a/drivers/misc/xlink-pcie/common/xpcie.h b/drivers/misc/xlink-pcie/common/xpcie.h
index d2f6d71ae06b..c59388871628 100644
--- a/drivers/misc/xlink-pcie/common/xpcie.h
+++ b/drivers/misc/xlink-pcie/common/xpcie.h
@@ -49,7 +49,7 @@ struct xpcie_mmio {
 	u32 device_status;
 	u32 host_status;
 #if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
-	u16 phy_dev_id;
+	u32 sw_devid;
 	u8 max_functions;
 #endif
 	u8 legacy_a0;
@@ -62,10 +62,10 @@ struct xpcie_mmio {
 	u8 dtoh_event_doorbell;
 #if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 	u8 htod_phy_id_doorbell_status;
+	u8 rsvd[2];
 #endif
 	u32 cap_offset;
 	u32 htod_rx_bd_list_count;
-	u32 dummy;
 } __packed;
 
 #define XPCIE_MMIO_LEGACY_A0	(offsetof(struct xpcie_mmio, legacy_a0))
@@ -94,7 +94,7 @@ struct xpcie_mmio {
 
 #if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 
-#define XPCIE_MMIO_PHY_DEV_ID	(offsetof(struct xpcie_mmio, phy_dev_id))
+#define XPCIE_MMIO_SW_DEVID	(offsetof(struct xpcie_mmio, sw_devid))
 #define XPCIE_MMIO_MAX_FUNCTIONS \
 	(offsetof(struct xpcie_mmio, max_functions))
 #define XPCIE_MMIO_HTOD_PHY_ID_DOORBELL_STATUS \
diff --git a/drivers/misc/xlink-pcie/local_host/epf.c b/drivers/misc/xlink-pcie/local_host/epf.c
index 4955222a069a..83c8b2c70029 100644
--- a/drivers/misc/xlink-pcie/local_host/epf.c
+++ b/drivers/misc/xlink-pcie/local_host/epf.c
@@ -190,10 +190,7 @@ static irqreturn_t intel_xpcie_host_interrupt(int irq, void *args)
 	struct xpcie_epf *xpcie_epf = container_of(xpcie,
 						   struct xpcie_epf, xpcie);
 	u8 event;
-#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
-	u16 phy_id = 0;
-	u8 max_functions = 0;
-#else
+#if (!IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 	u32 val;
 
 	val = ioread32(xpcie_epf->apb_base + PCIE_REGS_PCIE_INTR_FLAGS);
@@ -220,16 +217,16 @@ static irqreturn_t intel_xpcie_host_interrupt(int irq, void *args)
 	if (intel_xpcie_get_doorbell(xpcie, TO_DEVICE, PHY_ID_UPDATED)) {
 		intel_xpcie_set_doorbell(xpcie, TO_DEVICE, PHY_ID_UPDATED, 0);
 		if (!xpcie_epf->sw_dev_id_updated) {
-			phy_id = intel_xpcie_get_physical_device_id(xpcie);
-			max_functions = intel_xpcie_get_max_functions(xpcie);
 			xpcie_epf->sw_devid =
-			intel_xpcie_create_sw_device_id(xpcie_epf->epf->func_no,
-							phy_id, max_functions);
+				intel_xpcie_get_sw_device_id(xpcie);
 			xpcie_epf->sw_dev_id_updated = true;
 			dev_info(xpcie_to_dev(xpcie),
-				 "pcie: func_no=%x swid updated=%x phy_id=%x\n",
+				 "pcie: func_no=%x swid updated=%x\n",
 				 xpcie_epf->epf->func_no,
-				 xpcie_epf->sw_devid, phy_id);
+				 xpcie_epf->sw_devid);
+
+			intel_xpcie_set_doorbell(xpcie, FROM_DEVICE, DEV_EVENT,
+						 PHY_ID_RECIEVED_ACK);
 		}
 	}
 #endif
@@ -771,9 +768,8 @@ static ssize_t swdev_id_show(struct device *dev,
 {
 	struct pci_epf *epf = container_of(dev, struct pci_epf, dev);
 	struct xpcie_epf *xpcie_epf = epf_get_drvdata(epf);
-	struct xpcie *xpcie = &xpcie_epf->xpcie;
 
-	if (xpcie->swdev_avail)
+	if (xpcie_epf->sw_dev_id_updated)
 		snprintf(buf, 4096, "%s\n", "okay");
 	else
 		snprintf(buf, 4096, "%s\n", "disabled");
diff --git a/drivers/misc/xlink-pcie/local_host/epf.h b/drivers/misc/xlink-pcie/local_host/epf.h
index a31a429f3c23..4288c7fec43b 100644
--- a/drivers/misc/xlink-pcie/local_host/epf.h
+++ b/drivers/misc/xlink-pcie/local_host/epf.h
@@ -106,13 +106,13 @@ struct xpcie_epf {
 
 #if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 #define MXLK_MAX_NAME_LEN (32)
-	char                            name[MXLK_MAX_NAME_LEN];
-	u32                             sw_devid;
-	bool                            sw_dev_id_updated;
-	struct list_head                list;
-	xlink_device_event event_fn;
+	char				name[MXLK_MAX_NAME_LEN];
+	u32				sw_devid;
+	bool				sw_dev_id_updated;
+	struct list_head		list;
+	xlink_device_event		event_fn;
 
-	struct work_struct flr_irq_event;
+	struct work_struct		flr_irq_event;
 #endif
 };
 
diff --git a/drivers/misc/xlink-pcie/remote_host/pci.c b/drivers/misc/xlink-pcie/remote_host/pci.c
index 7fef8320f18d..07e33b7e3a02 100644
--- a/drivers/misc/xlink-pcie/remote_host/pci.c
+++ b/drivers/misc/xlink-pcie/remote_host/pci.c
@@ -21,6 +21,8 @@
 #include "../common/core.h"
 #include "../common/util.h"
 
+#define MAX_SW_DEVID_RETRIES 10
+
 static int aspm_enable;
 module_param(aspm_enable, int, 0664);
 MODULE_PARM_DESC(aspm_enable, "enable ASPM");
@@ -271,32 +273,60 @@ static void xpcie_device_poll(struct work_struct *work)
 					      wait_event.work);
 	enum xpcie_stage stage = intel_xpcie_check_magic(xdev);
 #if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
-	u8 max_functions;
+	u8 max_functions, event, fn_no;
+	static u8 sw_devid_retries;
+	bool poll_again = true;
 	u32 devid;
 #endif
 	if (stage == STAGE_RECOV) {
 		if (xdev->xpcie.status != XPCIE_STATUS_RECOVERY)
 			xdev->xpcie.status = XPCIE_STATUS_RECOVERY;
 	} else if (stage == STAGE_OS) {
-		xdev->xpcie.status = XPCIE_STATUS_READY;
 #if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
-		devid = (PCI_BUS_NUM(xdev->devid) << 8) |
-			 PCI_SLOT(xdev->pci->devfn);
-		intel_xpcie_set_physical_device_id(&xdev->xpcie, devid);
-		max_functions = intel_xpcie_get_max_functions(&xdev->xpcie);
-		xdev->sw_devid =
-			intel_xpcie_create_sw_device_id
-			(PCI_FUNC(xdev->pci->devfn), devid, max_functions);
-		dev_info(&xdev->pci->dev,
-			 "sw_devid=%x, function idx=%d, max_functions=%d\n",
-			 xdev->sw_devid,
-			 PCI_FUNC(xdev->pci->devfn), max_functions);
-		intel_xpcie_pci_raise_irq(xdev, PHY_ID_UPDATED, 1);
-
-		return;
+		event = intel_xpcie_get_doorbell(&xdev->xpcie,
+						 FROM_DEVICE, DEV_EVENT);
+		if (event == PHY_ID_RECIEVED_ACK) {
+			intel_xpcie_set_doorbell(&xdev->xpcie, FROM_DEVICE,
+						 DEV_EVENT, NO_OP);
+			xdev->xpcie.status = XPCIE_STATUS_READY;
+			intel_xpcie_pci_notify_event(xdev,
+						     NOTIFY_DEVICE_CONNECTED);
+			sw_devid_retries = 0;
+			poll_again = false;
+		} else {
+			if (sw_devid_retries++ == MAX_SW_DEVID_RETRIES) {
+				sw_devid_retries = 0;
+				dev_err(&xdev->pci->dev,
+					"ACK for sw_devid %x not rx'ed\n",
+					xdev->sw_devid);
+				poll_again = false;
+			}
+
+			fn_no = PCI_FUNC(xdev->pci->devfn);
+			devid = PCI_BUS_NUM(xdev->devid) << 8 |
+				PCI_SLOT(xdev->pci->devfn);
+			max_functions =
+				intel_xpcie_get_max_functions(&xdev->xpcie);
+			xdev->sw_devid =
+				intel_xpcie_create_sw_device_id(fn_no,
+								devid,
+								max_functions);
+			dev_info(&xdev->pci->dev,
+				 "sw_devid=%x, fn=%d, max_functions=%d\n",
+				 xdev->sw_devid, fn_no, max_functions);
+			intel_xpcie_set_sw_device_id(&xdev->xpcie,
+						     xdev->sw_devid);
+			intel_xpcie_pci_raise_irq(xdev, PHY_ID_UPDATED, 1);
+		}
+#else
+		xdev->xpcie.status = XPCIE_STATUS_READY;
+		poll_again = false;
 #endif
 	}
-	schedule_delayed_work(&xdev->wait_event, msecs_to_jiffies(2000));
+
+	if (poll_again)
+		schedule_delayed_work(&xdev->wait_event,
+				      msecs_to_jiffies(2000));
 }
 
 static int intel_xpcie_pci_prepare_dev_reset(struct xpcie_dev *xdev,
-- 
2.27.0

