From 509b33ae26aa4ab16ef115b4798666b47fa7a934 Mon Sep 17 00:00:00 2001
From: Ricardo Neri <ricardo.neri-calderon@linux.intel.com>
Date: Mon, 4 Nov 2019 09:09:51 -0800
Subject: [PATCH 24/80] cpufreq: intel_pstate: Use ITMT priority only when HFI
 is not supported

If the Intel Hardware Interface (HFI) is enabled and present, it will be
used to set CPU capacities. This makes HFI incompatible with Intel Turbo
Boost Max Technology 3.0, which sets CPU priorities for asymmetric
packing of tasks.

Furthermore, HFI will update CPU capacity at run time as hinted by the
underlying hardware. Hence, let HFI take precedence.

Cc: Andi Kleen <ak@linux.intel.com>
Cc: Aubrey Li <aubrey.li@intel.com>
Cc: Len Brown <len.brown@intel.com>
Cc: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Cc: Tim Chen <tim.c.chen@linux.intel.com>
Cc: "Ravi V. Shankar" <ravi.v.shankar@intel.com>
Suggested-by: Srinivas Pandruvada <srinivas.pandruvada@intel.com>
Signed-off-by: Ricardo Neri <ricardo.neri-calderon@linux.intel.com>
---
Changes since v4:
  * Reworded commit message for clarity. (Len)
  * Verified that /proc/sys/kernel/sched_itmt_enabled is not created when
    HFI is present. Thus, admins cannot enable it. No change needed. (Tim)

Changes since v3:
  * None

Changes since v2:
  * None

Changes since v1:
  * Introduced this patch.
---
 drivers/cpufreq/intel_pstate.c | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/drivers/cpufreq/intel_pstate.c b/drivers/cpufreq/intel_pstate.c
index 0e69dffd5a76..46008bedd066 100644
--- a/drivers/cpufreq/intel_pstate.c
+++ b/drivers/cpufreq/intel_pstate.c
@@ -336,6 +336,15 @@ static void intel_pstate_set_itmt_prio(int cpu)
 	static u32 max_highest_perf = 0, min_highest_perf = U32_MAX;
 	int ret;
 
+	/*
+	 * If the hardware feedback interface is available, do not set CPU
+	 * priorities for asymmetric packing of tasks.
+	 */
+	if (IS_ENABLED(CONFIG_INTEL_HFI) && boot_cpu_has(X86_FEATURE_INTEL_HFI)) {
+		pr_debug("Hardware Feedback Interface detected, will not configure ITMT\n");
+		return;
+	}
+
 	ret = cppc_get_perf_caps(cpu, &cppc_perf);
 	if (ret)
 		return;
-- 
2.27.0

