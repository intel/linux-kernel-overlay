From 8eba19f46790c10d9b660a75343d85245ba7bfa7 Mon Sep 17 00:00:00 2001
From: "Kirill A. Shutemov" <kirill.shutemov@linux.intel.com>
Date: Fri, 17 Jul 2020 11:12:09 +0300
Subject: [PATCH 47/82] x86/tdx: Implement port I/O filtering

In TDX guest, since host is an untrusted entity, interactions via
IO ports had to be hardened to keep the VM guest secure. So by
default block all IO ports and add support for allowlist of IO
ports that can be used for communication with the host. Only RTC
and PCI ranges are essential.

There are a lot of other IO port interactions that are difficult to
harden. So let's just block them by default to avoid any security
risks from unsafe drivers. Except for the listed blocks a modern
virtualized system shouldn't really need any IO ports.

This is an extra safety net against drivers that don't use the normal
driver registration infrastructure to make sure they cannot be loaded
by a malicious hypervisor.

The filtering is disabled for decompression code. It doesn't have
significant attack surface to care about.

Reviewed-by: Andi Kleen <ak@linux.intel.com>
Signed-off-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
Signed-off-by: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
---
 arch/x86/include/asm/tdx.h   |  1 +
 arch/x86/kernel/tdx-filter.c | 30 ++++++++++++++++++++++++++++++
 arch/x86/kernel/tdx.c        |  8 ++++++++
 3 files changed, 39 insertions(+)

diff --git a/arch/x86/include/asm/tdx.h b/arch/x86/include/asm/tdx.h
index 0dc49d76f633..48927fac9e12 100644
--- a/arch/x86/include/asm/tdx.h
+++ b/arch/x86/include/asm/tdx.h
@@ -87,6 +87,7 @@ int tdg_handle_virtualization_exception(struct pt_regs *regs,
 					struct ve_info *ve);
 
 bool tdg_early_handle_ve(struct pt_regs *regs);
+bool tdg_allowed_port(short int port);
 
 extern phys_addr_t tdg_shared_mask(void);
 
diff --git a/arch/x86/kernel/tdx-filter.c b/arch/x86/kernel/tdx-filter.c
index 218f453e5149..7e18cb61b397 100644
--- a/arch/x86/kernel/tdx-filter.c
+++ b/arch/x86/kernel/tdx-filter.c
@@ -55,6 +55,36 @@ bool tdg_filter_enabled(void)
 	return tdg_filter_status;
 }
 
+bool tdg_allowed_port(short int port)
+{
+	if (tdg_debug_enabled() && tdg_filter_enabled())
+		return true;
+
+	switch (port) {
+	/* MC146818 RTC */
+	case 0x70 ... 0x71:
+	/* PCI */
+	case 0xcf8 ... 0xcff:
+		return true;
+	/* ACPI ports list:
+	 * 0600-0603 : ACPI PM1a_EVT_BLK
+	 * 0604-0605 : ACPI PM1a_CNT_BLK
+	 * 0608-060b : ACPI PM_TMR
+	 * 0620-062f : ACPI GPE0_BLK
+	 */
+	case 0x600 ... 0x62f:
+		return true;
+	/* COM1 */
+	case 0x3f8:
+	case 0x3f9:
+	case 0x3fa:
+	case 0x3fd:
+		return tdg_debug_enabled();
+	default:
+		return false;
+	}
+}
+
 void __init tdg_filter_init(void)
 {
 	int i;
diff --git a/arch/x86/kernel/tdx.c b/arch/x86/kernel/tdx.c
index e89c6a035d4d..6afe629a7cb0 100644
--- a/arch/x86/kernel/tdx.c
+++ b/arch/x86/kernel/tdx.c
@@ -308,6 +308,14 @@ static void tdg_handle_io(struct pt_regs *regs, u32 exit_qual)
 	/* I/O strings ops are unrolled at build time. */
 	BUG_ON(string);
 
+	if (!tdg_allowed_port(port)) {
+		if (!out) {
+			regs->ax &= ~mask;
+			regs->ax |= (UINT_MAX & mask);
+		}
+		return;
+	}
+
 	if (!out) {
 		ret = _trace_tdx_hypercall(EXIT_REASON_IO_INSTRUCTION,
 					   size, out, port, regs->ax,
-- 
2.27.0

