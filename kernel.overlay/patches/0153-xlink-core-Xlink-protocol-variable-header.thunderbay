From 404424fd3b40b106c03af5b5c710ceecdfd848df Mon Sep 17 00:00:00 2001
From: Ravikumar PM <ravikumar.pm@intel.com>
Date: Tue, 9 Feb 2021 17:17:33 +0530
Subject: [PATCH 153/170] xlink-core: Xlink protocol variable header.

Reduce xlink protocol transaction to the header without control data.
When control data is transferred, header + data is transferrd in one
transaction and data is retrieve the data in 2 steps,
first header will be retrived and control data if the packet is control
data.
---
 drivers/misc/xlink-core/xlink-dispatcher.c  | 14 ++++++++++----
 drivers/misc/xlink-core/xlink-multiplexer.c | 15 ++++++++++++++-
 2 files changed, 24 insertions(+), 5 deletions(-)

diff --git a/drivers/misc/xlink-core/xlink-dispatcher.c b/drivers/misc/xlink-core/xlink-dispatcher.c
index bd99efe043f3..65a5e660df53 100644
--- a/drivers/misc/xlink-core/xlink-dispatcher.c
+++ b/drivers/misc/xlink-core/xlink-dispatcher.c
@@ -260,17 +260,23 @@ static int is_valid_event_header(struct xlink_event *event)
 
 static int dispatcher_event_send(struct xlink_event *event)
 {
-	size_t event_header_size = sizeof(event->header);
 	int rc;
+	size_t transfer_size = 0;
+	size_t event_header_size = sizeof(event->header) - XLINK_MAX_CONTROL_DATA_PCIE_SIZE;
 
 	trace_xlink_dispatcher_header(event->handle->sw_device_id,
 				      event->header.chan,
 				      event->header.id,
 				      event_header_size);
+
+	if (event->header.type == XLINK_WRITE_CONTROL_REQ)
+		event_header_size += event->header.size;
+	transfer_size = event_header_size;
+
 	rc = xlink_platform_write(event->interface,
 				  event->handle->sw_device_id, &event->header,
 				  &event_header_size, event->header.timeout, NULL);
-	if (rc || event_header_size != sizeof(event->header)) {
+	if (rc || event_header_size != transfer_size) {
 		pr_err("Write header failed %d\n", rc);
 		return rc;
 	}
@@ -322,12 +328,12 @@ static int xlink_dispatcher_rxthread(void *context)
 	allow_signal(SIGTERM); // allow thread termination while waiting on sem
 	complete(&disp->rx_done);
 	while (!kthread_should_stop()) {
-		size = sizeof(event->header);
+		size = (sizeof(event->header) - XLINK_MAX_CONTROL_DATA_PCIE_SIZE);
 		rc = xlink_platform_read(disp->interface,
 					 disp->handle->sw_device_id,
 					 &event->header, &size,
 					 DISPATCHER_RX_TIMEOUT_MSEC, NULL);
-		if (rc || size != (int)sizeof(event->header))
+		if (rc || size != (int)(sizeof(event->header) - XLINK_MAX_CONTROL_DATA_PCIE_SIZE))
 			continue;
 		if (is_valid_event_header(event)) {
 			event->link_id = disp->link_id;
diff --git a/drivers/misc/xlink-core/xlink-multiplexer.c b/drivers/misc/xlink-core/xlink-multiplexer.c
index de97c580c7aa..4833ba3942df 100644
--- a/drivers/misc/xlink-core/xlink-multiplexer.c
+++ b/drivers/misc/xlink-core/xlink-multiplexer.c
@@ -867,7 +867,20 @@ enum xlink_error xlink_multiplexer_rx(struct xlink_event *event)
 							 XLINK_NORMAL_MEMORY);
 			if (buffer) {
 				size = event->header.size;
-				memcpy(buffer, event->header.control_data, size);
+				rc = xlink_platform_read(event->interface,
+							 event->handle->sw_device_id,
+							 buffer,
+							 &size,
+							 opchan->chan->timeout, NULL);
+				if (rc || event->header.size != size) {
+					xlink_platform_deallocate(xmux->dev, buffer, paddr,
+								  event->header.size, XLINK_PACKET_ALIGNMENT,
+								  XLINK_NORMAL_MEMORY);
+					rc = X_LINK_ERROR;
+					release_channel(opchan);
+					break;
+				}
+
 				event->paddr = paddr;
 				event->data = buffer;
 				if (add_packet_to_channel(opchan,
-- 
2.27.0

