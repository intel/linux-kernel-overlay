From 5184fb2832e9736e042f106ff1ea89ab28f44d77 Mon Sep 17 00:00:00 2001
From: ssanil <shruthi.sanil@intel.com>
Date: Tue, 3 Dec 2019 09:52:39 +0530
Subject: [PATCH 034/223] Fix merge conflict: Enable the general purpose
 timers.

---
 drivers/clocksource/Kconfig            |   7 +
 drivers/clocksource/Makefile           |   2 +
 drivers/clocksource/timer-thunderbay.c | 269 +++++++++++++++++++++++++
 3 files changed, 278 insertions(+)
 create mode 100644 drivers/clocksource/timer-thunderbay.c

diff --git a/drivers/clocksource/Kconfig b/drivers/clocksource/Kconfig
index 39aa21d01e05..30021da95346 100644
--- a/drivers/clocksource/Kconfig
+++ b/drivers/clocksource/Kconfig
@@ -682,6 +682,13 @@ config INGENIC_OST
 	help
 	  Support for the Operating System Timer of the Ingenic JZ SoCs.
 
+config THUNDERBAY_TIMER
+	bool "Intel Thunder Bay timer driver"
+	depends on ARM || ARM64
+	select TIMER_OF if OF
+	help
+	  Enables the support for the Intel Thunder Bay timer driver.
+
 config MICROCHIP_PIT64B
 	bool "Microchip PIT64B support"
 	depends on OF || COMPILE_TEST
diff --git a/drivers/clocksource/Makefile b/drivers/clocksource/Makefile
index c17ee32a7151..6e18ee2cd59a 100644
--- a/drivers/clocksource/Makefile
+++ b/drivers/clocksource/Makefile
@@ -87,4 +87,6 @@ obj-$(CONFIG_CLINT_TIMER)		+= timer-clint.o
 obj-$(CONFIG_CSKY_MP_TIMER)		+= timer-mp-csky.o
 obj-$(CONFIG_GX6605S_TIMER)		+= timer-gx6605s.o
 obj-$(CONFIG_HYPERV_TIMER)		+= hyperv_timer.o
+obj-$(CONFIG_THUNDERBAY_TIMER)		+= timer-thunderbay.o
 obj-$(CONFIG_MICROCHIP_PIT64B)		+= timer-microchip-pit64b.o
+
diff --git a/drivers/clocksource/timer-thunderbay.c b/drivers/clocksource/timer-thunderbay.c
new file mode 100644
index 000000000000..a8ce8a877731
--- /dev/null
+++ b/drivers/clocksource/timer-thunderbay.c
@@ -0,0 +1,269 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Intel Thunder Bay Timer driver
+ *
+ * Copyright (C) 2019 Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2, as published
+ * by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include "timer-of.h"
+
+#define TIM_BASE_ADDRESS		0x88809000
+
+/* Registers offset */
+#define TIM_SCALER_VAL_OFFSET		0x0
+#define TIM_SCALER_RELOAD_OFFSET	0x4
+#define TIM_GEN_CONFIG_OFFSET		0x8
+
+#define TIM_CNT_VAL_OFFSET		0x0
+#define TIM_RELOAD_VAL_OFFSET		0x4
+#define TIM_CONFIG_OFFSET		0x8
+
+#define TIM_FREE_CNT2			0x00e8
+#define TIM_FREE_CNT3			0x00ec
+
+/* Bit fields of TIM_GEN_CONFIG register */
+#define TIM_GEN_CONFIG_PRESCALER_ENABLE	BIT(2)
+#define TIM_GEN_CONFIG_COUNTER_ENABLE	BIT(0)
+
+/* Bit fields of TIM_CONFIG registers */
+#define TIM_CONFIG_FORCED_RELOAD	BIT(5)
+#define TIM_CONFIG_INTERRUPT_PENDING	BIT(4)
+#define TIM_CONFIG_CHAIN		BIT(3)
+#define TIM_CONFIG_INTERRUPT_ENABLE	BIT(2)
+#define TIM_CONFIG_RESTART		BIT(1)
+#define TIM_CONFIG_ENABLE		BIT(0)
+
+static DEFINE_SPINLOCK(thunderbay_clocksource_lock);
+
+static inline void thunderbay_timer_disable(void __iomem *base)
+{
+	writel(0x0, base + TIM_CONFIG_OFFSET);
+}
+
+static inline void thunderbay_timer_enable(void __iomem *base, u32 flags)
+{
+	writel(TIM_CONFIG_ENABLE | flags, base + TIM_CONFIG_OFFSET);
+}
+
+static inline void thunderbay_timer_update_counter(void __iomem *base, u32 val)
+{
+	writel(val, base + TIM_CNT_VAL_OFFSET);
+	writel(val, base + TIM_RELOAD_VAL_OFFSET);
+}
+
+static int thunderbay_timer_set_next_event(unsigned long evt,
+					   struct clock_event_device *ce)
+{
+	struct timer_of *to = to_timer_of(ce);
+	u32 flags = TIM_CONFIG_INTERRUPT_ENABLE;
+
+	/* setup and enable oneshot timer */
+	thunderbay_timer_disable(timer_of_base(to));
+	thunderbay_timer_update_counter(timer_of_base(to), evt);
+	thunderbay_timer_enable(timer_of_base(to), flags);
+
+	return 0;
+}
+
+static int thunderbay_timer_periodic(struct clock_event_device *ce)
+{
+	struct timer_of *to = to_timer_of(ce);
+	u32 flags = TIM_CONFIG_INTERRUPT_ENABLE | TIM_CONFIG_RESTART;
+
+	/* setup and enable periodic timer */
+	thunderbay_timer_disable(timer_of_base(to));
+	thunderbay_timer_update_counter(timer_of_base(to), timer_of_period(to));
+	thunderbay_timer_enable(timer_of_base(to), flags);
+
+	return 0;
+}
+
+static int thunderbay_timer_shutdown(struct clock_event_device *ce)
+{
+	struct timer_of *to = to_timer_of(ce);
+
+	thunderbay_timer_disable(timer_of_base(to));
+
+	return 0;
+}
+
+static irqreturn_t thunderbay_timer_isr(int irq, void *dev_id)
+{
+	struct clock_event_device *evt = (struct clock_event_device *)dev_id;
+	struct timer_of *to = to_timer_of(evt);
+	u32 val;
+
+	/* clear interrupt */
+	val = readl(timer_of_base(to) + TIM_CONFIG_OFFSET);
+	val &= ~TIM_CONFIG_INTERRUPT_PENDING;
+	writel(val, timer_of_base(to) + TIM_CONFIG_OFFSET);
+
+	if (clockevent_state_oneshot(evt))
+		thunderbay_timer_disable(timer_of_base(to));
+
+	if(NULL != evt->event_handler)
+		evt->event_handler(evt);
+
+	return IRQ_HANDLED;
+}
+
+static int __init thunderbay_timer_init(struct device_node *np)
+{
+	int ret;
+	u32 val;
+	void __iomem *reg;
+	u32 flags = TIM_CONFIG_INTERRUPT_ENABLE;
+	struct timer_of *thunderbay_ce_to;
+	static int count = 0;
+	char *timer_name;
+	int timer_size;
+
+	reg = ioremap(TIM_BASE_ADDRESS + TIM_SCALER_VAL_OFFSET, 0xc);
+
+//	/* prescaler must be enabled for the timer to operate */
+//	val = readl(reg - TIM_SCALER_VAL_OFFSET + TIM_GEN_CONFIG_OFFSET);
+//	if (!(val & TIM_GEN_CONFIG_PRESCALER_ENABLE)) {
+//		iounmap(reg);
+//		pr_err("%s: prescaler in not enabled\n", __func__);
+//		return -ENODEV;
+//	}
+
+	thunderbay_ce_to = kzalloc(sizeof(struct timer_of), GFP_KERNEL);
+	if (!thunderbay_ce_to) {
+		pr_err("%s: No free memory\n", __func__);
+		return -ENOMEM;
+	}
+
+	timer_size = 20 * sizeof(char);
+	timer_name = kzalloc(timer_size, GFP_KERNEL);
+	if (!timer_name) {
+		pr_err("%s: No free memory\n", __func__);
+		return -ENOMEM;
+	}
+
+	snprintf(timer_name, timer_size, "thunderbay_timer%d", count+2);
+
+	thunderbay_ce_to->flags = TIMER_OF_IRQ | TIMER_OF_BASE | TIMER_OF_CLOCK;
+	thunderbay_ce_to->clkevt.name = timer_name;
+	thunderbay_ce_to->clkevt.features = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT;
+	thunderbay_ce_to->clkevt.rating = 200;
+	thunderbay_ce_to->clkevt.set_next_event = thunderbay_timer_set_next_event;
+	thunderbay_ce_to->clkevt.set_state_periodic = thunderbay_timer_periodic;
+	thunderbay_ce_to->clkevt.set_state_shutdown = thunderbay_timer_shutdown;
+	thunderbay_ce_to->of_irq.handler = thunderbay_timer_isr;
+	thunderbay_ce_to->of_irq.flags = IRQF_TIMER | IRQF_IRQPOLL;
+
+	ret = timer_of_init(np, thunderbay_ce_to);
+	if (ret)
+	{
+		iounmap(reg);
+		return ret;
+	}
+
+	/*
+	 * Clock input is divided by PRESCALER + 1 before it is fed
+	 * to the counter
+	 */
+	val = readl(reg - TIM_SCALER_VAL_OFFSET + TIM_SCALER_RELOAD_OFFSET);
+	thunderbay_ce_to->of_clk.rate = thunderbay_ce_to->of_clk.rate / (val + 1);
+
+	iounmap(reg);
+
+	thunderbay_timer_disable(timer_of_base(thunderbay_ce_to));
+
+	thunderbay_ce_to->clkevt.cpumask = cpumask_of(0);
+	clockevents_config_and_register(&thunderbay_ce_to->clkevt,
+					timer_of_rate(thunderbay_ce_to),
+					0x1,
+					0xffffffff);
+
+	thunderbay_timer_enable(timer_of_base(thunderbay_ce_to), flags);
+
+	count++;
+
+	return 0;
+}
+
+static struct timer_of thunderbay_cs_to = {
+	.flags = TIMER_OF_BASE | TIMER_OF_CLOCK,
+};
+
+static u64 notrace thunderbay_clocksource_read(struct clocksource *cs)
+{
+	u64 val_hi, val_lo, val_lo1;
+	unsigned long flags;
+
+	spin_lock_irqsave(&thunderbay_clocksource_lock, flags);
+
+	/* read lower 32-bit first, then read upper 32-bit next */
+	val_lo1 = readl(timer_of_base(&thunderbay_cs_to));
+	val_hi = readl(timer_of_base(&thunderbay_cs_to) + 4);
+	val_lo = readl(timer_of_base(&thunderbay_cs_to));
+
+	/* check for rollover, reread upper 32-bit if rollover */
+	if (val_lo < val_lo1)
+		val_hi = readl(timer_of_base(&thunderbay_cs_to) + 4);
+
+	spin_unlock_irqrestore(&thunderbay_clocksource_lock, flags);
+
+	return ((val_hi << 32) | (val_lo & 0xffffffff));
+}
+
+static struct clocksource thunderbay_counter = {
+	.name	= "thunderbay_sys_counter",
+	.rating	= 200,
+	.read	= thunderbay_clocksource_read,
+	.mask	= CLOCKSOURCE_MASK(64),
+	.flags	= CLOCK_SOURCE_IS_CONTINUOUS | CLOCK_SOURCE_SUSPEND_NONSTOP,
+};
+
+static int __init thunderbay_counter_init(struct device_node *np)
+{
+	int ret;
+//	int val;
+//	void __iomem *reg;
+
+//	reg = ioremap(TIM_BASE_ADDRESS + TIM_SCALER_VAL_OFFSET, 0xc);
+//
+//	/* free running counter must be enabled */
+//	val = readl(reg - TIM_SCALER_VAL_OFFSET + TIM_GEN_CONFIG_OFFSET);
+//	if (!(val & TIM_GEN_CONFIG_COUNTER_ENABLE)) {
+//		iounmap(reg);
+//		pr_err("%s: free running counter is not enabled\n", __func__);
+//		return -ENODEV;
+//	}
+//
+//	iounmap(reg);
+
+	ret = timer_of_init(np, &thunderbay_cs_to);
+	if (ret)
+		return ret;
+
+	if (of_device_is_compatible(np, "intel,thunderbay-counter"))
+		thunderbay_counter.name = "thunderbay_sys_counter";
+
+	ret = clocksource_register_hz(&thunderbay_counter,
+					timer_of_rate(&thunderbay_cs_to));
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+TIMER_OF_DECLARE(thumderbay_timer, "intel,thunderbay-timer", thunderbay_timer_init);
+TIMER_OF_DECLARE(thunderbay_sys_counter, "intel,thunderbay-counter", thunderbay_counter_init);
-- 
2.27.0

