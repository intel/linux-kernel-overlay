From fcc5e31709893cb58332ea77c357cba41268fbbb Mon Sep 17 00:00:00 2001
From: Chowdary Deekshith Reddy <chowdary.deekshith.reddy@intel.com>
Date: Fri, 12 Mar 2021 16:24:37 +0530
Subject: [PATCH 219/223] SecureXLink write TAG issue fix

Signed-off-by: Chowdary Deekshith Reddy <chowdary.deekshith.reddy@intel.com>
---
 drivers/misc/xlink-secure/xlink-secure.c | 20 ++++++++++++++------
 1 file changed, 14 insertions(+), 6 deletions(-)

diff --git a/drivers/misc/xlink-secure/xlink-secure.c b/drivers/misc/xlink-secure/xlink-secure.c
index 8452627aec9c..b939c3d77085 100644
--- a/drivers/misc/xlink-secure/xlink-secure.c
+++ b/drivers/misc/xlink-secure/xlink-secure.c
@@ -100,6 +100,7 @@ struct seqno_chan {
 	struct   iv_format     *r_gcm_iv;
 	struct   iv_format     *w_gcm_iv;
 	u8 *cipher_data;
+	u8 *wr_gcm_tag;
 	u32 cipher_data_size;
 	u32 xlink_read;
 };
@@ -205,6 +206,12 @@ static struct seqno_chan *seqno_list_create_add_node(u32 chan_no,
 	node->cipher_data = NULL;
 	node->cipher_data_size = 0;
 	node->xlink_read = 0;
+	node->wr_gcm_tag = kmalloc(AES_GCM_TAGLEN, GFP_KERNEL);
+	if (node->wr_gcm_tag == NULL) {
+		XLINK_SECURE_ERR("wr_gcm_tag kzalloc fail\n");
+		return NULL;
+	}
+
 	node->r_aead_req = kzalloc(reqsize, GFP_KERNEL);
 	if (!node->r_aead_req) {
 		XLINK_SECURE_ERR("read aead_req kzalloc fail\n");
@@ -259,6 +266,7 @@ static void  seqno_list_delete_node(struct xlnk_sec_handle *sec_handler, struct
 	kfree_sensitive(node->w_aead_req);
 	kfree(node->r_gcm_iv);
 	kfree(node->w_gcm_iv);
+	kfree(node->wr_gcm_tag);
 	kfree(node);
 }
 
@@ -1065,7 +1073,6 @@ enum xlink_error xlink_secure_write_data(struct xlink_handle *handle,
 	struct seqno_chan *node;
 	struct xlink_handle local_handle;
 	struct xlnk_sec_handle *sec_handler;
-	u8 *gcm_tag;
 	struct dma_buf *dmabuf = NULL;
 	phys_addr_t phys_addr;
 
@@ -1159,9 +1166,6 @@ enum xlink_error xlink_secure_write_data(struct xlink_handle *handle,
 	else
 		gcm_aad = (struct aad_format *)data_frame;
 
-	//Initialize TAG pointer
-	gcm_tag = data_frame + sizeof(struct header) + sizeof(frame.sequence) + size;
-
 	//construct secure xlink header
 	data_header.msg_type = ARM_SECURE;
 	data_header.ver_maj = 1;
@@ -1175,6 +1179,8 @@ enum xlink_error xlink_secure_write_data(struct xlink_handle *handle,
 	//construct IV
 	node->w_gcm_iv->counter = local_seq;
 
+	memset(node->wr_gcm_tag, 0, AES_GCM_TAGLEN);
+
 	if (handle->dev_type == VPUIP_DEVICE) {
 		data_out_paddr = dma_map_single(&xlink->pdev->dev, data_out_frame,
 						frame_len, DMA_BIDIRECTIONAL);
@@ -1193,7 +1199,7 @@ enum xlink_error xlink_secure_write_data(struct xlink_handle *handle,
 						(phys_addr),
 						(data_out_frame + METADATA_SIZE),
 						(data_out_paddr + METADATA_SIZE),
-						size, gcm_tag))) {
+						size, node->wr_gcm_tag))) {
 			XLINK_SECURE_ERR("xlink_aead_encrypt error on chan = %d\n", chan);
 			rc = X_LINK_ERROR;
 			goto sec_cleanup;
@@ -1204,6 +1210,7 @@ enum xlink_error xlink_secure_write_data(struct xlink_handle *handle,
 		//Copy header and seqno to data_frame.
 		memcpy(data_out_frame, &data_header, sizeof(struct header));
 		memcpy(data_out_frame + sizeof(struct header), &local_seq, sizeof(frame.sequence));
+		memcpy(data_out_frame + sizeof(struct header) + sizeof(frame.sequence) + size, node->wr_gcm_tag, AES_GCM_TAGLEN);
 		if (frame_len > (512 - 28))
 			rc = xlink_write_data(&local_handle, chan, data_out_frame, frame_len);
 		else
@@ -1230,7 +1237,7 @@ enum xlink_error xlink_secure_write_data(struct xlink_handle *handle,
 						(data_paddr + METADATA_SIZE),
 						(data_frame + METADATA_SIZE),
 						(data_paddr + METADATA_SIZE),
-						size, gcm_tag))) {
+						size, node->wr_gcm_tag))) {
 			XLINK_SECURE_ERR("xlink_aead_encrypt error on chan = %d\n", chan);
 			rc = X_LINK_ERROR;
 			goto sec_cleanup;
@@ -1241,6 +1248,7 @@ enum xlink_error xlink_secure_write_data(struct xlink_handle *handle,
 		//Copy header and seqno to data_frame.
 		memcpy(data_frame, &data_header, sizeof(struct header));
 		memcpy(data_frame + sizeof(struct header), &local_seq, sizeof(frame.sequence));
+		memcpy(data_frame + sizeof(struct header) + sizeof(frame.sequence) + size, node->wr_gcm_tag, AES_GCM_TAGLEN);
 		if (frame_len > (512 - 28))
 			rc = xlink_write_data(&local_handle, chan, data_frame, frame_len);
 		else
-- 
2.27.0

