From 0d6b8f7fa1f2d65826ce06135c5951e668fe867e Mon Sep 17 00:00:00 2001
From: Rajmohan Mani <rajmohan.mani@intel.com>
Date: Fri, 22 Jan 2021 18:36:49 +0200
Subject: [PATCH 25/28] WIP: thunderbolt: Retimer NDA NVM upgrade

Work in progress, not ready for upstreaming.

Not-signed-off-by: Rajmohan Mani <rajmohan.mani@intel.com>
Not-Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
---
 drivers/thunderbolt/acpi.c    | 185 +++++++++++++++++++++++++++++++++
 drivers/thunderbolt/domain.c  |  33 +++++-
 drivers/thunderbolt/retimer.c | 187 +++++++++++++++++++++++++++++-----
 drivers/thunderbolt/sb_regs.h |   2 +
 drivers/thunderbolt/tb.c      |  31 ++++--
 drivers/thunderbolt/tb.h      |  20 +++-
 drivers/thunderbolt/usb4.c    |  66 ++++++++++++
 7 files changed, 488 insertions(+), 36 deletions(-)

diff --git a/drivers/thunderbolt/acpi.c b/drivers/thunderbolt/acpi.c
index 35fa17f7e599..617245fdbc52 100644
--- a/drivers/thunderbolt/acpi.c
+++ b/drivers/thunderbolt/acpi.c
@@ -180,3 +180,188 @@ bool tb_acpi_is_xdomain_allowed(void)
 		return osc_sb_native_usb4_control & OSC_USB_XDOMAIN;
 	return true;
 }
+
+static struct acpi_device *tb_acpi_find_port(struct acpi_device *adev,
+					     const struct tb_port *port)
+{
+	struct acpi_device *port_adev;
+
+	if (!adev)
+		return NULL;
+
+	/*
+	 * Device routers exists under the downstream facing USB4 port
+	 * of the parent router. Their _ADR is always 0.
+	 */
+	list_for_each_entry(port_adev, &adev->children, node) {
+		if (acpi_device_adr(port_adev) == port->port)
+			return port_adev;
+	}
+
+	return NULL;
+}
+
+static bool tb_acpi_bus_match(struct device *dev)
+{
+	return tb_is_switch(dev);
+}
+
+static struct acpi_device *tb_acpi_find_companion(struct device *dev)
+{
+	struct tb_switch *sw = tb_to_switch(dev);
+	struct tb_switch *parent_sw = tb_switch_parent(sw);
+	struct acpi_device *adev = NULL, *port_adev;
+
+	/*
+	 * The Thunderbolt/USB4 hierarchy looks like following:
+	 *
+	 * Device (NHI)
+	 *   Device (HR)		// Host router _ADR = 0
+	 *      Device (DFP0)		// Downstream port _ADR == lane 0 adapter
+	 *        Device (DR)		// Device router _ADR == 0
+	 *          Device (UFP)	// Upstream port _ADR == lane 0 adapter
+	 *            Device (RT)	// On-board retimer
+	 *        Device (RT)		// Retimer _ADR >= 1 (router facing index always)
+	 *      Device (DFP1)		// Downstream port _ADR == lane 0 adapter number
+	 *
+	 * At the moment we bind the host router to the corresponding
+	 * Linux device.
+	 */
+	if (!parent_sw) {
+		struct tb_nhi *nhi = sw->tb->nhi;
+		struct acpi_device *parent_adev;
+
+		parent_adev = ACPI_COMPANION(&nhi->pdev->dev);
+		if (parent_adev)
+			adev = acpi_find_child_device(parent_adev, 0, false);
+	} else {
+		struct tb_port *port = tb_port_at(tb_route(sw), parent_sw);
+
+		port_adev = tb_acpi_find_port(ACPI_COMPANION(&parent_sw->dev), port);
+		if (port_adev)
+			adev = acpi_find_child_device(port_adev, 0, false);
+	}
+
+	return adev;
+}
+
+static struct acpi_bus_type tb_acpi_bus = {
+	.name = "thunderbolt",
+	.match = tb_acpi_bus_match,
+	.find_companion = tb_acpi_find_companion,
+};
+
+int tb_acpi_init(void)
+{
+	return register_acpi_bus_type(&tb_acpi_bus);
+}
+
+void tb_acpi_exit(void)
+{
+	unregister_acpi_bus_type(&tb_acpi_bus);
+}
+
+/* UUID for retimer _DSM: e0053122-795b-4122-8a5e-57be1d26acb3 */
+static const guid_t retimer_dsm_guid =
+	GUID_INIT(0xe0053122, 0x795b, 0x4122,
+		  0x8a, 0x5e, 0x57, 0xbe, 0x1d, 0x26, 0xac, 0xb3);
+
+#define RETIMER_DSM_QUERY_ONLINE_STATE	1
+#define RETIMER_DSM_SET_ONLINE_STATE	2
+
+static int tb_acpi_retimer_set_power(struct tb_port *port, bool power)
+{
+	union acpi_object argv4[2];
+	struct acpi_device *adev;
+	union acpi_object *obj;
+	int ret;
+
+	adev = tb_acpi_find_port(ACPI_COMPANION(&port->sw->dev), port);
+	if (!adev)
+		return -EOPNOTSUPP;
+
+	if (!acpi_check_dsm(adev->handle, &retimer_dsm_guid, 1,
+			    BIT(RETIMER_DSM_QUERY_ONLINE_STATE) |
+			    BIT(RETIMER_DSM_SET_ONLINE_STATE)))
+		return -EOPNOTSUPP;
+
+	/* Check if we are already powered on (and in correct mode) */
+	obj = acpi_evaluate_dsm_typed(adev->handle, &retimer_dsm_guid, 1,
+				      RETIMER_DSM_QUERY_ONLINE_STATE, NULL,
+				      ACPI_TYPE_INTEGER);
+	if (!obj) {
+		tb_port_warn(port, "ACPI: query online _DSM failed\n");
+		return -EIO;
+	}
+
+	ret = obj->integer.value;
+	ACPI_FREE(obj);
+
+	if (power == ret)
+		return 0;
+
+	tb_port_dbg(port, "ACPI: calling _DSM to power %s retimers\n",
+		    power ? "on" : "off");
+
+	argv4[0].type = ACPI_TYPE_PACKAGE;
+	argv4[0].package.count = 1;
+	argv4[0].package.elements = &argv4[1];
+	argv4[1].integer.type = ACPI_TYPE_INTEGER;
+	argv4[1].integer.value = power;
+
+	obj = acpi_evaluate_dsm_typed(adev->handle, &retimer_dsm_guid, 1,
+				      RETIMER_DSM_SET_ONLINE_STATE, argv4,
+				      ACPI_TYPE_INTEGER);
+	if (!obj) {
+		tb_port_warn(port,
+			     "ACPI: set online state _DSM evaluation failed\n");
+		return -EIO;
+	}
+
+	ret = obj->integer.value;
+	ACPI_FREE(obj);
+
+	if (ret >= 0) {
+		if (power)
+			return ret == 1 ? 0 : -EBUSY;
+		return 0;
+	}
+
+	tb_port_warn(port, "ACPI: set online state _DSM failed with error\n");
+	return -EIO;
+}
+
+/**
+ * tb_acpi_power_on_retimers() - Call platform to power on retimers
+ * @port: USB4 port
+ *
+ * Calls platform to turn on power to all retimers behind this USB4
+ * port. After this function returns successfully the caller can
+ * continue with the normal retimer flows (as specified in the USB4
+ * spec). Note if this returns %-EBUSY it means the type-C port is in
+ * non-USB4/TBT mode (there is non-USB4/TBT device connected).
+ *
+ * This should only be called if the USB4/TBT link is not up.
+ *
+ * If the operation is not supported by the platform returns
+ * %-EOPNOTSUPP. Returns %0 on success.
+ */
+int tb_acpi_power_on_retimers(struct tb_port *port)
+{
+	return tb_acpi_retimer_set_power(port, true);
+}
+
+/**
+ * tb_acpi_power_off_retimers() - Call platform to power off retimers
+ * @port: USB4 port
+ *
+ * This is the opposite of tb_acpi_power_on_retimers(). After returning
+ * successfully the normal operations with the @port can continue.
+ *
+ * If the operation is not supported by the platform returns
+ * %-EOPNOTSUPP. Returns %0 on success.
+ */
+int tb_acpi_power_off_retimers(struct tb_port *port)
+{
+	return tb_acpi_retimer_set_power(port, false);
+}
diff --git a/drivers/thunderbolt/domain.c b/drivers/thunderbolt/domain.c
index 3a1fb7a39f90..072623e56179 100644
--- a/drivers/thunderbolt/domain.c
+++ b/drivers/thunderbolt/domain.c
@@ -885,16 +885,41 @@ int tb_domain_disconnect_all_paths(struct tb *tb)
 	return bus_for_each_dev(&tb_bus_type, NULL, tb, disconnect_xdomain);
 }
 
+/**
+ * tb_domain_queue_hotplug() - Queue hotplug event for the domain
+ * @tb: Domain pointer
+ * @port: Port subject to the hotplug event
+ * @unplug: Plug or unplug event
+ *
+ * This function can be called to generate a hotplug event for the
+ * domain from software. If the connection manager implementation does
+ * not support this, return %-EOPNOTSUPP.
+ */
+int tb_domain_queue_hotplug(struct tb *tb, struct tb_port *port, bool unplug)
+{
+	struct tb_switch *sw;
+
+	if (!tb->cm_ops->queue_hotplug)
+		return -EOPNOTSUPP;
+
+	sw = tb_switch_get(port->sw);
+	tb->cm_ops->queue_hotplug(tb, port, unplug);
+	tb_switch_put(sw);
+
+	return 0;
+}
+
 int tb_domain_init(void)
 {
 	int ret;
 
 	tb_test_init();
-
 	tb_debugfs_init();
+	tb_acpi_init();
+
 	ret = tb_xdomain_init();
 	if (ret)
-		goto err_debugfs;
+		goto err_acpi;
 	ret = bus_register(&tb_bus_type);
 	if (ret)
 		goto err_xdomain;
@@ -903,7 +928,8 @@ int tb_domain_init(void)
 
 err_xdomain:
 	tb_xdomain_exit();
-err_debugfs:
+err_acpi:
+	tb_acpi_exit();
 	tb_debugfs_exit();
 	tb_test_exit();
 
@@ -916,6 +942,7 @@ void tb_domain_exit(void)
 	ida_destroy(&tb_domain_ida);
 	tb_nvm_exit();
 	tb_xdomain_exit();
+	tb_acpi_exit();
 	tb_debugfs_exit();
 	tb_test_exit();
 }
diff --git a/drivers/thunderbolt/retimer.c b/drivers/thunderbolt/retimer.c
index c44fad2b9fbb..d598e6673cdc 100644
--- a/drivers/thunderbolt/retimer.c
+++ b/drivers/thunderbolt/retimer.c
@@ -172,6 +172,34 @@ static ssize_t nvm_authenticate_show(struct device *dev,
 	return ret;
 }
 
+static int nvm_authenticate(struct tb_retimer *rt)
+{
+	struct tb_port *port = rt->port;
+	int ret;
+
+	ret = usb4_port_retimer_nvm_authenticate(port, rt->index);
+	if (ret)
+		return ret;
+
+	/*
+	 * If we are updating NVM when the USB4 link is not up (e.g
+	 * nothing connected to the Type-C port), there will be no
+	 * hot-remove event. Instead we remove retimers manually, and
+	 * schedule re-scan.
+	 */
+	if (!rt->online) {
+		/*
+		 * For offline update need to block everything here
+		 * until the NVM update time has elapsed.
+		 */
+		msleep(6000);
+		tb_retimer_remove_all(port);
+		tb_domain_queue_hotplug(port->sw->tb, port, true);
+	}
+
+	return 0;
+}
+
 static ssize_t nvm_authenticate_store(struct device *dev,
 	struct device_attribute *attr, const char *buf, size_t count)
 {
@@ -208,7 +236,7 @@ static ssize_t nvm_authenticate_store(struct device *dev,
 		if (ret)
 			goto exit_unlock;
 
-		ret = usb4_port_retimer_nvm_authenticate(rt->port, rt->index);
+		ret = nvm_authenticate(rt);
 	}
 
 exit_unlock:
@@ -275,13 +303,71 @@ static void tb_retimer_release(struct device *dev)
 	kfree(rt);
 }
 
+static int tb_retimer_runtime_suspend(struct device *dev)
+{
+	struct tb_retimer *rt = tb_to_retimer(dev);
+
+	mutex_lock(&rt->tb->lock);
+	/*
+	 * If there is no USB4 link but the platform supports powering
+	 * on-board retimers then we turn off that power now. But only
+	 * when we are runtime suspending the closest retimer.
+	 */
+	if (!rt->online && rt->index == 1)
+		tb_acpi_power_off_retimers(rt->port);
+
+	mutex_unlock(&rt->tb->lock);
+	return 0;
+}
+
+static int tb_retimer_runtime_resume(struct device *dev)
+{
+	struct tb_retimer *rt = tb_to_retimer(dev);
+	int ret = 0;
+
+	mutex_lock(&rt->tb->lock);
+	/*
+	 * Re-enable communications with the retimer if the platform
+	 * supports powering on-board retimers and there is no active
+	 * USB4 link.
+	 */
+	if (!rt->online) {
+		struct tb_port *port = rt->port;
+
+		if (rt->index == 1) {
+			ret = tb_acpi_power_on_retimers(port);
+			if (ret)
+				goto out_unlock;
+			ret = usb4_port_enumerate_retimers(port);
+			if (ret) {
+				tb_acpi_power_off_retimers(port);
+				goto out_unlock;
+			}
+		}
+
+		/* Enable sideband channel for this retimer */
+		usb4_port_retimer_set_inbound_sbtx(port, rt->index);
+	}
+
+out_unlock:
+	mutex_unlock(&rt->tb->lock);
+	return 0;
+}
+
+static const struct dev_pm_ops tb_retimer_pm_ops = {
+	SET_RUNTIME_PM_OPS(tb_retimer_runtime_suspend,
+			   tb_retimer_runtime_resume, NULL)
+};
+
 struct device_type tb_retimer_type = {
 	.name = "thunderbolt_retimer",
 	.groups = retimer_groups,
 	.release = tb_retimer_release,
+	.pm = &tb_retimer_pm_ops,
 };
 
-static int tb_retimer_add(struct tb_port *port, u8 index, u32 auth_status)
+static int tb_retimer_add(struct tb_port *port, u8 index, u32 auth_status,
+			  bool online)
 {
 	struct tb_retimer *rt;
 	u32 vendor, device;
@@ -328,6 +414,7 @@ static int tb_retimer_add(struct tb_port *port, u8 index, u32 auth_status)
 	rt->vendor = vendor;
 	rt->device = device;
 	rt->auth_status = auth_status;
+	rt->online = online;
 	rt->port = port;
 	rt->tb = port->sw->tb;
 
@@ -354,12 +441,12 @@ static int tb_retimer_add(struct tb_port *port, u8 index, u32 auth_status)
 	dev_info(&rt->dev, "new retimer found, vendor=%#x device=%#x\n",
 		 rt->vendor, rt->device);
 
-	pm_runtime_no_callbacks(&rt->dev);
 	pm_runtime_set_active(&rt->dev);
-	pm_runtime_enable(&rt->dev);
 	pm_runtime_set_autosuspend_delay(&rt->dev, TB_AUTOSUSPEND_DELAY);
-	pm_runtime_mark_last_busy(&rt->dev);
 	pm_runtime_use_autosuspend(&rt->dev);
+	pm_runtime_mark_last_busy(&rt->dev);
+	pm_runtime_enable(&rt->dev);
+	pm_request_autosuspend(&rt->dev);
 
 	return 0;
 }
@@ -396,29 +483,17 @@ static struct tb_retimer *tb_port_find_retimer(struct tb_port *port, u8 index)
 	return NULL;
 }
 
-/**
- * tb_retimer_scan() - Scan for on-board retimers under port
- * @port: USB4 port to scan
- *
- * Tries to enumerate on-board retimers connected to @port. Found
- * retimers are registered as children of @port. Does not scan for cable
- * retimers for now.
- */
-int tb_retimer_scan(struct tb_port *port)
+static int scan_retimers(struct tb_port *port, bool online)
 {
 	u32 status[TB_MAX_RETIMER_INDEX + 1] = {};
 	int ret, i, last_idx = 0;
 
-	if (!port->cap_usb4)
-		return 0;
-
 	/*
-	 * Send broadcast RT to make sure retimer indices facing this
-	 * port are set.
+	 * Enable sideband channel for each retimer. We can do this
+	 * regardless whether there is device connected or not.
 	 */
-	ret = usb4_port_enumerate_retimers(port);
-	if (ret)
-		return ret;
+	for (i = 1; i <= TB_MAX_RETIMER_INDEX; i++)
+		usb4_port_retimer_set_inbound_sbtx(port, i);
 
 	/*
 	 * Before doing anything else, read the authentication status.
@@ -450,15 +525,77 @@ int tb_retimer_scan(struct tb_port *port)
 
 		rt = tb_port_find_retimer(port, i);
 		if (rt) {
+			if (rt->online != online) {
+				rt->online = online;
+				kobject_uevent(&rt->dev.kobj, KOBJ_CHANGE);
+			}
 			put_device(&rt->dev);
 		} else {
-			ret = tb_retimer_add(port, i, status[i]);
+			ret = tb_retimer_add(port, i, status[i], online);
 			if (ret && ret != -EOPNOTSUPP)
-				return ret;
+				break;
 		}
 	}
 
-	return 0;
+	return ret;
+}
+
+/**
+ * tb_retimer_scan() - Scan for on-board retimers under port
+ * @port: USB4 port to scan
+ * @online: Is the USB4 link up
+ *
+ * Tries to enumerate on-board retimers connected to @port. Found
+ * retimers are registered as children of @port. Does not scan for cable
+ * retimers for now. If @online is not set then the function tries to
+ * call platform to bring the sideband up and if that succeeds scans the
+ * retimers accordingly.
+ */
+int tb_retimer_scan(struct tb_port *port, bool online)
+{
+	int ret;
+
+	if (!port->cap_usb4)
+		return 0;
+
+	if (!online) {
+		ret = tb_acpi_power_on_retimers(port);
+		switch (ret) {
+		case -EBUSY:
+			return 0;
+
+		case -EOPNOTSUPP:
+			break;
+
+		case 0:
+			ret = usb4_port_router_offline(port);
+			if (ret)
+				goto out_power_off;
+			break;
+
+		default:
+			return ret;
+		}
+	}
+
+	/*
+	 * Send broadcast RT to make sure retimer indices facing this
+	 * port are set.
+	 */
+	ret = usb4_port_enumerate_retimers(port);
+	if (ret)
+		goto out_online;
+
+	ret = scan_retimers(port, online);
+
+out_online:
+	if (!online)
+		usb4_port_router_online(port);
+out_power_off:
+	if (!online)
+		tb_acpi_power_off_retimers(port);
+
+	return ret;
 }
 
 static int remove_retimer(struct device *dev, void *data)
diff --git a/drivers/thunderbolt/sb_regs.h b/drivers/thunderbolt/sb_regs.h
index 9dafd696612f..bda889ff3bda 100644
--- a/drivers/thunderbolt/sb_regs.h
+++ b/drivers/thunderbolt/sb_regs.h
@@ -17,7 +17,9 @@
 enum usb4_sb_opcode {
 	USB4_SB_OPCODE_ERR = 0x20525245,			/* "ERR " */
 	USB4_SB_OPCODE_ONS = 0x444d4321,			/* "!CMD" */
+	USB4_SB_OPCODE_ROUTER_OFFLINE = 0x4e45534c,		/* "LSEN" */
 	USB4_SB_OPCODE_ENUMERATE_RETIMERS = 0x4d554e45,		/* "ENUM" */
+	USB4_SB_OPCODE_SET_INBOUND_SBTX = 0x5055534c,		/* "LSUP" */
 	USB4_SB_OPCODE_QUERY_LAST_RETIMER = 0x5453414c,		/* "LAST" */
 	USB4_SB_OPCODE_GET_NVM_SECTOR_SIZE = 0x53534e47,	/* "GNSS" */
 	USB4_SB_OPCODE_NVM_SET_OFFSET = 0x53504f42,		/* "BOPS" */
diff --git a/drivers/thunderbolt/tb.c b/drivers/thunderbolt/tb.c
index 32b79dce134f..b89d5296bb53 100644
--- a/drivers/thunderbolt/tb.c
+++ b/drivers/thunderbolt/tb.c
@@ -50,7 +50,7 @@ struct tb_hotplug_event {
 
 static void tb_handle_hotplug(struct work_struct *work);
 
-static void tb_queue_hotplug(struct tb *tb, u64 route, u8 port, bool unplug)
+static void __tb_queue_hotplug(struct tb *tb, u64 route, u8 port, bool unplug)
 {
 	struct tb_hotplug_event *ev;
 
@@ -604,8 +604,8 @@ static void tb_scan_port(struct tb_port *port)
 	if (tb_port_is_dpout(port) && tb_dp_port_hpd_is_active(port) == 1 &&
 	    !tb_dp_port_is_enabled(port)) {
 		tb_port_dbg(port, "DP adapter HPD set, queuing hotplug\n");
-		tb_queue_hotplug(port->sw->tb, tb_route(port->sw), port->port,
-				 false);
+		__tb_queue_hotplug(port->sw->tb, tb_route(port->sw), port->port,
+				   false);
 		return;
 	}
 
@@ -616,14 +616,23 @@ static void tb_scan_port(struct tb_port *port)
 			 * Downstream switch is reachable through two ports.
 			 * Only scan on the primary port (link_nr == 0).
 			 */
-	if (tb_wait_for_port(port, false) <= 0)
+
+	if (tb_wait_for_port(port, false) <= 0) {
+		/*
+		 * Scan for retimers even if the USB4 link did not come
+		 * up. It is possible that the platform supports
+		 * powering on-board retimers even if there is nothing
+		 * attached to the port.
+		 */
+		tb_retimer_scan(port, false);
 		return;
+	}
 	if (port->remote) {
 		tb_port_dbg(port, "port already has a remote\n");
 		return;
 	}
 
-	tb_retimer_scan(port);
+	tb_retimer_scan(port, true);
 
 	sw = tb_switch_alloc(port->sw->tb, &port->sw->dev,
 			     tb_downstream_route(port));
@@ -690,7 +699,7 @@ static void tb_scan_port(struct tb_port *port)
 		tb_sw_warn(sw, "failed to enable TMU\n");
 
 	/* Scan upstream retimers */
-	tb_retimer_scan(upstream_port);
+	tb_retimer_scan(upstream_port, true);
 
 	/*
 	 * Create USB 3.x tunnels only when the switch is plugged to the
@@ -1312,7 +1321,14 @@ static void tb_handle_event(struct tb *tb, enum tb_cfg_pkg_type type,
 			pkg->port);
 	}
 
-	tb_queue_hotplug(tb, route, pkg->port, pkg->unplug);
+	__tb_queue_hotplug(tb, route, pkg->port, pkg->unplug);
+}
+
+static void tb_queue_hotplug(struct tb *tb, struct tb_port *port, bool unplug)
+{
+	struct tb_switch *sw = port->sw;
+
+	__tb_queue_hotplug(tb, tb_route(sw), port->port, unplug);
 }
 
 static void tb_stop(struct tb *tb)
@@ -1595,6 +1611,7 @@ static const struct tb_cm_ops tb_cm_ops = {
 	.approve_switch = tb_tunnel_pci,
 	.approve_xdomain_paths = tb_approve_xdomain_paths,
 	.disconnect_xdomain_paths = tb_disconnect_xdomain_paths,
+	.queue_hotplug = tb_queue_hotplug,
 };
 
 struct tb *tb_probe(struct tb_nhi *nhi)
diff --git a/drivers/thunderbolt/tb.h b/drivers/thunderbolt/tb.h
index 06c131a80ab6..a790bb84b9a8 100644
--- a/drivers/thunderbolt/tb.h
+++ b/drivers/thunderbolt/tb.h
@@ -235,6 +235,7 @@ struct tb_port {
  * @port: Pointer to the lane 0 adapter
  * @nvm: Pointer to the NVM if the retimer has one (%NULL otherwise)
  * @auth_status: Status of last NVM authentication
+ * @online: Is the USB4 link up
  */
 struct tb_retimer {
 	struct device dev;
@@ -245,6 +246,7 @@ struct tb_retimer {
 	struct tb_port *port;
 	struct tb_nvm *nvm;
 	u32 auth_status;
+	bool online;
 };
 
 /**
@@ -386,6 +388,7 @@ struct tb_path {
  *					 implementation can be used to
  *					 return status of USB4 NVM_AUTH
  *					 router operation.
+ * @queue_hotplug: Queue hotplug event
  */
 struct tb_cm_ops {
 	int (*driver_ready)(struct tb *tb);
@@ -422,6 +425,7 @@ struct tb_cm_ops {
 			      void *rx_data, size_t rx_data_len);
 	int (*usb4_switch_nvm_authenticate_status)(struct tb_switch *sw,
 						   u32 *status);
+	void (*queue_hotplug)(struct tb *tb, struct tb_port *port, bool unplug);
 };
 
 static inline void *tb_priv(struct tb *tb)
@@ -657,6 +661,7 @@ int tb_domain_disconnect_xdomain_paths(struct tb *tb, struct tb_xdomain *xd,
 				       int transmit_path, int transmit_ring,
 				       int receive_path, int receive_ring);
 int tb_domain_disconnect_all_paths(struct tb *tb);
+int tb_domain_queue_hotplug(struct tb *tb, struct tb_port *port, bool unplug);
 
 static inline struct tb *tb_domain_get(struct tb *tb)
 {
@@ -981,7 +986,7 @@ void tb_xdomain_remove(struct tb_xdomain *xd);
 struct tb_xdomain *tb_xdomain_find_by_link_depth(struct tb *tb, u8 link,
 						 u8 depth);
 
-int tb_retimer_scan(struct tb_port *port);
+int tb_retimer_scan(struct tb_port *port, bool online);
 void tb_retimer_remove_all(struct tb_port *port);
 
 static inline bool tb_is_retimer(const struct device *dev)
@@ -1023,8 +1028,11 @@ int usb4_port_configure(struct tb_port *port);
 void usb4_port_unconfigure(struct tb_port *port);
 int usb4_port_configure_xdomain(struct tb_port *port);
 void usb4_port_unconfigure_xdomain(struct tb_port *port);
+int usb4_port_router_online(struct tb_port *port);
+int usb4_port_router_offline(struct tb_port *port);
 int usb4_port_enumerate_retimers(struct tb_port *port);
 
+int usb4_port_retimer_set_inbound_sbtx(struct tb_port *port, u8 index);
 int usb4_port_retimer_read(struct tb_port *port, u8 index, u8 reg, void *buf,
 			   u8 size);
 int usb4_port_retimer_write(struct tb_port *port, u8 index, u8 reg,
@@ -1062,6 +1070,11 @@ bool tb_acpi_may_tunnel_usb3(void);
 bool tb_acpi_may_tunnel_dp(void);
 bool tb_acpi_may_tunnel_pcie(void);
 bool tb_acpi_is_xdomain_allowed(void);
+
+int tb_acpi_init(void);
+void tb_acpi_exit(void);
+int tb_acpi_power_on_retimers(struct tb_port *port);
+int tb_acpi_power_off_retimers(struct tb_port *port);
 #else
 static inline void tb_acpi_add_links(struct tb_nhi *nhi) { }
 
@@ -1070,6 +1083,11 @@ static inline bool tb_acpi_may_tunnel_usb3(void) { return true; }
 static inline bool tb_acpi_may_tunnel_dp(void) { return true; }
 static inline bool tb_acpi_may_tunnel_pcie(void) { return true; }
 static inline bool tb_acpi_is_xdomain_allowed(void) { return true; }
+
+static inline int tb_acpi_init(void) { return 0; }
+static inline void tb_acpi_exit(void) { }
+static inline int tb_acpi_power_on_retimers(struct tb_port *port) { return -EOPNOTSUPP; }
+static inline int tb_acpi_power_off_retimers(struct tb_port *port) { return -EOPNOTSUPP; }
 #endif
 
 #ifdef CONFIG_DEBUG_FS
diff --git a/drivers/thunderbolt/usb4.c b/drivers/thunderbolt/usb4.c
index 0b44e54b814c..a9b275a25dcc 100644
--- a/drivers/thunderbolt/usb4.c
+++ b/drivers/thunderbolt/usb4.c
@@ -1182,6 +1182,46 @@ static int usb4_port_sb_op(struct tb_port *port, enum usb4_sb_target target,
 	return -ETIMEDOUT;
 }
 
+static int usb4_port_set_router_offline(struct tb_port *port, bool offline)
+{
+	u32 val = offline;
+	int ret;
+
+	ret = usb4_port_sb_write(port, USB4_SB_TARGET_ROUTER, 0,
+				  USB4_SB_METADATA, &val, sizeof(val));
+	if (ret)
+		return ret;
+
+	val = USB4_SB_OPCODE_ROUTER_OFFLINE;
+	return usb4_port_sb_write(port, USB4_SB_TARGET_ROUTER, 0,
+				  USB4_SB_OPCODE, &val, sizeof(val));
+}
+
+/**
+ * usb4_port_router_online() - Put the port into online mode
+ * @port: USB4 port
+ *
+ * Reverse of usb4_port_router_offline(). After this is successfully called
+ * the @port starts reacting to hotplug events again.
+ */
+int usb4_port_router_online(struct tb_port *port)
+{
+	/* Passing true means exit offline mode. Go figure. */
+	return usb4_port_set_router_offline(port, true);
+}
+
+/**
+ * usb4_port_router_offline() - Put the port into offline mode
+ * @port: USB4 port
+ *
+ * Puts the @port into offline mode so it does not react to hotplug events.
+ * Used with retimer access if there is nothing connected to the port.
+ */
+int usb4_port_router_offline(struct tb_port *port)
+{
+	return usb4_port_set_router_offline(port, false);
+}
+
 /**
  * usb4_port_enumerate_retimers() - Send RT broadcast transaction
  * @port: USB4 port
@@ -1207,6 +1247,32 @@ static inline int usb4_port_retimer_op(struct tb_port *port, u8 index,
 			       timeout_msec);
 }
 
+/**
+ * usb4_port_retimer_set_inbound_sbtx() - Enable sideband channel transactions
+ * @port: USB4 port
+ * @index: Retimer index
+ *
+ * Enables sideband channel transations on SBTX. Can be used when USB4
+ * link does not go up, for example if there is no device connected.
+ */
+int usb4_port_retimer_set_inbound_sbtx(struct tb_port *port, u8 index)
+{
+	int ret;
+
+	ret = usb4_port_retimer_op(port, index, USB4_SB_OPCODE_SET_INBOUND_SBTX,
+				   500);
+	/*
+	 * Per the USB4 retimer spec, the retimer is not required to
+	 * send an RT (Retimer Transaction) response for the first
+	 * SET_INBOUND_SBTX command
+	 */
+	if (ret == -ENODEV)
+		return usb4_port_retimer_op(port, index,
+					    USB4_SB_OPCODE_SET_INBOUND_SBTX,
+					    500);
+	return ret;
+}
+
 /**
  * usb4_port_retimer_read() - Read from retimer sideband registers
  * @port: USB4 port
-- 
2.27.0

