From 870cfef4238fcc463f6cea00e5b53652315d4e85 Mon Sep 17 00:00:00 2001
From: ssanil <shruthi.sanil@intel.com>
Date: Thu, 30 Apr 2020 11:37:40 +0530
Subject: [PATCH 001/223] Thunderbay Reset Driver

---
 drivers/reset/Kconfig                         |   7 +
 drivers/reset/Makefile                        |   1 +
 drivers/reset/reset-thunderbay.c              | 155 ++++++++++++++++++
 .../reset/intel,thunderbay-reset.h            |  89 ++++++++++
 include/linux/reset/reset-thunderbay-ss.h     | 126 ++++++++++++++
 include/linux/reset/reset-thunderbay.h        |  30 ++++
 6 files changed, 408 insertions(+)
 create mode 100644 drivers/reset/reset-thunderbay.c
 create mode 100644 include/dt-bindings/reset/intel,thunderbay-reset.h
 create mode 100644 include/linux/reset/reset-thunderbay-ss.h
 create mode 100644 include/linux/reset/reset-thunderbay.h

diff --git a/drivers/reset/Kconfig b/drivers/reset/Kconfig
index 4171c6f76385..0af7d693054e 100644
--- a/drivers/reset/Kconfig
+++ b/drivers/reset/Kconfig
@@ -219,6 +219,13 @@ config RESET_SUNXI
 	help
 	  This enables the reset driver for Allwinner SoCs.
 
+config RESET_THUNDERBAY
+	tristate "Intel Thunder Bay SoC reset driver"
+	depends on OF
+	help
+	  Say Y here to include support for reset driver
+	  in Intel Thunder Bay SoC.
+
 config RESET_TI_SCI
 	tristate "TI System Control Interface (TI-SCI) reset driver"
 	depends on TI_SCI_PROTOCOL
diff --git a/drivers/reset/Makefile b/drivers/reset/Makefile
index 65a118a91b27..bf8df45ea535 100644
--- a/drivers/reset/Makefile
+++ b/drivers/reset/Makefile
@@ -29,6 +29,7 @@ obj-$(CONFIG_RESET_SIMPLE) += reset-simple.o
 obj-$(CONFIG_RESET_STM32MP157) += reset-stm32mp1.o
 obj-$(CONFIG_RESET_SOCFPGA) += reset-socfpga.o
 obj-$(CONFIG_RESET_SUNXI) += reset-sunxi.o
+obj-$(CONFIG_RESET_THUNDERBAY) += reset-thunderbay.o
 obj-$(CONFIG_RESET_TI_SCI) += reset-ti-sci.o
 obj-$(CONFIG_RESET_TI_SYSCON) += reset-ti-syscon.o
 obj-$(CONFIG_RESET_UNIPHIER) += reset-uniphier.o
diff --git a/drivers/reset/reset-thunderbay.c b/drivers/reset/reset-thunderbay.c
new file mode 100644
index 000000000000..45d224d72a54
--- /dev/null
+++ b/drivers/reset/reset-thunderbay.c
@@ -0,0 +1,155 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Reset driver for Intel Thunder Bay Harbor.
+ *
+ * Copyright (C) 2020 Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2, as published
+ * by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.Â See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+ 
+#include <linux/platform_device.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/io.h>
+#include <linux/reset-controller.h>
+#include <linux/reset/reset-thunderbay.h>
+
+#define get_thunderbay_reset_data(x)  container_of(x, struct thunderbay_rst, rcdev)
+
+struct thunderbay_rst {
+	struct reset_controller_dev rcdev;
+	struct device *dev;
+	void __iomem *reg_base;
+	const struct thunderbay_rst_data *rst_data;
+};
+
+static int thunderbay_control_assert(struct reset_controller_dev *rcdev,
+				     unsigned long id)
+{
+	struct thunderbay_rst *data = get_thunderbay_reset_data(rcdev);
+	const struct thunderbay_rst_map *mmap = &data->rst_data->resets[id];
+
+	writel(1<<mmap->bit, data->reg_base + mmap->reg + THUNDERBAY_RESET_CLEAR_OFFSET);
+
+	return 0;
+}
+
+static int thunderbay_control_deassert(struct reset_controller_dev *rcdev,
+				       unsigned long id)
+{
+	struct thunderbay_rst *data = get_thunderbay_reset_data(rcdev);
+	const struct thunderbay_rst_map *mmap = &data->rst_data->resets[id];
+
+	writel(1<<mmap->bit, data->reg_base + mmap->reg + THUNDERBAY_RESET_SET_OFFSET);
+
+	return 0;
+}
+/*
+static int thunderbay_control_status(struct reset_controller_dev *rcdev,
+				       unsigned long id)
+{
+	struct thunderbay_rst *data = get_thunderbay_reset_data(rcdev);
+	const struct thunderbay_rst_map *mmap = &data->rst_data->resets[id];
+
+	return readl(data->reg_base + mmap->reg + THUNDERBAY_RESET_EN_OFFSET);
+}
+*/
+static const struct reset_control_ops thunderbay_rst_ops = {
+	.assert = thunderbay_control_assert,
+	.deassert = thunderbay_control_deassert,
+//	.status = thunderbay_control_status,
+};
+
+int thunderbay_rst_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct thunderbay_rst *rst;
+	const struct thunderbay_rst_data *data;
+	int ret = 0;
+
+	rst = devm_kzalloc(dev, sizeof(*rst), GFP_KERNEL);
+	if (!rst) {
+		dev_err(dev, "Failed to allocate memory.\n");
+		return -ENOMEM;
+	}
+
+	rst->reg_base = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(rst->reg_base)){
+		dev_err(dev, "Failed to remap resource.\n");
+		return PTR_ERR(rst->reg_base);
+	}
+
+	data = of_device_get_match_data(dev);
+	if (!data){
+		dev_err(dev, "Failed to get data.\n");
+		return -EINVAL;
+	}
+
+	rst->rcdev.owner = THIS_MODULE;
+	rst->rcdev.ops = &thunderbay_rst_ops;
+	rst->rcdev.of_node = dev->of_node;
+	rst->rcdev.nr_resets = data->n_resets;
+	rst->dev = dev;
+	rst->rst_data = data;
+
+	dev_info(dev, "No of resets %d\n", rst->rcdev.nr_resets);
+	ret = devm_reset_controller_register(dev, &rst->rcdev);
+	if (ret) {
+		dev_err(dev, "Failed to register reset device.\n");
+		return ret;
+	}
+
+	dev_info(dev, "Reset Driver registered successfully");
+
+	return 0;
+}
+
+static const struct of_device_id thunderbay_rst_match[] = {
+	{
+		.compatible = "intel,thunderbay-pss-rst1",
+		.data = &thunderbay_pss_reset_data1,
+	},
+	{
+		.compatible = "intel,thunderbay-pss-rst2",
+		.data = &thunderbay_pss_reset_data2,
+	},
+	{
+		.compatible = "intel,thunderbay-pcie-rst",
+		.data = &thunderbay_pcie_reset_data,
+	},
+	{
+		.compatible = "intel,thunderbay-comss-rst",
+		.data = &thunderbay_comss_reset_data,
+	},
+	{
+		.compatible = "intel,thunderbay-memss-rst",
+		.data = &thunderbay_memss_reset_data,
+	},
+	{ },
+};
+
+MODULE_DEVICE_TABLE(of, thunderbay_rst_match);
+
+static struct platform_driver thunderbay_reset_driver = {
+	.probe	= thunderbay_rst_probe,
+	.driver	= {
+		  .name		  = "thunderbay_reset",
+		  .of_match_table = thunderbay_rst_match,
+	},
+};
+
+module_platform_driver(thunderbay_reset_driver);
+
+MODULE_DESCRIPTION("Intel Thunderbay Reset Driver");
+MODULE_AUTHOR("Shruthi Sanil <shruthi.sanil@intel.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/include/dt-bindings/reset/intel,thunderbay-reset.h b/include/dt-bindings/reset/intel,thunderbay-reset.h
new file mode 100644
index 000000000000..6fce6b2dc59b
--- /dev/null
+++ b/include/dt-bindings/reset/intel,thunderbay-reset.h
@@ -0,0 +1,89 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2020 Intel Corporation
+ */
+
+/* PSS reset ID's */
+#define TBH_PSS_EFUSE_PRSTN             1
+#define TBH_PSS_GPIO_RST_N              2
+#define TBH_PSS_I2C_INST_0_RST_N        3
+#define TBH_PSS_I2C_INST_1_RST_N        4
+#define TBH_PSS_I2C_INST_2_RST_N        5
+#define TBH_PSS_I2C_INST_3_RST_N        6
+#define TBH_PSS_I2C_INST_4_RST_N        7
+#define TBH_PSS_UART_INST_0_RST_N       8
+#define TBH_PSS_UART_INST_1_RST_N       9
+#define TBH_PSS_EMMC_RST_N             10
+
+#define TBH_PSS_SSI_INST_0_RST_N        1
+#define TBH_PSS_SSI_INST_1_RST_N        2
+#define TBH_PSS_SMBUS_RST_N             3
+#define TBH_PSS_DMAC_INST_0_RST_N       4
+#define TBH_PSS_TRNG_RST_N              5
+#define TBH_PSS_ETHERNET_INST_0_RST_N   6
+#define TBH_PSS_ETHERNET_INST_1_RST_N   7
+#define TBH_PSS_DMAC_SECURE_RST_N       8
+
+/* PCIe reset ID's */
+#define TBH_PCIE_CTRL1_RST      1
+#define TBH_PCIE_CTRL0_RST      2
+#define TBH_PCIE_PHY_RST        3
+#define TBH_PCIE_SUBSYSTEM_RST  4
+#define TBH_PCIE_POWER_ON_RST   5
+
+/* COMSS reset ID's */
+#define TBH_COMSS_VPU_VPU_RESET_N           1
+#define TBH_COMSS_OCS_OCS_RESET_N           2
+#define TBH_COMSS_MEDIA_VCEJ_CORERST_N  3
+#define TBH_COMSS_MEDIA_VCEJ_ARESET_N   4
+#define TBH_COMSS_MEDIA_VCEJ_PRESET_N   5
+#define TBH_COMSS_MEDIA_VCE_CORERST_N   6
+#define TBH_COMSS_MEDIA_VCE_ARESET_N    7
+#define TBH_COMSS_MEDIA_VCE_PRESET_N    8
+#define TBH_COMSS_MEDIA_VCDA_CORERST_N  9
+#define TBH_COMSS_MEDIA_VCDA_ARESET_N   10
+#define TBH_COMSS_MEDIA_VCDA_PRESET_N   11
+#define TBH_COMSS_MEDIA_VCDB_CORERST_N  12
+#define TBH_COMSS_MEDIA_VCDB_ARESET_N   13
+#define TBH_COMSS_MEDIA_VCDB_PRESET_N   14
+#define TBH_COMSS_MEDIA_TBU0_ARESET_N   15
+#define TBH_COMSS_MEDIA_TBU1_ARESET_N   16
+#define TBH_COMSS_MEDIA_TBU2_ARESET_N   17
+#define TBH_COMSS_MEDIA_TBU3_ARESET_N   18
+#define TBH_COMSS_MEDIA_TBU4_ARESET_N   19
+#define TBH_COMSS_MEDIA_TCU_ARESET_N    20
+#define TBH_COMSS_MEDIA_DTI_ARESET_N    21
+#define TBH_COMSS_MEDIA_PVT_ARESET_N    22
+#define TBH_COMSS_MEDIA_PVT_PRESET_N    23
+
+/* MEMSS reset ID's */
+# define TBH_MEMSS_MC_MC_U1_CORE_DDRC_RSTN            1
+# define TBH_MEMSS_MC_MC_U2_CORE_DDRC_RSTN            2
+# define TBH_MEMSS_MC_MC_U1_SBR_RESETN                3
+# define TBH_MEMSS_MC_MC_U2_SBR_RESETN                4
+# define TBH_MEMSS_MC_MC_U1_ARESETN_0                 5
+# define TBH_MEMSS_MC_MC_U2_ARESETN_0                 6
+# define TBH_MEMSS_MC_MC_U1_PRESETN                   7
+# define TBH_MEMSS_MC_MC_U2_PRESETN                   8
+# define TBH_MEMSS_MC_MC_U1_SCAN_RESETN               9
+# define TBH_MEMSS_MC_MC_U2_SCAN_RESETN               10
+# define TBH_MEMSS_MC_PHY_U1_PRESETN_APB              11
+# define TBH_MEMSS_MC_PHY_U1_PWROKIN                  12
+# define TBH_MEMSS_MC_PHY_U1_RESET                    13
+# define TBH_MEMSS_MC_PHY_U1_WRSTN                    14
+# define TBH_MEMSS_MC_DDRSS_APB_REGS_U1_I_PRESETN     15
+# define TBH_MEMSS_MC_DDRSS_APB_REGS_U1_I_RSTN        16
+# define TBH_MEMSS_MC_MC_COUNTER_TOP_U1_I_MCA_RSTN    17
+# define TBH_MEMSS_MC_MC_COUNTER_TOP_U1_I_MCB_RSTN    18
+# define TBH_MEMSS_MC_DDRSS_GLUE_U1_I_MCA_RSTN        19
+# define TBH_MEMSS_MC_DDRSS_GLUE_U1_I_MCB_RSTN        20
+# define TBH_MEMSS_PHY_PHY_U1_PRESETN_APB             21
+# define TBH_MEMSS_PHY_PHY_U1_PWROKIN                 22
+# define TBH_MEMSS_PHY_PHY_U1_RESET                   23
+# define TBH_MEMSS_PHY_PHY_U1_WRSTN                   24
+# define TBH_MEMSS_MISC_DDRSS_APB_REGS_U1_I_PRESETN   25
+# define TBH_MEMSS_MISC_DDRSS_APB_REGS_U1_I_RSTN      26
+# define TBH_MEMSS_MISC_MC_COUNTER_TOP_U1_I_MCA_RSTN  27
+# define TBH_MEMSS_MISC_MC_COUNTER_TOP_U1_I_MCB_RSTN  28
+# define TBH_MEMSS_MISC_DDRSS_GLUE_U1_I_MCA_RSTN      29
+# define TBH_MEMSS_MISC_DDRSS_GLUE_U1_I_MCB_RSTN      30
diff --git a/include/linux/reset/reset-thunderbay-ss.h b/include/linux/reset/reset-thunderbay-ss.h
new file mode 100644
index 000000000000..f707b8fc3666
--- /dev/null
+++ b/include/linux/reset/reset-thunderbay-ss.h
@@ -0,0 +1,126 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2020 Intel Corporation
+ */
+
+#include <dt-bindings/reset/intel,thunderbay-reset.h>
+
+/* PSS reset data */
+static const struct thunderbay_rst_map thunderbay_pss_resets1[] = {
+	[TBH_PSS_EFUSE_PRSTN] = THUNDERBAY_RESET(0x0000, 0),
+	[TBH_PSS_GPIO_RST_N] = THUNDERBAY_RESET(0x1000, 0),
+	[TBH_PSS_I2C_INST_0_RST_N] = THUNDERBAY_RESET(0x9000, 0),
+	[TBH_PSS_I2C_INST_1_RST_N] = THUNDERBAY_RESET(0xA000, 0),
+	[TBH_PSS_I2C_INST_2_RST_N] = THUNDERBAY_RESET(0xB000, 0),
+	[TBH_PSS_I2C_INST_3_RST_N] = THUNDERBAY_RESET(0xC000, 0),
+	[TBH_PSS_I2C_INST_4_RST_N] = THUNDERBAY_RESET(0xD000, 0),
+	[TBH_PSS_UART_INST_0_RST_N] = THUNDERBAY_RESET(0xD000, 0),
+	[TBH_PSS_UART_INST_1_RST_N] = THUNDERBAY_RESET(0xE000, 0),
+	[TBH_PSS_EMMC_RST_N] = THUNDERBAY_RESET(0x10000, 0),
+};
+
+static const struct thunderbay_rst_data thunderbay_pss_reset_data1 = {
+	.resets = thunderbay_pss_resets1,
+	.n_resets = ARRAY_SIZE(thunderbay_pss_resets1),
+};
+
+static const struct thunderbay_rst_map thunderbay_pss_resets2[] = {
+	[TBH_PSS_SSI_INST_0_RST_N] = THUNDERBAY_RESET(0x0, 0),
+	[TBH_PSS_SSI_INST_1_RST_N] = THUNDERBAY_RESET(0x1000, 0),
+	[TBH_PSS_SMBUS_RST_N] = THUNDERBAY_RESET(0x2000, 0),
+	[TBH_PSS_DMAC_INST_0_RST_N] = THUNDERBAY_RESET(0x3000, 0),
+	[TBH_PSS_TRNG_RST_N] = THUNDERBAY_RESET(0x4000, 0),
+	[TBH_PSS_ETHERNET_INST_0_RST_N] = THUNDERBAY_RESET(0x5000, 0),
+	[TBH_PSS_ETHERNET_INST_1_RST_N] = THUNDERBAY_RESET(0x6000, 0),
+	[TBH_PSS_DMAC_SECURE_RST_N] = THUNDERBAY_RESET(0x9000, 0),
+};
+
+static const struct thunderbay_rst_data thunderbay_pss_reset_data2 = {
+	.resets = thunderbay_pss_resets2,
+	.n_resets = ARRAY_SIZE(thunderbay_pss_resets2),
+};
+
+/* PCIe reset data */
+static const struct thunderbay_rst_map thunderbay_pcie_resets[] = {
+	[TBH_PCIE_POWER_ON_RST] = THUNDERBAY_RESET(0x0, 0),
+	[TBH_PCIE_SUBSYSTEM_RST] = THUNDERBAY_RESET(0x0, 1),
+	[TBH_PCIE_PHY_RST] = THUNDERBAY_RESET(0x0, 2),
+	[TBH_PCIE_CTRL0_RST] = THUNDERBAY_RESET(0x0, 3),
+	[TBH_PCIE_CTRL1_RST] = THUNDERBAY_RESET(0x0, 4),
+};
+
+static const struct thunderbay_rst_data thunderbay_pcie_reset_data = {
+	.resets = thunderbay_pcie_resets,
+	.n_resets = ARRAY_SIZE(thunderbay_pcie_resets),
+};
+
+/* COMSS reset data */
+static const struct thunderbay_rst_map thunderbay_comss_resets[] = {
+	[TBH_COMSS_VPU_VPU_RESET_N] = THUNDERBAY_RESET(0x00, 0),
+	[TBH_COMSS_OCS_OCS_RESET_N] = THUNDERBAY_RESET(0x100, 0),
+	[TBH_COMSS_MEDIA_VCEJ_CORERST_N] = THUNDERBAY_RESET(0X1000, 0),
+	[TBH_COMSS_MEDIA_VCEJ_ARESET_N] = THUNDERBAY_RESET(0X1000, 1),
+	[TBH_COMSS_MEDIA_VCEJ_PRESET_N] = THUNDERBAY_RESET(0X1000, 2),
+	[TBH_COMSS_MEDIA_VCE_CORERST_N] = THUNDERBAY_RESET(0X1000, 3),
+	[TBH_COMSS_MEDIA_VCE_ARESET_N] = THUNDERBAY_RESET(0X1000, 4),
+	[TBH_COMSS_MEDIA_VCE_PRESET_N] = THUNDERBAY_RESET(0X1000, 5),
+	[TBH_COMSS_MEDIA_VCDA_CORERST_N] = THUNDERBAY_RESET(0X1000, 6),
+	[TBH_COMSS_MEDIA_VCDA_ARESET_N] = THUNDERBAY_RESET(0X1000, 7),
+	[TBH_COMSS_MEDIA_VCDA_PRESET_N] = THUNDERBAY_RESET(0X1000, 8),
+	[TBH_COMSS_MEDIA_VCDB_CORERST_N] = THUNDERBAY_RESET(0X1000, 9),
+	[TBH_COMSS_MEDIA_VCDB_ARESET_N] = THUNDERBAY_RESET(0X1000, 10),
+	[TBH_COMSS_MEDIA_VCDB_PRESET_N] = THUNDERBAY_RESET(0X1000, 11),
+	[TBH_COMSS_MEDIA_TBU0_ARESET_N] = THUNDERBAY_RESET(0X1000, 12),
+	[TBH_COMSS_MEDIA_TBU1_ARESET_N] = THUNDERBAY_RESET(0X1000, 13),
+	[TBH_COMSS_MEDIA_TBU2_ARESET_N] = THUNDERBAY_RESET(0X1000, 14),
+	[TBH_COMSS_MEDIA_TBU3_ARESET_N] = THUNDERBAY_RESET(0X1000, 15),
+	[TBH_COMSS_MEDIA_TBU4_ARESET_N] = THUNDERBAY_RESET(0X1000, 16),
+	[TBH_COMSS_MEDIA_TCU_ARESET_N] = THUNDERBAY_RESET(0X1000, 17),
+	[TBH_COMSS_MEDIA_DTI_ARESET_N] = THUNDERBAY_RESET(0X1000, 18),
+	[TBH_COMSS_MEDIA_PVT_ARESET_N] = THUNDERBAY_RESET(0X1000, 19),
+	[TBH_COMSS_MEDIA_PVT_PRESET_N] = THUNDERBAY_RESET(0X1000, 20),
+};
+
+static const struct thunderbay_rst_data thunderbay_comss_reset_data = {
+	.resets = thunderbay_comss_resets,
+	.n_resets = ARRAY_SIZE(thunderbay_comss_resets),
+};
+
+/* MEMSS reset data */
+static const struct thunderbay_rst_map thunderbay_memss_resets[] = {
+	[TBH_MEMSS_MC_MC_U1_CORE_DDRC_RSTN] = THUNDERBAY_RESET(0x0, 0),
+	[TBH_MEMSS_MC_MC_U2_CORE_DDRC_RSTN] = THUNDERBAY_RESET(0x0, 1),
+	[TBH_MEMSS_MC_MC_U1_SBR_RESETN] = THUNDERBAY_RESET(0x0, 2),
+	[TBH_MEMSS_MC_MC_U2_SBR_RESETN] = THUNDERBAY_RESET(0x0, 3),
+	[TBH_MEMSS_MC_MC_U1_ARESETN_0] = THUNDERBAY_RESET(0x0, 4),
+	[TBH_MEMSS_MC_MC_U2_ARESETN_0] = THUNDERBAY_RESET(0x0, 5),
+	[TBH_MEMSS_MC_MC_U1_PRESETN] = THUNDERBAY_RESET(0x0, 6),
+	[TBH_MEMSS_MC_MC_U2_PRESETN] = THUNDERBAY_RESET(0x0, 7),
+	[TBH_MEMSS_MC_MC_U1_SCAN_RESETN] = THUNDERBAY_RESET(0x0, 8),
+	[TBH_MEMSS_MC_MC_U2_SCAN_RESETN] = THUNDERBAY_RESET(0x0, 9),
+	[TBH_MEMSS_MC_PHY_U1_PRESETN_APB] = THUNDERBAY_RESET(0x0, 10),
+	[TBH_MEMSS_MC_PHY_U1_PWROKIN] = THUNDERBAY_RESET(0x0, 11),
+	[TBH_MEMSS_MC_PHY_U1_RESET] = THUNDERBAY_RESET(0x0, 12),
+	[TBH_MEMSS_MC_PHY_U1_WRSTN] = THUNDERBAY_RESET(0x0, 13),
+	[TBH_MEMSS_MC_DDRSS_APB_REGS_U1_I_PRESETN] = THUNDERBAY_RESET(0x0, 14),
+	[TBH_MEMSS_MC_DDRSS_APB_REGS_U1_I_RSTN] = THUNDERBAY_RESET(0x0, 15),
+	[TBH_MEMSS_MC_MC_COUNTER_TOP_U1_I_MCA_RSTN] = THUNDERBAY_RESET(0x0, 16),
+	[TBH_MEMSS_MC_MC_COUNTER_TOP_U1_I_MCB_RSTN] = THUNDERBAY_RESET(0x0, 17),
+	[TBH_MEMSS_MC_DDRSS_GLUE_U1_I_MCA_RSTN] = THUNDERBAY_RESET(0x0, 18),
+	[TBH_MEMSS_MC_DDRSS_GLUE_U1_I_MCB_RSTN] = THUNDERBAY_RESET(0x0, 19),
+	[TBH_MEMSS_PHY_PHY_U1_PRESETN_APB] = THUNDERBAY_RESET(0x10, 0),
+	[TBH_MEMSS_PHY_PHY_U1_PWROKIN] = THUNDERBAY_RESET(0x10, 1),
+	[TBH_MEMSS_PHY_PHY_U1_RESET] = THUNDERBAY_RESET(0x10, 2),
+	[TBH_MEMSS_PHY_PHY_U1_WRSTN] = THUNDERBAY_RESET(0x10, 3),
+	[TBH_MEMSS_MISC_DDRSS_APB_REGS_U1_I_PRESETN] = THUNDERBAY_RESET(0x20, 0),
+	[TBH_MEMSS_MISC_DDRSS_APB_REGS_U1_I_RSTN] = THUNDERBAY_RESET(0x20, 1),
+	[TBH_MEMSS_MISC_MC_COUNTER_TOP_U1_I_MCA_RSTN] = THUNDERBAY_RESET(0x20, 2),
+	[TBH_MEMSS_MISC_MC_COUNTER_TOP_U1_I_MCB_RSTN] = THUNDERBAY_RESET(0x20, 3),
+	[TBH_MEMSS_MISC_DDRSS_GLUE_U1_I_MCA_RSTN] = THUNDERBAY_RESET(0x20, 4),
+	[TBH_MEMSS_MISC_DDRSS_GLUE_U1_I_MCB_RSTN] = THUNDERBAY_RESET(0x20, 5),
+};
+
+static const struct thunderbay_rst_data thunderbay_memss_reset_data = {
+	.resets = thunderbay_memss_resets,
+	.n_resets = ARRAY_SIZE(thunderbay_memss_resets),
+};
diff --git a/include/linux/reset/reset-thunderbay.h b/include/linux/reset/reset-thunderbay.h
new file mode 100644
index 000000000000..32673f040ef8
--- /dev/null
+++ b/include/linux/reset/reset-thunderbay.h
@@ -0,0 +1,30 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2020 Intel Corporation
+ */
+
+#ifndef _LINUX_RESET_THUNDERBAY_H_
+#define _LINUX_RESET_THUNDERBAY_H_
+
+#define THUNDERBAY_RESET_EN_OFFSET     0x0
+#define THUNDERBAY_RESET_SET_OFFSET    0x4  //deassert
+#define THUNDERBAY_RESET_CLEAR_OFFSET  0x8  //assert
+
+#define THUNDERBAY_RESET(_reg, _bit)	\
+	{				\
+		.reg = (_reg),		\
+		.bit = (_bit),		\
+	}
+
+struct thunderbay_rst_map {
+	unsigned int reg;
+	unsigned int bit;
+};
+
+struct thunderbay_rst_data {
+	const struct thunderbay_rst_map *resets;
+	size_t n_resets;
+};
+
+#include <linux/reset/reset-thunderbay-ss.h>
+#endif
\ No newline at end of file
-- 
2.27.0

