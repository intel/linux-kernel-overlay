From 71d97590b4fb440899fd1d601f60e75d0dba58a9 Mon Sep 17 00:00:00 2001
From: Kyung Min Park <kyung.min.park@intel.com>
Date: Thu, 14 Jan 2021 10:31:12 -0800
Subject: [PATCH 24/63] iommu/vt-d: Dump DMAR translation structure for boot
 time debug

When the dmar translation fault happens, it prints a single line fault
reason with corresponding hexadecimal code defined in the Intel VT-d
specification.

Currently, when user wants to debug the translation fault, debugfs is used
for dumping the dmar_translation_struct, which is not available when the
kernel failed to boot.

Add an option to dump the DMAR translation structure and print the
corresponding page level when the kernel fails to boot.

Signed-off-by: Kyung Min Park <kyung.min.park@intel.com>
---
 .../admin-guide/kernel-parameters.txt         |  4 +
 drivers/iommu/intel/debugfs.c                 | 80 +++++++++++++++----
 drivers/iommu/intel/dmar.c                    |  9 ++-
 drivers/iommu/intel/iommu.c                   | 16 ++++
 include/linux/intel-iommu.h                   |  5 +-
 5 files changed, 96 insertions(+), 18 deletions(-)

diff --git a/Documentation/admin-guide/kernel-parameters.txt b/Documentation/admin-guide/kernel-parameters.txt
index 04545725f187..45c6276a6ad3 100644
--- a/Documentation/admin-guide/kernel-parameters.txt
+++ b/Documentation/admin-guide/kernel-parameters.txt
@@ -1898,6 +1898,10 @@
 			Note that using this option lowers the security
 			provided by tboot because it makes the system
 			vulnerable to DMA attacks.
+		boot_debug [Default off]
+			Prints additional DMA remapping table information in dmesg
+			to help debug during boot when debugfs is not available.
+			This option is dependent on the IOMMU debugfs being enabled.
 
 	intel_idle.max_cstate=	[KNL,HW,ACPI,X86]
 			0	disables intel_idle and fall back on acpi_idle.
diff --git a/drivers/iommu/intel/debugfs.c b/drivers/iommu/intel/debugfs.c
index efea7f02abd9..865238f1a0b9 100644
--- a/drivers/iommu/intel/debugfs.c
+++ b/drivers/iommu/intel/debugfs.c
@@ -153,15 +153,16 @@ static int iommu_regset_show(struct seq_file *m, void *unused)
 }
 DEFINE_SHOW_ATTRIBUTE(iommu_regset);
 
-static inline void print_tbl_walk(struct seq_file *m)
+static void dmar_dump_seq_print(struct seq_file *m, struct tbl_walk *tbl_wlk, bool to_dmesg)
 {
-	struct tbl_walk *tbl_wlk = m->private;
+	char bdf_buf[256], pasid_buf[256];
 
-	seq_printf(m, "%02x:%02x.%x\t0x%016llx:0x%016llx\t0x%016llx:0x%016llx\t",
-		   tbl_wlk->bus, PCI_SLOT(tbl_wlk->devfn),
-		   PCI_FUNC(tbl_wlk->devfn), tbl_wlk->rt_entry->hi,
-		   tbl_wlk->rt_entry->lo, tbl_wlk->ctx_entry->hi,
-		   tbl_wlk->ctx_entry->lo);
+	snprintf(bdf_buf, sizeof(bdf_buf),
+		 "%02x:%02x.%x\t0x%016llx:0x%016llx\t0x%016llx:0x%016llx\t",
+		 tbl_wlk->bus, PCI_SLOT(tbl_wlk->devfn),
+		 PCI_FUNC(tbl_wlk->devfn), tbl_wlk->rt_entry->hi,
+		 tbl_wlk->rt_entry->lo, tbl_wlk->ctx_entry->hi,
+		 tbl_wlk->ctx_entry->lo);
 
 	/*
 	 * A legacy mode DMAR doesn't support PASID, hence default it to -1
@@ -169,13 +170,30 @@ static inline void print_tbl_walk(struct seq_file *m)
 	 * to 0.
 	 */
 	if (!tbl_wlk->pasid_tbl_entry)
-		seq_printf(m, "%-6d\t0x%016llx:0x%016llx:0x%016llx\n", -1,
-			   (u64)0, (u64)0, (u64)0);
+		snprintf(pasid_buf, sizeof(pasid_buf), "%-6d\t0x%016llx:0x%016llx:0x%016llx\n", -1,
+			 (u64)0, (u64)0, (u64)0);
 	else
-		seq_printf(m, "%-6d\t0x%016llx:0x%016llx:0x%016llx\n",
-			   tbl_wlk->pasid, tbl_wlk->pasid_tbl_entry->val[2],
-			   tbl_wlk->pasid_tbl_entry->val[1],
-			   tbl_wlk->pasid_tbl_entry->val[0]);
+		snprintf(pasid_buf, sizeof(pasid_buf), "%-6d\t0x%016llx:0x%016llx:0x%016llx\n",
+			 tbl_wlk->pasid, tbl_wlk->pasid_tbl_entry->val[2],
+			 tbl_wlk->pasid_tbl_entry->val[1],
+			 tbl_wlk->pasid_tbl_entry->val[0]);
+
+	if (!to_dmesg) {
+		seq_printf(m, "%s", bdf_buf);
+		seq_printf(m, "%s", pasid_buf);
+	} else {
+		pr_info("%s", bdf_buf);
+		pr_info("%s", pasid_buf);
+	}
+}
+
+static inline void print_tbl_walk(struct seq_file *m, struct tbl_walk *boot_tbl_wlk, bool to_dmesg)
+{
+	if (!to_dmesg)
+		dmar_dump_seq_print(m, m->private, to_dmesg);
+
+	else
+		dmar_dump_seq_print(NULL, boot_tbl_wlk, to_dmesg);
 }
 
 static void pasid_tbl_walk(struct seq_file *m, struct pasid_entry *tbl_entry,
@@ -188,7 +206,7 @@ static void pasid_tbl_walk(struct seq_file *m, struct pasid_entry *tbl_entry,
 		if (pasid_pte_is_present(tbl_entry)) {
 			tbl_wlk->pasid_tbl_entry = tbl_entry;
 			tbl_wlk->pasid = (dir_idx << PASID_PDE_SHIFT) + tbl_idx;
-			print_tbl_walk(m);
+			print_tbl_walk(m, NULL, false);
 		}
 
 		tbl_entry++;
@@ -253,7 +271,7 @@ static void ctx_tbl_walk(struct seq_file *m, struct intel_iommu *iommu, u16 bus)
 			continue;
 		}
 
-		print_tbl_walk(m);
+		print_tbl_walk(m, NULL, false);
 	}
 }
 
@@ -338,6 +356,38 @@ static void pgtable_walk_level(struct seq_file *m, struct dma_pte *pde,
 	}
 }
 
+void dmar_translation_walk(struct intel_iommu *iommu, u8 bus, u16 devfn)
+{
+	struct pasid_dir_entry *dir_entry;
+	struct pasid_entry *pasid_tbl;
+	struct context_entry *context;
+	struct tbl_walk tbl_wlk = {0};
+	struct dmar_domain *domain;
+	unsigned long flags;
+	u64 path[6] = { 0 };
+
+	spin_lock_irqsave(&iommu->lock, flags);
+	context = iommu_context_addr(iommu, bus, devfn, 0);
+	dir_entry = phys_to_virt(context->lo & VTD_PAGE_MASK);
+	pasid_tbl = get_pasid_table_from_pde(dir_entry);
+
+	tbl_wlk.bus = bus;
+	tbl_wlk.devfn = devfn;
+	tbl_wlk.rt_entry = &iommu->root_entry[bus];
+	tbl_wlk.ctx_entry = context;
+	tbl_wlk.pasid_tbl_entry = pasid_tbl;
+
+	pr_info("IOMMU %s: Root Table Address: 0x%llx\n", iommu->name,
+		(u64)virt_to_phys(iommu->root_entry));
+	print_tbl_walk(NULL, &tbl_wlk, true);
+
+	domain = get_domain_from_bus_devfn(iommu, bus, devfn);
+	if (domain)
+		pgtable_walk_level(NULL, domain->pgd, domain->agaw + 2, 0, path);
+
+	spin_unlock_irqrestore(&iommu->lock, flags);
+}
+
 static int show_device_domain_translation(struct device *dev, void *data)
 {
 	struct dmar_domain *domain = find_domain(dev);
diff --git a/drivers/iommu/intel/dmar.c b/drivers/iommu/intel/dmar.c
index d5c51b5c20af..44032139be02 100644
--- a/drivers/iommu/intel/dmar.c
+++ b/drivers/iommu/intel/dmar.c
@@ -1847,22 +1847,27 @@ static int dmar_fault_do_one(struct intel_iommu *iommu, int type,
 		u8 fault_reason, u32 pasid, u16 source_id,
 		unsigned long long addr)
 {
+	u16 devfn = PCI_SLOT(source_id & 0xFF);
+	u8 bus = source_id >> 8;
 	const char *reason;
 	int fault_type;
 
 	reason = dmar_get_fault_reason(fault_reason, &fault_type);
 
-	if (fault_type == INTR_REMAP)
+	if (fault_type == INTR_REMAP) {
 		pr_err("[INTR-REMAP] Request device [%02x:%02x.%d] fault index %llx [fault reason %02d] %s\n",
 			source_id >> 8, PCI_SLOT(source_id & 0xFF),
 			PCI_FUNC(source_id & 0xFF), addr >> 48,
 			fault_reason, reason);
-	else
+	} else {
 		pr_err("[%s] Request device [%02x:%02x.%d] PASID %x fault addr %llx [fault reason %02d] %s\n",
 		       type ? "DMA Read" : "DMA Write",
 		       source_id >> 8, PCI_SLOT(source_id & 0xFF),
 		       PCI_FUNC(source_id & 0xFF), pasid, addr,
 		       fault_reason, reason);
+		if (boot_debug)
+			dmar_translation_walk(iommu, bus, devfn);
+	}
 	return 0;
 }
 
diff --git a/drivers/iommu/intel/iommu.c b/drivers/iommu/intel/iommu.c
index 956a02eb40b4..28e3ef66ba6a 100644
--- a/drivers/iommu/intel/iommu.c
+++ b/drivers/iommu/intel/iommu.c
@@ -365,6 +365,7 @@ static int intel_iommu_strict;
 static int intel_iommu_superpage = 1;
 static int iommu_identity_mapping;
 static int iommu_skip_te_disable;
+int boot_debug;
 
 #define IDENTMAP_GFX		2
 #define IDENTMAP_AZALIA		4
@@ -465,6 +466,9 @@ static int __init intel_iommu_setup(char *str)
 		} else if (!strncmp(str, "tboot_noforce", 13)) {
 			pr_info("Intel-IOMMU: not forcing on after tboot. This could expose security risk for tboot\n");
 			intel_iommu_tboot_noforce = 1;
+		} else if (!strncmp(str, "boot_debug", 10)) {
+			pr_info("Intel-IOMMU: dmar translation walk\n");
+			boot_debug = 1;
 		}
 
 		str += strcspn(str, ",");
@@ -2467,6 +2471,18 @@ struct dmar_domain *find_domain(struct device *dev)
 	return NULL;
 }
 
+struct dmar_domain *get_domain_from_bus_devfn(struct intel_iommu *iommu, u8 bus, u16 devfn)
+{
+	struct device_domain_info *info;
+	struct dmar_domain *domain = NULL;
+
+	list_for_each_entry(info, &device_domain_list, global)
+		if (info->iommu == iommu && info->bus == bus &&
+		    info->devfn == devfn)
+			domain = info->domain;
+	return domain;
+}
+
 static inline struct device_domain_info *
 dmar_search_domain_by_dev_info(int segment, int bus, int devfn)
 {
diff --git a/include/linux/intel-iommu.h b/include/linux/intel-iommu.h
index 1bc46b88711a..7d4c39ff1df5 100644
--- a/include/linux/intel-iommu.h
+++ b/include/linux/intel-iommu.h
@@ -472,7 +472,7 @@ enum {
 #define VTD_FLAG_IRQ_REMAP_PRE_ENABLED	(1 << 1)
 #define VTD_FLAG_SVM_CAPABLE		(1 << 2)
 
-extern int intel_iommu_sm;
+extern int intel_iommu_sm, boot_debug;
 extern spinlock_t device_domain_lock;
 
 #define sm_supported(iommu)	(intel_iommu_sm && ecap_smts((iommu)->ecap))
@@ -748,6 +748,7 @@ int intel_iommu_enable_pasid(struct intel_iommu *iommu, struct device *dev);
 struct dmar_domain *find_domain(struct device *dev);
 struct device_domain_info *get_domain_info(struct device *dev);
 struct intel_iommu *device_to_iommu(struct device *dev, u8 *bus, u8 *devfn);
+struct dmar_domain *get_domain_from_bus_devfn(struct intel_iommu *iommu, u8 bus, u16 devfn);
 
 #ifdef CONFIG_INTEL_IOMMU_SVM
 extern void intel_svm_check(struct intel_iommu *iommu);
@@ -795,8 +796,10 @@ static inline void intel_svm_check(struct intel_iommu *iommu) {}
 
 #ifdef CONFIG_INTEL_IOMMU_DEBUGFS
 void intel_iommu_debugfs_init(void);
+void dmar_translation_walk(struct intel_iommu *iommu, u8 bus, u16 devfn);
 #else
 static inline void intel_iommu_debugfs_init(void) {}
+static inline void dmar_translation_walk(struct intel_iommu *iommu, u8 bus, u16 devfn) {}
 #endif /* CONFIG_INTEL_IOMMU_DEBUGFS */
 
 extern const struct attribute_group *intel_iommu_groups[];
-- 
2.27.0

