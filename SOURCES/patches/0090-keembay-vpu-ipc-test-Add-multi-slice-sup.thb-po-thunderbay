From bec59e2ace40cfb1757f6e45c131a7a59f7836f0 Mon Sep 17 00:00:00 2001
From: Daniele Alessandrelli <daniele.alessandrelli@intel.com>
Date: Fri, 13 Dec 2019 13:47:07 +0000
Subject: [PATCH 090/223] keembay-vpu-ipc-test: Add multi-slice support

Make the test module support multiple VPU/IPC devices.

Signed-off-by: Daniele Alessandrelli <daniele.alessandrelli@intel.com>
---
 drivers/firmware/keembay-vpu-ipc-test.c | 191 +++++++++++++++++++++---
 1 file changed, 171 insertions(+), 20 deletions(-)

diff --git a/drivers/firmware/keembay-vpu-ipc-test.c b/drivers/firmware/keembay-vpu-ipc-test.c
index 248a5d3beee7..4dff59f9393f 100644
--- a/drivers/firmware/keembay-vpu-ipc-test.c
+++ b/drivers/firmware/keembay-vpu-ipc-test.c
@@ -5,12 +5,14 @@
  * Copyright (c) 2019 Intel Corporation.
  */
 
+#include <linux/debugfs.h>
 #include <linux/device.h>
 #include <linux/io.h>
 #include <linux/keembay-vpu-ipc.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/platform_device.h>
+#include <linux/slab.h>
 
 #define TEST_READY_WAIT_TIME_MS (31000)
 
@@ -19,17 +21,36 @@
 #define TEST_DATA (0x53544f50)
 #define TEST_SIZE (0)
 
-static struct device *get_vpu_dev(void)
-{
-	struct device_driver *vpu_drv;
+/* Device Under Test (DUT) struct. */
+struct dut {
+	struct device *dev;
+	struct list_head list;
+};
 
-	vpu_drv = driver_find("keembay-vpu-ipc", &platform_bus_type);
-	if (!vpu_drv) {
-		pr_err("Cannot find IPC driver\n");
-		return NULL;
-	}
-	return driver_find_next_device(vpu_drv, NULL);
-}
+/* The struct grouping all the parameters to be passed to a test kthread. */
+struct test_params {
+	struct device *ipc_dev;
+	unsigned long chan_id;
+};
+
+/* Forward declaration of the write function for the 'test_vpu' file. */
+static ssize_t test_vpu_wr(struct file *, const char __user *, size_t,
+			   loff_t *);
+
+/* List of VPU/IPC devices under test. */
+static LIST_HEAD(dut_list);
+
+/*
+ * The dentry of the base debugfs directory for this module
+ * /<dbgfs>/keembay_vpu_ipc_test
+ */
+static struct dentry *test_dir;
+
+/* The file operations for the 'test_vpu' file. */
+static const struct file_operations test_vpu_fops = {
+	.owner	= THIS_MODULE,
+	.write	= test_vpu_wr,
+};
 
 static int __init intel_keembay_vpu_ipc_test_send_data(struct device *dev)
 {
@@ -63,18 +84,12 @@ static int __init intel_keembay_vpu_ipc_test_send_data(struct device *dev)
 	return ret;
 }
 
-static int __init keem_bay_vpu_ipc_test_init(void)
+static int run_vpu_test(struct device *dev)
 {
 	int ret;
 	enum intel_keembay_vpu_state state;
-	struct device *dev;
 
-	pr_info("Entering VPU IPC test.\n");
-
-	dev = get_vpu_dev();
-	if (!dev)
-		return -1;
-	pr_info("Running test for device: %s\n", dev_name(dev));
+	pr_info("Starting VPU/IPC test for device: %s\n", dev_name(dev));
 
 	/* Check state */
 	state = intel_keembay_vpu_status(dev);
@@ -168,14 +183,149 @@ static int __init keem_bay_vpu_ipc_test_init(void)
 		return -EIO;
 	}
 
-	put_device(dev);
+	return 0;
+}
+
+static ssize_t test_vpu_wr(struct file *filp, const char __user *buf,
+			   size_t count, loff_t *fpos)
+{
+	int rc;
+	struct device *vpu_dev = filp->f_inode->i_private;
+
+	pr_info("TEST_VPU write: %s\n", dev_name(vpu_dev));
+
+	rc = run_vpu_test(vpu_dev);
+	if (rc)
+		return rc;
+
+	return count;
+}
+
+/*
+ * Add an IPC device to be tested.
+ */
+static int add_dev_to_dbgfs_tree(struct device *dev, struct dentry *base_dir)
+{
+	struct dentry *dev_dir;
+	struct dentry *file;
+
+	dev_dir = debugfs_create_dir(dev_name(dev), base_dir);
+	if (!dev_dir)
+		return -ENOMEM;
+	pr_info("TEST_MOD: device dir created: %s\n", dev_name(dev));
+
+	/* Create test_vpu file */
+	file = debugfs_create_file("test_vpu", 0220, dev_dir, dev,
+				   &test_vpu_fops);
+	if (!file)
+		return -ENOMEM;
+	pr_info("TEST_MOD: send file created\n");
+
+	return 0;
+}
+
+/* Remove the DebugFS tree. */
+static void remove_vpu_test_dbgfs_tree(void)
+{
+	debugfs_remove_recursive(test_dir);
+}
+
+/* Create the DebugFS tree. */
+static int create_vpu_test_dbgfs_tree(struct list_head *list)
+{
+	struct dut *dut;
+	struct list_head *pos;
+	int rc = 0;
+
+	test_dir = debugfs_create_dir("keembay_vpu_ipc_test", NULL);
+	/*
+	 * The only error can be -ENODEV; i.e., debugfs is not enabled.
+	 * Therefore, the IS_ERR(test_dir) check is done only here.
+	 */
+	if (IS_ERR(test_dir))
+		return PTR_ERR(test_dir);
+	if (!test_dir)
+		return -ENOMEM;
+	pr_info("TEST_MOD: kmb_vpu_ipc_test dir created\n");
+
+	list_for_each(pos, list) {
+		dut = list_entry(pos, struct dut, list);
+		rc = add_dev_to_dbgfs_tree(dut->dev, test_dir);
+		if (rc) {
+			remove_vpu_test_dbgfs_tree();
+			return rc;
+		}
+	}
+	return 0;
+}
+
+/* Release the list of DUTs. */
+static void free_dut_list(struct list_head *list)
+{
+	struct dut *dut;
+	struct list_head *pos, *q;
+
+	list_for_each_safe(pos, q, list) {
+		list_del(pos);
+		dut = list_entry(pos, struct dut, list);
+		pr_info("Removing DUT %s\n", dev_name(dut->dev));
+		put_device(dut->dev);
+		kfree(dut);
+	}
+}
+
+/* Initialize the list of DUTs. */
+static int init_dut_list(struct list_head *list)
+{
+	struct device_driver *vpu_drv;
+	struct device *dev = NULL;
+	struct dut *dut;
+
+	vpu_drv = driver_find("keembay-vpu-ipc", &platform_bus_type);
+	if (!vpu_drv) {
+		pr_err("Cannot find VPU/IPC driver\n");
+		return -ENODEV;
+	}
+
+	while ((dev = driver_find_next_device(vpu_drv, dev))) {
+		dut = kmalloc(sizeof(*dut), GFP_KERNEL);
+		if (!dut) {
+			free_dut_list(list);
+			return -ENOMEM;
+		}
+		pr_info("Adding DUT %s\n", dev_name(dev));
+		dut->dev = dev;
+		list_add_tail(&dut->list, &dut_list);
+	}
 
 	return 0;
 }
 
+static int __init keem_bay_vpu_ipc_test_init(void)
+{
+	int rc;
+
+	pr_info("Loading VPU IPC test module.\n");
+
+	rc = init_dut_list(&dut_list);
+	if (rc) {
+		pr_err("Failed to init DUT list\n");
+		return rc;
+	}
+	rc = create_vpu_test_dbgfs_tree(&dut_list);
+	if (rc) {
+		pr_err("Failed to create debugfs tree\n");
+		free_dut_list(&dut_list);
+		return rc;
+	}
+	return 0;
+}
+
 static void __exit keem_bay_vpu_ipc_test_exit(void)
 {
-	pr_info("Leaving VPU IPC test.\n");
+	pr_info("Removing VPU IPC test module.\n");
+	remove_vpu_test_dbgfs_tree();
+	free_dut_list(&dut_list);
 }
 
 module_init(keem_bay_vpu_ipc_test_init);
@@ -183,4 +333,5 @@ module_exit(keem_bay_vpu_ipc_test_exit);
 
 MODULE_DESCRIPTION("Keem Bay VPU IPC test driver");
 MODULE_AUTHOR("Paul Murphy <paul.j.murphy@intel.com>");
+MODULE_AUTHOR("Daniele Alessandrelli <daniele.alessandrelli@intel.com>");
 MODULE_LICENSE("Dual BSD/GPL");
-- 
2.27.0

