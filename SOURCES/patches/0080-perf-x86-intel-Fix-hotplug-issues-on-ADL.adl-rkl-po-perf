From 7259d852d4c46c8ef0763278237fa5072de722fb Mon Sep 17 00:00:00 2001
From: Kan Liang <kan.liang@linux.intel.com>
Date: Wed, 10 Mar 2021 08:23:28 -0800
Subject: [PATCH 80/88] perf/x86/intel: Fix hotplug issues on ADL

Signed-off-by: Kan Liang <kan.liang@linux.intel.com>
---
 arch/x86/events/intel/core.c | 34 +++++++++++++++++-----------------
 1 file changed, 17 insertions(+), 17 deletions(-)

diff --git a/arch/x86/events/intel/core.c b/arch/x86/events/intel/core.c
index 3887530dc6c8..f39a58d0f0ab 100644
--- a/arch/x86/events/intel/core.c
+++ b/arch/x86/events/intel/core.c
@@ -4483,26 +4483,21 @@ int x86_get_hybrid_pmu_type(u8 cpu_type)
 	return -1;
 }
 
-static struct x86_hybrid_pmu *intel_pmu_get_hybrid_pmu(int cpu)
-{
-	u8 cpu_type = get_hybrid_cpu_type(cpu);
-	int i;
-
-	for (i = 0; i < x86_pmu.num_hybrid_pmus; i++) {
-		if (x86_pmu.hybrid_pmu[i].cpu_type == cpu_type)
-			return &x86_pmu.hybrid_pmu[i];
-	}
-	return NULL;
-}
-
 static void init_hybrid_pmu(int cpu)
 {
 	unsigned int fixed_mask, unused_eax, unused_ebx, unused_edx;
 	struct cpu_hw_events *cpuc = &per_cpu(cpu_hw_events, cpu);
+	u8 cpu_type = get_hybrid_cpu_type(cpu);
+	struct x86_hybrid_pmu *pmu = NULL;
 	struct perf_cpu_context *cpuctx;
-	struct x86_hybrid_pmu *pmu;
+	int i;
 
-	pmu = intel_pmu_get_hybrid_pmu(cpu);
+	for (i = 0; i < x86_pmu.num_hybrid_pmus; i++) {
+		if (x86_pmu.hybrid_pmu[i].cpu_type == cpu_type) {
+			pmu = &x86_pmu.hybrid_pmu[i];
+			break;
+		}
+	}
 	if (WARN_ON_ONCE(!pmu))
 		return;
 
@@ -4698,13 +4693,18 @@ static void intel_pmu_cpu_dead(int cpu)
 
 	if (is_hybrid()) {
 		struct cpu_hw_events *cpuc = &per_cpu(cpu_hw_events, cpu);
-		struct x86_hybrid_pmu *hybrid_pmu;
+		struct x86_hybrid_pmu *hybrid_pmu = NULL;
+		int i;
 
-		hybrid_pmu = intel_pmu_get_hybrid_pmu(cpu);
+		for (i = 0; i < x86_pmu.num_hybrid_pmus; i++) {
+			if (cpumask_test_and_clear_cpu(cpu, &x86_pmu.hybrid_pmu[i].supported_cpus)) {
+				hybrid_pmu = &x86_pmu.hybrid_pmu[i];
+				break;
+			}
+		}
 		if (WARN_ON_ONCE(!hybrid_pmu))
 			return;
 
-		cpumask_clear_cpu(cpu, &hybrid_pmu->supported_cpus);
 		cpuc->pmu = NULL;
 		if (cpumask_empty(&hybrid_pmu->supported_cpus)) {
 			perf_pmu_unregister(&hybrid_pmu->pmu);
-- 
2.27.0

