From 6787646e7ad5ad294bc68d6e29dfd71851bb7b9f Mon Sep 17 00:00:00 2001
From: hemanthk <hemanthkumar.sm@intel.com>
Date: Fri, 12 Mar 2021 07:46:18 +0530
Subject: [PATCH 215/223] crypto: keembay - Add support for Thunder Bay OCS HCU

        Extends the Keem Bay OCS HCU driver to support Thunder Bay Soc.

Signed-off-by: hemanthk <hemanthkumar.sm@intel.com>
---
 drivers/crypto/keembay/Kconfig                |  32 +++++
 drivers/crypto/keembay/Makefile               |   3 +
 drivers/crypto/keembay/keembay-ocs-hcu-core.c | 125 +++++++++++++-----
 drivers/crypto/keembay/ocs-hcu.c              |  29 +++-
 drivers/crypto/keembay/ocs-hcu.h              |  26 +++-
 5 files changed, 169 insertions(+), 46 deletions(-)

diff --git a/drivers/crypto/keembay/Kconfig b/drivers/crypto/keembay/Kconfig
index 269b7cbf10c9..1cca445f48f1 100644
--- a/drivers/crypto/keembay/Kconfig
+++ b/drivers/crypto/keembay/Kconfig
@@ -152,3 +152,35 @@ config CRYPTO_DEV_THUNDERBAY_OCS_AES_SM4_CTS
 	  Provides OCS version of cts(cbc(aes)) and cts(cbc(sm4)).
 
 	  Intel does not recommend use of CTS mode with AES/SM4.
+
+config CRYPTO_DEV_THUNDERBAY_OCS_HCU
+	tristate "Support for Intel Thunder Bay OCS HCU HW acceleration"
+	select CRYPTO_HASH
+	select CRYPTO_ENGINE
+	depends on HAS_IOMEM
+	depends on ARCH_THUNDERBAY || COMPILE_TEST
+	depends on OF || COMPILE_TEST
+	depends on CRYPTO_DEV_OCS_WRAPPER
+	help
+	  Support for Intel Thunder Bay Offload and Crypto Subsystem (OCS) Hash
+	  Control Unit (HCU) hardware acceleration for use with Crypto API.
+
+	  Provides OCS HCU hardware acceleration of sha256, sha384, sha512, and
+	  sm3, as well as the HMAC variant of these algorithms.
+
+	  Say Y or M if you're building for the Intel Thunder Bay SoC. If compiled
+	  as a module, the module will be called thunderbay-ocs-hcu.
+
+	  If unsure, say N.
+
+config CRYPTO_DEV_THUNDERBAY_OCS_HCU_HMAC_SHA224
+	bool "Enable sha224 and hmac(sha224) support in Intel Thunder Bay OCS HCU"
+	depends on CRYPTO_DEV_THUNDERBAY_OCS_HCU
+	help
+	  Enables support for sha224 and hmac(sha224) algorithms in the Intel
+	  Thunder Bay OCS HCU driver. Intel recommends not to use these
+	  algorithms.
+
+	  Provides OCS HCU hardware acceleration of sha224 and hmac(224).
+
+	  If unsure, say N.
diff --git a/drivers/crypto/keembay/Makefile b/drivers/crypto/keembay/Makefile
index 7b32f24e1212..96cade43b629 100644
--- a/drivers/crypto/keembay/Makefile
+++ b/drivers/crypto/keembay/Makefile
@@ -13,3 +13,6 @@ obj-$(CONFIG_CRYPTO_DEV_OCS_WRAPPER) +=ocs-wrapper.o
 
 obj-$(CONFIG_CRYPTO_DEV_THUNDERBAY_OCS_AES_SM4) += thunderbay-ocs-aes.o
 thunderbay-ocs-aes-objs := keembay-ocs-aes-core.o ocs-aes.o
+
+obj-$(CONFIG_CRYPTO_DEV_THUNDERBAY_OCS_HCU) += thunderbay-ocs-hcu.o
+thunderbay-ocs-hcu-objs := keembay-ocs-hcu-core.o ocs-hcu.o
diff --git a/drivers/crypto/keembay/keembay-ocs-hcu-core.c b/drivers/crypto/keembay/keembay-ocs-hcu-core.c
index c4b97b4160e9..ab192a0f0699 100644
--- a/drivers/crypto/keembay/keembay-ocs-hcu-core.c
+++ b/drivers/crypto/keembay/keembay-ocs-hcu-core.c
@@ -20,9 +20,20 @@
 #include <crypto/internal/hash.h>
 
 #include "ocs-hcu.h"
+#ifdef CONFIG_ARCH_THUNDERBAY
+#include "ocs-wrapper.h"
+#endif
 
 #define DRV_NAME	"keembay-ocs-hcu"
 
+#ifdef CONFIG_CRYPTO_DEV_KEEMBAY_OCS_HCU_HMAC_SHA224
+#define ENABLE_OCS_HCU_HMAC_SHA224
+#endif
+
+#ifdef CONFIG_CRYPTO_DEV_THUNDERBAY_OCS_HCU_HMAC_SHA224
+#define ENABLE_OCS_HCU_HMAC_SHA224
+#endif
+
 /* Flag marking a final request. */
 #define REQ_FINAL			BIT(0)
 /* Flag marking a HMAC request. */
@@ -161,23 +172,32 @@ static int flush_sg_to_ocs_buffer(struct ocs_hcu_rctx *rctx)
 	return 0;
 }
 
-static struct ocs_hcu_dev *kmb_ocs_hcu_find_dev(struct ahash_request *req)
+static struct ocs_hcu_dev *kmb_ocs_hcu_find_dev(struct crypto_ahash *tfm)
 {
-	struct crypto_ahash *tfm = crypto_ahash_reqtfm(req);
 	struct ocs_hcu_ctx *tctx = crypto_ahash_ctx(tfm);
+	struct ocs_hcu_dev *hcu_dev;
+	struct list_head *p = NULL;
+	const char *driver_name = NULL;
 
 	/* If the HCU device for the request was previously set, return it. */
 	if (tctx->hcu_dev)
 		return tctx->hcu_dev;
 
+	driver_name = crypto_tfm_alg_driver_name(crypto_ahash_tfm(tfm));
+
 	/*
-	 * Otherwise, get the first HCU device available (there should be one
-	 * and only one device).
+	 * Otherwise, get the HCU device with matching driver_name.
 	 */
 	spin_lock_bh(&ocs_hcu.lock);
-	tctx->hcu_dev = list_first_entry_or_null(&ocs_hcu.dev_list,
-						 struct ocs_hcu_dev,
-						 list);
+	list_for_each(p, &ocs_hcu.dev_list) {
+		hcu_dev = list_entry(p, struct ocs_hcu_dev, list);
+		if (strstr(driver_name, hcu_dev->driver_name)) {
+			tctx->hcu_dev = hcu_dev;
+			goto exit;
+		}
+	}
+
+exit:
 	spin_unlock_bh(&ocs_hcu.lock);
 
 	return tctx->hcu_dev;
@@ -364,7 +384,7 @@ static void kmb_ocs_hcu_secure_cleanup(struct ahash_request *req)
 
 static int kmb_ocs_hcu_handle_queue(struct ahash_request *req)
 {
-	struct ocs_hcu_dev *hcu_dev = kmb_ocs_hcu_find_dev(req);
+	struct ocs_hcu_dev *hcu_dev = kmb_ocs_hcu_find_dev(crypto_ahash_reqtfm(req));
 
 	if (!hcu_dev)
 		return -ENOENT;
@@ -412,8 +432,8 @@ static int kmb_ocs_hcu_do_one_request(struct crypto_engine *engine, void *areq)
 {
 	struct ahash_request *req = container_of(areq, struct ahash_request,
 						 base);
-	struct ocs_hcu_dev *hcu_dev = kmb_ocs_hcu_find_dev(req);
 	struct crypto_ahash *tfm = crypto_ahash_reqtfm(req);
+	struct ocs_hcu_dev *hcu_dev = kmb_ocs_hcu_find_dev(tfm);
 	struct ocs_hcu_rctx *rctx = ahash_request_ctx(req);
 	struct ocs_hcu_ctx *tctx = crypto_ahash_ctx(tfm);
 	int rc;
@@ -560,9 +580,9 @@ static int kmb_ocs_hcu_do_one_request(struct crypto_engine *engine, void *areq)
 
 static int kmb_ocs_hcu_init(struct ahash_request *req)
 {
-	struct ocs_hcu_dev *hcu_dev = kmb_ocs_hcu_find_dev(req);
 	struct ocs_hcu_rctx *rctx = ahash_request_ctx(req);
 	struct crypto_ahash *tfm = crypto_ahash_reqtfm(req);
+	struct ocs_hcu_dev *hcu_dev = kmb_ocs_hcu_find_dev(tfm);
 	struct ocs_hcu_ctx *ctx = crypto_ahash_ctx(tfm);
 
 	if (!hcu_dev)
@@ -575,12 +595,12 @@ static int kmb_ocs_hcu_init(struct ahash_request *req)
 	rctx->dig_sz = crypto_ahash_digestsize(tfm);
 
 	switch (rctx->dig_sz) {
-#ifdef CONFIG_CRYPTO_DEV_KEEMBAY_OCS_HCU_HMAC_SHA224
+#ifdef ENABLE_OCS_HCU_HMAC_SHA224
 	case SHA224_DIGEST_SIZE:
 		rctx->blk_sz = SHA224_BLOCK_SIZE;
 		rctx->algo = OCS_HCU_ALGO_SHA224;
 		break;
-#endif /* CONFIG_CRYPTO_DEV_KEEMBAY_OCS_HCU_HMAC_SHA224 */
+#endif /* ENABLE_OCS_HCU_HMAC_SHA224 */
 	case SHA256_DIGEST_SIZE:
 		rctx->blk_sz = SHA256_BLOCK_SIZE;
 		/*
@@ -710,7 +730,7 @@ static int kmb_ocs_hcu_finup(struct ahash_request *req)
 static int kmb_ocs_hcu_digest(struct ahash_request *req)
 {
 	int rc = 0;
-	struct ocs_hcu_dev *hcu_dev = kmb_ocs_hcu_find_dev(req);
+	struct ocs_hcu_dev *hcu_dev = kmb_ocs_hcu_find_dev(crypto_ahash_reqtfm(req));
 
 	if (!hcu_dev)
 		return -ENOENT;
@@ -750,11 +770,12 @@ static int kmb_ocs_hcu_setkey(struct crypto_ahash *tfm, const u8 *key,
 	unsigned int digestsize = crypto_ahash_digestsize(tfm);
 	struct ocs_hcu_ctx *ctx = crypto_ahash_ctx(tfm);
 	size_t blk_sz = crypto_ahash_blocksize(tfm);
+	struct ocs_hcu_dev *hcu_dev = kmb_ocs_hcu_find_dev(tfm);
 	struct crypto_ahash *ahash_tfm;
 	struct ahash_request *req;
 	struct crypto_wait wait;
 	struct scatterlist sg;
-	const char *alg_name;
+	char alg_name[CRYPTO_MAX_ALG_NAME] = {0};
 	int rc;
 
 	/*
@@ -771,25 +792,25 @@ static int kmb_ocs_hcu_setkey(struct crypto_ahash *tfm, const u8 *key,
 	}
 
 	switch (digestsize) {
-#ifdef CONFIG_CRYPTO_DEV_KEEMBAY_OCS_HCU_HMAC_SHA224
+#ifdef ENABLE_OCS_HCU_HMAC_SHA224
 	case SHA224_DIGEST_SIZE:
-		alg_name = "sha224-keembay-ocs";
+		strcpy(alg_name, "sha224-");
 		break;
-#endif /* CONFIG_CRYPTO_DEV_KEEMBAY_OCS_HCU_HMAC_SHA224 */
+#endif /* ENABLE_OCS_HCU_HMAC_SHA224 */
 	case SHA256_DIGEST_SIZE:
-		alg_name = ctx->is_sm3_tfm ? "sm3-keembay-ocs" :
-					     "sha256-keembay-ocs";
+		strcpy(alg_name, ctx->is_sm3_tfm ? "sm3-" : "sha256-");
 		break;
 	case SHA384_DIGEST_SIZE:
-		alg_name = "sha384-keembay-ocs";
+		strcpy(alg_name, "sha384-");
 		break;
 	case SHA512_DIGEST_SIZE:
-		alg_name = "sha512-keembay-ocs";
+		strcpy(alg_name, "sha512-");
 		break;
 	default:
 		return -EINVAL;
 	}
 
+	strcat(alg_name, hcu_dev->driver_name);
 	ahash_tfm = crypto_alloc_ahash(alg_name, 0, 0);
 	if (IS_ERR(ahash_tfm))
 		return PTR_ERR(ahash_tfm);
@@ -884,7 +905,7 @@ static void kmb_ocs_hcu_hmac_cra_exit(struct crypto_tfm *tfm)
 }
 
 static struct ahash_alg ocs_hcu_algs[] = {
-#ifdef CONFIG_CRYPTO_DEV_KEEMBAY_OCS_HCU_HMAC_SHA224
+#ifdef ENABLE_OCS_HCU_HMAC_SHA224
 {
 	.init		= kmb_ocs_hcu_init,
 	.update		= kmb_ocs_hcu_update,
@@ -898,7 +919,7 @@ static struct ahash_alg ocs_hcu_algs[] = {
 		.statesize	= sizeof(struct ocs_hcu_rctx),
 		.base	= {
 			.cra_name		= "sha224",
-			.cra_driver_name	= "sha224-keembay-ocs",
+			.cra_driver_name	= "sha224-",
 			.cra_priority		= 255,
 			.cra_flags		= CRYPTO_ALG_ASYNC,
 			.cra_blocksize		= SHA224_BLOCK_SIZE,
@@ -923,7 +944,7 @@ static struct ahash_alg ocs_hcu_algs[] = {
 		.statesize	= sizeof(struct ocs_hcu_rctx),
 		.base	= {
 			.cra_name		= "hmac(sha224)",
-			.cra_driver_name	= "hmac-sha224-keembay-ocs",
+			.cra_driver_name	= "hmac-sha224-",
 			.cra_priority		= 255,
 			.cra_flags		= CRYPTO_ALG_ASYNC,
 			.cra_blocksize		= SHA224_BLOCK_SIZE,
@@ -935,7 +956,7 @@ static struct ahash_alg ocs_hcu_algs[] = {
 		}
 	}
 },
-#endif /* CONFIG_CRYPTO_DEV_KEEMBAY_OCS_HCU_HMAC_SHA224 */
+#endif /* ENABLE_OCS_HCU_HMAC_SHA224 */
 {
 	.init		= kmb_ocs_hcu_init,
 	.update		= kmb_ocs_hcu_update,
@@ -949,7 +970,7 @@ static struct ahash_alg ocs_hcu_algs[] = {
 		.statesize	= sizeof(struct ocs_hcu_rctx),
 		.base	= {
 			.cra_name		= "sha256",
-			.cra_driver_name	= "sha256-keembay-ocs",
+			.cra_driver_name	= "sha256-",
 			.cra_priority		= 255,
 			.cra_flags		= CRYPTO_ALG_ASYNC,
 			.cra_blocksize		= SHA256_BLOCK_SIZE,
@@ -974,7 +995,7 @@ static struct ahash_alg ocs_hcu_algs[] = {
 		.statesize	= sizeof(struct ocs_hcu_rctx),
 		.base	= {
 			.cra_name		= "hmac(sha256)",
-			.cra_driver_name	= "hmac-sha256-keembay-ocs",
+			.cra_driver_name	= "hmac-sha256-",
 			.cra_priority		= 255,
 			.cra_flags		= CRYPTO_ALG_ASYNC,
 			.cra_blocksize		= SHA256_BLOCK_SIZE,
@@ -999,7 +1020,7 @@ static struct ahash_alg ocs_hcu_algs[] = {
 		.statesize	= sizeof(struct ocs_hcu_rctx),
 		.base	= {
 			.cra_name		= "sm3",
-			.cra_driver_name	= "sm3-keembay-ocs",
+			.cra_driver_name	= "sm3-",
 			.cra_priority		= 255,
 			.cra_flags		= CRYPTO_ALG_ASYNC,
 			.cra_blocksize		= SM3_BLOCK_SIZE,
@@ -1024,7 +1045,7 @@ static struct ahash_alg ocs_hcu_algs[] = {
 		.statesize	= sizeof(struct ocs_hcu_rctx),
 		.base	= {
 			.cra_name		= "hmac(sm3)",
-			.cra_driver_name	= "hmac-sm3-keembay-ocs",
+			.cra_driver_name	= "hmac-sm3-",
 			.cra_priority		= 255,
 			.cra_flags		= CRYPTO_ALG_ASYNC,
 			.cra_blocksize		= SM3_BLOCK_SIZE,
@@ -1049,7 +1070,7 @@ static struct ahash_alg ocs_hcu_algs[] = {
 		.statesize	= sizeof(struct ocs_hcu_rctx),
 		.base	= {
 			.cra_name		= "sha384",
-			.cra_driver_name	= "sha384-keembay-ocs",
+			.cra_driver_name	= "sha384-",
 			.cra_priority		= 255,
 			.cra_flags		= CRYPTO_ALG_ASYNC,
 			.cra_blocksize		= SHA384_BLOCK_SIZE,
@@ -1074,7 +1095,7 @@ static struct ahash_alg ocs_hcu_algs[] = {
 		.statesize	= sizeof(struct ocs_hcu_rctx),
 		.base	= {
 			.cra_name		= "hmac(sha384)",
-			.cra_driver_name	= "hmac-sha384-keembay-ocs",
+			.cra_driver_name	= "hmac-sha384-",
 			.cra_priority		= 255,
 			.cra_flags		= CRYPTO_ALG_ASYNC,
 			.cra_blocksize		= SHA384_BLOCK_SIZE,
@@ -1099,7 +1120,7 @@ static struct ahash_alg ocs_hcu_algs[] = {
 		.statesize	= sizeof(struct ocs_hcu_rctx),
 		.base	= {
 			.cra_name		= "sha512",
-			.cra_driver_name	= "sha512-keembay-ocs",
+			.cra_driver_name	= "sha512-",
 			.cra_priority		= 255,
 			.cra_flags		= CRYPTO_ALG_ASYNC,
 			.cra_blocksize		= SHA512_BLOCK_SIZE,
@@ -1124,7 +1145,7 @@ static struct ahash_alg ocs_hcu_algs[] = {
 		.statesize	= sizeof(struct ocs_hcu_rctx),
 		.base	= {
 			.cra_name		= "hmac(sha512)",
-			.cra_driver_name	= "hmac-sha512-keembay-ocs",
+			.cra_driver_name	= "hmac-sha512-",
 			.cra_priority		= 255,
 			.cra_flags		= CRYPTO_ALG_ASYNC,
 			.cra_blocksize		= SHA512_BLOCK_SIZE,
@@ -1155,7 +1176,7 @@ static int kmb_ocs_hcu_remove(struct platform_device *pdev)
 	if (!hcu_dev)
 		return -ENODEV;
 
-	crypto_unregister_ahashes(ocs_hcu_algs, ARRAY_SIZE(ocs_hcu_algs));
+	crypto_unregister_ahashes(hcu_dev->algs, ARRAY_SIZE(ocs_hcu_algs));
 
 	rc = crypto_engine_exit(hcu_dev->engine);
 
@@ -1171,7 +1192,8 @@ static int kmb_ocs_hcu_probe(struct platform_device *pdev)
 	struct device *dev = &pdev->dev;
 	struct ocs_hcu_dev *hcu_dev;
 	struct resource *hcu_mem;
-	int rc;
+	int rc, i;
+	const char *driver_name = NULL;
 
 	hcu_dev = devm_kzalloc(dev, sizeof(*hcu_dev), GFP_KERNEL);
 	if (!hcu_dev)
@@ -1212,6 +1234,37 @@ static int kmb_ocs_hcu_probe(struct platform_device *pdev)
 		return rc;
 	}
 
+	rc = of_property_read_string(pdev->dev.of_node, "driver-name", &driver_name);
+	if (rc < 0) {
+		dev_err(dev, "Could not get driver-name\n");
+		return rc;
+	}
+	strcpy(hcu_dev->driver_name, driver_name);
+
+#ifdef CONFIG_ARCH_THUNDERBAY
+	hcu_dev->wrapper_dev = ocs_wrapper_find_dev(hcu_dev->driver_name);
+	if (!hcu_dev->wrapper_dev) {
+		dev_err(dev, "Could not find ocs wrapper device\n");
+		return -ENODEV;
+	}
+#endif
+
+	rc = of_property_read_u32(pdev->dev.of_node, "priority",
+				  (u32 *)&hcu_dev->priority);
+	if (rc < 0) {
+		dev_err(dev, "Could not get priority\n");
+		return rc;
+	}
+
+	hcu_dev->algs = devm_kzalloc(dev, sizeof(ocs_hcu_algs), GFP_KERNEL);
+	if (!hcu_dev->algs)
+		return -ENOMEM;
+	memcpy(hcu_dev->algs, ocs_hcu_algs, sizeof(ocs_hcu_algs));
+	for (i = 0; i < ARRAY_SIZE(ocs_hcu_algs); i++) {
+		strcat(hcu_dev->algs[i].halg.base.cra_driver_name, hcu_dev->driver_name);
+		hcu_dev->algs[i].halg.base.cra_priority = hcu_dev->priority;
+	}
+
 	INIT_LIST_HEAD(&hcu_dev->list);
 
 	spin_lock_bh(&ocs_hcu.lock);
@@ -1231,7 +1284,7 @@ static int kmb_ocs_hcu_probe(struct platform_device *pdev)
 
 	/* Security infrastructure guarantees OCS clock is enabled. */
 
-	rc = crypto_register_ahashes(ocs_hcu_algs, ARRAY_SIZE(ocs_hcu_algs));
+	rc = crypto_register_ahashes(hcu_dev->algs, ARRAY_SIZE(ocs_hcu_algs));
 	if (rc) {
 		dev_err(dev, "Could not register algorithms.\n");
 		goto cleanup;
diff --git a/drivers/crypto/keembay/ocs-hcu.c b/drivers/crypto/keembay/ocs-hcu.c
index 81eecacf603a..6418977d14f2 100644
--- a/drivers/crypto/keembay/ocs-hcu.c
+++ b/drivers/crypto/keembay/ocs-hcu.c
@@ -14,6 +14,9 @@
 #include <crypto/sha2.h>
 
 #include "ocs-hcu.h"
+#ifdef CONFIG_ARCH_THUNDERBAY
+#include "ocs-wrapper.h"
+#endif
 
 /* Registers. */
 #define OCS_HCU_MODE			0x00
@@ -468,7 +471,10 @@ static int ocs_hcu_ll_dma_start(struct ocs_hcu_dev *hcu_dev,
 		ocs_hcu_dma_irq_en(hcu_dev);
 
 	reinit_completion(&hcu_dev->irq_done);
-	writel(dma_list->dma_addr, hcu_dev->io_base + OCS_HCU_DMA_NEXT_SRC_DESCR);
+#ifdef CONFIG_ARCH_THUNDERBAY
+	ocs_wrapper_setconfig(hcu_dev->wrapper_dev, (dma_list->dma_addr >> 32), 0);
+#endif /* CONFIG_ARCH_THUNDERBAY */
+	writel((dma_list->dma_addr & 0xFFFFFFFF), hcu_dev->io_base + OCS_HCU_DMA_NEXT_SRC_DESCR);
 	writel(0, hcu_dev->io_base + OCS_HCU_DMA_SRC_SIZE);
 	writel(0, hcu_dev->io_base + OCS_HCU_DMA_DST_SIZE);
 
@@ -480,6 +486,9 @@ static int ocs_hcu_ll_dma_start(struct ocs_hcu_dev *hcu_dev,
 		writel(OCS_HCU_TERMINATE, hcu_dev->io_base + OCS_HCU_OPERATION);
 
 	rc = ocs_hcu_wait_and_disable_irq(hcu_dev);
+#ifdef CONFIG_ARCH_THUNDERBAY
+	ocs_wrapper_release(hcu_dev->wrapper_dev);
+#endif /* CONFIG_ARCH_THUNDERBAY */
 	if (rc)
 		return rc;
 
@@ -550,6 +559,14 @@ int ocs_hcu_dma_list_add_tail(struct ocs_hcu_dev *hcu_dev,
 	if (new_tail - dma_list->head >= dma_list->max_nents)
 		return -ENOMEM;
 
+#ifdef CONFIG_ARCH_THUNDERBAY
+	if ((addr >> 32) != (dma_list->dma_addr >> 32)) {
+		dev_err(dev,
+			"data and descriptor not on the same ddr slice\n");
+		return -EINVAL;
+	}
+#endif
+
 	/*
 	 * If there was an old tail (i.e., this is not the first element we are
 	 * adding), un-terminate the old tail and make it point to the new one.
@@ -565,7 +582,7 @@ int ocs_hcu_dma_list_add_tail(struct ocs_hcu_dev *hcu_dev,
 								dma_list->head);
 	}
 
-	new_tail->src_addr = (u32)addr;
+	new_tail->src_addr = (u32)(addr & 0xFFFFFFFF);
 	new_tail->src_len = (u32)len;
 	new_tail->ll_flags = OCS_LL_DMA_FLAG_TERMINATE;
 	new_tail->nxt_desc = 0;
@@ -746,7 +763,10 @@ int ocs_hcu_digest(struct ocs_hcu_dev *hcu_dev, enum ocs_hcu_algo algo,
 
 	reinit_completion(&hcu_dev->irq_done);
 
-	writel(dma_handle, hcu_dev->io_base + OCS_HCU_DMA_SRC_ADDR);
+#ifdef CONFIG_ARCH_THUNDERBAY
+	ocs_wrapper_setconfig(hcu_dev->wrapper_dev, (dma_handle >> 32), 0);
+#endif /* CONFIG_ARCH_THUNDERBAY */
+	writel((dma_handle & 0xFFFFFFFF), hcu_dev->io_base + OCS_HCU_DMA_SRC_ADDR);
 	writel(data_len, hcu_dev->io_base + OCS_HCU_DMA_SRC_SIZE);
 	writel(OCS_HCU_START, hcu_dev->io_base + OCS_HCU_OPERATION);
 	writel(reg, hcu_dev->io_base + OCS_HCU_DMA_DMA_MODE);
@@ -754,6 +774,9 @@ int ocs_hcu_digest(struct ocs_hcu_dev *hcu_dev, enum ocs_hcu_algo algo,
 	writel(OCS_HCU_TERMINATE, hcu_dev->io_base + OCS_HCU_OPERATION);
 
 	rc = ocs_hcu_wait_and_disable_irq(hcu_dev);
+#ifdef CONFIG_ARCH_THUNDERBAY
+	ocs_wrapper_release(hcu_dev->wrapper_dev);
+#endif /* CONFIG_ARCH_THUNDERBAY */
 	if (rc)
 		return rc;
 
diff --git a/drivers/crypto/keembay/ocs-hcu.h b/drivers/crypto/keembay/ocs-hcu.h
index fbbbb92a0592..73ec56a88063 100644
--- a/drivers/crypto/keembay/ocs-hcu.h
+++ b/drivers/crypto/keembay/ocs-hcu.h
@@ -10,7 +10,11 @@
 #ifndef _CRYPTO_OCS_HCU_H
 #define _CRYPTO_OCS_HCU_H
 
+#ifdef CONFIG_ARCH_THUNDERBAY
+#define OCS_HCU_DMA_BIT_MASK		DMA_BIT_MASK(64)
+#else
 #define OCS_HCU_DMA_BIT_MASK		DMA_BIT_MASK(32)
+#endif
 
 #define OCS_HCU_HW_KEY_LEN		64
 
@@ -26,13 +30,17 @@ enum ocs_hcu_algo {
 
 /**
  * struct ocs_hcu_dev - OCS HCU device context.
- * @list:	List of device contexts.
- * @dev:	OCS HCU device.
- * @io_base:	Base address of OCS HCU registers.
- * @engine:	Crypto engine for the device.
- * @irq:	IRQ number.
- * @irq_done:	Completion for IRQ.
- * @irq_err:	Flag indicating an IRQ error has happened.
+ * @list:		List of device contexts.
+ * @dev:		OCS HCU device.
+ * @io_base:		Base address of OCS HCU registers.
+ * @engine:		Crypto engine for the device.
+ * @irq:		IRQ number.
+ * @irq_done:		Completion for IRQ.
+ * @irq_err:		Flag indicating an IRQ error has happened.
+ * @algs:		Address to ahash algorithm configuration.
+ * @priority:		Crypto algorithm priority
+ * @wrapper_dev:	Address to OCS Wrapper device context
+ * driver_name:		Identifier for OCS instance
  */
 struct ocs_hcu_dev {
 	struct list_head list;
@@ -42,6 +50,10 @@ struct ocs_hcu_dev {
 	int irq;
 	struct completion irq_done;
 	bool irq_err;
+	struct ahash_alg *algs;
+	int priority;
+	struct ocs_wrapper_dev *wrapper_dev;
+	char driver_name[64];
 };
 
 /**
-- 
2.27.0

