From 2641950928641249c86f87bd4838fc53ef600047 Mon Sep 17 00:00:00 2001
From: hemanthk <hemanthkumar.sm@intel.com>
Date: Fri, 12 Mar 2021 07:20:47 +0530
Subject: [PATCH 213/223]     crypto: keembay - Add Thunder Bay OCS WRAPPER
 driver

    Add support for the OCS WRAPPER included in the Intel Thunder Bay SoC,
    thus extending the addressing capabilities of OCS from 32 bits to 38 bits.

    The driver is composed of one file:

    - 'ocs-wrapper.c' which interacts with the hardware and abstracts it by
      providing API to Aquire mutex, set MSB 6 bits of DMA address before
      accessing by OCS Engine And Release mutex after DMA operation.

Signed-off-by: hemanthk <hemanthkumar.sm@intel.com>
---
 drivers/crypto/keembay/Kconfig       |  10 ++
 drivers/crypto/keembay/Makefile      |   2 +
 drivers/crypto/keembay/ocs-wrapper.c | 173 +++++++++++++++++++++++++++
 drivers/crypto/keembay/ocs-wrapper.h |  34 ++++++
 4 files changed, 219 insertions(+)
 create mode 100644 drivers/crypto/keembay/ocs-wrapper.c
 create mode 100644 drivers/crypto/keembay/ocs-wrapper.h

diff --git a/drivers/crypto/keembay/Kconfig b/drivers/crypto/keembay/Kconfig
index 8b45f0f9f0e5..d32329c11d8c 100644
--- a/drivers/crypto/keembay/Kconfig
+++ b/drivers/crypto/keembay/Kconfig
@@ -100,3 +100,13 @@ config CRYPTO_DEV_KEEMBAY_OCS_ECDH_GEN_PRIV_KEY_SUPPORT
 
 	  Say Y if you need the driver to pass crypto self-tests. If unsure,
 	  say N.
+
+config CRYPTO_DEV_OCS_WRAPPER
+	tristate "Support for Intel Thunder Bay OCS AES/SM4 HW acceleration"
+	depends on HAS_IOMEM
+	depends on ARCH_THUNDERBAY || COMPILE_TEST
+	help
+	  Support for Intel Thunder Bay Offload and Crypto Subsystem (OCS)
+	  WRAPPER for use by OCS AES, HCU HW accelerators.
+
+	  Extends the Addressing capability of OCS Engines from 32 to 38 bits.
diff --git a/drivers/crypto/keembay/Makefile b/drivers/crypto/keembay/Makefile
index 7dfc9c2bc727..8f91cb908e14 100644
--- a/drivers/crypto/keembay/Makefile
+++ b/drivers/crypto/keembay/Makefile
@@ -8,3 +8,5 @@ obj-$(CONFIG_CRYPTO_DEV_KEEMBAY_OCS_HCU) += keembay-ocs-hcu.o
 keembay-ocs-hcu-objs := keembay-ocs-hcu-core.o ocs-hcu.o
 
 obj-$(CONFIG_CRYPTO_DEV_KEEMBAY_OCS_ECC) += keembay-ocs-ecc.o
+
+obj-$(CONFIG_CRYPTO_DEV_OCS_WRAPPER) +=ocs-wrapper.o
diff --git a/drivers/crypto/keembay/ocs-wrapper.c b/drivers/crypto/keembay/ocs-wrapper.c
new file mode 100644
index 000000000000..74e2ee8b83e9
--- /dev/null
+++ b/drivers/crypto/keembay/ocs-wrapper.c
@@ -0,0 +1,173 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * ThunderBay OCS Crypto Driver.
+ *
+ * Copyright (C) 2020-2021 Intel Corporation
+ */
+
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/reset.h>
+#include <linux/types.h>
+#include "ocs-wrapper.h"
+
+#define DRV_NAME		"ocs-wrapper"
+
+#define OCS_WRAPPER_READ_CONFIG 0
+#define OCS_WRAPPER_WRITE_CONFIG 16
+#define OCS_WRAPPER_READ_CONFIG_MASK 0x3F
+#define OCS_WRAPPER_WRITE_CONFIG_MASK 0x3F
+#define OCS_WRAPPER_CONFIGURATION_REG_0_OFFSET (0x0000)
+#define OCS_WRAPPER_STATUS_BIT_FUSE_ATTACK_0_OFFSET (0x0004)
+
+/* Driver data. */
+struct ocs_wrapper_drv {
+	struct list_head dev_list;
+	spinlock_t lock;	/* Protects dev_list. */
+};
+
+static struct ocs_wrapper_drv ocs_wrapper = {
+	.dev_list = LIST_HEAD_INIT(ocs_wrapper.dev_list),
+	.lock = __SPIN_LOCK_UNLOCKED(ocs_wrapper.lock),
+};
+
+struct ocs_wrapper_dev *ocs_wrapper_find_dev(const char *driver_name)
+{
+	struct ocs_wrapper_dev *wrapper_dev = NULL;
+	struct list_head *p = NULL;
+
+	if (!driver_name)
+		return NULL;
+
+	spin_lock(&ocs_wrapper.lock);
+
+	list_for_each(p, &ocs_wrapper.dev_list) {
+		wrapper_dev = list_entry(p, struct ocs_wrapper_dev, list);
+		if (strcmp(driver_name, wrapper_dev->driver_name) == 0)
+			goto exit;
+	}
+
+	wrapper_dev = NULL;
+
+exit:
+	spin_unlock(&ocs_wrapper.lock);
+
+	return wrapper_dev;
+}
+EXPORT_SYMBOL_GPL(ocs_wrapper_find_dev);
+
+void ocs_wrapper_setconfig(struct ocs_wrapper_dev *dev, u32 read_address, u32 write_address)
+{
+	u32 val;
+
+	mutex_lock(&dev->wrapper_mutex);
+	val = (read_address & OCS_WRAPPER_READ_CONFIG_MASK) << OCS_WRAPPER_READ_CONFIG;
+	val = val | ((write_address & OCS_WRAPPER_WRITE_CONFIG_MASK) << OCS_WRAPPER_WRITE_CONFIG);
+
+	iowrite32(val, dev->base_reg + OCS_WRAPPER_CONFIGURATION_REG_0_OFFSET);
+}
+EXPORT_SYMBOL_GPL(ocs_wrapper_setconfig);
+
+void ocs_wrapper_release(struct ocs_wrapper_dev *dev)
+{
+	mutex_unlock(&dev->wrapper_mutex);
+}
+EXPORT_SYMBOL_GPL(ocs_wrapper_release);
+
+static int ocs_wrapper_remove(struct platform_device *pdev)
+{
+	struct ocs_wrapper_dev *wrapper_dev;
+
+	wrapper_dev = platform_get_drvdata(pdev);
+	if (!wrapper_dev)
+		return -ENODEV;
+
+	spin_lock(&ocs_wrapper.lock);
+	list_del(&wrapper_dev->list);
+	spin_unlock(&ocs_wrapper.lock);
+
+	return 0;
+}
+
+static int ocs_wrapper_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct ocs_wrapper_dev *wrapper_dev;
+	struct resource *wrapper_mem;
+	int rc;
+	const char *driver_name = NULL;
+
+	wrapper_dev = devm_kzalloc(dev, sizeof(*wrapper_dev), GFP_KERNEL);
+	if (!wrapper_dev)
+		return -ENOMEM;
+
+	wrapper_dev->dev = dev;
+
+	platform_set_drvdata(pdev, wrapper_dev);
+
+	/* Get base register address. */
+	wrapper_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!wrapper_mem) {
+		dev_err(dev, "Could not retrieve io mem resource\n");
+		return -ENODEV;
+	}
+
+	wrapper_dev->base_reg = devm_ioremap_resource(&pdev->dev, wrapper_mem);
+	if (IS_ERR(wrapper_dev->base_reg)) {
+		dev_err(dev, "Failed to get base address\n");
+		return PTR_ERR(wrapper_dev->base_reg);
+	}
+
+	wrapper_dev->reset = devm_reset_control_get_by_index(dev, 0);
+	if (IS_ERR(wrapper_dev->reset)) {
+		dev_err(dev, "Could not retrieve RESET\n");
+		return PTR_ERR(wrapper_dev->reset);
+	}
+
+	rc = reset_control_deassert(wrapper_dev->reset);
+	if (rc < 0) {
+		dev_err(dev, "Failed to deassert reset\n");
+		return rc;
+	}
+
+	rc = of_property_read_string(pdev->dev.of_node, "driver-name", &driver_name);
+	if (rc < 0) {
+		dev_err(dev, "Could not get driver-name\n");
+		return -ENODEV;
+	}
+	strcpy(wrapper_dev->driver_name, driver_name);
+
+	INIT_LIST_HEAD(&wrapper_dev->list);
+	spin_lock(&ocs_wrapper.lock);
+	list_add_tail(&wrapper_dev->list, &ocs_wrapper.dev_list);
+	spin_unlock(&ocs_wrapper.lock);
+
+	mutex_init(&wrapper_dev->wrapper_mutex);
+	return 0;
+}
+
+/* Device tree driver match. */
+static const struct of_device_id ocs_wrapper_of_match[] = {
+	{
+		.compatible = "intel,ocs-wrapper",
+	},
+	{}
+};
+
+/* The OCS Wrapper driver is a platform device. */
+static struct platform_driver ocs_wrapper_driver = {
+	.probe = ocs_wrapper_probe,
+	.remove = ocs_wrapper_remove,
+	.driver = {
+			.name = DRV_NAME,
+			.of_match_table = ocs_wrapper_of_match,
+		},
+};
+
+module_platform_driver(ocs_wrapper_driver);
+
+MODULE_DESCRIPTION("Intel OCS Wrapper driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/crypto/keembay/ocs-wrapper.h b/drivers/crypto/keembay/ocs-wrapper.h
new file mode 100644
index 000000000000..8d154a6ed6fc
--- /dev/null
+++ b/drivers/crypto/keembay/ocs-wrapper.h
@@ -0,0 +1,34 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * ThunderBay OCS AES Crypto Driver.
+ *
+ * Copyright (C) 2020-2021 Intel Corporation
+ */
+
+#ifndef _CRYPTO_OCS_WRAPPER_H
+#define _CRYPTO_OCS_WRAPPER_H
+
+/**
+ * struct ocs_wrapper_dev - OCS WRAPPER device context.
+ * @list:			List head for insertion into device list hold
+ *				by driver.
+ * @dev:			OCS WRAPPER device.
+ * @base_reg:			IO base address of OCS WRAPPER.
+ * @wrapper_mutex:		Mutex to control access to wrapper ip
+ * @reset:			Address to Reset Control Info
+ * @driver_name:		Identifier for OCS instance
+ */
+struct ocs_wrapper_dev {
+	struct list_head list;
+	struct device *dev;
+	void __iomem *base_reg;
+	struct mutex wrapper_mutex; /* Protect OCS wrapper access */
+	struct reset_control *reset;
+	char driver_name[64];
+};
+
+struct ocs_wrapper_dev *ocs_wrapper_find_dev(const char *driver_name);
+void ocs_wrapper_setconfig(struct ocs_wrapper_dev *dev, u32 read_address, u32 write_address);
+void ocs_wrapper_release(struct ocs_wrapper_dev *dev);
+
+#endif
-- 
2.27.0

