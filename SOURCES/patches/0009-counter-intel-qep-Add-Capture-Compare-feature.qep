From 2b1602d44f331cdf6028491f78e0820d4d578542 Mon Sep 17 00:00:00 2001
From: "Tan, Raymond" <raymond.tan@intel.com>
Date: Wed, 13 Nov 2019 14:17:10 +0800
Subject: [PATCH 09/61] counter: intel-qep: Add Capture Compare feature

Intel QEP controller supports Capture Compare as secondary function.

Then this function is active, the controller will record the current
value of the free running counter QEPCNTR into a FIFO when the selected
edge is detected.

The content of the FIFO is retrieved through QEPCAPBUF.

The implementation of capture_compare function is done at
counter_count_ext because this mode has dependencies on the
edge selection for the signals (A, B and INDEX).

Signed-off-by: Tan, Raymond <raymond.tan@intel.com>
---
 drivers/counter/intel-qep.c | 92 +++++++++++++++++++++++++++++++++++++
 1 file changed, 92 insertions(+)

diff --git a/drivers/counter/intel-qep.c b/drivers/counter/intel-qep.c
index 0c1e0a7c9f87..f1cfaea7d201 100644
--- a/drivers/counter/intel-qep.c
+++ b/drivers/counter/intel-qep.c
@@ -104,6 +104,7 @@ struct intel_qep {
 	bool enabled;
 	bool phase_error;
 	int op_mode;
+	int cap_mode;
 };
 
 #define counter_to_qep(c)	(container_of((c), struct intel_qep, counter))
@@ -470,11 +471,101 @@ static ssize_t phase_error_read(struct counter_device *counter,
 			"error" : "no_error");
 }
 
+static ssize_t operating_mode_read(struct counter_device *counter,
+		struct counter_count *count, void *priv, char *buf)
+{
+	struct intel_qep *qep = counter_to_qep(counter);
+
+	return snprintf(buf, PAGE_SIZE, "%s\n", qep->op_mode ?
+			"capture" : "quadrature");
+}
+
+static ssize_t operating_mode_write(struct counter_device *counter,
+		struct counter_count *count, void *priv, const char *buf,
+		size_t len)
+{
+	struct intel_qep *qep = counter_to_qep(counter);
+	u32 reg;
+
+	if (qep->enabled)
+		return -EINVAL;
+
+	pm_runtime_get_sync(qep->dev);
+
+	reg = intel_qep_readl(qep->regs, INTEL_QEPCON);
+
+	if (sysfs_streq(buf, "capture")) {
+		reg |= INTEL_QEPCON_OP_MODE;
+		qep->op_mode = INTEL_QEP_OP_MODE_CC;
+	} else if (sysfs_streq(buf, "quadrature")) {
+		reg &= ~INTEL_QEPCON_OP_MODE;
+		qep->op_mode = INTEL_QEP_OP_MODE_QEP;
+	}
+
+	intel_qep_writel(qep->regs, INTEL_QEPCON, reg);
+
+	pm_runtime_put(qep->dev);
+
+	return len;
+}
+
+static ssize_t capture_data_read(struct counter_device *counter,
+		struct counter_count *count, void *priv, char *buf)
+{
+	struct intel_qep *qep = counter_to_qep(counter);
+	u32 reg;
+
+	reg = intel_qep_readl(qep->regs, INTEL_QEPCAPBUF);
+
+	return snprintf(buf, PAGE_SIZE, "%u\n", reg);
+}
+
+static ssize_t capture_mode_read(struct counter_device *counter,
+		struct counter_count *count, void *priv, char *buf)
+{
+	struct intel_qep *qep = counter_to_qep(counter);
+
+	return snprintf(buf, PAGE_SIZE, "%s\n", qep->cap_mode ?
+			"both" : "single");
+}
+
+static ssize_t capture_mode_write(struct counter_device *counter,
+		struct counter_count *count, void *priv, const char *buf,
+		size_t len)
+{
+	struct intel_qep *qep = counter_to_qep(counter);
+	u32 reg;
+
+	if (qep->enabled)
+		return -EINVAL;
+
+	pm_runtime_get_sync(qep->dev);
+
+	reg = intel_qep_readl(qep->regs, INTEL_QEPCON);
+
+	if (sysfs_streq(buf, "both")) {
+		reg |= INTEL_QEPCON_CAP_MODE;
+		qep->cap_mode = 1;
+	} else if (sysfs_streq(buf, "single")) {
+		reg &= ~INTEL_QEPCON_CAP_MODE;
+		qep->cap_mode = 0;
+	}
+
+	intel_qep_writel(qep->regs, INTEL_QEPCON, reg);
+
+	pm_runtime_put(qep->dev);
+
+	return len;
+}
+
 static const struct counter_count_ext intel_qep_count_ext[] = {
 	INTEL_QEP_COUNTER_COUNT_EXT_RW(ceiling),
 	INTEL_QEP_COUNTER_COUNT_EXT_RW(enable),
 	INTEL_QEP_COUNTER_COUNT_EXT_RO(direction),
 	INTEL_QEP_COUNTER_COUNT_EXT_RO(phase_error),
+	INTEL_QEP_COUNTER_COUNT_EXT_RW(operating_mode),
+	INTEL_QEP_COUNTER_COUNT_EXT_RO(capture_data),
+	INTEL_QEP_COUNTER_COUNT_EXT_RW(capture_mode),
 };
 
 static struct counter_count intel_qep_counter_count[] = {
@@ -635,6 +726,7 @@ static int intel_qep_probe(struct pci_dev *pci, const struct pci_device_id *id)
 	qep->enabled = false;
 	qep->phase_error = false;
 	qep->op_mode = INTEL_QEP_OP_MODE_QEP;
+	qep->cap_mode = 0;
 
 	ret = counter_register(&qep->counter);
 	if (ret)
-- 
2.27.0

