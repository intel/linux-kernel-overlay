From b388361df44423a130bd076a64ecab8e1cf0b3db Mon Sep 17 00:00:00 2001
From: Ricardo Neri <ricardo.neri-calderon@linux.intel.com>
Date: Sat, 28 Mar 2020 16:27:48 -0700
Subject: [PATCH 32/68] x86/platform/hfi: Populate the simplified energy model

The Intel Hardware Feedback Interface delivers a per-CPU energy efficiency
rating. Deliver these ratings to the scheduler via the simplified energy
model.

The Intel Hardware Interface gives higher energy efficiency rating to more
efficient CPUs. However, the simple energy model and the scheduler make
task placement decisions based on CPUs with the lowest energy rating.
Hence, invert the energy ratings from HFI.

Also, if the energy ratings are too similar, the scheduler will not find
sufficient energy gains and placement decisions will be skewed towards
capacity. Hence, scale the energy ratings from HFI.

Signed-off-by: Ricardo Neri <ricardo.neri-calderon@linux.intel.com>
---
 arch/x86/Kconfig              |  1 +
 arch/x86/platform/intel/hfi.c | 89 +++++++++++++++++++++++++++++++++++
 2 files changed, 90 insertions(+)

diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
index d292cc723c55..8713d77fdda6 100644
--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@ -697,6 +697,7 @@ config INTEL_HFI
 	bool "Intel Hardware Feedback Interface"
 	depends on CPU_SUP_INTEL
 	depends on SCHED_MC && X86_INTEL_PSTATE && X86_THERMAL_VECTOR
+	select ENERGY_MODEL
 	help
 	  Select this option to enable the Hardware Feedback Interface in
 	  Intel hybrid processors. If selected, hardware provides guidance to
diff --git a/arch/x86/platform/intel/hfi.c b/arch/x86/platform/intel/hfi.c
index 3ee8ef8aae0f..c1be783d5b91 100644
--- a/arch/x86/platform/intel/hfi.c
+++ b/arch/x86/platform/intel/hfi.c
@@ -18,6 +18,7 @@
 
 #define pr_fmt(fmt)  "intel-hfi: " fmt
 
+#include <linux/cpu.h>
 #include <linux/cpuset.h>
 #include <linux/gfp.h>
 #include <linux/io.h>
@@ -31,6 +32,9 @@
 /* Delay reading HFI updates a few milliseconds */
 #define HFI_UPDATE_DELAY (1000 / HZ)
 
+#define HFI_EFFICIENCY_SHIFT 10
+#define HFI_EFFICIENCY_SCALE (1L << HFI_EFFICIENCY_SHIFT)
+
 /**
  * struct hfi_cpu_data - Capabilities of a logical processor in the HFI table.
  *			 These capabilities are unitless.
@@ -87,6 +91,72 @@ unsigned long hfi_scale_cpu_capacity(int cpu)
 	return per_cpu(cpu_scale, cpu);
 }
 
+/*
+ * HFI tells us which CPU is more efficient but not by how much. Hence,
+ * we are free to scale the HFI energy efficiency data. This makes the
+ * relative efficiency among CPUs sufficiently large for the scheduler's
+ * compute_energy() to identify energy-efficient CPUs.
+ */
+static void scale_energy_efficiency(void)
+{
+	unsigned int ee_scale = 1, ee;
+	int cpu;
+
+	for_each_online_cpu(cpu)
+		ee_scale = max(raw_data[cpu], ee_scale);
+
+	for_each_online_cpu(cpu) {
+		ee = raw_data[cpu];
+		ee <<= HFI_EFFICIENCY_SHIFT;
+		do_div(ee, ee_scale);
+		raw_data[cpu] = ee;
+	}
+}
+
+static void update_energy_efficiency(void)
+{
+	struct hfi_hdr *hdr = hfi_params.hdr;
+	int cpu;
+
+	if (!hdr->ee_updated)
+		return;
+
+	/* Get data from the HFI table */
+	for_each_online_cpu(cpu) {
+		struct hfi_cpu_data *data;
+		s16 index;
+
+		index = per_cpu(hfi_cpu_index, cpu);
+		data = hfi_params.data + index * hfi_params.cpu_stride;
+		raw_data[cpu] = data->ee_cap;
+	}
+
+	scale_energy_efficiency();
+
+	for_each_online_cpu(cpu) {
+		struct em_perf_domain *em_pd;
+		unsigned long eff;
+
+		/*
+		 * Energy efficiency ratings are higher for more efficient CPUs. The
+		 * energy model expects lower ratings for more efficient CPUs. Invert
+		 * it.
+		 */
+		eff = (SCHED_CAPACITY_SCALE << 1) -  raw_data[cpu];
+
+		em_pd = em_cpu_get(cpu);
+		if (!em_pd)
+			em_dev_register_perf_domain_simple(get_cpu_device(cpu),
+							   topology_type_cpumask(cpu),
+							   eff);
+		else
+			em_dev_perf_domain_update_energy_rating(get_cpu_device(cpu),
+								eff);
+	}
+
+	hdr->ee_updated = 0;
+}
+
 static int get_hfi_performance_cap(void)
 {
 	u32 max_perf = 0;
@@ -167,6 +237,7 @@ static void hfi_update_work_fn(struct work_struct *work)
 	hfi_timestamp = *hfi_params.ts_counter;
 
 	update_capacity();
+	update_energy_efficiency();
 
 	/*
 	 * Using the HFI means that not all CPUs will have the same capacity.
@@ -212,6 +283,22 @@ void intel_hfi_check_event(__u64 pkg_therm_status_msr_val)
 	schedule_delayed_work(&hfi_update_work, HFI_UPDATE_DELAY);
 }
 
+static void __init init_energy_model(void)
+{
+	struct hfi_hdr *hdr = hfi_params.hdr;
+
+	/*
+	 * TODO: Rework the energy efficiency updates witout having to check
+	 * if there is a performance domain for a given CPU every time.
+	 */
+	/*
+	 * At this point the HFI interrupt has not been enabled. Thus, we own
+	 * the HFI memory and can change it safely.
+	 */
+	hdr->ee_updated = 1;
+	update_energy_efficiency();
+}
+
 void enable_hfi(void)
 {
 	u64 msr_val;
@@ -352,6 +439,8 @@ static void __init intel_hfi_init(void)
 
 	init_hfi_params(table_base, capabilities);
 
+	init_energy_model();
+
 	return;
 
 free_raw_data:
-- 
2.27.0

