From c0446621df5a74738b6d14b4b492b035c1e09825 Mon Sep 17 00:00:00 2001
From: Srikanth Thokala <srikanth.thokala@intel.com>
Date: Sat, 7 Nov 2020 03:32:00 +0530
Subject: [PATCH 164/223] mxlk: xlink-pcie: v1 and v2 review comments

Signed-off-by: Srikanth Thokala <srikanth.thokala@intel.com>
---
 drivers/misc/xlink-pcie/common/core.h        | 10 +-
 drivers/misc/xlink-pcie/local_host/Makefile  |  2 -
 drivers/misc/xlink-pcie/local_host/core.c    |  3 -
 drivers/misc/xlink-pcie/local_host/dma.c     | 96 ++++++++++----------
 drivers/misc/xlink-pcie/local_host/epf.c     | 54 +++--------
 drivers/misc/xlink-pcie/remote_host/Makefile |  2 -
 drivers/misc/xlink-pcie/remote_host/main.c   | 30 +++---
 include/linux/xlink_drv_inf.h                | 22 ++---
 8 files changed, 90 insertions(+), 129 deletions(-)

diff --git a/drivers/misc/xlink-pcie/common/core.h b/drivers/misc/xlink-pcie/common/core.h
index ca381336879f..34b6c268aac5 100644
--- a/drivers/misc/xlink-pcie/common/core.h
+++ b/drivers/misc/xlink-pcie/common/core.h
@@ -10,15 +10,11 @@
 #ifndef XPCIE_CORE_HEADER_
 #define XPCIE_CORE_HEADER_
 
-#include <linux/io.h>
-#include <linux/types.h>
-#include <linux/workqueue.h>
-#include <linux/slab.h>
-#include <linux/mutex.h>
-#include <linux/mempool.h>
 #include <linux/dma-mapping.h>
-#include <linux/cache.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
 #include <linux/wait.h>
+#include <linux/workqueue.h>
 
 #include <linux/xlink_drv_inf.h>
 
diff --git a/drivers/misc/xlink-pcie/local_host/Makefile b/drivers/misc/xlink-pcie/local_host/Makefile
index 133530a3611c..16bb1e7345ac 100644
--- a/drivers/misc/xlink-pcie/local_host/Makefile
+++ b/drivers/misc/xlink-pcie/local_host/Makefile
@@ -1,5 +1,3 @@
-ccflags-y += -Wall -Wno-unused-function -Werror
-
 obj-$(CONFIG_XLINK_PCIE_LH_DRIVER) += mxlk_ep.o
 mxlk_ep-objs := epf.o
 mxlk_ep-objs += dma.o
diff --git a/drivers/misc/xlink-pcie/local_host/core.c b/drivers/misc/xlink-pcie/local_host/core.c
index 62a29a8c3477..b99ed8596a02 100644
--- a/drivers/misc/xlink-pcie/local_host/core.c
+++ b/drivers/misc/xlink-pcie/local_host/core.c
@@ -7,10 +7,7 @@
  *
  ****************************************************************************/
 
-#include <linux/uaccess.h>
-#include <linux/delay.h>
 #include <linux/of_reserved_mem.h>
-#include <linux/interrupt.h>
 
 #include "epf.h"
 #include "../common/core.h"
diff --git a/drivers/misc/xlink-pcie/local_host/dma.c b/drivers/misc/xlink-pcie/local_host/dma.c
index ffb3cc48b85b..58693c4d92d5 100644
--- a/drivers/misc/xlink-pcie/local_host/dma.c
+++ b/drivers/misc/xlink-pcie/local_host/dma.c
@@ -6,9 +6,9 @@
  * Copyright (C) 2020 Intel Corporation
  *
  ****************************************************************************/
+#include <linux/delay.h>
 #include <linux/interrupt.h>
 #include <linux/wait.h>
-#include <linux/delay.h>
 
 #include "epf.h"
 
@@ -85,6 +85,7 @@
 #define PM_LINKST_IN_L1			BIT(10)
 
 #define DMA_POLLING_TIMEOUT		1000000
+#define DMA_ENABLE_TIMEOUT		1000
 
 struct __packed pcie_dma_reg {
 	u32 dma_ctrl_data_arb_prior;
@@ -168,18 +169,20 @@ static int intel_xpcie_ep_dma_disable(void __iomem *dma_base,
 	int i;
 	struct __iomem pcie_dma_reg * dma_reg =
 				(struct __iomem pcie_dma_reg *)dma_base;
-	void __iomem *engine_en = (void __iomem *)((rw == WRITE_ENGINE) ?
-					&dma_reg->dma_write_engine_en :
-					&dma_reg->dma_read_engine_en);
-	void __iomem *int_mask = (void __iomem *)((rw == WRITE_ENGINE) ?
-					&dma_reg->dma_write_int_mask :
-					&dma_reg->dma_read_int_mask);
-	void __iomem *int_clear = (void __iomem *)((rw == WRITE_ENGINE) ?
-					&dma_reg->dma_write_int_clear :
-					&dma_reg->dma_read_int_clear);
-	void __iomem *ll_err = (void __iomem *)((rw == WRITE_ENGINE) ?
-					&dma_reg->dma_write_linked_list_err_en :
-					&dma_reg->dma_read_linked_list_err_en);
+	void __iomem *engine_en, *ll_err;
+	void __iomem *int_mask, *int_clear;
+
+	if (rw == WRITE_ENGINE) {
+		engine_en = (void __iomem *)&dma_reg->dma_write_engine_en;
+		int_mask = (void __iomem *)&dma_reg->dma_write_int_mask;
+		int_clear = (void __iomem *)&dma_reg->dma_write_int_clear;
+		ll_err = (void __iomem *)&dma_reg->dma_write_linked_list_err_en;
+	} else {
+		engine_en = (void __iomem *)&dma_reg->dma_read_engine_en;
+		int_mask = (void __iomem *)&dma_reg->dma_read_int_mask;
+		int_clear = (void __iomem *)&dma_reg->dma_read_int_clear;
+		ll_err = (void __iomem *)&dma_reg->dma_read_linked_list_err_en;
+	}
 
 	iowrite32(0x0, engine_en);
 
@@ -193,7 +196,7 @@ static int intel_xpcie_ep_dma_disable(void __iomem *dma_base,
 	iowrite32(0, ll_err);
 
 	/* Wait until the engine is disabled. */
-	for (i = 0; i < 1000; i++) {
+	for (i = 0; i < DMA_ENABLE_TIMEOUT; i++) {
 		if (!(ioread32(engine_en) & DMA_ENGINE_EN_MASK))
 			return 0;
 		msleep(20);
@@ -207,27 +210,30 @@ static void intel_xpcie_ep_dma_enable(void __iomem *dma_base,
 {
 	struct __iomem pcie_dma_reg * dma_reg =
 				(struct __iomem pcie_dma_reg *)(dma_base);
-	void __iomem *engine_en = (void __iomem *)((rw == WRITE_ENGINE) ?
-					&dma_reg->dma_write_engine_en :
-					&dma_reg->dma_read_engine_en);
-	void __iomem *int_mask = (void __iomem *)((rw == WRITE_ENGINE) ?
-					&dma_reg->dma_write_int_mask :
-					&dma_reg->dma_read_int_mask);
-	void __iomem *int_clear = (void __iomem *)((rw == WRITE_ENGINE) ?
-					&dma_reg->dma_write_int_clear :
-					&dma_reg->dma_read_int_clear);
-	void __iomem *ll_err = (void __iomem *)((rw == WRITE_ENGINE) ?
-					&dma_reg->dma_write_linked_list_err_en :
-					&dma_reg->dma_read_linked_list_err_en);
-	void __iomem *arb_weight = (void __iomem *)((rw == WRITE_ENGINE) ?
-				&dma_reg->dma_write_channel_arb_weight_low :
-				&dma_reg->dma_read_channel_arb_weight_low);
-	u32 weight = (rw == WRITE_ENGINE) ? DMA_CHAN_WRITE_ALL_MAX_WEIGHT :
-					    DMA_CHAN_READ_ALL_MAX_WEIGHT;
+	void __iomem *engine_en, *ll_err, *arb_weight;
+	void __iomem *int_mask, *int_clear;
 	struct __iomem pcie_dma_chan * dma_chan;
-	u32 offset;
+	u32 offset, weight;
 	int i;
 
+	if (rw == WRITE_ENGINE) {
+		engine_en = (void __iomem *)&dma_reg->dma_write_engine_en;
+		int_mask = (void __iomem *)&dma_reg->dma_write_int_mask;
+		int_clear = (void __iomem *)&dma_reg->dma_write_int_clear;
+		ll_err = (void __iomem *)&dma_reg->dma_write_linked_list_err_en;
+		arb_weight = (void __iomem *)
+			     &dma_reg->dma_write_channel_arb_weight_low;
+		weight = DMA_CHAN_WRITE_ALL_MAX_WEIGHT;
+	} else {
+		engine_en = (void __iomem *)&dma_reg->dma_read_engine_en;
+		int_mask = (void __iomem *)&dma_reg->dma_read_int_mask;
+		int_clear = (void __iomem *)&dma_reg->dma_read_int_clear;
+		ll_err = (void __iomem *)&dma_reg->dma_read_linked_list_err_en;
+		arb_weight = (void __iomem *)
+			     &dma_reg->dma_read_channel_arb_weight_low;
+		weight = DMA_CHAN_READ_ALL_MAX_WEIGHT;
+	}
+
 	iowrite32(DMA_ENGINE_EN_MASK, engine_en);
 
 	/* Unmask all interrupts, so that the interrupt line gets asserted. */
@@ -387,7 +393,11 @@ int intel_xpcie_ep_dma_write_ll(struct pci_epf *epf, int chan, int descs_num)
 		  (void __iomem *)&dma_reg->dma_write_int_clear);
 
 	if (rc) {
-		intel_xpcie_ep_dma_disable(dma_base, WRITE_ENGINE);
+		if (intel_xpcie_ep_dma_disable(dma_base, WRITE_ENGINE)) {
+			dev_err(&xpcie_epf->epf->dev,
+				"failed to disable WR DMA\n");
+			return rc;
+		}
 		intel_xpcie_ep_dma_enable(dma_base, WRITE_ENGINE);
 	}
 
@@ -454,7 +464,11 @@ int intel_xpcie_ep_dma_read_ll(struct pci_epf *epf, int chan, int descs_num)
 		  (void __iomem *)&dma_reg->dma_read_int_clear);
 
 	if (rc) {
-		intel_xpcie_ep_dma_disable(dma_base, READ_ENGINE);
+		if (intel_xpcie_ep_dma_disable(dma_base, READ_ENGINE)) {
+			dev_err(&xpcie_epf->epf->dev,
+				"failed to disable RD DMA\n");
+			return rc;
+		}
 		intel_xpcie_ep_dma_enable(dma_base, READ_ENGINE);
 	}
 
@@ -520,20 +534,6 @@ static int intel_xpcie_ep_dma_alloc_ll_descs_mem(struct xpcie_epf *xpcie_epf)
 	return 0;
 }
 
-static bool intel_xpcie_ep_dma_enabled(struct pci_epf *epf)
-{
-	struct xpcie_epf *xpcie_epf = epf_get_drvdata(epf);
-	void __iomem *w_engine_en, *r_engine_en;
-	struct __iomem pcie_dma_reg * dma_reg =
-			(struct __iomem pcie_dma_reg *)(xpcie_epf->dma_base);
-
-	r_engine_en = (void __iomem *)&dma_reg->dma_read_engine_en;
-	w_engine_en = (void __iomem *)&dma_reg->dma_write_engine_en;
-
-	return (ioread32(w_engine_en) & DMA_ENGINE_EN_MASK) &&
-		(ioread32(r_engine_en) & DMA_ENGINE_EN_MASK);
-}
-
 int intel_xpcie_ep_dma_reset(struct pci_epf *epf)
 {
 	struct xpcie_epf *xpcie_epf = epf_get_drvdata(epf);
diff --git a/drivers/misc/xlink-pcie/local_host/epf.c b/drivers/misc/xlink-pcie/local_host/epf.c
index 0d16bf6103c0..cf0e7788c612 100644
--- a/drivers/misc/xlink-pcie/local_host/epf.c
+++ b/drivers/misc/xlink-pcie/local_host/epf.c
@@ -7,8 +7,8 @@
  *
  ****************************************************************************/
 
-#include <linux/platform_device.h>
 #include <linux/of.h>
+#include <linux/platform_device.h>
 #include <linux/reboot.h>
 
 #include "epf.h"
@@ -128,31 +128,6 @@ static irqreturn_t intel_xpcie_host_interrupt(int irq, void *args)
 	return IRQ_HANDLED;
 }
 
-static void __iomem *intel_xpcie_epc_alloc_addr(struct pci_epc *epc,
-						phys_addr_t *phys_addr,
-						size_t size)
-{
-	void __iomem *virt_addr;
-	unsigned long flags;
-
-	spin_lock_irqsave(&epc->lock, flags);
-	virt_addr = pci_epc_mem_alloc_addr(epc, phys_addr, size);
-	spin_unlock_irqrestore(&epc->lock, flags);
-
-	return virt_addr;
-}
-
-static void intel_xpcie_epc_free_addr(struct pci_epc *epc,
-				      phys_addr_t phys_addr,
-				      void __iomem *virt_addr, size_t size)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&epc->lock, flags);
-	pci_epc_mem_free_addr(epc, phys_addr, virt_addr, size);
-	spin_unlock_irqrestore(&epc->lock, flags);
-}
-
 static int intel_xpcie_check_bar(struct pci_epf *epf,
 				 struct pci_epf_bar *epf_bar,
 				 enum pci_barno barno,
@@ -216,9 +191,8 @@ static void intel_xpcie_cleanup_bar(struct pci_epf *epf, enum pci_barno barno)
 	if (xpcie_epf->vaddr[barno]) {
 		pci_epc_clear_bar(epc, epf->func_no, &epf->bar[barno]);
 		pci_epf_free_space(epf, xpcie_epf->vaddr[barno], barno);
+		xpcie_epf->vaddr[barno] = NULL;
 	}
-
-	xpcie_epf->vaddr[barno] = NULL;
 }
 
 static void intel_xpcie_cleanup_bars(struct pci_epf *epf)
@@ -248,14 +222,12 @@ static int intel_xpcie_setup_bar(struct pci_epf *epf, enum pci_barno barno,
 		bar->flags |= PCI_BASE_ADDRESS_MEM_PREFETCH;
 
 	vaddr = pci_epf_alloc_space(epf, bar->size, barno, align);
-
 	if (!vaddr) {
 		dev_err(&epf->dev, "Failed to map BAR%d\n", barno);
 		return -ENOMEM;
 	}
 
 	ret = pci_epc_set_bar(epc, epf->func_no, bar);
-
 	if (ret) {
 		pci_epf_free_space(epf, vaddr, barno);
 		dev_err(&epf->dev, "Failed to set BAR%d\n", barno);
@@ -335,7 +307,7 @@ static int intel_xpcie_epf_get_platform_data(struct device *dev,
 	if (IS_ERR(xpcie_epf->dbi_base))
 		return PTR_ERR(xpcie_epf->dbi_base);
 
-	memcpy(xpcie_epf->stepping, "B0", strlen("B0"));
+	memcpy(xpcie_epf->stepping, "B0", 2);
 	soc_node = of_get_parent(pdev->dev.of_node);
 	if (soc_node) {
 		version_node = of_get_child_by_name(soc_node, "version-info");
@@ -357,9 +329,9 @@ static int intel_xpcie_epf_bind(struct pci_epf *epf)
 	struct xpcie_epf *xpcie_epf = epf_get_drvdata(epf);
 	const struct pci_epc_features *features;
 	struct pci_epc *epc = epf->epc;
-	struct device *dev;
-	size_t align;
 	u32 bus_num, dev_num;
+	struct device *dev;
+	size_t align = SZ_16K;
 	int ret;
 
 	if (WARN_ON_ONCE(!epc))
@@ -425,11 +397,13 @@ static int intel_xpcie_epf_bind(struct pci_epf *epf)
 	dev_num = (ret >> PCIE_CFG_PBUS_DEV_NUM_OFFSET) &
 			PCIE_CFG_PBUS_DEV_NUM_MASK;
 
-	xlink_sw_id = (XLINK_DEV_INF_PCIE << XLINK_DEV_INF_TYPE_SHIFT) |
-		   ((bus_num << 8 | dev_num) << XLINK_DEV_PHYS_ID_SHIFT) |
-		   (XLINK_DEV_TYPE_KMB << XLINK_DEV_TYPE_SHIFT) |
-		   (XLINK_DEV_SLICE_0 << XLINK_DEV_SLICE_ID_SHIFT) |
-		   (XLINK_DEV_FUNC_VPU << XLINK_DEV_FUNC_SHIFT);
+	xlink_sw_id = FIELD_PREP(XLINK_DEV_INF_TYPE_MASK,
+			      XLINK_DEV_INF_PCIE) |
+		      FIELD_PREP(XLINK_DEV_PHYS_ID_MASK,
+				 bus_num << 8 | dev_num) |
+		      FIELD_PREP(XLINK_DEV_TYPE_MASK, XLINK_DEV_TYPE_KMB) |
+		      FIELD_PREP(XLINK_DEV_PCIE_ID_MASK, XLINK_DEV_PCIE_0) |
+		      FIELD_PREP(XLINK_DEV_FUNC_MASK, XLINK_DEV_FUNC_VPU);
 
 	ret = intel_xpcie_core_init(&xpcie_epf->xpcie);
 	if (ret) {
@@ -536,7 +510,7 @@ static struct pci_epf_driver xpcie_epf_driver = {
 
 static int __init intel_xpcie_epf_init(void)
 {
-	int ret = -EBUSY;
+	int ret;
 
 	ret = pci_epf_register_driver(&xpcie_epf_driver);
 	if (ret) {
@@ -555,6 +529,6 @@ static void __exit intel_xpcie_epf_exit(void)
 module_exit(intel_xpcie_epf_exit);
 
 MODULE_LICENSE("GPL");
-MODULE_AUTHOR("Intel");
+MODULE_AUTHOR("Intel Corporation");
 MODULE_DESCRIPTION(XPCIE_DRIVER_DESC);
 MODULE_VERSION(XPCIE_DRIVER_VERSION);
diff --git a/drivers/misc/xlink-pcie/remote_host/Makefile b/drivers/misc/xlink-pcie/remote_host/Makefile
index 0b6c0c32705f..088e121ad46e 100644
--- a/drivers/misc/xlink-pcie/remote_host/Makefile
+++ b/drivers/misc/xlink-pcie/remote_host/Makefile
@@ -1,5 +1,3 @@
-ccflags-y += -Wall -Wno-unused-function -Werror
-
 obj-$(CONFIG_XLINK_PCIE_RH_DRIVER) += mxlk.o
 mxlk-objs := main.o
 mxlk-objs += pci.o
diff --git a/drivers/misc/xlink-pcie/remote_host/main.c b/drivers/misc/xlink-pcie/remote_host/main.c
index 22dfe6fd884e..421635321f1b 100644
--- a/drivers/misc/xlink-pcie/remote_host/main.c
+++ b/drivers/misc/xlink-pcie/remote_host/main.c
@@ -10,28 +10,32 @@
 #include "pci.h"
 #include "../common/core.h"
 
+#define HW_ID_LO_MASK	GENMASK(7, 0)
+#define HW_ID_HI_MASK	GENMASK(15, 8)
+
 static const struct pci_device_id xpcie_pci_table[] = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_KEEMBAY), 0 },
 	{ 0 }
 };
 
-static bool driver_unload;
-
 static int intel_xpcie_probe(struct pci_dev *pdev,
 			     const struct pci_device_id *ent)
 {
 	bool new_device = false;
 	struct xpcie_dev *xdev;
-	u32 hw_id, sw_devid;
+	u32 sw_devid;
+	u16 hw_id;
 	int ret;
 
-	hw_id = ((u16)pdev->bus->number << 8) | PCI_SLOT(pdev->devfn);
+	hw_id = FIELD_PREP(HW_ID_HI_MASK, pdev->bus->number) |
+		FIELD_PREP(HW_ID_LO_MASK, PCI_SLOT(pdev->devfn));
 
-	sw_devid = (XLINK_DEV_INF_PCIE << XLINK_DEV_INF_TYPE_SHIFT) |
-		   (hw_id << XLINK_DEV_PHYS_ID_SHIFT) |
-		   (XLINK_DEV_TYPE_KMB << XLINK_DEV_TYPE_SHIFT) |
-		   (XLINK_DEV_SLICE_0 << XLINK_DEV_SLICE_ID_SHIFT) |
-		   (XLINK_DEV_FUNC_VPU << XLINK_DEV_FUNC_SHIFT);
+	sw_devid = FIELD_PREP(XLINK_DEV_INF_TYPE_MASK,
+			      XLINK_DEV_INF_PCIE) |
+		   FIELD_PREP(XLINK_DEV_PHYS_ID_MASK, hw_id) |
+		   FIELD_PREP(XLINK_DEV_TYPE_MASK, XLINK_DEV_TYPE_KMB) |
+		   FIELD_PREP(XLINK_DEV_PCIE_ID_MASK, XLINK_DEV_PCIE_0) |
+		   FIELD_PREP(XLINK_DEV_FUNC_MASK, XLINK_DEV_FUNC_VPU);
 
 	xdev = intel_xpcie_get_device_by_id(sw_devid);
 	if (!xdev) {
@@ -62,11 +66,8 @@ static void intel_xpcie_remove(struct pci_dev *pdev)
 
 	if (xdev) {
 		intel_xpcie_pci_cleanup(xdev);
-
 		intel_xpcie_pci_notify_event(xdev, NOTIFY_DEVICE_DISCONNECTED);
-
-		if (driver_unload)
-			intel_xpcie_remove_device(xdev);
+		intel_xpcie_remove_device(xdev);
 	}
 }
 
@@ -84,13 +85,12 @@ static int __init intel_xpcie_init_module(void)
 
 static void __exit intel_xpcie_exit_module(void)
 {
-	driver_unload = true;
 	pci_unregister_driver(&xpcie_driver);
 }
 
 module_init(intel_xpcie_init_module);
 module_exit(intel_xpcie_exit_module);
 MODULE_LICENSE("GPL");
-MODULE_AUTHOR("Intel");
+MODULE_AUTHOR("Intel Corporation");
 MODULE_DESCRIPTION(XPCIE_DRIVER_DESC);
 MODULE_VERSION(XPCIE_DRIVER_VERSION);
diff --git a/include/linux/xlink_drv_inf.h b/include/linux/xlink_drv_inf.h
index cf1ccda2a228..1a13ed25a56c 100644
--- a/include/linux/xlink_drv_inf.h
+++ b/include/linux/xlink_drv_inf.h
@@ -10,18 +10,16 @@
 #ifndef _XLINK_DRV_INF_H_
 #define _XLINK_DRV_INF_H_
 
+#include <linux/bitfield.h>
+#include <linux/bits.h>
 #include <linux/types.h>
 
-#define XLINK_DEV_INF_TYPE_SHIFT (24)
-#define XLINK_DEV_INT_TYPE_MASK (0x7)
-#define XLINK_DEV_PHYS_ID_SHIFT (8)
-#define XLINK_DEV_PHYS_ID_MASK (0xFFFF)
-#define XLINK_DEV_TYPE_SHIFT (4)
-#define XLINK_DEV_TYPE_MASK (0xF)
-#define XLINK_DEV_SLICE_ID_SHIFT (1)
-#define XLINK_DEV_SLICE_ID_MASK (0x7)
-#define XLINK_DEV_FUNC_SHIFT (0)
-#define XLINK_DEV_FUNC_MASK (0x1)
+#define XLINK_DEV_INF_TYPE_MASK		GENMASK(27, 24)
+#define XLINK_DEV_PHYS_ID_MASK		GENMASK(23, 8)
+#define XLINK_DEV_TYPE_MASK		GENMASK(6, 4)
+#define XLINK_DEV_PCIE_ID_MASK		GENMASK(3, 1)
+#define XLINK_DEV_FUNC_MASK		GENMASK(0, 0)
+
 
 enum xlink_device_inf_type {
 	XLINK_DEV_INF_PCIE = 1,
@@ -31,8 +29,8 @@ enum xlink_device_type {
 	XLINK_DEV_TYPE_KMB = 0,
 };
 
-enum xlink_device_slice {
-	XLINK_DEV_SLICE_0 = 0,
+enum xlink_device_pcie {
+	XLINK_DEV_PCIE_0 = 0,
 };
 
 enum xlink_device_func {
-- 
2.27.0

