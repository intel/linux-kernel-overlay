From 1648baf69df8a0f7f7fe74b5ce16ce99f420d06b Mon Sep 17 00:00:00 2001
From: Ricardo Neri <ricardo.neri-calderon@linux.intel.com>
Date: Mon, 19 Jun 2017 14:54:33 -0700
Subject: [PATCH 10/68] x86/cpu/intel: Add function to get name of hybrid CPU
 types

Provided a human-friendly string name for each type of CPU
microarchitecture in Intel hybrid parts. This string is to be used in the
CPU type sysfs interface.

In order to uniquely identify CPUs of the same type, compose the name
string as <cpu_type_name>_<native_model_id_nr>.

Cc: Andi Kleen <ak@linux.intel.com>
Cc: Andy Shevchenko <andriy.shevchenko@intel.com>
Cc: Aubrey Li <aubrey.li@linux.intel.com>
Cc: Chen Yu <yu.c.chen@intel.com>
Cc: Dave Hansen <dave.hansen@intel.com>
Cc: Kan Liang <kan.liang@linux.intel.com>
Cc: Len Brown <len.brown@intel.com>
Cc: "Rafael J. Wysocki" <rafael.j.wysocki@intel.com>
Cc: "Ravi V. Shankar" <ravi.v.shankar@intel.com>
Cc: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Cc: Tony Luck <tony.luck@intel.com>
Signed-off-by: Ricardo Neri <ricardo.neri-calderon@linux.intel.com>
---
Changes since v2:
 * Include the native model ID in the name of the CPU type.

---
Changes before submitting this series independently:

Changes since v3:
 * Merged patch adding the CPU type definitions into the patch
   implementing the function returning the CPU type
   (intel_get_hybrid_cpu_type_name()). (Tony, Dave)

Changes since v2:
 * Simplified logic to determine the name string with a switch. (Tony)
 * Removed verification for valid CPU type. (Andi)

Changes since v1:
 * Removed _FAM6_ portion from the definition names. (Dave)
 * Removed unnecessary INTEL_HYBRID_TYPE_NONHYBRID definition. (Dave)
 * Removed Quark and Knights CPU type definitions.
 * Use ARRAY_SIZE instead the largest CPU type definition. (Andy)
 * Verify that the CPU type is valid.
 * Simplified name of CPY types. These names will be used in the topology
   sysfs entries. Also, kept the intel_ prefix as other vendors could also
   offer hybrid CPUs.
---
 arch/x86/include/asm/intel-family.h |  4 ++++
 arch/x86/include/asm/processor.h    |  1 +
 arch/x86/kernel/cpu/cpu.h           |  3 +++
 arch/x86/kernel/cpu/intel.c         | 23 +++++++++++++++++++++++
 4 files changed, 31 insertions(+)

diff --git a/arch/x86/include/asm/intel-family.h b/arch/x86/include/asm/intel-family.h
index 9abe842dbd84..b5fb475bdf10 100644
--- a/arch/x86/include/asm/intel-family.h
+++ b/arch/x86/include/asm/intel-family.h
@@ -134,4 +134,8 @@
 /* Family 5 */
 #define INTEL_FAM5_QUARK_X1000		0x09 /* Quark X1000 SoC */
 
+/* Types of CPUs in hybrid parts. */
+#define INTEL_HYBRID_TYPE_ATOM		0x20
+#define INTEL_HYBRID_TYPE_CORE		0x40
+
 #endif /* _ASM_X86_INTEL_FAMILY_H */
diff --git a/arch/x86/include/asm/processor.h b/arch/x86/include/asm/processor.h
index 84eed0222147..a4a52b86b583 100644
--- a/arch/x86/include/asm/processor.h
+++ b/arch/x86/include/asm/processor.h
@@ -167,6 +167,7 @@ enum cpuid_regs_idx {
 #define X86_VENDOR_UNKNOWN	0xff
 
 #define X86_HYBRID_CPU_TYPE_ID_SHIFT		24
+#define X86_HYBRID_CPU_NATIVE_MODEL_ID_MASK	0xffffff
 
 /*
  * capabilities of CPUs
diff --git a/arch/x86/kernel/cpu/cpu.h b/arch/x86/kernel/cpu/cpu.h
index 67944128876d..e3112afb5316 100644
--- a/arch/x86/kernel/cpu/cpu.h
+++ b/arch/x86/kernel/cpu/cpu.h
@@ -56,8 +56,11 @@ extern __ro_after_init enum tsx_ctrl_states tsx_ctrl_state;
 extern void __init tsx_init(void);
 extern void tsx_enable(void);
 extern void tsx_disable(void);
+extern const char *intel_get_hybrid_cpu_type_name(u32 cpu_type);
 #else
 static inline void tsx_init(void) { }
+static inline const char *intel_get_hybrid_cpu_type_name(u32 cpu_type)
+{ return NULL; }
 #endif /* CONFIG_CPU_SUP_INTEL */
 
 extern void get_cpu_cap(struct cpuinfo_x86 *c);
diff --git a/arch/x86/kernel/cpu/intel.c b/arch/x86/kernel/cpu/intel.c
index 446207f7f397..fbe992662b54 100644
--- a/arch/x86/kernel/cpu/intel.c
+++ b/arch/x86/kernel/cpu/intel.c
@@ -1269,3 +1269,26 @@ u32 get_hybrid_cpu_params(int cpu)
 	smp_call_function_single(cpu, __do_get_hybrid_params, &params, true);
 	return params;
 }
+
+static char hybrid_name[64];
+
+const char *intel_get_hybrid_cpu_type_name(u32 cpu_type)
+{
+	u32 native_model_id = cpu_type & X86_HYBRID_CPU_NATIVE_MODEL_ID_MASK;
+	u8 type = cpu_type >> X86_HYBRID_CPU_TYPE_ID_SHIFT;
+
+	switch (type) {
+	case INTEL_HYBRID_TYPE_ATOM:
+		snprintf(hybrid_name, sizeof(hybrid_name), "intel_atom_%u",
+			 native_model_id);
+		break;
+	case INTEL_HYBRID_TYPE_CORE:
+		snprintf(hybrid_name, sizeof(hybrid_name), "intel_core_%u",
+			 native_model_id);
+		break;
+	default:
+		return NULL;
+	}
+
+	return hybrid_name;
+}
-- 
2.27.0

