From c278f1322e2b29f3e046c490997e4ea86b1b8f47 Mon Sep 17 00:00:00 2001
From: "David E. Box" <david.e.box@linux.intel.com>
Date: Sun, 21 Mar 2021 09:50:42 -0700
Subject: [PATCH 15/16] platform/x86: Add Intel Software Defined Silicon driver

Intel Software Defined Silicon (SDSi) is a mechanism for configuring
silicon features with a license. The SDSi driver provides a per socket,
sysfs ABI for application access to the SDSi interface. The interface
provides registers that allow software to target the socket the license
applies to. License provisioning is done through a mailbox that will
configure the silicon feture upon verification of the license.

Signed-off-by: David E. Box <david.e.box@linux.intel.com>
---
 MAINTAINERS                       |   5 +
 drivers/platform/x86/Kconfig      |  10 +
 drivers/platform/x86/Makefile     |   1 +
 drivers/platform/x86/intel_sdsi.c | 369 ++++++++++++++++++++++++++++++
 4 files changed, 385 insertions(+)
 create mode 100644 drivers/platform/x86/intel_sdsi.c

diff --git a/MAINTAINERS b/MAINTAINERS
index b706dd20ff2b..e17c50fb65d5 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -9387,6 +9387,11 @@ S:	Maintained
 F:	arch/x86/include/asm/intel_scu_ipc.h
 F:	drivers/platform/x86/intel_scu_*
 
+INTEL SDSI DRIVER
+M:	"David E. Box" <david.e.box@linux.intel.com>
+S:	Maintained
+F:	drivers/platform/x86/intel_sdsi.c
+
 INTEL SPEED SELECT TECHNOLOGY
 M:	Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
 L:	platform-driver-x86@vger.kernel.org
diff --git a/drivers/platform/x86/Kconfig b/drivers/platform/x86/Kconfig
index 5f5271c410fc..1a04f8fabb69 100644
--- a/drivers/platform/x86/Kconfig
+++ b/drivers/platform/x86/Kconfig
@@ -748,6 +748,16 @@ config INTEL_OAKTRAIL
 	  enable/disable the Camera, WiFi, BT etc. devices. If in doubt, say Y
 	  here; it will only load on supported platforms.
 
+config INTEL_SDSI
+	tristate "INTEL SDSI"
+	select MFD_INTEL_PMT
+	help
+	  This driver provides support for the Intel Software Defined Silicon
+	  mailbox mechanism.
+
+	  To compile this driver as a module, choose M here: the module will
+	  be called intel_sdsi.
+
 config INTEL_VBTN
 	tristate "INTEL VIRTUAL BUTTON"
 	depends on ACPI
diff --git a/drivers/platform/x86/Makefile b/drivers/platform/x86/Makefile
index 84018bd18a25..79060e5903d6 100644
--- a/drivers/platform/x86/Makefile
+++ b/drivers/platform/x86/Makefile
@@ -76,6 +76,7 @@ obj-$(CONFIG_INTEL_HID_EVENT)		+= intel-hid.o
 obj-$(CONFIG_INTEL_INT0002_VGPIO)	+= intel_int0002_vgpio.o
 obj-$(CONFIG_INTEL_MENLOW)		+= intel_menlow.o
 obj-$(CONFIG_INTEL_OAKTRAIL)		+= intel_oaktrail.o
+obj-$(CONFIG_INTEL_SDSI)		+= intel_sdsi.o
 obj-$(CONFIG_INTEL_VBTN)		+= intel-vbtn.o
 
 # MSI
diff --git a/drivers/platform/x86/intel_sdsi.c b/drivers/platform/x86/intel_sdsi.c
new file mode 100644
index 000000000000..49823cf63f51
--- /dev/null
+++ b/drivers/platform/x86/intel_sdsi.c
@@ -0,0 +1,369 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Intel Software Defined Silicon driver
+ *
+ * Copyright (c) 2021, Intel Corporation.
+ * All Rights Reserved.
+ *
+ * Author: "David E. Box" <david.e.box@linux.intel.com>
+ */
+
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+//#include <linux/sysfs.h>
+#include <linux/uaccess.h>
+
+#define SDSI_DEV_NAME		"intel-vsec-41"
+#define ACCESS_TYPE_BARID	2
+
+#define SDSI_XA_START		0
+#define SDSI_XA_MAX		INT_MAX
+#define SDSI_XA_LIMIT		XA_LIMIT(SDSI_XA_START, SDSI_XA_MAX)
+#define SDSI_SIZE_CONTROL	8
+#define SDSI_SIZE_MAILBOX	1024
+#define SDSI_GET_OFFSET(v)	((v) << 3)
+#define SDSI_SIZE_REGS(v)	(((v) * 4) - SDSI_SIZE_MAILBOX - SDSI_SIZE_CONTROL)
+
+static DEFINE_XARRAY_ALLOC(sdsi_xa);
+
+struct intel_sdsi_disc_table {
+	u32	access_type:4;
+	u32	sdsi_type:8;
+	u32	size:16;
+	u32	reserved:4;
+	u32	guid:32;
+	u32	tbir:3;
+	u32	offset:29;
+} __attribute((packed))__;
+
+struct intel_sdsi_priv {
+	struct intel_sdsi_disc_table	disc_table;
+	struct mutex			mutex;
+	void __iomem			*sdsi_addr;
+	struct bin_attribute		control_bin_attr;
+	struct bin_attribute		mailbox_bin_attr;
+	struct bin_attribute		regs_bin_attr;
+	struct device			*dev;
+	int				reg_size;
+	int				devid;
+};
+
+static ssize_t guid_show(struct device *dev, struct device_attribute *attr,
+			 char *buf)
+{
+	struct intel_sdsi_priv *priv = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%d\n", priv->disc_table.guid);
+}
+static DEVICE_ATTR_RO(guid);
+
+static struct attribute *intel_sdsi_attrs[] = {
+	&dev_attr_guid.attr,
+	NULL
+};
+ATTRIBUTE_GROUPS(intel_sdsi);
+
+static struct class intel_sdsi_class = {
+	.name = "intel_sdsi",
+	.owner = THIS_MODULE,
+	.dev_groups = intel_sdsi_groups,
+};
+
+ssize_t intel_sdsi_control_read(struct file *filp, struct kobject *kobj,
+				struct bin_attribute *attr, char *buf, loff_t off,
+				size_t count)
+{
+	struct intel_sdsi_priv *priv = container_of(attr,
+						    struct intel_sdsi_priv,
+						    control_bin_attr);
+
+	if (off < 0)
+		return -EINVAL;
+
+	if (off >= attr->size)
+		return 0;
+
+	if (count > attr->size - off)
+		count = attr->size - off;
+
+	memcpy_fromio(buf, priv->sdsi_addr + off, count);
+
+	return count;
+}
+
+ssize_t intel_sdsi_control_write(struct file *filp, struct kobject *kobj,
+				 struct bin_attribute *attr, char *buf, loff_t off,
+				 size_t count)
+{
+	struct intel_sdsi_priv *priv = container_of(attr,
+						    struct intel_sdsi_priv,
+						    control_bin_attr);
+
+	if (off < 0)
+		return -EINVAL;
+
+	if (off >= attr->size)
+		return 0;
+
+	if (count > attr->size - off)
+		count = attr->size - off;
+
+	memcpy_toio(priv->sdsi_addr + off, buf, count);
+
+	return count;
+}
+
+ssize_t intel_sdsi_mailbox_read(struct file *filp, struct kobject *kobj,
+				struct bin_attribute *attr, char *buf, loff_t off,
+				size_t count)
+{
+	struct intel_sdsi_priv *priv = container_of(attr,
+						    struct intel_sdsi_priv,
+						    mailbox_bin_attr);
+	void __iomem *addr = priv->sdsi_addr + SDSI_SIZE_CONTROL;
+
+	if (off < 0)
+		return -EINVAL;
+
+	if (off >= attr->size)
+		return 0;
+
+	if (count > attr->size - off)
+		count = attr->size - off;
+
+	memcpy_fromio(buf, addr + off, count);
+
+	return count;
+}
+
+ssize_t intel_sdsi_mailbox_write(struct file *filp, struct kobject *kobj,
+				 struct bin_attribute *attr, char *buf, loff_t off,
+				 size_t count)
+{
+	struct intel_sdsi_priv *priv = container_of(attr,
+						    struct intel_sdsi_priv,
+						    mailbox_bin_attr);
+	void __iomem *addr = priv->sdsi_addr + SDSI_SIZE_CONTROL;
+
+	if (off < 0)
+		return -EINVAL;
+
+	if (off >= attr->size)
+		return 0;
+
+	if (count > attr->size - off)
+		count = attr->size - off;
+
+	memcpy_toio(addr + off, buf, count);
+
+	return count;
+}
+
+ssize_t intel_sdsi_registers_read(struct file *filp, struct kobject *kobj,
+				  struct bin_attribute *attr, char *buf, loff_t off,
+				  size_t count)
+{
+	struct intel_sdsi_priv *priv = container_of(attr,
+						    struct intel_sdsi_priv,
+						    regs_bin_attr);
+	void __iomem *addr = priv->sdsi_addr + SDSI_SIZE_CONTROL + SDSI_SIZE_MAILBOX;
+
+	if (off < 0)
+		return -EINVAL;
+
+	if (off >= attr->size)
+		return 0;
+
+	if (count > attr->size - off)
+		count = attr->size - off;
+
+	memcpy_fromio(buf, addr + off, count);
+
+	return count;
+}
+
+static int intel_sdsi_sysfs_register(struct platform_device *pdev)
+{
+	struct intel_sdsi_priv *priv = platform_get_drvdata(pdev);
+	struct intel_sdsi_disc_table *table = &priv->disc_table;
+	struct pci_dev *pci_dev = to_pci_dev(pdev->dev.parent);
+	struct resource res = {0};
+	struct device *dev;
+	u32 offset = SDSI_GET_OFFSET(table->offset);
+	int tbir = table->tbir;
+	int ret;
+
+	ret = xa_alloc(&sdsi_xa, &priv->devid, NULL, SDSI_XA_LIMIT, GFP_KERNEL);
+	if (ret)
+		return ret;
+
+	dev = device_create(&intel_sdsi_class, &pdev->dev, MKDEV(0, 0), priv,
+			    "socket-%d", priv->devid);
+
+	if (IS_ERR(dev)) {
+		dev_err(&pdev->dev, "Could not create socket-%d device node\n",
+			priv->devid);
+		ret = PTR_ERR(dev);
+		goto fail_dev_create;
+	}
+	priv->dev = dev;
+
+	res.start = pci_resource_start(pci_dev, tbir) + offset;
+	res.end = res.start + table->size - 1;
+	res.flags = IORESOURCE_MEM;
+
+	priv->sdsi_addr = devm_ioremap_resource(&pdev->dev, &res);
+	if (IS_ERR(priv->sdsi_addr)) {
+		ret = PTR_ERR(priv->sdsi_addr);
+		goto fail_ioremap;
+	}
+
+	sysfs_bin_attr_init(&priv->control_bin_attr);
+	priv->mailbox_bin_attr.attr.name = "control";
+	priv->mailbox_bin_attr.attr.mode = 0600;
+	priv->mailbox_bin_attr.read = intel_sdsi_control_read;
+	priv->mailbox_bin_attr.write = intel_sdsi_control_write;
+	priv->mailbox_bin_attr.size = SDSI_SIZE_CONTROL;
+	ret = sysfs_create_bin_file(&dev->kobj, &priv->mailbox_bin_attr);
+	if (ret)
+		goto fail_ioremap;
+
+	sysfs_bin_attr_init(&priv->mailbox_bin_attr);
+	priv->mailbox_bin_attr.attr.name = "mailbox";
+	priv->mailbox_bin_attr.attr.mode = 0600;
+	priv->mailbox_bin_attr.read = intel_sdsi_mailbox_read;
+	priv->mailbox_bin_attr.write = intel_sdsi_mailbox_write;
+	priv->mailbox_bin_attr.size = SDSI_SIZE_MAILBOX;
+	ret = sysfs_create_bin_file(&dev->kobj, &priv->mailbox_bin_attr);
+	if (ret)
+		goto fail_sysfs_mailbox;
+
+	sysfs_bin_attr_init(&priv->regs_bin_attr);
+	priv->regs_bin_attr.attr.name = "registers";
+	priv->regs_bin_attr.attr.mode = 0400;
+	priv->regs_bin_attr.read = intel_sdsi_registers_read;
+	priv->regs_bin_attr.size = priv->reg_size;
+	ret = sysfs_create_bin_file(&dev->kobj, &priv->regs_bin_attr);
+	if (ret)
+		goto fail_sysfs_registers;
+
+	return 0;
+
+fail_sysfs_registers:
+	sysfs_remove_bin_file(&priv->dev->kobj, &priv->mailbox_bin_attr);
+fail_sysfs_mailbox:
+	sysfs_remove_bin_file(&priv->dev->kobj, &priv->control_bin_attr);
+fail_ioremap:
+	device_unregister(dev);
+fail_dev_create:
+	xa_erase(&sdsi_xa, priv->devid);
+
+	return ret;
+}
+
+static int intel_sdsi_header_decode(struct platform_device *pdev,
+				    void __iomem *disc_addr)
+{
+	struct intel_sdsi_priv *priv = platform_get_drvdata(pdev);
+	u32 *table = (u32 *)&priv->disc_table;
+
+	table[0] = readl(disc_addr);
+	table[1] = readl(disc_addr + 4);
+	table[2] = readl(disc_addr + 8);
+
+	if (priv->disc_table.access_type != ACCESS_TYPE_BARID) {
+		dev_err(&pdev->dev, "Expected access_type %d, got %d\n",
+			ACCESS_TYPE_BARID, priv->disc_table.access_type);
+		return -EINVAL;
+	}
+
+	if (!priv->disc_table.size) {
+		dev_err(&pdev->dev, "size is 0\n");
+		return -EINVAL;
+	}
+
+	priv->reg_size = SDSI_SIZE_REGS(priv->disc_table.size);
+	if (priv->reg_size < 0) {
+		dev_err(&pdev->dev, "Error accessing registers\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int intel_sdsi_probe(struct platform_device *pdev)
+{
+	struct intel_sdsi_priv *priv;
+	void __iomem *disc_addr;
+	int ret;
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+	platform_set_drvdata(pdev, priv);
+
+	mutex_init(&priv->mutex);
+
+	disc_addr = devm_platform_get_and_ioremap_resource(pdev, 0, NULL);
+	if (IS_ERR(disc_addr))
+		return PTR_ERR(disc_addr);
+
+	ret = intel_sdsi_header_decode(pdev, disc_addr);
+	if (ret)
+		return ret;
+
+	ret = intel_sdsi_sysfs_register(pdev);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int intel_sdsi_remove(struct platform_device *pdev)
+{
+	struct intel_sdsi_priv *priv = platform_get_drvdata(pdev);
+
+	sysfs_remove_bin_file(&priv->dev->kobj, &priv->regs_bin_attr);
+	sysfs_remove_bin_file(&priv->dev->kobj, &priv->mailbox_bin_attr);
+	device_unregister(priv->dev);
+	xa_erase(&sdsi_xa, priv->devid);
+
+	return 0;
+}
+
+static struct platform_driver intel_sdsi_driver = {
+	.driver = {
+		.name   = SDSI_DEV_NAME,
+	},
+	.remove = intel_sdsi_remove,
+	.probe  = intel_sdsi_probe,
+};
+
+static int __init intel_sdsi_init(void)
+{
+	int err;
+
+	err = class_register(&intel_sdsi_class);
+	if (err)
+		return err;
+
+	return platform_driver_register(&intel_sdsi_driver);
+}
+module_init(intel_sdsi_init);
+
+static void __exit intel_sdsi_exit(void)
+{
+	platform_driver_unregister(&intel_sdsi_driver);
+	class_unregister(&intel_sdsi_class);
+	xa_destroy(&sdsi_xa);
+}
+module_exit(intel_sdsi_exit);
+
+MODULE_AUTHOR("David E. Box <david.e.box@linux.intel.com>");
+MODULE_DESCRIPTION("Intel Software Defined Silicon driver");
+MODULE_ALIAS("platform:intel_sdsi");
+MODULE_LICENSE("GPL v2");
-- 
2.27.0

