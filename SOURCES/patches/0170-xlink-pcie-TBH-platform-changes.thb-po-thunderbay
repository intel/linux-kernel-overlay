From 373f32f7f8485c1ee6de822987689aa210856f75 Mon Sep 17 00:00:00 2001
From: kadarlax <raghuveerx.kadarla@intel.com>
Date: Wed, 20 Jan 2021 13:21:05 +0530
Subject: [PATCH 170/223] xlink-pcie: TBH platform changes

Adding TBH platform changes.

Signed-off-by: kadarlax <raghuveerx.kadarla@intel.com>
---
 drivers/misc/xlink-pcie/Kconfig              |   6 +-
 drivers/misc/xlink-pcie/common/core.h        |   6 +-
 drivers/misc/xlink-pcie/common/interface.c   |   2 +-
 drivers/misc/xlink-pcie/common/util.c        |  92 ++++-
 drivers/misc/xlink-pcie/common/util.h        |  12 +-
 drivers/misc/xlink-pcie/common/xpcie.h       |  34 +-
 drivers/misc/xlink-pcie/local_host/Makefile  |   1 +
 drivers/misc/xlink-pcie/local_host/core.c    |  98 +++++-
 drivers/misc/xlink-pcie/local_host/dma.c     |  67 ++--
 drivers/misc/xlink-pcie/local_host/epf.c     | 345 +++++++++++++++++--
 drivers/misc/xlink-pcie/local_host/epf.h     |  31 +-
 drivers/misc/xlink-pcie/remote_host/Makefile |   2 +
 drivers/misc/xlink-pcie/remote_host/core.c   |   2 +-
 drivers/misc/xlink-pcie/remote_host/main.c   |  26 +-
 drivers/misc/xlink-pcie/remote_host/pci.c    |  52 ++-
 drivers/misc/xlink-pcie/remote_host/pci.h    |   8 +-
 include/linux/xlink_drv_inf.h                |  15 +
 17 files changed, 694 insertions(+), 105 deletions(-)

diff --git a/drivers/misc/xlink-pcie/Kconfig b/drivers/misc/xlink-pcie/Kconfig
index 448b9bfbdfa2..6feee3c48e16 100644
--- a/drivers/misc/xlink-pcie/Kconfig
+++ b/drivers/misc/xlink-pcie/Kconfig
@@ -7,14 +7,14 @@ config XLINK_PCIE_RH_DRIVER
 	  Choose M here to compile this driver as a module, name is mxlk.
 	  This driver is used for XLink communication over PCIe,
 	  and is to be loaded on the IA host which is connected to
-	  the Intel Keem Bay.
+	  the Intel XPCIe device.
 
 config XLINK_PCIE_LH_DRIVER
 	tristate "XLink PCIe Local Host driver"
-	depends on PCI_ENDPOINT && ARCH_KEEMBAY
+	depends on PCI_ENDPOINT && (ARCH_KEEMBAY || ARCH_THUNDERBAY)
 	help
 	  This option enables XLink PCIe Local Host driver.
 
 	  Choose M here to compile this driver as a module, name is mxlk_ep.
 	  This driver is used for XLink communication over PCIe and is to be
-	  loaded on the Intel Keem Bay platform.
+	  loaded on the Intel XPCIe platform.
diff --git a/drivers/misc/xlink-pcie/common/core.h b/drivers/misc/xlink-pcie/common/core.h
index 34b6c268aac5..3400a4838fb2 100644
--- a/drivers/misc/xlink-pcie/common/core.h
+++ b/drivers/misc/xlink-pcie/common/core.h
@@ -1,7 +1,7 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*****************************************************************************
  *
- * Intel Keem Bay XLink PCIe Driver
+ * Intel XPCIe XLink PCIe Driver
  *
  * Copyright (C) 2020 Intel Corporation
  *
@@ -233,7 +233,11 @@ int intel_xpcie_core_read(struct xpcie *xpcie, void *buffer, size_t *length,
 int intel_xpcie_core_write(struct xpcie *xpcie, void *buffer, size_t *length,
 			   u32 timeout_ms);
 u32 intel_xpcie_get_device_num(u32 *id_list);
+#if (IS_ENABLED(CONFIG_XLINK_PCIE_LH_DRIVER))
+struct xpcie_epf *intel_xpcie_get_device_by_id(u32 id);
+#else
 struct xpcie_dev *intel_xpcie_get_device_by_id(u32 id);
+#endif
 int intel_xpcie_get_device_name_by_id(u32 id, char *device_name,
 				      size_t name_size);
 int intel_xpcie_get_device_status_by_id(u32 id, u32 *status);
diff --git a/drivers/misc/xlink-pcie/common/interface.c b/drivers/misc/xlink-pcie/common/interface.c
index 4ad291ff97c8..b4d6b827bed8 100644
--- a/drivers/misc/xlink-pcie/common/interface.c
+++ b/drivers/misc/xlink-pcie/common/interface.c
@@ -1,7 +1,7 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*****************************************************************************
  *
- * Intel Keem Bay XLink PCIe Driver
+ * Intel XPCIe XLink PCIe Driver
  *
  * Copyright (C) 2020 Intel Corporation
  *
diff --git a/drivers/misc/xlink-pcie/common/util.c b/drivers/misc/xlink-pcie/common/util.c
index ec808b0cd72b..51cb318e6bc9 100644
--- a/drivers/misc/xlink-pcie/common/util.c
+++ b/drivers/misc/xlink-pcie/common/util.c
@@ -1,11 +1,11 @@
 // SPDX-License-Identifier: GPL-2.0-only
-/*****************************************************************************
- *
- * Intel Keem Bay XLink PCIe Driver
+/*********************************************************************/
+/*
+ * Intel XPCIe XLink PCIe Driver
  *
  * Copyright (C) 2020 Intel Corporation
- *
- ****************************************************************************/
+ */
+/*********************************************************************/
 
 #include "util.h"
 
@@ -36,7 +36,10 @@ static size_t intel_xpcie_doorbell_offset(struct xpcie *xpcie,
 		return XPCIE_MMIO_DTOH_RX_DOORBELL;
 	if (dirt == FROM_DEVICE && type == DEV_EVENT)
 		return XPCIE_MMIO_DTOH_EVENT_DOORBELL;
-
+#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+	if (dirt == TO_DEVICE && type == PHY_ID_UPDATED)
+		return XPCIE_MMIO_HTOD_PHY_ID_DOORBELL_STATUS;
+#endif
 	return 0;
 }
 
@@ -92,7 +95,79 @@ struct xpcie_buf_desc *intel_xpcie_alloc_bd(size_t length)
 	return bd;
 }
 
-struct xpcie_buf_desc *intel_xpcie_alloc_bd_reuse(size_t length, void *virt,
+#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+u32 intel_xpcie_create_sw_device_id(u8 func_no, u16 phy_id,
+				    u8 max_functions)
+{
+	int sw_id = 0;
+
+	switch (func_no) {
+	case 0:
+		sw_id = sw_id |
+			(XLINK_DEV_SLICE_0 << XLINK_DEV_SLICE_ID_SHIFT);
+		break;
+	case 1:
+	case 2:
+		sw_id = sw_id |
+			(XLINK_DEV_SLICE_1 << XLINK_DEV_SLICE_ID_SHIFT);
+		break;
+	case 3:
+	case 4:
+		sw_id = sw_id |
+			(XLINK_DEV_SLICE_2 << XLINK_DEV_SLICE_ID_SHIFT);
+		break;
+	case 5:
+	case 6:
+		sw_id = sw_id |
+			(XLINK_DEV_SLICE_3 << XLINK_DEV_SLICE_ID_SHIFT);
+		break;
+	case 7:
+	default:
+		break;
+	}
+	/* all odd functions are media function */
+	if (func_no & 1)
+		sw_id = sw_id | (XLINK_DEV_FUNC_MEDIA << XLINK_DEV_FUNC_SHIFT);
+
+	/* physical id */
+	sw_id |= (phy_id << XLINK_DEV_PHYS_ID_SHIFT);
+
+	if (max_functions == 8)
+		sw_id = sw_id |
+			(XLINK_DEV_TYPE_THB_STANDARD << XLINK_DEV_TYPE_SHIFT);
+	else if (max_functions == 4)
+		sw_id = sw_id |
+			(XLINK_DEV_TYPE_THB_PRIME << XLINK_DEV_TYPE_SHIFT);
+
+	sw_id = sw_id | (XLINK_DEV_INF_PCIE << XLINK_DEV_INF_TYPE_SHIFT);
+
+	return sw_id;
+}
+
+void intel_xpcie_set_max_functions(struct xpcie *xpcie, u8 max_functions)
+{
+	intel_xpcie_iowrite8(max_functions,
+			     xpcie->mmio + XPCIE_MMIO_MAX_FUNCTIONS);
+}
+
+u8 intel_xpcie_get_max_functions(struct xpcie *xpcie)
+{
+	return intel_xpcie_ioread8(xpcie->mmio + XPCIE_MMIO_MAX_FUNCTIONS);
+}
+
+void intel_xpcie_set_physical_device_id(struct xpcie *xpcie, u16 phys_id)
+{
+	intel_xpcie_iowrite16(phys_id, xpcie->mmio + XPCIE_MMIO_PHY_DEV_ID);
+}
+
+u16 intel_xpcie_get_physical_device_id(struct xpcie *xpcie)
+{
+	return intel_xpcie_ioread8(xpcie->mmio + XPCIE_MMIO_PHY_DEV_ID);
+}
+#endif
+
+struct xpcie_buf_desc *intel_xpcie_alloc_bd_reuse(size_t length,
+						  void *virt,
 						  dma_addr_t phys)
 {
 	struct xpcie_buf_desc *bd;
@@ -148,7 +223,8 @@ void intel_xpcie_list_cleanup(struct xpcie_list *list)
 	spin_unlock(&list->lock);
 }
 
-int intel_xpcie_list_put(struct xpcie_list *list, struct xpcie_buf_desc *bd)
+int intel_xpcie_list_put(struct xpcie_list *list,
+			 struct xpcie_buf_desc *bd)
 {
 	if (!bd)
 		return -EINVAL;
diff --git a/drivers/misc/xlink-pcie/common/util.h b/drivers/misc/xlink-pcie/common/util.h
index 908be897a61d..303fbf5a1ebf 100644
--- a/drivers/misc/xlink-pcie/common/util.h
+++ b/drivers/misc/xlink-pcie/common/util.h
@@ -1,7 +1,7 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*****************************************************************************
  *
- * Intel Keem Bay XLink PCIe Driver
+ * Intel XPCIe XLink PCIe Driver
  *
  * Copyright (C) 2020 Intel Corporation
  *
@@ -20,6 +20,7 @@ enum xpcie_doorbell_direction {
 enum xpcie_doorbell_type {
 	DATA_SENT,
 	DATA_RECEIVED,
+	PHY_ID_UPDATED,
 	DEV_EVENT
 };
 
@@ -41,6 +42,15 @@ u32 intel_xpcie_get_device_status(struct xpcie *xpcie);
 u32 intel_xpcie_get_host_status(struct xpcie *xpcie);
 void intel_xpcie_set_host_status(struct xpcie *xpcie, u32 status);
 
+#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+
+void intel_xpcie_set_max_functions(struct xpcie *xpcie, u8 max_functions);
+u8 intel_xpcie_get_max_functions(struct xpcie *xpcie);
+u32 intel_xpcie_create_sw_device_id(u8 func_no, u16 phy_id, u8 max_functions);
+void intel_xpcie_set_physical_device_id(struct xpcie *xpcie, u16 phys_id);
+u16 intel_xpcie_get_physical_device_id(struct xpcie *xpcie);
+#endif
+
 struct xpcie_buf_desc *intel_xpcie_alloc_bd(size_t length);
 struct xpcie_buf_desc *intel_xpcie_alloc_bd_reuse(size_t length, void *virt,
 						  dma_addr_t phys);
diff --git a/drivers/misc/xlink-pcie/common/xpcie.h b/drivers/misc/xlink-pcie/common/xpcie.h
index ade0699c9156..b080ffed74d4 100644
--- a/drivers/misc/xlink-pcie/common/xpcie.h
+++ b/drivers/misc/xlink-pcie/common/xpcie.h
@@ -1,7 +1,7 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*****************************************************************************
  *
- * Intel Keem Bay XLink PCIe Driver
+ * Intel XPCIe XLink PCIe Driver
  *
  * Copyright (C) 2020 Intel Corporation
  *
@@ -13,6 +13,7 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/pci_ids.h>
+#include <linux/xlink_drv_inf.h>
 
 #include "core.h"
 
@@ -20,6 +21,14 @@
 #define PCI_DEVICE_ID_INTEL_KEEMBAY 0x6240
 #endif
 
+#ifndef PCI_DEVICE_ID_INTEL_TBH_FULL
+#define PCI_DEVICE_ID_INTEL_TBH_FULL 0x4FC0
+#endif
+
+#ifndef PCI_DEVICE_ID_INTEL_TBH_PRIME
+#define PCI_DEVICE_ID_INTEL_TBH_PRIME 0x4FC1
+#endif
+
 #define XPCIE_IO_COMM_SIZE SZ_16K
 #define XPCIE_MMIO_OFFSET SZ_4K
 
@@ -38,6 +47,10 @@
 struct xpcie_mmio {
 	u32 device_status;
 	u32 host_status;
+#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+	u16 phy_dev_id;
+	u8 max_functions;
+#endif
 	u8 legacy_a0;
 	u8 htod_tx_doorbell;
 	u8 htod_rx_doorbell;
@@ -45,10 +58,13 @@ struct xpcie_mmio {
 	u8 dtoh_tx_doorbell;
 	u8 dtoh_rx_doorbell;
 	u8 dtoh_event_doorbell;
+#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+	u8 htod_phy_id_doorbell_status;
+#endif
 	u8 reserved;
 	u32 cap_offset;
 	u8 magic[XPCIE_MAGIC_STRLEN];
-} __packed;
+} __packed __aligned(8);
 
 #define XPCIE_MMIO_LEGACY_A0	(offsetof(struct xpcie_mmio, legacy_a0))
 #define XPCIE_MMIO_DEV_STATUS	(offsetof(struct xpcie_mmio, device_status))
@@ -70,13 +86,25 @@ struct xpcie_mmio {
 #define XPCIE_MMIO_CAP_OFF	(offsetof(struct xpcie_mmio, cap_offset))
 #define XPCIE_MMIO_MAGIC_OFF	(offsetof(struct xpcie_mmio, magic))
 
+#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+
+#define XPCIE_MMIO_PHY_DEV_ID	(offsetof(struct xpcie_mmio, phy_dev_id))
+#define XPCIE_MMIO_MAX_FUNCTIONS \
+	(offsetof(struct xpcie_mmio, max_functions))
+#define XPCIE_MMIO_HTOD_PHY_ID_DOORBELL_STATUS \
+	(offsetof(struct xpcie_mmio, htod_phy_id_doorbell_status))
+#endif
+
 struct xpcie {
 	u32 status;
 	bool legacy_a0;
 	void *bar0;
 	void *mmio;
 	void *bar4;
-
+#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+	void __iomem *doorbell_base; /*IPC DoorBell address space*/
+	void __iomem *doorbell_clear; /*IPC DoorBell clear address space*/
+#endif
 	struct workqueue_struct *rx_wq;
 	struct workqueue_struct *tx_wq;
 
diff --git a/drivers/misc/xlink-pcie/local_host/Makefile b/drivers/misc/xlink-pcie/local_host/Makefile
index 16bb1e7345ac..f430414b9f76 100644
--- a/drivers/misc/xlink-pcie/local_host/Makefile
+++ b/drivers/misc/xlink-pcie/local_host/Makefile
@@ -1,3 +1,4 @@
+ccflags-y += -I$(srctree)/drivers/pci/controller/dwc
 obj-$(CONFIG_XLINK_PCIE_LH_DRIVER) += mxlk_ep.o
 mxlk_ep-objs := epf.o
 mxlk_ep-objs += dma.o
diff --git a/drivers/misc/xlink-pcie/local_host/core.c b/drivers/misc/xlink-pcie/local_host/core.c
index a343e30d8b45..e174fe0bd078 100644
--- a/drivers/misc/xlink-pcie/local_host/core.c
+++ b/drivers/misc/xlink-pcie/local_host/core.c
@@ -1,7 +1,7 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*****************************************************************************
  *
- * Intel Keem Bay XLink PCIe Driver
+ * Intel XPCIe XLink PCIe Driver
  *
  * Copyright (C) 2020 Intel Corporation
  *
@@ -15,10 +15,12 @@
 
 static struct xpcie *global_xpcie;
 
+#if (!IS_ENABLED(CONFIG_PCIE_TBH_EP))
 static struct xpcie *intel_xpcie_core_get_by_id(u32 sw_device_id)
 {
 	return (sw_device_id == xlink_sw_id) ? global_xpcie : NULL;
 }
+#endif
 
 static int intel_xpcie_map_dma(struct xpcie *xpcie, struct xpcie_buf_desc *bd,
 			       int direction)
@@ -58,7 +60,7 @@ static void intel_xpcie_set_cap_txrx(struct xpcie *xpcie)
 
 	next = (u16)(start + hdr_len + tx_len + rx_len);
 	intel_xpcie_iowrite32(start, xpcie->mmio + XPCIE_MMIO_CAP_OFF);
-	cap = (void *)xpcie->mmio + start;
+	cap = (struct xpcie_cap_txrx *)((void *)xpcie->mmio + start);
 	memset(cap, 0, sizeof(struct xpcie_cap_txrx));
 	cap->hdr.id = XPCIE_CAP_TXRX;
 	cap->hdr.next = next;
@@ -123,13 +125,17 @@ static int intel_xpcie_txrx_init(struct xpcie *xpcie,
 {
 	struct xpcie_epf *xpcie_epf = container_of(xpcie,
 						   struct xpcie_epf, xpcie);
-	struct device *dma_dev = xpcie_epf->epf->epc->dev.parent;
 	struct xpcie_stream *tx = &xpcie->tx;
 	struct xpcie_stream *rx = &xpcie->rx;
 	int tx_pool_size, rx_pool_size;
 	struct xpcie_buf_desc *bd;
-	int index, ndesc, rc;
-
+	int index, ndesc;
+#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+	struct device *dma_dev = &xpcie_epf->epf->dev;
+#else
+	int rc;
+	struct device *dma_dev = xpcie_epf->epf->epc->dev.parent;
+#endif
 	xpcie->txrx = cap;
 	xpcie->fragment_size = cap->fragment_size;
 	xpcie->stop_flag = false;
@@ -147,13 +153,14 @@ static int intel_xpcie_txrx_init(struct xpcie *xpcie,
 	intel_xpcie_list_init(&xpcie->rx_pool);
 	rx_pool_size = roundup(SZ_32M, xpcie->fragment_size);
 	ndesc = rx_pool_size / xpcie->fragment_size;
-
+#if (!IS_ENABLED(CONFIG_PCIE_TBH_EP))
 	/* Initialize reserved memory resources */
 	rc = of_reserved_mem_device_init(dma_dev);
 	if (rc) {
 		dev_err(dma_dev, "Could not get reserved memory\n");
 		goto error;
 	}
+#endif
 
 	for (index = 0; index < ndesc; index++) {
 		bd = intel_xpcie_alloc_bd(xpcie->fragment_size);
@@ -291,7 +298,7 @@ static void intel_xpcie_rx_event_handler(struct work_struct *work)
 			break;
 		}
 
-		desc = &xpcie_epf->rx_desc_buf[chan].virt[descs_num++];
+		desc = &xpcie_epf->rx_desc_buf.virt[descs_num++];
 		desc->dma_transfer_size = length;
 		desc->dst_addr = bd->phys;
 		desc->src_addr = address;
@@ -391,7 +398,7 @@ static void intel_xpcie_tx_event_handler(struct work_struct *work)
 		td = tx->pipe.tdr + tail;
 		address = intel_xpcie_get_td_address(td);
 
-		desc = &xpcie_epf->tx_desc_buf[chan].virt[descs_num++];
+		desc = &xpcie_epf->tx_desc_buf.virt[descs_num++];
 		desc->dma_transfer_size = bd->length;
 		desc->src_addr = bd->phys;
 		desc->dst_addr = address;
@@ -456,7 +463,14 @@ static void intel_xpcie_tx_event_handler(struct work_struct *work)
 static irqreturn_t intel_xpcie_core_irq_cb(int irq, void *args)
 {
 	struct xpcie *xpcie = args;
-
+#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+	u16 phy_id = 0;
+	u8 max_functions = 0, func_no = 0;
+	struct xpcie_epf *xpcie_epf =
+				container_of(xpcie, struct xpcie_epf, xpcie);
+	/*clear the interrupt*/
+	writel(0x1, xpcie->doorbell_clear);
+#endif
 	if (intel_xpcie_get_doorbell(xpcie, TO_DEVICE, DATA_SENT)) {
 		intel_xpcie_set_doorbell(xpcie, TO_DEVICE, DATA_SENT, 0);
 		intel_xpcie_start_rx(xpcie, 0);
@@ -466,7 +480,22 @@ static irqreturn_t intel_xpcie_core_irq_cb(int irq, void *args)
 		if (xpcie->tx_pending)
 			intel_xpcie_start_tx(xpcie, 0);
 	}
-
+#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+	if (intel_xpcie_get_doorbell(xpcie, TO_DEVICE, PHY_ID_UPDATED)) {
+		intel_xpcie_set_doorbell(xpcie, TO_DEVICE, PHY_ID_UPDATED, 0);
+		if (!xpcie_epf->sw_dev_id_updated) {
+			phy_id = intel_xpcie_get_physical_device_id(xpcie);
+			max_functions = intel_xpcie_get_max_functions(xpcie);
+			func_no = xpcie_epf->epf->func_no;
+		xpcie_epf->sw_devid =
+		intel_xpcie_create_sw_device_id(func_no, phy_id, max_functions);
+			xpcie_epf->sw_dev_id_updated = true;
+			dev_info(xpcie_to_dev(xpcie),
+				 "pcie: func_no=%x swid updated=%x phy_id=%x\n",
+				 func_no, xpcie_epf->sw_devid, phy_id);
+		}
+	}
+#endif
 	return IRQ_HANDLED;
 }
 
@@ -531,7 +560,9 @@ int intel_xpcie_core_init(struct xpcie *xpcie)
 	intel_xpcie_set_doorbell(xpcie, FROM_DEVICE, DATA_SENT, 0);
 	intel_xpcie_set_doorbell(xpcie, FROM_DEVICE, DATA_RECEIVED, 0);
 	intel_xpcie_set_doorbell(xpcie, FROM_DEVICE, DEV_EVENT, NO_OP);
-
+#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+	intel_xpcie_set_doorbell(xpcie, TO_DEVICE, PHY_ID_UPDATED, 0);
+#endif
 	intel_xpcie_register_host_irq(xpcie, intel_xpcie_core_irq_cb);
 
 	return 0;
@@ -727,8 +758,16 @@ int intel_xpcie_core_write(struct xpcie *xpcie, void *buffer,
 
 int intel_xpcie_get_device_status_by_id(u32 id, u32 *status)
 {
-	struct xpcie *xpcie = intel_xpcie_core_get_by_id(id);
+	struct xpcie *xpcie;
+#if (!IS_ENABLED(CONFIG_PCIE_TBH_EP))
+	xpcie = intel_xpcie_core_get_by_id(id);
+#else
+	struct xpcie_epf *xpcie_epf = intel_xpcie_get_device_by_id(id);
 
+	if (!xpcie_epf)
+		return -ENODEV;
+	xpcie = &xpcie_epf->xpcie;
+#endif
 	if (!xpcie)
 		return -ENODEV;
 
@@ -737,6 +776,7 @@ int intel_xpcie_get_device_status_by_id(u32 id, u32 *status)
 	return 0;
 }
 
+#if (!IS_ENABLED(CONFIG_PCIE_TBH_EP))
 u32 intel_xpcie_get_device_num(u32 *id_list)
 {
 	u32 num_devices = 0;
@@ -748,13 +788,21 @@ u32 intel_xpcie_get_device_num(u32 *id_list)
 
 	return num_devices;
 }
+#endif
 
 int intel_xpcie_get_device_name_by_id(u32 id,
 				      char *device_name, size_t name_size)
 {
 	struct xpcie *xpcie;
-
+#if (!IS_ENABLED(CONFIG_PCIE_TBH_EP))
 	xpcie = intel_xpcie_core_get_by_id(id);
+#else
+	struct xpcie_epf *xpcie_epf = intel_xpcie_get_device_by_id(id);
+
+	if (!xpcie_epf)
+		return -ENODEV;
+	xpcie = &xpcie_epf->xpcie;
+#endif
 	if (!xpcie)
 		return -ENODEV;
 
@@ -770,7 +818,15 @@ int intel_xpcie_pci_connect_device(u32 id)
 {
 	struct xpcie *xpcie;
 
+#if (!IS_ENABLED(CONFIG_PCIE_TBH_EP))
 	xpcie = intel_xpcie_core_get_by_id(id);
+#else
+	struct xpcie_epf *xpcie_epf = intel_xpcie_get_device_by_id(id);
+
+	if (!xpcie_epf)
+		return -ENODEV;
+	xpcie = &xpcie_epf->xpcie;
+#endif
 	if (!xpcie)
 		return -ENODEV;
 
@@ -784,7 +840,15 @@ int intel_xpcie_pci_read(u32 id, void *data, size_t *size, u32 timeout)
 {
 	struct xpcie *xpcie;
 
+#if (!IS_ENABLED(CONFIG_PCIE_TBH_EP))
 	xpcie = intel_xpcie_core_get_by_id(id);
+#else
+	struct xpcie_epf *xpcie_epf = intel_xpcie_get_device_by_id(id);
+
+	if (!xpcie_epf)
+		return -ENODEV;
+	xpcie = &xpcie_epf->xpcie;
+#endif
 	if (!xpcie)
 		return -ENODEV;
 
@@ -795,7 +859,15 @@ int intel_xpcie_pci_write(u32 id, void *data, size_t *size, u32 timeout)
 {
 	struct xpcie *xpcie;
 
+#if (!IS_ENABLED(CONFIG_PCIE_TBH_EP))
 	xpcie = intel_xpcie_core_get_by_id(id);
+#else
+	struct xpcie_epf *xpcie_epf = intel_xpcie_get_device_by_id(id);
+
+	if (!xpcie_epf)
+		return -ENODEV;
+	xpcie = &xpcie_epf->xpcie;
+#endif
 	if (!xpcie)
 		return -ENODEV;
 
diff --git a/drivers/misc/xlink-pcie/local_host/dma.c b/drivers/misc/xlink-pcie/local_host/dma.c
index 811e5eebb7ab..8c89bd9ebb46 100644
--- a/drivers/misc/xlink-pcie/local_host/dma.c
+++ b/drivers/misc/xlink-pcie/local_host/dma.c
@@ -1,7 +1,7 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*****************************************************************************
  *
- * Intel Keem Bay XLink PCIe Driver
+ * Intel XPCIe XLink PCIe Driver
  *
  * Copyright (C) 2020 Intel Corporation
  *
@@ -152,8 +152,13 @@ enum xpcie_ep_engine_type {
 };
 
 static u32 dma_chan_offset[2][DMA_CHAN_NUM] = {
+#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+	{ 0x200, 0x400, 0x600, 0x800, 0xA00, 0xC00, 0xE00, 0x1000 },
+	{ 0x300, 0x500, 0x700, 0x900, 0xB00, 0xD00, 0xF00, 0x1100 }
+#else
 	{ 0x200, 0x400, 0x600, 0x800 },
 	{ 0x300, 0x500, 0x700, 0x900 }
+#endif
 };
 
 static void __iomem *intel_xpcie_ep_get_dma_base(struct pci_epf *epf)
@@ -357,7 +362,7 @@ int intel_xpcie_ep_dma_write_ll(struct pci_epf *epf, int chan, int descs_num)
 	dma_chan = (struct __iomem pcie_dma_chan *)
 		(dma_base + dma_chan_offset[WRITE_ENGINE][chan]);
 
-	desc_buf = &xpcie_epf->tx_desc_buf[chan];
+	desc_buf = &xpcie_epf->tx_desc_buf;
 
 	intel_xpcie_ep_dma_setup_ll_descs(dma_chan, desc_buf, descs_num);
 
@@ -423,7 +428,7 @@ int intel_xpcie_ep_dma_read_ll(struct pci_epf *epf, int chan, int descs_num)
 	dma_chan = (struct __iomem pcie_dma_chan *)
 		(dma_base + dma_chan_offset[READ_ENGINE][chan]);
 
-	desc_buf = &xpcie_epf->rx_desc_buf[chan];
+	desc_buf = &xpcie_epf->rx_desc_buf;
 
 	intel_xpcie_ep_dma_setup_ll_descs(dma_chan, desc_buf, descs_num);
 
@@ -477,60 +482,64 @@ int intel_xpcie_ep_dma_read_ll(struct pci_epf *epf, int chan, int descs_num)
 
 static void intel_xpcie_ep_dma_free_ll_descs_mem(struct xpcie_epf *xpcie_epf)
 {
+#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+	struct device *dma_dev = &xpcie_epf->epf->dev;
+#else
 	struct device *dma_dev = xpcie_epf->epf->epc->dev.parent;
+#endif
 	int i;
 
 	for (i = 0; i < DMA_CHAN_NUM; i++) {
-		if (xpcie_epf->tx_desc_buf[i].virt) {
+		if (xpcie_epf->tx_desc_buf.virt) {
 			dma_free_coherent(dma_dev,
-					  xpcie_epf->tx_desc_buf[i].size,
-					  xpcie_epf->tx_desc_buf[i].virt,
-					  xpcie_epf->tx_desc_buf[i].phys);
+					  xpcie_epf->tx_desc_buf.size,
+					  xpcie_epf->tx_desc_buf.virt,
+					  xpcie_epf->tx_desc_buf.phys);
 		}
-		if (xpcie_epf->rx_desc_buf[i].virt) {
+		if (xpcie_epf->rx_desc_buf.virt) {
 			dma_free_coherent(dma_dev,
-					  xpcie_epf->rx_desc_buf[i].size,
-					  xpcie_epf->rx_desc_buf[i].virt,
-					  xpcie_epf->rx_desc_buf[i].phys);
+					  xpcie_epf->rx_desc_buf.size,
+					  xpcie_epf->rx_desc_buf.virt,
+					  xpcie_epf->rx_desc_buf.phys);
 		}
 
-		memset(&xpcie_epf->tx_desc_buf[i], 0,
+		memset(&xpcie_epf->tx_desc_buf, 0,
 		       sizeof(struct xpcie_dma_ll_desc_buf));
-		memset(&xpcie_epf->rx_desc_buf[i], 0,
+		memset(&xpcie_epf->rx_desc_buf, 0,
 		       sizeof(struct xpcie_dma_ll_desc_buf));
 	}
 }
 
 static int intel_xpcie_ep_dma_alloc_ll_descs_mem(struct xpcie_epf *xpcie_epf)
 {
-	struct device *dma_dev = xpcie_epf->epf->epc->dev.parent;
 	int tx_num = XPCIE_NUM_TX_DESCS + 1;
 	int rx_num = XPCIE_NUM_RX_DESCS + 1;
 	size_t tx_size, rx_size;
-	int i;
-
+#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+	struct device *dma_dev = &xpcie_epf->epf->dev;
+#else
+	struct device *dma_dev = xpcie_epf->epf->epc->dev.parent;
+#endif
 	tx_size = tx_num * sizeof(struct xpcie_dma_ll_desc);
 	rx_size = rx_num * sizeof(struct xpcie_dma_ll_desc);
 
-	for (i = 0; i < DMA_CHAN_NUM; i++) {
-		xpcie_epf->tx_desc_buf[i].virt =
+	xpcie_epf->tx_desc_buf.virt =
 			dma_alloc_coherent(dma_dev, tx_size,
-					   &xpcie_epf->tx_desc_buf[i].phys,
+					   &xpcie_epf->tx_desc_buf.phys,
 					   GFP_KERNEL);
-		xpcie_epf->rx_desc_buf[i].virt =
+	xpcie_epf->rx_desc_buf.virt =
 			dma_alloc_coherent(dma_dev, rx_size,
-					   &xpcie_epf->rx_desc_buf[i].phys,
+					   &xpcie_epf->rx_desc_buf.phys,
 					   GFP_KERNEL);
+	if (!xpcie_epf->tx_desc_buf.virt ||
+	    !xpcie_epf->rx_desc_buf.virt) {
+		intel_xpcie_ep_dma_free_ll_descs_mem(xpcie_epf);
+		return -ENOMEM;
+	}
 
-		if (!xpcie_epf->tx_desc_buf[i].virt ||
-		    !xpcie_epf->rx_desc_buf[i].virt) {
-			intel_xpcie_ep_dma_free_ll_descs_mem(xpcie_epf);
-			return -ENOMEM;
-		}
+	xpcie_epf->tx_desc_buf.size = tx_size;
+	xpcie_epf->rx_desc_buf.size = rx_size;
 
-		xpcie_epf->tx_desc_buf[i].size = tx_size;
-		xpcie_epf->rx_desc_buf[i].size = rx_size;
-	}
 	return 0;
 }
 
diff --git a/drivers/misc/xlink-pcie/local_host/epf.c b/drivers/misc/xlink-pcie/local_host/epf.c
index 6af5252e029b..c5ba52b9031e 100644
--- a/drivers/misc/xlink-pcie/local_host/epf.c
+++ b/drivers/misc/xlink-pcie/local_host/epf.c
@@ -1,7 +1,7 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*****************************************************************************
  *
- * Intel Keem Bay XLink PCIe Driver
+ * Intel XPCIe XLink PCIe Driver
  *
  * Copyright (C) 2020 Intel Corporation
  *
@@ -10,11 +10,22 @@
 #include <linux/of.h>
 #include <linux/platform_device.h>
 #include <linux/reboot.h>
+#include <linux/of_device.h>
+#include <linux/of_reserved_mem.h>
 
 #include "epf.h"
 
+#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#define BAR0_MIN_SIZE			SZ_4K
+#endif
+
 #define BAR2_MIN_SIZE			SZ_16K
+
+#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#define BAR4_MIN_SIZE			SZ_8K
+#else
 #define BAR4_MIN_SIZE			SZ_16K
+#endif
 
 #define PCIE_REGS_PCIE_INTR_ENABLE	0x18
 #define PCIE_REGS_PCIE_INTR_FLAGS	0x1C
@@ -30,7 +41,11 @@
 
 static struct pci_epf_header xpcie_header = {
 	.vendorid = PCI_VENDOR_ID_INTEL,
+#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+	.deviceid = PCI_DEVICE_ID_INTEL_TBH_FULL,
+#else
 	.deviceid = PCI_DEVICE_ID_INTEL_KEEMBAY,
+#endif
 	.baseclass_code = PCI_BASE_CLASS_MULTIMEDIA,
 	.subclass_code = 0x0,
 	.subsys_vendor_id = 0x0,
@@ -44,7 +59,61 @@ static const struct pci_epf_device_id xpcie_epf_ids[] = {
 	{},
 };
 
+#if (!IS_ENABLED(CONFIG_PCIE_TBH_EP))
 u32 xlink_sw_id;
+#endif
+
+#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#define XPCIE_MAX_NAME_LEN	(32)
+
+static LIST_HEAD(dev_list);
+static DEFINE_MUTEX(dev_list_mutex);
+
+u32 intel_xpcie_get_device_num(u32 *id_list)
+{
+	u32 num = 0;
+	struct xpcie_epf *p;
+
+	mutex_lock(&dev_list_mutex);
+	list_for_each_entry(p, &dev_list, list) {
+		if (p->sw_dev_id_updated) {
+			*id_list++ = p->sw_devid;
+			num++;
+		}
+	}
+	mutex_unlock(&dev_list_mutex);
+	return num;
+}
+
+struct xpcie_epf *intel_xpcie_get_device_by_id(u32 id)
+{
+	struct xpcie_epf *xdev;
+
+	mutex_lock(&dev_list_mutex);
+
+	list_for_each_entry(xdev, &dev_list, list) {
+		if (xdev->sw_devid == id)
+			break;
+	}
+
+	mutex_unlock(&dev_list_mutex);
+
+	return xdev;
+}
+
+struct xpcie_epf *intel_xpcie_get_device_by_name(const char *name)
+{
+	struct xpcie_epf *p;
+
+	mutex_lock(&dev_list_mutex);
+	list_for_each_entry(p, &dev_list, list) {
+		if (!strncmp(p->name, name, XPCIE_MAX_NAME_LEN))
+			break;
+	}
+	mutex_unlock(&dev_list_mutex);
+	return p;
+}
+#endif
 
 int intel_xpcie_copy_from_host_ll(struct xpcie *xpcie, int chan, int descs_num)
 {
@@ -83,6 +152,7 @@ int intel_xpcie_raise_irq(struct xpcie *xpcie, enum xpcie_doorbell_type type)
 	return pci_epc_raise_irq(epf->epc, epf->func_no, PCI_EPC_IRQ_MSI, 1);
 }
 
+#if (!IS_ENABLED(CONFIG_PCIE_TBH_EP))
 static irqreturn_t intel_xpcie_err_interrupt(int irq, void *args)
 {
 	struct xpcie_epf *xpcie_epf;
@@ -98,12 +168,14 @@ static irqreturn_t intel_xpcie_err_interrupt(int irq, void *args)
 
 	return IRQ_HANDLED;
 }
+#endif
 
 static irqreturn_t intel_xpcie_host_interrupt(int irq, void *args)
 {
 	struct xpcie_epf *xpcie_epf;
 	struct xpcie *xpcie = args;
 	u8 event;
+#if (!IS_ENABLED(CONFIG_PCIE_TBH_EP))
 	u32 val;
 
 	xpcie_epf = container_of(xpcie, struct xpcie_epf, xpcie);
@@ -111,20 +183,19 @@ static irqreturn_t intel_xpcie_host_interrupt(int irq, void *args)
 	if (val & LBC_CII_EVENT_FLAG) {
 		iowrite32(LBC_CII_EVENT_FLAG,
 			  xpcie_epf->apb_base + PCIE_REGS_PCIE_INTR_FLAGS);
-
-		event = intel_xpcie_get_doorbell(xpcie, TO_DEVICE, DEV_EVENT);
-		if (unlikely(event != NO_OP)) {
-			intel_xpcie_set_doorbell(xpcie, TO_DEVICE,
-						 DEV_EVENT, NO_OP);
-			if (event == REQUEST_RESET)
-				orderly_reboot();
-			return IRQ_HANDLED;
-		}
-
-		if (likely(xpcie_epf->core_irq_callback))
-			xpcie_epf->core_irq_callback(irq, xpcie);
+	}
+#endif
+	event = intel_xpcie_get_doorbell(xpcie, TO_DEVICE, DEV_EVENT);
+	if (unlikely(event != NO_OP)) {
+		intel_xpcie_set_doorbell(xpcie, TO_DEVICE, DEV_EVENT, NO_OP);
+		if (event == REQUEST_RESET)
+			orderly_reboot();
+		return IRQ_HANDLED;
 	}
 
+	if (likely(xpcie_epf->core_irq_callback))
+		xpcie_epf->core_irq_callback(irq, xpcie);
+
 	return IRQ_HANDLED;
 }
 
@@ -204,6 +275,64 @@ static void intel_xpcie_cleanup_bars(struct pci_epf *epf)
 	xpcie_epf->xpcie.bar4 = NULL;
 }
 
+#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+static int intel_xpcie_setup_bar(struct pci_epf *epf, enum pci_barno barno,
+				 size_t size, size_t align)
+{
+	int ret;
+	void __iomem *vaddr = NULL;
+	struct pci_epc *epc = epf->epc;
+	struct xpcie_epf *xpcie_epf = epf_get_drvdata(epf);
+	struct pci_epf_bar *bar = &epf->bar[barno];
+	struct dw_pcie_ep *ep = epc_get_drvdata(epc);
+	struct dw_pcie *pci = to_dw_pcie_from_ep(ep);
+	struct thunderbay_pcie *thunderbay = to_thunderbay_pcie(pci);
+
+	bar->flags |= PCI_BASE_ADDRESS_MEM_TYPE_64;
+	bar->size = size;
+
+	if (barno == 0) {
+		bar->phys_addr =
+			thunderbay->doorbell->start + (epf->func_no * 0x1000);
+		vaddr = ioremap(bar->phys_addr, size);
+	}
+
+	if (barno == 2) {
+		bar->phys_addr = thunderbay->mmr2[epf->func_no]->start;
+		vaddr = ioremap(bar->phys_addr, size);
+	}
+	if (barno == 4) {
+		bar->phys_addr = thunderbay->mmr4[epf->func_no]->start;
+		vaddr = ioremap_cache(bar->phys_addr, size);
+	}
+
+	if (!vaddr) {
+		dev_err(&epf->dev, "Failed to map BAR%d\n", barno);
+		return -ENOMEM;
+	}
+
+	epf->bar[barno].phys_addr = bar->phys_addr;
+	epf->bar[barno].size = size;
+	epf->bar[barno].barno = barno;
+	epf->bar[barno].flags |= upper_32_bits(size) ?
+		PCI_BASE_ADDRESS_MEM_TYPE_64 :
+		PCI_BASE_ADDRESS_MEM_TYPE_32;
+
+	thunderbay->setup_bar[epf->func_no] = true;
+	ret = pci_epc_set_bar(epc, epf->func_no, bar);
+	thunderbay->setup_bar[epf->func_no] = false;
+
+	if (ret) {
+		pci_epf_free_space(epf, vaddr, barno);
+		dev_err(&epf->dev, "Failed to set BAR%d\n", barno);
+		return ret;
+	}
+
+	xpcie_epf->vaddr[barno] = vaddr;
+
+	return 0;
+}
+#else
 static int intel_xpcie_setup_bar(struct pci_epf *epf, enum pci_barno barno,
 				 size_t min_size, size_t align)
 {
@@ -237,13 +366,20 @@ static int intel_xpcie_setup_bar(struct pci_epf *epf, enum pci_barno barno,
 
 	return 0;
 }
+#endif
 
 static int intel_xpcie_setup_bars(struct pci_epf *epf, size_t align)
 {
 	int ret;
 
 	struct xpcie_epf *xpcie_epf = epf_get_drvdata(epf);
-
+#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+	ret = intel_xpcie_setup_bar(epf, BAR_0, BAR0_MIN_SIZE, align);
+	if (ret)
+		return ret;
+	xpcie_epf->doorbell_bar = BAR_0;
+	xpcie_epf->xpcie.doorbell_base = xpcie_epf->vaddr[BAR_0];
+#endif
 	ret = intel_xpcie_setup_bar(epf, BAR_2, BAR2_MIN_SIZE, align);
 	if (ret)
 		return ret;
@@ -264,6 +400,161 @@ static int intel_xpcie_setup_bars(struct pci_epf *epf, size_t align)
 	return 0;
 }
 
+#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+static void intel_xpcie_enable_multi_functions(struct pci_epf *epf)
+{
+	struct pci_epc *epc = epf->epc;
+	struct xpcie_epf *xpcie_epf = epf_get_drvdata(epf);
+	struct dw_pcie_ep *ep = epc_get_drvdata(epc);
+	struct dw_pcie *pci = to_dw_pcie_from_ep(ep);
+	struct thunderbay_pcie *thunderbay = to_thunderbay_pcie(pci);
+	size_t doorbell_clr_size = 0;
+	unsigned long doorbell_clr_addr = 0;
+	int ret = 0;
+
+	xpcie_epf->irq_doorbell = thunderbay->irq_doorbell[epf->func_no];
+	xpcie_epf->irq_rdma = thunderbay->irq_rdma[epf->func_no];
+	xpcie_epf->irq_wdma = thunderbay->irq_wdma[epf->func_no];
+	xpcie_epf->apb_base = thunderbay->slv_apb_base;
+
+	switch (epf->func_no) {
+	case 0:
+		if (thunderbay->tbh_half) {
+			ret = of_reserved_mem_device_init_by_idx
+				(&epf->dev, pci->dev->of_node, 8);
+		} else {
+			ret = of_reserved_mem_device_init_by_idx
+				(&epf->dev, pci->dev->of_node, 16);
+			}
+		if (ret) {
+			dev_warn(&epc->dev,
+				 "of_reserved_mem_device_init_by_idx(): %d\n",
+				 ret);
+		}
+		epf->dev.dma_mask = pci->dev->dma_mask;
+		epf->dev.coherent_dma_mask = pci->dev->coherent_dma_mask;
+		ret = of_dma_configure(&epf->dev, pci->dev->of_node, true);
+		if (ret) {
+			dev_warn(&epc->dev,
+				 "pcie:failed of_dma_configure()ret=%d\n", ret);
+		}
+		ret = dma_set_mask_and_coherent(&epf->dev, DMA_BIT_MASK(64));
+		if (ret) {
+			dev_warn(&epc->dev,
+				 "pcie:failed to set dma mask. ret=%d\n", ret);
+		}
+		doorbell_clr_addr = thunderbay->doorbell_clear->start;
+		doorbell_clr_size = 4;
+		break;
+	case 1:
+		doorbell_clr_addr = thunderbay->doorbell_clear->start + 0x8;
+		doorbell_clr_size = 4;
+		break;
+	case 2:
+		if (thunderbay->tbh_half)
+			ret = of_reserved_mem_device_init_by_idx
+				(&epf->dev, pci->dev->of_node, 9);
+		else
+			ret = of_reserved_mem_device_init_by_idx
+				(&epf->dev, pci->dev->of_node, 17);
+		if (ret) {
+			dev_warn(&epc->dev,
+				 "of_reserved_mem_device_init_by_idx(): %d\n",
+				 ret);
+		}
+		epf->dev.dma_mask = pci->dev->dma_mask;
+		epf->dev.coherent_dma_mask = pci->dev->coherent_dma_mask;
+		ret = of_dma_configure(&epf->dev, pci->dev->of_node, true);
+		if (ret) {
+			dev_warn(&epc->dev,
+				 "pcie:failed of_dma_configure()ret=%d\n", ret);
+		}
+		ret = dma_set_mask_and_coherent(&epf->dev, DMA_BIT_MASK(64));
+		if (ret) {
+			dev_warn(&epc->dev,
+				 "pcie:failed to set dma mask. ret=%d\n", ret);
+		}
+		doorbell_clr_addr = thunderbay->doorbell_clear->start + 0x14;
+		doorbell_clr_size = 4;
+		break;
+	case 3:
+		doorbell_clr_addr = thunderbay->doorbell_clear->start + 0x1C;
+		doorbell_clr_size = 4;
+		break;
+	case 4:
+		ret = of_reserved_mem_device_init_by_idx
+			(&epf->dev, pci->dev->of_node, 18);
+		if (ret) {
+			dev_warn(&epc->dev,
+				 "of_xx_mem_device_init_by_idx(): 18 ret=%d\n",
+				 ret);
+		}
+		epf->dev.dma_mask = pci->dev->dma_mask;
+		epf->dev.coherent_dma_mask = pci->dev->coherent_dma_mask;
+		ret = of_dma_configure(&epf->dev, pci->dev->of_node, true);
+		if (ret) {
+			dev_warn(&epc->dev, "failed of_dma_configure(): %d\n",
+				 ret);
+		}
+		ret = dma_set_mask_and_coherent(&epf->dev, DMA_BIT_MASK(64));
+		if (ret) {
+			dev_warn(&epc->dev, "failed to set dma mask ret=%d\n",
+				 ret);
+		}
+		doorbell_clr_addr = thunderbay->doorbell_clear->start + 0x28;
+		doorbell_clr_size = 4;
+		break;
+	case 5:
+		doorbell_clr_addr = thunderbay->doorbell_clear->start + 0x30;
+		doorbell_clr_size = 4;
+		break;
+	case 6:
+		ret = of_reserved_mem_device_init_by_idx
+			(&epf->dev, pci->dev->of_node, 19);
+		if (ret) {
+			dev_warn(&epc->dev,
+				 "of_xx_mem_device_init_by_idx(): 19 ret=%d\n",
+				 ret);
+		}
+		epf->dev.dma_mask = pci->dev->dma_mask;
+		epf->dev.coherent_dma_mask = pci->dev->coherent_dma_mask;
+		ret = of_dma_configure(&epf->dev, pci->dev->of_node, true);
+		if (ret) {
+			dev_warn(&epc->dev,
+				 "pcie:failed of_dma_configure() ret:%d\n",
+				 ret);
+		}
+		ret = dma_set_mask_and_coherent(&epf->dev, DMA_BIT_MASK(64));
+		if (ret) {
+			dev_warn(&epc->dev, "failed to set dma mask ret=%d\n",
+				 ret);
+		}
+		doorbell_clr_addr = thunderbay->doorbell_clear->start + 0x3C;
+		doorbell_clr_size = 4;
+		break;
+	case 7:
+		doorbell_clr_addr = thunderbay->doorbell_clear->start + 0x44;
+		doorbell_clr_size = 4;
+		break;
+	}
+
+	xpcie_epf->xpcie.doorbell_clear =
+				ioremap(doorbell_clr_addr, doorbell_clr_size);
+	dev_dbg(&epc->dev,
+		"virtual doorbell_clear=%p,physical doorbell_clr_addr=%lx\n",
+		 xpcie_epf->xpcie.doorbell_clear, doorbell_clr_addr);
+	intel_xpcie_set_max_functions(&xpcie_epf->xpcie, epc->max_functions);
+	list_add_tail(&xpcie_epf->list, &dev_list);
+	snprintf(xpcie_epf->name, MXLK_MAX_NAME_LEN, "%s_func%x", epf->name,
+		 epf->func_no);
+
+	ret = request_irq(xpcie_epf->irq_doorbell,
+			  &intel_xpcie_host_interrupt, 0, XPCIE_DRIVER_NAME,
+			  &xpcie_epf->xpcie);
+	if (ret)
+		dev_err(&epf->dev, "failed to request irq\n");
+}
+#else
 static int intel_xpcie_epf_get_platform_data(struct device *dev,
 					     struct xpcie_epf *xpcie_epf)
 {
@@ -322,13 +613,16 @@ static int intel_xpcie_epf_get_platform_data(struct device *dev,
 
 	return 0;
 }
+#endif
 
 static int intel_xpcie_epf_bind(struct pci_epf *epf)
 {
 	struct xpcie_epf *xpcie_epf = epf_get_drvdata(epf);
 	const struct pci_epc_features *features;
 	struct pci_epc *epc = epf->epc;
+#if (!IS_ENABLED(CONFIG_PCIE_TBH_EP))
 	u32 bus_num, dev_num;
+#endif
 	struct device *dev;
 	size_t align = SZ_16K;
 	int ret;
@@ -336,6 +630,11 @@ static int intel_xpcie_epf_bind(struct pci_epf *epf)
 	if (WARN_ON_ONCE(!epc))
 		return -EINVAL;
 
+#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+	if ((epf->func_no & 0x1))
+		return 0;
+#endif
+
 	dev = epc->dev.parent;
 	features = pci_epc_get_features(epc, epf->func_no);
 	xpcie_epf->epc_features = features;
@@ -351,7 +650,9 @@ static int intel_xpcie_epf_bind(struct pci_epf *epf)
 		dev_err(&epf->dev, "BAR initialization failed\n");
 		return ret;
 	}
-
+#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+	intel_xpcie_enable_multi_functions(epf);
+#else
 	ret = intel_xpcie_epf_get_platform_data(dev, xpcie_epf);
 	if (ret) {
 		dev_err(&epf->dev, "Unable to get platform data\n");
@@ -380,13 +681,13 @@ static int intel_xpcie_epf_bind(struct pci_epf *epf)
 	}
 
 	ret = devm_request_irq(&epf->dev, xpcie_epf->irq_err,
-			       &intel_xpcie_err_interrupt, 0,
+			       &(intel_xpcie_err_interrupt), 0,
 			       XPCIE_DRIVER_NAME, &xpcie_epf->xpcie);
 	if (ret) {
 		dev_err(&epf->dev, "failed to request error irq\n");
 		goto err_cleanup_bars;
 	}
-
+#endif
 	ret = intel_xpcie_ep_dma_init(epf);
 	if (ret) {
 		dev_err(&epf->dev, "DMA initialization failed\n");
@@ -394,12 +695,14 @@ static int intel_xpcie_epf_bind(struct pci_epf *epf)
 	}
 
 	intel_xpcie_set_device_status(&xpcie_epf->xpcie, XPCIE_STATUS_READY);
-
+#if (!IS_ENABLED(CONFIG_PCIE_TBH_EP))
 	ret = ioread32(xpcie_epf->apb_base + PCIE_REGS_PCIE_SYS_CFG_CORE);
 	bus_num = (ret >> PCIE_CFG_PBUS_NUM_OFFSET) & PCIE_CFG_PBUS_NUM_MASK;
 	dev_num = (ret >> PCIE_CFG_PBUS_DEV_NUM_OFFSET) &
 			PCIE_CFG_PBUS_DEV_NUM_MASK;
+#endif
 
+#if (!IS_ENABLED(CONFIG_PCIE_TBH_EP))
 	xlink_sw_id = FIELD_PREP(XLINK_DEV_INF_TYPE_MASK,
 				 XLINK_DEV_INF_PCIE) |
 		      FIELD_PREP(XLINK_DEV_PHYS_ID_MASK,
@@ -407,6 +710,7 @@ static int intel_xpcie_epf_bind(struct pci_epf *epf)
 		      FIELD_PREP(XLINK_DEV_TYPE_MASK, XLINK_DEV_TYPE_KMB) |
 		      FIELD_PREP(XLINK_DEV_PCIE_ID_MASK, XLINK_DEV_PCIE_0) |
 		      FIELD_PREP(XLINK_DEV_FUNC_MASK, XLINK_DEV_FUNC_VPU);
+#endif
 
 	ret = intel_xpcie_core_init(&xpcie_epf->xpcie);
 	if (ret) {
@@ -452,10 +756,6 @@ static void intel_xpcie_epf_unbind(struct pci_epf *epf)
 	intel_xpcie_cleanup_bars(epf);
 }
 
-static void intel_xpcie_epf_linkup(struct pci_epf *epf)
-{
-}
-
 static int intel_xpcie_epf_probe(struct pci_epf *epf)
 {
 	struct device *dev = &epf->dev;
@@ -490,7 +790,6 @@ static void intel_xpcie_epf_shutdown(struct device *dev)
 static struct pci_epf_ops ops = {
 	.bind = intel_xpcie_epf_bind,
 	.unbind = intel_xpcie_epf_unbind,
-	.linkup = intel_xpcie_epf_linkup,
 };
 
 static struct pci_epf_driver xpcie_epf_driver = {
diff --git a/drivers/misc/xlink-pcie/local_host/epf.h b/drivers/misc/xlink-pcie/local_host/epf.h
index ad79416476d5..fb63e4f6f2ca 100644
--- a/drivers/misc/xlink-pcie/local_host/epf.h
+++ b/drivers/misc/xlink-pcie/local_host/epf.h
@@ -1,7 +1,7 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*****************************************************************************
  *
- * Intel Keem Bay XLink PCIe Driver
+ * Intel XPCIe XLink PCIe Driver
  *
  * Copyright (C) 2020 Intel Corporation
  *
@@ -12,6 +12,7 @@
 
 #include <linux/pci-epc.h>
 #include <linux/pci-epf.h>
+#include <pcie-keembay.h>
 
 #include "../common/xpcie.h"
 #include "../common/util.h"
@@ -21,7 +22,11 @@
 
 #define KEEMBAY_XPCIE_STEPPING_MAXLEN 8
 
+#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#define DMA_CHAN_NUM		(8)
+#else
 #define DMA_CHAN_NUM		(4)
+#endif
 
 #define XPCIE_NUM_TX_DESCS	(64)
 #define XPCIE_NUM_RX_DESCS	(64)
@@ -57,13 +62,22 @@ struct xpcie_dma_ll_desc_buf {
 struct xpcie_epf {
 	struct pci_epf *epf;
 	void *vaddr[BAR_5 + 1];
+#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+	enum pci_barno                  doorbell_bar;
+#endif
 	enum pci_barno comm_bar;
 	enum pci_barno bar4;
 	const struct pci_epc_features *epc_features;
 	struct xpcie xpcie;
 	int irq;
+#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+	int                             irq_doorbell;
+	int                             irq_rdma;
+	int                             irq_wdma;
+#else
 	int irq_dma;
 	int irq_err;
+#endif
 	void __iomem *apb_base;
 	void __iomem *dma_base;
 	void __iomem *dbi_base;
@@ -74,8 +88,16 @@ struct xpcie_epf {
 	void				*tx_virt;
 	size_t				tx_size;
 
-	struct xpcie_dma_ll_desc_buf	tx_desc_buf[DMA_CHAN_NUM];
-	struct xpcie_dma_ll_desc_buf	rx_desc_buf[DMA_CHAN_NUM];
+	struct xpcie_dma_ll_desc_buf     tx_desc_buf;
+	struct xpcie_dma_ll_desc_buf     rx_desc_buf;
+
+#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#define MXLK_MAX_NAME_LEN (32)
+	char                            name[MXLK_MAX_NAME_LEN];
+	u32                             sw_devid;
+	bool                            sw_dev_id_updated;
+	struct list_head                list;
+#endif
 };
 
 static inline struct device *xpcie_to_dev(struct xpcie *xpcie)
@@ -86,6 +108,9 @@ static inline struct device *xpcie_to_dev(struct xpcie *xpcie)
 	return &xpcie_epf->epf->dev;
 }
 
+#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+struct xpcie_epf *intel_xpcie_get_device_by_name(const char *name);
+#endif
 int intel_xpcie_ep_dma_init(struct pci_epf *epf);
 int intel_xpcie_ep_dma_uninit(struct pci_epf *epf);
 int intel_xpcie_ep_dma_reset(struct pci_epf *epf);
diff --git a/drivers/misc/xlink-pcie/remote_host/Makefile b/drivers/misc/xlink-pcie/remote_host/Makefile
index 088e121ad46e..f6b09a93bb5f 100644
--- a/drivers/misc/xlink-pcie/remote_host/Makefile
+++ b/drivers/misc/xlink-pcie/remote_host/Makefile
@@ -1,3 +1,5 @@
+ccflags-y += -DCONFIG_PCIE_TBH_EP=1
+
 obj-$(CONFIG_XLINK_PCIE_RH_DRIVER) += mxlk.o
 mxlk-objs := main.o
 mxlk-objs += pci.o
diff --git a/drivers/misc/xlink-pcie/remote_host/core.c b/drivers/misc/xlink-pcie/remote_host/core.c
index 2e20e1490076..9d58e7d652eb 100644
--- a/drivers/misc/xlink-pcie/remote_host/core.c
+++ b/drivers/misc/xlink-pcie/remote_host/core.c
@@ -1,7 +1,7 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*****************************************************************************
  *
- * Intel Keem Bay XLink PCIe Driver
+ * Intel XPCIe XLink PCIe Driver
  *
  * Copyright (C) 2020 Intel Corporation
  *
diff --git a/drivers/misc/xlink-pcie/remote_host/main.c b/drivers/misc/xlink-pcie/remote_host/main.c
index fd31ee3c153b..1462bb695191 100644
--- a/drivers/misc/xlink-pcie/remote_host/main.c
+++ b/drivers/misc/xlink-pcie/remote_host/main.c
@@ -1,7 +1,7 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*****************************************************************************
  *
- * Intel Keem Bay XLink PCIe Driver
+ * Intel XPCIe XLink PCIe Driver
  *
  * Copyright (C) 2020 Intel Corporation
  *
@@ -15,6 +15,10 @@
 
 static const struct pci_device_id xpcie_pci_table[] = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_KEEMBAY), 0 },
+#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_TBH_FULL), 0 },
+	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_TBH_PRIME), 0 },
+#endif
 	{ 0 }
 };
 
@@ -27,15 +31,23 @@ static int intel_xpcie_probe(struct pci_dev *pdev,
 	u16 hw_id;
 	int ret;
 
+#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+	if (PCI_FUNC(pdev->devfn) & 0x1)
+		return 0;
+#endif
+
 	hw_id = FIELD_PREP(HW_ID_HI_MASK, pdev->bus->number) |
 		FIELD_PREP(HW_ID_LO_MASK, PCI_SLOT(pdev->devfn));
 
-	sw_devid = FIELD_PREP(XLINK_DEV_INF_TYPE_MASK,
-			      XLINK_DEV_INF_PCIE) |
-		   FIELD_PREP(XLINK_DEV_PHYS_ID_MASK, hw_id) |
-		   FIELD_PREP(XLINK_DEV_TYPE_MASK, XLINK_DEV_TYPE_KMB) |
-		   FIELD_PREP(XLINK_DEV_PCIE_ID_MASK, XLINK_DEV_PCIE_0) |
-		   FIELD_PREP(XLINK_DEV_FUNC_MASK, XLINK_DEV_FUNC_VPU);
+#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+	sw_devid = FIELD_PREP(XLINK_DEV_INF_TYPE_MASK, XLINK_DEV_INF_PCIE) |
+		FIELD_PREP(XLINK_DEV_PHYS_ID_MASK, hw_id) |
+		FIELD_PREP(XLINK_DEV_TYPE_MASK, XLINK_DEV_TYPE_KMB) |
+		FIELD_PREP(XLINK_DEV_PCIE_ID_MASK, XLINK_DEV_PCIE_0) |
+		FIELD_PREP(XLINK_DEV_FUNC_MASK, XLINK_DEV_FUNC_VPU);
+#else
+	sw_devid = hw_id;
+#endif
 
 	xdev = intel_xpcie_get_device_by_id(sw_devid);
 	if (!xdev) {
diff --git a/drivers/misc/xlink-pcie/remote_host/pci.c b/drivers/misc/xlink-pcie/remote_host/pci.c
index 0046bff5f604..fb54d357b44e 100644
--- a/drivers/misc/xlink-pcie/remote_host/pci.c
+++ b/drivers/misc/xlink-pcie/remote_host/pci.c
@@ -1,7 +1,7 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*****************************************************************************
  *
- * Intel Keem Bay XLink PCIe Driver
+ * Intel XPCIe XLink PCIe Driver
  *
  * Copyright (C) 2020 Intel Corporation
  *
@@ -37,14 +37,16 @@ struct xpcie_dev *intel_xpcie_get_device_by_id(u32 id)
 	}
 
 	list_for_each_entry(xdev, &dev_list, list) {
+#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+		if (xdev->sw_devid == id) {
+#else
 		if (xdev->devid == id) {
+#endif
 			mutex_unlock(&dev_list_mutex);
-			return xdev;
+				return xdev;
 		}
+		mutex_unlock(&dev_list_mutex);
 	}
-
-	mutex_unlock(&dev_list_mutex);
-
 	return NULL;
 }
 
@@ -115,6 +117,9 @@ static void intel_xpcie_pci_unmap_bar(struct xpcie_dev *xdev)
 	if (xdev->xpcie.bar0) {
 		iounmap((void __iomem *)xdev->xpcie.bar0);
 		xdev->xpcie.bar0 = NULL;
+#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+		xdev->xpcie.doorbell_base = xdev->xpcie.bar0;
+#endif
 	}
 
 	if (xdev->xpcie.mmio) {
@@ -140,7 +145,9 @@ static int intel_xpcie_pci_map_bar(struct xpcie_dev *xdev)
 		dev_err(&xdev->pci->dev, "failed to ioremap BAR0\n");
 		goto bar_error;
 	}
-
+#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+	xdev->xpcie.doorbell_base = xdev->xpcie.bar0;
+#endif
 	xdev->xpcie.mmio = (void __force *)
 			   (pci_ioremap_bar(xdev->pci, 2) + XPCIE_MMIO_OFFSET);
 	if (!xdev->xpcie.mmio) {
@@ -209,12 +216,31 @@ static void xpcie_device_poll(struct work_struct *work)
 {
 	struct xpcie_dev *xdev = container_of(work, struct xpcie_dev,
 					      wait_event.work);
-
-	if (intel_xpcie_get_device_status(&xdev->xpcie) < XPCIE_STATUS_RUN)
+#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+	u8 max_functions;
+#endif
+	if (intel_xpcie_get_device_status(&xdev->xpcie) < XPCIE_STATUS_RUN) {
 		schedule_delayed_work(&xdev->wait_event,
 				      msecs_to_jiffies(100));
-	else
+	} else {
 		xdev->xpcie.status = XPCIE_STATUS_READY;
+#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+		intel_xpcie_set_physical_device_id(&xdev->xpcie, xdev->devid);
+		max_functions = intel_xpcie_get_max_functions(&xdev->xpcie);
+		xdev->sw_devid =
+			intel_xpcie_create_sw_device_id
+			(PCI_FUNC(xdev->pci->devfn),
+			 xdev->devid, max_functions);
+		dev_info(&xdev->pci->dev,
+			 "sw_devid=%x, function idx=%d, max_functions=%d\n",
+			 xdev->sw_devid,
+			 PCI_FUNC(xdev->pci->devfn), max_functions);
+
+		intel_xpcie_set_doorbell(&xdev->xpcie, TO_DEVICE,
+					 PHY_ID_UPDATED, 1);
+		iowrite32(1, xdev->xpcie.doorbell_base);
+#endif
+	}
 }
 
 static int intel_xpcie_pci_prepare_dev_reset(struct xpcie_dev *xdev,
@@ -363,7 +389,9 @@ int intel_xpcie_pci_raise_irq(struct xpcie_dev *xdev,
 
 	intel_xpcie_set_doorbell(&xdev->xpcie, TO_DEVICE, type, value);
 	pci_read_config_word(xdev->pci, PCI_STATUS, &pci_status);
-
+#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+	iowrite32(1, xdev->xpcie.doorbell_base);
+#endif
 	return 0;
 }
 
@@ -380,7 +408,11 @@ u32 intel_xpcie_get_device_num(u32 *id_list)
 	}
 
 	list_for_each_entry(p, &dev_list, list) {
+#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+		*id_list++ = p->sw_devid;
+#else
 		*id_list++ = p->devid;
+#endif
 		num++;
 	}
 	mutex_unlock(&dev_list_mutex);
diff --git a/drivers/misc/xlink-pcie/remote_host/pci.h b/drivers/misc/xlink-pcie/remote_host/pci.h
index a05dedf36a12..e0b892752415 100644
--- a/drivers/misc/xlink-pcie/remote_host/pci.h
+++ b/drivers/misc/xlink-pcie/remote_host/pci.h
@@ -1,7 +1,7 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*****************************************************************************
  *
- * Intel Keem Bay XLink PCIe Driver
+ * Intel XPCIe XLink PCIe Driver
  *
  * Copyright (C) 2020 Intel Corporation
  *
@@ -14,11 +14,12 @@
 #include <linux/list.h>
 #include <linux/pci.h>
 #include <linux/xlink_drv_inf.h>
+
 #include "../common/xpcie.h"
 #include "../common/util.h"
 
 #define XPCIE_DRIVER_NAME "mxlk"
-#define XPCIE_DRIVER_DESC "Intel(R) Keem Bay XLink PCIe driver"
+#define XPCIE_DRIVER_DESC "Intel(R) XPCIe XLink PCIe driver"
 
 #define XPCIE_MAX_NAME_LEN	(32)
 
@@ -29,6 +30,9 @@ struct xpcie_dev {
 	struct pci_dev *pci;
 	char name[XPCIE_MAX_NAME_LEN];
 	u32 devid;
+#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+	u32 sw_devid;
+#endif
 	char fw_name[XPCIE_MAX_NAME_LEN];
 
 	struct delayed_work wait_event;
diff --git a/include/linux/xlink_drv_inf.h b/include/linux/xlink_drv_inf.h
index 1a13ed25a56c..180ec038eb62 100644
--- a/include/linux/xlink_drv_inf.h
+++ b/include/linux/xlink_drv_inf.h
@@ -20,6 +20,18 @@
 #define XLINK_DEV_PCIE_ID_MASK		GENMASK(3, 1)
 #define XLINK_DEV_FUNC_MASK		GENMASK(0, 0)
 
+#define XLINK_DEV_FUNC_SHIFT		(0)
+#define XLINK_DEV_SLICE_ID_SHIFT	(1)
+#define XLINK_DEV_TYPE_SHIFT		(4)
+#define XLINK_DEV_PHYS_ID_SHIFT		(8)
+#define XLINK_DEV_INF_TYPE_SHIFT	(24)
+
+enum xlink_device_slice {
+	XLINK_DEV_SLICE_0 = 0,
+	XLINK_DEV_SLICE_1 = 1,
+	XLINK_DEV_SLICE_2 = 2,
+	XLINK_DEV_SLICE_3 = 3
+};
 
 enum xlink_device_inf_type {
 	XLINK_DEV_INF_PCIE = 1,
@@ -27,6 +39,8 @@ enum xlink_device_inf_type {
 
 enum xlink_device_type {
 	XLINK_DEV_TYPE_KMB = 0,
+	XLINK_DEV_TYPE_THB_PRIME = 1,
+	XLINK_DEV_TYPE_THB_STANDARD = 2
 };
 
 enum xlink_device_pcie {
@@ -35,6 +49,7 @@ enum xlink_device_pcie {
 
 enum xlink_device_func {
 	XLINK_DEV_FUNC_VPU = 0,
+	XLINK_DEV_FUNC_MEDIA = 1
 };
 
 enum _xlink_device_status {
-- 
2.27.0

