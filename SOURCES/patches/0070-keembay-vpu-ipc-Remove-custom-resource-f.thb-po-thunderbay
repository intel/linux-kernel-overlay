From 48994a3bed36403dcac8e6464f4b57d76f750fa0 Mon Sep 17 00:00:00 2001
From: Paul Murphy <paul.j.murphy@intel.com>
Date: Thu, 5 Sep 2019 19:05:18 +0000
Subject: [PATCH 070/223] keembay-vpu-ipc: Remove custom resource functions

Replace 'regions_overlapping' with the standard 'resource_overlaps',
this now works because we have made the region end = start + size - 1,
which is the expected calculation for this function.

Replace 'contained_in_reserved_region' with 'resource_contains', this
now works with a new temporary resource 'total_reserved_res' which
describes the full VPU FW region, this now also works because of the
re-definition of end to be start + size - 1.

We can't ioremap these region as suggested, because the entire region
has already been mapped by the dmam_alloc_coherent call, so I think it
is valid to offset into it to retrieve virtual base address of
sub-regions.

Signed-off-by: Paul Murphy <paul.j.murphy@intel.com>

(cherry picked from commit 54e1fdbb9973aa63b3779479d0da56994c1a6abb)
---
 drivers/firmware/keembay-vpu-ipc.c | 80 +++++++++++++-----------------
 1 file changed, 34 insertions(+), 46 deletions(-)

diff --git a/drivers/firmware/keembay-vpu-ipc.c b/drivers/firmware/keembay-vpu-ipc.c
index b92e8f345e76..70f3c7b5ebcf 100644
--- a/drivers/firmware/keembay-vpu-ipc.c
+++ b/drivers/firmware/keembay-vpu-ipc.c
@@ -757,40 +757,6 @@ static int request_vpu_stop(struct vpu_ipc_dev *vpu_dev)
 	return 0;
 }
 
-/* True iff reserved region completely contains this region. */
-static bool contained_in_reserved_region(struct vpu_ipc_dev *vpu_dev,
-					 struct resource *res)
-{
-	uint64_t reserved_start = vpu_dev->reserved_mem.dma_handle;
-	uint64_t reserved_end = reserved_start + vpu_dev->reserved_mem.size;
-
-	if (reserved_start <= res->start && reserved_end >= res->end)
-		return true;
-
-	return false;
-}
-
-/**
- * regions_overlapping() - True if any part of r1 overlaps r2
- * @r1:	Any region
- * @r2: Any region
- *
- * Return true if any part of r1 overlaps r2. However, the basic
- * check returns 'true' if for example, the end of r1 == start of
- * r2. This is not a problem for us.
- *
- * Returns true if there is overlap, otherwise false.
- */
-static bool regions_overlapping(struct resource *r1, struct resource *r2)
-{
-	if (r1->start <= r2->end && r1->end >= r2->start) {
-		if (!(r2->start == r1->end || r1->start == r2->end))
-			return true;
-	}
-
-	return false;
-}
-
 static void *get_vpu_dev_vaddr(struct vpu_ipc_dev *vpu_dev,
 			       struct resource *res)
 {
@@ -809,7 +775,7 @@ static int parse_fw_header(struct vpu_ipc_dev *vpu_dev,
 			   const struct firmware *fw)
 {
 	struct firmware_header *fw_header = NULL;
-	struct resource config_res, version_res;
+	struct resource config_res, version_res, total_reserved_res;
 	void *fw_region = NULL;
 	void *version_region = NULL;
 	void *config_region = NULL;
@@ -859,48 +825,70 @@ static int parse_fw_header(struct vpu_ipc_dev *vpu_dev,
 	}
 
 	/*
-	 * TODO: look at using "struct resource *" to handle overlap detection
-	 * and valid address/size checks. Then get io address with ioremap.
+	 * Generate the resource describing the region containing the actual
+	 * firmware data.
 	 */
 	vpu_dev->fw_res.start = fw_header->image_load_address;
 	vpu_dev->fw_res.end =
-		fw_header->image_size + fw_header->image_load_address;
+		fw_header->image_size + fw_header->image_load_address - 1;
+	vpu_dev->fw_res.flags = IORESOURCE_MEM;
+
+	/*
+	 * Generate the resource describing the region containing the
+	 * configuration data for the VPU.
+	 */
 	config_res.start = fw_header->configuration_data_load_address;
 	config_res.end = sizeof(struct boot_parameters) +
-			 fw_header->configuration_data_load_address;
+			 fw_header->configuration_data_load_address - 1;
+	config_res.flags = IORESOURCE_MEM;
+
+	/*
+	 * Generate the resource describing the region containing the
+	 * version information for the VPU.
+	 */
 	version_res.start = fw_header->firmware_version_load_address;
 	version_res.end = fw_header->firmware_version_size +
-			  fw_header->firmware_version_load_address;
+			  fw_header->firmware_version_load_address - 1;
+	version_res.flags = IORESOURCE_MEM;
+
+	/*
+	 * Generate the resource describing the region of memory
+	 * completely dedicated to the VPU.
+	 */
+	total_reserved_res.start = vpu_dev->reserved_mem.dma_handle;
+	total_reserved_res.end = vpu_dev->reserved_mem.dma_handle +
+		vpu_dev->reserved_mem.size - 1;
+	total_reserved_res.flags = IORESOURCE_MEM;
 
 	/*
 	 * Check all pieces to be copied reside completely in the reserved
 	 * region
 	 */
-	if (!contained_in_reserved_region(vpu_dev, &vpu_dev->fw_res)) {
+	if (!resource_contains(&total_reserved_res, &vpu_dev->fw_res)) {
 		dev_err(dev, "Can't fit firmware in reserved region.\n");
 		return -EINVAL;
 	}
-	if (!contained_in_reserved_region(vpu_dev, &version_res)) {
+	if (!resource_contains(&total_reserved_res, &version_res)) {
 		dev_err(dev,
 			"Can't fit firmware version data in reserved region.\n");
 		return -EINVAL;
 	}
-	if (!contained_in_reserved_region(vpu_dev, &config_res)) {
+	if (!resource_contains(&total_reserved_res, &config_res)) {
 		dev_err(dev,
 			"Can't fit configuration information in reserved region.\n");
 		return -EINVAL;
 	}
 
 	/* Check for overlapping regions */
-	if (regions_overlapping(&vpu_dev->fw_res, &version_res)) {
+	if (resource_overlaps(&vpu_dev->fw_res, &version_res)) {
 		dev_err(dev, "FW and version regions overlap.\n");
 		return -EINVAL;
 	}
-	if (regions_overlapping(&vpu_dev->fw_res, &config_res)) {
+	if (resource_overlaps(&vpu_dev->fw_res, &config_res)) {
 		dev_err(dev, "FW and config regions overlap.\n");
 		return -EINVAL;
 	}
-	if (regions_overlapping(&config_res, &version_res)) {
+	if (resource_overlaps(&config_res, &version_res)) {
 		dev_err(dev, "Version and config regions overlap.\n");
 		return -EINVAL;
 	}
-- 
2.27.0

