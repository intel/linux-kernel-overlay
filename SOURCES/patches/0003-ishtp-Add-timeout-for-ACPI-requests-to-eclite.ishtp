From c50349bc85d65c99f4d84ead06d04ba87a3e52a6 Mon Sep 17 00:00:00 2001
From: "K Naduvalath, Sumesh" <sumesh.k.naduvalath@intel.com>
Date: Thu, 23 Jul 2020 08:36:15 +0530
Subject: [PATCH 3/8] ishtp: Add timeout for ACPI requests to eclite

This fix adds timeout for ACPI requests to ish in eclite driver

Signed-off-by: K Naduvalath, Sumesh <sumesh.k.naduvalath@intel.com>
---
 drivers/platform/x86/intel_ishtp_eclite.c | 76 ++++++++++++++++++++---
 1 file changed, 66 insertions(+), 10 deletions(-)

diff --git a/drivers/platform/x86/intel_ishtp_eclite.c b/drivers/platform/x86/intel_ishtp_eclite.c
index ce2a9d6ca659..5713634b1f53 100644
--- a/drivers/platform/x86/intel_ishtp_eclite.c
+++ b/drivers/platform/x86/intel_ishtp_eclite.c
@@ -28,8 +28,8 @@
 #define ECL_ISH_WRITE	0x2
 #define ECL_ISH_HEADER_VERSION	0
 
-#define ECL_CL_RX_RING_SIZE	8
-#define ECL_CL_TX_RING_SIZE	4
+#define ECL_CL_RX_RING_SIZE	16
+#define ECL_CL_TX_RING_SIZE	8
 
 #define ECL_DATA_OPR_BUFLEN	384
 
@@ -78,7 +78,10 @@ struct ishtp_opregion_dev {
 	struct ishtp_cl_rb *rb;
 	struct acpi_handle *acpi_handle;
 	unsigned int dsm_event_id;
+	unsigned int ish_link_ready;
+	unsigned int ish_read_done;
 	wait_queue_head_t read_wait;
+	wait_queue_head_t link_wait;
 	struct work_struct event_work;
 	struct work_struct reset_work;
 };
@@ -115,14 +118,38 @@ static int ecl_ish_cl_read(struct ishtp_opregion_dev *opr_dev)
 	header.event = opr_dev->opr_context.cmd_area.event_id;
 	len = sizeof(header);
 
+	rv = wait_event_interruptible_timeout(opr_dev->link_wait,
+					      opr_dev->ish_link_ready,
+					      5 * HZ);
+	if (!rv) {
+		dev_warn(cl_data_to_dev(opr_dev),
+			 "[ish_rd] Timeout, Link not ready\n");
+	}
+
+	opr_dev->ish_read_done = false;
+
+	if (!opr_dev->ish_link_ready)
+		return -EIO;
+
 	rv = ishtp_cl_send(opr_dev->ecl_ishtp_cl, (uint8_t *)&header, len);
 	if (rv) {
 		dev_err(cl_data_to_dev(opr_dev), "ish-read : send failed\n");
 		return rv;
 	}
 
-	wait_event_interruptible(opr_dev->read_wait, opr_dev->rb != NULL);
-	opr_dev->rb = NULL;
+	dev_dbg(cl_data_to_dev(opr_dev),
+		"[ish_rd] Req: off : %x, len : %x\n",
+		header.offset,
+		header.data_len);
+
+	rv = wait_event_interruptible_timeout(opr_dev->read_wait,
+					      opr_dev->ish_read_done,
+					      5 * HZ);
+	if (!rv) {
+		dev_err(cl_data_to_dev(opr_dev),
+			 "[ish_rd] No response from firmware\n");
+		return -EIO;
+	}
 
 	return 0;
 }
@@ -151,8 +178,15 @@ static int ecl_ish_cl_write(struct ishtp_opregion_dev *opr_dev)
 	       opr_dev->opr_context.data_area.data + message.header.offset,
 	       message.header.data_len);
 
-	return ishtp_cl_send(opr_dev->ecl_ishtp_cl, (uint8_t *)&message, len);
+	if (!opr_dev->ish_link_ready)
+		return 0;
+
+	dev_dbg(cl_data_to_dev(opr_dev),
+		"[ish_wr] off : %x, len : %x\n",
+		message.header.offset,
+		message.header.data_len);
 
+	return ishtp_cl_send(opr_dev->ecl_ishtp_cl, (uint8_t *)&message, len);
 }
 
 static acpi_status
@@ -288,6 +322,7 @@ static void ecl_acpi_invoke_dsm(struct work_struct *work)
 
 	dev_dbg(cl_data_to_dev(opr_dev), "Exec DSM function code: %d success\n",
 		opr_dev->dsm_event_id);
+
 	ACPI_FREE(obj);
 }
 
@@ -304,6 +339,7 @@ static void ecl_ish_process_rx_data(struct ishtp_opregion_dev *opr_dev)
 	memcpy(opr_dev->opr_context.data_area.data + message->header.offset,
 	       message->payload, message->header.data_len);
 
+	opr_dev->ish_read_done = true;
 	wake_up_interruptible(&opr_dev->read_wait);
 }
 
@@ -316,10 +352,7 @@ static void ecl_ish_process_rx_event(struct ishtp_opregion_dev *opr_dev)
 		"[ish_ev] Evt received: %8x\n", header->event);
 
 	opr_dev->dsm_event_id = header->event;
-
 	schedule_work(&opr_dev->event_work);
-
-	opr_dev->rb = NULL;
 }
 
 static void ecl_ishtp_cl_event_cb(struct ishtp_cl_device *cl_device)
@@ -374,7 +407,9 @@ static int ecl_ishtp_cl_init(struct ishtp_cl *ecl_ishtp_cl)
 		return -ENOENT;
 	}
 
-	ishtp_cl_set_fw_client_id(ecl_ishtp_cl, ishtp_get_fw_client_id(fw_client));
+	ishtp_cl_set_fw_client_id(ecl_ishtp_cl,
+				  ishtp_get_fw_client_id(fw_client));
+
 	ishtp_set_connection_state(ecl_ishtp_cl, ISHTP_CL_CONNECTING);
 
 	rv = ishtp_cl_connect(ecl_ishtp_cl);
@@ -403,9 +438,12 @@ static void ecl_ishtp_cl_reset_handler(struct work_struct *work)
 	struct ishtp_cl_device *cl_device;
 	struct ishtp_cl *ecl_ishtp_cl;
 	int rv;
+	int retry;
 
 	opr_dev = container_of(work, struct ishtp_opregion_dev, reset_work);
 
+	opr_dev->ish_link_ready = false;
+
 	cl_device = opr_dev->cl_device;
 	ecl_ishtp_cl = opr_dev->ecl_ishtp_cl;
 
@@ -420,13 +458,27 @@ static void ecl_ishtp_cl_reset_handler(struct work_struct *work)
 
 	opr_dev->ecl_ishtp_cl = ecl_ishtp_cl;
 
-	rv = ecl_ishtp_cl_init(ecl_ishtp_cl);
+	for (retry = 0; retry < 3; ++retry) {
+		rv = ecl_ishtp_cl_init(ecl_ishtp_cl);
+		if (!rv)
+			break;
+	}
 	if (rv) {
 		ishtp_cl_free(ecl_ishtp_cl);
 		opr_dev->ecl_ishtp_cl = NULL;
+		dev_err(cl_data_to_dev(opr_dev),
+			"[ish_rst] Reset failed. Link not ready.\n");
+		return;
 	}
 
 	ishtp_register_event_cb(cl_device, ecl_ishtp_cl_event_cb);
+
+	opr_dev->ish_link_ready = true;
+
+	dev_err(cl_data_to_dev(opr_dev),
+		"[ish_rst] Reset success. Link ready.\n");
+
+	wake_up_interruptible(&opr_dev->link_wait);
 }
 
 static int ecl_ishtp_cl_probe(struct ishtp_cl_device *cl_device)
@@ -450,9 +502,11 @@ static int ecl_ishtp_cl_probe(struct ishtp_cl_device *cl_device)
 	opr_dev->cl_device = cl_device;
 
 	init_waitqueue_head(&opr_dev->read_wait);
+	init_waitqueue_head(&opr_dev->link_wait);
 	INIT_WORK(&opr_dev->event_work, ecl_acpi_invoke_dsm);
 	INIT_WORK(&opr_dev->reset_work, ecl_ishtp_cl_reset_handler);
 
+
 	/* Initialize ish client device */
 	rv = ecl_ishtp_cl_init(ecl_ishtp_cl);
 	if (rv) {
@@ -467,6 +521,8 @@ static int ecl_ishtp_cl_probe(struct ishtp_cl_device *cl_device)
 
 	ishtp_get_device(cl_device);
 
+	opr_dev->ish_link_ready = true;
+
 	/* Now find ACPI device and init opregion handlers */
 	rv = acpi_opregion_init(opr_dev);
 	if (rv) {
-- 
2.27.0

