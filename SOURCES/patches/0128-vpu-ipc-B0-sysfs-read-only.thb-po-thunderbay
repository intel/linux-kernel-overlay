From 03eb8b37e2d97a45a936edfad372296bc0f367cf Mon Sep 17 00:00:00 2001
From: Mike Healy <mikex.healy@intel.com>
Date: Wed, 4 Nov 2020 01:36:58 -0800
Subject: [PATCH 128/223] vpu-ipc: B0 sysfs read only

Make stepping sysfs file read only for all chip versions
If B0, make device ID, feature exclusion, and SKU read
only if not fused and not A0 equivalent SKU.

Signed-off-by: Mike Healy <mikex.healy@intel.com>
---
 drivers/firmware/keembay-vpu-ipc.c | 76 ++++++++++++++++++++++--------
 1 file changed, 56 insertions(+), 20 deletions(-)

diff --git a/drivers/firmware/keembay-vpu-ipc.c b/drivers/firmware/keembay-vpu-ipc.c
index b5ba5fb443fa..4a8c40e5851b 100644
--- a/drivers/firmware/keembay-vpu-ipc.c
+++ b/drivers/firmware/keembay-vpu-ipc.c
@@ -121,6 +121,15 @@
 /* SoC stepping length, in bytes. */
 #define SOC_INFO_STEPPING_BYTES 2
 
+/* A0 stepping fused value */
+#define A0_STEPPING "A0"
+
+/* B0 stepping fused value */
+#define B0_STEPPING "B0"
+
+/* A0 equivalent SKU fused value */
+#define A0_EQUIV_SKU "3400VE"
+
 /**
  * struct boot_parameters
  * @magic_number:		Magic number to indicate structure populated
@@ -1805,15 +1814,7 @@ static ssize_t stepping_show(struct device *dev,
 	return show_attr_u8_array(buf, vpu_ipc_soc_info->stepping,
 				  sizeof(vpu_ipc_soc_info->stepping));
 }
-
-static ssize_t stepping_store(struct device *dev,
-	struct device_attribute *attr,
-	const char *buf, size_t n)
-{
-	return store_attr_u8_array(buf, n, vpu_ipc_soc_info->stepping,
-				   sizeof(vpu_ipc_soc_info->stepping));
-}
-static DEVICE_ATTR_RW(stepping);
+static DEVICE_ATTR_RO(stepping);
 
 static ssize_t sku_show(struct device *dev,
 		struct device_attribute *attr,
@@ -1822,15 +1823,7 @@ static ssize_t sku_show(struct device *dev,
 	return show_attr_u8_array(buf, vpu_ipc_soc_info->sku,
 				  sizeof(vpu_ipc_soc_info->sku));
 }
-
-static ssize_t sku_store(struct device *dev,
-	struct device_attribute *attr,
-	const char *buf, size_t n)
-{
-	return store_attr_u8_array(buf, n, vpu_ipc_soc_info->sku,
-				   sizeof(vpu_ipc_soc_info->sku));
-}
-static DEVICE_ATTR_RW(sku);
+static DEVICE_ATTR_RO(sku);
 
 static ssize_t device_id_show(struct device *dev,
 		struct device_attribute *attr,
@@ -1845,7 +1838,7 @@ static ssize_t device_id_store(struct device *dev,
 {
 	return store_attr_u64(buf, n, &vpu_ipc_soc_info->device_id);
 }
-static DEVICE_ATTR_RW(device_id);
+static DEVICE_ATTR_RO(device_id);
 
 static ssize_t feature_exclusion_show(struct device *dev,
 		struct device_attribute *attr,
@@ -1860,7 +1853,7 @@ static ssize_t feature_exclusion_store(struct device *dev,
 {
 	return store_attr_u64(buf, n, &vpu_ipc_soc_info->feature_exclusion);
 }
-static DEVICE_ATTR_RW(feature_exclusion);
+static DEVICE_ATTR_RO(feature_exclusion);
 
 static ssize_t hardware_id_show(struct device *dev,
 		struct device_attribute *attr,
@@ -2109,6 +2102,42 @@ static int retrieve_dt_soc_information(void)
 	return 0;
 }
 
+/**
+ * should_sysfw_be_rw() - Check if sysfs files should be writable?
+ *
+ * The feature exclusion information and device ID files are read and write
+ * enabled on A0.
+ * They are read-only on B0, unless the device ID and feature exclusion
+ * information are zero indicating that the part has not been fused, or the SKU
+ * is the A0 equivalent SKU, in which case they will be readable and writeable.
+ *
+ * Returns: True if should be writable
+ *          False otherwise
+ */
+static inline bool should_sysfs_be_rw(void)
+{
+	/* is A0 stepping? */
+	if (!memcmp(vpu_ipc_soc_info->stepping, A0_STEPPING,
+		    SOC_INFO_STEPPING_BYTES))
+		return true;
+
+	/* is B0 stepping? */
+	if (!memcmp(vpu_ipc_soc_info->stepping, B0_STEPPING,
+		    SOC_INFO_STEPPING_BYTES)) {
+		/* is not fused? */
+		if (!vpu_ipc_soc_info->device_id &&
+		    !vpu_ipc_soc_info->feature_exclusion)
+			return true;
+
+		/* or is A0 equivalent SKU? */
+		if (!memcmp(vpu_ipc_soc_info->sku, A0_EQUIV_SKU,
+			    SOC_INFO_SKU_BYTES))
+			return true;
+	}
+
+	return false;
+}
+
 static int __init vpu_ipc_init(void)
 {
 	int rc;
@@ -2127,6 +2156,13 @@ static int __init vpu_ipc_init(void)
 	if (rc < 0)
 		pr_warn("VPU IPC failed to find SoC info, using defaults.\n");
 
+	if (should_sysfs_be_rw()) {
+		dev_attr_device_id.store = device_id_store;
+		dev_attr_device_id.attr.mode = 0644;
+		dev_attr_feature_exclusion.store = feature_exclusion_store;
+		dev_attr_feature_exclusion.attr.mode = 0644;
+	}
+
 	rc = sysfs_create_files(vpu_ipc_kobj, vpu_ipc_attrs);
 	if (rc < 0)
 		goto cleanup_soc_info;
-- 
2.27.0

