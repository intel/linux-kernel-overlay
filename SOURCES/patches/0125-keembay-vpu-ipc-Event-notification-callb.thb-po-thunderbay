From 86ae367705db463c2f4d4658ca497c81df4482a8 Mon Sep 17 00:00:00 2001
From: Mike Healy <mikex.healy@intel.com>
Date: Thu, 23 Jul 2020 14:10:39 +0100
Subject: [PATCH 125/223] keembay-vpu-ipc: Event notification callback

As specified by HSD:
https://hsdes.intel.com/appstore/article/#/1307512344

Signed-off-by: Mike Healy <mikex.healy@intel.com>
---
 drivers/firmware/keembay-vpu-ipc.c | 74 ++++++++++++++++++++++++++++++
 include/linux/keembay-vpu-ipc.h    | 12 +++++
 2 files changed, 86 insertions(+)

diff --git a/drivers/firmware/keembay-vpu-ipc.c b/drivers/firmware/keembay-vpu-ipc.c
index c21e77071daf..5acf8344f728 100644
--- a/drivers/firmware/keembay-vpu-ipc.c
+++ b/drivers/firmware/keembay-vpu-ipc.c
@@ -241,6 +241,7 @@ struct vpu_ipc_dev {
 	wait_queue_head_t ready_queue;
 	struct device *ipc_dev;
 	char *firmware_name;
+	void (*callback)(struct device *dev, enum intel_keembay_vpu_event);
 };
 
 struct vpu_ipc_soc_info {
@@ -268,6 +269,25 @@ static struct kobject *vpu_ipc_kobj;
 
 static struct vpu_ipc_soc_info *vpu_ipc_soc_info;
 
+/**
+ * vpu_ipc_notify_event() - Trigger callback
+ * @vpu_dev:		Private data
+ * @event:		Event to notify
+ *
+ * This function is called when an event has occurred. If a callback has
+ * been registered it is called with the device and event as arguments.
+ *
+ * This function can be called from interrupt context.
+ */
+static void vpu_ipc_notify_event(struct vpu_ipc_dev *vpu_dev,
+				 enum intel_keembay_vpu_event event)
+{
+	struct device *dev = &vpu_dev->pdev->dev;
+
+	if (*vpu_dev->callback)
+		(*vpu_dev->callback)(dev, event);
+}
+
 /**
  * vpu_ipc_handle_event() - Handle events and optionally update state
  *
@@ -301,6 +321,8 @@ static int vpu_ipc_handle_event(struct vpu_ipc_dev *vpu_dev,
 	case KEEMBAY_VPU_BUSY:
 		if (event == KEEMBAY_VPU_EVENT_MSS_READY_OK) {
 			vpu_dev->state = KEEMBAY_VPU_READY;
+			vpu_ipc_notify_event(vpu_dev,
+					     KEEMBAY_VPU_NOTIFY_CONNECT);
 			rc = 0;
 		}
 		if (event == KEEMBAY_VPU_EVENT_MSS_READY_FAIL ||
@@ -310,6 +332,10 @@ static int vpu_ipc_handle_event(struct vpu_ipc_dev *vpu_dev,
 		}
 		break;
 	case KEEMBAY_VPU_READY:
+		if (event != KEEMBAY_VPU_EVENT_MSS_READY_OK)
+			vpu_ipc_notify_event(vpu_dev,
+					     KEEMBAY_VPU_NOTIFY_DISCONNECT);
+
 		if (event == KEEMBAY_VPU_EVENT_MSS_READY_FAIL ||
 		    event == KEEMBAY_VPU_EVENT_BOOT_FAILED) {
 			vpu_dev->state = KEEMBAY_VPU_ERROR;
@@ -375,6 +401,7 @@ static irqreturn_t nce_wdt_irq_handler(int irq, void *ptr)
 	struct device *dev = &vpu_dev->pdev->dev;
 	int rc;
 
+	vpu_ipc_notify_event(vpu_dev, KEEMBAY_VPU_NOTIFY_NCE_WDT);
 	dev_dbg(dev, "NCE WDT IRQ occurred.\n");
 
 	clear_and_disable_vpu_wdt(vpu_dev->nce_wdt_reg,
@@ -395,6 +422,7 @@ static irqreturn_t mss_wdt_irq_handler(int irq, void *ptr)
 	struct device *dev = &vpu_dev->pdev->dev;
 	int rc;
 
+	vpu_ipc_notify_event(vpu_dev, KEEMBAY_VPU_NOTIFY_MSS_WDT);
 	dev_dbg(dev, "MSS WDT IRQ occurred.\n");
 
 	clear_and_disable_vpu_wdt(vpu_dev->mss_wdt_reg,
@@ -1534,6 +1562,52 @@ int intel_keembay_vpu_wait_for_ready(struct device *dev, u32 timeout)
 }
 EXPORT_SYMBOL(intel_keembay_vpu_wait_for_ready);
 
+/**
+ * intel_keembay_vpu_register_for_events() - Register callback for event notification
+ * @callback: Callback function pointer
+ *
+ * Only a single callback can be registered at a time.
+ *
+ * Callback can be triggered from any context, so needs to be able to be run
+ * from IRQ context.
+ *
+ * Return: 0 on success, negative error code otherwise
+ */
+int intel_keembay_vpu_register_for_events(struct device *dev,
+					  void (*callback)(struct device *dev,
+							   enum intel_keembay_vpu_event))
+{
+	struct vpu_ipc_dev *vpu_dev = to_vpu_dev(dev);
+
+	if (IS_ERR(vpu_dev))
+		return PTR_ERR(vpu_dev);
+
+	if (vpu_dev->callback)
+		return -EEXIST;
+
+	vpu_dev->callback = callback;
+
+	return 0;
+}
+EXPORT_SYMBOL(intel_keembay_vpu_register_for_events);
+
+/**
+ * intel_keembay_vpu_unregister_for_events() - Unregister callback for event notification
+ * Return: 0 on success, negative error code otherwise
+ */
+int intel_keembay_vpu_unregister_for_events(struct device *dev)
+{
+	struct vpu_ipc_dev *vpu_dev = to_vpu_dev(dev);
+
+	if (IS_ERR(vpu_dev))
+		return PTR_ERR(vpu_dev);
+
+	vpu_dev->callback = NULL;
+
+	return 0;
+}
+EXPORT_SYMBOL(intel_keembay_vpu_unregister_for_events);
+
 static inline ssize_t show_attr_u32(char *buf, u32 val)
 {
 	return sprintf(buf, "0x%x\n", val);
diff --git a/include/linux/keembay-vpu-ipc.h b/include/linux/keembay-vpu-ipc.h
index 21a38637606f..fa4184a38ef3 100644
--- a/include/linux/keembay-vpu-ipc.h
+++ b/include/linux/keembay-vpu-ipc.h
@@ -31,6 +31,14 @@ enum intel_keembay_wdt_cpu_id {
 	KEEMBAY_VPU_NCE
 };
 
+/* Events that can be notified via callback, when registered. */
+enum intel_keembay_vpu_event {
+	KEEMBAY_VPU_NOTIFY_DISCONNECT = 0,
+	KEEMBAY_VPU_NOTIFY_CONNECT,
+	KEEMBAY_VPU_NOTIFY_MSS_WDT,
+	KEEMBAY_VPU_NOTIFY_NCE_WDT,
+};
+
 int intel_keembay_vpu_ipc_open_channel(struct device *dev, u8 node_id,
 				       u16 chan_id);
 int intel_keembay_vpu_ipc_close_channel(struct device *dev, u8 node_id,
@@ -46,5 +54,9 @@ enum intel_keembay_vpu_state intel_keembay_vpu_status(struct device *dev);
 int intel_keembay_vpu_get_wdt_count(struct device *dev,
 				    enum intel_keembay_wdt_cpu_id id);
 int intel_keembay_vpu_wait_for_ready(struct device *dev, u32 timeout);
+int intel_keembay_vpu_register_for_events(struct device *dev,
+					  void (*callback)(struct device *dev,
+							   enum intel_keembay_vpu_event event));
+int intel_keembay_vpu_unregister_for_events(struct device *dev);
 
 #endif /* __KEEMBAY_VPU_IPC_H */
-- 
2.27.0

