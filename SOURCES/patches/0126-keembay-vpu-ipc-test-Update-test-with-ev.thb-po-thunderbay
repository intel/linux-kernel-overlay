From 4af0d774f5f60f6b3b436d2633fae3f10f3f3aca Mon Sep 17 00:00:00 2001
From: Daniele Alessandrelli <daniele.alessandrelli@intel.com>
Date: Mon, 27 Jul 2020 14:26:41 +0100
Subject: [PATCH 126/223] keembay-vpu-ipc-test: Update test with event
 notification callback

Update test with event notification callback

Signed-off-by: Mike Healy <mikex.healy@intel.com>
Signed-off-by: Daniele Alessandrelli <daniele.alessandrelli@intel.com>
---
 drivers/firmware/keembay-vpu-ipc-test.c | 60 ++++++++++++++++++++++---
 1 file changed, 54 insertions(+), 6 deletions(-)

diff --git a/drivers/firmware/keembay-vpu-ipc-test.c b/drivers/firmware/keembay-vpu-ipc-test.c
index fc8166d0e238..358ec79a3783 100644
--- a/drivers/firmware/keembay-vpu-ipc-test.c
+++ b/drivers/firmware/keembay-vpu-ipc-test.c
@@ -96,6 +96,28 @@ static const struct file_operations test_fw_name_fops = {
 	.release		= single_release,
 };
 
+static void test_notification_cb(struct device *dev,
+				 enum intel_keembay_vpu_event event)
+{
+	switch (event) {
+	case KEEMBAY_VPU_NOTIFY_DISCONNECT:
+		pr_info("KEEMBAY_VPU_NOTIFY_DISCONNECT event notification received\n");
+		break;
+	case KEEMBAY_VPU_NOTIFY_CONNECT:
+		pr_info("KEEMBAY_VPU_NOTIFY_CONNECT event notification received\n");
+		break;
+	case KEEMBAY_VPU_NOTIFY_MSS_WDT:
+		pr_info("KEEMBAY_VPU_NOTIFY_MSS_WDT event notification received\n");
+		break;
+	case KEEMBAY_VPU_NOTIFY_NCE_WDT:
+		pr_info("KEEMBAY_VPU_NOTIFY_NCE_WDT event notification received\n");
+		break;
+	default:
+		pr_err("Unrecognised event received: 0x%02x\n", event);
+		break;
+	}
+}
+
 static int intel_keembay_vpu_ipc_test_send_data(struct device *dev)
 {
 	int ret;
@@ -133,11 +155,21 @@ static int test_vpu_start(struct device *dev)
 	int ret;
 	enum intel_keembay_vpu_state state;
 
+	/* Register callback for event notifications */
+	ret = intel_keembay_vpu_register_for_events(dev,
+						    &test_notification_cb);
+	if (ret == -EEXIST)
+		pr_err("Callback already registered. Unable to reregister\n");
+	else if (ret)
+		pr_err("Unable to register notification callback\n");
+	else
+		pr_info("Notification callback registered\n");
+
 	/* Boot VPU */
 	ret = intel_keembay_vpu_startup(dev, test_fw_name);
 	if (ret) {
 		pr_err("Failed to start VPU: %d\n", ret);
-		return ret;
+		goto unregister_notify;
 	}
 	pr_info("Successfully started VPU!\n");
 
@@ -145,7 +177,7 @@ static int test_vpu_start(struct device *dev)
 	ret = intel_keembay_vpu_wait_for_ready(dev, TEST_READY_WAIT_TIME_MS);
 	if (ret) {
 		pr_err("Tried to start VPU but never got READY.\n");
-		return ret;
+		goto unregister_notify;
 	}
 	pr_info("Successfully synchronised state with VPU - after start!\n");
 
@@ -153,11 +185,20 @@ static int test_vpu_start(struct device *dev)
 	state = intel_keembay_vpu_status(dev);
 	if (state != KEEMBAY_VPU_READY) {
 		pr_err("VPU was not ready, it was %d\n", state);
-		return -EIO;
+		ret = -EIO;
+		goto unregister_notify;
 	}
 	pr_info("VPU was ready.\n");
 
 	return 0;
+
+unregister_notify:
+	/* Unregister callback for event notifications */
+	intel_keembay_vpu_unregister_for_events(dev);
+	pr_info("%s: Notification callback unregistered due to error\n",
+		__func__);
+
+	return ret;
 }
 
 static int test_vpu_reset(struct device *dev)
@@ -191,7 +232,7 @@ static int test_vpu_stop(struct device *dev)
 	ret = intel_keembay_vpu_stop(dev);
 	if (ret) {
 		pr_err("Failed to stop VPU: %d\n", ret);
-		return ret;
+		goto unregister_notify;
 	}
 	pr_info("Successfully stopped VPU!\n");
 
@@ -200,9 +241,16 @@ static int test_vpu_stop(struct device *dev)
 	if (state != KEEMBAY_VPU_OFF) {
 		pr_err("VPU was not OFF after stop request, it was %d\n",
 		       state);
-		return -EIO;
+		ret = -EIO;
 	}
-	return 0;
+
+unregister_notify:
+	/* Unregister callback for event notifications */
+	intel_keembay_vpu_unregister_for_events(dev);
+	pr_info("%s: Notification callback unregistered\n",
+		__func__);
+
+	return ret;
 }
 
 static int run_vpu_test(struct device *dev)
-- 
2.27.0

