From 5168829d2e0ea4659eaabdc27cd1ecf0e16aa6d5 Mon Sep 17 00:00:00 2001
From: Tomas Winkler <tomas.winkler@intel.com>
Date: Mon, 4 Nov 2019 01:28:16 +0200
Subject: [PATCH 11/33] mei: [WIP] add support to GSC extended header

Change-Id: I0f70a24c0debf884e8c69aca170094cd655c649e
Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
---
 drivers/misc/mei/client.c    | 32 ++++++++++++++++++++++----
 drivers/misc/mei/hbm.c       | 13 +++++++++++
 drivers/misc/mei/hw.h        | 33 +++++++++++++++++++++++++++
 drivers/misc/mei/interrupt.c | 44 ++++++++++++++++++++++++++++++++----
 drivers/misc/mei/mei_dev.h   |  2 ++
 5 files changed, 116 insertions(+), 8 deletions(-)

diff --git a/drivers/misc/mei/client.c b/drivers/misc/mei/client.c
index 5e71f455db35..ecf2ec2711d0 100644
--- a/drivers/misc/mei/client.c
+++ b/drivers/misc/mei/client.c
@@ -1748,16 +1748,21 @@ static struct mei_msg_hdr *mei_msg_hdr_init(const struct mei_cl_cb *cb)
 {
 	size_t hdr_len;
 	struct mei_ext_meta_hdr *meta;
-	struct mei_ext_hdr *ext;
+	struct mei_ext_hdr *vtag;
+	struct mei_ext_hdr *gsc_hdr;
+	struct mei_ext_hdr_gsc_h2f *gsc_h2f;
 	struct mei_msg_hdr *mei_hdr;
-	bool is_ext, is_vtag;
+	bool is_ext, is_hbm, is_gsc, is_vtag;
+	struct mei_ext_hdr *next_ext;
 
 	if (!cb)
 		return ERR_PTR(-EINVAL);
 
 	/* Extended header for vtag is attached only on the first fragment */
 	is_vtag = (cb->vtag && cb->buf_idx == 0);
-	is_ext = is_vtag;
+	is_hbm = cb->cl->me_cl->client_id == 0;
+	is_gsc = !(is_hbm) && cb->cl->dev->hbm_f_gsc_supported;
+	is_ext = is_vtag || is_gsc;
 
 	/* Compute extended header size */
 	hdr_len = sizeof(*mei_hdr);
@@ -1767,7 +1772,10 @@ static struct mei_msg_hdr *mei_msg_hdr_init(const struct mei_cl_cb *cb)
 
 	hdr_len += sizeof(*meta);
 	if (is_vtag)
-		hdr_len += sizeof(*ext);
+		hdr_len += sizeof(*vtag);
+
+	if (is_gsc)
+		hdr_len += sizeof(*gsc_hdr) + sizeof(*gsc_h2f);
 
 setup_hdr:
 	mei_hdr = kzalloc(hdr_len, GFP_KERNEL);
@@ -1783,10 +1791,26 @@ static struct mei_msg_hdr *mei_msg_hdr_init(const struct mei_cl_cb *cb)
 		goto out;
 
 	meta = (struct mei_ext_meta_hdr *)mei_hdr->extension;
+	meta->size = 0;
+	next_ext = meta->hdrs;
 	if (is_vtag) {
 		meta->count++;
 		meta->size += mei_ext_hdr_set_vtag(meta->hdrs, cb->vtag);
+		next_ext = mei_ext_next(next_ext);
+	}
+
+	if (is_gsc) {
+		/* FIXME: add actual field values... */
+		meta->count++;
+		gsc_hdr = next_ext;
+		gsc_hdr->type = MEI_EXT_HDR_GSC;
+		gsc_h2f = (struct mei_ext_hdr_gsc_h2f *)gsc_hdr->hdr;
+
+		meta->size += mei_data2slots(sizeof(*gsc_hdr) +
+					     sizeof(*gsc_h2f));
+		next_ext = mei_ext_next(next_ext);
 	}
+
 out:
 	mei_hdr->length = hdr_len - sizeof(*mei_hdr);
 	return mei_hdr;
diff --git a/drivers/misc/mei/hbm.c b/drivers/misc/mei/hbm.c
index d0277c7fed10..d973fa3a3b98 100644
--- a/drivers/misc/mei/hbm.c
+++ b/drivers/misc/mei/hbm.c
@@ -340,9 +340,13 @@ static int mei_hbm_capabilities_req(struct mei_device *dev)
 	req.hbm_cmd = MEI_HBM_CAPABILITIES_REQ_CMD;
 	if (dev->hbm_f_vt_supported)
 		req.capability_requested[0] |= HBM_CAP_VT;
+
 	if (dev->hbm_f_cd_supported)
 		req.capability_requested[0] |= HBM_CAP_CD;
 
+	if (dev->hbm_f_gsc_supported)
+		req.capability_requested[0] |= HBM_CAP_GSC;
+
 	ret = mei_hbm_write_message(dev, &mei_hdr, &req);
 	if (ret) {
 		dev_err(dev->dev,
@@ -1192,6 +1196,12 @@ static void mei_hbm_config_features(struct mei_device *dev)
 	     dev->version.minor_version >= HBM_MINOR_VERSION_VT))
 		dev->hbm_f_vt_supported = 1;
 
+	/* GSC support */
+	if (dev->version.major_version > HBM_MAJOR_VERSION_GSC ||
+	    (dev->version.major_version == HBM_MAJOR_VERSION_GSC &&
+	     dev->version.minor_version >= HBM_MINOR_VERSION_GSC))
+		dev->hbm_f_gsc_supported = 1;
+
 	/* Capability message Support */
 	dev->hbm_f_cap_supported = 0;
 	if (dev->version.major_version > HBM_MAJOR_VERSION_CAP ||
@@ -1357,6 +1367,9 @@ int mei_hbm_dispatch(struct mei_device *dev, struct mei_msg_hdr *hdr)
 		if (!(capability_res->capability_granted[0] & HBM_CAP_CD))
 			dev->hbm_f_cd_supported = 0;
 
+		if (!(capability_res->capability_granted[0] & HBM_CAP_GSC))
+			dev->hbm_f_gsc_supported = 0;
+
 		if (dev->hbm_f_dr_supported) {
 			if (mei_dmam_ring_alloc(dev))
 				dev_info(dev->dev, "running w/o dma ring\n");
diff --git a/drivers/misc/mei/hw.h b/drivers/misc/mei/hw.h
index bc240b88abf1..b3e7e482f807 100644
--- a/drivers/misc/mei/hw.h
+++ b/drivers/misc/mei/hw.h
@@ -87,6 +87,12 @@
 #define HBM_MINOR_VERSION_VT               2
 #define HBM_MAJOR_VERSION_VT               2
 
+/*
+ * MEI version with GSC support
+ */
+#define HBM_MINOR_VERSION_GSC              2
+#define HBM_MAJOR_VERSION_GSC              2
+
 /*
  * MEI version with capabilities message support
  */
@@ -224,10 +230,12 @@ enum mei_cl_disconnect_status {
  *
  * @MEI_EXT_HDR_NONE: sentinel
  * @MEI_EXT_HDR_VTAG: vtag header
+ * @MEI_EXT_HDR_GSC: gsc header
  */
 enum mei_ext_hdr_type {
 	MEI_EXT_HDR_NONE = 0,
 	MEI_EXT_HDR_VTAG = 1,
+	MEI_EXT_HDR_GSC = 2,
 };
 
 /**
@@ -288,6 +296,27 @@ static inline bool mei_ext_last(struct mei_ext_meta_hdr *meta,
 	return (u8 *)ext >= (u8 *)meta + sizeof(*meta) + (meta->size * 4);
 }
 
+struct mei_gsc_sgl {
+	u32 low;
+	u32 high;
+	u32 length;
+} __packed;
+
+struct mei_ext_hdr_gsc_h2f {
+	u32                fence_id;
+	u32                addr_type;
+	u32                input_address_count;
+	u32                output_address_count;
+	struct mei_gsc_sgl input_buffer[0];
+	struct mei_gsc_sgl output_buffer[0];
+} __packed;
+
+struct mei_ext_hdr_gsc_f2h {
+	u8  reserved[2];
+	u32 fence_id;
+	u32 total_bytes_written;
+} __packed;
+
 /**
  *mei_ext_next - following extended header on the TLV list
  *
@@ -665,6 +694,10 @@ struct hbm_dma_ring_ctrl {
 
 /* virtual tag supported */
 #define HBM_CAP_VT BIT(0)
+
+/* gsc extended header support */
+#define HBM_CAP_GSC BIT(1)
+
 /* client dma supported */
 #define HBM_CAP_CD BIT(2)
 
diff --git a/drivers/misc/mei/interrupt.c b/drivers/misc/mei/interrupt.c
index a98f6b895af7..58a263f87b38 100644
--- a/drivers/misc/mei/interrupt.c
+++ b/drivers/misc/mei/interrupt.c
@@ -98,6 +98,10 @@ static int mei_cl_irq_read_msg(struct mei_cl *cl,
 	struct mei_device *dev = cl->dev;
 	struct mei_cl_cb *cb;
 
+	struct mei_ext_hdr *vtag = NULL;
+	struct mei_ext_hdr *gsc_hdr = NULL;
+	struct mei_ext_hdr_gsc_f2h *gsc_f2h = NULL;
+
 	size_t buf_sz;
 	u32 length;
 	int ext_len;
@@ -122,18 +126,27 @@ static int mei_cl_irq_read_msg(struct mei_cl *cl,
 	}
 
 	if (mei_hdr->extended) {
+		int is_gsc_next = 0;
 		struct mei_ext_hdr *ext;
-		struct mei_ext_hdr *vtag = NULL;
-
 		ext = mei_ext_begin(meta);
 		do {
+			if (is_gsc_next) {
+				gsc_f2h = (struct mei_ext_hdr_gsc_f2h *)ext;
+				is_gsc_next = 0;
+				continue;
+			}
 			switch (ext->type) {
 			case MEI_EXT_HDR_VTAG:
 				vtag = ext;
 				break;
+			case MEI_EXT_HDR_GSC:
+				gsc_hdr = ext;
+				is_gsc_next = 1;
+				break;
 			case MEI_EXT_HDR_NONE:
 				fallthrough;
 			default:
+				cl_err(dev, cl, "unknown extended header\n");
 				cb->status = -EPROTO;
 				break;
 			}
@@ -141,12 +154,14 @@ static int mei_cl_irq_read_msg(struct mei_cl *cl,
 			ext = mei_ext_next(ext);
 		} while (!mei_ext_last(meta, ext));
 
-		if (!vtag) {
-			cl_dbg(dev, cl, "vtag not found in extended header.\n");
+		if (!vtag && !gsc_hdr) {
+			cl_dbg(dev, cl, "no vtag or gsc found in extended header.\n");
 			cb->status = -EPROTO;
 			goto discard;
 		}
+	}
 
+	if (vtag) {
 		cl_dbg(dev, cl, "vtag: %d\n", vtag->ext_payload[0]);
 		if (cb->vtag && cb->vtag != vtag->ext_payload[0]) {
 			cl_err(dev, cl, "mismatched tag: %d != %d\n",
@@ -157,6 +172,27 @@ static int mei_cl_irq_read_msg(struct mei_cl *cl,
 		cb->vtag = vtag->ext_payload[0];
 	}
 
+	if (gsc_hdr) {
+		if (!dev->hbm_f_gsc_supported) {
+			cl_err(dev, cl,
+			       "gsc extended header is not supported\n");
+			cb->status = -EPROTO;
+			goto discard;
+		}
+
+		if (length) {
+			cl_err(dev, cl, "no data allowed in cb with gsc\n");
+			cb->status = -EPROTO;
+			goto discard;
+		}
+
+		if (!gsc_f2h) {
+			cl_err(dev, cl, "gsc f2h header missing\n");
+			cb->status = -EPROTO;
+			goto discard;
+		}
+	}
+
 	if (!mei_cl_is_connected(cl)) {
 		cl_dbg(dev, cl, "not connected\n");
 		cb->status = -ENODEV;
diff --git a/drivers/misc/mei/mei_dev.h b/drivers/misc/mei/mei_dev.h
index b7b6ef344e80..15b77bb836f5 100644
--- a/drivers/misc/mei/mei_dev.h
+++ b/drivers/misc/mei/mei_dev.h
@@ -467,6 +467,7 @@ struct mei_fw_version {
  * @hbm_f_vt_supported  : hbm feature vtag supported
  * @hbm_f_cap_supported : hbm feature capabilities message supported
  * @hbm_f_cd_supported  : hbm feature client dma supported
+ * @hbm_f_gsc_supported : hbm feature gsc supported
  *
  * @fw_ver : FW versions
  *
@@ -555,6 +556,7 @@ struct mei_device {
 	unsigned int hbm_f_vt_supported:1;
 	unsigned int hbm_f_cap_supported:1;
 	unsigned int hbm_f_cd_supported:1;
+	unsigned int hbm_f_gsc_supported:1;
 
 	struct mei_fw_version fw_ver[MEI_MAX_FW_VER_BLOCKS];
 
-- 
2.27.0

