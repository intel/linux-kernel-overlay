From 010f1fc045e89c6968a4bd6027e6f59ab9122c44 Mon Sep 17 00:00:00 2001
From: Daniele Alessandrelli <daniele.alessandrelli@intel.com>
Date: Thu, 9 Jul 2020 12:34:16 +0100
Subject: [PATCH 122/223] keembay-ipc: Clean-up code

- Add check for NULL dev in exported API
- Improve kernel-doc
- Other minor clean-up

Signed-off-by: Daniele Alessandrelli <daniele.alessandrelli@intel.com>
---
 drivers/soc/intel/Kconfig              |  19 +-
 drivers/soc/intel/Makefile             |   2 +-
 drivers/soc/intel/keembay-ipc-common.h |  49 ----
 drivers/soc/intel/keembay-ipc.c        | 332 +++++++++++++++++--------
 include/linux/soc/intel/keembay-ipc.h  |  13 +-
 5 files changed, 242 insertions(+), 173 deletions(-)
 delete mode 100644 drivers/soc/intel/keembay-ipc-common.h

diff --git a/drivers/soc/intel/Kconfig b/drivers/soc/intel/Kconfig
index 35f8ce80bf4d..ad834023015c 100644
--- a/drivers/soc/intel/Kconfig
+++ b/drivers/soc/intel/Kconfig
@@ -1,5 +1,18 @@
+# SPDX-License-Identifier: GPL-2.0-only
+#
+# Intel SoC drivers
+#
+
+menu "Intel SoC drivers"
+
 config KEEMBAY_IPC
-	tristate "Support for KeemBay IPC"
+	tristate "Support for Intel Keem Bay IPC"
+	depends on ARM64 && OF || COMPILE_TEST
 	help
-	  KeemBay IPC enables communication between KeemBay CPU Sub-System
-	  (CSS) and KeemBay Media Sub-System (MSS).
+	  Keem Bay IPC enables communication between the Keem Bay CPU
+	  Sub-System (CSS) and the Keem Bay Media Sub-System (MSS).
+
+	  Select this if you are compiling the Kernel for the Intel Movidius
+	  SoC code named Keem Bay.
+
+endmenu
diff --git a/drivers/soc/intel/Makefile b/drivers/soc/intel/Makefile
index 4486e4231bd4..ecf0246e7822 100644
--- a/drivers/soc/intel/Makefile
+++ b/drivers/soc/intel/Makefile
@@ -1,4 +1,4 @@
 #
-# Makefile for KeemBay IPC Linux driver
+# Makefile for Keem Bay IPC Linux driver
 #
 obj-$(CONFIG_KEEMBAY_IPC) += keembay-ipc.o
diff --git a/drivers/soc/intel/keembay-ipc-common.h b/drivers/soc/intel/keembay-ipc-common.h
deleted file mode 100644
index 9b5bf18e5e54..000000000000
--- a/drivers/soc/intel/keembay-ipc-common.h
+++ /dev/null
@@ -1,49 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0-only */
-/*
- * KeemBay IPC common definitions.
- *
- * Copyright (C) 2018-2019 Intel Corporation
- */
-
-#ifndef __KEEMBAY_IPC_COMMON_H
-#define __KEEMBAY_IPC_COMMON_H
-
-/* The alignment to be used for IPC Buffers and IPC Data. */
-#define KMB_IPC_ALIGNMENT		64
-
-/* Maximum number of channels per link. */
-#define KMB_IPC_MAX_CHANNELS		1024
-
-/* The number of high-speed channels per link. */
-#define KMB_IPC_NUM_HIGH_SPEED_CHANNELS	10
-
-/* The possible states of an IPC buffer. */
-enum {
-	/*
-	 * KMB_IPC_BUF_FREE must be set to 0 to ensure that buffers can be
-	 * initialized with memset(&buf, 0, sizeof(buf)).
-	 */
-	KMB_IPC_BUF_FREE = 0,
-	KMB_IPC_BUF_ALLOCATED,
-};
-
-/**
- * struct kmb_ipc_buf - The IPC buffer structure.
- * @data_addr:	The address where the IPC payload is located; NOTE: this is a
- *		VPU address (not a CPU one).
- * @data_size:	The size of the payload.
- * @channel:	The channel used.
- * @src_node:	The Node ID of the sender.
- * @dst_node:	The Node ID of the intended receiver.
- * @status:	Either free or allocated.
- */
-struct kmb_ipc_buf {
-	uint32_t data_addr;
-	uint32_t data_size;
-	uint16_t channel;
-	uint8_t src_node;
-	uint8_t dst_node;
-	uint8_t status;
-} __packed __aligned(KMB_IPC_ALIGNMENT);
-
-#endif /* __KEEMBAY_IPC_COMMON_H */
diff --git a/drivers/soc/intel/keembay-ipc.c b/drivers/soc/intel/keembay-ipc.c
index b6802acc088a..2f27a20d914a 100644
--- a/drivers/soc/intel/keembay-ipc.c
+++ b/drivers/soc/intel/keembay-ipc.c
@@ -1,14 +1,58 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * KeemBay IPC Driver.
+ * Keem Bay IPC Driver.
  *
- * Copyright (C) 2018-2019 Intel Corporation
+ * Copyright (C) 2018-2020 Intel Corporation
+ *
+ * This driver enables Inter-Processor Communication (IPC) between the
+ * Computing Sub-System (CSS) and the Multimedia Sub-System (MSS) of Keem Bay.
+ * CSS is where Linux is running; while MSS is where the VPU firmware runs.
+ *
+ * The IPC uses the following terminology:
+ *
+ * - Node:    A processing entity that can use the IPC to communicate
+ *	      (currently, we just have two nodes, CSS and MSS).
+ *
+ * - Link:    Two nodes that can communicate over IPC form an IPC link
+ *	      (currently, we just have one link, the one formed by CSS and MSS).
+ *
+ * - Channel: An IPC link can provide multiple IPC channels. IPC channels allow
+ *            communication multiplexing, i.e., the same IPC link can be used
+ *            by different applications for different communications. Each
+ *            channel is identified by a channel ID, which must be unique
+ *            within a single IPC link. Channels are divided in two categories,
+ *            High-Speed (HS) channels and General-Purpose (GP) channels.
+ *            HS channels have higher priority over GP channels.
+ *
+ * Keem Bay IPC mechanism is based on shared memory and hardware FIFOs. Both
+ * CSS and MSS have their own hardware FIFO. When CSS wants to send an IPC
+ * message to MSS, it writes to the MSS FIFO; similarly, when MSS wants to send
+ * an IPC message to CSS, it writes to the CSS FIFO.
+ *
+ * A FIFO entry is simply a pointer to an IPC buffer (aka IPC header) stored in
+ * a portion of memory shared between CSS and MSS. Specifically, the FIFO entry
+ * contains the (VPU) physical address of the IPC buffer being transferred.
+ *
+ * In turn, the IPC buffer contains the (VPU) physical address of the payload
+ * (which must be located in shared memory too) as well as other information
+ * (payload size, IPC channel ID, etc.).
+ *
+ * Each IPC node instantiates a pool of IPC buffers from its own IPC buffer
+ * memory region. When instantiated, IPC buffers are marked as free. When the
+ * node needs to send an IPC message, it gets the first free buffer it finds
+ * (from its own pool), marks it as allocated (used), and puts its physical
+ * address into the IPC FIFO of the destination node. The destination node
+ * (which is notified by an interrupt when there are entries pending in its
+ * FIFO) extract the physical address from the FIFO and process the IPC buffer,
+ * marking it as free once done (so that the sender can reuse the buffer).
+ *
+ * Note: Keem Bay IPC is not based on RPMsg, since MSS HW/FW does not support
+ * Virtio and Virtqueues.
  */
 
-#include <linux/completion.h>
 #include <linux/circ_buf.h>
+#include <linux/completion.h>
 #include <linux/dma-mapping.h>
-#include <linux/init.h>
 #include <linux/interrupt.h>
 #include <linux/io.h>
 #include <linux/jiffies.h>
@@ -26,9 +70,16 @@
 
 #include <linux/soc/intel/keembay-ipc.h>
 
-#include "keembay-ipc-common.h"
+#define DRV_NAME		"keembay-ipc"
+
+/* The alignment to be used for IPC Buffers and IPC Data. */
+#define KMB_IPC_ALIGNMENT	64
 
-#define DRV_NAME		"kmb-ipc-driver"
+/* Maximum number of channels per link. */
+#define KMB_IPC_MAX_CHANNELS	1024
+
+/* The number of high-speed channels per link. */
+#define KMB_IPC_NUM_HS_CHANNELS	10
 
 /* The IPC Node ID of this node. */
 #define MY_NODE_ID		KMB_IPC_NODE_ARM_CSS
@@ -60,40 +111,82 @@
 #define IPC_FIFO_OF_FLAG0	0x10
 #define IPC_FIFO_OF_FLAG1	0x14
 
+/* The possible states of an IPC buffer. */
+enum {
+	/*
+	 * KMB_IPC_BUF_FREE must be set to 0 to ensure that buffers can be
+	 * initialized with memset(&buf, 0, sizeof(buf)).
+	 */
+	KMB_IPC_BUF_FREE = 0,
+	KMB_IPC_BUF_ALLOCATED,
+};
+
+/**
+ * struct kmb_ipc_buf - The IPC buffer structure.
+ * @data_addr:	The address where the IPC payload is located; NOTE: this is a
+ *		VPU address (not a CPU one).
+ * @data_size:	The size of the payload.
+ * @channel:	The channel used.
+ * @src_node:	The Node ID of the sender.
+ * @dst_node:	The Node ID of the intended receiver.
+ * @status:	Either free or allocated.
+ */
+struct kmb_ipc_buf {
+	u32 data_addr;
+	u32 data_size;
+	u16 channel;
+	u8  src_node;
+	u8  dst_node;
+	u8  status;
+} __packed __aligned(KMB_IPC_ALIGNMENT);
 
-/* struct ipc_buf_mem - IPC Buffer Memory Region. */
+/**
+ * struct ipc_buf_mem - IPC Buffer Memory Region.
+ * @dev:	Child device managing the memory region.
+ * @vaddr:	The virtual address of the memory region.
+ * @dma_handle:	The VPU address of the memory region.
+ * @size:	The size of the memory region.
+ */
 struct ipc_buf_mem {
-	struct device *dev;	/* Child device managing the memory region. */
-	void *vaddr;		/* The virtual address of the memory region. */
-	dma_addr_t dma_handle;  /* The VPU address of the memory region. */
-	size_t size;		/* The size of the memory region. */
+	struct device *dev;
+	void *vaddr;
+	dma_addr_t dma_handle;
+	size_t size;
 };
 
-/* IPC buffer pool. */
+/**
+ * struct ipc_buf_pool - IPC buffer pool.
+ * @buffers:	Pointer to the array of buffers.
+ * @buf_cnt:	Pool size (i.e., number of buffers).
+ * @idx:	Current index.
+ * @lock:	The lock protecting this pool.
+ */
 struct ipc_buf_pool {
-	struct kmb_ipc_buf *buffers; /* Pointer to the array of buffers. */
-	size_t buf_cnt;		     /* Pool size (i.e., number of buffers). */
-	size_t idx;		     /* Current index. */
-	spinlock_t lock;	     /* The lock protecting this pool. */
+	struct kmb_ipc_buf *buffers;
+	size_t buf_cnt;
+	size_t idx;
+	spinlock_t lock; /* Protects 'idx' and 'buffers'. */
 };
 
-/* IPC channel. */
+/**
+ * struct ipc_chan - IPC channel.
+ * @rx_data_list:	The list of incoming messages.
+ * @rx_lock:		The lock for modifying the rx_data_list.
+ * @rx_wait_queue:	The wait queue for RX Data (recv() waits on it).
+ * @closing:		Closing flag, set when the channel is being closed.
+ */
 struct ipc_chan {
-	/* The list of incoming messages. */
 	struct list_head rx_data_list;
-	/* The lock for modifying the rx_data_list. */
-	spinlock_t rx_lock;
-	/* The wait queue for RX Data (recv() waits on it). */
+	spinlock_t rx_lock; /* Protects 'rx_data_list'. */
 	wait_queue_head_t rx_wait_queue;
-	/* Closing flag, set when the channel is being closed. */
 	bool closing;
 };
 
 /**
  * struct tx_data - Element of a TX queue.
- * @vpu_addr:	The VPU address of the data to be "transferred".
- * @size:	The size of the data to be "transferred".
- * @chan_id:	The channel to be used for the "transfer".
+ * @vpu_addr:	The VPU address of the data to be transferred.
+ * @size:	The size of the data to be transferred.
+ * @chan_id:	The channel to be used for the transfer.
  * @dst_node:	The destination node.
  * @retv:	The result of the transfer.
  * @list:	The list head used to concatenate TX data elements.
@@ -117,7 +210,7 @@ struct tx_data {
  */
 struct tx_queue {
 	struct list_head tx_data_list;
-	spinlock_t lock;
+	spinlock_t lock;	/* Protects tx_data_list. */
 };
 
 /**
@@ -135,9 +228,9 @@ struct tx_queue {
  */
 struct ipc_link {
 	struct ipc_chan __rcu *channels[KMB_IPC_MAX_CHANNELS];
-	spinlock_t chan_lock;
+	spinlock_t chan_lock; /* Protects modifications to 'channels'. */
 	struct srcu_struct srcu_sp[KMB_IPC_MAX_CHANNELS];
-	struct tx_queue tx_queues[KMB_IPC_NUM_HIGH_SPEED_CHANNELS + 1];
+	struct tx_queue tx_queues[KMB_IPC_NUM_HS_CHANNELS + 1];
 	int tx_qidx;
 	struct completion tx_queued;
 	struct task_struct *tx_thread;
@@ -172,9 +265,9 @@ struct rx_circ_buf {
  *                          local FIFO IRQ.
  * @local_fifo_reg:	    The base address of the local HW FIFO.
  * @remote_fifo_reg:	    The base address of the remote HW FIFO (i.e., the
- *                          Leon MSS FIFO).
- * @rx_sw_fifo:		The RX SW FIFO. The RX ISR writes to this FIFO and
- *                  the RX tasklet reads from it.
+ *			    Leon MSS FIFO).
+ * @rx_sw_fifo		    The RX SW FIFO. The RX ISR writes to this FIFO and
+ *			    the RX tasklet reads from it.
  */
 struct keembay_ipc_dev {
 	struct platform_device *plat_dev;
@@ -184,7 +277,7 @@ struct keembay_ipc_dev {
 	struct ipc_link leon_mss_link;
 	int local_fifo_irq;
 	int local_fifo_irq_enabled;
-	spinlock_t local_fifo_irq_lock;
+	spinlock_t local_fifo_irq_lock; /* Protects status of FIFO IRQ. */
 	void __iomem *local_fifo_reg;
 	void __iomem *remote_fifo_reg;
 	struct tasklet_struct rx_tasklet;
@@ -213,7 +306,6 @@ static irqreturn_t local_fifo_irq_handler(int irq, void *dev_id);
 /* Forward declaration of RX tasklet function. */
 static void rx_tasklet_func(unsigned long);
 
-
 /*
  * Functions related to reserved-memory sub-devices.
  */
@@ -390,7 +482,6 @@ static void remote_fifo_put(struct keembay_ipc_dev *ipc_dev, u32 entry)
 	iowrite32(entry, ipc_dev->remote_fifo_reg + IPC_FIFO);
 }
 
-
 /*
  * Check if we have overflowed the remote FIFO.
  *
@@ -438,6 +529,7 @@ static bool remote_fifo_overflow(struct keembay_ipc_dev *ipc_dev)
 	/* Clear our overflow bit, if we overflowed. */
 	if (rc)
 		iowrite32(mask, ipc_dev->remote_fifo_reg + offset);
+
 	return rc;
 }
 
@@ -487,12 +579,11 @@ static int channel_close(struct ipc_link *link, u16 chan_id)
 	return 1;
 }
 
-/*
- * Allocate an IPC buffer to be used for TX.
- *
- * @param pool The IPC buffer pool from which the IPC buffer will be allocated.
+/**
+ * ipc_buf_tx_alloc() - Allocate an IPC buffer to be used for TX.
+ * @pool:  The IPC buffer pool from which the IPC buffer will be allocated.
  *
- * @return The pointer to the allocated buffer, or NULL if allocation fails.
+ * Return: The pointer to the allocated buffer, or NULL if allocation fails.
  */
 static struct kmb_ipc_buf *ipc_buf_tx_alloc(struct ipc_buf_pool *pool)
 {
@@ -526,12 +617,15 @@ static struct kmb_ipc_buf *ipc_buf_tx_alloc(struct ipc_buf_pool *pool)
 	return NULL;
 }
 
-/*
- * Init the IPC Buffer Pool.
+/**
+ * init_ipc_buf_pool() - Init the IPC Buffer Pool.
+ * @ipc_dev:	The IPC device the pool belongs to.
  *
  * Set up the IPC Buffer Pool to be used for allocating TX buffers.
  *
  * The pool uses the local IPC Buffer memory previously allocated.
+ *
+ * Return:	0 on success, negative error code otherwise.
  */
 static int init_ipc_buf_pool(struct keembay_ipc_dev *ipc_dev)
 {
@@ -548,6 +642,7 @@ static int init_ipc_buf_pool(struct keembay_ipc_dev *ipc_dev)
 	dev_info(&ipc_dev->plat_dev->dev, "IPC Buffer Pool size: %zu\n",
 		 ipc_dev->ipc_buf_pool.buf_cnt);
 	spin_lock_init(&ipc_dev->ipc_buf_pool.lock);
+
 	return 0;
 }
 
@@ -700,8 +795,6 @@ static int kmb_ipc_probe(struct platform_device *pdev)
 	struct keembay_ipc_dev *ipc_dev;
 	struct device *dev = &pdev->dev;
 
-	dev_info(&pdev->dev, "Keem Bay IPC device probing");
-
 	ipc_dev = devm_kzalloc(dev, sizeof(*ipc_dev), GFP_KERNEL);
 	if (!ipc_dev)
 		return -ENOMEM;
@@ -745,8 +838,6 @@ static int kmb_ipc_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, ipc_dev);
 
-	dev_info(&pdev->dev, "Keem Bay IPC device probed");
-
 	return 0;
 }
 
@@ -770,25 +861,6 @@ static int kmb_ipc_remove(struct platform_device *pdev)
 	return 0;
 }
 
-/*
- * Perform basic validity check on specified node ID and channel ID.
- *
- * Verify that the specified node ID and the channel ID are within the allowed
- * ranges.
- */
-static int validate_link_chan(struct device *dev, u8 node_id, u16 chan_id)
-{
-	if (node_id != KMB_IPC_NODE_LEON_MSS) {
-		dev_warn(dev, "Invalid Link ID\n");
-		return -EINVAL;
-	}
-	if (chan_id >= KMB_IPC_MAX_CHANNELS) {
-		dev_warn(dev, "Invalid Channel ID\n");
-		return -EINVAL;
-	}
-	return 0;
-}
-
 /*
  * ipc_vpu_to_virt() - Convert a VPU address to a CPU virtual address.
  *
@@ -800,10 +872,10 @@ static int validate_link_chan(struct device *dev, u8 node_id, u16 chan_id)
  *	   is not in the expected memory range.
  */
 static void *ipc_vpu_to_virt(const struct ipc_buf_mem *ipc_mem,
-			    u32 vpu_addr)
+			     u32 vpu_addr)
 {
-	if (unlikely(vpu_addr < ipc_mem->dma_handle) ||
-		     vpu_addr >= (ipc_mem->dma_handle + ipc_mem->size))
+	if (unlikely(vpu_addr < ipc_mem->dma_handle ||
+		     vpu_addr >= (ipc_mem->dma_handle + ipc_mem->size)))
 		return NULL;
 	return ipc_mem->vaddr + (vpu_addr - ipc_mem->dma_handle);
 }
@@ -818,7 +890,7 @@ static void *ipc_vpu_to_virt(const struct ipc_buf_mem *ipc_mem,
  * Return: 0 on success, negative error code otherwise.
  */
 static int ipc_virt_to_vpu(struct ipc_buf_mem *ipc_mem, void *vaddr,
-			    u32 *vpu_addr)
+			   u32 *vpu_addr)
 {
 	if (unlikely((ipc_mem->dma_handle + ipc_mem->size) > 0xFFFFFFFF))
 		return -EINVAL;
@@ -832,7 +904,7 @@ static int ipc_virt_to_vpu(struct ipc_buf_mem *ipc_mem, void *vaddr,
 
 /**
  * process_rx_fifo_entry() - Process a FIFO entry.
- * @entry	The FIFO entry to process.
+ * @entry:	The FIFO entry to process.
  * @ipc_dev:	The IPC device to use.
  *
  * This function performs the following tasks:
@@ -904,6 +976,7 @@ static void process_rx_fifo_entry(u32 entry,
 	wake_up_interruptible(&chan->rx_wait_queue);
 	/* Exit SRCU region protecting chan struct. */
 	srcu_read_unlock(&link->srcu_sp[ipc_buf->channel], idx);
+
 exit:
 	barrier(); /* Ensure IPC buffer is fully processed before release. */
 	ipc_buf->status = KMB_IPC_BUF_FREE;
@@ -943,7 +1016,6 @@ static void rx_tasklet_func(unsigned long ipc_dev_ptr)
 	local_fifo_irq_enable(ipc_dev);
 }
 
-
 /*
  * Local FIFO ISR.
  *
@@ -980,6 +1052,7 @@ static irqreturn_t local_fifo_irq_handler(int irq, void *ptr)
 		/* Update head index (wrapping it if needed). */
 		head = (head + 1) & (size - 1);
 	}
+
 exit:
 	/*
 	 * Memory barrier: make sure that updating the buffer head is the last
@@ -1128,7 +1201,7 @@ static void tx_data_enqueue(struct ipc_link *link, struct tx_data *tx_data)
 	 * - All the general-purpose channels use the same TX queue, which is
 	 *   the last element in the tx_queues array.
 	 *
-	 * Note: tx_queues[] has KMB_IPC_NUM_HIGH_SPEED_CHANNELS+1 elements)
+	 * Note: tx_queues[] has KMB_IPC_NUM_HS_CHANNELS+1 elements)
 	 */
 	qid = tx_data->chan_id < ARRAY_SIZE(link->tx_queues) ?
 	      tx_data->chan_id : (ARRAY_SIZE(link->tx_queues) - 1);
@@ -1161,7 +1234,7 @@ static void tx_data_remove(struct ipc_link *link, struct tx_data *tx_data)
 	 * - All the general-purpose channels use the same TX queue, which is
 	 *   the last element in the tx_queues array.
 	 *
-	 * Note: tx_queues[] has KMB_IPC_NUM_HIGH_SPEED_CHANNELS+1 elements)
+	 * Note: tx_queues[] has KMB_IPC_NUM_HS_CHANNELS+1 elements)
 	 */
 	qid = tx_data->chan_id < ARRAY_SIZE(link->tx_queues) ?
 	      tx_data->chan_id : (ARRAY_SIZE(link->tx_queues) - 1);
@@ -1244,11 +1317,57 @@ static int __ipc_send(struct keembay_ipc_dev *ipc_dev, u8 dst_node,
 		goto exit;
 	}
 	rc = tx_data->retv;
+
 exit:
 	kfree(tx_data);
 	return rc;
 }
 
+/*
+ * Driver allocation.
+ */
+
+/* Device tree driver match. */
+static const struct of_device_id kmb_ipc_of_match[] = {
+	{
+		.compatible = "intel,keembay-ipc",
+	},
+	{}
+};
+
+/* The IPC driver is a platform device. */
+static struct platform_driver kmb_ipc_driver = {
+	.probe  = kmb_ipc_probe,
+	.remove = kmb_ipc_remove,
+	.driver = {
+		.name = DRV_NAME,
+		.of_match_table = kmb_ipc_of_match,
+	},
+};
+
+module_platform_driver(kmb_ipc_driver);
+
+/*
+ * Perform basic validity check on common API arguments.
+ *
+ * Verify that the specified device is a Keem Bay IPC device and that node ID
+ * and the channel ID are within the allowed ranges.
+ */
+static int validate_api_args(struct device *dev, u8 node_id, u16 chan_id)
+{
+	if (!dev || dev->driver != &kmb_ipc_driver.driver)
+		return -EINVAL;
+	if (node_id != KMB_IPC_NODE_LEON_MSS) {
+		dev_warn(dev, "Invalid Link ID\n");
+		return -EINVAL;
+	}
+	if (chan_id >= KMB_IPC_MAX_CHANNELS) {
+		dev_warn(dev, "Invalid Channel ID\n");
+		return -EINVAL;
+	}
+	return 0;
+}
+
 /*
  * IPC Kernel API.
  */
@@ -1265,21 +1384,24 @@ static int __ipc_send(struct keembay_ipc_dev *ipc_dev, u8 dst_node,
  */
 int intel_keembay_ipc_open_channel(struct device *dev, u8 node_id, u16 chan_id)
 {
-	/* TODO: ensure dev is not NULL. */
-	struct keembay_ipc_dev *ipc_dev = dev_get_drvdata(dev);
-	struct ipc_link *link = &ipc_dev->leon_mss_link;
+	struct keembay_ipc_dev *ipc_dev;
+	struct ipc_link *link;
 	struct ipc_chan *chan, *cur_chan;
 	unsigned long flags;
 	int rc;
 
-	rc = validate_link_chan(dev, node_id, chan_id);
+	rc = validate_api_args(dev, node_id, chan_id);
 	if (rc)
 		return rc;
 
+	ipc_dev = dev_get_drvdata(dev);
+	link = &ipc_dev->leon_mss_link;
+
 	/* Create channel before getting lock. */
 	chan = kzalloc(sizeof(*chan), GFP_KERNEL);
 	if (!chan)
 		return -ENOMEM;
+
 	INIT_LIST_HEAD(&chan->rx_data_list);
 	spin_lock_init(&chan->rx_lock);
 	init_waitqueue_head(&chan->rx_wait_queue);
@@ -1312,15 +1434,17 @@ EXPORT_SYMBOL(intel_keembay_ipc_open_channel);
  */
 int intel_keembay_ipc_close_channel(struct device *dev, u8 node_id, u16 chan_id)
 {
-	/* TODO: ensure dev is not NULL. */
-	struct keembay_ipc_dev *ipc_dev = dev_get_drvdata(dev);
-	struct ipc_link *link = &ipc_dev->leon_mss_link;
+	struct keembay_ipc_dev *ipc_dev;
+	struct ipc_link *link;
 	int rc;
 
-	rc = validate_link_chan(dev, node_id, chan_id);
+	rc = validate_api_args(dev, node_id, chan_id);
 	if (rc)
 		return rc;
 
+	ipc_dev = dev_get_drvdata(dev);
+	link = &ipc_dev->leon_mss_link;
+
 	rc = channel_close(link, chan_id);
 	if (!rc)
 		dev_info(dev, "Channel was already closed\n");
@@ -1344,15 +1468,17 @@ EXPORT_SYMBOL(intel_keembay_ipc_close_channel);
 int intel_keembay_ipc_send(struct device *dev, u8 node_id, u16 chan_id,
 			   u32 vpu_addr, size_t size)
 {
-	/* TODO: ensure dev is not NULL. */
-	struct keembay_ipc_dev *ipc_dev = dev_get_drvdata(dev);
-	struct ipc_link *link = &ipc_dev->leon_mss_link;
+	struct keembay_ipc_dev *ipc_dev;
+	struct ipc_link *link;
 	struct ipc_chan *chan;
 	int idx, rc;
 
-	rc = validate_link_chan(dev, node_id, chan_id);
+	rc = validate_api_args(dev, node_id, chan_id);
 	if (rc)
 		return rc;
+
+	ipc_dev = dev_get_drvdata(dev);
+	link = &ipc_dev->leon_mss_link;
 	/*
 	 * Start Sleepable RCU critical section (this prevents close() from
 	 * destroying the channels struct while we are sending data)
@@ -1368,6 +1494,7 @@ int intel_keembay_ipc_send(struct device *dev, u8 node_id, u16 chan_id,
 	}
 
 	rc = __ipc_send(ipc_dev, node_id, chan_id, vpu_addr, size);
+
 exit:
 	/* End sleepable RCU critical section. */
 	srcu_read_unlock(&link->srcu_sp[chan_id], idx);
@@ -1393,17 +1520,23 @@ EXPORT_SYMBOL(intel_keembay_ipc_send);
 int intel_keembay_ipc_recv(struct device *dev, u8 node_id, u16 chan_id,
 			   u32 *vpu_addr, size_t *size, u32 timeout)
 {
-	/* TODO: ensure dev is not NULL. */
-	struct keembay_ipc_dev *ipc_dev = dev_get_drvdata(dev);
-	struct ipc_link *link = &ipc_dev->leon_mss_link;
+	struct keembay_ipc_dev *ipc_dev;
+	struct ipc_link *link;
 	struct ipc_chan *chan;
 	struct rx_data *rx_entry;
 	unsigned long flags;
 	int idx, rc;
 
-	rc = validate_link_chan(dev, node_id, chan_id);
+	rc = validate_api_args(dev, node_id, chan_id);
 	if (rc)
 		return rc;
+
+	if (!vpu_addr || !size)
+		return -EINVAL;
+
+	ipc_dev = dev_get_drvdata(dev);
+	link = &ipc_dev->leon_mss_link;
+
 	/*
 	 * Start Sleepable RCU critical section (this prevents close() from
 	 * destroying the channels struct while we are using it)
@@ -1469,6 +1602,7 @@ int intel_keembay_ipc_recv(struct device *dev, u8 node_id, u16 chan_id,
 	*size = rx_entry->data_size;
 	/* Free RX entry. */
 	kfree(rx_entry);
+
 err:
 	/* End sleepable RCU critical section. */
 	srcu_read_unlock(&link->srcu_sp[chan_id], idx);
@@ -1476,27 +1610,7 @@ int intel_keembay_ipc_recv(struct device *dev, u8 node_id, u16 chan_id,
 }
 EXPORT_SYMBOL(intel_keembay_ipc_recv);
 
-/* Device tree driver match. */
-static const struct of_device_id kmb_ipc_of_match[] = {
-	{
-		.compatible = "intel,keembay-ipc",
-	},
-	{}
-};
-
-/* The IPC driver is a platform device. */
-static struct platform_driver kmb_ipc_driver = {
-	.probe = kmb_ipc_probe,
-	.remove = kmb_ipc_remove,
-	.driver = {
-			.name = DRV_NAME,
-			.of_match_table = kmb_ipc_of_match,
-		},
-};
-
-module_platform_driver(kmb_ipc_driver);
-
-MODULE_DESCRIPTION("KeemBay IPC Driver");
+MODULE_DESCRIPTION("Keem Bay IPC Driver");
 MODULE_AUTHOR("Daniele Alessandrelli <daniele.alessandrelli@intel.com>");
 MODULE_AUTHOR("Paul Murphy <paul.j.murphy@intel.com>");
 MODULE_LICENSE("GPL v2");
diff --git a/include/linux/soc/intel/keembay-ipc.h b/include/linux/soc/intel/keembay-ipc.h
index 34c0b7b04dea..bbcf387ecdbd 100644
--- a/include/linux/soc/intel/keembay-ipc.h
+++ b/include/linux/soc/intel/keembay-ipc.h
@@ -1,17 +1,8 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * keembay-ipc.h - KeemBay IPC Linux Kernel API
+ * Keem Bay IPC Linux Kernel API
  *
- * Copyright (C) 2018-2019 Intel Corporation
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the Free
- * Software Foundation; version 2.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
+ * Copyright (C) 2018-2020 Intel Corporation
  */
 
 #ifndef __KEEMBAY_IPC_H
-- 
2.27.0

