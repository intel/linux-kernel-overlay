From 9781a32bb953b0c75d28dadf2565374c8a2c1efe Mon Sep 17 00:00:00 2001
From: kadarlax <raghuveerx.kadarla@intel.com>
Date: Fri, 18 Sep 2020 12:43:24 +0530
Subject: [PATCH 156/223] mxlk: Common driver interface file for lh &rh

Signed-off-by: kadarlax <raghuveerx.kadarla@intel.com>
---
 .../xlink-pcie/{local_host => common}/if.c    | 57 ++++++++++-
 drivers/misc/xlink-pcie/local_host/Makefile   |  2 +-
 drivers/misc/xlink-pcie/remote_host/Makefile  |  2 +-
 drivers/misc/xlink-pcie/remote_host/if.c      | 94 -------------------
 4 files changed, 55 insertions(+), 100 deletions(-)
 rename drivers/misc/xlink-pcie/{local_host => common}/if.c (68%)
 delete mode 100644 drivers/misc/xlink-pcie/remote_host/if.c

diff --git a/drivers/misc/xlink-pcie/local_host/if.c b/drivers/misc/xlink-pcie/common/if.c
similarity index 68%
rename from drivers/misc/xlink-pcie/local_host/if.c
rename to drivers/misc/xlink-pcie/common/if.c
index b7559744be6e..b597636551b8 100644
--- a/drivers/misc/xlink-pcie/local_host/if.c
+++ b/drivers/misc/xlink-pcie/common/if.c
@@ -10,18 +10,29 @@
 #include <linux/errno.h>
 #include <linux/module.h>
 #include <linux/xlink_drv_inf.h>
-#include "../common/core.h"
-#include "epf.h"
 
+#ifdef XLINK_PCIE_REMOTE
+#include "../remote_host/pci.h"
+#else
+#include "core.h"
+#include "../local_host/epf.h"
+#include "../local_host/struct.h"
+#endif
+
+/* Define xpcie driver interface API */
 int xlink_pcie_get_device_list(u32 *sw_device_id_list,
 			       u32 *num_devices)
 {
+#ifdef XLINK_PCIE_LOCAL
 	if (xlink_sw_id != 0) {
 		*num_devices = 1;
 		*sw_device_id_list = xlink_sw_id;
 	} else {
 		*num_devices = 0;
 	}
+#else
+	*num_devices = intel_xpcie_get_device_num(sw_device_id_list);
+#endif
 
 	return 0;
 }
@@ -30,6 +41,7 @@ EXPORT_SYMBOL(xlink_pcie_get_device_list);
 int xlink_pcie_get_device_name(u32 sw_device_id, char *device_name,
 			       size_t name_size)
 {
+#ifdef XLINK_PCIE_LOCAL
 	struct xpcie *xpcie = intel_xpcie_core_get_by_id(sw_device_id);
 
 	if (!xpcie)
@@ -41,17 +53,32 @@ int xlink_pcie_get_device_name(u32 sw_device_id, char *device_name,
 	strncpy(device_name, XPCIE_DRIVER_NAME, name_size);
 
 	return 0;
+#else
+	return intel_xpcie_get_device_name_by_id(sw_device_id,
+						 device_name, name_size);
+#endif
 }
 EXPORT_SYMBOL(xlink_pcie_get_device_name);
 
 int xlink_pcie_get_device_status(u32 sw_device_id, u32 *device_status)
 {
+	u32 status;
+
+#ifdef XLINK_PCIE_LOCAL
 	struct xpcie *xpcie = intel_xpcie_core_get_by_id(sw_device_id);
 
 	if (!xpcie)
 		return -ENODEV;
 
-	switch (xpcie->status) {
+	status = xpcie->status;
+#else
+	int rc;
+
+	rc = intel_xpcie_get_device_status_by_id(sw_device_id, &status);
+	if (rc)
+		return rc;
+#endif
+	switch (status) {
 	case XPCIE_STATUS_READY:
 	case XPCIE_STATUS_RUN:
 		*device_status = _XLINK_DEV_READY;
@@ -59,6 +86,12 @@ int xlink_pcie_get_device_status(u32 sw_device_id, u32 *device_status)
 	case XPCIE_STATUS_ERROR:
 		*device_status = _XLINK_DEV_ERROR;
 		break;
+	case XPCIE_STATUS_RECOVERY:
+		*device_status = _XLINK_DEV_RECOVERY;
+		break;
+	case XPCIE_STATUS_OFF:
+		*device_status = _XLINK_DEV_OFF;
+		break;
 	default:
 		*device_status = _XLINK_DEV_BUSY;
 		break;
@@ -76,6 +109,7 @@ EXPORT_SYMBOL(xlink_pcie_boot_device);
 
 int xlink_pcie_connect(u32 sw_device_id)
 {
+#ifdef XLINK_PCIE_LOCAL
 	struct xpcie *xpcie = intel_xpcie_core_get_by_id(sw_device_id);
 
 	if (!xpcie)
@@ -85,35 +119,50 @@ int xlink_pcie_connect(u32 sw_device_id)
 		return -EIO;
 
 	return 0;
+#else
+	return intel_xpcie_pci_connect_device(sw_device_id);
+#endif
 }
 EXPORT_SYMBOL(xlink_pcie_connect);
 
 int xlink_pcie_read(u32 sw_device_id, void *data, size_t *const size,
 		    u32 timeout)
 {
+#ifdef XLINK_PCIE_LOCAL
 	struct xpcie *xpcie = intel_xpcie_core_get_by_id(sw_device_id);
 
 	if (!xpcie)
 		return -ENODEV;
 
 	return intel_xpcie_core_read(xpcie, data, size, timeout);
+#else
+	return intel_xpcie_pci_read(sw_device_id, data, size, timeout);
+#endif
 }
 EXPORT_SYMBOL(xlink_pcie_read);
 
 int xlink_pcie_write(u32 sw_device_id, void *data, size_t *const size,
 		     u32 timeout)
 {
+#ifdef XLINK_PCIE_LOCAL
 	struct xpcie *xpcie = intel_xpcie_core_get_by_id(sw_device_id);
 
 	if (!xpcie)
 		return -ENODEV;
 
 	return intel_xpcie_core_write(xpcie, data, size, timeout);
+#else
+	return intel_xpcie_pci_write(sw_device_id, data, size, timeout);
+#endif
 }
 EXPORT_SYMBOL(xlink_pcie_write);
 
 int xlink_pcie_reset_device(u32 sw_device_id)
 {
-	return 0;
+	int ret = 0;
+#ifdef XLINK_PCIE_REMOTE
+	ret = intel_xpcie_pci_reset_device(sw_device_id);
+#endif
+	return ret;
 }
 EXPORT_SYMBOL(xlink_pcie_reset_device);
diff --git a/drivers/misc/xlink-pcie/local_host/Makefile b/drivers/misc/xlink-pcie/local_host/Makefile
index c24d5b3a2e0f..b56c7b7fc1af 100644
--- a/drivers/misc/xlink-pcie/local_host/Makefile
+++ b/drivers/misc/xlink-pcie/local_host/Makefile
@@ -5,5 +5,5 @@ obj-$(CONFIG_XLINK_PCIE_LH_DRIVER) += mxlk_ep.o
 mxlk_ep-objs := epf.o
 mxlk_ep-objs += core.o
 mxlk_ep-objs += dma.o
-mxlk_ep-objs += if.o
+mxlk_ep-objs += ../common/if.o
 mxlk_ep-objs += ../common/util.o
diff --git a/drivers/misc/xlink-pcie/remote_host/Makefile b/drivers/misc/xlink-pcie/remote_host/Makefile
index 5934a4e88630..fd48ae3cd3ae 100644
--- a/drivers/misc/xlink-pcie/remote_host/Makefile
+++ b/drivers/misc/xlink-pcie/remote_host/Makefile
@@ -4,5 +4,5 @@ obj-$(CONFIG_XLINK_PCIE_RH_DRIVER) += mxlk.o
 mxlk-objs := main.o
 mxlk-objs += pci.o
 mxlk-objs += core.o
-mxlk-objs += if.o
+mxlk-objs += ../common/if.o
 mxlk-objs += ../common/util.o
diff --git a/drivers/misc/xlink-pcie/remote_host/if.c b/drivers/misc/xlink-pcie/remote_host/if.c
deleted file mode 100644
index 5125b6869560..000000000000
--- a/drivers/misc/xlink-pcie/remote_host/if.c
+++ /dev/null
@@ -1,94 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-only
-/*****************************************************************************
- *
- * Intel Keem Bay XLink PCIe Driver
- *
- * Copyright (C) 2020 Intel Corporation
- *
- ****************************************************************************/
-
-#include <linux/errno.h>
-#include <linux/module.h>
-#include <linux/xlink_drv_inf.h>
-#include "pci.h"
-
-int xlink_pcie_get_device_list(u32 *sw_device_id_list,
-			       u32 *num_devices)
-{
-	*num_devices = intel_xpcie_get_device_num(sw_device_id_list);
-
-	return 0;
-}
-EXPORT_SYMBOL(xlink_pcie_get_device_list);
-
-int xlink_pcie_get_device_name(u32 sw_device_id, char *device_name,
-			       size_t name_size)
-{
-	return intel_xpcie_get_device_name_by_id(sw_device_id,
-						 device_name, name_size);
-}
-EXPORT_SYMBOL(xlink_pcie_get_device_name);
-
-int xlink_pcie_get_device_status(u32 sw_device_id, u32 *device_status)
-{
-	int rc;
-	u32 status;
-
-	rc = intel_xpcie_get_device_status_by_id(sw_device_id, &status);
-	if (rc)
-		return rc;
-
-	switch (status) {
-	case XPCIE_STATUS_READY:
-	case XPCIE_STATUS_RUN:
-		*device_status = _XLINK_DEV_READY;
-		break;
-	case XPCIE_STATUS_ERROR:
-		*device_status = _XLINK_DEV_ERROR;
-		break;
-	case XPCIE_STATUS_RECOVERY:
-		*device_status = _XLINK_DEV_RECOVERY;
-		break;
-	case XPCIE_STATUS_OFF:
-		*device_status = _XLINK_DEV_OFF;
-		break;
-	default:
-		*device_status = _XLINK_DEV_BUSY;
-		break;
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL(xlink_pcie_get_device_status);
-
-int xlink_pcie_boot_device(u32 sw_device_id, const char *binary_name)
-{
-	return 0;
-}
-EXPORT_SYMBOL(xlink_pcie_boot_device);
-
-int xlink_pcie_connect(u32 sw_device_id)
-{
-	return intel_xpcie_pci_connect_device(sw_device_id);
-}
-EXPORT_SYMBOL(xlink_pcie_connect);
-
-int xlink_pcie_read(u32 sw_device_id, void *data, size_t *const size,
-		    u32 timeout)
-{
-	return intel_xpcie_pci_read(sw_device_id, data, size, timeout);
-}
-EXPORT_SYMBOL(xlink_pcie_read);
-
-int xlink_pcie_write(u32 sw_device_id, void *data, size_t *const size,
-		     u32 timeout)
-{
-	return intel_xpcie_pci_write(sw_device_id, data, size, timeout);
-}
-EXPORT_SYMBOL(xlink_pcie_write);
-
-int xlink_pcie_reset_device(u32 sw_device_id)
-{
-	return intel_xpcie_pci_reset_device(sw_device_id);
-}
-EXPORT_SYMBOL(xlink_pcie_reset_device);
-- 
2.27.0

