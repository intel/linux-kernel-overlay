From 88c5b8bf0a1b7b37059f24379921377f1cbc215e Mon Sep 17 00:00:00 2001
From: Shashank A P <shashankx.ap@intel.com>
Date: Wed, 14 Apr 2021 16:12:27 +0530
Subject: [PATCH 199/223] xlink-core: events bypass tx thread

events are directly sent instead of enqueuing

Signed-off-by: Shashank A P <shashankx.ap@intel.com>
---
 drivers/misc/xlink-core/xlink-dispatcher.c | 24 ++++++++++++++++++++--
 1 file changed, 22 insertions(+), 2 deletions(-)

diff --git a/drivers/misc/xlink-core/xlink-dispatcher.c b/drivers/misc/xlink-core/xlink-dispatcher.c
index 6bd8b987d178..3a8bc34712dd 100644
--- a/drivers/misc/xlink-core/xlink-dispatcher.c
+++ b/drivers/misc/xlink-core/xlink-dispatcher.c
@@ -53,6 +53,7 @@ struct dispatcher {
 	struct semaphore event_sem;		/* signals tx kthread of events */
 	struct completion rx_done;		/* sync start/stop of rx kthread */
 	struct completion tx_done;		/* sync start/stop of tx thread */
+	struct mutex disp_mutex;
 };
 
 /* xlink dispatcher system component */
@@ -433,6 +434,7 @@ enum xlink_error xlink_dispatcher_start(int id, struct xlink_handle *handle)
 	// set the dispatcher context
 	disp->handle = handle;
 	disp->interface = get_interface_from_sw_device_id(handle->sw_device_id);
+	mutex_init(&disp->disp_mutex);
 
 	// run dispatcher thread to handle and write outgoing packets
 	disp->txthread = kthread_run(xlink_dispatcher_txthread,
@@ -460,6 +462,7 @@ enum xlink_error xlink_dispatcher_start(int id, struct xlink_handle *handle)
 r_txthread:
 	disp->state = XLINK_DISPATCHER_STOPPED;
 r_error:
+	mutex_destroy(&disp->disp_mutex);
 	mutex_unlock(&xlinkd->lock);
 	return X_LINK_ERROR;
 }
@@ -468,7 +471,7 @@ enum xlink_error xlink_dispatcher_event_add(enum xlink_event_origin origin,
 					    struct xlink_event *event)
 {
 	struct dispatcher *disp;
-	int rc;
+	//int rc;
 
 	// get dispatcher by link id
 	disp = get_dispatcher_by_id(event->link_id);
@@ -483,12 +486,21 @@ enum xlink_error xlink_dispatcher_event_add(enum xlink_event_origin origin,
 	if (origin == EVENT_TX)
 		event->header.id = event_generate_id();
 	event->origin = origin;
+
+	mutex_lock(&disp->disp_mutex);
+	dispatcher_event_send(event);
+	//event is handled and can now be freed
+	xlink_destroy_event(event);
+	mutex_unlock(&disp->disp_mutex);
+
+	/*
 	rc = event_enqueue(&disp->queue, event);
 	if (rc)
 		return X_LINK_CHAN_FULL;
 
 	// notify dispatcher tx thread of new event
 	up(&disp->event_sem);
+	*/
 	return X_LINK_SUCCESS;
 }
 
@@ -510,21 +522,26 @@ enum xlink_error xlink_dispatcher_stop(int id)
 	if (disp->rxthread) {
 		wait_tx_queue_empty(disp);
 		// stop dispatcher rx thread
+		get_task_struct(disp->rxthread);
 		send_sig(SIGTERM, disp->rxthread, 0);
 		rc = kthread_stop(disp->rxthread);
+		put_task_struct(disp->rxthread);
 		if (rc)
 			goto r_thread;
 	}
 	wait_for_completion(&disp->rx_done);
 	if (disp->txthread) {
 		// stop dispatcher tx thread
+		get_task_struct(disp->txthread);
 		send_sig(SIGTERM, disp->txthread, 0);
 		rc = kthread_stop(disp->txthread);
+		put_task_struct(disp->txthread);
 		if (rc)
 			goto r_thread;
 	}
 	wait_for_completion(&disp->tx_done);
 	disp->state = XLINK_DISPATCHER_STOPPED;
+	mutex_destroy(&disp->disp_mutex);
 	mutex_unlock(&xlinkd->lock);
 	return X_LINK_SUCCESS;
 
@@ -554,8 +571,10 @@ enum xlink_error xlink_dispatcher_destroy(void)
 			xlink_dispatcher_stop(i);
 
 		// empty queues of all used dispatchers
-		if (disp->state == XLINK_DISPATCHER_INIT)
+		if (disp->state == XLINK_DISPATCHER_INIT) {
+			deinit_buffers(&xlinkd->dispatchers[i].event_buffer_queue);
 			continue;
+		}
 
 		// deallocate remaining events in queue
 		while (!list_empty(&disp->queue.head)) {
@@ -576,6 +595,7 @@ enum xlink_error xlink_dispatcher_destroy(void)
 			}
 			xlink_destroy_event(event);
 		}
+		deinit_buffers(&xlinkd->dispatchers[i].event_buffer_queue);
 		mutex_destroy(&disp->queue.lock);
 	}
 	mutex_destroy(&xlinkd->lock);
-- 
2.27.0

