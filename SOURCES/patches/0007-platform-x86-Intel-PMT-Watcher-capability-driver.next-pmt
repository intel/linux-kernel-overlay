From 458a90d3cce0361e47c2a53c2baa1df90d661be8 Mon Sep 17 00:00:00 2001
From: Alexander Duyck <alexander.h.duyck@linux.intel.com>
Date: Thu, 1 Oct 2020 19:26:18 -0700
Subject: [PATCH 07/16] platform/x86: Intel PMT Watcher capability driver

INTEL INTERNAL ONLY

Watcher is a capability of the Intel Platform Monitoring Technology.
The Watcher capability provides access to hardware sampling and tracing
functionality.

PMT architecture uses PCI to enumerate the Watcher capability and
to access configuration registers and result buffers. Watcher supports
two types of hardware collection features, Sampler and Tracer. Both
Sampler and Tracer allow configuring a collection mode (oneshot,
periodic), a period, and an enabling vector to select the metrics to
be sampled/traced. On Intel devices, Tracer result data is processed
by the CPU Trace Hub hardware, while Sampler data is made available to
the OS through MMIO.

The PMT Watcher capability has a connection with the PMT Telemetry
capability (see Intel PMT Watcher capability driver). It is from a
Telemetry region that Watchers are configured to be sampled or traced
from. Like Telemetry, Watcher also provides a GUID that is used by
software to identify a version of a XML. Though related to the Telemetry
capability, Watchers function as stand alone components that do not
interact with or otherwise disturb the operation of a Telemetry.

Tracers and Samplers are enumerated separately in the class folder.
Files to configure a Tracer or Sampler are provided along with a
pointer to the parent device the feature belongs to. For samplers,
a binary sysfs attribute is created that allows user space to mmap
the result buffer.

Also move early_client_hw pci id list to the intel_pmt_class.c since
the issues are common to the discovery of both Telemetry and Watcher
features.

Signed-off-by: Alexander Duyck <alexander.h.duyck@linux.intel.com>
Signed-off-by: "David E. Box" <david.e.box@linux.intel.com>
---
 .../ABI/testing/sysfs-class-intel_pmt         | 206 +++-
 drivers/platform/x86/Kconfig                  |  11 +
 drivers/platform/x86/Makefile                 |   1 +
 drivers/platform/x86/intel_pmt_class.c        |  10 +-
 drivers/platform/x86/intel_pmt_class.h        |   6 +-
 drivers/platform/x86/intel_pmt_crashlog.c     |   3 +-
 drivers/platform/x86/intel_pmt_telemetry.c    |   3 +-
 drivers/platform/x86/intel_pmt_watcher.c      | 930 ++++++++++++++++++
 8 files changed, 1117 insertions(+), 53 deletions(-)
 create mode 100644 drivers/platform/x86/intel_pmt_watcher.c

diff --git a/Documentation/ABI/testing/sysfs-class-intel_pmt b/Documentation/ABI/testing/sysfs-class-intel_pmt
index ed4c886a21b1..f1193dd9e991 100644
--- a/Documentation/ABI/testing/sysfs-class-intel_pmt
+++ b/Documentation/ABI/testing/sysfs-class-intel_pmt
@@ -7,56 +7,56 @@ Description:
 		devices that expose hardware telemetry using Intel Platform
 		Monitoring Technology (PMT)
 
-What:		/sys/class/intel_pmt/telem<x>
+What:		/sys/class/intel_pmt/.../guid
 Date:		October 2020
 KernelVersion:	5.10
 Contact:	David Box <david.e.box@linux.intel.com>
 Description:
-		The telem<x> directory contains files describing an instance of
-		a PMT telemetry device that exposes hardware telemetry. Each
-		telem<x> directory has an associated telem file. This file
-		may be opened and mapped or read to access the telemetry space
-		of the device. The register layout of the telemetry space is
-		determined from an XML file that matches the PCI device id and
-		GUID for the device.
+		(RO) The GUID for this device. The GUID identifies the
+		version of the XML file for the parent device that should
+		be used to determine the register layout.
 
-What:		/sys/class/intel_pmt/telem<x>/telem
+What:		/sys/class/intel_pmt/.../size
 Date:		October 2020
 KernelVersion:	5.10
 Contact:	David Box <david.e.box@linux.intel.com>
 Description:
-		(RO) The telemetry data for this telemetry device. This file
-		may be mapped or read to obtain the data.
+		(RO) The length of the result buffer in bytes that corresponds
+		to the size for the crashlog/sample/telem device.
 
-What:		/sys/class/intel_pmt/telem<x>/guid
+What:		/sys/class/intel_pmt/.../offset
 Date:		October 2020
 KernelVersion:	5.10
 Contact:	David Box <david.e.box@linux.intel.com>
 Description:
-		(RO) The GUID for this telemetry device. The GUID identifies
-		the version of the XML file for the parent device that is to
-		be used to get the register layout.
+		(RO) The offset of the buffer in bytes that corresponds
+		to the mapping for the crashlog/sample/telem device.
 
-What:		/sys/class/intel_pmt/telem<x>/size
+What:		/sys/class/intel_pmt/telem<x>
 Date:		October 2020
 KernelVersion:	5.10
 Contact:	David Box <david.e.box@linux.intel.com>
 Description:
-		(RO) The size of telemetry region in bytes that corresponds to
-		the mapping size for the telem file.
+		The telem<x> directory contains files describing an instance of
+		a PMT telemetry device that exposes hardware telemetry. Each
+		telem<x> directory has an associated telem file. This file
+		may be opened and mapped or read to access the telemetry space
+		of the device. The register layout of the telemetry space is
+		determined from an XML file that matches the PCI device id and
+		GUID for the device.
 
-What:		/sys/class/intel_pmt/telem<x>/offset
+What:		/sys/class/intel_pmt/telem<x>/telem
 Date:		October 2020
 KernelVersion:	5.10
 Contact:	David Box <david.e.box@linux.intel.com>
 Description:
-		(RO) The offset of telemetry region in bytes that corresponds to
-		the mapping for the telem file.
+		(RO) The telemetry data for this telemetry device. This file
+		may be mapped or read to obtain the data.
 
 What:		/sys/class/intel_pmt/crashlog<x>
 Date:		October 2020
 KernelVersion:	5.10
-Contact:	Alexander Duyck <alexander.h.duyck@linux.intel.com>
+Contact:	David Box <david.e.box@linux.intel.com>
 Description:
 		The crashlog<x> directory contains files for configuring an
 		instance of a PMT crashlog device that can perform crash data
@@ -74,46 +74,162 @@ Description:
 		(RO) The crashlog buffer for this crashlog device. This file
 		may be mapped or read to obtain the data.
 
-What:		/sys/class/intel_pmt/crashlog<x>/guid
+What:		/sys/class/intel_pmt/crashlog<x>/enable
 Date:		October 2020
 KernelVersion:	5.10
-Contact:	Alexander Duyck <alexander.h.duyck@linux.intel.com>
+Contact:	David Box <david.e.box@linux.intel.com>
 Description:
 		(RO) The GUID for this crashlog device. The GUID identifies the
 		version of the XML file for the parent device that should be
 		used to determine the register layout.
 
-What:		/sys/class/intel_pmt/crashlog<x>/size
+What:		/sys/class/intel_pmt/crashlog<x>/trigger
 Date:		October 2020
 KernelVersion:	5.10
-Contact:	Alexander Duyck <alexander.h.duyck@linux.intel.com>
+Contact:	David Box <david.e.box@linux.intel.com>
 Description:
-		(RO) The length of the result buffer in bytes that corresponds
-		to the size for the crashlog buffer.
+		(RW) Boolean value controlling the triggering of the crashlog
+		device node. When read it provides data on if the crashlog has
+		been triggered. When written to it can be used to either clear
+		the current trigger by writing false, or to trigger a new
+		event if the trigger is not currently set.
 
-What:		/sys/class/intel_pmt/crashlog<x>/offset
+What:		/sys/class/intel_pmt/sample<x>
 Date:		October 2020
-KernelVersion:	5.10
-Contact:	Alexander Duyck <alexander.h.duyck@linux.intel.com>
+KernelVersion:	5.8
+Contact:	David Box <david.e.box@linux.intel.com>
 Description:
-		(RO) The offset of the buffer in bytes that corresponds
-		to the mapping for the crashlog device.
+		The sample<x> directory contains files for configuring an
+		instance of a PMT watcher device that can perform hardware
+		sampling. Each sample<x> device has an associated sample file.
+		This file can be opened and mapped to access the resulting
+		sample data. The registers to be sampled are determined from
+		an XML file of specified GUID for the parent device. Programs
+		use this XML file to determine which registers to sample by
+		selecting the corresponding bit in the "vector" file.
 
-What:		/sys/class/intel_pmt/crashlog<x>/enable
+What:		/sys/class/intel_pmt/sample<x>/sample
 Date:		October 2020
 KernelVersion:	5.10
-Contact:	Alexander Duyck <alexander.h.duyck@linux.intel.com>
+Contact:	David Box <david.e.box@linux.intel.com>
 Description:
-		(RW) Boolean value controlling if the crashlog functionality
-		is enabled for the crashlog device.
+		(RO) The sample buffer for this sampler device. This file
+		may be mapped or read to obtain the data.
 
-What:		/sys/class/intel_pmt/crashlog<x>/trigger
+What:		/sys/class/intel_pmt/trace<x>
 Date:		October 2020
-KernelVersion:	5.10
-Contact:	Alexander Duyck <alexander.h.duyck@linux.intel.com>
+KernelVersion:	5.8
+Contact:	David Box <david.e.box@linux.intel.com>
 Description:
-		(RW) Boolean value controlling the triggering of the crashlog
-		device node. When read it provides data on if the crashlog has
-		been triggered. When written to it can be used to either clear
-		the current trigger by writing false, or to trigger a new
-		event if the trigger is not currently set.
+		The trace<x> directory contains files for configuring an
+		instance of a PMT watcher device that can perform hardware
+		tracing. File operations cannot be performed on it. The
+		resulting trace data is placed in the destination specified
+		by the "destination" file. The registers to be traced are
+		determined from an XML file of specified GUID for the parent
+		device. Programs use this XML file to determine which registers
+		to sample by selecting the corresponding bit in the vector file.
+
+What:		/sys/class/intel_pmt/trace<x>/destination
+Date:		October 2020
+KernelVersion:	5.8
+Contact:	David Box <david.e.box@linux.intel.com>
+Description:
+		(RW) The storage destination for the trace data. This value is
+		not writable when mode is 'Disabled'.
+
+What:		/sys/class/cta_watcher/trace<x>/stream_uid
+Date:		October 2020
+KernelVersion:	5.8
+Contact:	David Box <david.e.box@linux.intel.com>
+Description:
+		(RW) The unique stream ID for the trace data. This value is
+		not writable when mode is 'Disabled'. If the tracer does not
+		support stream UID the value will be set to -1.
+
+What:		/sys/class/intel_pmt/trace<x>/token
+Date:		October 2020
+KernelVersion:	5.8
+Contact:	David Box <david.e.box@linux.intel.com>
+Description:
+		(RW) 8 bit Token value.
+
+What:		/sys/class/intel_pmt/sample<x>/enable_id_limit
+What:		/sys/class/intel_pmt/trace<x>/enable_id_limit
+Date:		October 2020
+KernelVersion:	5.8
+Contact:	David Box <david.e.box@linux.intel.com>
+Description:
+		(RO) This value represents the upper limit on ID values that
+		can be accepted by the sampler or tracer.
+
+What:		/sys/class/intel_pmt/sample<x>/enable_list
+What:		/sys/class/intel_pmt/trace<x>/enable_list
+Date:		October 2020
+KernelVersion:	5.8
+Contact:	David Box <david.e.box@linux.intel.com>
+Description:
+		(RW) Comma separated list representing the selected metrics to
+		be sampled or traced. Sample IDs are matched to registers based
+		on the XML file. Each ID represents a 64 bit register to sample.
+		This file is only writable when mode is set to 'Disabled'
+
+What:		/sys/class/intel_pmt/sample<x>/enable_vector
+What:		/sys/class/intel_pmt/trace<x>/enable_vector
+Date:		October 2020
+KernelVersion:	5.8
+Contact:	David Box <david.e.box@linux.intel.com>
+Description:
+		(RW) Bitmask representing the selected metrics to be sampled or
+		traced. Programs correlate the register to be sampled with the
+		bit position by using the XML file. Each bit represents a 64 bit
+		register to sample. This file is only writable when mode is set
+		to 'Disabled'
+
+What:		/sys/class/intel_pmt/sample<x>/mode
+What:		/sys/class/intel_pmt/trace<x>/mode
+Date:		October 2020
+KernelVersion:	5.8
+Contact:	David Box <david.e.box@linux.intel.com>
+Description:
+		(RW) The operating mode of the sampler/tracer. Modes are one
+		of the following:
+
+			disabled:	Not operational
+			oneshot:	One sample or trace
+			periodic:	Periodic sampling or tracing
+
+		mode select works as follows:
+
+		Selecting a non 'disabled' mode will automatically start the
+		sample/trace according to the options selected in the other
+		configuration files (period_us, vector, destination, and token,
+		as applicable). This files will also become read only until
+		mode is set back to 'disabled'.
+
+		Transitions
+
+			Current		Next
+			-------		----
+			disabled	Any
+			oneshot		disabled
+			periodic	disabled
+
+What:		/sys/class/intel_pmt/sample<x>/period_us
+What:		/sys/class/intel_pmt/trace<x>/period_us
+Date:		October 2020
+KernelVersion:	5.8
+Contact:	David Box <david.e.box@linux.intel.com>
+Description:
+		(RW) The sampling/tracing period in microseconds. Applicable
+		to 'periodic' mode only. This file is only writable when mode
+		is set to 'Disabled'.
+
+What:		/sys/class/intel_pmt/sample<x>/select_limit
+What:		/sys/class/intel_pmt/trace<x>/select_limit
+Date:		October 2020
+KernelVersion:	5.8
+Contact:	David Box <david.e.box@linux.intel.com>
+Description:
+		(RO) The maximum number of select bits that can be enabled
+		in the vector file.
diff --git a/drivers/platform/x86/Kconfig b/drivers/platform/x86/Kconfig
index 60592fb88e7a..5f5271c410fc 100644
--- a/drivers/platform/x86/Kconfig
+++ b/drivers/platform/x86/Kconfig
@@ -1248,6 +1248,17 @@ config INTEL_PMT_CRASHLOG
 	  To compile this driver as a module, choose M here: the module
 	  will be called intel_pmt_crashlog.
 
+config INTEL_PMT_WATCHER
+	tristate "Intel Platform Monitoring Technology (PMT) Watcher driver"
+	select INTEL_PMT_CLASS
+	help
+	  The Intel Platform Monitoring Technology (PMT) Watcher driver provides
+	  access to hardware sampling and tracing capabilities on devices that
+	  support the feature.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called intel_pmt_watcher.
+
 config INTEL_PUNIT_IPC
 	tristate "Intel P-Unit IPC Driver"
 	help
diff --git a/drivers/platform/x86/Makefile b/drivers/platform/x86/Makefile
index dcc8cdb95b4d..84018bd18a25 100644
--- a/drivers/platform/x86/Makefile
+++ b/drivers/platform/x86/Makefile
@@ -132,6 +132,7 @@ obj-$(CONFIG_INTEL_PMC_CORE)		+= intel_pmc_core.o intel_pmc_core_pltdrv.o
 obj-$(CONFIG_INTEL_PMT_CLASS)		+= intel_pmt_class.o
 obj-$(CONFIG_INTEL_PMT_TELEMETRY)	+= intel_pmt_telemetry.o
 obj-$(CONFIG_INTEL_PMT_CRASHLOG)	+= intel_pmt_crashlog.o
+obj-$(CONFIG_INTEL_PMT_WATCHER)		+= intel_pmt_watcher.o
 obj-$(CONFIG_INTEL_PUNIT_IPC)		+= intel_punit_ipc.o
 obj-$(CONFIG_INTEL_SCU_IPC)		+= intel_scu_ipc.o
 obj-$(CONFIG_INTEL_SCU_PCI)		+= intel_scu_pcidrv.o
diff --git a/drivers/platform/x86/intel_pmt_class.c b/drivers/platform/x86/intel_pmt_class.c
index f4919a8f836a..0c2ef9373017 100644
--- a/drivers/platform/x86/intel_pmt_class.c
+++ b/drivers/platform/x86/intel_pmt_class.c
@@ -138,10 +138,9 @@ static struct class intel_pmt_class = {
 	.dev_groups = intel_pmt_groups,
 };
 
-static int intel_pmt_populate_entry(struct intel_pmt_entry *entry,
-				    struct intel_pmt_header *header,
-				    struct device *dev,
-				    struct resource *disc_res)
+int intel_pmt_populate_entry(struct intel_pmt_entry *entry,
+			     struct intel_pmt_header *header,
+			     struct device *dev, struct resource *disc_res)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev->parent);
 	u8 bir;
@@ -214,6 +213,7 @@ static int intel_pmt_populate_entry(struct intel_pmt_entry *entry,
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(intel_pmt_populate_entry);
 
 static int intel_pmt_dev_register(struct intel_pmt_entry *entry,
 				  struct intel_pmt_namespace *ns,
@@ -297,7 +297,7 @@ int intel_pmt_dev_create(struct intel_pmt_entry *entry,
 	if (IS_ERR(entry->disc_table))
 		return PTR_ERR(entry->disc_table);
 
-	ret = ns->pmt_header_decode(entry, &header, &pdev->dev);
+	ret = ns->pmt_header_decode(entry, &header, &pdev->dev, disc_res);
 	if (ret)
 		return ret;
 
diff --git a/drivers/platform/x86/intel_pmt_class.h b/drivers/platform/x86/intel_pmt_class.h
index 1337019c2873..5262dd30c41a 100644
--- a/drivers/platform/x86/intel_pmt_class.h
+++ b/drivers/platform/x86/intel_pmt_class.h
@@ -4,6 +4,7 @@
 
 #include <linux/platform_device.h>
 #include <linux/xarray.h>
+#include <linux/ioport.h>
 #include <linux/types.h>
 #include <linux/bits.h>
 #include <linux/err.h>
@@ -41,10 +42,13 @@ struct intel_pmt_namespace {
 	const struct attribute_group *attr_grp;
 	int (*pmt_header_decode)(struct intel_pmt_entry *entry,
 				 struct intel_pmt_header *header,
-				 struct device *dev);
+				 struct device *dev, struct resource *disc_res);
 };
 
 bool intel_pmt_is_early_client_hw(struct device *dev);
+int intel_pmt_populate_entry(struct intel_pmt_entry *entry,
+			     struct intel_pmt_header *header,
+			     struct device *dev, struct resource *disc_res);
 int intel_pmt_dev_create(struct intel_pmt_entry *entry,
 			 struct intel_pmt_namespace *ns,
 			 struct platform_device *pdev, int idx);
diff --git a/drivers/platform/x86/intel_pmt_crashlog.c b/drivers/platform/x86/intel_pmt_crashlog.c
index 3da480e05ea8..df1de6c54b14 100644
--- a/drivers/platform/x86/intel_pmt_crashlog.c
+++ b/drivers/platform/x86/intel_pmt_crashlog.c
@@ -224,7 +224,8 @@ static struct attribute_group pmt_crashlog_group = {
 
 static int pmt_crashlog_header_decode(struct intel_pmt_entry *entry,
 				      struct intel_pmt_header *header,
-				      struct device *dev)
+				      struct device *dev,
+				      struct resource *disc_res)
 {
 	void __iomem *disc_table = entry->disc_table;
 	struct crashlog_entry *crashlog;
diff --git a/drivers/platform/x86/intel_pmt_telemetry.c b/drivers/platform/x86/intel_pmt_telemetry.c
index e156315d6de9..30e36e033653 100644
--- a/drivers/platform/x86/intel_pmt_telemetry.c
+++ b/drivers/platform/x86/intel_pmt_telemetry.c
@@ -47,7 +47,8 @@ static bool pmt_telem_region_overlaps(struct intel_pmt_entry *entry,
 
 static int pmt_telem_header_decode(struct intel_pmt_entry *entry,
 				   struct intel_pmt_header *header,
-				   struct device *dev)
+				   struct device *dev,
+				   struct resource *disc_res)
 {
 	void __iomem *disc_table = entry->disc_table;
 
diff --git a/drivers/platform/x86/intel_pmt_watcher.c b/drivers/platform/x86/intel_pmt_watcher.c
new file mode 100644
index 000000000000..513c28a004a2
--- /dev/null
+++ b/drivers/platform/x86/intel_pmt_watcher.c
@@ -0,0 +1,930 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Intel Platform Monitoring Technology Watcher driver
+ *
+ * Copyright (c) 2020, Intel Corporation.
+ * All Rights Reserved.
+ *
+ * Authors: "David E. Box" <david.e.box@linux.intel.com>
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/overflow.h>
+
+#include "intel_pmt_class.h"
+
+#define DRV_NAME		"intel-dvsec-3"
+#define SMPLR_DEV_PREFIX	"sample"
+#define TRCR_DEV_PREFIX		"trace"
+
+#define TYPE_TRACER2		0
+#define TYPE_SAMPLER2		1
+#define TYPE_TRACER1		2
+#define TYPE_SAMPLER1		3
+
+/* Watcher sampler mods */
+#define MODE_OFF		0
+#define MODE_PERIODIC		1
+#define MODE_ONESHOT		2
+#define MODE_SHARED		3
+
+/* Watcher access types */
+#define ACCESS_FUTURE		1
+#define ACCESS_BARID		2
+#define ACCESS_LOCAL		3
+
+/* Common Header */
+#define GUID_OFFSET		0x4
+#define BASE_OFFSET		0x8
+#define GET_ACCESS(v)		((v) & GENMASK(3, 0))
+#define GET_TYPE(v)		(((v) & GENMASK(11, 4)) >> 4)
+#define GET_SIZE(v)		(((v) & GENMASK(27, 12)) >> 10)
+
+/* Common Config fields */
+#define GET_MODE(v)		((v) & 0x3)
+#define MODE_MASK		GENMASK(1, 0)
+#define GET_REQ(v)		((v) & BIT(31))
+#define SET_REQ_BIT(v)		((v) | BIT(31))
+#define REQUEST_PENDING		1
+#define MAX_PERIOD_US		(396 * USEC_PER_SEC)	/* 3600s + 360s = 1.1 hours */
+
+/* Tracer Config - Destination field */
+#define TRCR_DEST_TRACEHUB	0
+#define TRCR_DEST_OOB		1
+#define TRCR_DEST_IRQ		2
+#define TRCR_DEST_MASK		GENMASK(5, 2)
+#define SET_TRCR_DEST_BITS(v)	((v) << 2)
+#define GET_TRCR_DEST(v)	(((v) & TRCR_DEST_MASK) >> 2)
+
+/* Tracer Config - Token field */
+#define TRCR_TOKEN_MASK		GENMASK(15, 8)
+#define SET_TRCR_TOKEN_BITS(v)	((v) << 8)
+#define GET_TRCR_TOKEN(v)	(((v) & TRCR_TOKEN_MASK) >> 8)
+#define TRCR_TOKEN_MAX_SIZE	255
+
+/* Tracer Config Offsets */
+#define TRCR_CONTROL_OFFSET	0x4
+#define TRCR_STREAM_UID_OFFSET	0x8
+#define TRCR_VECTOR_OFFSET	0x10
+
+/* Sampler Config Offsets */
+#define SMPLR_BUFFER_SIZE_OFFSET	0x4
+#define SMPLR_CONTROL_OFFSET		0xC
+#define SMPLR_VECTOR_OFFSET		0x10
+
+/*
+ * Sampler data size in bytes.
+ * s - the size of the sampler data buffer space
+ *     given in the config header (pointer field)
+ * n - is the number of select vectors
+ *
+ * Subtract 8 bytes for the size of the timestamp
+ */
+#define SMPLR_NUM_SAMPLES(s, n)		(((s) - (n) - 8) / 8)
+
+static const char * const sample_mode[] = {
+	[MODE_OFF] = "off",
+	[MODE_PERIODIC] = "periodic",
+	[MODE_ONESHOT] = "oneshot",
+	[MODE_SHARED] = "shared"
+};
+
+static const char * const tracer_destination[] = {
+	[TRCR_DEST_TRACEHUB] = "trace_hub",
+	[TRCR_DEST_OOB] = "oob",
+	[TRCR_DEST_IRQ] = "irq"
+};
+
+struct watcher_config {
+	unsigned int	select_limit;
+	unsigned int	vector_size;
+	unsigned long	*vector;
+	u32		control;
+	u32		period;
+	u32		stream_uid;
+};
+
+struct pmt_watcher_priv;
+
+struct watcher_entry {
+	/* entry must be first member of struct */
+	struct intel_pmt_entry	entry;
+	struct watcher_config	config;
+	u8			type;
+	struct resource		*header_res;
+	void __iomem		*cfg_base;
+	bool			mode_lock;
+	s8			ctrl_offset;
+	s8			stream_uid_offset;
+	s8			vector_start;
+};
+
+#define to_pmt_watcher(e) container_of(e, struct watcher_entry, entry)
+
+struct pmt_watcher_priv {
+	int			num_entries;
+	struct watcher_entry	entry[];
+};
+
+static inline bool pmt_watcher_is_sampler(struct watcher_entry *watcher)
+{
+	return watcher->type == TYPE_SAMPLER1 ||
+	       watcher->type == TYPE_SAMPLER2;
+}
+
+static inline bool pmt_watcher_is_tracer(struct watcher_entry *watcher)
+{
+	return watcher->type == TYPE_TRACER1 ||
+	       watcher->type == TYPE_TRACER2;
+}
+
+static inline bool pmt_watcher_select_limited(struct watcher_entry *watcher)
+{
+	return pmt_watcher_is_sampler(watcher) ||
+	       watcher->type == TYPE_TRACER2;
+}
+
+static inline bool pmt_watcher_is_type2(struct watcher_entry *watcher)
+{
+	return watcher->type == TYPE_SAMPLER2 ||
+	       watcher->type == TYPE_TRACER2;
+}
+
+/*
+ * I/O
+ */
+static bool pmt_watcher_request_pending(struct watcher_entry *watcher)
+{
+	/*
+	 * Read request pending bit into temporary location so we can read the
+	 * pending bit without overwriting other settings. If a collection is
+	 * still in progress we can't start a new one.
+	 */
+	u32 control = readl(watcher->cfg_base + watcher->ctrl_offset);
+
+	return GET_REQ(control) == REQUEST_PENDING;
+}
+
+static bool pmt_watcher_in_use(struct watcher_entry *watcher)
+{
+	/*
+	 * Read request pending bit into temporary location so we can read the
+	 * pending bit without overwriting other settings. If a collection is
+	 * still in progress we can't start a new one.
+	 */
+	u32 control = readl(watcher->cfg_base + watcher->ctrl_offset);
+
+	return GET_MODE(control) != MODE_OFF;
+}
+
+static void pmt_watcher_write_ctrl_to_dev(struct watcher_entry *watcher)
+{
+	/*
+	 * Set the request pending bit and write the control register to
+	 * start the collection.
+	 */
+	u32 control = SET_REQ_BIT(watcher->config.control);
+
+	writel(control, watcher->cfg_base + watcher->ctrl_offset);
+}
+
+static void pmt_watcher_write_period_to_dev(struct watcher_entry *watcher)
+{
+	/* The period exists on the DWORD opposite the control register */
+	writel(watcher->config.period, watcher->cfg_base + (watcher->ctrl_offset ^ 0x4));
+}
+
+static void pmt_watcher_write_stream_uid_to_dev(struct watcher_entry *watcher)
+{
+	/* nothing to write if stream_uid_offset is negative */
+	if (watcher->stream_uid_offset < 0)
+		return;
+
+	/*
+	 * The stream UUID occupies a 64b value, however the second DWORD
+	 * is reserved 0 so just write the value as such.
+	 */
+	writel(watcher->config.period,
+	       watcher->cfg_base + watcher->stream_uid_offset);
+	writel(0, watcher->cfg_base + watcher->stream_uid_offset + 4);
+}
+
+void
+pmt_watcher_write_vector_to_dev_type1(struct watcher_entry *watcher)
+{
+	memcpy_toio(watcher->cfg_base + watcher->vector_start,
+		    watcher->config.vector,
+		    DIV_ROUND_UP(watcher->config.vector_size, BITS_PER_BYTE));
+}
+
+void
+pmt_watcher_write_vector_to_dev_type2(struct watcher_entry *watcher)
+{
+	unsigned int index, offset = 0;
+	u32 temp;
+
+	for_each_set_bit(index, watcher->config.vector, watcher->config.vector_size) {
+		if (offset & 2) {
+			temp |= index << 16;
+			writel(temp, watcher->cfg_base + watcher->vector_start + offset);
+		} else {
+			temp = index;
+		}
+
+		offset += 2;
+	}
+
+	if (offset & 2)
+		writel(temp, watcher->cfg_base + watcher->vector_start + offset);
+}
+
+void
+pmt_watcher_write_vector_to_dev(struct watcher_entry *watcher)
+{
+	if (pmt_watcher_is_type2(watcher))
+		pmt_watcher_write_vector_to_dev_type2(watcher);
+	else
+		pmt_watcher_write_vector_to_dev_type1(watcher);
+}
+/*
+ * sysfs
+ */
+static ssize_t
+mode_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct watcher_entry *watcher;
+	int i, cnt = 0;
+
+	watcher = dev_get_drvdata(dev);
+
+	for (i = 0; i < ARRAY_SIZE(sample_mode); i++) {
+		if (i == GET_MODE(watcher->config.control))
+			cnt += sprintf(buf + cnt, "[%s]", sample_mode[i]);
+		else
+			cnt += sprintf(buf + cnt, "%s", sample_mode[i]);
+		if (i < (ARRAY_SIZE(sample_mode) - 1))
+			cnt += sprintf(buf + cnt, " ");
+	}
+
+	cnt += sprintf(buf + cnt, "\n");
+
+	return cnt;
+}
+
+static ssize_t
+mode_store(struct device *dev, struct device_attribute *attr,
+	   const char *buf, size_t count)
+{
+	struct watcher_entry *watcher;
+	int mode;
+
+	watcher = dev_get_drvdata(dev);
+
+	mode = sysfs_match_string(sample_mode, buf);
+	if (mode < 0)
+		return mode;
+
+	/*
+	 * Allowable transitions:
+	 * Current State     Requested State
+	 * -------------     ---------------
+	 * DISABLED          PERIODIC or ONESHOT
+	 * PERIODIC          DISABLED
+	 * ONESHOT           DISABLED
+	 * SHARED            DISABLED
+	 */
+	if ((GET_MODE(watcher->config.control) != MODE_OFF) &&
+	    (mode != MODE_OFF))
+		return -EPERM;
+
+	/* Do not allow user to put device in shared state */
+	if (mode == MODE_SHARED)
+		return -EPERM;
+
+	/* We cannot change state if there is a request already pending */
+	if (pmt_watcher_request_pending(watcher))
+		return -EBUSY;
+
+	/*
+	 * Transition request is valid. Set mode, mode_lock
+	 * and execute request.
+	 */
+	watcher->config.control &= ~MODE_MASK;
+	watcher->config.control |= mode;
+
+	watcher->mode_lock = false;
+
+	if (mode != MODE_OFF) {
+		watcher->mode_lock = true;
+
+		/* Write the period and vector registers to the device */
+		pmt_watcher_write_period_to_dev(watcher);
+		pmt_watcher_write_stream_uid_to_dev(watcher);
+		pmt_watcher_write_vector_to_dev(watcher);
+	}
+
+	/* Submit requested changes to device */
+	pmt_watcher_write_ctrl_to_dev(watcher);
+
+	return strnlen(buf, count);
+}
+static DEVICE_ATTR_RW(mode);
+
+static ssize_t
+period_us_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct watcher_entry *watcher;
+
+	watcher = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", watcher->config.period);
+}
+
+static ssize_t
+period_us_store(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	struct watcher_entry *watcher;
+	u32 period;
+	int err;
+
+	watcher = dev_get_drvdata(dev);
+
+	if (watcher->mode_lock)
+		return -EPERM;
+
+	err = kstrtouint(buf, 0, &period);
+	if (err)
+		return err;
+
+	if (period > MAX_PERIOD_US) {
+		dev_err(dev, "Maximum period(us) allowed is %ld\n",
+			MAX_PERIOD_US);
+		return -EINVAL;
+	}
+
+	watcher->config.period = period;
+
+	return strnlen(buf, count);
+}
+static DEVICE_ATTR_RW(period_us);
+
+static ssize_t
+enable_list_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct watcher_entry *watcher;
+	int err;
+
+	watcher = dev_get_drvdata(dev);
+
+	err = bitmap_print_to_pagebuf(true, buf, watcher->config.vector,
+				      watcher->config.vector_size);
+
+	return err ?: strlen(buf);
+}
+
+static int
+pmt_watcher_write_vector(struct device *dev, struct watcher_entry *watcher,
+			 unsigned long *bit_vector)
+{
+	/*
+	 * Sampler vector select is limited by the size of the sampler
+	 * result buffer. Determine if we're exceeding the limit.
+	 */
+	if (pmt_watcher_select_limited(watcher)) {
+		int hw = bitmap_weight(bit_vector, watcher->config.vector_size);
+
+		if (hw > watcher->config.select_limit) {
+			dev_err(dev, "Too many bits(%d) selected. Maximum is %d\n",
+				hw, watcher->config.select_limit);
+			return -EINVAL;
+		}
+	}
+
+	/* Save the vector */
+	bitmap_copy(watcher->config.vector, bit_vector, watcher->config.vector_size);
+
+	return 0;
+}
+
+static ssize_t
+enable_list_store(struct device *dev, struct device_attribute *attr,
+		    const char *buf, size_t count)
+{
+	struct watcher_entry *watcher;
+	unsigned long *temp;
+	int err;
+
+	watcher = dev_get_drvdata(dev);
+
+	if (watcher->mode_lock)
+		return -EPERM;
+
+	/*
+	 * Create a temp buffer to store the incoming selection for
+	 * validation before saving.
+	 */
+	temp = bitmap_zalloc(watcher->config.vector_size, GFP_KERNEL);
+	if (!temp)
+		return -ENOMEM;
+
+	/*
+	 * Convert and store hexadecimal input string values into the
+	 * temp buffer.
+	 */
+	err = bitmap_parselist(buf, temp, watcher->config.vector_size);
+
+	/* Write new vector to watcher entry */
+	if (!err)
+		err = pmt_watcher_write_vector(dev, watcher, temp);
+
+	kfree(temp);
+
+	return err ?: count;
+}
+static DEVICE_ATTR_RW(enable_list);
+
+static ssize_t
+enable_vector_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct watcher_entry *watcher;
+	int err;
+
+	watcher = dev_get_drvdata(dev);
+
+	err = bitmap_print_to_pagebuf(false, buf, watcher->config.vector,
+				      watcher->config.vector_size);
+
+	return err ?: strlen(buf);
+}
+
+static ssize_t
+enable_vector_store(struct device *dev, struct device_attribute *attr,
+		    const char *buf, size_t count)
+{
+	struct watcher_entry *watcher;
+	unsigned long *temp;
+	int err;
+
+	watcher = dev_get_drvdata(dev);
+
+	if (watcher->mode_lock)
+		return -EPERM;
+
+	/*
+	 * Create a temp buffer to store the incoming selection for
+	 * validation before saving.
+	 */
+	temp = bitmap_zalloc(watcher->config.vector_size, GFP_KERNEL);
+	if (!temp)
+		return -ENOMEM;
+
+	/*
+	 * Convert and store hexadecimal input string values into the
+	 * temp buffer.
+	 */
+	err = bitmap_parse(buf, count, temp, watcher->config.vector_size);
+
+	/* Write new vector to watcher entry */
+	if (!err)
+		err = pmt_watcher_write_vector(dev, watcher, temp);
+
+	kfree(temp);
+
+	return err ?: count;
+}
+static DEVICE_ATTR_RW(enable_vector);
+
+static ssize_t
+enable_id_limit_show(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct watcher_entry *watcher;
+
+	watcher = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%d\n", watcher->config.vector_size - 1);
+}
+static DEVICE_ATTR_RO(enable_id_limit);
+
+static ssize_t
+select_limit_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct watcher_entry *watcher;
+
+	watcher = dev_get_drvdata(dev);
+
+	/* vector limit only applies to sampler */
+	if (!pmt_watcher_select_limited(watcher))
+		return sprintf(buf, "%d\n", -1);
+
+	return sprintf(buf, "%u\n", watcher->config.select_limit);
+}
+static DEVICE_ATTR_RO(select_limit);
+
+static ssize_t
+destination_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct watcher_entry *watcher;
+	int i, cnt = 0;
+
+	watcher = dev_get_drvdata(dev);
+
+	if (!pmt_watcher_is_tracer(watcher))
+		return sprintf(buf, "%d\n", -1);
+
+	for (i = 0; i < ARRAY_SIZE(tracer_destination); i++) {
+		if (i == GET_TRCR_DEST(watcher->config.control))
+			cnt += sprintf(buf + cnt, "[%s]",
+				       tracer_destination[i]);
+		else
+			cnt += sprintf(buf + cnt, "%s",
+				       tracer_destination[i]);
+		if (i < (ARRAY_SIZE(tracer_destination) - 1))
+			cnt += sprintf(buf + cnt, " ");
+	}
+
+	cnt += sprintf(buf + cnt, "\n");
+
+	return cnt;
+}
+
+static ssize_t
+destination_store(struct device *dev, struct device_attribute *attr,
+		  const char *buf, size_t count)
+{
+	struct watcher_entry *watcher;
+	int ret;
+
+	watcher = dev_get_drvdata(dev);
+
+	if (!pmt_watcher_is_tracer(watcher))
+		return -EINVAL;
+
+	if (watcher->mode_lock)
+		return -EPERM;
+
+	ret = sysfs_match_string(tracer_destination, buf);
+	if (ret < 0)
+		return ret;
+
+	watcher->config.control &= ~TRCR_DEST_MASK;
+	watcher->config.control |= SET_TRCR_DEST_BITS(ret);
+
+	return strnlen(buf, count);
+}
+static DEVICE_ATTR_RW(destination);
+
+static ssize_t
+token_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct watcher_entry *watcher;
+
+	watcher = dev_get_drvdata(dev);
+
+	if (!pmt_watcher_is_tracer(watcher))
+		return sprintf(buf, "%d\n", -1);
+
+	return sprintf(buf, "%lu\n", GET_TRCR_DEST(watcher->config.control));
+}
+
+static ssize_t
+token_store(struct device *dev, struct device_attribute *attr,
+	    const char *buf, size_t count)
+{
+	struct watcher_entry *watcher;
+	u32 token;
+	int result;
+
+	watcher = dev_get_drvdata(dev);
+
+	if (!pmt_watcher_is_tracer(watcher))
+		return -EINVAL;
+
+	if (watcher->mode_lock)
+		return -EPERM;
+
+	result = kstrtouint(buf, 0, &token);
+	if (result)
+		return result;
+
+	if (token > TRCR_TOKEN_MAX_SIZE)
+		return -EINVAL;
+
+	watcher->config.control &= ~TRCR_TOKEN_MASK;
+	watcher->config.control |= SET_TRCR_TOKEN_BITS(token);
+
+	return strnlen(buf, count);
+}
+static DEVICE_ATTR_RW(token);
+
+static ssize_t
+stream_uid_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct watcher_entry *watcher;
+
+	watcher = dev_get_drvdata(dev);
+
+	if (!pmt_watcher_is_tracer(watcher) ||
+	    watcher->stream_uid_offset < 0)
+		return sprintf(buf, "%d\n", -1);
+
+	return sprintf(buf, "0x%08x\n", watcher->config.stream_uid);
+}
+
+static ssize_t
+stream_uid_store(struct device *dev, struct device_attribute *attr,
+	    const char *buf, size_t count)
+{
+	struct watcher_entry *watcher;
+	u32 stream_uid;
+	int result;
+
+	watcher = dev_get_drvdata(dev);
+
+	if (!pmt_watcher_is_tracer(watcher) || watcher->stream_uid_offset < 0)
+		return -EINVAL;
+
+	if (watcher->mode_lock)
+		return -EPERM;
+
+	result = kstrtouint(buf, 0, &stream_uid);
+	if (result)
+		return result;
+
+	watcher->config.stream_uid = stream_uid;
+
+	return strnlen(buf, count);
+}
+static DEVICE_ATTR_RW(stream_uid);
+
+static struct attribute *pmt_watcher_attrs[] = {
+	&dev_attr_period_us.attr,
+	&dev_attr_mode.attr,
+	&dev_attr_enable_list.attr,
+	&dev_attr_enable_vector.attr,
+	&dev_attr_enable_id_limit.attr,
+	&dev_attr_select_limit.attr,
+	&dev_attr_destination.attr,
+	&dev_attr_token.attr,
+	&dev_attr_stream_uid.attr,
+	NULL
+};
+
+static struct attribute_group pmt_watcher_group = {
+	.attrs	= pmt_watcher_attrs,
+};
+
+/*
+ * initialization
+ */
+static void
+pmt_sample_repopulate_header(struct intel_pmt_entry *entry,
+			    struct intel_pmt_header *header,
+			    struct device *dev)
+{
+	struct watcher_entry *watcher = to_pmt_watcher(entry);
+	size_t vector_sz_in_bytes = entry->size - watcher->vector_start;
+	unsigned int sample_limit;
+	u8 bir;
+
+	/*
+	 * The base offset should always be 8 byte aligned.
+	 *
+	 * For non-local access types the lower 3 bits of base offset
+	 * contains the index of the base address register where the
+	 * telemetry can be found.
+	 */
+	bir = GET_BIR(header->base_offset);
+
+	/*
+	 * For sampler only, get the physical address and size of
+	 * the result buffer for the mmap as well as the vector
+	 * select limit for bounds checking.
+	 *
+	 * We are assuming "local" BAR to be BAR 0.
+	 */
+	header->base_offset = readl(watcher->cfg_base) + bir;
+
+	/* Size is reported in DWORDs so multiply by 4 to get bytes */
+	header->size = readb(watcher->cfg_base + SMPLR_BUFFER_SIZE_OFFSET) * 4;
+
+	/*
+	 * SMPLR_NUM_SAMPLES returns bytes divided by 8 to get number
+	 * of qwords which is the unit of sampling. Select_limit is
+	 * the maximum allowable hweight for the select vector
+	 */
+	sample_limit = SMPLR_NUM_SAMPLES(header->size, vector_sz_in_bytes);
+
+	if (sample_limit < watcher->config.select_limit)
+		watcher->config.select_limit = sample_limit;
+}
+
+static int
+pmt_watcher_create_entry(struct intel_pmt_entry *entry,
+			 struct intel_pmt_header *header,
+			 struct device *dev, struct resource *disc_res)
+{
+	struct watcher_entry *watcher = to_pmt_watcher(entry);
+	size_t vector_sz_in_bytes;
+	struct resource res;
+	int ret;
+
+	ret = intel_pmt_populate_entry(entry, header, dev, disc_res);
+	if (ret)
+		return ret;
+
+	watcher->type = GET_TYPE(readb(entry->disc_table));
+	if (pmt_watcher_is_tracer(watcher)) {
+		watcher->stream_uid_offset = TRCR_STREAM_UID_OFFSET;
+		watcher->ctrl_offset = TRCR_CONTROL_OFFSET;
+		watcher->vector_start = TRCR_VECTOR_OFFSET;
+	} else {
+		watcher->stream_uid_offset = -1;
+		watcher->ctrl_offset = SMPLR_CONTROL_OFFSET;
+		watcher->vector_start = SMPLR_VECTOR_OFFSET;
+	}
+
+	/* Add quirks related to TGL part */
+	if (intel_pmt_is_early_client_hw(dev)) {
+		/* tracer for TGL does not have support for stream UID */
+		watcher->stream_uid_offset = -1;
+		/* strip section that would have been stream UID */
+		if (pmt_watcher_is_tracer(watcher))
+			watcher->vector_start -= 8;
+		/* account for period and control being swapped */
+		watcher->ctrl_offset -= 4;
+
+		/*
+		 * Add offset for watcher type to account for type1 vs
+		 * type2 values.
+		 */
+		watcher->type += TYPE_TRACER1;
+	}
+
+	/*
+	 * Verify we have sufficient space to store the sample IDs or
+	 * bit vector needed to select sample IDs.
+	 */
+	vector_sz_in_bytes = entry->size - watcher->vector_start;
+	if (vector_sz_in_bytes < 2 || vector_sz_in_bytes > entry->size)
+		return -EINVAL;
+
+	/*
+	 * Determine the appropriate size of the vector in bits so that
+	 * the bitmap can be allocated.
+	 */
+	if (pmt_watcher_is_type2(watcher)) {
+		watcher->config.vector_size = 1UL << 16;
+		watcher->config.select_limit = vector_sz_in_bytes / 2;
+	} else {
+		watcher->config.vector_size = vector_sz_in_bytes * BITS_PER_BYTE;
+		watcher->config.select_limit = UINT_MAX;
+	}
+
+	res.start = entry->base_addr;
+	res.end = res.start + entry->size - 1;
+	res.flags = IORESOURCE_MEM;
+
+	watcher->cfg_base = devm_ioremap_resource(dev, &res);
+	if (IS_ERR(watcher->cfg_base)) {
+		dev_err(dev, "Failed to ioremap watcher control region\n");
+		return -EIO;
+	}
+
+	/*
+	 * Reset the base_addr and size fields as what was previously stored
+	 * there has now been mapped as the base for configuration. Instead
+	 * we will leave this as 0 for now and repopulate in the case of a
+	 * sampler.
+	 */
+
+	header->access_type = ACCESS_BARID;
+	header->size = 0;
+
+	if (pmt_watcher_is_sampler(watcher))
+		pmt_sample_repopulate_header(entry, header, dev);
+
+	/*
+	 * If there is already some request that is stuck in the hardware
+	 * then we will need to wait for it to be cleared before we can
+	 * bring up the device.
+	 */
+	if (pmt_watcher_request_pending(watcher))
+		return -EBUSY;
+
+	watcher->config.vector = bitmap_zalloc(watcher->config.vector_size, GFP_KERNEL);
+	if (!watcher->config.vector)
+		return -ENOMEM;
+
+	/*
+	 * Set mode to "Disabled" to clean up any state that may still be
+	 * floating around in the registers. If it looks like an out-of-band
+	 * entity might be using the part set the mode to shared to indicate
+	 * that we have not taken full control of the device yet.
+	 */
+	if (!pmt_watcher_in_use(watcher))
+		pmt_watcher_write_ctrl_to_dev(watcher);
+	else
+		watcher->config.control = MODE_SHARED;
+
+	return 0;
+}
+
+static int pmt_watcher_header_decode(struct intel_pmt_entry *entry,
+				     struct intel_pmt_header *header,
+				     struct device *dev,
+				     struct resource *disc_res)
+{
+	void __iomem *disc_table = entry->disc_table;
+
+	header->access_type = GET_ACCESS(readb(disc_table));
+	header->guid = readl(disc_table + GUID_OFFSET);
+	header->base_offset = readl(disc_table + BASE_OFFSET);
+
+	/* Size is measured in DWORDS, but accessor returns bytes */
+	header->size = GET_SIZE(readl(disc_table));
+
+	return pmt_watcher_create_entry(entry, header, dev, disc_res);
+}
+
+static DEFINE_XARRAY_ALLOC(watcher_array);
+static struct intel_pmt_namespace pmt_watcher_ns = {
+	.name = "watcher",
+	.xa = &watcher_array,
+	.attr_grp = &pmt_watcher_group,
+	.pmt_header_decode = pmt_watcher_header_decode,
+};
+
+static int pmt_watcher_remove(struct platform_device *pdev)
+{
+	struct pmt_watcher_priv *priv = platform_get_drvdata(pdev);
+	int i;
+
+	for (i = 0; i < priv->num_entries; i++)
+		intel_pmt_dev_destroy(&priv->entry[i].entry, &pmt_watcher_ns);
+
+	return 0;
+}
+
+static int pmt_watcher_probe(struct platform_device *pdev)
+{
+	struct pmt_watcher_priv *priv;
+	size_t size;
+	int i, ret;
+
+	size = struct_size(priv, entry, pdev->num_resources);
+	priv = devm_kzalloc(&pdev->dev, size, GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, priv);
+
+	for (i = 0; i < pdev->num_resources; i++) {
+		struct intel_pmt_entry *entry = &priv->entry[i].entry;
+
+		ret = intel_pmt_dev_create(entry, &pmt_watcher_ns, pdev, i);
+		if (ret < 0)
+			goto abort_probe;
+		if (ret)
+			continue;
+
+		priv->num_entries++;
+	}
+
+	return 0;
+abort_probe:
+	pmt_watcher_remove(pdev);
+	return ret;
+}
+
+static struct platform_driver pmt_watcher_driver = {
+	.driver = {
+		.name   = DRV_NAME,
+	},
+	.remove = pmt_watcher_remove,
+	.probe  = pmt_watcher_probe,
+};
+
+static int __init pmt_watcher_init(void)
+{
+	return platform_driver_register(&pmt_watcher_driver);
+}
+
+static void __exit pmt_watcher_exit(void)
+{
+	platform_driver_unregister(&pmt_watcher_driver);
+	xa_destroy(&watcher_array);
+}
+
+module_init(pmt_watcher_init);
+module_exit(pmt_watcher_exit);
+
+MODULE_AUTHOR("David E. Box <david.e.box@linux.intel.com>");
+MODULE_DESCRIPTION("Intel PMT Watcher driver");
+MODULE_ALIAS("platform:" DRV_NAME);
+MODULE_LICENSE("GPL v2");
-- 
2.27.0

