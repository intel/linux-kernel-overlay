From 0435c9a589eeb2f98f3f113bb7328bcd19373bb6 Mon Sep 17 00:00:00 2001
From: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date: Wed, 17 Feb 2021 20:46:48 +0200
Subject: [PATCH 42/81] counter: intel-qep: Remove capture compare feature

I have a few doubts with capture compare feature:

- Reading capture data in busy loop will drain the capture FIFO and
  userspace gets then mostly zeros and valid data only when new data was
  put into FIFO by the HW. SW should at least perhaps check the FIFO_EMPTY
  flag in QEPCON before returning data to userspace.
- HW is able to trigger FIFO_CRIT interrupt storm when userspace hasn't
  read the capture data and when FIFO threshold is reached. And it looks
  this storm won't end even when FIFO is read.
- Userspace should block if FIFO is empty and wakeup after FIFOENTRY
  interrupt. Not sure is that wait allowed by the counter subsystem.
- "operating_mode" and "capture_mode" sysfs files don't reveal what is
  expected write to them. It must be checked from source code. They
  perhaps should be implemented by using the COUNTER_COUNT_ENUM() and
  COUNTER_COUNT_ENUM_AVAILABLE() helper macros.
- I'm unsure does this feature actually fit in counter subsystem.

Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
---
 drivers/counter/intel-qep.c | 110 ------------------------------------
 1 file changed, 110 deletions(-)

diff --git a/drivers/counter/intel-qep.c b/drivers/counter/intel-qep.c
index 286c510fcc6c..61d69fadc096 100644
--- a/drivers/counter/intel-qep.c
+++ b/drivers/counter/intel-qep.c
@@ -66,9 +66,6 @@
 					INTEL_QEPINT_QEPDIR)
 #define INTEL_QEPINT_MASK_ALL		GENMASK(5, 0)
 
-#define INTEL_QEP_OP_MODE_QEP		0
-#define INTEL_QEP_OP_MODE_CC		1
-
 #define INTEL_QEP_COUNTER_EXT_RW(_name) \
 { \
 	.name = #_name, \
@@ -89,12 +86,6 @@
 	.write = _name##_write, \
 }
 
-#define INTEL_QEP_COUNTER_COUNT_EXT_RO(_name) \
-{ \
-	.name = #_name, \
-	.read = _name##_read, \
-}
-
 struct intel_qep {
 	struct counter_device counter;
 	struct mutex lock;
@@ -102,8 +93,6 @@ struct intel_qep {
 	void __iomem *regs;
 	u32 int_stat;
 	bool enabled;
-	int op_mode;
-	int cap_mode;
 };
 
 #define counter_to_qep(c)	(container_of((c), struct intel_qep, counter))
@@ -423,106 +412,9 @@ static ssize_t enable_write(struct counter_device *counter,
 	return len;
 }
 
-static ssize_t operating_mode_read(struct counter_device *counter,
-				   struct counter_count *count,
-				   void *priv, char *buf)
-{
-	struct intel_qep *qep = counter_to_qep(counter);
-
-	return snprintf(buf, PAGE_SIZE, "%s\n", qep->op_mode ?
-			"capture" : "quadrature");
-}
-
-static ssize_t operating_mode_write(struct counter_device *counter,
-				    struct counter_count *count,
-				    void *priv, const char *buf, size_t len)
-{
-	struct intel_qep *qep = counter_to_qep(counter);
-	u32 reg;
-
-	if (qep->enabled)
-		return -EINVAL;
-
-	pm_runtime_get_sync(qep->dev);
-
-	mutex_lock(&qep->lock);
-	reg = intel_qep_readl(qep, INTEL_QEPCON);
-
-	if (sysfs_streq(buf, "capture")) {
-		reg |= INTEL_QEPCON_OP_MODE;
-		qep->op_mode = INTEL_QEP_OP_MODE_CC;
-	} else if (sysfs_streq(buf, "quadrature")) {
-		reg &= ~INTEL_QEPCON_OP_MODE;
-		qep->op_mode = INTEL_QEP_OP_MODE_QEP;
-	}
-
-	intel_qep_writel(qep, INTEL_QEPCON, reg);
-	mutex_unlock(&qep->lock);
-
-	pm_runtime_put(qep->dev);
-
-	return len;
-}
-
-static ssize_t capture_data_read(struct counter_device *counter,
-				 struct counter_count *count,
-				 void *priv, char *buf)
-{
-	struct intel_qep *qep = counter_to_qep(counter);
-	u32 reg;
-
-	reg = intel_qep_readl(qep, INTEL_QEPCAPBUF);
-
-	return snprintf(buf, PAGE_SIZE, "%u\n", reg);
-}
-
-static ssize_t capture_mode_read(struct counter_device *counter,
-				 struct counter_count *count,
-				 void *priv, char *buf)
-{
-	struct intel_qep *qep = counter_to_qep(counter);
-
-	return snprintf(buf, PAGE_SIZE, "%s\n", qep->cap_mode ?
-			"both" : "single");
-}
-
-static ssize_t capture_mode_write(struct counter_device *counter,
-				  struct counter_count *count,
-				  void *priv, const char *buf, size_t len)
-{
-	struct intel_qep *qep = counter_to_qep(counter);
-	u32 reg;
-
-	if (qep->enabled)
-		return -EINVAL;
-
-	pm_runtime_get_sync(qep->dev);
-
-	mutex_lock(&qep->lock);
-	reg = intel_qep_readl(qep, INTEL_QEPCON);
-
-	if (sysfs_streq(buf, "both")) {
-		reg |= INTEL_QEPCON_CAP_MODE;
-		qep->cap_mode = 1;
-	} else if (sysfs_streq(buf, "single")) {
-		reg &= ~INTEL_QEPCON_CAP_MODE;
-		qep->cap_mode = 0;
-	}
-
-	intel_qep_writel(qep, INTEL_QEPCON, reg);
-	mutex_unlock(&qep->lock);
-
-	pm_runtime_put(qep->dev);
-
-	return len;
-}
-
 static const struct counter_count_ext intel_qep_count_ext[] = {
 	INTEL_QEP_COUNTER_COUNT_EXT_RW(ceiling),
 	INTEL_QEP_COUNTER_COUNT_EXT_RW(enable),
-	INTEL_QEP_COUNTER_COUNT_EXT_RW(operating_mode),
-	INTEL_QEP_COUNTER_COUNT_EXT_RO(capture_data),
-	INTEL_QEP_COUNTER_COUNT_EXT_RW(capture_mode),
 };
 
 static struct counter_count intel_qep_counter_count[] = {
@@ -686,8 +578,6 @@ static int intel_qep_probe(struct pci_dev *pci, const struct pci_device_id *id)
 	qep->counter.num_ext = ARRAY_SIZE(intel_qep_ext);
 	qep->counter.priv = qep;
 	qep->enabled = false;
-	qep->op_mode = INTEL_QEP_OP_MODE_QEP;
-	qep->cap_mode = 0;
 
 	ret = pci_alloc_irq_vectors(pci, 1, 1, PCI_IRQ_ALL_TYPES);
 	if (ret < 0)
-- 
2.27.0

