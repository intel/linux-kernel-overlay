From 85cf74ab215efecaf2fa289f5b123b83a0b38f82 Mon Sep 17 00:00:00 2001
From: sandeep singh <sandeep1.singh@intel.com>
Date: Thu, 15 Apr 2021 15:13:54 +0530
Subject: [PATCH 060/223] Board_id changes

Adding Board Id for TBH

Signed-off-by: sandeep singh <sandeep1.singh@intel.com>
---
 drivers/misc/hddl_device/hddl_device_lh.c     | 11 +++
 .../misc/intel_tsens/intel_tsens_thermal.c    |  4 +-
 drivers/misc/intel_tsens/thunderbay_thermal.c | 89 +++++++++++++++++++
 drivers/misc/intel_tsens/thunderbay_tsens.h   | 34 ++++++-
 4 files changed, 134 insertions(+), 4 deletions(-)

diff --git a/drivers/misc/hddl_device/hddl_device_lh.c b/drivers/misc/hddl_device/hddl_device_lh.c
index 6551d4417e88..dda908754992 100644
--- a/drivers/misc/hddl_device/hddl_device_lh.c
+++ b/drivers/misc/hddl_device/hddl_device_lh.c
@@ -47,6 +47,7 @@ struct intel_tsens {
 struct intel_hddl_client_priv {
 	void __iomem *base_addr;
 	int board_id;
+	int board_type;
 	int soc_id;
 	int n_clients;
 	u32 nsens;
@@ -691,6 +692,16 @@ static int intel_hddl_config_dt(struct intel_hddl_client_priv *priv)
 		dev_err(&pdev->dev, "Unable to get board/soc id");
 		return ret;
 	}
+
+	if (of_property_read_bool(np, "id")) {
+		of_property_read_u32(np, "id", &priv->board_info.soc_id);
+		priv->soc_id = priv->board_info.soc_id;
+		dev_info(&pdev->dev, "soc-id cfg available in dts %d\n",
+		priv->soc_id);
+        }
+
+        of_property_read_u32(np, "board_type", &priv->board_type);
+
 	ret = hddl_get_board_reset_data(pdev, priv);
 	if (ret) {
 		dev_err(&pdev->dev, "Unable to get reset data");
diff --git a/drivers/misc/intel_tsens/intel_tsens_thermal.c b/drivers/misc/intel_tsens/intel_tsens_thermal.c
index 12fbe33b33ae..9218768c1aea 100644
--- a/drivers/misc/intel_tsens/intel_tsens_thermal.c
+++ b/drivers/misc/intel_tsens/intel_tsens_thermal.c
@@ -48,6 +48,7 @@ struct intel_tsens_priv {
 	void __iomem *base_addr;
 	struct clk *tsens_clk;
 	u32 tsens_clk_rate;
+	u32 board_type;
 	struct intel_tsens **intel_tsens;
 	struct device *dev;
 	struct platform_device *pdev;
@@ -540,7 +541,7 @@ static int intel_iccmax_config_dt(struct intel_tsens_priv *priv)
 	icc_config->polarity = of_property_read_bool(np, "polarity");
 	if (icc_config->polarity) {
 		of_property_read_u32_index(np, "polarity", 0, &icc_config->set_polarity);
-		iowrite32(icc_config->set_polarity, icc_config->base_addr + icc_config->size);
+		//iowrite32(icc_config->set_polarity, icc_config->base_addr + icc_config->size);
 	}
 
 	if (icc_config->n_iccmax == 0) {
@@ -678,6 +679,7 @@ static int intel_tsens_config_dt(struct intel_tsens_priv *priv)
 			return ret;
 		}
 	}
+	of_property_read_u32(np, "board_type", &priv->board_type);
 	of_property_read_string_index(np, "plat_name", 0,
 				      &priv->plat_info.plat_name);
 	priv->intel_tsens =
diff --git a/drivers/misc/intel_tsens/thunderbay_thermal.c b/drivers/misc/intel_tsens/thunderbay_thermal.c
index 2fac4e9a0e39..a23cc6e14c3e 100644
--- a/drivers/misc/intel_tsens/thunderbay_thermal.c
+++ b/drivers/misc/intel_tsens/thunderbay_thermal.c
@@ -70,12 +70,15 @@ u32 dts_pid_min_accum_limit;
 struct thunderbay_thermal_priv {
 	const char *name;
 	void __iomem *base_addr;
+	void __iomem *gpio_addr;
 	spinlock_t lock;		/* Spinlock */
 	u32 current_temp[THUNDERBAY_SENSOR_MAX];
 	struct intel_tsens_plat_data *plat_data;
 	struct device_node *s_node;
 	struct intel_tsens_pid *pid_info;
 	bool irq_available;
+	int calib_off;
+	int board_type;
 	struct platform_device *pdev;
 };
 
@@ -296,6 +299,7 @@ static int intel_tbh_thermal_config(struct thunderbay_thermal_priv *priv, int ty
 	struct dentry *thermal_debug;
 	struct thb_thermal *thb_t;
 	static int common_dir;
+	struct device_node *np = pdev->dev.of_node;
 
 	thb_t = devm_kzalloc(&pdev->dev,
 			     sizeof(struct thb_thermal),
@@ -304,6 +308,19 @@ static int intel_tbh_thermal_config(struct thunderbay_thermal_priv *priv, int ty
 		dev_err(&pdev->dev, "No memory");
 		return -ENOMEM;
 	}
+	ret = of_property_read_u32(np, "calib_off",
+				   &priv->calib_off);
+	if (ret && ret != -EINVAL)
+		pr_info("calib_off failed \n");
+	pr_info("hddl: calibration value for %s is %x",
+				   np->name,  priv->calib_off);
+	ret = of_property_read_u32(np, "board_type",
+				   &priv->board_type);
+	if (ret && ret != -EINVAL)
+		pr_info("board_id failed \n");
+	pr_info("hddl_thb: board_type value for %s is %x",
+		np->name, priv->board_type);
+
 	if (common_dir == 0) {
 		dir = debugfs_create_dir("thb_thermal", 0);
 		if (!dir) {
@@ -692,6 +709,71 @@ static int intel_tbh_thermal_config(struct thunderbay_thermal_priv *priv, int ty
 return 0;
 }
 
+static int thunderbay_thermal_trip(void __iomem *base_addr, int type)
+{
+	if (type == CPUSS_SOUTH_NOC)
+		iowrite32(0x1, base_addr + A53SS_THERM_CTRL);
+return 0;
+}
+
+static int thunderbay_iccmax_default_config(void __iomem *base_addr,
+					    void __iomem *gpio_addr,
+    					    int board_type, int type)
+{
+	if (board_type == 9 || board_type == 11) {
+		iowrite32(GPIO_POLARITY_EVT2, gpio_addr + GPIO_POWER_OFFSET);
+		switch (type) {
+		case PAR_VPU_0:
+			iowrite32(COMSS_THERM_SCALING_CNT,
+				  base_addr + COMSS_THERM_SCALING_CNT_OFFSET);
+			iowrite32(COMSS_0_ICCMAX_GPIO_EN_CCU0,
+				  base_addr + ICCMAX_GPIO_EN_CCU0_OFFSET);
+			iowrite32(COMSS_ICCMAX_THROT_CFG_CCU0,
+				  base_addr + ICCMAX_THROT_CFG_CCU0_OFFSET);
+			break;
+
+		case PAR_VPU_1:
+			iowrite32(COMSS_THERM_SCALING_CNT,
+				  base_addr + COMSS_THERM_SCALING_CNT_OFFSET);
+			iowrite32(COMSS_1_ICCMAX_GPIO_EN_CCU0,
+				  base_addr + ICCMAX_GPIO_EN_CCU0_OFFSET);
+			iowrite32(COMSS_ICCMAX_THROT_CFG_CCU0,
+				  base_addr + ICCMAX_THROT_CFG_CCU0_OFFSET);
+			break;
+
+		case PAR_VPU_2:
+			iowrite32(COMSS_THERM_SCALING_CNT,
+				  base_addr + COMSS_THERM_SCALING_CNT_OFFSET);
+			iowrite32(COMSS_2_ICCMAX_GPIO_EN_CCU0,
+				  base_addr + ICCMAX_GPIO_EN_CCU0_OFFSET);
+			iowrite32(COMSS_ICCMAX_THROT_CFG_CCU0,
+				  base_addr + ICCMAX_THROT_CFG_CCU0_OFFSET);
+			break;
+
+		case PAR_VPU_3:
+			iowrite32(COMSS_THERM_SCALING_CNT,
+				  base_addr + COMSS_THERM_SCALING_CNT_OFFSET);
+			iowrite32(COMSS_3_ICCMAX_GPIO_EN_CCU0,
+				  base_addr + ICCMAX_GPIO_EN_CCU0_OFFSET);
+			iowrite32(COMSS_ICCMAX_THROT_CFG_CCU0,
+				  base_addr + ICCMAX_THROT_CFG_CCU0_OFFSET);
+			break;
+
+		default:
+			break;
+			}
+		}
+	if (board_type == 8 || board_type == 10 || board_type == 12) {
+		iowrite32(GPIO_PMAX_POLARITY_EVT1, gpio_addr + GPIO_POWER_OFFSET);
+		iowrite32(COMSS_THERM_SCALING_CNT,
+			  base_addr + COMSS_THERM_SCALING_CNT_OFFSET);
+		iowrite32(COMSS_ONLY_PMAX_ENABLED,
+			  base_addr + ICCMAX_GPIO_EN_CCU0_OFFSET);
+		iowrite32(COMSS_ICCMAX_THROT_CFG_CCU0,
+			  base_addr + ICCMAX_THROT_CFG_CCU0_OFFSET);
+	}
+return 0;
+}
 
 static int thunderbay_thermal_probe(struct platform_device *pdev)
 {
@@ -710,6 +792,7 @@ static int thunderbay_thermal_probe(struct platform_device *pdev)
 		dev_err(&pdev->dev, "No memory");
 		return -ENOMEM;
 	}
+	priv->gpio_addr = devm_ioremap(&pdev->dev, GPIO_REG, GPIO_POWER_OFFSET);	
 	//iowrite32(0x1c0, plat_data->base_addr+DTS_THD_SAR_PID_EN_ABORT);
 	priv->name = plat_data->name;
 	priv->base_addr = plat_data->base_addr;
@@ -720,6 +803,12 @@ static int thunderbay_thermal_probe(struct platform_device *pdev)
 	//thermal register config
 	if (intel_tbh_thermal_config(priv, plat_data->sensor_type))
 		dev_info(&pdev->dev, "THENDERBAY_THERMAL_CONFIGURATION_FAILED");
+	//setting thermal_trip
+	thunderbay_thermal_trip(priv->base_addr, plat_data->sensor_type);
+	//seting iccmax and pmax default values
+	thunderbay_iccmax_default_config(priv->base_addr,priv->gpio_addr,
+					 priv->board_type,
+					 plat_data->sensor_type);
 	spin_lock_init(&priv->lock);
 	platform_set_drvdata(pdev, priv);
 
diff --git a/drivers/misc/intel_tsens/thunderbay_tsens.h b/drivers/misc/intel_tsens/thunderbay_tsens.h
index aa542d1c152b..b5ea8a2940d0 100644
--- a/drivers/misc/intel_tsens/thunderbay_tsens.h
+++ b/drivers/misc/intel_tsens/thunderbay_tsens.h
@@ -19,8 +19,39 @@
 #define COM_CPR_1_BASE 0x285520000
 #define COM_CPR_0_BASE 0x185520000
 #define A53SS_BASE     0x88830000
+/* GPIO Polarity */
+#define GPIO_REG 0x80450000
+#define GPIO_POWER_OFFSET 0x010C
+#define GPIO_POLARITY_EVT1 0x6
+#define GPIO_POLARITY_EVT2 0xE
+#define GPIO_PMAX_POLARITY_EVT1 0x2
 /* SAR_PID_EN */
 #define DTS_THD_SAR_PID_EN_ABORT 0x3024
+/* THERM_CTRL */
+#define A53SS_THERM_CTRL 0x4c0
+
+/* THERMAL INTERRUPT CLEAR */
+#define SW_THERM_INTR_STAT 0x407c
+
+/* ICCMAX_PMAX_DEFAULT_CFG */
+#define ICCMAX_THROT_CFG_CCU0_OFFSET 0X307c
+#define ICCMAX_GPIO_EN_CCU0_OFFSET 0x30bc
+#define ICCMAX_THROT_CFG_CCU0_VALUE 0x81019
+#define REG_THROT_MODE 0x1
+#define REG_THROT_CNT 0xc
+#define REG_MAX_CG_MASK 0x8
+#define REG_START_CG_MASK 0x0
+#define REG_CG_INCR_VAL 0x1
+#define COMSS_ICCMAX_THROT_CFG_CCU0 ((REG_THROT_MODE) | (REG_THROT_CNT << 1) |\
+				    (REG_MAX_CG_MASK << 9) | (REG_START_CG_MASK << 14) |\
+    				    (REG_CG_INCR_VAL << 19))
+#define COMSS_0_ICCMAX_GPIO_EN_CCU0 0x9
+#define COMSS_1_ICCMAX_GPIO_EN_CCU0 0x5
+#define COMSS_2_ICCMAX_GPIO_EN_CCU0 0x9
+#define COMSS_3_ICCMAX_GPIO_EN_CCU0 0x5
+#define COMSS_ONLY_PMAX_ENABLED 0x1
+#define COMSS_THERM_SCALING_CNT 0x1
+#define COMSS_THERM_SCALING_CNT_OFFSET 0x3078
 
 /*temp boundary cases */
 /* temperature boundary cases */
@@ -29,9 +60,6 @@
 #define LOWER_TEMP -13736
 #define UPPER_TEMP 153123
 
-/* THERMAL INTERRUPT CLEAR */
-#define SW_THERM_INTR_STAT 0x407c
-
 /* PID Registers */
 #define HW_THROT_MODE_CCU0 0x308c
 #define HW_THROT_MODE_CCU1 0x3090
-- 
2.27.0

