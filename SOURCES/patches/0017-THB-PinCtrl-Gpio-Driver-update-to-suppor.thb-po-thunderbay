From 84d2fa5850f77446056a52e6c93bdad582de7c30 Mon Sep 17 00:00:00 2001
From: Pavitra <PavitraX.S@intel.com>
Date: Wed, 3 Feb 2021 18:36:56 +0530
Subject: [PATCH 017/223] THB:PinCtrl/Gpio - Driver update to support pinmux
 configuration read via device-tree

Driver update to support pinmux

Signed-off-by: Pavitra <PavitraX.S@intel.com>
---
 drivers/pinctrl/pinctrl-thunderbay.c | 1828 +++++++++++++++-----------
 drivers/pinctrl/pinctrl-thunderbay.h |  320 +----
 2 files changed, 1102 insertions(+), 1046 deletions(-)

diff --git a/drivers/pinctrl/pinctrl-thunderbay.c b/drivers/pinctrl/pinctrl-thunderbay.c
index 751c12172282..07629fa78677 100644
--- a/drivers/pinctrl/pinctrl-thunderbay.c
+++ b/drivers/pinctrl/pinctrl-thunderbay.c
@@ -35,421 +35,438 @@
 
 #include "pinctrl-thunderbay.h"
 
-
+/*********************************************************************************
+ * Private structures
+ ********************************************************************************/
 const struct pinctrl_pin_desc thunderbay_pins[] = {
 	THUNDERBAY_PIN_DESC(0, "GPIO0",
-		THUNDERBAY_MUX(0x0, "I2C0_SCL"),
-		THUNDERBAY_MUX(0x1, "EMPTY"),
-		THUNDERBAY_MUX(0x2, "EMPTY"),
-		THUNDERBAY_MUX(0x3, "EMPTY"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "I2C0_M0"), /* I2C0_SCL */
+		THUNDERBAY_MUX(0X1, "EMPTY_M1"), /* EMPTY */
+		THUNDERBAY_MUX(0X2, "EMPTY_M2"), /* EMPTY */
+		THUNDERBAY_MUX(0X3, "EMPTY_M3"), /* EMPTY */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(1, "GPIO1",
-		THUNDERBAY_MUX(0x0, "I2C0_SDA"),
-		THUNDERBAY_MUX(0x1, "EMPTY"),
-		THUNDERBAY_MUX(0x2, "EMPTY"),
-		THUNDERBAY_MUX(0x3, "EMPTY"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "I2C0_M0"),  /* I2C0_SDA */
+		THUNDERBAY_MUX(0X1, "EMPTY_M1"), /* EMPTY */
+		THUNDERBAY_MUX(0X2, "EMPTY_M2"), /* EMPTY */
+		THUNDERBAY_MUX(0X3, "EMPTY_M3"), /* EMPTY */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(2, "GPIO2",
-		THUNDERBAY_MUX(0x0, "I2C1_SCL"),
-		THUNDERBAY_MUX(0x1, "EMPTY"),
-		THUNDERBAY_MUX(0x2, "EMPTY"),
-		THUNDERBAY_MUX(0x3, "EMPTY"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "I2C1_M0"),  /* I2C1_SCL */
+		THUNDERBAY_MUX(0X1, "EMPTY_M1"), /* EMPTY */
+		THUNDERBAY_MUX(0X2, "EMPTY_M2"), /* EMPTY */
+		THUNDERBAY_MUX(0X3, "EMPTY_M3"), /* EMPTY */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(3, "GPIO3",
-		THUNDERBAY_MUX(0x0, "I2C1_SDA"),
-		THUNDERBAY_MUX(0x1, "EMPTY"),
-		THUNDERBAY_MUX(0x2, "EMPTY"),
-		THUNDERBAY_MUX(0x3, "EMPTY"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "I2C1_M0"),  /* I2C1_SDA */
+		THUNDERBAY_MUX(0X1, "EMPTY_M1"), /* EMPTY */
+		THUNDERBAY_MUX(0X2, "EMPTY_M2"), /* EMPTY */
+		THUNDERBAY_MUX(0X3, "EMPTY_M3"), /* EMPTY */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(4, "GPIO4",
-		THUNDERBAY_MUX(0x0, "I2C2_SCL"),
-		THUNDERBAY_MUX(0x1, "EMPTY"),
-		THUNDERBAY_MUX(0x2, "EMPTY"),
-		THUNDERBAY_MUX(0x3, "EMPTY"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "I2C2_M0"),  /* I2C2_SCL */
+		THUNDERBAY_MUX(0X1, "EMPTY_M1"), /* EMPTY */
+		THUNDERBAY_MUX(0X2, "EMPTY_M2"), /* EMPTY */
+		THUNDERBAY_MUX(0X3, "EMPTY_M3"), /* EMPTY */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(5, "GPIO5",
-		THUNDERBAY_MUX(0x0, "I2C2_SDA"),
-		THUNDERBAY_MUX(0x1, "EMPTY"),
-		THUNDERBAY_MUX(0x2, "EMPTY"),
-		THUNDERBAY_MUX(0x3, "EMPTY"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "I2C2_M0"),  /* I2C2_SDA */
+		THUNDERBAY_MUX(0X1, "EMPTY_M1"), /* EMPTY */
+		THUNDERBAY_MUX(0X2, "EMPTY_M2"), /* EMPTY */
+		THUNDERBAY_MUX(0X3, "EMPTY_M3"), /* EMPTY */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(6, "GPIO6",
-		THUNDERBAY_MUX(0x0, "I2C3_SCL"),
-		THUNDERBAY_MUX(0x1, "EMPTY"),
-		THUNDERBAY_MUX(0x2, "EMPTY"),
-		THUNDERBAY_MUX(0x3, "EMPTY"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "I2C3_M0"),  /* I2C3_SCL */
+		THUNDERBAY_MUX(0X1, "EMPTY_M1"), /* EMPTY */
+		THUNDERBAY_MUX(0X2, "EMPTY_M2"), /* EMPTY */
+		THUNDERBAY_MUX(0X3, "EMPTY_M3"), /* EMPTY */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(7, "GPIO7",
-		THUNDERBAY_MUX(0x0, "I2C3_SDA"),
-		THUNDERBAY_MUX(0x1, "EMPTY"),
-		THUNDERBAY_MUX(0x2, "EMPTY"),
-		THUNDERBAY_MUX(0x3, "EMPTY"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "I2C3_M0"),  /* I2C3_SDA */
+		THUNDERBAY_MUX(0X1, "EMPTY_M1"), /* EMPTY */
+		THUNDERBAY_MUX(0X2, "EMPTY_M2"), /* EMPTY */
+		THUNDERBAY_MUX(0X3, "EMPTY_M3"), /* EMPTY */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(8, "GPIO8",
-		THUNDERBAY_MUX(0x0, "I2C4_SCL"),
-		THUNDERBAY_MUX(0x1, "EMPTY"),
-		THUNDERBAY_MUX(0x2, "EMPTY"),
-		THUNDERBAY_MUX(0x3, "EMPTY"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "I2C4_M0"),  /* I2C4_SCL */
+		THUNDERBAY_MUX(0X1, "EMPTY_M1"), /* EMPTY */
+		THUNDERBAY_MUX(0X2, "EMPTY_M2"), /* EMPTY */
+		THUNDERBAY_MUX(0X3, "EMPTY_M3"), /* EMPTY */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(9, "GPIO9",
-		THUNDERBAY_MUX(0x0, "I2C4_SDA"),
-		THUNDERBAY_MUX(0x1, "EMPTY"),
-		THUNDERBAY_MUX(0x2, "EMPTY"),
-		THUNDERBAY_MUX(0x3, "EMPTY"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "I2C4_M0"),  /* I2C4_SDA */
+		THUNDERBAY_MUX(0X1, "EMPTY_M1"), /* EMPTY */
+		THUNDERBAY_MUX(0X2, "EMPTY_M2"), /* EMPTY */
+		THUNDERBAY_MUX(0X3, "EMPTY_M3"), /* EMPTY */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(10, "GPIO10",
-		THUNDERBAY_MUX(0x0, "UART0_SOUT"),
-		THUNDERBAY_MUX(0x1, "rt0_dsu_active"),
-		THUNDERBAY_MUX(0x2, "EMPTY"),
-		THUNDERBAY_MUX(0x3, "EMPTY"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "UART0_M0"), /* UART0_SOUT */
+		THUNDERBAY_MUX(0X1, "RT0_DSU_M1"), /* RT0_DSU_ACTIVE */
+		THUNDERBAY_MUX(0X2, "EMPTY_M2"), /* EMPTY */
+		THUNDERBAY_MUX(0X3, "EMPTY_M3"), /* EMPTY */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(11, "GPIO11",
-		THUNDERBAY_MUX(0x0, "UART0_SIN"),
-		THUNDERBAY_MUX(0x1, "rt0_dsu_tstop"),
-		THUNDERBAY_MUX(0x2, "EMPTY"),
-		THUNDERBAY_MUX(0x3, "EMPTY"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "UART0_M0"), /* UART0_SIN */
+		THUNDERBAY_MUX(0X1, "RT0_DSU_M1"), /* RT0_DSU_TSTOP */
+		THUNDERBAY_MUX(0X2, "EMPTY_M2"), /* EMPTY */
+		THUNDERBAY_MUX(0X3, "EMPTY_M3"), /* EMPTY */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(12, "GPIO12",
-		THUNDERBAY_MUX(0x0, "uart0_cts_n"),
-		THUNDERBAY_MUX(0x1, "rt1_dsu_active"),
-		THUNDERBAY_MUX(0x2, "EMPTY"),
-		THUNDERBAY_MUX(0x3, "EMPTY"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "UART0_M0"), /* UART0_CTS_N */
+		THUNDERBAY_MUX(0X1, "RT1_DSU_M1"), /* RT1_DSU_ACTIVE */
+		THUNDERBAY_MUX(0X2, "EMPTY_M2"), /* EMPTY */
+		THUNDERBAY_MUX(0X3, "EMPTY_M3"), /* EMPTY */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(13, "GPIO13",
-		THUNDERBAY_MUX(0x0, "uart0_rts_n"),
-		THUNDERBAY_MUX(0x1, "rt1_dsu_tstop"),
-		THUNDERBAY_MUX(0x2, "EMPTY"),
-		THUNDERBAY_MUX(0x3, "EMPTY"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "UART0_M0"), /* UART0_RTS_N */
+		THUNDERBAY_MUX(0X1, "RT1_DSU_M1"), /* RT1_DSU_TSTOP */
+		THUNDERBAY_MUX(0X2, "EMPTY_M2"), /* EMPTY */
+		THUNDERBAY_MUX(0X3, "EMPTY_M3"), /* EMPTY */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(14, "GPIO14",
-		THUNDERBAY_MUX(0x0, "uart1_sout"),
-		THUNDERBAY_MUX(0x1, "rt2_dsu_active"),
-		THUNDERBAY_MUX(0x2, "EMPTY"),
-		THUNDERBAY_MUX(0x3, "trigger_out"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "UART1_M0"), /* UART1_SOUT */
+		THUNDERBAY_MUX(0X1, "RT2_DSU_M1"), /* RT2_DSU_ACTIVE */
+		THUNDERBAY_MUX(0X2, "EMPTY_M2"),  /* EMPTY */
+		THUNDERBAY_MUX(0X3, "TRIGGER_M3"), /* TRIGGER_OUT */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(15, "GPIO15",
-		THUNDERBAY_MUX(0x0, "uart1_sin"),
-		THUNDERBAY_MUX(0x1, "rt2_dsu_tstop"),
-		THUNDERBAY_MUX(0x2, "EMPTY"),
-		THUNDERBAY_MUX(0x3, "trigger_in"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "UART1_M0"), /* UART1_SIN */
+		THUNDERBAY_MUX(0X1, "RT2_DSU_M1"), /* RT2_DSU_TSTOP */
+		THUNDERBAY_MUX(0X2, "EMPTY_M2"), /* EMPTY */
+		THUNDERBAY_MUX(0X3, "TRIGGER_M3"), /* TRIGGER_IN */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(16, "GPIO16",
-		THUNDERBAY_MUX(0x0, "uart1_cts_n"),
-		THUNDERBAY_MUX(0x1, "rt3_dsu_active"),
-		THUNDERBAY_MUX(0x2, "EMPTY"),
-		THUNDERBAY_MUX(0x3, "EMPTY"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "UART1_M0"), /* UART1_CTS_N */
+		THUNDERBAY_MUX(0X1, "RT3_DSU_M1"), /* RT3_DSU_ACTIVE */
+		THUNDERBAY_MUX(0X2, "EMPTY_M2"), /* EMPTY */
+		THUNDERBAY_MUX(0X3, "EMPTY_M3"), /* EMPTY */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(17, "GPIO17",
-		THUNDERBAY_MUX(0x0, "uart1_rts_n"),
-		THUNDERBAY_MUX(0x1, "rt3_dsu_tstop"),
-		THUNDERBAY_MUX(0x2, "EMPTY"),
-		THUNDERBAY_MUX(0x3, "EMPTY"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "UART1_M0"), /* UART1_RTS_N */
+		THUNDERBAY_MUX(0X1, "RT3_DSU_M1"), /* RT3_DSU_TSTOP */
+		THUNDERBAY_MUX(0X2, "EMPTY_M2"), /* EMPTY */
+		THUNDERBAY_MUX(0X3, "EMPTY_M3"), /* EMPTY */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(18, "GPIO18",
-		THUNDERBAY_MUX(0x0, "spi0_sclk"),
-		THUNDERBAY_MUX(0x1, "EMPTY"),
-		THUNDERBAY_MUX(0x2, "EMPTY"),
-		THUNDERBAY_MUX(0x3, "EMPTY"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "SPI0_M0"),  /* SPI0_SCLK */
+		THUNDERBAY_MUX(0X1, "EMPTY_M1"), /* EMPTY */
+		THUNDERBAY_MUX(0X2, "EMPTY_M2"), /* EMPTY */
+		THUNDERBAY_MUX(0X3, "EMPTY_M3"), /* EMPTY */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(19, "GPIO19",
-		THUNDERBAY_MUX(0x0, "spi0_ss_0"),
-		THUNDERBAY_MUX(0x1, "EMPTY"),
-		THUNDERBAY_MUX(0x2, "EMPTY"),
-		THUNDERBAY_MUX(0x3, "EMPTY"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "SPI0_M0"),  /* SPI0_SS_0 */
+		THUNDERBAY_MUX(0X1, "EMPTY_M1"), /* EMPTY */
+		THUNDERBAY_MUX(0X2, "EMPTY_M2"), /* EMPTY */
+		THUNDERBAY_MUX(0X3, "EMPTY_M3"), /* EMPTY */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(20, "GPIO20",
-		THUNDERBAY_MUX(0x0, "spi0_dio_0_mosi"),
-		THUNDERBAY_MUX(0x1, "EMPTY"),
-		THUNDERBAY_MUX(0x2, "tpiu_traceclk"),
-		THUNDERBAY_MUX(0x3, "EMPTY"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "SPI0_M0"),  /* SPI0_DIO_0_MOSI */
+		THUNDERBAY_MUX(0X1, "EMPTY_M1"), /* EMPTY */
+		THUNDERBAY_MUX(0X2, "TPIU_TRACE_M2"), /* TPIU_TRACECLK */
+		THUNDERBAY_MUX(0X3, "EMPTY_M3"), /* EMPTY */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(21, "GPIO21",
-		THUNDERBAY_MUX(0x0, "spi0_dio_1_miso"),
-		THUNDERBAY_MUX(0x1, "EMPTY"),
-		THUNDERBAY_MUX(0x2, "tpiu_tracectl"),
-		THUNDERBAY_MUX(0x3, "EMPTY"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "SPI0_M0"),  /* SPI0_DIO_1_MISO */
+		THUNDERBAY_MUX(0X1, "EMPTY_M1"), /* EMPTY */
+		THUNDERBAY_MUX(0X2, "TPIU_TRACE_M2"), /* TPIU_TRACECTL */
+		THUNDERBAY_MUX(0X3, "EMPTY_M3"), /* EMPTY */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(22, "GPIO22",
-		THUNDERBAY_MUX(0x0, "spi1_sclk"),
-		THUNDERBAY_MUX(0x1, "EMPTY"),
-		THUNDERBAY_MUX(0x2, "EMPTY"),
-		THUNDERBAY_MUX(0x3, "EMPTY"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "SPI1_M0"),  /* SPI1_SCLK */
+		THUNDERBAY_MUX(0X1, "EMPTY_M0"), /* EMPTY */
+		THUNDERBAY_MUX(0X2, "EMPTY_M2"), /* EMPTY */
+		THUNDERBAY_MUX(0X3, "EMPTY_M3"), /* EMPTY */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(23, "GPIO23",
-		THUNDERBAY_MUX(0x0, "spi1_ss_0"),
-		THUNDERBAY_MUX(0x1, "EMPTY"),
-		THUNDERBAY_MUX(0x2, "EMPTY"),
-		THUNDERBAY_MUX(0x3, "EMPTY"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "SPI1_M0"),  /* SPI1_SS_0 */
+		THUNDERBAY_MUX(0X1, "EMPTY_M1"), /* EMPTY */
+		THUNDERBAY_MUX(0X2, "EMPTY_M2"), /* EMPTY */
+		THUNDERBAY_MUX(0X3, "EMPTY_M3"), /* EMPTY */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(24, "GPIO24",
-		THUNDERBAY_MUX(0x0, "spi1_dio_0_mosi"),
-		THUNDERBAY_MUX(0x1, "tpiu_traceclk"),
-		THUNDERBAY_MUX(0x2, "EMPTY"),
-		THUNDERBAY_MUX(0x3, "EMPTY"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "SPI1_M0"),  /* SPI1_DIO_0_MOSI */
+		THUNDERBAY_MUX(0X1, "TPIU_TRACE_M1"), /* TPIU_TRACECLK */
+		THUNDERBAY_MUX(0X2, "EMPTY_M2"), /* EMPTY */
+		THUNDERBAY_MUX(0X3, "EMPTY_M3"), /* EMPTY */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(25, "GPIO25",
-		THUNDERBAY_MUX(0x0, "spi1_dio_1_miso"),
-		THUNDERBAY_MUX(0x1, "tpiu_tracectl"),
-		THUNDERBAY_MUX(0x2, "EMPTY"),
-		THUNDERBAY_MUX(0x3, "EMPTY"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "SPI1_M0"),  /* SPI1_DIO_1_MISO */
+		THUNDERBAY_MUX(0X1, "TPIU_TRACE_M1"), /* TPIU_TRACECTL */
+		THUNDERBAY_MUX(0X2, "EMPTY_M2"), /* EMPTY */
+		THUNDERBAY_MUX(0X3, "EMPTY_M3"), /* EMPTY */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(26, "GPIO26",
-		THUNDERBAY_MUX(0x0, "ether0_phy_txen"),
-		THUNDERBAY_MUX(0x1, "tpiu_data0"),
-		THUNDERBAY_MUX(0x2, "tpiu_data16"),
-		THUNDERBAY_MUX(0x3, "debug_0"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "ETHER0_M0"), /* ETHER0_PHY_TXEN */
+		THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"), /* TPIU_DATA0 */
+		THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"), /* TPIU_DATA16 */
+		THUNDERBAY_MUX(0X3, "DEBUG_M3"),  /* DEBUG_0 */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(27, "GPIO27",
-		THUNDERBAY_MUX(0x0, "ether0_gmii_clk_tx"),
-		THUNDERBAY_MUX(0x1, "tpiu_data1"),
-		THUNDERBAY_MUX(0x2, "tpiu_data17"),
-		THUNDERBAY_MUX(0x3, "debug_1"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "ETHER0_M0"), /* ETHER0_GMII_CLK_TX */
+		THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"), /* TPIU_DATA1 */
+		THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"), /* TPIU_DATA17 */
+		THUNDERBAY_MUX(0X3, "DEBUG_M3"),  /* DEBUG_1 */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(28, "GPIO28",
-		THUNDERBAY_MUX(0x0, "ether0_phy_txd_0"),
-		THUNDERBAY_MUX(0x1, "tpiu_data2"),
-		THUNDERBAY_MUX(0x2, "tpiu_data18"),
-		THUNDERBAY_MUX(0x3, "debug_2"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "ETHER0_M0"), /* ETHER0_PHY_TXD_0 */
+		THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"),/* TPIU_DATA2 */
+		THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"), /* TPIU_DATA18 */
+		THUNDERBAY_MUX(0X3, "DEBUG_M3"), /* DEBUG_2 */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(29, "GPIO29",
-		THUNDERBAY_MUX(0x0, "ether0_phy_txd_1"),
-		THUNDERBAY_MUX(0x1, "tpiu_data3"),
-		THUNDERBAY_MUX(0x2, "tpiu_data19"),
-		THUNDERBAY_MUX(0x3, "debug_3"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "ETHER0_M0"), /* ETHER0_PHY_TXD_1 */
+		THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"), /* TPIU_DATA3 */
+		THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"), /* TPIU_DATA19 */
+		THUNDERBAY_MUX(0X3, "DEBUG_M3"), /* DEBUG_3 */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(30, "GPIO30",
-		THUNDERBAY_MUX(0x0, "ether0_phy_txd_2"),
-		THUNDERBAY_MUX(0x1, "tpiu_data4"),
-		THUNDERBAY_MUX(0x2, "tpiu_data20"),
-		THUNDERBAY_MUX(0x3, "debug_4"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "ETHER0_M0"), /* ETHER0_PHY_TXD_2 */
+		THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"), /* TPIU_DATA4 */
+		THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"), /* TPIU_DATA20 */
+		THUNDERBAY_MUX(0X3, "DEBUG_M3"), /* DEBUG_4 */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(31, "GPIO31",
-		THUNDERBAY_MUX(0x0, "ether0_phy_txd_3"),
-		THUNDERBAY_MUX(0x1, "tpiu_data5"),
-		THUNDERBAY_MUX(0x2, "tpiu_data21"),
-		THUNDERBAY_MUX(0x3, "debug_5"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "ETHER0_M0"), /* ETHER0_PHY_TXD_3 */
+		THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"), /* TPIU_DATA5 */
+		THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"), /* TPIU_DATA21 */
+		THUNDERBAY_MUX(0X3, "DEBUG_M3"), /* DEBUG_5 */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(32, "GPIO32",
-		THUNDERBAY_MUX(0x0, "ether0_phy_rxdv"),
-		THUNDERBAY_MUX(0x1, "tpiu_data6"),
-		THUNDERBAY_MUX(0x2, "tpiu_data22"),
-		THUNDERBAY_MUX(0x3, "debug_6"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "ETHER0_M0"), /* ETHER0_PHY_RXDV */
+		THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"), /* TPIU_DATA6 */
+		THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"), /* TPIU_DATA22 */
+		THUNDERBAY_MUX(0X3, "DEBUG_M3"), /* DEBUG_6 */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(33, "GPIO33",
-		THUNDERBAY_MUX(0x0, "ether0_gmii_clk_rx"),
-		THUNDERBAY_MUX(0x1, "tpiu_data7"),
-		THUNDERBAY_MUX(0x2, "tpiu_data23"),
-		THUNDERBAY_MUX(0x3, "debug_7"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "ETHER0_M0"), /* ETHER0_GMII_CLK_RX */
+		THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"), /* TPIU_DATA7 */
+		THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"), /* TPIU_DATA23 */
+		THUNDERBAY_MUX(0X3, "DEBUG_M3"), /* DEBUG_7 */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(34, "GPIO34",
-		THUNDERBAY_MUX(0x0, "ether0_phy_rxd_0"),
-		THUNDERBAY_MUX(0x1, "tpiu_data8"),
-		THUNDERBAY_MUX(0x2, "tpiu_data24"),
-		THUNDERBAY_MUX(0x3, "dig_view_0"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "ETHER0_M0"), /* ETHER0_PHY_RXD_0 */
+		THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"), /* TPIU_DATA8 */
+		THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"), /* TPIU_DATA24 */
+		THUNDERBAY_MUX(0X3, "DIG_VIEW_0"), /* DIG_VIEW_0 */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(35, "GPIO35",
-		THUNDERBAY_MUX(0x0, "ether0_phy_rxd_1"),
-		THUNDERBAY_MUX(0x1, "tpiu_data9"),
-		THUNDERBAY_MUX(0x2, "tpiu_data25"),
-		THUNDERBAY_MUX(0x3, "dig_view_1"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "ETHER0_M0"), /* ETHER0_PHY_RXD_1 */
+		THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"), /* TPIU_DATA9 */
+		THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"), /* TPIU_DATA25 */
+		THUNDERBAY_MUX(0X3, "DIG_VIEW_1"), /* DIG_VIEW_1 */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(36, "GPIO36",
-		THUNDERBAY_MUX(0x0, "ether0_phy_rxd_2"),
-		THUNDERBAY_MUX(0x1, "tpiu_data1"),
-		THUNDERBAY_MUX(0x2, "tpiu_data26"),
-		THUNDERBAY_MUX(0x3, "cpr_io_out_clk_0"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "ETHER0_M0"), /* ETHER0_PHY_RXD_2 */
+		THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"), /* TPIU_DATA10 */
+		THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"), /* TPIU_DATA26 */
+		THUNDERBAY_MUX(0X3, "CPR_IO_OUT_CLK_0"), /* CPR_IO_OUT_CLK_0 */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(37, "GPIO37",
-		THUNDERBAY_MUX(0x0, "ether0_phy_rxd_3"),
-		THUNDERBAY_MUX(0x1, "tpiu_data1"),
-		THUNDERBAY_MUX(0x2, "tpiu_data27"),
-		THUNDERBAY_MUX(0x3, "cpr_io_out_clk_1"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "ETHER0_M0"), /* ETHER0_PHY_RXD_3 */
+		THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"), /* TPIU_DATA11 */
+		THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"), /* TPIU_DATA27 */
+		THUNDERBAY_MUX(0X3, "CPR_IO_OUT_CLK_1"), /* CPR_IO_OUT_CLK_1 */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(38, "GPIO38",
-		THUNDERBAY_MUX(0x0, "ether0_gmii_mdc"),
-		THUNDERBAY_MUX(0x1, "tpiu_data1"),
-		THUNDERBAY_MUX(0x2, "tpiu_data28"),
-		THUNDERBAY_MUX(0x3, "cpr_io_out_clk_2"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "ETHER0_M0"), /* ETHER0_GMII_MDC */
+		THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"), /* TPIU_DATA12 */
+		THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"), /* TPIU_DATA28 */
+		THUNDERBAY_MUX(0X3, "CPR_IO_OUT_CLK_2"), /* CPR_IO_OUT_CLK_2 */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(39, "GPIO39",
-		THUNDERBAY_MUX(0x0, "ether0_gmii_mdio"),
-		THUNDERBAY_MUX(0x1, "tpiu_data1"),
-		THUNDERBAY_MUX(0x2, "tpiu_data29"),
-		THUNDERBAY_MUX(0x3, "cpr_io_out_clk_3"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "ETHER0_M0"), /* ETHER0_GMII_MDIO */
+		THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"), /* TPIU_DATA13 */
+		THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"), /* TPIU_DATA29 */
+		THUNDERBAY_MUX(0X3, "CPR_IO_OUT_CLK_3"), /* CPR_IO_OUT_CLK_3 */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(40, "GPIO40",
-		THUNDERBAY_MUX(0x0, "ether0_phy_intr"),
-		THUNDERBAY_MUX(0x1, "tpiu_data1"),
-		THUNDERBAY_MUX(0x2, "tpiu_data30"),
-		THUNDERBAY_MUX(0x3, "EMPTY"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "ETHER0_M0"), /* ETHER0_PHY_INTR */
+		THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"), /* TPIU_DATA14 */
+		THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"), /* TPIU_DATA30 */
+		THUNDERBAY_MUX(0X3, "EMPTY_M3"), /* EMPTY_M3 */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(41, "GPIO41",
-		THUNDERBAY_MUX(0x0, "power_interrupt_max_platform_power"),
-		THUNDERBAY_MUX(0x1, "tpiu_data1"),
-		THUNDERBAY_MUX(0x2, "tpiu_data31"),
-		THUNDERBAY_MUX(0x3, "EMPTY"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "POWER_INTERRUPT_MAX_PLATFORM_POWER_M0"),
+		/* POWER_INTERRUPT_MAX_PLATFORM_POWER */
+		THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"), /* TPIU_DATA15 */
+		THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"), /* TPIU_DATA31 */
+		THUNDERBAY_MUX(0X3, "EMPTY_M3"), /* EMPTY_M3 */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(42, "GPIO42",
-		THUNDERBAY_MUX(0x0, "ether1_phy_txen"),
-		THUNDERBAY_MUX(0x1, "tpiu_data1"),
-		THUNDERBAY_MUX(0x2, "tpiu_data0"),
-		THUNDERBAY_MUX(0x3, "debug_0"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "ETHER1_M0"), /* ETHER1_PHY_TXEN */
+		THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"), /* TPIU_DATA16 */
+		THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"), /* TPIU_DATA0 */
+		THUNDERBAY_MUX(0X3, "DEBUG_M3"), /* DEBUG_0 */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(43, "GPIO43",
-		THUNDERBAY_MUX(0x0, "ether1_gmii_clk_tx"),
-		THUNDERBAY_MUX(0x1, "tpiu_data1"),
-		THUNDERBAY_MUX(0x2, "tpiu_data1"),
-		THUNDERBAY_MUX(0x3, "debug_1"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "ETHER1_M0"), /* ETHER1_GMII_CLK_TX */
+		THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"), /* TPIU_DATA17 */
+		THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"), /* TPIU_DATA1 */
+		THUNDERBAY_MUX(0X3, "DEBUG_M3"), /* DEBUG_1 */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(44, "GPIO44",
-		THUNDERBAY_MUX(0x0, "ether1_phy_txd_0"),
-		THUNDERBAY_MUX(0x1, "tpiu_data1"),
-		THUNDERBAY_MUX(0x2, "tpiu_data2"),
-		THUNDERBAY_MUX(0x3, "debug_2"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "ETHER1_M0"), /* ETHER1_PHY_TXD_0 */
+		THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"), /* TPIU_DATA18 */
+		THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"), /* TPIU_DATA2 */
+		THUNDERBAY_MUX(0X3, "DEBUG_M3"), /* DEBUG_2 */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(45, "GPIO45",
-		THUNDERBAY_MUX(0x0, "ether1_phy_txd_1"),
-		THUNDERBAY_MUX(0x1, "tpiu_data1"),
-		THUNDERBAY_MUX(0x2, "tpiu_data3"),
-		THUNDERBAY_MUX(0x3, "debug_3"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "ETHER1_M0"), /* ETHER1_PHY_TXD_1 */
+		THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"), /* TPIU_DATA19 */
+		THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"), /* TPIU_DATA3 */
+		THUNDERBAY_MUX(0X3, "DEBUG_M3"), /* DEBUG_3 */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(46, "GPIO46",
-		THUNDERBAY_MUX(0x0, "ether1_phy_txd_2"),
-		THUNDERBAY_MUX(0x1, "tpiu_data2"),
-		THUNDERBAY_MUX(0x2, "tpiu_data4"),
-		THUNDERBAY_MUX(0x3, "debug_4"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "ETHER1_M0"), /* ETHER1_PHY_TXD_2 */
+		THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"), /* TPIU_DATA20 */
+		THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"), /* TPIU_DATA4 */
+		THUNDERBAY_MUX(0X3, "DEBUG_M3"), /* DEBUG_4 */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(47, "GPIO47",
-		THUNDERBAY_MUX(0x0, "ether1_phy_txd_3"),
-		THUNDERBAY_MUX(0x1, "tpiu_data2"),
-		THUNDERBAY_MUX(0x2, "tpiu_data5"),
-		THUNDERBAY_MUX(0x3, "debug_5"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "ETHER1_M0"), /* ETHER1_PHY_TXD_3 */
+		THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"), /* TPIU_DATA21 */
+		THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"), /* TPIU_DATA5 */
+		THUNDERBAY_MUX(0X3, "DEBUG_M3"), /* DEBUG_5 */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(48, "GPIO48",
-		THUNDERBAY_MUX(0x0, "ether1_phy_rxdv"),
-		THUNDERBAY_MUX(0x1, "tpiu_data2"),
-		THUNDERBAY_MUX(0x2, "tpiu_data6"),
-		THUNDERBAY_MUX(0x3, "debug_6"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "ETHER1_M0"), /* ETHER1_PHY_RXDV */
+		THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"), /* TPIU_DATA22 */
+		THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"), /* TPIU_DATA6 */
+		THUNDERBAY_MUX(0X3, "DEBUG_M3"), /* DEBUG_6 */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(49, "GPIO49",
-		THUNDERBAY_MUX(0x0, "ether1_gmii_clk_rx"),
-		THUNDERBAY_MUX(0x1, "tpiu_data2"),
-		THUNDERBAY_MUX(0x2, "tpiu_data7"),
-		THUNDERBAY_MUX(0x3, "debug_7"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "ETHER1_M0"), /* ETHER1_GMII_CLK_RX */
+		THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"), /* TPIU_DATA23 */
+		THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"), /* TPIU_DATA7 */
+		THUNDERBAY_MUX(0X3, "DEBUG_M3"), /* DEBUG_7 */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(50, "GPIO50",
-		THUNDERBAY_MUX(0x0, "ether1_phy_rxd_0"),
-		THUNDERBAY_MUX(0x1, "tpiu_data2"),
-		THUNDERBAY_MUX(0x2, "tpiu_data8"),
-		THUNDERBAY_MUX(0x3, "dig_view_0"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "ETHER1_M0"), /* ETHER1_PHY_RXD_0 */
+		THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"), /* TPIU_DATA24 */
+		THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"), /* TPIU_DATA8 */
+		THUNDERBAY_MUX(0X3, "DIG_VIEW_0"), /* DIG_VIEW_0 */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(51, "GPIO51",
-		THUNDERBAY_MUX(0x0, "ether1_phy_rxd_1"),
-		THUNDERBAY_MUX(0x1, "tpiu_data2"),
-		THUNDERBAY_MUX(0x2, "tpiu_data9"),
-		THUNDERBAY_MUX(0x3, "dig_view_1"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "ETHER1_M0"), /* ETHER1_PHY_RXD_1 */
+		THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"), /* TPIU_DATA25 */
+		THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"), /* TPIU_DATA9 */
+		THUNDERBAY_MUX(0X3, "DIG_VIEW_1"), /* DIG_VIEW_1 */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(52, "GPIO52",
-		THUNDERBAY_MUX(0x0, "ether1_phy_rxd_2"),
-		THUNDERBAY_MUX(0x1, "tpiu_data2"),
-		THUNDERBAY_MUX(0x2, "tpiu_data10"),
-		THUNDERBAY_MUX(0x3, "cpr_io_out_clk_0"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "ETHER1_M0"), /* ETHER1_PHY_RXD_2 */
+		THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"), /* TPIU_DATA26 */
+		THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"), /* TPIU_DATA10 */
+		THUNDERBAY_MUX(0X3, "CPR_IO_OUT_CLK_0"), /* CPR_IO_OUT_CLK_0 */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(53, "GPIO53",
-		THUNDERBAY_MUX(0x0, "ether1_phy_rxd_3"),
-		THUNDERBAY_MUX(0x1, "tpiu_data2"),
-		THUNDERBAY_MUX(0x2, "tpiu_data11"),
-		THUNDERBAY_MUX(0x3, "cpr_io_out_clk_1"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "ETHER1_M0"), /* ETHER1_PHY_RXD_3 */
+		THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"), /* TPIU_DATA27 */
+		THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"), /* TPIU_DATA11 */
+		THUNDERBAY_MUX(0X3, "CPR_IO_OUT_CLK_1"), /* CPR_IO_OUT_CLK_1 */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(54, "GPIO54",
-		THUNDERBAY_MUX(0x0, "ether1_gmii_mdc"),
-		THUNDERBAY_MUX(0x1, "tpiu_data2"),
-		THUNDERBAY_MUX(0x2, "tpiu_data12"),
-		THUNDERBAY_MUX(0x3, "cpr_io_out_clk_2"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "ETHER1_M0"), /* ETHER1_GMII_MDC */
+		THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"), /* TPIU_DATA28 */
+		THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"), /* TPIU_DATA12 */
+		THUNDERBAY_MUX(0X3, "CPR_IO_OUT_CLK_2"), /* CPR_IO_OUT_CLK_2 */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(55, "GPIO55",
-		THUNDERBAY_MUX(0x0, "ether1_gmii_mdio"),
-		THUNDERBAY_MUX(0x1, "tpiu_data2"),
-		THUNDERBAY_MUX(0x2, "tpiu_data13"),
-		THUNDERBAY_MUX(0x3, "cpr_io_out_clk_3"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "ETHER1_M0"), /* ETHER1_GMII_MDIO */
+		THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"), /* TPIU_DATA29 */
+		THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"), /* TPIU_DATA13 */
+		THUNDERBAY_MUX(0X3, "CPR_IO_OUT_CLK_3"), /* CPR_IO_OUT_CLK_3 */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(56, "GPIO56",
-		THUNDERBAY_MUX(0x0, "ether1_phy_intr"),
-		THUNDERBAY_MUX(0x1, "tpiu_data3"),
-		THUNDERBAY_MUX(0x2, "tpiu_data14"),
-		THUNDERBAY_MUX(0x3, "power_interrupt_iccmax_vddd"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "ETHER1_M0"), /* ETHER1_PHY_INTR */
+		THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"), /* TPIU_DATA30 */
+		THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"), /* TPIU_DATA14 */
+		THUNDERBAY_MUX(0X3, "POWER_INTERRUPT_ICCMAX_VDDD_M3"),
+		/* POWER_INTERRUPT_ICCMAX_VDDD */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(57, "GPIO57",
-		THUNDERBAY_MUX(0x0, "power_interrupt_iccmax_vpu"),
-		THUNDERBAY_MUX(0x1, "tpiu_data3"),
-		THUNDERBAY_MUX(0x2, "tpiu_data15"),
-		THUNDERBAY_MUX(0x3, "EMPTY"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "POWER_INTERRUPT_ICCMAX_VPU_M0"),
+		/* POWER_INTERRUPT_ICCMAX_VPU */
+		THUNDERBAY_MUX(0X1, "TPIU_DATA_M1"), /* TPIU_DATA31 */
+		THUNDERBAY_MUX(0X2, "TPIU_DATA_M2"), /* TPIU_DATA15 */
+		THUNDERBAY_MUX(0X3, "EMPTY_M3"), /* EMPTY_M3 */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(58, "GPIO58",
-		THUNDERBAY_MUX(0x0, "thermtrip_in"),
-		THUNDERBAY_MUX(0x1, "EMPTY"),
-		THUNDERBAY_MUX(0x2, "EMPTY"),
-		THUNDERBAY_MUX(0x3, "EMPTY"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "THERMTRIP_M0"), /* THERMTRIP_IN */
+		THUNDERBAY_MUX(0X1, "EMPTY_M1"), /* EMPTY */
+		THUNDERBAY_MUX(0X2, "EMPTY_M2"), /* EMPTY */
+		THUNDERBAY_MUX(0X3, "EMPTY_M3"), /* EMPTY */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(59, "GPIO59",
-		THUNDERBAY_MUX(0x0, "thermtrip_out"),
-		THUNDERBAY_MUX(0x1, "EMPTY"),
-		THUNDERBAY_MUX(0x2, "EMPTY"),
-		THUNDERBAY_MUX(0x3, "EMPTY"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "THERMTRIP_M0"), /* THERMTRIP_OUT */
+		THUNDERBAY_MUX(0X1, "EMPTY_M1"), /* EMPTY */
+		THUNDERBAY_MUX(0X2, "EMPTY_M2"), /* EMPTY */
+		THUNDERBAY_MUX(0X3, "EMPTY_M3"), /* EMPTY */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(60, "GPIO60",
-		THUNDERBAY_MUX(0x0, "smbus_scl"),
-		THUNDERBAY_MUX(0x1, "EMPTY"),
-		THUNDERBAY_MUX(0x2, "EMPTY"),
-		THUNDERBAY_MUX(0x3, "EMPTY"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "SMBUS_M0"), /* SMBUS_SCL */
+		THUNDERBAY_MUX(0X1, "EMPTY_M1"), /* EMPTY */
+		THUNDERBAY_MUX(0X2, "EMPTY_M2"), /* EMPTY */
+		THUNDERBAY_MUX(0X3, "EMPTY_M3"), /* EMPTY */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(61, "GPIO61",
-		THUNDERBAY_MUX(0x0, "smbus_sda"),
-		THUNDERBAY_MUX(0x1, "EMPTY"),
-		THUNDERBAY_MUX(0x2, "EMPTY"),
-		THUNDERBAY_MUX(0x3, "power_interrupt_iccmax_vddd"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "SMBUS_M0"), /* SMBUS_SDA */
+		THUNDERBAY_MUX(0X1, "EMPTY_M1"), /* EMPTY */
+		THUNDERBAY_MUX(0X2, "EMPTY_M2"), /* EMPTY */
+		THUNDERBAY_MUX(0X3, "POWER_INTERRUPT_ICCMAX_VDDD_M3"),
+		/* POWER_INTERRUPT_ICCMAX_VDDD */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(62, "GPIO62",
-		THUNDERBAY_MUX(0x0, "platform_reset_in"),
-		THUNDERBAY_MUX(0x1, "EMPTY"),
-		THUNDERBAY_MUX(0x2, "EMPTY"),
-		THUNDERBAY_MUX(0x3, "EMPTY"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "PLATFORM_RESET_M0"), /* PLATFORM_RESET_IN */
+		THUNDERBAY_MUX(0X1, "EMPTY_M1"), /* EMPTY */
+		THUNDERBAY_MUX(0X2, "EMPTY_M2"), /* EMPTY */
+		THUNDERBAY_MUX(0X3, "EMPTY_M3"), /* EMPTY */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(63, "GPIO63",
-		THUNDERBAY_MUX(0x0, "platform_reset_out"),
-		THUNDERBAY_MUX(0x1, "EMPTY"),
-		THUNDERBAY_MUX(0x2, "EMPTY"),
-		THUNDERBAY_MUX(0x3, "EMPTY"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "PLATFORM_RESET_M0"), /* PLATFORM_RESET_OUT */
+		THUNDERBAY_MUX(0X1, "EMPTY_M1"), /* EMPTY */
+		THUNDERBAY_MUX(0X2, "EMPTY_M2"), /* EMPTY */
+		THUNDERBAY_MUX(0X3, "EMPTY_M3"), /* EMPTY */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(64, "GPIO64",
-		THUNDERBAY_MUX(0x0, "platform_shutdown_in"),
-		THUNDERBAY_MUX(0x1, "EMPTY"),
-		THUNDERBAY_MUX(0x2, "EMPTY"),
-		THUNDERBAY_MUX(0x3, "EMPTY"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "PLATFORM_SHUTDOWN_M0"), /* PLATFORM_SHUTDOWN_IN */
+		THUNDERBAY_MUX(0X1, "EMPTY_M1"), /* EMPTY */
+		THUNDERBAY_MUX(0X2, "EMPTY_M2"), /* EMPTY */
+		THUNDERBAY_MUX(0X3, "EMPTY_M3"), /* EMPTY */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(65, "GPIO65",
-		THUNDERBAY_MUX(0x0, "platform_shutdown_out"),
-		THUNDERBAY_MUX(0x1, "EMPTY"),
-		THUNDERBAY_MUX(0x2, "EMPTY"),
-		THUNDERBAY_MUX(0x3, "EMPTY"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "PLATFORM_SHUTDOWN_M0"), /* PLATFORM_SHUTDOWN_OUT */
+		THUNDERBAY_MUX(0X1, "EMPTY_M1"), /* EMPTY */
+		THUNDERBAY_MUX(0X2, "EMPTY_M2"), /* EMPTY */
+		THUNDERBAY_MUX(0X3, "EMPTY_M3"), /* EMPTY */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 	THUNDERBAY_PIN_DESC(66, "GPIO66",
-		THUNDERBAY_MUX(0x0, "power_interrupt_iccmax_media"),
-		THUNDERBAY_MUX(0x1, "EMPTY"),
-		THUNDERBAY_MUX(0x2, "EMPTY"),
-		THUNDERBAY_MUX(0x3, "EMPTY"),
-		THUNDERBAY_MUX(0x4, "CPU_DIRECT_CONTROL")),
+		THUNDERBAY_MUX(0X0, "POWER_INTERRUPT_ICCMAX_MEDIA_M0"),
+		/* POWER_INTERRUPT_ICCMAX_MEDIA */
+		THUNDERBAY_MUX(0X1, "EMPTY_M1"), /* EMPTY */
+		THUNDERBAY_MUX(0X2, "EMPTY_M2"), /* EMPTY */
+		THUNDERBAY_MUX(0X3, "EMPTY_M3"), /* EMPTY */
+		THUNDERBAY_MUX(0X4, "GPIO_M4")), /* CPU_DIRECT_CONTROL */
 };
 
+/************************************************************************************/
 static const struct thunderbay_pin_soc thunderbay_data = {
 	.pins	= thunderbay_pins,
 	.npins  = ARRAY_SIZE(thunderbay_pins),
 };
 
+/************************************************************************************/
 
-/*******************************************************************************/
-
-/* GPIO register read */
+/***************************************************************************************
+ * Private functions
+ *******************************************************************************/
+
+/*******************************************************************************
+ * Function name: thb_gpio_read_reg
+ * Description: Reads gpio configuration register
+ * Arg[0]: thunderbay specific gpio_chip structure address
+ * Arg[1]: pin number (0-66)
+ * Return value: gpio configuration register value
+ *******************************************************************************/
 static u32 thb_gpio_read_reg(struct gpio_chip *chip, unsigned int pinnr)
 {
 	struct thunderbay_pinctrl *tpc = gpiochip_get_data(chip);
@@ -457,7 +474,14 @@ static u32 thb_gpio_read_reg(struct gpio_chip *chip, unsigned int pinnr)
 	return readl(tpc->base0 + THB_GPIO_REG_OFFSET(pinnr));
 }
 
-/* GPIO register write */
+/*******************************************************************************
+ * Function name: thb_gpio_write_reg
+ * Description: Writes/updates gpio configuration register
+ * Arg[0]: thunderbay specific gpio_chip structure address
+ * Arg[1]: pin number (0-66)
+ * ARg[2]: Value to be updated in register
+ * Return value: 0u for success/ Negative value for failure
+ *******************************************************************************/
 static u32 thb_gpio_write_reg(struct gpio_chip *chip, unsigned int pinnr, u32 value)
 {
 	struct thunderbay_pinctrl *tpc = gpiochip_get_data(chip);
@@ -467,12 +491,14 @@ static u32 thb_gpio_write_reg(struct gpio_chip *chip, unsigned int pinnr, u32 va
 	return 0;
 }
 
-/*
- * Read GPIO DATA registers:
- * GPIO_DATA_OUT, GPIO_DATA_IN,
- * GPIO_DATA_LOW, GPIO_DATA_HIGH,
- * pad_dir: 1-in; 0-out
- */
+/*******************************************************************************
+ * Function name: thb_read_gpio_data
+ * Description: Reads GPIO Data IN/OUT register
+ * Arg[0]: thunderbay specific gpio_chip structure address
+ * Arg[1]: pin number (0-66)
+ * ARg[2]: gpio pad direction (0-in; 1-out)
+ * Return value: GPIO Data IN/OUT register value
+ *******************************************************************************/
 static int thb_read_gpio_data(struct gpio_chip *chip, unsigned int offset, unsigned int pad_dir)
 {
 	int ret_val = -EINVAL;
@@ -480,8 +506,7 @@ static int thb_read_gpio_data(struct gpio_chip *chip, unsigned int offset, unsig
 	u32 data_reg;
 
 	/* as per GPIO Spec = pad_dir 0:input, 1:output */
-	data_offset = ((pad_dir == 0u) ? (data_offset + 0x4 + (offset/32))
-							: (data_offset + (offset/32)));
+	data_offset = ((pad_dir == 0u)?(data_offset+0x4+(offset/32)):(data_offset+(offset/32)));
 
 	data_reg = thb_gpio_read_reg(chip, data_offset);
 
@@ -490,11 +515,14 @@ static int thb_read_gpio_data(struct gpio_chip *chip, unsigned int offset, unsig
 	return ret_val;
 }
 
-/* Write GPIO DATA Registers:
- * GPIO_DATA_OUT,
- * GPIO_DATA_LOW, GPIO_DATA_HIGH,
- */
-
+/*******************************************************************************
+ * Function name: thb_write_gpio_data
+ * Description: writes/updates GPIO Data IN/OUT register
+ * Arg[0]: thunderbay specific gpio_chip structure address
+ * Arg[1]: pin number (0-66)
+ * ARg[2]: Value to be updated in register
+ * Return value: 0u for success/Negative value for failure
+ *******************************************************************************/
 static int thb_write_gpio_data(struct gpio_chip *chip, unsigned int offset, unsigned int value)
 {
 	int ret_val = -EINVAL;
@@ -507,21 +535,239 @@ static int thb_write_gpio_data(struct gpio_chip *chip, unsigned int offset, unsi
 
 	data_reg = thb_gpio_read_reg(chip, data_offset);
 
-	data_reg = ((value > 0u) ? (data_reg|BIT(offset % 32))
-							: (data_reg & (~(BIT(offset % 32)))));
+	data_reg = ((value > 0u)?(data_reg|BIT(offset%32)):(data_reg&(~(BIT(offset % 32)))));
 
 	ret_val = thb_gpio_write_reg(chip, data_offset, data_reg);
 
 	return ret_val;
 }
 
-/*******************************************************************************/
+#if (THB_BOARD_SPECIFIC_GPIO_REQUIREMENTS_HANDLE)
 
+/*******************************************************************************
+ * Function name: thb_gpio_board_requirements_handle
+ * Description: updates required configurations based on THB Board need.
+ * Arg[0]: thunderbay specific gpio_chip structure address
+ * Return value: 0 - success / negative value for any error
+ *******************************************************************************/
 
+static u32 thb_gpio_board_requirements_handle(struct gpio_chip *chip)
+{
+	u32 offset, reg = 0u;
+	int ret_val = -EINVAL;
 
-/*
- * Update PIN configuration from PORT to GPIO
+	/* 0x43 = register Offset for gpio_power_int_setup/4u */
+	offset = 0x43;
+	reg = thb_gpio_read_reg(chip, offset);
+
+	/* Keeping all power interrupts to Level-High triggered as suggested by HW team */
+	reg |= 0x1E;
+	ret_val = thb_gpio_write_reg(chip, offset, reg);
+
+	return ret_val;
+}
+
+#endif
+
+/*************************************************************************************/
+
+/***********************************************************************************
+ * THB - GPIO Driver : Call back functions
+ ********************************************************************************/
+
+/*******************************************************************************
+ * Function name: thunderbay_gpio_get_direction
+ * Description: provides GPIO pad direction
+ * Arg[0]: thunderbay specific gpio_chip structure address
+ * Arg[1]: pin number (0-66)
+ * Return value: If pin is configured as GPIO : Return GPIO Pad direction
+ *               If pin is configured as PORT : Return Negative error
+ *******************************************************************************/
+static int thunderbay_gpio_get_direction(struct gpio_chip *chip, unsigned int offset)
+{
+	int ret_val = -EINVAL;
+
+	u32 reg = thb_gpio_read_reg(chip, offset);
+
+	/* Return direction only if configured as GPIO else negative error */
+	if (reg & THB_GPIO_PORT_SELECT_MASK)
+		ret_val = ((reg & THB_GPIO_PAD_DIRECTION_MASK) == 0) ? 1 : 0;
+
+	return ret_val;
+}
+
+/*******************************************************************************
+ * Function name: thunderbay_gpio_set_direction_input
+ * Description: update GPIO pad direction as INPUT
+ * Arg[0]: thunderbay specific gpio_chip structure address
+ * Arg[1]: pin number (0-66)
+ * Return value: If pin is configured as GPIO : Return 0u
+ *               If pin is configured as PORT : Negative error
+ *******************************************************************************/
+static int thunderbay_gpio_set_direction_input(struct gpio_chip *chip, unsigned int offset)
+{
+	int ret_val = -EINVAL;
+
+	u32 reg = thb_gpio_read_reg(chip, offset);
+
+	/* set pin as input only if it is GPIO else error */
+	if (reg & THB_GPIO_PORT_SELECT_MASK) {
+		reg &= (~THB_GPIO_PAD_DIRECTION_MASK);
+
+		thb_gpio_write_reg(chip, offset, reg);
+
+		ret_val = 0;
+	}
+
+	return ret_val;
+}
+
+/*******************************************************************************
+ * Function name: thunderbay_gpio_set_value
+ * Description: update GPIO DATA OUT value
+ * Arg[0]: thunderbay specific gpio_chip structure address
+ * Arg[1]: pin number (0-66)
+ * Arg[2]: output value (0/1)
+ * Return value: void
+ *******************************************************************************/
+static void thunderbay_gpio_set_value(struct gpio_chip *chip, unsigned int offset, int value)
+{
+	int ret_val = -EINVAL;
+
+	u32 reg = thb_gpio_read_reg(chip, offset);
+
+	/* update pin value only if it is GPIO-output else error */
+	if ((reg & THB_GPIO_PORT_SELECT_MASK) && (reg & THB_GPIO_PAD_DIRECTION_MASK))
+		ret_val = thb_write_gpio_data(chip, offset, value);
+}
+
+/*******************************************************************************
+ * Function name: thunderbay_gpio_set_direction_output
+ * Description: update GPIO pad direction as output and its value
+ * Arg[0]: thunderbay specific gpio_chip structure address
+ * Arg[1]: pin number (0-66)
+ * Arg[2]: output value (0/1)
+ * Return value: If pin is configured as GPIO : Return 0u
+ *               If pin is configured as PORT : Negative error
+ *******************************************************************************/
+static int thunderbay_gpio_set_direction_output(struct gpio_chip *chip,
+						unsigned int offset, int value)
+{
+	int ret_val = -EINVAL;
+
+	u32 reg = thb_gpio_read_reg(chip, offset);
+
+	/* set pin as output only if it is GPIO else error */
+	if (reg & THB_GPIO_PORT_SELECT_MASK) {
+		reg |= THB_GPIO_PAD_DIRECTION_MASK;
+
+		thb_gpio_write_reg(chip, offset, reg);
+
+		thunderbay_gpio_set_value(chip, offset, value);
+
+		ret_val = 0;
+	}
+
+	return ret_val;
+}
+
+/*******************************************************************************
+ * Function name: thunderbay_gpio_get_value
+ * Description: provides GPIO DATA OUT/IN value
+ * Arg[0]: thunderbay specific gpio_chip structure address
+ * Arg[1]: pin number (0-66)
+ * Return value: If pin is configured as GPIO : Return GPIO DATA OUT/IN value (0/1)
+ *               If pin is configured as PORT : Return Negative error
+ *******************************************************************************/
+static int thunderbay_gpio_get_value(struct gpio_chip *chip, unsigned int offset)
+{
+	int ret_val = -EINVAL;
+	int gpio_dir = 0;
+
+	u32 reg = thb_gpio_read_reg(chip, offset);
+
+	/* Read pin value only if it is GPIO else error */
+	if (reg & THB_GPIO_PORT_SELECT_MASK) {
+		/* 0=in, 1=out */
+		gpio_dir = ((reg & THB_GPIO_PAD_DIRECTION_MASK) > 0) ? 1 : 0;
+
+		ret_val = thb_read_gpio_data(chip, offset, gpio_dir);
+	}
+
+	return ret_val;
+}
+
+/*******************************************************************************/
+
+/*******************************************************************************
+ * Function name: thunderbay_gpiochip_probe
+ * Description: gpio probe/init function to register THB gpio chip and
+ *              required call back functions with standard linux frame work.
+ * Arg[0]: thunderbay GPIO specific structure address
+ * Return value: 0u -> success / Negative value for any failure
+ *******************************************************************************/
+static int thunderbay_gpiochip_probe(struct thunderbay_pinctrl *tpc)
+{
+	struct gpio_chip *chip = &tpc->chip;
+	int ret;
+
+	chip->label		= dev_name(tpc->dev);
+	chip->parent		= tpc->dev;
+	chip->request		= gpiochip_generic_request;
+	chip->free		= gpiochip_generic_free;
+	chip->get_direction	= thunderbay_gpio_get_direction;
+	chip->direction_input	= thunderbay_gpio_set_direction_input;
+	chip->direction_output  = thunderbay_gpio_set_direction_output;
+	chip->get		= thunderbay_gpio_get_value;
+	chip->set               = thunderbay_gpio_set_value;
+/* identifies the first GPIO number handled by this chip; or,
+ * if negative during registration, requests dynamic ID allocation.
+ * DEPRECATION: providing anything non-negative and nailing the
+ * base offset of GPIO chips is deprecated.
+ * Please pass -1 as base to let gpiolib select the chip base in all possible cases.
+ * We want to get rid of the static GPIO number space in the long run.
  */
+	chip->base		= -1;
+/* the number of GPIOs handled by this controller; the last GPIO handled is (base + ngpio - 1).*/
+	chip->ngpio		= THB_MAX_NPINS_SUPPORTED;
+
+	/* Register/add thb gpio chip with linux framework */
+	ret = gpiochip_add_data(chip, tpc);
+	if (ret) {
+		dev_err(tpc->dev, "Failed to add gpiochip\n");
+		return ret;
+	}
+
+	/* Register pin mapping between GPIO and PinControl */
+	ret = gpiochip_add_pin_range(chip, dev_name(tpc->dev), 0, 0, chip->ngpio);
+	if (ret) {
+		dev_err(tpc->dev, "Failed to add gpiochip pin range\n");
+		return ret;
+	}
+
+#if (THB_BOARD_SPECIFIC_GPIO_REQUIREMENTS_HANDLE)
+	/* function to handle THB board specific requirements */
+	ret = thb_gpio_board_requirements_handle(chip);
+#endif
+
+	return ret;
+}
+
+/***************************************************************************************/
+
+/************************************************************************************
+ * THB - PinCtrl Driver - PinMux : Call back functions
+ ********************************************************************************/
+
+/*******************************************************************************
+ * Function name: thunderbay_request_gpio
+ * Description: updates pin status as busy and keep pin in mode-4 (GPIO operation)
+ * Arg[0]: thunderbay specific pinctrl_dev structure address
+ * Arg[1]: pin range
+ * Arg[2]: pin number (0-66)
+ * Return value: 0u - for Success,
+ *               Negative value for any error.
+ *******************************************************************************/
 static int thunderbay_request_gpio(struct pinctrl_dev *pctldev,
 				struct pinctrl_gpio_range *range,
 				unsigned int pin)
@@ -537,26 +783,38 @@ static int thunderbay_request_gpio(struct pinctrl_dev *pctldev,
 
 	struct gpio_chip *chip = &tpc->chip;
 
-	reg = thb_gpio_read_reg(chip, pin);
 
-	/* Updates PIN configuration from PORT to GPIO */
-	/* SW WA to set the GPIO to MODE-4 */
-	reg |= (THB_GPIO_PORT_SELECT_MASK | THB_GPIO_DIRECT_CONTROL_MODE_4);
+	if (thb_pinx_status[pin] == 0u) {
+		reg = thb_gpio_read_reg(chip, pin);
+		/* Updates PIN configuration as GPIO */
+		/* set the GPIO to MODE-4 */
+		reg |= (THB_GPIO_PORT_SELECT_MASK | THB_GPIO_PINMUX_MODE_4);
 
 	ret_val = thb_gpio_write_reg(chip, pin, reg);
 
+		if (~ret_val) {
+			/* update pin status as busy */
+			thb_pinx_status[pin] = 1u;
+		}
+	}
+
 	return ret_val;
 
 }
 
-/*
- * Updates PIN configuration from GPIO to PORT/default mode
- */
+/*******************************************************************************
+ * Function name: thunderbay_free_gpio
+ * Description: updates pin status as free and keep pin in mode-0 (default mode/Port function)
+ * Arg[0]: thunderbay specific pinctrl_dev structure address
+ * Arg[1]: pin range
+ * Arg[2]: pin number (0-66)
+ * Return value: 0u - for Success,
+ *               Negative value for any error.
+ *******************************************************************************/
 static void thunderbay_free_gpio(struct pinctrl_dev *pctldev,
 				struct pinctrl_gpio_range *range,
 				unsigned int pin)
 {
-	/* TODO: Proper usecase to be verified for conditions check */
 	int ret_val = -EINVAL;
 
 	u32 reg = 0;
@@ -565,17 +823,270 @@ static void thunderbay_free_gpio(struct pinctrl_dev *pctldev,
 
 	struct gpio_chip *chip = &tpc->chip;
 
-	reg = thb_gpio_read_reg(chip, pin);
+	if (thb_pinx_status[pin] == 1u) {
+		reg = thb_gpio_read_reg(chip, pin);
+
+		/* Updates PIN configuration from GPIO to PORT */
+		reg &= (~THB_GPIO_PORT_SELECT_MASK);
 
-	/* Updates PIN configuration from GPIO to PORT */
-	reg &= (~THB_GPIO_PORT_SELECT_MASK);
-	/* Change Port/gpio mode to default mode-0 */
-	reg &= (~THB_GPIO_DIRECT_CONTROL_MODE_4);
-	ret_val = thb_gpio_write_reg(chip, pin, reg);
 
+		/* Change Port/gpio mode to default mode-0 */
+		reg &= (~THB_GPIO_PINMUX_MODE_4);
+
+		ret_val = thb_gpio_write_reg(chip, pin, reg);
+
+		if (~ret_val) {
+			/* update pin status as free */
+			thb_pinx_status[pin] = 0u;
+		}
+	}
 }
 
 /*******************************************************************************************/
+/*******************************************************************************
+ * Function name: thb_pinctrl_set_mux
+ * Description: Configures pin for required port function/pin mux
+ * Arg[0]: thunderbay specific pinctrl_dev structure address
+ * Arg[1]: mux function selector
+ * Arg[2]: mux group selector
+ * Return value: 0u - for Success,
+ *               Negative value for any error.
+ *******************************************************************************/
+static int thb_pinctrl_set_mux(struct pinctrl_dev *pctldev,
+				unsigned int func_select, unsigned int group_select)
+{
+	u32 reg = 0u;
+	unsigned int i, pin_mode;
+	int ret_val = -EINVAL;
+
+	struct thunderbay_pinctrl *tpc = pinctrl_dev_get_drvdata(pctldev);
+	struct gpio_chip *chip = &tpc->chip;
+	struct group_desc *group;
+	struct function_desc *function;
+
+	group = pinctrl_generic_get_group(pctldev, group_select);
+	if (!group)
+		return -EINVAL;
+
+	function = pinmux_generic_get_function(pctldev, func_select);
+	if (!function)
+		return -EINVAL;
+
+	pin_mode = *(unsigned int *)(function->data);
+
+	/* Change modes for pins in the selected group */
+	for (i = 0; i < group->num_pins; i++) {
+		reg = thb_gpio_read_reg(chip, group->pins[i]);
+
+		switch (pin_mode) {
+		case 0u:
+			reg |= THB_GPIO_PINMUX_MODE_0;
+			break;
+		case 1u:
+			reg |= THB_GPIO_PINMUX_MODE_1;
+			break;
+		case 2u:
+			reg |= THB_GPIO_PINMUX_MODE_2;
+			break;
+		case 3u:
+			reg |= THB_GPIO_PINMUX_MODE_3;
+			break;
+		case 4u:
+			reg |= THB_GPIO_PINMUX_MODE_4;
+			break;
+		default:
+			return -EINVAL;
+		}
+
+		ret_val = thb_gpio_write_reg(chip, group->pins[i], reg);
+
+		if (~ret_val) {
+			/* update pin status as busy */
+			thb_pinx_status[group->pins[i]] = 1u;
+		}
+	}
+
+	return ret_val;
+}
+
+/*******************************************************************************
+ * Function name: thunderbay_build_groups
+ * Description: add group of pins to support port function with generic framework
+ * Arg[0]: thunderbay specific pinctrl_dev structure address
+ * Return value: 0u - for Success,
+ *               Negative value for any error.
+ *******************************************************************************/
+static int thunderbay_build_groups(struct thunderbay_pinctrl *tpc)
+{
+	int i;
+	struct group_desc *thunderbay_groups;
+
+	tpc->ngroups = tpc->soc->npins;
+	thunderbay_groups = devm_kcalloc(tpc->dev, tpc->ngroups,
+					sizeof(*thunderbay_groups), GFP_KERNEL);
+	if (!thunderbay_groups)
+		return -ENOMEM;
+
+	for (i = 0; i < tpc->ngroups; i++) {
+		struct group_desc *group = thunderbay_groups + i;
+		const struct pinctrl_pin_desc *pin_info = thunderbay_pins + i;
+
+		group->name = pin_info->name;
+		group->pins = (int *)&pin_info->number;
+		pinctrl_generic_add_group(tpc->pctrl, group->name,
+						group->pins, 1, NULL);
+	}
+
+	return 0;
+}
+
+/*******************************************************************************
+ * Function name: thunderbay_add_functions
+ * Description: add group of functions supported with generic framework
+ * Arg[0]: thunderbay specific pinctrl_dev structure address
+ * Return value: 0u - for Success,
+ *               Negative value for any error.
+ *******************************************************************************/
+static int thunderbay_add_functions(struct thunderbay_pinctrl *tpc, struct function_desc *funcs)
+{
+	int i;
+	struct function_desc *function = funcs;
+
+	/* Assign the groups for each function */
+	for (i = 0; i < tpc->soc->npins; i++) {
+		const struct pinctrl_pin_desc *pin_info = thunderbay_pins + i;
+		struct thunderbay_mux_desc *pin_mux = pin_info->drv_data;
+
+		while (pin_mux->name) {
+			const char **grp;
+			int j, grp_num, match = 0;
+			size_t grp_size;
+			struct function_desc *func;
+
+			for (j = 0; j < tpc->nfuncs; j++) {
+				if (!strcmp(pin_mux->name, function[j].name)) {
+					match = 1;
+					break;
+				}
+			}
+
+			if (!match)
+				return -EINVAL;
+
+			func = function + j;
+			grp_num = func->num_group_names;
+			grp_size = sizeof(*func->group_names);
+
+			if (!func->group_names) {
+				func->group_names = devm_kcalloc(tpc->dev,
+								grp_num,
+								grp_size,
+								GFP_KERNEL);
+				if (!func->group_names) {
+					kfree(func);
+					return -ENOMEM;
+				}
+			}
+
+			grp = func->group_names;
+			while (*grp)
+				grp++;
+
+			*grp = pin_info->name;
+			pin_mux++;
+		}
+	}
+
+	/* Add all functions */
+	for (i = 0; i < tpc->nfuncs; i++) {
+		pinmux_generic_add_function(tpc->pctrl,
+						function[i].name,
+						function[i].group_names,
+						function[i].num_group_names,
+						function[i].data);
+	}
+
+	return 0;
+}
+
+/*******************************************************************************
+ * Function name: thunderbay_build_functions
+ * Description: add group of functions supported with generic framework
+ * Arg[0]: thunderbay specific thunderbay_pinctrl structure address
+ * Return value: 0u - for Success,
+ *               Negative value for any error.
+ *******************************************************************************/
+static int thunderbay_build_functions(struct thunderbay_pinctrl *tpc)
+{
+	int i, err;
+	void *ptr;
+	struct function_desc *thunderbay_funcs;
+
+	/* Total number of functions is unknown at this point. Allocate first. */
+	tpc->nfuncs = 0;
+	thunderbay_funcs = kcalloc(tpc->soc->npins * 8,
+				sizeof(*thunderbay_funcs), GFP_KERNEL);
+	if (!thunderbay_funcs)
+		return -ENOMEM;
+
+	/* Find total number of functions and each's properties */
+	for (i = 0; i < tpc->soc->npins; i++) {
+		const struct pinctrl_pin_desc *pin_info = thunderbay_pins + i;
+		struct thunderbay_mux_desc *pin_mux = pin_info->drv_data;
+
+		while (pin_mux->name) {
+			struct function_desc *func = thunderbay_funcs;
+
+			while (func->name) {
+				if (!strcmp(pin_mux->name, func->name)) {
+					func->num_group_names++;
+					break;
+				}
+
+				func++;
+			}
+
+			if (!func->name) {
+				func->name = pin_mux->name;
+				func->num_group_names = 1;
+				func->data = (int *)&pin_mux->mode;
+				tpc->nfuncs++;
+			}
+
+			pin_mux++;
+		}
+	}
+
+	/* Reallocate memory based on actual number of functions */
+	ptr = krealloc(thunderbay_funcs,
+				tpc->nfuncs * sizeof(*thunderbay_funcs),
+				GFP_KERNEL);
+	if (!ptr)
+		return -ENOMEM;
+
+	thunderbay_funcs = ptr;
+
+	err = thunderbay_add_functions(tpc, thunderbay_funcs);
+	if (err)
+		return -ENOMEM;
+
+	return 0;
+}
+/*********************************************************************************************/
+
+/***********************************************************************************
+ * THB - PinCtrl Driver - PinConfig : Call back functions
+ ************************************************************************************/
+
+/*******************************************************************************
+ * Function name: thunderbay_pinconf_set_tristate
+ * Description: set pin to tri-state
+ * Arg[0]: thunderbay specific structure thunderbay_pinctrl address
+ * Arg[1]: pin number
+ * Arg[2]: required pin configuration
+ * Return value: 0u - for Success,
+ *               Negative value for any error.
+ *******************************************************************************/
 
 static int thunderbay_pinconf_set_tristate(struct thunderbay_pinctrl *tpc,
 				unsigned int pin, u32 config)
@@ -598,6 +1109,15 @@ static int thunderbay_pinconf_set_tristate(struct thunderbay_pinctrl *tpc,
 	return ret_val;
 }
 
+/*******************************************************************************
+ * Function name: thunderbay_pinconf_get_tristate
+ * Description: provides pin tri-state status
+ * Arg[0]: thunderbay specific structure thunderbay_pinctrl address
+ * Arg[1]: pin number
+ * Arg[2]: address to update pin configuration
+ * Return value: 0u - for Success,
+ *               Negative value for any error.
+ *******************************************************************************/
 static int thunderbay_pinconf_get_tristate(struct thunderbay_pinctrl *tpc,
 							unsigned int pin, u32 *config)
 {
@@ -617,6 +1137,15 @@ static int thunderbay_pinconf_get_tristate(struct thunderbay_pinctrl *tpc,
 	return ret_val;
 }
 
+/*******************************************************************************
+ * Function name: thunderbay_pinconf_set_pulldown
+ * Description: Set pin pull-down
+ * Arg[0]: thunderbay specific structure thunderbay_pinctrl address
+ * Arg[1]: pin number
+ * Arg[2]: required pin configuration
+ * Return value: 0u - for Success,
+ *               Negative value for any error.
+ *******************************************************************************/
 static int thunderbay_pinconf_set_pulldown(struct thunderbay_pinctrl *tpc,
 							unsigned int pin, u32 config)
 {
@@ -638,6 +1167,15 @@ static int thunderbay_pinconf_set_pulldown(struct thunderbay_pinctrl *tpc,
 	return ret_val;
 }
 
+/*******************************************************************************
+ * Function name: thunderbay_pinconf_get_pulldown
+ * Description: Provides pin pull-down status
+ * Arg[0]: thunderbay specific structure thunderbay_pinctrl address
+ * Arg[1]: pin number
+ * Arg[2]: address to update pin configuration
+ * Return value: 0u - for Success,
+ *               Negative value for any error.
+ *******************************************************************************/
 static int thunderbay_pinconf_get_pulldown(struct thunderbay_pinctrl *tpc,
 					unsigned int pin, u32 *config)
 {
@@ -657,6 +1195,15 @@ static int thunderbay_pinconf_get_pulldown(struct thunderbay_pinctrl *tpc,
 	return ret_val;
 }
 
+/*******************************************************************************
+ * Function name: thunderbay_pinconf_set_pullup
+ * Description: Set pin pull-up
+ * Arg[0]: thunderbay specific structure thunderbay_pinctrl address
+ * Arg[1]: pin number
+ * Arg[2]: required pin configuration
+ * Return value: 0u - for Success,
+ *               Negative value for any error.
+ *******************************************************************************/
 static int thunderbay_pinconf_set_pullup(struct thunderbay_pinctrl *tpc,
 						unsigned int pin, u32 config)
 {
@@ -678,6 +1225,15 @@ static int thunderbay_pinconf_set_pullup(struct thunderbay_pinctrl *tpc,
 	return ret_val;
 }
 
+/*******************************************************************************
+ * Function name: thunderbay_pinconf_get_pullup
+ * Description: Provides pin pull-up status
+ * Arg[0]: thunderbay specific structure thunderbay_pinctrl address
+ * Arg[1]: pin number
+ * Arg[2]: address to update pin configuration
+ * Return value: 0u - for Success,
+ *               Negative value for any error.
+ *******************************************************************************/
 static int thunderbay_pinconf_get_pullup(struct thunderbay_pinctrl *tpc,
 						unsigned int pin, u32 *config)
 {
@@ -697,6 +1253,15 @@ static int thunderbay_pinconf_get_pullup(struct thunderbay_pinctrl *tpc,
 	return ret_val;
 }
 
+/*******************************************************************************
+ * Function name: thunderbay_pinconf_set_opendrain
+ * Description: Set pin open-drain
+ * Arg[0]: thunderbay specific structure thunderbay_pinctrl address
+ * Arg[1]: pin number
+ * Arg[2]: required pin configuration
+ * Return value: 0u - for Success,
+ *               Negative value for any error.
+ *******************************************************************************/
 static int thunderbay_pinconf_set_opendrain(struct thunderbay_pinctrl *tpc,
 								unsigned int pin, u32 config)
 {
@@ -711,14 +1276,22 @@ static int thunderbay_pinconf_set_opendrain(struct thunderbay_pinctrl *tpc,
 
 	reg = thb_gpio_read_reg(chip, pin);
 
-	reg = (config > 0) ? (reg & (~(THB_GPIO_PULL_ENABLE_MASK)))
-						: (reg | THB_GPIO_PULL_ENABLE_MASK);
+	reg = (config > 0)?(reg & (~(THB_GPIO_PULL_ENABLE_MASK))):(reg | THB_GPIO_PULL_ENABLE_MASK);
 
 	ret_val = thb_gpio_write_reg(chip, pin, reg);
 
 	return ret_val;
 }
 
+/*******************************************************************************
+ * Function name: thunderbay_pinconf_get_opendrain
+ * Description: Provides pin open-drain status
+ * Arg[0]: thunderbay specific structure thunderbay_pinctrl address
+ * Arg[1]: pin number
+ * Arg[2]: address to update pin configuration
+ * Return value: 0u - for Success,
+ *               Negative value for any error.
+ *******************************************************************************/
 static int thunderbay_pinconf_get_opendrain(struct thunderbay_pinctrl *tpc,
 						unsigned int pin, u32 *config)
 {
@@ -738,7 +1311,15 @@ static int thunderbay_pinconf_get_opendrain(struct thunderbay_pinctrl *tpc,
 	return ret_val;
 }
 
-
+/*******************************************************************************
+ * Function name: thunderbay_pinconf_set_pushpull
+ * Description: Set pin push-pull
+ * Arg[0]: thunderbay specific structure thunderbay_pinctrl address
+ * Arg[1]: pin number
+ * Arg[2]: required pin configuration
+ * Return value: 0u - for Success,
+ *               Negative value for any error.
+ *******************************************************************************/
 static int thunderbay_pinconf_set_pushpull(struct thunderbay_pinctrl *tpc,
 						unsigned int pin, u32 config)
 {
@@ -753,14 +1334,22 @@ static int thunderbay_pinconf_set_pushpull(struct thunderbay_pinctrl *tpc,
 
 	reg = thb_gpio_read_reg(chip, pin);
 
-	reg = (config > 0) ? (reg | THB_GPIO_PULL_ENABLE_MASK)
-						: (reg & (~(THB_GPIO_PULL_ENABLE_MASK)));
+	reg = (config > 0)?(reg | THB_GPIO_PULL_ENABLE_MASK):(reg & (~(THB_GPIO_PULL_ENABLE_MASK)));
 
 	ret_val = thb_gpio_write_reg(chip, pin, reg);
 
 	return ret_val;
 }
 
+/*******************************************************************************
+ * Function name: thunderbay_pinconf_get_opendrain
+ * Description: Provides pin push-pull status
+ * Arg[0]: thunderbay specific structure thunderbay_pinctrl address
+ * Arg[1]: pin number
+ * Arg[2]: address to update pin configuration
+ * Return value: 0u - for Success,
+ *               Negative value for any error.
+ *******************************************************************************/
 static int thunderbay_pinconf_get_pushpull(struct thunderbay_pinctrl *tpc,
 							unsigned int pin, u32 *config)
 {
@@ -779,7 +1368,15 @@ static int thunderbay_pinconf_get_pushpull(struct thunderbay_pinctrl *tpc,
 
 	return ret_val;
 }
-
+/*******************************************************************************
+ * Function name: thunderbay_pinconf_set_drivestrength
+ * Description: Set pin drive-strength
+ * Arg[0]: thunderbay specific structure thunderbay_pinctrl address
+ * Arg[1]: pin number
+ * Arg[2]: required pin configuration
+ * Return value: 0u - for Success,
+ *               Negative value for any error.
+ *******************************************************************************/
 static int thunderbay_pinconf_set_drivestrength(struct thunderbay_pinctrl *tpc,
 							unsigned int pin, u32 config)
 {
@@ -802,7 +1399,15 @@ static int thunderbay_pinconf_set_drivestrength(struct thunderbay_pinctrl *tpc,
 
 	return ret_val;
 }
-
+/*******************************************************************************
+ * Function name: thunderbay_pinconf_get_drivestrength
+ * Description: Provides pin drive-strength status
+ * Arg[0]: thunderbay specific structure thunderbay_pinctrl address
+ * Arg[1]: pin number
+ * Arg[2]: address to update pin configuration
+ * Return value: 0u - for Success,
+ *               Negative value for any error.
+ *******************************************************************************/
 static int thunderbay_pinconf_get_drivestrength(struct thunderbay_pinctrl *tpc,
 						unsigned int pin, u32 *config)
 {
@@ -824,6 +1429,15 @@ static int thunderbay_pinconf_get_drivestrength(struct thunderbay_pinctrl *tpc,
 	return ret_val;
 }
 
+/*******************************************************************************
+ * Function name: thunderbay_pinconf_set_schmitt
+ * Description: Set pin schmitt-trigger
+ * Arg[0]: thunderbay specific structure thunderbay_pinctrl address
+ * Arg[1]: pin number
+ * Arg[2]: required pin configuration
+ * Return value: 0u - for Success,
+ *               Negative value for any error.
+ *******************************************************************************/
 static int thunderbay_pinconf_set_schmitt(struct thunderbay_pinctrl *tpc,
 						unsigned int pin, u32 config)
 {
@@ -838,14 +1452,23 @@ static int thunderbay_pinconf_set_schmitt(struct thunderbay_pinctrl *tpc,
 
 	reg = thb_gpio_read_reg(chip, pin);
 
-	reg = (config > 0) ? (reg | THB_GPIO_SCHMITT_TRIGGER_MASK)
-						: (reg & (~(THB_GPIO_SCHMITT_TRIGGER_MASK)));
+	reg = (config > 0)?(reg|THB_GPIO_SCHMITT_TRIGGER_MASK) :
+				(reg&(~(THB_GPIO_SCHMITT_TRIGGER_MASK)));
 
 	ret_val = thb_gpio_write_reg(chip, pin, reg);
 
 	return ret_val;
 }
 
+/*******************************************************************************
+ * Function name: thunderbay_pinconf_get_schmitt
+ * Description: Provides pin schmitt-trigger status
+ * Arg[0]: thunderbay specific structure thunderbay_pinctrl address
+ * Arg[1]: pin number
+ * Arg[2]: address to update pin configuration
+ * Return value: 0u - for Success,
+ *               Negative value for any error.
+ *******************************************************************************/
 static int thunderbay_pinconf_get_schmitt(struct thunderbay_pinctrl *tpc,
 						unsigned int pin, u32 *config)
 {
@@ -865,7 +1488,15 @@ static int thunderbay_pinconf_get_schmitt(struct thunderbay_pinctrl *tpc,
 	return ret_val;
 }
 
-
+/*******************************************************************************
+ * Function name: thunderbay_pinconf_set_slew_rate
+ * Description: Set pin slewrate
+ * Arg[0]: thunderbay specific structure thunderbay_pinctrl address
+ * Arg[1]: pin number
+ * Arg[2]: required pin configuration
+ * Return value: 0u - for Success,
+ *               Negative value for any error.
+ *******************************************************************************/
 static int thunderbay_pinconf_set_slew_rate(struct thunderbay_pinctrl *tpc,
 						unsigned int pin, u32 config)
 {
@@ -880,14 +1511,22 @@ static int thunderbay_pinconf_set_slew_rate(struct thunderbay_pinctrl *tpc,
 
 	reg = thb_gpio_read_reg(chip, pin);
 
-	reg = (config > 0) ? (reg | THB_GPIO_SLEW_RATE_MASK)
-						: (reg & (~(THB_GPIO_SLEW_RATE_MASK)));
+	reg = (config > 0) ? (reg | THB_GPIO_SLEW_RATE_MASK):(reg & (~(THB_GPIO_SLEW_RATE_MASK)));
 
 	ret_val = thb_gpio_write_reg(chip, pin, reg);
 
 	return ret_val;
 }
 
+/*******************************************************************************
+ * Function name: thunderbay_pinconf_get_slew_rate
+ * Description: Provides pin slewrate status
+ * Arg[0]: thunderbay specific structure thunderbay_pinctrl address
+ * Arg[1]: pin number
+ * Arg[2]: address to update pin configuration
+ * Return value: 0u - for Success,
+ *               Negative value for any error.
+ *******************************************************************************/
 static int thunderbay_pinconf_get_slew_rate(struct thunderbay_pinctrl *tpc,
 						unsigned int pin, u32 *config)
 {
@@ -907,7 +1546,15 @@ static int thunderbay_pinconf_get_slew_rate(struct thunderbay_pinctrl *tpc,
 	return ret_val;
 }
 
-
+/*******************************************************************************
+ * Function name: thunderbay_pinconf_get
+ * Description: Provides required pin configuration status
+ * Arg[0]: thunderbay specific structure pinctrl_dev address
+ * Arg[1]: pin number
+ * Arg[2]: address to update pin configuration
+ * Return value: 0u - for Success,
+ *               Negative value for any error.
+ *******************************************************************************/
 static int thunderbay_pinconf_get(struct pinctrl_dev *pctldev, unsigned int pin,
 					unsigned long *config)
 {
@@ -959,7 +1606,16 @@ static int thunderbay_pinconf_get(struct pinctrl_dev *pctldev, unsigned int pin,
 	return 0;
 }
 
-
+/*******************************************************************************
+ * Function name: thunderbay_pinconf_set
+ * Description: Set required pin configuration
+ * Arg[0]: thunderbay specific structure pinctrl_dev address
+ * Arg[1]: pin number
+ * Arg[2]: address to update pin configuration
+ * Arg[3]: number of configurations
+ * Return value: 0u - for Success,
+ *               Negative value for any error.
+ *******************************************************************************/
 static int thunderbay_pinconf_set(struct pinctrl_dev *pctldev, unsigned int pin,
 					unsigned long *configs, unsigned int num_configs)
 {
@@ -1013,212 +1669,22 @@ static int thunderbay_pinconf_set(struct pinctrl_dev *pctldev, unsigned int pin,
 
 	return ret;
 }
-/***********************************************************************************/
-
-static const unsigned int i2c_0_pins[] = { 0, 1 };
-static const unsigned int i2c_1_pins[] = { 2, 3 };
-static const unsigned int i2c_2_pins[] = { 4, 5 };
-static const unsigned int i2c_3_pins[] = { 6, 7 };
-static const unsigned int i2c_4_pins[] = { 8, 9 };
-
-static const unsigned int uart_0_pins[] = { 10, 11, 12, 13 };
-static const unsigned int uart_1_pins[] = { 14, 15, 16, 17 };
-
-static const unsigned int spi_0_pins[] = { 18, 19, 20, 21 };
-static const unsigned int spi_1_pins[] = { 22, 23, 24, 25 };
-
-static const unsigned int ethernet_0_pins[] = { 26, 27, 28, 29, 30, 31, 32, 33,
-				34, 35, 36, 37, 38, 39, 40 };
-static const unsigned int ethernet_1_pins[] = { 42, 43, 44, 45, 46, 47, 48, 49,
-				50, 51, 52, 53, 54, 55, 56 };
-
-static const unsigned int power_interrupt_max_platform_power_pins[] = { 41 };
-static const unsigned int power_interrupt_iccmax_vpu_pins[] = { 57 };
-static const unsigned int power_interrupt_iccmax_media_pins[] = { 66 };
-
-static const unsigned int thermtrip_in_pins[] = { 58 };
-static const unsigned int thermtrip_out_pins[] = { 59 };
-
-static const unsigned int smbus_0_pins[] = { 60, 61 };
-
-static const unsigned int platform_reset_in_pins[] = { 62 };
-static const unsigned int platform_reset_out_pins[] = { 63 };
-
-static const unsigned int platform_shutdown_in_pins[] = { 64 };
-static const unsigned int platform_shutdown_out_pins[] = { 65 };
-
-
-#define DEFINE_THB_PINCTRL_GRP(gname) \
-	{\
-		.name = #gname "_grp", \
-		.pins = gname ## _pins, \
-		.npins = ARRAY_SIZE(gname ## _pins), \
-	}
-
-
-static const struct thb_pinctrl_group thb_pinctrl_groups[] = {
-	DEFINE_THB_PINCTRL_GRP(i2c_0),
-	DEFINE_THB_PINCTRL_GRP(i2c_1),
-	DEFINE_THB_PINCTRL_GRP(i2c_2),
-	DEFINE_THB_PINCTRL_GRP(i2c_3),
-	DEFINE_THB_PINCTRL_GRP(i2c_4),
-	DEFINE_THB_PINCTRL_GRP(uart_0),
-	DEFINE_THB_PINCTRL_GRP(uart_1),
-	DEFINE_THB_PINCTRL_GRP(spi_0),
-	DEFINE_THB_PINCTRL_GRP(spi_1),
-	DEFINE_THB_PINCTRL_GRP(ethernet_0),
-	DEFINE_THB_PINCTRL_GRP(ethernet_1),
-	DEFINE_THB_PINCTRL_GRP(power_interrupt_max_platform_power),
-	DEFINE_THB_PINCTRL_GRP(power_interrupt_iccmax_vpu),
-	DEFINE_THB_PINCTRL_GRP(power_interrupt_iccmax_media),
-	DEFINE_THB_PINCTRL_GRP(thermtrip_in),
-	DEFINE_THB_PINCTRL_GRP(thermtrip_out),
-	DEFINE_THB_PINCTRL_GRP(smbus_0),
-	DEFINE_THB_PINCTRL_GRP(platform_reset_in),
-	DEFINE_THB_PINCTRL_GRP(platform_reset_out),
-	DEFINE_THB_PINCTRL_GRP(platform_shutdown_in),
-	DEFINE_THB_PINCTRL_GRP(platform_shutdown_out),
-};
-
-/* function groups */
-static const char * const i2c_groups[] = { "i2c_0_grp", "i2c_1_grp", "i2c_2_grp",
-					"i2c_3_grp", "i2c_4_grp" };
-static const char * const uart_groups[] = { "uart_0_grp", "uart_1_grp" };
-static const char * const spi_groups[] = { "spi_0_grp", "spi_1_grp" };
-static const char * const ethernet_groups[] = { "ethernet_0_grp", "ethernet_1_grp" };
-static const char * const power_interrupt_max_platform_power_groups[] = {
-							"power_interrupt_max_platform_power_grp" };
-static const char * const power_interrupt_iccmax_vpu_groups[] = {
-							"power_interrupt_iccmax_vpu_grp" };
-static const char * const power_interrupt_iccmax_media_groups[] = {
-							"power_interrupt_iccmax_media" };
-static const char * const thermtrip_in_groups[] = { "thermtrip_in_grp" };
-static const char * const thermtrip_out_groups[] = { "thermtrip_out_grp" };
-static const char * const smbus_groups[] = { "smbus_0_grp" };
-static const char * const platform_reset_in_groups[] = { "platform_reset_in_grp" };
-static const char * const platform_reset_out_groups[] = { "platform_reset_out_grp" };
-static const char * const platform_shutdown_in_groups[] = { "platform_shutdown_in_grp" };
-static const char * const platform_shutdown_out_groups[] = { "platform_shutdown_out_grp" };
-
-
-static int thb_pinctrl_get_groups_count(struct pinctrl_dev *pctldev)
-{
-	struct thunderbay_pinctrl *tpc = pinctrl_dev_get_drvdata(pctldev);
-
-	return tpc->ngroups;
-}
-
-static const char *thb_pinctrl_get_group_name(struct pinctrl_dev *pctldev, unsigned int selector)
-{
-	struct thunderbay_pinctrl *tpc = pinctrl_dev_get_drvdata(pctldev);
-
-		return tpc->groups[selector].name;
-}
-
-static int thb_pinctrl_get_group_pins(struct pinctrl_dev *pctldev, unsigned int selector,
-						const unsigned int **pins, unsigned int *num_pins)
-{
-	struct thunderbay_pinctrl *tpc = pinctrl_dev_get_drvdata(pctldev);
-
-		*pins = tpc->groups[selector].pins;
-		*num_pins = tpc->groups[selector].npins;
-		return 0;
-}
-
-/* pinmux */
-
-#define DEFINE_THB_PINMUX_FUNCTION(fname) \
-{\
-	.name = #fname, \
-	.groups = fname##_groups, \
-	.ngroups = ARRAY_SIZE(fname##_groups), \
-}
-
-static const struct thb_pinmux_function thb_pinctrl_pmx_funcs[] = {
-	DEFINE_THB_PINMUX_FUNCTION(i2c),
-	DEFINE_THB_PINMUX_FUNCTION(uart),
-	DEFINE_THB_PINMUX_FUNCTION(spi),
-	DEFINE_THB_PINMUX_FUNCTION(ethernet),
-	DEFINE_THB_PINMUX_FUNCTION(power_interrupt_max_platform_power),
-	DEFINE_THB_PINMUX_FUNCTION(power_interrupt_iccmax_vpu),
-	DEFINE_THB_PINMUX_FUNCTION(power_interrupt_iccmax_media),
-	DEFINE_THB_PINMUX_FUNCTION(thermtrip_in),
-	DEFINE_THB_PINMUX_FUNCTION(thermtrip_out),
-	DEFINE_THB_PINMUX_FUNCTION(smbus),
-	DEFINE_THB_PINMUX_FUNCTION(platform_reset_in),
-	DEFINE_THB_PINMUX_FUNCTION(platform_reset_out),
-	DEFINE_THB_PINMUX_FUNCTION(platform_shutdown_in),
-	DEFINE_THB_PINMUX_FUNCTION(platform_shutdown_out),
-};
-
-static int thb_pinctrl_get_functions_count(struct pinctrl_dev *pctldev)
-{
-	struct thunderbay_pinctrl *tpc = pinctrl_dev_get_drvdata(pctldev);
-
-		return tpc->nfuncs;
-}
-
-static const char *thb_pinctrl_get_fname(struct pinctrl_dev *pctldev, unsigned int selector)
-{
-	struct thunderbay_pinctrl *tpc = pinctrl_dev_get_drvdata(pctldev);
-
-		return tpc->funcs[selector].name;
-}
-
-static int thb_pinctrl_get_groups(struct pinctrl_dev *pctldev, unsigned int selector,
-						const char * const **groups,
-						unsigned int *const num_groups)
-{
-	struct thunderbay_pinctrl *tpc = pinctrl_dev_get_drvdata(pctldev);
-
-		*groups = tpc->funcs[selector].groups;
-		*num_groups = tpc->funcs[selector].ngroups;
-		return 0;
-}
-
-static int thb_pinctrl_set_mux(struct pinctrl_dev *pctldev, unsigned int selector,
-					unsigned int group)
-{
-	/* Check and update precondition check required before setting as mux
-	 * this as to be updated as per the THB register configuration
-	 */
-
-	u32 reg = 0;
-	int i, modex = 0, ret_val = -EINVAL;
-
-	struct thunderbay_pinctrl *tpc = pinctrl_dev_get_drvdata(pctldev);
-	struct gpio_chip *chip = &tpc->chip;
-	const struct thb_pinctrl_group *pgrp = &tpc->groups[group];
-//	const struct thb_pinmux_function *func = &tpc->funcs[selector];
-
-	for (i = 0; i < pgrp->npins; i++) {
-		unsigned int pin = pgrp->pins[i];
-
-		reg = thb_gpio_read_reg(chip, pin);
-
-		reg |= thb_modex_pinval[pin][modex];
-
-		ret_val = thb_gpio_write_reg(chip, pin, reg);
-	}
-
-	return ret_val;
-}
-
-
-/*********************************************************************************/
+/***********************************************************************************
+ * Register/assign pin control operations
+ *********************************************************************************/
 
 const struct pinctrl_ops thunderbay_pctlops = {
-	.get_groups_count = thb_pinctrl_get_groups_count,
-	.get_group_name   = thb_pinctrl_get_group_name,
-	.get_group_pins   = thb_pinctrl_get_group_pins,
+	.get_groups_count = pinctrl_generic_get_group_count,
+	.get_group_name   = pinctrl_generic_get_group_name,
+	.get_group_pins   = pinctrl_generic_get_group_pins,
 	.dt_node_to_map   = pinconf_generic_dt_node_to_map_all,
 	.dt_free_map	  = pinconf_generic_dt_free_map,
 };
 
 const struct pinmux_ops thunderbay_pmxops = {
-	.get_functions_count = thb_pinctrl_get_functions_count,
-	.get_function_name   = thb_pinctrl_get_fname,
-	.get_function_groups = thb_pinctrl_get_groups,
+	.get_functions_count = pinmux_generic_get_function_count,
+	.get_function_name   = pinmux_generic_get_function_name,
+	.get_function_groups = pinmux_generic_get_function_groups,
 	.set_mux			 = thb_pinctrl_set_mux,
 	.gpio_request_enable = thunderbay_request_gpio,
 	.gpio_disable_free   = thunderbay_free_gpio,
@@ -1237,172 +1703,6 @@ static struct pinctrl_desc thunderbay_pinctrl_desc = {
 	.confops = &thunderbay_confops,
 	.owner   = THIS_MODULE,
 };
-/**************************************************************************************/
-
-/* returns direction for signal “offset”, 0=out, 1=in,
- * (same as GPIOF_DIR_XXX), or negative error
- */
-static int thunderbay_gpio_get_direction(struct gpio_chip *chip, unsigned int offset)
-{
-	int ret_val = -EINVAL;
-
-	u32 reg = thb_gpio_read_reg(chip, offset);
-
-	/* Return direction only if configured as GPIO else negative error */
-	if (reg & THB_GPIO_PORT_SELECT_MASK)
-		ret_val = ((reg & THB_GPIO_PAD_DIRECTION_MASK) == 0) ? 1 : 0;
-
-
-	return ret_val;
-}
-
-// configures signal “offset” as input, or returns error
-static int thunderbay_gpio_set_direction_input(struct gpio_chip *chip, unsigned int offset)
-{
-	int ret_val = -EINVAL;
-
-	u32 reg = thb_gpio_read_reg(chip, offset);
-
-	/* set pin as input only if it is GPIO else error */
-	if (reg & THB_GPIO_PORT_SELECT_MASK) {
-		reg &= (~THB_GPIO_PAD_DIRECTION_MASK);
-
-		thb_gpio_write_reg(chip, offset, reg);
-
-		ret_val = 0;
-	}
-
-	return ret_val;
-}
-
-// assigns output value for signal “offset”
-static void thunderbay_gpio_set_value(struct gpio_chip *chip, unsigned int offset, int value)
-{
-	int ret_val = -EINVAL;
-
-	u32 reg = thb_gpio_read_reg(chip, offset);
-
-	/* update pin value only if it is GPIO-output else error */
-	if ((reg & THB_GPIO_PORT_SELECT_MASK) && (reg & THB_GPIO_PAD_DIRECTION_MASK))
-		ret_val = thb_write_gpio_data(chip, offset, value);
-
-	return;
-
-}
-
-
-// configures signal “offset” as output, or returns error
-static int thunderbay_gpio_set_direction_output(struct gpio_chip *chip,
-					unsigned int offset, int value)
-{
-	int ret_val = -EINVAL;
-
-	u32 reg = thb_gpio_read_reg(chip, offset);
-
-	/* set pin as output only if it is GPIO else error */
-	if (reg & THB_GPIO_PORT_SELECT_MASK) {
-		reg |= THB_GPIO_PAD_DIRECTION_MASK;
-
-		thb_gpio_write_reg(chip, offset, reg);
-
-		thunderbay_gpio_set_value(chip, offset, value);
-
-		ret_val = 0u;
-	}
-
-	return ret_val;
-}
-
-
-
-// returns value for signal “offset”, 0=low, 1=high, or negative error
-static int thunderbay_gpio_get_value(struct gpio_chip *chip, unsigned int offset)
-{
-	int ret_val = -EINVAL;
-	int gpio_dir = 0;
-
-	u32 reg = thb_gpio_read_reg(chip, offset);
-
-	/* Read pin value only if it is GPIO else error */
-	if (reg & THB_GPIO_PORT_SELECT_MASK) {
-		gpio_dir = ((reg & THB_GPIO_PAD_DIRECTION_MASK) > 0) ? 1 : 0;
-
-		ret_val = thb_read_gpio_data(chip, offset, gpio_dir);
-	}
-
-	return ret_val;
-}
-
-/******************************************************************************************
- * thunderbay_gpio_probe - Initialization method for a thb_gpio device
- * @pdev:	platform device instance
- *
- * This function allocates memory resources for the gpio device and register the GPIO chip
- * It will also set up interrupts for the gpio pins -> Yet to be implemnetd
- * Note: Interrupts are disabled/not handled temporarily.
- *
- * Return: 0 on success, negative error otherwise.
- ******************************************************************************************/
-static int thunderbay_gpiochip_probe(struct thunderbay_pinctrl *tpc)
-{
-	struct gpio_chip *chip = &tpc->chip;
-	int ret, i, offset;
-	u32 reg = 0;
-
-	chip->label		= dev_name(tpc->dev);
-	chip->parent		= tpc->dev;
-	chip->request		= gpiochip_generic_request;
-	chip->free		= gpiochip_generic_free;
-	chip->get_direction	= thunderbay_gpio_get_direction;
-	chip->direction_input	= thunderbay_gpio_set_direction_input;
-	chip->direction_output  = thunderbay_gpio_set_direction_output;
-	chip->get		= thunderbay_gpio_get_value;
-	chip->set			   = thunderbay_gpio_set_value;
-/* identifies the first GPIO number handled by this chip; or, if negative during registration,
- * requests dynamic ID allocation.
- * DEPRECATION: providing anything non-negative and nailing the base
- * offset of GPIO chips is deprecated.
- * Please pass -1 as base to let gpiolib select the chip base in all possible cases.
- * We want to get rid of the static GPIO number space in the long run.
- */
-	chip->base		= -1;
-/* the number of GPIOs handled by this controller; the last GPIO handled is (base + ngpio - 1). */
-	chip->ngpio		= tpc->soc->npins;
-
-	ret = gpiochip_add_data(chip, tpc);
-	if (ret) {
-		dev_err(tpc->dev, "Failed to add gpiochip\n");
-		return ret;
-	}
-
-	ret = gpiochip_add_pin_range(chip, dev_name(tpc->dev), 0, 0,
-					chip->ngpio);
-	if (ret) {
-		dev_err(tpc->dev, "Failed to add gpiochip pin range\n");
-		return ret;
-	}
-
-	for (i = 0; i < 67; i++) {
-	/* TODO: Remove after THB-PO
-	 * THB GPIO Default configuration as per THB-VV/CRB board
-	 */
-		reg = thb_vv_cfg_modex_regval[i][0];
-		thb_gpio_write_reg(chip, i, reg);
-	}
-
-	/* TODO: Remove after THB-PO
-	 * 0x43 = Offset for gpio_power_int_setup/4
-	 */
-	offset = 0x43;
-	reg = thb_gpio_read_reg(chip, offset);
-	/* Keeping all power interrupts to Level-High triggered as suggested by HW team */
-	reg |= 0x1E;
-	thb_gpio_write_reg(chip, offset, reg);
-
-	return 0;
-}
-
-/************************************************************************************/
 
 static const struct of_device_id thunderbay_pinctrl_match[] = {
 {	.compatible = "intel,thunderbay-pinctrl",
@@ -1410,9 +1710,13 @@ static const struct of_device_id thunderbay_pinctrl_match[] = {
 	{},
 };
 
-
-
-/* THB-PinCtrl: Probe/Init function */
+/*******************************************************************************
+ * Function name: thunderbay_pinctrl_probe
+ * Description: Pinctrl probe/init function to register THB pincontrol chip and
+ *              required call back functions with standard linux frame work.
+ * Arg[0]: thunderbay specific structure platform_device address
+ * Return value: 0u -> success / Negative value for any failure
+ *******************************************************************************/
 int thunderbay_pinctrl_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
@@ -1448,6 +1752,16 @@ int thunderbay_pinctrl_probe(struct platform_device *pdev)
 	if (IS_ERR(tpc->pctrl))
 		return PTR_ERR(tpc->pctrl);
 
+	/* Setup pinmux groups */
+	ret = thunderbay_build_groups(tpc);
+	if (ret)
+		return ret;
+
+	/* Setup pinmux functions */
+	ret = thunderbay_build_functions(tpc);
+	if (ret)
+		return ret;
+
 	/* Setup GPIO */
 	ret = thunderbay_gpiochip_probe(tpc);
 	if (ret < 0)
@@ -1467,7 +1781,7 @@ int thunderbay_pinctrl_probe(struct platform_device *pdev)
  **********************************************************************/
 static int thunderbay_pinctrl_remove(struct platform_device *pdev)
 {
-	/* TODO: Update thunderbay_pinctrl_remove function to clear the memory */
+	/* thunderbay_pinctrl_remove function to clear the assigned memory */
 	return 0;
 }
 
@@ -1482,3 +1796,7 @@ static struct platform_driver thunderbay_pinctrl_driver = {
 };
 
 builtin_platform_driver(thunderbay_pinctrl_driver);
+
+MODULE_DESCRIPTION("Intel Thunderbay PinCtrl/Gpio Driver");
+MODULE_AUTHOR("Kiran Kumar <kiran.kumar1.s@intel.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/pinctrl/pinctrl-thunderbay.h b/drivers/pinctrl/pinctrl-thunderbay.h
index f3be4fc35a41..32f7d9e04f08 100644
--- a/drivers/pinctrl/pinctrl-thunderbay.h
+++ b/drivers/pinctrl/pinctrl-thunderbay.h
@@ -13,35 +13,17 @@
 #ifndef PINCTRL_THUNDERBAY_H
 #define PINCTRL_THUNDERBAY_H
 
-/* THB GPIO Base address, Size is 64 KB */
-#define THB_GPIO_APB_REGISTER_BASE_ADDR  0x80450000
-
-#define THB_GPIO_DATA_INOUTx_OFFSET (0x8000)
-
-#define THB_GPIO_DATA_IN (0x1)
-
-#define THB_GPIO_REG_OFFSET(pin_num) (pin_num * (0x4))
-
-/* bit 0:2 - IS: Input Selection.*/
-#define THB_GPIO_INPUT_SELECTION_MASK (0x7)
-
-/* bit 3 - ID: Input Disable.
- * Note: if inputs are floating then the input of the pad should be disabled
- */
-#define THB_GPIO_INPUT_DISABLE_MASK (0x8)
-
-/* bit 4:6 - OS: Output Selection.
- * Note: These bit are only valid when bit[8] (PS) is set to 1’b0 (Port mode).
- * Otherwise these bits have no effect.
- */
-#define THB_GPIO_OUTPUT_SELECTION_MASK (0x70)
-
-/* Bit 0:2 and 4:6 should be set 0x4, for GPIO direct control */
-#define THB_GPIO_DIRECT_CONTROL_MODE_4 (0x44)
-
-
-/* bit 7 - FBD: Feedback Disable. Note if ID=1 then FBD has no impact*/
-#define THB_GPIO_FEEDBACK_DISABLE_MASK (0x80)
+/***********************************************************************************
+ * Private Macros
+ ***********************************************************************************/
+
+/* Bit 0:2 and 4:6 should be used for mode selection */
+#define THB_GPIO_PINMUX_MODE_0 (0x00)
+#define THB_GPIO_PINMUX_MODE_1 (0x11)
+#define THB_GPIO_PINMUX_MODE_2 (0x22)
+#define THB_GPIO_PINMUX_MODE_3 (0x33)
+/* GPIO direct control */
+#define THB_GPIO_PINMUX_MODE_4 (0x44)
 
 /* bit 8 - PS: Port Select */
 #define THB_GPIO_PORT_SELECT_MASK (0x100)
@@ -50,7 +32,7 @@
 #define THB_GPIO_PAD_DIRECTION_MASK (0x400)
 
 /* bit 11 - SPU: Strong Pull function of pad */
-#define THB_GPIO_SPU_MASK (0x800)
+//#define THB_GPIO_SPU_MASK (0x800)
 
 /* bit 12 - PPEN: Pull Enable function of pad  */
 #define THB_GPIO_PULL_ENABLE_MASK (0x1000)
@@ -67,245 +49,28 @@
 /* bit 16-19: Drive Strength for the Pad */
 #define THB_GPIO_DRIVE_STRENGTH_MASK (0xF0000)
 
-/* bit 20 - ModeI2CnCMOSq: Mode for operating the pad in I2C or CMOS*/
-#define THB_GPIO_I2C_CMOS_MASK (0x100000)
+/* bit 20 - Slew rate for the pad */
 #define THB_GPIO_SLEW_RATE_MASK (0x100000)
 
-/* bit 21 - Mode1p8n1p2b: Mode for operating voltage selection of I2C pad*/
-#define THB_GPIO_I2C_PAD_VOLTAGE_MASK (0x200000)
+/* bit 21 - Schmitt-Trigger for the pad */
 #define THB_GPIO_SCHMITT_TRIGGER_MASK (0x200000)
 
-/* Reg:0-9, 60-61 */
-#define THB_GPIO_I2C_CTRL_REG_x(pinnr) (((pinnr <= 9) || ((pinnr >= 60) && (pinnr < 62))) ? 1 : 0)
+/* calculate register offset */
+#define THB_GPIO_REG_OFFSET(pin_num) (pin_num * (0x4))
 
-/* Reg:10-59, 62-66 */
-#define THB_GPIO_CTRL_REG_x(pinnr) ((((pinnr >= 10) && (pinnr < 60)) \
-				|| ((pinnr >= 62) && (pinnr <= 66))) ? 1 : 0)
+/* Max number of modes supported */
+#define THB_MAX_MODE_SUPPORTED (5u)
 
-/* THB each PIN support different modes (0-4)
- * for each mode corresponding register value/pin is listed below
- * list is updated based on THB_Pinlist.xlsx (1.0)
- * @column 0: Pin number (0-66)
- * @column 1: mode number (0-4)
- * TODO: Update table for mode-4
- */
-static const u32 thb_modex_pinval[67][5] = {
-	{ 0x00000800, 0x00000811, 0x00000822, 0x00000833 },
-	{ 0x00000800, 0x00000811, 0x00000822, 0x00000833 },
-	{ 0x00000800, 0x00000811, 0x00000822, 0x00000833 },
-	{ 0x00000800, 0x00000811, 0x00000822, 0x00000833 },
-	{ 0x00000800, 0x00000811, 0x00000822, 0x00000833 },
-	{ 0x00000800, 0x00000811, 0x00000822, 0x00000833 },
-	{ 0x00000800, 0x00000811, 0x00000822, 0x00000833 },
-	{ 0x00000800, 0x00000811, 0x00000822, 0x00000833 },
-	{ 0x00000800, 0x00000811, 0x00000822, 0x00000833 },
-	{ 0x00000800, 0x00000811, 0x00000822, 0x00000833 },
-	{ 0x00370000, 0x00370011, 0x00370022, 0x00370033 },
-	{ 0x00370000, 0x00370011, 0x00370022, 0x00370033 },
-	{ 0x00370000, 0x00370011, 0x00370022, 0x00370033 },
-	{ 0x00370000, 0x00370011, 0x00370022, 0x00370033 },
-	{ 0x00370000, 0x00370011, 0x00370022, 0x00370033 },
-	{ 0x00370000, 0x00370011, 0x00370022, 0x00370033 },
-	{ 0x00370000, 0x00370011, 0x00370022, 0x00370033 },
-	{ 0x00370000, 0x00370011, 0x00370022, 0x00370033 },
-	{ 0x00170000, 0x00170011, 0x00170022, 0x00170033 },
-	{ 0x00170000, 0x00170011, 0x00170022, 0x00170033 },
-	{ 0x00170000, 0x00170011, 0x00170022, 0x00170033 },
-	{ 0x00170000, 0x00170011, 0x00170022, 0x00170033 },
-	{ 0x00170000, 0x00170011, 0x00170022, 0x00170033 },
-	{ 0x00170000, 0x00170011, 0x00170022, 0x00170033 },
-	{ 0x00170000, 0x00170011, 0x00170022, 0x00170033 },
-	{ 0x00170000, 0x00170011, 0x00170022, 0x00170033 },
-	{ 0x00170000, 0x00170011, 0x00170022, 0x00170033 },
-	{ 0x00170000, 0x00170011, 0x00170022, 0x00170033 },
-	{ 0x00170000, 0x00170011, 0x00170022, 0x00170033 },
-	{ 0x00170000, 0x00170011, 0x00170022, 0x00170033 },
-	{ 0x00170000, 0x00170011, 0x00170022, 0x00170033 },
-	{ 0x00170000, 0x00170011, 0x00170022, 0x00170033 },
-	{ 0x00170000, 0x00170011, 0x00170022, 0x00170033 },
-	{ 0x00170000, 0x00170011, 0x00170022, 0x00170033 },
-	{ 0x00170000, 0x00170011, 0x00170022, 0x00170033 },
-	{ 0x00170000, 0x00170011, 0x00170022, 0x00170033 },
-	{ 0x00170000, 0x00170011, 0x00170022, 0x00170033 },
-	{ 0x00170000, 0x00170011, 0x00170022, 0x00170033 },
-	{ 0x00170000, 0x00170011, 0x00170022, 0x00170033 },
-	{ 0x00170000, 0x00170011, 0x00170022, 0x00170033 },
-	{ 0x00170000, 0x00170011, 0x00170022, 0x00170033 },
-	{ 0x00170000, 0x00170011, 0x00170022, 0x00170033 },
-	{ 0x00170000, 0x00170011, 0x00170022, 0x00170033 },
-	{ 0x00170000, 0x00170011, 0x00170022, 0x00170033 },
-	{ 0x00170000, 0x00170011, 0x00170022, 0x00170033 },
-	{ 0x00170000, 0x00170011, 0x00170022, 0x00170033 },
-	{ 0x00170000, 0x00170011, 0x00170022, 0x00170033 },
-	{ 0x00170000, 0x00170011, 0x00170022, 0x00170033 },
-	{ 0x00170000, 0x00170011, 0x00170022, 0x00170033 },
-	{ 0x00170000, 0x00170011, 0x00170022, 0x00170033 },
-	{ 0x00170000, 0x00170011, 0x00170022, 0x00170033 },
-	{ 0x00170000, 0x00170011, 0x00170022, 0x00170033 },
-	{ 0x00170000, 0x00170011, 0x00170022, 0x00170033 },
-	{ 0x00170000, 0x00170011, 0x00170022, 0x00170033 },
-	{ 0x00170000, 0x00170011, 0x00170022, 0x00170033 },
-	{ 0x00170000, 0x00170011, 0x00170022, 0x00170033 },
-	{ 0x00170000, 0x00170011, 0x00170022, 0x00170033 },
-	{ 0x00170000, 0x00170011, 0x00170022, 0x00170033 },
-	{ 0x00370000, 0x00370011, 0x00370022, 0x00370033 },
-	{ 0x00370000, 0x00370011, 0x00370022, 0x00370033 },
-	{ 0x00000800, 0x00000811, 0x00000822, 0x00000833 },
-	{ 0x00000800, 0x00000811, 0x00000822, 0x00000833 },
-	{ 0x00370000, 0x00370011, 0x00370022, 0x00370033 },
-	{ 0x00370000, 0x00370011, 0x00370022, 0x00370033 },
-	{ 0x00370000, 0x00370011, 0x00370022, 0x00370033 },
-	{ 0x00370000, 0x00370011, 0x00370022, 0x00370033 },
-	{ 0x00370000, 0x00370011, 0x00370022, 0x00370033 },
-};
+/* Max number of pins supported */
+#define THB_MAX_NPINS_SUPPORTED (67u)
 
-/* Keeping all power interrupts to Level-High triggered as suggested by HW team
- *
- * static u32 thb_gpio_power_int_setup = 0x1E;
- * THB-VV board default configuration
- */
+/* THB Board specific requirements handle */
+#define THB_BOARD_SPECIFIC_GPIO_REQUIREMENTS_HANDLE (1u)
 
-static const u32 thb_vv_cfg_modex_regval[67][1] = {
-	{ 0x00000800 }, /* GPIO - 0   */
-	{ 0x00000800 }, /* GPIO - 1   */
-	{ 0x00000800 }, /* GPIO - 2   */
-	{ 0x00000800 }, /* GPIO - 3   */
-	{ 0x00000800 }, /* GPIO - 4   */
-	{ 0x00000800 }, /* GPIO - 5   */
-	{ 0x00000800 }, /* GPIO - 6   */
-	{ 0x00000800 }, /* GPIO - 7   */
-	{ 0x00000900 }, /* GPIO - 8   */
-	{ 0x00000900 }, /* GPIO - 9   */
-	{ 0x00370000 }, /* GPIO - 10  */
-	{ 0x00370000 }, /* GPIO - 11  */
-	{ 0x00370000 }, /* GPIO - 12  */
-	{ 0x00370000 }, /* GPIO - 13  */
-	{ 0x00370100 }, /* GPIO - 14  */
-	{ 0x00370100 }, /* GPIO - 15  */
-	{ 0x00370100 }, /* GPIO - 16  */
-	{ 0x00370100 }, /* GPIO - 17  */
-	{ 0x00170000 }, /* GPIO - 18  */
-	{ 0x00170000 }, /* GPIO - 19  */
-	{ 0x00170000 }, /* GPIO - 20  */
-	{ 0x00170000 }, /* GPIO - 21  */
-	{ 0x00170000 }, /* GPIO - 22  */
-	{ 0x00170000 }, /* GPIO - 23  */
-	{ 0x00170000 }, /* GPIO - 24  */
-	{ 0x00170000 }, /* GPIO - 25  */
-	{ 0x00170000 }, /* GPIO - 26  */
-	{ 0x00170000 }, /* GPIO - 27  */
-	{ 0x00170000 }, /* GPIO - 28  */
-	{ 0x00170000 }, /* GPIO - 29  */
-	{ 0x00170000 }, /* GPIO - 30  */
-	{ 0x00170000 }, /* GPIO - 31  */
-	{ 0x00170000 }, /* GPIO - 32  */
-	{ 0x00170000 }, /* GPIO - 33  */
-	{ 0x00170000 }, /* GPIO - 34  */
-	{ 0x00170000 }, /* GPIO - 35  */
-	{ 0x00170000 }, /* GPIO - 36  */
-	{ 0x00170000 }, /* GPIO - 37  */
-	{ 0x00170000 }, /* GPIO - 38  */
-	{ 0x00170000 }, /* GPIO - 39  */
-	{ 0x00170000 }, /* GPIO - 40  */
-	{ 0x00170000 }, /* GPIO - 41  */
-	{ 0x00170000 }, /* GPIO - 42  */
-	{ 0x00170000 }, /* GPIO - 43  */
-	{ 0x00170000 }, /* GPIO - 44  */
-	{ 0x00170000 }, /* GPIO - 45  */
-	{ 0x00170000 }, /* GPIO - 46  */
-	{ 0x00170000 }, /* GPIO - 47  */
-	{ 0x00170000 }, /* GPIO - 48  */
-	{ 0x00170000 }, /* GPIO - 49  */
-	{ 0x00170000 }, /* GPIO - 50  */
-	{ 0x00170000 }, /* GPIO - 51  */
-	{ 0x00170000 }, /* GPIO - 52  */
-	{ 0x00170000 }, /* GPIO - 53  */
-	{ 0x00170000 }, /* GPIO - 54  */
-	{ 0x00170000 }, /* GPIO - 55  */
-	{ 0x00170000 }, /* GPIO - 56  */
-	{ 0x00170000 }, /* GPIO - 57  */
-	{ 0x00370000 }, /* GPIO - 58  */
-	{ 0x00370000 }, /* GPIO - 59  */
-	{ 0x00000800 }, /* GPIO - 60  */
-	{ 0x00000833 }, /* GPIO - 61  */
-	{ 0x00370000 }, /* GPIO - 62  */
-	{ 0x00370000 }, /* GPIO - 63  */
-	{ 0x00370000 }, /* GPIO - 64  */
-	{ 0x00370000 }, /* GPIO - 65  */
-	{ 0x00370000 }, /* GPIO - 66  */
-};
+/**********************************************************************************************/
 
-/* THB-CRB board default configuration */
-
-static const u32 thb_crb_cfg_modex_regval[67][1] = {
-	{ 0x00000800 },	/* GPIO - 0   */
-	{ 0x00000800 }, /* GPIO - 1   */
-	{ 0x00000800 }, /* GPIO - 2   */
-	{ 0x00000800 }, /* GPIO - 3   */
-	{ 0x00000800 }, /* GPIO - 4   */
-	{ 0x00000800 }, /* GPIO - 5   */
-	{ 0x00000800 }, /* GPIO - 6   */
-	{ 0x00000800 }, /* GPIO - 7   */
-	{ 0x00000900 }, /* GPIO - 8   */
-	{ 0x00000900 }, /* GPIO - 9   */
-	{ 0x00370000 }, /* GPIO - 10  */
-	{ 0x00370000 }, /* GPIO - 11  */
-	{ 0x00370000 }, /* GPIO - 12  */
-	{ 0x00370000 }, /* GPIO - 13  */
-	{ 0x00370100 }, /* GPIO - 14  */
-	{ 0x00370100 }, /* GPIO - 15  */
-	{ 0x00370100 }, /* GPIO - 16  */
-	{ 0x00370100 }, /* GPIO - 17  */
-	{ 0x00170000 }, /* GPIO - 18  */
-	{ 0x00170000 }, /* GPIO - 19  */
-	{ 0x00170000 }, /* GPIO - 20  */
-	{ 0x00170000 }, /* GPIO - 21  */
-	{ 0x00170000 }, /* GPIO - 22  */
-	{ 0x00170000 }, /* GPIO - 23  */
-	{ 0x00170000 }, /* GPIO - 24  */
-	{ 0x00170000 }, /* GPIO - 25  */
-	{ 0x00170000 }, /* GPIO - 26  */
-	{ 0x00170000 }, /* GPIO - 27  */
-	{ 0x00170000 }, /* GPIO - 28  */
-	{ 0x00170000 }, /* GPIO - 29  */
-	{ 0x00170000 }, /* GPIO - 30  */
-	{ 0x00170000 }, /* GPIO - 31  */
-	{ 0x00170000 }, /* GPIO - 32  */
-	{ 0x00170000 }, /* GPIO - 33  */
-	{ 0x00170000 }, /* GPIO - 34  */
-	{ 0x00170000 }, /* GPIO - 35  */
-	{ 0x00170000 }, /* GPIO - 36  */
-	{ 0x00170000 }, /* GPIO - 37  */
-	{ 0x00170000 }, /* GPIO - 38  */
-	{ 0x00170000 }, /* GPIO - 39  */
-	{ 0x00170000 }, /* GPIO - 40  */
-	{ 0x00170000 }, /* GPIO - 41  */
-	{ 0x00170000 }, /* GPIO - 42  */
-	{ 0x00170000 }, /* GPIO - 43  */
-	{ 0x00170000 }, /* GPIO - 44  */
-	{ 0x00170000 }, /* GPIO - 45  */
-	{ 0x00170000 }, /* GPIO - 46  */
-	{ 0x00170000 }, /* GPIO - 47  */
-	{ 0x00170000 }, /* GPIO - 48  */
-	{ 0x00170000 }, /* GPIO - 49  */
-	{ 0x00170000 }, /* GPIO - 50  */
-	{ 0x00170000 }, /* GPIO - 51  */
-	{ 0x00170000 }, /* GPIO - 52  */
-	{ 0x00170000 }, /* GPIO - 53  */
-	{ 0x00170000 }, /* GPIO - 54  */
-	{ 0x00170000 }, /* GPIO - 55  */
-	{ 0x00170000 }, /* GPIO - 56  */
-	{ 0x00170000 }, /* GPIO - 57  */
-	{ 0x00370000 }, /* GPIO - 58  */
-	{ 0x00370000 }, /* GPIO - 59  */
-	{ 0x00000800 }, /* GPIO - 60  */
-	{ 0x00000833 }, /* GPIO - 61  */
-	{ 0x00370000 }, /* GPIO - 62  */
-	{ 0x00370000 }, /* GPIO - 63  */
-	{ 0x00370000 }, /* GPIO - 64  */
-	{ 0x00370000 }, /* GPIO - 65  */
-	{ 0x00370000 }, /* GPIO - 66  */
-};
+/* store Pin status */
+static u32 thb_pinx_status[THB_MAX_NPINS_SUPPORTED] = { 0u };
 
 struct thunderbay_mux_desc {
 	u8 mode;
@@ -324,7 +89,10 @@ struct thunderbay_mux_desc {
 	.name = pin_function,				\
 }							\
 
-#define THUNDERBAY_NUM_IRQ_LINES	8
+struct thunderbay_pin_soc {
+	const struct pinctrl_pin_desc		*pins;
+	unsigned int				npins;
+};
 
 struct thunderbay_pinctrl {
 	struct pinctrl_dev		*pctrl;
@@ -332,40 +100,10 @@ struct thunderbay_pinctrl {
 	struct device			*dev;
 	struct gpio_chip		chip;
 	const struct thunderbay_pin_soc	*soc;
-	int irq[THUNDERBAY_NUM_IRQ_LINES];
-	raw_spinlock_t          lock;
-	const struct thb_pinctrl_group *groups;
 	unsigned int			ngroups;
-	const struct thb_pinmux_function *funcs;
 	unsigned int			nfuncs;
 };
 
-struct thb_pinctrl_group {
-	const char *name;
-	const unsigned int *pins;
-	const unsigned int npins;
-};
-
-struct thb_pinmux_function {
-	const char *name;
-	const char * const *groups;
-	unsigned int ngroups;
-};
-
-struct thunderbay_pin_soc {
-	const struct pinctrl_pin_desc		*pins;
-	unsigned int				npins;
-};
-
-struct gpio_irq_source {
-	bool active;
-	unsigned int source;
-	unsigned int line;
-	unsigned int pins[4];
-	unsigned int trigger;
-	unsigned int gpios_conn;
-};
-
 int thunderbay_pinctrl_probe(struct platform_device *pdev);
 
 #endif /* PINCTRL_THUNDERBAY_H */
-- 
2.27.0

