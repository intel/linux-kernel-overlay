From 87c2a31b705273fab30e5220b29802bccab4c537 Mon Sep 17 00:00:00 2001
From: Sohil Mehta <sohil.mehta@intel.com>
Date: Tue, 28 Jul 2020 16:31:36 -0700
Subject: [PATCH 44/85] Documentation/x86: Add documentation for User
 Interrupts

Only include the hardware and software architecture summary

<The kernel design trade-offs and other information from the cover letter
can eventually be moved to the kernel documentation>

Signed-off-by: Sohil Mehta <sohil.mehta@intel.com>
---
 Documentation/x86/index.rst           |  1 +
 Documentation/x86/user-interrupts.rst | 97 +++++++++++++++++++++++++++
 2 files changed, 98 insertions(+)
 create mode 100644 Documentation/x86/user-interrupts.rst

diff --git a/Documentation/x86/index.rst b/Documentation/x86/index.rst
index cf5250a3cc70..283d023413be 100644
--- a/Documentation/x86/index.rst
+++ b/Documentation/x86/index.rst
@@ -31,6 +31,7 @@ x86-specific Documentation
    resctrl
    tsx_async_abort
    usb-legacy-support
+   user-interrupts
    i386/index
    x86_64/index
    sva
diff --git a/Documentation/x86/user-interrupts.rst b/Documentation/x86/user-interrupts.rst
new file mode 100644
index 000000000000..d73978c68c78
--- /dev/null
+++ b/Documentation/x86/user-interrupts.rst
@@ -0,0 +1,97 @@
+.. SPDX-License-Identifier: GPL-2.0
+
+=======================
+User Interrupts (UINTR)
+=======================
+
+Overview
+========
+User Interrupts provides a low latency event delivery and inter process
+communication mechanism. These events can be delivered directly to userspace
+without a transition through the kernel.
+
+The interrupts can be generated by another userspace task, kernel or a device.
+The feature that allows another task to send inter/intra process interrupt
+(IPI) is referred to as User IPI.
+
+Hardware Summary
+================
+User Interrupts is a posted interrupt delivery mechanism. The interrupts are
+first posted to a memory location and then delivered to the receiver when they
+are running with CPL=3.
+
+Kernel managed architectural data structures
+--------------------------------------------
+UPID: User Posted Interrupt Descriptor - Holds receiver interrupt vector
+information and notification state (like an ongoing notification, suppressed
+notifications).
+
+UITT: User Interrupt Target Table - Stores UPID pointer and vector information
+for interrupt routing on the sender side. Referred by the senduipi instruction.
+
+Instructions
+------------
+senduipi <index> - send a user IPI to a target task based on the UITT index.
+
+clui - Mask user interrupts by clearing UIF (User Interrupt Flag).
+
+stui - Unmask user interrupts by setting UIF.
+
+testui - Test current value of UIF.
+
+uiret - return from a user interrupt handler.
+
+User IPI
+--------
+When a User IPI sender executes 'senduipi <index>' the hardware refers the UITT
+table entry pointed by the index and posts the interrupt vector into the
+receiver's UPID.
+
+If the receiver is running the sender cpu would send a physical IPI to the
+receiver's cpu. On the receiver side this IPI is detected as a User Interrupt.
+The User Interrupt handler for the receiver is invoked and the vector number is
+pushed onto the stack.
+
+Upon execution of 'uiret' in the interrupt handler, the control is transferred
+back to instruction that was interrupted.
+
+Refer the Intel Software Developer's Manual for more details.
+
+Software Architecture
+=====================
+User Interrupts (Uintr) is an opt-in feature (unlike signals). Applications
+wanting to use Uintr are expected to register themselves with the kernel using
+the Uintr related system calls. A Uintr receiver is always a userspace task. A
+Uintr sender can be another userspace task, kernel or a device.
+
+A receiver can register/unregister an interrupt handler using the Uintr
+receiver related syscalls. A syscall also allows a receiver to register a
+vector and create a user interrupt file descriptor - uintr_fd.
+
+User Interrupts can be useful in some of the usages where eventfd or signals
+are used for frequent userspace event notifications. Though uintr_fd is not a
+drop-in replacement, the semantics are meant to be somewhat similar to an
+eventfd or the write end of a pipe. Any sender with access to uintr_fd can use
+it to deliver events (in this case - interrupts) to a receiver.
+
+Using a file descriptor abstraction provides a secure mechanism to connect with
+a receiver. The FD sharing and isolation mechanisms put in place by the kernel
+would apply to User Interrupts as well. This also makes the tracking and
+management of the interrupt vector resource easier for userspace.
+
+A sender task can manage its connection with the receiver using the sender
+related syscalls based on uintr_fd. After the initial setup a sender can use
+the SENDUIPI instruction to generate user IPIs without any kernel intervention.
+
+If the receiver is running (CPL=3), then the user interrupt is delivered
+directly without a kernel transition.  If the receiver isn't running the
+interrupt is delivered when the receiver gets context switched back. If the
+receiver is blocked in the kernel, the user interrupt is delivered to the
+kernel which then unblocks the intended receiver to deliver the interrupt.
+
+If the sender is the kernel or a device, the uintr_fd can be passed onto the
+related kernel entity to allow them to setup a connection and then generate a
+user interrupt for event delivery. <The exact details of this API are still
+being worked upon.>
+
+Refer the Uintr man-pages for details on the syscall interface.
-- 
2.27.0

