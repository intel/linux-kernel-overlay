From 6fe63a352c446b60070ae33f1e0ebf992894ff6f Mon Sep 17 00:00:00 2001
From: Shruthi Sanil <shruthi.sanil@intel.com>
Date: Thu, 25 Feb 2021 16:33:02 +0530
Subject: [PATCH 032/223] GPT and WDT check patch error/warning fixes

Signed-off-by: Shruthi Sanil <shruthi.sanil@intel.com>
---
 .../watchdog/intel,thunderbaybay-wdt.txt      | 19 +++++++++
 drivers/watchdog/thunderbay_wdt.c             | 41 +++++++++++--------
 2 files changed, 42 insertions(+), 18 deletions(-)
 create mode 100644 Documentation/devicetree/bindings/watchdog/intel,thunderbaybay-wdt.txt

diff --git a/Documentation/devicetree/bindings/watchdog/intel,thunderbaybay-wdt.txt b/Documentation/devicetree/bindings/watchdog/intel,thunderbaybay-wdt.txt
new file mode 100644
index 000000000000..77936493a0d7
--- /dev/null
+++ b/Documentation/devicetree/bindings/watchdog/intel,thunderbaybay-wdt.txt
@@ -0,0 +1,19 @@
+Intel Thunder Bay SoC non-secure Watchdog Timer
+
+Required properties:
+
+- compatible: should be "intel,thunderbay-wdt"
+- reg: specifies base physical address and size of the registers
+- interrupts: exactly two interrupts specifier
+- interrupt-names: should contain "threshold" and "timeout"
+- clocks: the clock running the watchdog
+
+Example:
+gpt_wdt: watchdog@8880a09c {
+	compatible = "intel,thunderbay-wdt";
+	reg = <0x0 0x8880a09c 0x0 0xf>;
+	interrupts = <GIC_SPI 1 IRQ_TYPE_LEVEL_HIGH>,
+	             <GIC_SPI 2 IRQ_TYPE_LEVEL_HIGH>;
+	interrupt-names = "threshold","timeout";
+	clocks = <&scmi_clk TIMER_WDT_XTAL_CLK>;
+};
diff --git a/drivers/watchdog/thunderbay_wdt.c b/drivers/watchdog/thunderbay_wdt.c
index 8596901ea122..3f05e82862a7 100644
--- a/drivers/watchdog/thunderbay_wdt.c
+++ b/drivers/watchdog/thunderbay_wdt.c
@@ -50,18 +50,21 @@
 
 static int start_enabled = START_DEFAULT;
 module_param(start_enabled, int, 0);
-MODULE_PARM_DESC(start_enabled, "Watchdog is started on module insertion"
-				"(default = " __MODULE_STRING(START_DEFAULT)")");
+MODULE_PARM_DESC(start_enabled,
+		 "Watchdog is started on module insertion (default = "
+		 __MODULE_STRING(START_DEFAULT)")");
 
 static unsigned int timeout = WATCHDOG_TIMEOUT;
 module_param(timeout, int, 0);
-MODULE_PARM_DESC(timeout, "Watchdog timeout period in seconds"
-			  "(default = " __MODULE_STRING(WATCHDOG_TIMEOUT)")");
+MODULE_PARM_DESC(timeout,
+		 "Watchdog timeout period in seconds (default = "
+		 __MODULE_STRING(WATCHDOG_TIMEOUT)")");
 
 static bool nowayout = WATCHDOG_NOWAYOUT;
 module_param(nowayout, bool, 0);
-MODULE_PARM_DESC(nowayout, "Watchdog cannot be stopped once started"
-			   "(default = " __MODULE_STRING(WATCHDOG_NOWAYOUT)")");
+MODULE_PARM_DESC(nowayout,
+		 "Watchdog cannot be stopped once started (default = "
+		 __MODULE_STRING(WATCHDOG_NOWAYOUT) ")");
 
 struct thunderbay_wdt {
 	void __iomem *reg_base;
@@ -123,6 +126,7 @@ static int thunderbay_wdt_set_timeout(struct watchdog_device *wdog, u32 t)
 {
 	struct thunderbay_wdt *wdt = watchdog_get_drvdata(wdog);
 	u32 actual = min(t, wdog->max_timeout);
+
 	wdog->timeout = actual;
 
 	thunderbay_wdt_writel(wdt, TIM_WATCHDOG, wdog->timeout * wdt->rate);
@@ -132,7 +136,7 @@ static int thunderbay_wdt_set_timeout(struct watchdog_device *wdog, u32 t)
 
 static int thunderbay_wdt_set_pretimeout(struct watchdog_device *wdog, u32 t)
 {
-	if ((t != 0) && (t < wdog->min_timeout || t >= wdog->timeout))
+	if (t != 0 && (t < wdog->min_timeout || t >= wdog->timeout))
 		return -EINVAL;
 
 	wdog->pretimeout = t;
@@ -165,7 +169,7 @@ static irqreturn_t thunderbay_wdt_to_isr(int irq, void *dev_id)
 {
 	struct arm_smccc_res res;
 
-	// clear bit 9 (WDOG_TO_INT_CLR)
+	/* clear bit 9 (WDOG_TO_INT_CLR) */
 	if (IS_ENABLED(CONFIG_HAVE_ARM_SMCCC))
 		arm_smccc_smc(0x8200ff18, 0x200, 0, 0, 0, 0, 0, 0, &res);
 
@@ -178,7 +182,7 @@ static irqreturn_t thunderbay_wdt_to_isr(int irq, void *dev_id)
 	 * Print critical log message, and reboot.
 	 */
 	pr_crit("Intel Thunder Bay non-secure watchdog timeout.\n");
-//	emergency_restart();
+	emergency_restart();
 
 	return IRQ_HANDLED;
 }
@@ -188,10 +192,12 @@ static irqreturn_t thunderbay_wdt_th_isr(int irq, void *dev_id)
 	struct thunderbay_wdt *wdt = (struct thunderbay_wdt *)dev_id;
 	struct arm_smccc_res res;
 
-	//Set Pre-Timeout to Zero to avoid th interrupt getting trigerred for every tick until timeout
+	/* Set Pre-Timeout to Zero to avoid th interrupt getting triggered
+	 * for every tick until timeout
+	 */
 	thunderbay_wdt_set_pretimeout(&wdt->wdd, 0);
 
-	// clear bit 8 (WDOG_TH_INT_CLR)
+	/* clear bit 8 (WDOG_TH_INT_CLR) */
 	if (IS_ENABLED(CONFIG_HAVE_ARM_SMCCC))
 		arm_smccc_smc(0x8200ff18, 0x100, 0, 0, 0, 0, 0, 0, &res);
 
@@ -234,10 +240,8 @@ static int thunderbay_wdt_probe(struct platform_device *pdev)
 	int ret;
 
 	wdt = devm_kzalloc(dev, sizeof(*wdt), GFP_KERNEL);
-	if (!wdt) {
-		dev_err(dev, "Failed to allocate memory.\n");
+	if (!wdt)
 		return -ENOMEM;
-	}
 
 	wdt->reg_base = devm_platform_ioremap_resource(pdev, 0);
 	if (IS_ERR(wdt->reg_base))
@@ -245,8 +249,10 @@ static int thunderbay_wdt_probe(struct platform_device *pdev)
 
 	wdt->clk = devm_clk_get(dev, NULL);
 	if (IS_ERR(wdt->clk)) {
-		dev_err(dev, "Clock not found.\n");
-		return PTR_ERR(wdt->clk);
+		ret = PTR_ERR(wdt->clk);
+		if (ret != -EPROBE_DEFER)
+			dev_err(dev, "Clock not found.\n");
+		return ret;
 	}
 
 	wdt->rate = clk_get_rate(wdt->clk);
@@ -303,8 +309,7 @@ static int thunderbay_wdt_probe(struct platform_device *pdev)
 	dev_info(dev, "Initial timeout %d sec%s\n",
 		 wdt->wdd.timeout, nowayout ? ", nowayout." : ".");
 
-	if(start_enabled)
-	{
+	if (start_enabled) {
 		wdt->wdd.status = 3;
 		thunderbay_wdt_start(&wdt->wdd);
 	}
-- 
2.27.0

