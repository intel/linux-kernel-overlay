From f13dc9d98541aabceb81254ff90c581a1c56d53a Mon Sep 17 00:00:00 2001
From: Gayatri Kammela <gayatri.kammela@intel.com>
Date: Sun, 21 Feb 2021 20:57:35 -0800
Subject: [PATCH 35/47] platform/x86: intel_pmc_core: Add requirements file to
 debugfs

Just like status registers, Tiger Lake has another set of 6 registers
called requirement registers per each sub-state. These registers are
not memory mapped and thus saved their contents in an array for easy
access via ACPI DSM method. Accessing these registers contents is useful
for debugging any low power related activities.

Thus, add debugfs entry to access the contents of low power mode
requirement registers.

After this patch, the debugfs file looks like this:

Cc: Mark Gross <mark.gross@intel.com>
Cc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Cc: Srinivas Pandruvada <srinivas.pandruvada@intel.com>
Co-developed-by: David E. Box <david.e.box@linux.intel.com>
Signed-off-by: David E. Box <david.e.box@linux.intel.com>
Signed-off-by: Gayatri Kammela <gayatri.kammela@intel.com>
---
 drivers/platform/x86/intel_pmc_core.c | 96 +++++++++++++++++++++++++++
 1 file changed, 96 insertions(+)

diff --git a/drivers/platform/x86/intel_pmc_core.c b/drivers/platform/x86/intel_pmc_core.c
index 1a70bb4505fc..d5f03ce0ead5 100644
--- a/drivers/platform/x86/intel_pmc_core.c
+++ b/drivers/platform/x86/intel_pmc_core.c
@@ -1143,6 +1143,99 @@ static int pmc_core_substate_l_sts_regs_show(struct seq_file *s, void *unused)
 }
 DEFINE_SHOW_ATTRIBUTE(pmc_core_substate_l_sts_regs);
 
+static void pmc_core_substate_req_header_show(struct seq_file *s)
+{
+	struct pmc_dev *pmcdev = s->private;
+	int p;
+
+	seq_printf(s, "%30s |", "Element");
+	for (p = LPM_MAX_NUM_MODES - 1; p >= 0; p--) {
+		int mode = pmcdev->lpm_mode_priority[p];
+
+		if (!pmc_core_substate_enabled(pmcdev, mode))
+			continue;
+		else
+			seq_printf(s, " %9s |", pmc_lpm_modes[mode]);
+	}
+	seq_printf(s, " %9s |\n", "Status");
+}
+
+static int pmc_core_lpm_req_display(struct seq_file *s)
+{
+	struct pmc_dev *pmcdev = s->private;
+	const struct pmc_bit_map **maps = pmcdev->map->lpm_sts;
+	const struct pmc_bit_map *map;
+	const int num_maps = pmcdev->map->lpm_num_maps;
+	u32 offset = pmcdev->map->lpm_status_offset;
+	u32 *lpm_req_regs = pmcdev->lpm_req_regs;
+	int i, mp, md, len = 32;
+
+	/* Display the header */
+	pmc_core_substate_req_header_show(s);
+
+	/* Look over IP maps */
+	for (mp = 0; mp < num_maps; mp++) {
+		u32 req_mask = 0;
+		u32 lpm_status;
+		/*
+		 * Capture the requirements and create a mask so that we only
+		 * show an element if it's required for at least one of the
+		 * enabled low power modes
+		 */
+		for (md = 0; md < LPM_MAX_NUM_MODES; md++) {
+			if (!pmc_core_substate_enabled(pmcdev, md))
+				continue;
+			req_mask |= lpm_req_regs[mp + (md * num_maps)];
+		}
+
+		map = maps[mp];
+		lpm_status = pmc_core_reg_read(pmcdev, offset + (mp * 4));
+		for (i = 0; map[i].name && i < len; i++) {
+			u32 bit_mask = map[i].bit_mask;
+			int p;
+
+			if (!(bit_mask & req_mask))
+				/* not required for any enabled state */
+				continue;
+
+			/* Display the element name in the first column */
+			seq_printf(s, "%30s |", map[i].name);
+
+			/* Display if element is required for enabled state */
+			for (p = LPM_MAX_NUM_MODES - 1; p >= 0; p--) {
+				int mode = pmcdev->lpm_mode_priority[p];
+
+				if (!pmc_core_substate_enabled(pmcdev, mode))
+					continue;
+
+				if (lpm_req_regs[mp + (mode * num_maps)] & bit_mask)
+					seq_printf(s, " %9s |",
+						   "Required");
+				else
+					seq_printf(s, " %9s |", " ");
+
+			}
+
+			if (lpm_status & bit_mask)
+				seq_printf(s, " %9s |", "Yes");
+			else
+				seq_printf(s, " %9s |", " ");
+
+			seq_puts(s, "\n");
+		}
+	}
+
+	return 0;
+}
+
+static int pmc_core_substate_req_regs_show(struct seq_file *s, void *unused)
+{
+	pmc_core_lpm_req_display(s);
+
+	return 0;
+}
+DEFINE_SHOW_ATTRIBUTE(pmc_core_substate_req_regs);
+
 static int pmc_core_pkgc_show(struct seq_file *s, void *unused)
 {
 	struct pmc_dev *pmcdev = s->private;
@@ -1241,6 +1334,9 @@ static void pmc_core_dbgfs_register(struct pmc_dev *pmcdev)
 		debugfs_create_file("substate_live_status_registers", 0444,
 				    pmcdev->dbgfs_dir, pmcdev,
 				    &pmc_core_substate_l_sts_regs_fops);
+		debugfs_create_file("substate_requirements", 0444,
+				    pmcdev->dbgfs_dir, pmcdev,
+				    &pmc_core_substate_req_regs_fops);
 	}
 }
 
-- 
2.27.0

