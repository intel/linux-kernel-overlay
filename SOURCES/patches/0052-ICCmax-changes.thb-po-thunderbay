From 0e33a443b3dc0235875b6ba42f4734f523e88f7e Mon Sep 17 00:00:00 2001
From: sandeep singh <sandeep1.singh@intel.com>
Date: Fri, 16 Oct 2020 16:25:23 +0530
Subject: [PATCH 052/223] ICCmax changes

Debugfs interface for ICCMax throttling

Signed-off-by: sandeep singh <sandeep1.singh@intel.com>
---
 .../misc/intel_tsens/intel_tsens_thermal.c    | 289 ++++++++++++++++++
 1 file changed, 289 insertions(+)

diff --git a/drivers/misc/intel_tsens/intel_tsens_thermal.c b/drivers/misc/intel_tsens/intel_tsens_thermal.c
index d0eefbd60aa1..cc63b9e1b238 100644
--- a/drivers/misc/intel_tsens/intel_tsens_thermal.c
+++ b/drivers/misc/intel_tsens/intel_tsens_thermal.c
@@ -18,6 +18,7 @@
 #include <linux/of.h>
 #include <linux/slab.h>
 #include <linux/thermal.h>
+#include <linux/debugfs.h> /* this is for DebugFS libraries */
 #include "intel_tsens_thermal.h"
 
 struct intel_tsens_trip_info {
@@ -53,6 +54,43 @@ struct intel_tsens_priv {
 	struct intel_tsens_plat_info plat_info;
 };
 
+struct intel_iccmax {
+char name[20];
+u64 addr;
+u64 size;
+void __iomem *base_addr;
+};
+
+struct intel_icc_config {
+	int n_iccmax;
+	bool polarity;
+	struct intel_iccmax **intel_iccmax;
+	void __iomem *base_addr;
+	u64 addr;
+	u64 size;
+	u32 set_polarity;
+};
+
+static struct dentry *dir;
+
+struct debugfs_data {
+	void __iomem *base_addr;
+	u32 offset;
+	u32 data;
+	char name[20];
+};
+
+static const mode_t ICC_MODE = 0600;
+struct debugfs_data *debugfs_data;
+struct intel_icc_config *icc_config;
+
+#define len 200
+u64 current_base_addr;
+char offset[len];
+char reg_data[len];
+
+static int g_nsens;
+static struct intel_tsens **g_intel_tsens;
 static int intel_tsens_register_pdev(struct intel_tsens_plat_info *plat_info)
 {
 	struct intel_tsens_plat_data plat_data;
@@ -352,6 +390,254 @@ static int intel_tsens_config_sensors(struct device_node *s_node,
 	return 0;
 }
 
+/**
+ * ICC_MAX Debug-fs.
+ *
+ * Hierarchy schema:
+ * /sys/kernel/debug/
+ *        /intel_iccmax
+ *        /intel_iccmax/iccmax_cpuss		dir with different iccmax cpuss
+ *        /intel_iccmax/iccmax_cpuss/offset	read/write offset value for register
+ *        /intel_iccmax/iccmax_cpuss/data	data to be written on registers write only
+ *        /intel_iccmax/iccmax_cpuss/set_data	read-only it will write data to reg+offset
+ *						and return 1 for success
+ */
+
+static int base_addr_reader(struct inode *inode, struct file *file)
+{
+	current_base_addr = inode->i_private;
+	return 0;
+}
+
+static ssize_t offset_read_op(struct file *file, char __user *buf,
+			      size_t count, loff_t *ppos)
+{
+	return simple_read_from_buffer(buf, count, ppos, offset, len);
+}
+
+static ssize_t offset_write_op(struct file *file, const char __user *buf,
+			       size_t count, loff_t *ppos)
+{
+	if (count > len)
+		return -EINVAL;
+	return simple_write_to_buffer(offset, len, ppos, buf, count);
+}
+
+static ssize_t reg_data_read_op(struct file *file, char __user *buf,
+				size_t count, loff_t *ppos)
+{
+	return simple_read_from_buffer(buf, count, ppos, reg_data, len);
+}
+
+static ssize_t reg_data_write_op(struct file *file, const char __user *buf,
+				 size_t count, loff_t *ppos)
+{
+	if (count > len)
+		return -EINVAL;
+	return simple_write_to_buffer(reg_data, len, ppos, buf, count);
+}
+
+static const struct file_operations reg_offset_fops = {
+	.open		= base_addr_reader,
+	.read		= offset_read_op,
+	.write		= offset_write_op,
+};
+
+static const struct file_operations reg_data_fops = {
+	.open		= base_addr_reader,
+	.read		= reg_data_read_op,
+	.write		= reg_data_write_op,
+};
+
+static int set_data(int reg_offset, int data)
+{
+	void __iomem *reg = current_base_addr;
+
+	iowrite32(data, reg + reg_offset);
+	return 0;
+}
+
+static int set_write_op(void *data, u64 *value)
+{
+	int ret;
+	int local_offset, local_reg_data;
+
+	ret = kstrtou32(offset, 0, &local_offset);
+	if (ret)
+		return -EINVAL;
+	ret = kstrtou32(reg_data, 0, &local_reg_data);
+	if (ret)
+		return -EINVAL;
+	ret = set_data(local_offset, local_reg_data);
+	*value = 1;
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(set_fops, set_write_op, NULL, "%llu\n");
+
+static int intel_iccmax_config_dt(struct intel_tsens_priv *priv)
+{
+	struct platform_device *pdev = priv->pdev;
+	struct device_node *np;
+	struct device_node *s_node;
+	struct dentry *icc_debug, *icc_debug_value;
+	int i = 0;
+	u64 base;
+
+	np = of_parse_phandle(pdev->dev.of_node, "icc_max", 0);
+	if (!np)
+		return NULL;
+	dir = debugfs_create_dir("intel_iccmax", 0);
+	if (!dir) {
+		// Abort module load.
+		pr_info("debugfs_example2: failed to create /sys/kernel/debug/intel_iccmax\n");
+		return -1;
+	}
+
+	int icc_reg_count, icc_size_count;
+
+	icc_config = devm_kzalloc(&pdev->dev,
+				  sizeof(struct intel_icc_config),
+				  GFP_KERNEL);
+	if (!icc_config) {
+		dev_err(&pdev->dev, "Memory alloc failed for %s\n",
+			s_node->name);
+	}
+
+	of_property_read_u32(np, "address-cells", &icc_reg_count);
+	of_property_read_u32(np, "size-cells", &icc_size_count);
+	if (icc_reg_count > 1)
+		of_property_read_u64_index(np, "reg", 0, &icc_config->addr);
+	else
+		of_property_read_u32_index(np, "reg", 0, (u32 *)&icc_config->addr);
+
+	if (icc_size_count > 1) {
+		int index = (icc_reg_count > 1) ? (icc_reg_count / 2) : icc_reg_count;
+
+		of_property_read_u64_index(np, "reg", index, &icc_config->size);
+	} else {
+		of_property_read_u32_index(np, "reg", icc_reg_count, (u32 *)&icc_config->size);
+	}
+	icc_config->base_addr = devm_ioremap(&pdev->dev,
+					     icc_config->addr,
+					     icc_config->size);
+
+	icc_config->n_iccmax = of_get_child_count(np);
+
+	//struct debugfs_data *debugfs_data[icc_config->n_iccmax ];
+
+	icc_config->polarity = of_property_read_bool(np, "polarity");
+	if (icc_config->polarity) {
+		of_property_read_u32_index(np, "polarity", 0, &icc_config->set_polarity);
+		iowrite32(icc_config->set_polarity, icc_config->base_addr + icc_config->size);
+	}
+
+	if (icc_config->n_iccmax == 0) {
+		dev_err(&pdev->dev, "No iccmax configured in dt\n");
+		return -EINVAL;
+	}
+	icc_config->intel_iccmax = devm_kzalloc(&pdev->dev,
+						(sizeof(struct intel_iccmax *) *
+						icc_config->n_iccmax),
+						GFP_KERNEL);
+	for_each_child_of_node(np, s_node) {
+		int reg_count, size_count;
+
+		icc_config->intel_iccmax[i] = devm_kzalloc(&pdev->dev,
+							   sizeof(struct intel_iccmax),
+							   GFP_KERNEL);
+		if (!icc_config->intel_iccmax[i]) {
+			dev_err(&pdev->dev, "Memory alloc failed for %s\n",
+				s_node->name);
+			i--;
+			goto free_iccmax;
+		}
+		strcpy(icc_config->intel_iccmax[i]->name, s_node->name);
+		if (!of_property_read_u32(s_node, "address-cells", &reg_count) &&
+		    !of_property_read_u32(s_node, "size-cells",	&size_count)) {
+			if (reg_count > 1) {
+				of_property_read_u64_index(s_node, "reg", 0,
+							   &icc_config->intel_iccmax[i]->addr);
+			} else {
+				of_property_read_u32_index(s_node, "reg", 0,
+							   (u32 *)
+							   &icc_config->intel_iccmax[i]->addr);
+			}
+			if (size_count > 1) {
+				int index = (reg_count > 1) ? (reg_count / 2) : reg_count;
+
+				of_property_read_u64_index(s_node, "reg", index,
+							   &icc_config->intel_iccmax[i]->size);
+			} else {
+				of_property_read_u32_index(s_node, "reg",
+							   reg_count,
+							   (u32 *)
+							   &icc_config->intel_iccmax[i]->size);
+			}
+			dev_info(&pdev->dev, "address %llx\n", icc_config->intel_iccmax[i]->addr);
+			dev_info(&pdev->dev, "size %llx\n", icc_config->intel_iccmax[i]->size);
+			icc_config->intel_iccmax[i]->base_addr =
+				devm_ioremap(&pdev->dev,
+					     icc_config->intel_iccmax[i]->addr,
+					     icc_config->intel_iccmax[i]->size);
+		} else {
+			icc_config->intel_iccmax[i]->base_addr = icc_config->base_addr;
+		}
+		if (!icc_config->intel_iccmax[i]->base_addr) {
+			dev_err(&pdev->dev, "ioremap failed for %s\n",
+				icc_config->intel_iccmax[i]->name);
+			goto unmap;
+		}
+		icc_debug = debugfs_create_dir(icc_config->intel_iccmax[i]->name, dir);
+		if (!icc_debug) {
+			// Abort module load.
+			pr_info("failed to create dir\n");
+			return -1;
+		}
+		base = icc_config->intel_iccmax[i]->base_addr;
+		icc_debug_value = debugfs_create_file("reg_offset",
+						      ICC_MODE,
+						      icc_debug,
+						      base,
+						      &reg_offset_fops);
+		if (!icc_debug_value) {
+			// Abort module load.
+			pr_info(" failed to create file\n");
+			return -1;
+		}
+		icc_debug_value = debugfs_create_file("reg_data",
+						      ICC_MODE,
+						      icc_debug,
+						      base,
+						      &reg_data_fops);
+		if (!icc_debug_value) {
+			// Abort module load.
+			pr_info(" failed to create /sys/kernel/debug/intel_iccmax/reg_data\n");
+			return -1;
+		}
+		//icc_config->intel_iccmax[i]->pdata = icc_config;
+		icc_debug_value = debugfs_create_file("set_data",
+						      ICC_MODE,
+						      icc_debug,
+						      NULL,
+						      &set_fops);
+		if (!icc_debug_value) {
+			// Abort module load.
+			pr_info(" failed to create /sys/kernel/debug/intel_iccmax/reg_data\n");
+			return -1;
+		}
+		i++;
+		}
+		return 0;
+
+unmap:
+free_iccmax:
+		while (i >= 0)
+			devm_kfree(&pdev->dev, icc_config->intel_iccmax[i--]);
+			devm_kfree(&pdev->dev, icc_config->intel_iccmax);
+		return -EINVAL;
+}
+
 static int intel_tsens_config_dt(struct intel_tsens_priv *priv)
 {
 	struct platform_device *pdev = priv->pdev;
@@ -499,6 +785,9 @@ static int intel_tsens_thermal_probe(struct platform_device *pdev)
 	}
 	platform_set_drvdata(pdev, intel_tsens_priv);
 	i2c_plat_data.pdata = intel_tsens_priv;
+
+	ret = intel_iccmax_config_dt(intel_tsens_priv);
+
 	return 0;
 
 remove_tz:
-- 
2.27.0

