From 5b9b75a549efb9600f7ee81ad0552281a23c6355 Mon Sep 17 00:00:00 2001
From: Srikanth Thokala <srikanth.thokala@intel.com>
Date: Fri, 12 Feb 2021 11:22:49 +0530
Subject: [PATCH 040/223] ras: misc: Prepare RAS driver for upstreaming

- Fix checkpatch issues
- Copyright header and year

Signed-off-by: Srikanth Thokala <srikanth.thokala@intel.com>
---
 drivers/misc/xbay_ras/cortex_a53_edac.c  | 28 ++++---------
 drivers/misc/xbay_ras/csram_edac.c       | 39 ++++++------------
 drivers/misc/xbay_ras/ras_core.c         | 39 +++++++-----------
 drivers/misc/xbay_ras/ras_core.h         | 14 +------
 drivers/misc/xbay_ras/snps_lpddr_edac.c  | 51 ++++++++++--------------
 drivers/misc/xbay_ras/snps_pcie_rasdes.c | 20 ++--------
 6 files changed, 59 insertions(+), 132 deletions(-)

diff --git a/drivers/misc/xbay_ras/cortex_a53_edac.c b/drivers/misc/xbay_ras/cortex_a53_edac.c
index 6b3118439463..f31181ee5333 100644
--- a/drivers/misc/xbay_ras/cortex_a53_edac.c
+++ b/drivers/misc/xbay_ras/cortex_a53_edac.c
@@ -2,22 +2,10 @@
 /*
  * Intel xBay RAS: CPU EDAC SW
  *
- * Copyright (C) 2020 Intel Corporation
+ * Copyright (C) 2021 Intel Corporation
  *
  * Code used from:
  *  https://lwn.net/Articles/662208/
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2, as published
- * by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, see <http://www.gnu.org/licenses/>.
  */
 
 #include <linux/cpu.h>
@@ -56,11 +44,11 @@
 #define EDAC_MOD_STR			DRV_NAME
 
 /* Error injectin macros*/
-#define L1_DCACHE_ERRINJ_ENABLE		(1 << 6)
+#define L1_DCACHE_ERRINJ_ENABLE		BIT(6)
 #define L1_DCACHE_ERRINJ_DISABLE	(~(1 << 6))
-#define L2_DCACHE_ERRINJ_ENABLE		(1 << 29)
+#define L2_DCACHE_ERRINJ_ENABLE		BIT(29)
 #define L2_DCACHE_ERRINJ_DISABLE	(~(1 << 29))
-#define L2_ECC_PROTECTION		(1 << 22)
+#define L2_ECC_PROTECTION		BIT(22)
 
 static struct cpu_edac_info_t
 	cpu_edac_info[NUM_CACHES];
@@ -121,7 +109,6 @@ static inline u64 read_l2ctlr_el1(void)
 
 	asm volatile("mrs %0,  S3_1_C11_C0_2" : "=r" (rval));
 	return rval;
-
 }
 
 static inline u64 read_l1actrl_el1(void)
@@ -336,11 +323,11 @@ static ssize_t tst_cpu_edac_sw_inj_store(struct device *dev,
 	struct cpu_edac_info_t *e_sts = NULL;
 	int cache_id;
 
-	if (strncmp(data, "L1", 2) == 0)
+	if (strncmp(data, "L1", 2) == 0) {
 		cache_id = 0;
-	else if (strncmp(data, "L2", 2) == 0)
+	} else if (strncmp(data, "L2", 2) == 0) {
 		cache_id = 1;
-	else {
+	} else {
 		dev_err(&pdev->dev, "Invalid options chosen\n");
 		dev_err(&pdev->dev, "L1, L2 are available\n");
 		return -EINVAL;
@@ -406,5 +393,4 @@ int xbay_cortex_a53_edac_probe(struct platform_device *pdev,
 		 "ARM Cortex a53 EDAC module probed Successfully\n");
 
 	return 0;
-
 }
diff --git a/drivers/misc/xbay_ras/csram_edac.c b/drivers/misc/xbay_ras/csram_edac.c
index 25e1b224c39e..755a8a7f709c 100644
--- a/drivers/misc/xbay_ras/csram_edac.c
+++ b/drivers/misc/xbay_ras/csram_edac.c
@@ -2,19 +2,7 @@
 /*
  * Intel xBay RAS: Synopsys CSRAM ECC SW
  *
- * Copyright (C) 2020 Intel Corporation
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2, as published
- * by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ * Copyright (C) 2021 Intel Corporation
  */
 
 #include "ras_core.h"
@@ -64,11 +52,11 @@ static void csram_edac_print_info(struct platform_device *pdev)
 
 		dev_dbg(&pdev->dev, "CSRAM Bank %d Statistics :\n", bank_num);
 		dev_dbg(&pdev->dev, "SBIT: %d DBIT: %d\n",
-				     e_sts->sbit_cnt, e_sts->dbit_cnt);
+			e_sts->sbit_cnt, e_sts->dbit_cnt);
 		dev_dbg(&pdev->dev, "Error @Acsramess: %llx\n",
-				     e_sts->err_acsramess);
+			e_sts->err_acsramess);
 		dev_dbg(&pdev->dev, "Error status: %08x\n",
-				     e_sts->err_status);
+			e_sts->err_status);
 	}
 }
 #endif
@@ -134,23 +122,23 @@ static ssize_t tst_csram_edac_inj_error_store(struct device *dev,
 	struct platform_device *pdev = to_pdev(dev);
 	u32 inj_error_val = 0;
 
-	if (strncmp(data, "Parity", 6) == 0)
+	if (strncmp(data, "Parity", 6) == 0) {
 		inj_error_val = ERR_INJ_PARITY;
-	else if (strncmp(data, "DecBG", 5) == 0)
+	} else if (strncmp(data, "DecBG", 5) == 0) {
 		inj_error_val = ERR_INJ_DEC_BG;
-	else if (strncmp(data, "DecFG", 5) == 0)
+	} else if (strncmp(data, "DecFG", 5) == 0) {
 		inj_error_val = ERR_INJ_DEC_FG;
-	else if (strncmp(data, "BG", 2) == 0)
+	} else if (strncmp(data, "BG", 2) == 0) {
 		inj_error_val = ERR_INJ_BG;
-	else if (strncmp(data, "FG", 2) == 0)
+	} else if (strncmp(data, "FG", 2) == 0) {
 		inj_error_val = ERR_INJ_FG;
-	else {
+	} else {
 		dev_err(&pdev->dev, "Invalid option chosen\n");
 		return 0;
 	}
 
 	dev_dbg(&pdev->dev, "Injecting %08x error on CSRAM ...\n",
-			     inj_error_val);
+		inj_error_val);
 	writel(inj_error_val, csram_edac_base[0] + ERR_INJ);
 
 	return count;
@@ -240,8 +228,8 @@ int xbay_csram_edac_probe(struct platform_device *pdev, struct device_node *np)
 
 	if (num_banks > THB_CSRAM_BANK_NUM) {
 		dev_err(&pdev->dev, "Expected CSRAM Banks %d, but got %d\n",
-					THB_CSRAM_BANK_NUM,
-					num_banks);
+			THB_CSRAM_BANK_NUM,
+			num_banks);
 		return -EINVAL;
 	}
 
@@ -285,7 +273,6 @@ int xbay_csram_edac_probe(struct platform_device *pdev, struct device_node *np)
 				csram_edac_irq[i]);
 			return err;
 		}
-
 	}
 
 	err = sysfs_create_group(&pdev->dev.kobj, &csram_edac_attributes);
diff --git a/drivers/misc/xbay_ras/ras_core.c b/drivers/misc/xbay_ras/ras_core.c
index f57984db1fb0..b82d9eb00d7c 100644
--- a/drivers/misc/xbay_ras/ras_core.c
+++ b/drivers/misc/xbay_ras/ras_core.c
@@ -2,19 +2,7 @@
 /*
  * Intel xBay RAS Collector Driver
  *
- * Copyright (C) 2020 Intel Corporation
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2, as published
- * by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ * Copyright (C) 2021 Intel Corporation
  */
 
 #include <linux/wait.h>
@@ -66,17 +54,17 @@ static ssize_t ras_get_edac_info(struct file *filp, struct kobject *kobj,
 					 (record_last_edac_err != 0));
 		memcpy(buf + EDAC_STS_OFF, &record_last_edac_err, EDAC_STS_SZ);
 		return count;
-	} else if (count == DDR_EDAC_INFO_SZ)
+	} else if (count == DDR_EDAC_INFO_SZ) {
 		read_map |= RAS_DDR_EDAC_BMAP;
-	else if (count == CSRAM_EDAC_INFO_SZ)
+	} else if (count == CSRAM_EDAC_INFO_SZ) {
 		read_map |= RAS_CSRAM_EDAC_BMAP;
-	else if (count == CPU_EDAC_INFO_SZ)
+	} else if (count == CPU_EDAC_INFO_SZ) {
 		read_map |= RAS_CPU_EDAC_BMAP;
-	else if (count == WDOG_INFO_SZ)
+	} else if (count == WDOG_INFO_SZ) {
 		read_map |= RAS_WDOG_EDAC_BMAP;
-	else if (count == TOTAL_INFO_SZ)
+	} else if (count == TOTAL_INFO_SZ) {
 		read_map |= RAS_ALL_EDAC_BMAP;
-	else {
+	} else {
 		dev_warn(&pdev->dev, "Invalid length to read\n");
 		return -EINVAL;
 	}
@@ -132,15 +120,15 @@ static ssize_t tst_set_ras_interrupt_store(struct device *dev,
 	u32 val = 0;
 	unsigned long flags;
 
-	if (strncmp(data, "DDR", 3) == 0)
+	if (strncmp(data, "DDR", 3) == 0) {
 		val = RAS_TST_DDR_INTR;
-	else if (strncmp(data, "CSRAM", 5) == 0)
+	} else if (strncmp(data, "CSRAM", 5) == 0) {
 		val = RAS_TST_CSRAM_INTR;
-	else if (strncmp(data, "CPU", 3) == 0)
+	} else if (strncmp(data, "CPU", 3) == 0) {
 		val = RAS_TST_CPU_INTR;
-	else if (strncmp(data, "WDOG", 4) == 0)
+	} else if (strncmp(data, "WDOG", 4) == 0) {
 		val = RAS_RESV_WDOG_INTR;
-	else {
+	} else {
 		dev_err(&pdev->dev, "Invalid options chosen\n");
 		dev_err(&pdev->dev,
 			"DDR, CSRAM, CPU, WDOG available\n");
@@ -164,7 +152,8 @@ static ssize_t tst_clear_edac_info_store(struct device *dev,
 {
 	struct platform_device *pdev = to_pdev(dev);
 
-	record_last_edac_err = ns_wdog_sts = 0;
+	record_last_edac_err = 0;
+	ns_wdog_sts = 0;
 	xbay_ddr_edac_clear_all_info(pdev, DDR_EDAC_INFO_SZ);
 	xbay_csram_edac_clear_all_info(pdev, CSRAM_EDAC_INFO_SZ);
 	xbay_cpu_edac_clear_all_info(pdev, CPU_EDAC_INFO_SZ);
diff --git a/drivers/misc/xbay_ras/ras_core.h b/drivers/misc/xbay_ras/ras_core.h
index ffabec91afe8..c8a43d52b0c5 100644
--- a/drivers/misc/xbay_ras/ras_core.h
+++ b/drivers/misc/xbay_ras/ras_core.h
@@ -2,19 +2,7 @@
 /*
  * Intel xBay RAS: Core Header file
  *
- * Copyright (C) 2020 Intel Corporation
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2, as published
- * by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ * Copyright (C) 2021 Intel Corporation
  */
 
 #include <linux/io.h>
diff --git a/drivers/misc/xbay_ras/snps_lpddr_edac.c b/drivers/misc/xbay_ras/snps_lpddr_edac.c
index 66be9dec5431..d5d4e666a176 100644
--- a/drivers/misc/xbay_ras/snps_lpddr_edac.c
+++ b/drivers/misc/xbay_ras/snps_lpddr_edac.c
@@ -2,22 +2,10 @@
 /*
  * Intel xBay RAS: Synopsys DDR ECC SW
  *
- * Copyright (C) 2020 Intel Corporation
+ * Copyright (C) 2021 Intel Corporation
  *
  * Code referred from:
  * drivers/edac/synopsys_edac.c
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2, as published
- * by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, see <http://www.gnu.org/licenses/>.
  */
 
 #include "ras_core.h"
@@ -77,7 +65,7 @@ static int ddr_edac_irq[THB_DDR_SLICE_NUM][THB_DDR_MCS_PER_SLICE];
 static u32 num_slices, num_mcs_per_slice;
 
 static int ddr_edac_clear_err(struct platform_device *pdev,
-				   int slice_id, int mc_id)
+			      int slice_id, int mc_id)
 {
 	void __iomem *base;
 
@@ -95,40 +83,40 @@ static int ddr_edac_clear_err(struct platform_device *pdev,
 
 #if defined(DEBUG_RAS_DDR) && defined(DEBUG_DDR_HW_INJ)
 static void ddr_edac_print_info(struct platform_device *pdev,
-				    int slice_id, int mc_id)
+				int slice_id, int mc_id)
 {
 	struct ddr_edac_status_t *e_sts;
 	struct ddr_edac_err_info_t *e_info = NULL;
 
 	if (slice_id >= num_slices || mc_id >= num_mcs_per_slice) {
 		dev_err(&pdev->dev, "Invalid DDR ECC Slice %d MC %d\n",
-				    slice_id, mc_id);
+			slice_id, mc_id);
 		return;
 	}
 
 	e_sts = &ddr_edac_status[slice_id][mc_id];
 
 	dev_info(&pdev->dev, "DDR ECC Slice %d MC %d Statistics :\n",
-			     slice_id, mc_id);
+		 slice_id, mc_id);
 	dev_info(&pdev->dev, "CE: %d UE: %d\n", e_sts->ce_cnt, e_sts->ue_cnt);
 	dev_info(&pdev->dev, "CE Statistics :\n");
 	e_info = &e_sts->ce_info;
 	dev_info(&pdev->dev, "BitPos %d\n", e_info->bit_pos);
 	dev_info(&pdev->dev, "Row %d Bank %d Bank Group %d Block %d\n",
-			     e_info->row, e_info->bank,
-			     e_info->bank_grp_num, e_info->blk_num);
+		 e_info->row, e_info->bank,
+		 e_info->bank_grp_num, e_info->blk_num);
 	dev_info(&pdev->dev, "Data Pattern: %08x\n", e_info->data_pattern);
 	dev_info(&pdev->dev, "UE Statistics :\n");
 	e_info = &e_sts->ue_info;
 	dev_info(&pdev->dev, "Row %d Bank %d Bank Group %d Block %d\n",
-			     e_info->row, e_info->bank,
-			     e_info->bank_grp_num, e_info->blk_num);
+		 e_info->row, e_info->bank,
+		 e_info->bank_grp_num, e_info->blk_num);
 	dev_info(&pdev->dev, "Data Pattern: %08x\n", e_info->data_pattern);
 }
 #endif
 
 static int ddr_edac_get_err_info(struct platform_device *pdev,
-				     int slice_id, int mc_id)
+				 int slice_id, int mc_id)
 {
 	void __iomem *base, *e_base = NULL;
 	struct ddr_edac_status_t *e_sts;
@@ -138,7 +126,7 @@ static int ddr_edac_get_err_info(struct platform_device *pdev,
 
 	if (slice_id >= num_slices || mc_id >= num_mcs_per_slice) {
 		dev_err(&pdev->dev, "Invalid DDR ECC Slice %d MC %d\n",
-				    slice_id, mc_id);
+			slice_id, mc_id);
 		return -EINVAL;
 	}
 
@@ -150,8 +138,9 @@ static int ddr_edac_get_err_info(struct platform_device *pdev,
 	e_sts->ce_cnt = (val & ECC_STAT_CE_CNT_MASK) >> ECC_STAT_CE_CNT_SHIFT;
 	e_sts->ue_cnt = (val & ECC_STAT_UE_CNT_MASK) >> ECC_STAT_UE_CNT_SHIFT;
 	if (!e_sts->ce_cnt && !e_sts->ue_cnt) {
-		dev_err(&pdev->dev, "No DDR ECC CE/UE detected on Slice %d MC %d\n",
-				    slice_id, mc_id);
+		dev_err(&pdev->dev,
+			"No DDR ECC CE/UE detected on Slice %d MC %d\n",
+			slice_id, mc_id);
 		return NO_ERR;
 	}
 
@@ -217,8 +206,8 @@ static irqreturn_t ddr_edac_handle_irq(int irq, void *data)
 
 #if defined(DEBUG_RAS_DDR) && defined(DEBUG_DDR_HW_INJ)
 static ssize_t tst_ddr_edac_poison_addr_show(struct device *dev,
-					 struct device_attribute *mattr,
-					 char *data)
+					     struct device_attribute *mattr,
+					     char *data)
 {
 	struct platform_device *pdev = to_pdev(dev);
 
@@ -351,8 +340,8 @@ int xbay_ddr_edac_probe(struct platform_device *pdev, struct device_node *np)
 
 	if (num_slices > THB_DDR_SLICE_NUM) {
 		dev_err(&pdev->dev, "Expected DDR Slices %d, but got %d\n",
-					THB_DDR_SLICE_NUM,
-					num_slices);
+			THB_DDR_SLICE_NUM,
+			num_slices);
 		return -EINVAL;
 	}
 
@@ -365,8 +354,8 @@ int xbay_ddr_edac_probe(struct platform_device *pdev, struct device_node *np)
 
 	if (num_mcs_per_slice > THB_DDR_MCS_PER_SLICE) {
 		dev_err(&pdev->dev, "Expected MCs per Slice %d, but got %d\n",
-					THB_DDR_MCS_PER_SLICE,
-					num_mcs_per_slice);
+			THB_DDR_MCS_PER_SLICE,
+			num_mcs_per_slice);
 		return -EINVAL;
 	}
 
diff --git a/drivers/misc/xbay_ras/snps_pcie_rasdes.c b/drivers/misc/xbay_ras/snps_pcie_rasdes.c
index 32e06018ecfe..aad49d8f62de 100644
--- a/drivers/misc/xbay_ras/snps_pcie_rasdes.c
+++ b/drivers/misc/xbay_ras/snps_pcie_rasdes.c
@@ -2,19 +2,7 @@
 /*
  * Intel xBay RAS: PCIe RAS DES SW
  *
- * Copyright (C) 2020 Intel Corporation
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2, as published
- * by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ * Copyright (C) 2021 Intel Corporation
  */
 
 #include "ras_core.h"
@@ -251,7 +239,6 @@ struct pcie_rasdes_grp_desc_t {
 };
 
 static pcie_rasdes_grp_desc_t pcie_rasdes_grp_table[PCIE_RASDES_NUM_GROUPS] = {
-
 	{
 		.entry_size = sizeof(pcie_rasdes_grp0_t),
 		.counter_offsets = {0, 1, 2, 3, 4, 5, 6, 0xff}
@@ -353,8 +340,8 @@ void xbay_pcie_rasdes_get_err_counters(void)
 
 #ifdef DEBUG_RAS_PCIE
 static ssize_t tst_pcie_ep_report_error_store(struct device *dev,
-					  struct device_attribute *mattr,
-					  const char *data, size_t count)
+					      struct device_attribute *mattr,
+					      const char *data, size_t count)
 {
 	struct platform_device *pdev = to_pdev(dev);
 
@@ -374,6 +361,7 @@ static const struct attribute *pcie_rasdes_attrs[] = {
 	&dev_attr_tst_pcie_ep_report_error.attr,
 	NULL,
 };
+
 static const struct attribute_group pcie_rasdes_attributes = {
 	.attrs = (struct attribute **)pcie_rasdes_attrs,
 };
-- 
2.27.0

