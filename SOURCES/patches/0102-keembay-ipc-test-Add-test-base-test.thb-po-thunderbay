From b92875fce91cb8b2e7b4d2ea0bde6ab09d92d004 Mon Sep 17 00:00:00 2001
From: Daniele Alessandrelli <daniele.alessandrelli@intel.com>
Date: Mon, 6 Apr 2020 16:58:52 +0100
Subject: [PATCH 102/223] keembay-ipc-test: Add 'test-base' test

Add test described in 'linux_ipc_base' ITS.

The test requires the Leon IPC FIFO to be enabled.

On Keem Bay, this can be done in OpenOCD as follows:
> mww 0x20810004 0x10
> mww 0x20810014 0x10

The output of a successful test run is similar to the following:

[ <ts> ] TEST_BASE: 203300f0.ipc
[ <ts> ]  71158	Kernel API:		PASS
[ <ts> ]  97349	High-speed channels:	PASS
[ <ts> ] 159919	Normal-speed channels:	PASS
[ <ts> ] 160010	Receive (non-blocking):	PASS	[chan_id=672]
[ <ts> ] 160012	Receive (w/ timeout):	PASS	[chan_id=15]
[ <ts> ] 160009	Send (non-blocking):	PASS	[chan_id=754, <cut>]
[ <ts> ] ------	Test clean-up:		PASS

Signed-off-by: Daniele Alessandrelli <daniele.alessandrelli@intel.com>
---
 drivers/misc/keembay-ipc/keembay-ipc-test.c | 119 +++++++++++++++++++-
 1 file changed, 117 insertions(+), 2 deletions(-)

diff --git a/drivers/misc/keembay-ipc/keembay-ipc-test.c b/drivers/misc/keembay-ipc/keembay-ipc-test.c
index e08d332f30c7..514af841a72d 100644
--- a/drivers/misc/keembay-ipc/keembay-ipc-test.c
+++ b/drivers/misc/keembay-ipc/keembay-ipc-test.c
@@ -10,6 +10,7 @@
 #include <linux/device.h>
 #include <linux/init.h>
 #include <linux/io.h>
+#include <linux/jiffies.h>
 #include <linux/keembay-ipc.h>
 #include <linux/kernel.h>
 #include <linux/kthread.h>
@@ -17,6 +18,7 @@
 #include <linux/of.h>
 #include <linux/of_address.h>
 #include <linux/platform_device.h>
+#include <linux/random.h>
 #include <linux/slab.h>
 #include <linux/string.h>
 
@@ -28,6 +30,17 @@ MODULE_VERSION("0.2");
 /* Timeout out in ms. */
 #define RECV_TIMEOUT	(15 * 1000)
 
+#define HS_CHAN_MIN	0x0
+#define HS_CHAN_MAX	0x9
+#define NS_CHAN_MIN	0x00a
+#define NS_CHAN_MAX	0x3FF
+
+#define CHAN_MIN	HS_CHAN_MIN
+#define CHAN_MAX	NS_CHAN_MAX
+#define CHAN_NUM	(CHAN_MAX - CHAN_MIN + 1)
+
+#define FIFO_SIZE	128
+
 #define LOCAL_IPC_MEM_VADDR ((void *)0xffff000009200000)
 #define LOCAL_IPC_MEM_SIZE  0x200000
 
@@ -56,6 +69,8 @@ static ssize_t recv_wr(struct file *, const char __user *, size_t, loff_t *);
 static ssize_t send_wr(struct file *, const char __user *, size_t, loff_t *);
 static ssize_t open_wr(struct file *, const char __user *, size_t, loff_t *);
 static ssize_t close_wr(struct file *, const char __user *, size_t, loff_t *);
+static ssize_t test_base_wr(struct file *filp, const char __user *buf,
+			    size_t count, loff_t *fpos);
 static ssize_t test_loop_wr(struct file *filp, const char __user *buf,
 			    size_t count, loff_t *fpos);
 static ssize_t test_long_send_wr(struct file *filp, const char __user *buf,
@@ -94,13 +109,19 @@ static const struct file_operations close_fops = {
 	.write	= close_wr,
 };
 
-/* The file operations for the 'close' file. */
+/* The file operations for the 'test_base' file. */
+static const struct file_operations test_base_fops = {
+	.owner	= THIS_MODULE,
+	.write	= test_base_wr,
+};
+
+/* The file operations for the 'test_loop' file. */
 static const struct file_operations test_loop_fops = {
 	.owner	= THIS_MODULE,
 	.write	= test_loop_wr,
 };
 
-/* The file operations for the 'close' file. */
+/* The file operations for the 'test_long_send' file. */
 static const struct file_operations test_long_send_fops = {
 	.owner	= THIS_MODULE,
 	.write	= test_long_send_wr,
@@ -380,6 +401,93 @@ static ssize_t close_wr(struct file *filp, const char __user *buf, size_t count,
 	return count;
 }
 
+/* Write operation for the 'test-base' file. */
+static ssize_t test_base_wr(struct file *filp, const char __user *buf,
+			    size_t count, loff_t *fpos)
+{
+	int rc, i;
+	struct device *ipc_dev = filp->f_inode->i_private;
+	size_t size;
+	unsigned long js;
+	u16 chan_id;
+	u32 timeout_ms, vpu_addr;
+
+	pr_info("TEST_BASE: %s\n", dev_name(ipc_dev));
+
+	/*
+	 * If we managed to load this module and start this test, it means that
+	 * the IPC driver provides the expected Kernel API.
+	 */
+	pr_info(" 71158\tKernel API:\t\tPASS\n");
+
+	/* Verify IDs for High-Speed channels. */
+	for (chan_id = HS_CHAN_MIN; chan_id <= HS_CHAN_MAX; chan_id++) {
+		rc = intel_keembay_ipc_open_channel(ipc_dev,
+						    KMB_IPC_NODE_LEON_MSS,
+						    chan_id);
+		if (rc)
+			break;
+	}
+	pr_info(" 97349\tHigh-speed channels:\t%s\n", rc ? "FAIL" : "PASS");
+
+	/* Verify IDs for Normal-Speed channels. */
+	for (chan_id = NS_CHAN_MIN; chan_id <= NS_CHAN_MAX; chan_id++) {
+		rc = intel_keembay_ipc_open_channel(ipc_dev,
+						    KMB_IPC_NODE_LEON_MSS,
+						    chan_id);
+		if (rc) {
+			pr_info("FAIL");
+			break;
+		}
+	}
+	pr_info("159919\tNormal-speed channels:\t%s\n", rc ? "FAIL" : "PASS");
+
+	/* Verify non-blocking receive. */
+	chan_id = (get_random_u32() % CHAN_NUM) + CHAN_MIN;
+	timeout_ms = 0;
+	rc = intel_keembay_ipc_recv(ipc_dev, KMB_IPC_NODE_LEON_MSS, chan_id,
+				    &vpu_addr, &size, timeout_ms);
+	pr_info("160010\tReceive (non-blocking):\t%s\t[chan_id=%u]\n",
+		rc != -ETIME ? "FAIL" : "PASS", chan_id);
+
+	/* Verify blocking  with timeout receive. */
+	chan_id = (get_random_u32() % CHAN_NUM) + CHAN_MIN;
+	timeout_ms = 5000;
+	js = jiffies;
+	rc = intel_keembay_ipc_recv(ipc_dev, KMB_IPC_NODE_LEON_MSS, chan_id,
+				    &vpu_addr, &size, timeout_ms);
+	/* Fail if return code is != -ETIME or function returned too early. */
+	rc = rc != -ETIME ||
+	     time_before(jiffies, js + msecs_to_jiffies(timeout_ms));
+	pr_info("160012\tReceive (w/ timeout):\t%s\t[chan_id=%u]\n",
+		rc ? "FAIL" : "PASS", chan_id);
+
+	/* Verify non-blocking send. */
+	chan_id = (get_random_u32() % CHAN_NUM) + CHAN_MIN;
+	vpu_addr = get_random_u32();
+	size = get_random_u32();
+	/* Send FIFO_SIZE + 1 messages in order to fill FIFO. */
+	for (i = 0; i <= FIFO_SIZE; i++) {
+		rc = intel_keembay_ipc_send(ipc_dev, KMB_IPC_NODE_LEON_MSS,
+					    chan_id, vpu_addr, size);
+	}
+	/* Fail if final send didn't fail due to full FIFO. */
+	pr_info("160009\tSend (non-blocking):\t%s\t[chan_id=%u, addr=%x, size=%lx]\n",
+		rc != -EBUSY ? "FAIL" : "PASS", chan_id, vpu_addr, size);
+
+	/* Clean-up. */
+	for (chan_id = CHAN_MIN; chan_id <= CHAN_MAX; chan_id++) {
+		rc = intel_keembay_ipc_close_channel(ipc_dev,
+						     KMB_IPC_NODE_LEON_MSS,
+						     chan_id);
+		if (rc)
+			break;
+	}
+	pr_info("------\tTest clean-up:\t\t%s\n", rc ? "FAIL" : "PASS");
+
+	return count;
+}
+
 /* Write operation for the 'test-loop' file. */
 static ssize_t test_loop_wr(struct file *filp, const char __user *buf,
 			    size_t count, loff_t *fpos)
@@ -487,6 +595,13 @@ static int add_dev_to_dbgfs_tree(struct device *dev, struct dentry *base_dir)
 		return -ENOMEM;
 	pr_info("TEST_MOD: recv file created\n");
 
+	/* Create test-base file. */
+	file = debugfs_create_file("test-base", 0220, dev_dir, dev,
+				   &test_base_fops);
+	if (!file)
+		return -ENOMEM;
+	pr_info("TEST_MOD: test-base file created\n");
+
 	/* Create test-loop file. */
 	file = debugfs_create_file("test-loop", 0220, dev_dir, dev,
 				   &test_loop_fops);
-- 
2.27.0

