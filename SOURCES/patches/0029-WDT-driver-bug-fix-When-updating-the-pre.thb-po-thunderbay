From c6804396bb8ab1b755e4e11998bd1f691e00b85a Mon Sep 17 00:00:00 2001
From: ssanil <shruthi.sanil@intel.com>
Date: Wed, 8 Apr 2020 13:01:16 +0530
Subject: [PATCH 029/223] WDT driver bug fix When updating the pre-timeout
 value, the timeout value was also getting updated. This was happenning
 because the same function was being used to update both the timeout and
 pre-timeout values.

---
 drivers/watchdog/thunderbay_wdt.c | 69 ++++++++++++-------------------
 1 file changed, 27 insertions(+), 42 deletions(-)

diff --git a/drivers/watchdog/thunderbay_wdt.c b/drivers/watchdog/thunderbay_wdt.c
index 9f2deda5fda3..849234a22c6c 100644
--- a/drivers/watchdog/thunderbay_wdt.c
+++ b/drivers/watchdog/thunderbay_wdt.c
@@ -43,6 +43,7 @@
 #define WATCHDOG_PRETIMEOUT	4 /* seconds */
 
 #define START_DEFAULT		0
+
 static int start_enabled = START_DEFAULT;
 module_param(start_enabled, int, 0);
 MODULE_PARM_DESC(start_enabled, "Watchdog is started on module insertion"
@@ -51,12 +52,12 @@ MODULE_PARM_DESC(start_enabled, "Watchdog is started on module insertion"
 static unsigned int timeout = WATCHDOG_TIMEOUT;
 module_param(timeout, int, 0);
 MODULE_PARM_DESC(timeout, "Watchdog timeout period in seconds"
-				"(default = " __MODULE_STRING(WATCHDOG_TIMEOUT)")");
+			  "(default = " __MODULE_STRING(WATCHDOG_TIMEOUT)")");
 
 static bool nowayout = WATCHDOG_NOWAYOUT;
 module_param(nowayout, bool, 0);
 MODULE_PARM_DESC(nowayout, "Watchdog cannot be stopped once started"
-				"(default = " __MODULE_STRING(WATCHDOG_NOWAYOUT)")");
+			   "(default = " __MODULE_STRING(WATCHDOG_NOWAYOUT)")");
 
 struct thunderbay_wdt {
 	void __iomem *reg_base;
@@ -78,31 +79,11 @@ static inline void thunderbay_wdt_writel(struct thunderbay_wdt *thunderbay, u32
 	writel(val, thunderbay->reg_base + offset);
 }
 
-static void thunderbay_wdt_set_timeout_reg(struct watchdog_device *wdog, bool ping)
-{
-	struct thunderbay_wdt *wdt = watchdog_get_drvdata(wdog);
-	u32 th_val = 0;
-
-	if (ping)
-	{
-		thunderbay_wdt_writel(wdt, TIM_WATCHDOG, wdog->timeout * wdt->rate);
-	}
-	else
-	{
-		if (wdog->pretimeout != 0)
-			th_val = wdog->timeout - wdog->pretimeout;
-		thunderbay_wdt_writel(wdt, TIM_WATCHDOG_INT_THRES, th_val * wdt->rate);
-		thunderbay_wdt_writel(wdt, TIM_WATCHDOG, wdog->timeout * wdt->rate);
-	}
-}
-
 static int thunderbay_wdt_start(struct watchdog_device *wdog)
 {
 	struct thunderbay_wdt *wdt = watchdog_get_drvdata(wdog);
 
-	thunderbay_wdt_set_timeout_reg(wdog, 0);
 	thunderbay_wdt_writel(wdt, TIM_WDOG_EN, WDT_ENABLE);
-
 	return 0;
 }
 
@@ -111,24 +92,37 @@ static int thunderbay_wdt_stop(struct watchdog_device *wdog)
 	struct thunderbay_wdt *wdt = watchdog_get_drvdata(wdog);
 
 	thunderbay_wdt_writel(wdt, TIM_WDOG_EN, WDT_DISABLE);
-
 	return 0;
 }
 
 static int thunderbay_wdt_ping(struct watchdog_device *wdog)
 {
-	thunderbay_wdt_set_timeout_reg(wdog, 1);
+	struct thunderbay_wdt *wdt = watchdog_get_drvdata(wdog);
+
+	thunderbay_wdt_writel(wdt, TIM_WATCHDOG, wdog->timeout * wdt->rate);
+	return 0;
+}
+
+static int thunderbay_wdt_update_pretimeout(struct watchdog_device *wdog)
+{
+	struct thunderbay_wdt *wdt = watchdog_get_drvdata(wdog);
+	u32 th_val = 0;
+
+	if (wdog->pretimeout != 0)
+		th_val = wdog->timeout - wdog->pretimeout;
 
+	thunderbay_wdt_writel(wdt, TIM_WATCHDOG_INT_THRES, th_val * wdt->rate);
 	return 0;
 }
 
 static int thunderbay_wdt_set_timeout(struct watchdog_device *wdog, u32 t)
 {
+	struct thunderbay_wdt *wdt = watchdog_get_drvdata(wdog);
 	u32 actual = min(t, wdog->max_timeout);
-
 	wdog->timeout = actual;
-	thunderbay_wdt_set_timeout_reg(wdog, 0);
 
+	thunderbay_wdt_writel(wdt, TIM_WATCHDOG, wdog->timeout * wdt->rate);
+	thunderbay_wdt_update_pretimeout(wdog);
 	return 0;
 }
 
@@ -138,8 +132,8 @@ static int thunderbay_wdt_set_pretimeout(struct watchdog_device *wdog, u32 t)
 		return -EINVAL;
 
 	wdog->pretimeout = t;
-	thunderbay_wdt_set_timeout_reg(wdog, 0);
 
+	thunderbay_wdt_update_pretimeout(wdog);
 	return 0;
 }
 
@@ -165,13 +159,8 @@ static unsigned int thunderbay_wdt_get_timeleft(struct watchdog_device *wdog)
  */
 static irqreturn_t thunderbay_wdt_to_isr(int irq, void *dev_id)
 {
-	struct thunderbay_wdt *wdt = (struct thunderbay_wdt *)dev_id;
 	struct arm_smccc_res res;
 
-	// write a new TIM_WATCHDOG value greater than 0
-	thunderbay_wdt_writel(wdt, TIM_WATCHDOG, 0x1);
-
-
 	// clear bit 9 (WDOG_TO_INT_CLR)
 	if (IS_ENABLED(CONFIG_HAVE_ARM_SMCCC))
 		arm_smccc_smc(0x8200ff18, 0x200, 0, 0, 0, 0, 0, 0, &res);
@@ -191,20 +180,17 @@ static irqreturn_t thunderbay_wdt_th_isr(int irq, void *dev_id)
 	struct thunderbay_wdt *wdt = (struct thunderbay_wdt *)dev_id;
 	struct arm_smccc_res res;
 
-	//u32 th_val = 0;
-
-	// write a new TIM_WATCHDOG value greater than TIM_WATCHDOG_INT_THRES
-	//if (wdt->wdd.pretimeout != 0)
-	//	th_val = wdt->wdd.timeout - wdt->wdd.pretimeout;
-	//thunderbay_wdt_writel(wdt, TIM_WATCHDOG, th_val * wdt->rate + 1);
-
-	//Set Pre-Timeout to Zero to avoid interrupt getting trigerred for every tick until timeout
+	//Set Pre-Timeout to Zero to avoid th interrupt getting trigerred for every tick until timeout
 	thunderbay_wdt_set_pretimeout(&wdt->wdd, 0);
 
 	// clear bit 8 (WDOG_TH_INT_CLR)
 	if (IS_ENABLED(CONFIG_HAVE_ARM_SMCCC))
 		arm_smccc_smc(0x8200ff18, 0x100, 0, 0, 0, 0, 0, 0, &res);
 
+	/*
+	 * TODO: No action defined.
+	 * Print log message.
+	 */
 	pr_crit("Intel Thunder Bay non-secure watchdog pre-timeout.\n");
 	watchdog_notify_pretimeout(&wdt->wdd);
 
@@ -308,8 +294,7 @@ static int thunderbay_wdt_probe(struct platform_device *pdev)
 	if(start_enabled)
 	{
 		wdt->wdd.status = 3;
-		thunderbay_wdt_writel(wdt, TIM_WATCHDOG, 30 * wdt->rate);
-		thunderbay_wdt_writel(wdt, TIM_WDOG_EN, WDT_ENABLE);
+		thunderbay_wdt_start(&wdt->wdd);
 	}
 
 	return 0;
-- 
2.27.0

