From 039be599fbaf867c43cda228d02a0a1678ea1f2d Mon Sep 17 00:00:00 2001
From: Srikanth Thokala <srikanth.thokala@intel.com>
Date: Thu, 14 May 2020 19:16:12 +0530
Subject: [PATCH 005/223] Register Synopsys AXI DMA controller to DT DMA
 helpers

---
 drivers/dma/dw-axi-dmac/dw-axi-dmac-platform.c | 11 +++++++++++
 1 file changed, 11 insertions(+)

diff --git a/drivers/dma/dw-axi-dmac/dw-axi-dmac-platform.c b/drivers/dma/dw-axi-dmac/dw-axi-dmac-platform.c
index 713f3b5a69a0..299c4d038167 100644
--- a/drivers/dma/dw-axi-dmac/dw-axi-dmac-platform.c
+++ b/drivers/dma/dw-axi-dmac/dw-axi-dmac-platform.c
@@ -33,6 +33,8 @@
 #include "../dmaengine.h"
 #include "../virt-dma.h"
 
+#include <linux/of_dma.h>
+
 /*
  * The set of bus widths supported by the DMA controller. DW AXI DMAC supports
  * master data bus width up to 512 bits (for both AXI master interfaces), but
@@ -1447,13 +1449,20 @@ static int dw_probe(struct platform_device *pdev)
 	ret = dmaenginem_async_device_register(&dw->dma);
 	if (ret)
 		goto err_pm_disable;
+#ifdef CONFIG_ARCH_THUNDERBAY
+	ret = of_dma_controller_register(pdev->dev.of_node,
+					 of_dma_xlate_by_chan_id, &dw->dma);
 
+	if (ret)
+		goto err_pm_disable;
+#else
 	/* Register with OF helpers for DMA lookups */
 	ret = of_dma_controller_register(pdev->dev.of_node,
 					 dw_axi_dma_of_xlate, dw);
 	if (ret < 0)
 		dev_warn(&pdev->dev,
 			 "Failed to register OF DMA controller, fallback to MEM_TO_MEM mode\n");
+#endif /* CONFIG_ARCH_THUNDERBAY */
 
 	dev_info(chip->dev, "DesignWare AXI DMA Controller, %d channels\n",
 		 dw->hdata->nr_channels);
@@ -1473,6 +1482,8 @@ static int dw_remove(struct platform_device *pdev)
 	struct axi_dma_chan *chan, *_chan;
 	u32 i;
 
+	of_dma_controller_free(pdev->dev.of_node);
+
 	/* Enable clk before accessing to registers */
 	clk_prepare_enable(chip->cfgr_clk);
 	clk_prepare_enable(chip->core_clk);
-- 
2.27.0

