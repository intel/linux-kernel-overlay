From 77e023ce3f8feb78bfeebb76b1c15607e3880ee1 Mon Sep 17 00:00:00 2001
From: Srikanth Thokala <srikanth.thokala@intel.com>
Date: Mon, 8 Mar 2021 13:20:56 +0530
Subject: [PATCH 179/223] xlink-pcie: Adapt unified PCIe controller changes

Following changes:
- Use ARCH_THUNDERBAY flag to differentiate KMB and THB code
- Read platform data from device node
- Remove pcie-keembay.h

Signed-off-by: Srikanth Thokala <srikanth.thokala@intel.com>
---
 drivers/misc/xlink-pcie/common/boot.h        |   2 +-
 drivers/misc/xlink-pcie/common/util.c        |   4 +-
 drivers/misc/xlink-pcie/common/util.h        |   2 +-
 drivers/misc/xlink-pcie/common/xpcie.h       |   8 +-
 drivers/misc/xlink-pcie/local_host/Makefile  |   1 -
 drivers/misc/xlink-pcie/local_host/core.c    |  24 +--
 drivers/misc/xlink-pcie/local_host/dma.c     |  52 +++---
 drivers/misc/xlink-pcie/local_host/epf.c     | 181 ++++++++++++-------
 drivers/misc/xlink-pcie/local_host/epf.h     |  20 +-
 drivers/misc/xlink-pcie/remote_host/Makefile |   2 +-
 drivers/misc/xlink-pcie/remote_host/boot.c   |   2 +-
 drivers/misc/xlink-pcie/remote_host/main.c   |   8 +-
 drivers/misc/xlink-pcie/remote_host/pci.c    |  22 +--
 drivers/misc/xlink-pcie/remote_host/pci.h    |   6 +-
 drivers/pci/controller/dwc/pcie-keembay.h    |  77 --------
 15 files changed, 191 insertions(+), 220 deletions(-)
 delete mode 100644 drivers/pci/controller/dwc/pcie-keembay.h

diff --git a/drivers/misc/xlink-pcie/common/boot.h b/drivers/misc/xlink-pcie/common/boot.h
index e8be76c05163..facfba40e225 100644
--- a/drivers/misc/xlink-pcie/common/boot.h
+++ b/drivers/misc/xlink-pcie/common/boot.h
@@ -12,7 +12,7 @@
 
 #include <linux/types.h>
 
-#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 #define XPCIE_BOOT_MAGIC_ROM "THBROM"
 #define XPCIE_BOOT_MAGIC_EMMC "THBEMMC"
 #else
diff --git a/drivers/misc/xlink-pcie/common/util.c b/drivers/misc/xlink-pcie/common/util.c
index f3c6bda2db64..8b3da57540f3 100644
--- a/drivers/misc/xlink-pcie/common/util.c
+++ b/drivers/misc/xlink-pcie/common/util.c
@@ -36,7 +36,7 @@ static size_t intel_xpcie_doorbell_offset(struct xpcie *xpcie,
 		return XPCIE_MMIO_DTOH_RX_DOORBELL;
 	if (dirt == FROM_DEVICE && type == DEV_EVENT)
 		return XPCIE_MMIO_DTOH_EVENT_DOORBELL;
-#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 	if (dirt == TO_DEVICE && type == PHY_ID_UPDATED)
 		return XPCIE_MMIO_HTOD_PHY_ID_DOORBELL_STATUS;
 #endif
@@ -95,7 +95,7 @@ struct xpcie_buf_desc *intel_xpcie_alloc_bd(size_t length)
 	return bd;
 }
 
-#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 u32 intel_xpcie_create_sw_device_id(u8 func_no, u16 phy_id,
 				    u8 max_functions)
 {
diff --git a/drivers/misc/xlink-pcie/common/util.h b/drivers/misc/xlink-pcie/common/util.h
index 303fbf5a1ebf..8486ad853269 100644
--- a/drivers/misc/xlink-pcie/common/util.h
+++ b/drivers/misc/xlink-pcie/common/util.h
@@ -42,7 +42,7 @@ u32 intel_xpcie_get_device_status(struct xpcie *xpcie);
 u32 intel_xpcie_get_host_status(struct xpcie *xpcie);
 void intel_xpcie_set_host_status(struct xpcie *xpcie, u32 status);
 
-#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 
 void intel_xpcie_set_max_functions(struct xpcie *xpcie, u8 max_functions);
 u8 intel_xpcie_get_max_functions(struct xpcie *xpcie);
diff --git a/drivers/misc/xlink-pcie/common/xpcie.h b/drivers/misc/xlink-pcie/common/xpcie.h
index 69dadde66175..ace2778efc04 100644
--- a/drivers/misc/xlink-pcie/common/xpcie.h
+++ b/drivers/misc/xlink-pcie/common/xpcie.h
@@ -47,7 +47,7 @@
 struct xpcie_mmio {
 	u32 device_status;
 	u32 host_status;
-#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 	u16 phy_dev_id;
 	u8 max_functions;
 #endif
@@ -58,7 +58,7 @@ struct xpcie_mmio {
 	u8 dtoh_tx_doorbell;
 	u8 dtoh_rx_doorbell;
 	u8 dtoh_event_doorbell;
-#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 	u8 htod_phy_id_doorbell_status;
 #endif
 	u8 reserved;
@@ -85,7 +85,7 @@ struct xpcie_mmio {
 #define XPCIE_MMIO_CAP_OFF	(offsetof(struct xpcie_mmio, cap_offset))
 #define XPCIE_MMIO_MAGIC_OFF	(offsetof(struct xpcie_mmio, magic))
 
-#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 
 #define XPCIE_MMIO_PHY_DEV_ID	(offsetof(struct xpcie_mmio, phy_dev_id))
 #define XPCIE_MMIO_MAX_FUNCTIONS \
@@ -101,7 +101,7 @@ struct xpcie {
 	void *mmio;
 	void *bar4;
 	void *io_comm;
-#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 	void __iomem *doorbell_base; /*IPC DoorBell address space*/
 	void __iomem *doorbell_clear; /*IPC DoorBell clear address space*/
 #endif
diff --git a/drivers/misc/xlink-pcie/local_host/Makefile b/drivers/misc/xlink-pcie/local_host/Makefile
index f430414b9f76..16bb1e7345ac 100644
--- a/drivers/misc/xlink-pcie/local_host/Makefile
+++ b/drivers/misc/xlink-pcie/local_host/Makefile
@@ -1,4 +1,3 @@
-ccflags-y += -I$(srctree)/drivers/pci/controller/dwc
 obj-$(CONFIG_XLINK_PCIE_LH_DRIVER) += mxlk_ep.o
 mxlk_ep-objs := epf.o
 mxlk_ep-objs += dma.o
diff --git a/drivers/misc/xlink-pcie/local_host/core.c b/drivers/misc/xlink-pcie/local_host/core.c
index e174fe0bd078..4e74c853f459 100644
--- a/drivers/misc/xlink-pcie/local_host/core.c
+++ b/drivers/misc/xlink-pcie/local_host/core.c
@@ -15,7 +15,7 @@
 
 static struct xpcie *global_xpcie;
 
-#if (!IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (!IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 static struct xpcie *intel_xpcie_core_get_by_id(u32 sw_device_id)
 {
 	return (sw_device_id == xlink_sw_id) ? global_xpcie : NULL;
@@ -130,7 +130,7 @@ static int intel_xpcie_txrx_init(struct xpcie *xpcie,
 	int tx_pool_size, rx_pool_size;
 	struct xpcie_buf_desc *bd;
 	int index, ndesc;
-#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 	struct device *dma_dev = &xpcie_epf->epf->dev;
 #else
 	int rc;
@@ -153,7 +153,7 @@ static int intel_xpcie_txrx_init(struct xpcie *xpcie,
 	intel_xpcie_list_init(&xpcie->rx_pool);
 	rx_pool_size = roundup(SZ_32M, xpcie->fragment_size);
 	ndesc = rx_pool_size / xpcie->fragment_size;
-#if (!IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (!IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 	/* Initialize reserved memory resources */
 	rc = of_reserved_mem_device_init(dma_dev);
 	if (rc) {
@@ -463,7 +463,7 @@ static void intel_xpcie_tx_event_handler(struct work_struct *work)
 static irqreturn_t intel_xpcie_core_irq_cb(int irq, void *args)
 {
 	struct xpcie *xpcie = args;
-#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 	u16 phy_id = 0;
 	u8 max_functions = 0, func_no = 0;
 	struct xpcie_epf *xpcie_epf =
@@ -480,7 +480,7 @@ static irqreturn_t intel_xpcie_core_irq_cb(int irq, void *args)
 		if (xpcie->tx_pending)
 			intel_xpcie_start_tx(xpcie, 0);
 	}
-#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 	if (intel_xpcie_get_doorbell(xpcie, TO_DEVICE, PHY_ID_UPDATED)) {
 		intel_xpcie_set_doorbell(xpcie, TO_DEVICE, PHY_ID_UPDATED, 0);
 		if (!xpcie_epf->sw_dev_id_updated) {
@@ -560,7 +560,7 @@ int intel_xpcie_core_init(struct xpcie *xpcie)
 	intel_xpcie_set_doorbell(xpcie, FROM_DEVICE, DATA_SENT, 0);
 	intel_xpcie_set_doorbell(xpcie, FROM_DEVICE, DATA_RECEIVED, 0);
 	intel_xpcie_set_doorbell(xpcie, FROM_DEVICE, DEV_EVENT, NO_OP);
-#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 	intel_xpcie_set_doorbell(xpcie, TO_DEVICE, PHY_ID_UPDATED, 0);
 #endif
 	intel_xpcie_register_host_irq(xpcie, intel_xpcie_core_irq_cb);
@@ -759,7 +759,7 @@ int intel_xpcie_core_write(struct xpcie *xpcie, void *buffer,
 int intel_xpcie_get_device_status_by_id(u32 id, u32 *status)
 {
 	struct xpcie *xpcie;
-#if (!IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (!IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 	xpcie = intel_xpcie_core_get_by_id(id);
 #else
 	struct xpcie_epf *xpcie_epf = intel_xpcie_get_device_by_id(id);
@@ -776,7 +776,7 @@ int intel_xpcie_get_device_status_by_id(u32 id, u32 *status)
 	return 0;
 }
 
-#if (!IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (!IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 u32 intel_xpcie_get_device_num(u32 *id_list)
 {
 	u32 num_devices = 0;
@@ -794,7 +794,7 @@ int intel_xpcie_get_device_name_by_id(u32 id,
 				      char *device_name, size_t name_size)
 {
 	struct xpcie *xpcie;
-#if (!IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (!IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 	xpcie = intel_xpcie_core_get_by_id(id);
 #else
 	struct xpcie_epf *xpcie_epf = intel_xpcie_get_device_by_id(id);
@@ -818,7 +818,7 @@ int intel_xpcie_pci_connect_device(u32 id)
 {
 	struct xpcie *xpcie;
 
-#if (!IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (!IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 	xpcie = intel_xpcie_core_get_by_id(id);
 #else
 	struct xpcie_epf *xpcie_epf = intel_xpcie_get_device_by_id(id);
@@ -840,7 +840,7 @@ int intel_xpcie_pci_read(u32 id, void *data, size_t *size, u32 timeout)
 {
 	struct xpcie *xpcie;
 
-#if (!IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (!IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 	xpcie = intel_xpcie_core_get_by_id(id);
 #else
 	struct xpcie_epf *xpcie_epf = intel_xpcie_get_device_by_id(id);
@@ -859,7 +859,7 @@ int intel_xpcie_pci_write(u32 id, void *data, size_t *size, u32 timeout)
 {
 	struct xpcie *xpcie;
 
-#if (!IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (!IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 	xpcie = intel_xpcie_core_get_by_id(id);
 #else
 	struct xpcie_epf *xpcie_epf = intel_xpcie_get_device_by_id(id);
diff --git a/drivers/misc/xlink-pcie/local_host/dma.c b/drivers/misc/xlink-pcie/local_host/dma.c
index 267d33d9671d..8cd3de62ee35 100644
--- a/drivers/misc/xlink-pcie/local_host/dma.c
+++ b/drivers/misc/xlink-pcie/local_host/dma.c
@@ -151,14 +151,14 @@ enum xpcie_ep_engine_type {
 	READ_ENGINE
 };
 
-#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 #define DMA_CHAN_NUM (8)
 #else
 #define DMA_CHAN_NUM (4)
 #endif
 
 static u32 dma_chan_offset[2][DMA_CHAN_NUM] = {
-#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 	{ 0x200, 0x400, 0x600, 0x800, 0xA00, 0xC00, 0xE00, 0x1000 },
 	{ 0x300, 0x500, 0x700, 0x900, 0xB00, 0xD00, 0xF00, 0x1100 }
 #else
@@ -171,15 +171,8 @@ static void __iomem *intel_xpcie_ep_get_dma_base(struct pci_epf *epf)
 {
 	struct device *dev = &epf->dev;
 	struct xpcie_epf *xpcie_epf = (struct xpcie_epf *)dev->driver_data;
-#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
-	struct pci_epc *epc = epf->epc;
-	struct dw_pcie_ep *ep = epc_get_drvdata(epc);
-	struct dw_pcie *pci = to_dw_pcie_from_ep(ep);
 
-	xpcie_epf->dbi_base = pci->dbi_base;
-#endif
-
-	return pci->dbi_base + DMA_DBI_OFFSET;
+	return xpcie_epf->dbi_base + DMA_DBI_OFFSET;
 }
 
 static int intel_xpcie_ep_dma_disable(void __iomem *dma_base,
@@ -284,7 +277,9 @@ static void intel_xpcie_ep_dma_enable(void __iomem *dma_base,
 static int intel_xpcie_ep_dma_doorbell(struct xpcie_epf *xpcie_epf, int chan,
 				       void __iomem *doorbell)
 {
-	int i = DMA_PCIE_PM_L1_TIMEOUT, rc = 0;
+	int rc = 0;
+#if (!IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
+	int i = DMA_PCIE_PM_L1_TIMEOUT;
 	u32 val, pm_val;
 
 	val = ioread32(xpcie_epf->apb_base + PCIE_REGS_PCIE_APP_CNTRL);
@@ -305,6 +300,9 @@ static int intel_xpcie_ep_dma_doorbell(struct xpcie_epf *xpcie_epf, int chan,
 
 	iowrite32(val & ~APP_XFER_PENDING,
 		  xpcie_epf->apb_base + PCIE_REGS_PCIE_APP_CNTRL);
+#else
+	iowrite32((u32)chan, doorbell);
+#endif
 
 	return rc;
 }
@@ -365,14 +363,14 @@ int intel_xpcie_ep_dma_write_ll(struct pci_epf *epf, int chan, int descs_num)
 	struct __iomem pcie_dma_reg * dma_reg =
 				(struct __iomem pcie_dma_reg *)(dma_base);
 	int rc;
-#if (!IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (!IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 	int i;
 #endif
 
 	if (descs_num <= 0 || descs_num > XPCIE_NUM_TX_DESCS)
 		return -EINVAL;
 
-#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 	chan = xpcie_epf->epf->func_no;
 #endif
 
@@ -386,7 +384,7 @@ int intel_xpcie_ep_dma_write_ll(struct pci_epf *epf, int chan, int descs_num)
 
 	intel_xpcie_ep_dma_setup_ll_descs(dma_chan, desc_buf, descs_num);
 
-#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 	xpcie_epf->dma_wr_done = false;
 #endif
 
@@ -397,7 +395,7 @@ int intel_xpcie_ep_dma_write_ll(struct pci_epf *epf, int chan, int descs_num)
 	if (rc)
 		return rc;
 
-#if (!IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (!IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 	/* Wait for DMA transfer to complete. */
 	for (i = 0; i < DMA_POLLING_TIMEOUT; i++) {
 		usleep_range(5, 10);
@@ -421,7 +419,7 @@ int intel_xpcie_ep_dma_write_ll(struct pci_epf *epf, int chan, int descs_num)
 					   &dma_reg->dma_write_err_status,
 					   chan);
 
-#if (!IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (!IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 cleanup:
 	/* Clear the done/abort interrupt. */
 	iowrite32((DMA_DONE_INTERRUPT_CH_MASK(chan) |
@@ -450,14 +448,14 @@ int intel_xpcie_ep_dma_read_ll(struct pci_epf *epf, int chan, int descs_num)
 				(struct __iomem pcie_dma_reg *)(dma_base);
 	struct __iomem pcie_dma_chan * dma_chan;
 	int rc;
-#if (!IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (!IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 	int i;
 #endif
 
 	if (descs_num <= 0 || descs_num > XPCIE_NUM_RX_DESCS)
 		return -EINVAL;
 
-#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 	chan = xpcie_epf->epf->func_no;
 #endif
 
@@ -471,7 +469,7 @@ int intel_xpcie_ep_dma_read_ll(struct pci_epf *epf, int chan, int descs_num)
 
 	intel_xpcie_ep_dma_setup_ll_descs(dma_chan, desc_buf, descs_num);
 
-#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 	xpcie_epf->dma_rd_done = false;
 #endif
 
@@ -482,7 +480,7 @@ int intel_xpcie_ep_dma_read_ll(struct pci_epf *epf, int chan, int descs_num)
 	if (rc)
 		return rc;
 
-#if (!IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (!IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 	/* Wait for DMA transfer to complete. */
 	for (i = 0; i < DMA_POLLING_TIMEOUT; i++) {
 		usleep_range(5, 10);
@@ -512,7 +510,7 @@ int intel_xpcie_ep_dma_read_ll(struct pci_epf *epf, int chan, int descs_num)
 						chan);
 	}
 
-#if (!IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (!IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 cleanup:
 	/* Clear the done/abort interrupt. */
 	iowrite32((DMA_DONE_INTERRUPT_CH_MASK(chan) |
@@ -534,7 +532,7 @@ int intel_xpcie_ep_dma_read_ll(struct pci_epf *epf, int chan, int descs_num)
 
 static void intel_xpcie_ep_dma_free_ll_descs_mem(struct xpcie_epf *xpcie_epf)
 {
-#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 	struct device *dma_dev = &xpcie_epf->epf->dev;
 #else
 	struct device *dma_dev = xpcie_epf->epf->epc->dev.parent;
@@ -567,7 +565,7 @@ static int intel_xpcie_ep_dma_alloc_ll_descs_mem(struct xpcie_epf *xpcie_epf)
 	int tx_num = XPCIE_NUM_TX_DESCS + 1;
 	int rx_num = XPCIE_NUM_RX_DESCS + 1;
 	size_t tx_size, rx_size;
-#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 	struct device *dma_dev = &xpcie_epf->epf->dev;
 #else
 	struct device *dma_dev = xpcie_epf->epf->epc->dev.parent;
@@ -616,7 +614,7 @@ static irqreturn_t intel_xpcie_ep_dma_wr_interrupt(int irq, void *args)
 	void __iomem *dma_base = xpcie_epf->dma_base;
 	struct pcie_dma_reg *dma_reg = (struct pcie_dma_reg *)dma_base;
 	struct pcie_dma_chan *dma_chan;
-#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 	int chan = xpcie_epf->epf->func_no;
 #endif
 	dma_chan = (struct pcie_dma_chan *)
@@ -641,7 +639,7 @@ static irqreturn_t intel_xpcie_ep_dma_rd_interrupt(int irq, void *args)
 	void __iomem *dma_base = xpcie_epf->dma_base;
 	struct pcie_dma_reg *dma_reg = (struct pcie_dma_reg *)dma_base;
 	struct pcie_dma_chan *dma_chan;
-#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 	int chan = xpcie_epf->epf->func_no;
 #endif
 
@@ -669,7 +667,7 @@ int intel_xpcie_ep_dma_uninit(struct pci_epf *epf)
 	    intel_xpcie_ep_dma_disable(xpcie_epf->dma_base, READ_ENGINE))
 		return -EBUSY;
 
-#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 	if (xpcie_epf->irq_rdma)
 		free_irq(xpcie_epf->irq_rdma, xpcie_epf);
 	if (xpcie_epf->irq_wdma)
@@ -692,7 +690,7 @@ int intel_xpcie_ep_dma_init(struct pci_epf *epf)
 	if (rc)
 		return rc;
 
-#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 	init_waitqueue_head(&xpcie_epf->dma_rd_wq);
 	init_waitqueue_head(&xpcie_epf->dma_wr_wq);
 
diff --git a/drivers/misc/xlink-pcie/local_host/epf.c b/drivers/misc/xlink-pcie/local_host/epf.c
index e8b3b57453a7..cb4e9c5358b2 100644
--- a/drivers/misc/xlink-pcie/local_host/epf.c
+++ b/drivers/misc/xlink-pcie/local_host/epf.c
@@ -10,19 +10,21 @@
 #include <linux/of.h>
 #include <linux/platform_device.h>
 #include <linux/reboot.h>
+#include <linux/of_address.h>
 #include <linux/of_device.h>
+#include <linux/of_irq.h>
 #include <linux/of_reserved_mem.h>
 
 #include "epf.h"
 #include "../common/boot.h"
 
-#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 #define BAR0_MIN_SIZE			SZ_4K
 #endif
 
 #define BAR2_MIN_SIZE			SZ_16K
 
-#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 #define BAR4_MIN_SIZE			SZ_8K
 #else
 #define BAR4_MIN_SIZE			SZ_16K
@@ -42,7 +44,7 @@
 
 static struct pci_epf_header xpcie_header = {
 	.vendorid = PCI_VENDOR_ID_INTEL,
-#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 	.deviceid = PCI_DEVICE_ID_INTEL_TBH_FULL,
 #else
 	.deviceid = PCI_DEVICE_ID_INTEL_KEEMBAY,
@@ -60,11 +62,11 @@ static const struct pci_epf_device_id xpcie_epf_ids[] = {
 	{},
 };
 
-#if (!IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (!IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 u32 xlink_sw_id;
 #endif
 
-#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 #define XPCIE_MAX_NAME_LEN	(32)
 
 static LIST_HEAD(dev_list);
@@ -153,7 +155,7 @@ int intel_xpcie_raise_irq(struct xpcie *xpcie, enum xpcie_doorbell_type type)
 	return pci_epc_raise_irq(epf->epc, epf->func_no, PCI_EPC_IRQ_MSI, 1);
 }
 
-#if (!IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (!IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 static irqreturn_t intel_xpcie_err_interrupt(int irq, void *args)
 {
 	struct xpcie_epf *xpcie_epf;
@@ -177,7 +179,7 @@ static irqreturn_t intel_xpcie_host_interrupt(int irq, void *args)
 	struct xpcie_epf *xpcie_epf = container_of(xpcie,
 						   struct xpcie_epf, xpcie);
 	u8 event;
-#if (!IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (!IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 	u32 val;
 
 	val = ioread32(xpcie_epf->apb_base + PCIE_REGS_PCIE_INTR_FLAGS);
@@ -277,7 +279,7 @@ static void intel_xpcie_cleanup_bars(struct pci_epf *epf)
 	xpcie_epf->xpcie.bar4 = NULL;
 }
 
-#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 static int intel_xpcie_setup_bar(struct pci_epf *epf, enum pci_barno barno,
 				 size_t size, size_t align)
 {
@@ -286,25 +288,25 @@ static int intel_xpcie_setup_bar(struct pci_epf *epf, enum pci_barno barno,
 	struct pci_epc *epc = epf->epc;
 	struct xpcie_epf *xpcie_epf = epf_get_drvdata(epf);
 	struct pci_epf_bar *bar = &epf->bar[barno];
-	struct dw_pcie_ep *ep = epc_get_drvdata(epc);
-	struct dw_pcie *pci = to_dw_pcie_from_ep(ep);
-	struct thunderbay_pcie *thunderbay = to_thunderbay_pcie(pci);
+	//struct dw_pcie_ep *ep = epc_get_drvdata(epc);
+	//struct dw_pcie *pci = to_dw_pcie_from_ep(ep);
+	//struct thunderbay_pcie *thunderbay = to_thunderbay_pcie(pci);
 
 	bar->flags |= PCI_BASE_ADDRESS_MEM_TYPE_64;
 	bar->size = size;
 
 	if (barno == 0) {
 		bar->phys_addr =
-			thunderbay->doorbell_base->start + (epf->func_no * 0x1000);
+			xpcie_epf->doorbell_base->start + (epf->func_no * 0x1000);
 		vaddr = ioremap(bar->phys_addr, size);
 	}
 
 	if (barno == 2) {
-		bar->phys_addr = thunderbay->mmr2[epf->func_no]->start;
+		bar->phys_addr = xpcie_epf->mmr2.start;
 		vaddr = ioremap(bar->phys_addr, size);
 	}
 	if (barno == 4) {
-		bar->phys_addr = thunderbay->mmr4[epf->func_no]->start;
+		bar->phys_addr = xpcie_epf->mmr4.start;
 		vaddr = ioremap_cache(bar->phys_addr, size);
 	}
 
@@ -320,9 +322,7 @@ static int intel_xpcie_setup_bar(struct pci_epf *epf, enum pci_barno barno,
 		PCI_BASE_ADDRESS_MEM_TYPE_64 :
 		PCI_BASE_ADDRESS_MEM_TYPE_32;
 
-	thunderbay->setup_bar[epf->func_no] = true;
 	ret = pci_epc_set_bar(epc, epf->func_no, bar);
-	thunderbay->setup_bar[epf->func_no] = false;
 
 	if (ret) {
 		pci_epf_free_space(epf, vaddr, barno);
@@ -375,7 +375,7 @@ static int intel_xpcie_setup_bars(struct pci_epf *epf, size_t align)
 	int ret;
 
 	struct xpcie_epf *xpcie_epf = epf_get_drvdata(epf);
-#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 	ret = intel_xpcie_setup_bar(epf, BAR_0, BAR0_MIN_SIZE, align);
 	if (ret)
 		return ret;
@@ -403,40 +403,37 @@ static int intel_xpcie_setup_bars(struct pci_epf *epf, size_t align)
 	return 0;
 }
 
-#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 static void intel_xpcie_enable_multi_functions(struct pci_epf *epf)
 {
-	struct pci_epc *epc = epf->epc;
 	struct xpcie_epf *xpcie_epf = epf_get_drvdata(epf);
-	struct dw_pcie_ep *ep = epc_get_drvdata(epc);
-	struct dw_pcie *pci = to_dw_pcie_from_ep(ep);
-	struct thunderbay_pcie *thunderbay = to_thunderbay_pcie(pci);
-	size_t doorbell_clr_size = 0;
 	unsigned long doorbell_clr_addr = 0;
+	struct platform_device *pdev = NULL;
+	struct pci_epc *epc = epf->epc;
+	size_t doorbell_clr_size = 0;
+	struct device *dev = NULL;
 	int ret = 0;
 
-	xpcie_epf->irq_doorbell = thunderbay->irq_doorbell[epf->func_no];
-	xpcie_epf->irq_rdma = thunderbay->irq_rdma[epf->func_no];
-	xpcie_epf->irq_wdma = thunderbay->irq_wdma[epf->func_no];
-	xpcie_epf->apb_base = thunderbay->base;
+	dev = epc->dev.parent;
+	pdev = to_platform_device(dev);
 
 	switch (epf->func_no) {
 	case 0:
-		if (thunderbay->tbh_half) {
+		if (xpcie_epf->tbh_half) {
 			ret = of_reserved_mem_device_init_by_idx
-				(&epf->dev, pci->dev->of_node, 8);
+				(&epf->dev, pdev->dev.of_node, 8);
 		} else {
 			ret = of_reserved_mem_device_init_by_idx
-				(&epf->dev, pci->dev->of_node, 16);
+				(&epf->dev, pdev->dev.of_node, 16);
 			}
 		if (ret) {
 			dev_warn(&epc->dev,
 				 "of_reserved_mem_device_init_by_idx(): %d\n",
 				 ret);
 		}
-		epf->dev.dma_mask = pci->dev->dma_mask;
-		epf->dev.coherent_dma_mask = pci->dev->coherent_dma_mask;
-		ret = of_dma_configure(&epf->dev, pci->dev->of_node, true);
+		epf->dev.dma_mask = dev->dma_mask;
+		epf->dev.coherent_dma_mask = dev->coherent_dma_mask;
+		ret = of_dma_configure(&epf->dev, pdev->dev.of_node, true);
 		if (ret) {
 			dev_warn(&epc->dev,
 				 "pcie:failed of_dma_configure()ret=%d\n", ret);
@@ -446,28 +443,28 @@ static void intel_xpcie_enable_multi_functions(struct pci_epf *epf)
 			dev_warn(&epc->dev,
 				 "pcie:failed to set dma mask. ret=%d\n", ret);
 		}
-		doorbell_clr_addr = thunderbay->doorbell_clear->start;
+		doorbell_clr_addr = xpcie_epf->doorbell_clear->start;
 		doorbell_clr_size = 4;
 		break;
 	case 1:
-		doorbell_clr_addr = thunderbay->doorbell_clear->start + 0x8;
+		doorbell_clr_addr = xpcie_epf->doorbell_clear->start + 0x8;
 		doorbell_clr_size = 4;
 		break;
 	case 2:
-		if (thunderbay->tbh_half)
+		if (xpcie_epf->tbh_half)
 			ret = of_reserved_mem_device_init_by_idx
-				(&epf->dev, pci->dev->of_node, 9);
+				(&epf->dev, pdev->dev.of_node, 9);
 		else
 			ret = of_reserved_mem_device_init_by_idx
-				(&epf->dev, pci->dev->of_node, 17);
+				(&epf->dev, pdev->dev.of_node, 17);
 		if (ret) {
 			dev_warn(&epc->dev,
 				 "of_reserved_mem_device_init_by_idx(): %d\n",
 				 ret);
 		}
-		epf->dev.dma_mask = pci->dev->dma_mask;
-		epf->dev.coherent_dma_mask = pci->dev->coherent_dma_mask;
-		ret = of_dma_configure(&epf->dev, pci->dev->of_node, true);
+		epf->dev.dma_mask = dev->dma_mask;
+		epf->dev.coherent_dma_mask = dev->coherent_dma_mask;
+		ret = of_dma_configure(&epf->dev, pdev->dev.of_node, true);
 		if (ret) {
 			dev_warn(&epc->dev,
 				 "pcie:failed of_dma_configure()ret=%d\n", ret);
@@ -477,24 +474,24 @@ static void intel_xpcie_enable_multi_functions(struct pci_epf *epf)
 			dev_warn(&epc->dev,
 				 "pcie:failed to set dma mask. ret=%d\n", ret);
 		}
-		doorbell_clr_addr = thunderbay->doorbell_clear->start + 0x14;
+		doorbell_clr_addr = xpcie_epf->doorbell_clear->start + 0x14;
 		doorbell_clr_size = 4;
 		break;
 	case 3:
-		doorbell_clr_addr = thunderbay->doorbell_clear->start + 0x1C;
+		doorbell_clr_addr = xpcie_epf->doorbell_clear->start + 0x1C;
 		doorbell_clr_size = 4;
 		break;
 	case 4:
 		ret = of_reserved_mem_device_init_by_idx
-			(&epf->dev, pci->dev->of_node, 18);
+			(&epf->dev, pdev->dev.of_node, 18);
 		if (ret) {
 			dev_warn(&epc->dev,
 				 "of_xx_mem_device_init_by_idx(): 18 ret=%d\n",
 				 ret);
 		}
-		epf->dev.dma_mask = pci->dev->dma_mask;
-		epf->dev.coherent_dma_mask = pci->dev->coherent_dma_mask;
-		ret = of_dma_configure(&epf->dev, pci->dev->of_node, true);
+		epf->dev.dma_mask = dev->dma_mask;
+		epf->dev.coherent_dma_mask = dev->coherent_dma_mask;
+		ret = of_dma_configure(&epf->dev, pdev->dev.of_node, true);
 		if (ret) {
 			dev_warn(&epc->dev, "failed of_dma_configure(): %d\n",
 				 ret);
@@ -504,24 +501,24 @@ static void intel_xpcie_enable_multi_functions(struct pci_epf *epf)
 			dev_warn(&epc->dev, "failed to set dma mask ret=%d\n",
 				 ret);
 		}
-		doorbell_clr_addr = thunderbay->doorbell_clear->start + 0x28;
+		doorbell_clr_addr = xpcie_epf->doorbell_clear->start + 0x28;
 		doorbell_clr_size = 4;
 		break;
 	case 5:
-		doorbell_clr_addr = thunderbay->doorbell_clear->start + 0x30;
+		doorbell_clr_addr = xpcie_epf->doorbell_clear->start + 0x30;
 		doorbell_clr_size = 4;
 		break;
 	case 6:
 		ret = of_reserved_mem_device_init_by_idx
-			(&epf->dev, pci->dev->of_node, 19);
+			(&epf->dev, pdev->dev.of_node, 19);
 		if (ret) {
 			dev_warn(&epc->dev,
 				 "of_xx_mem_device_init_by_idx(): 19 ret=%d\n",
 				 ret);
 		}
-		epf->dev.dma_mask = pci->dev->dma_mask;
-		epf->dev.coherent_dma_mask = pci->dev->coherent_dma_mask;
-		ret = of_dma_configure(&epf->dev, pci->dev->of_node, true);
+		epf->dev.dma_mask = dev->dma_mask;
+		epf->dev.coherent_dma_mask = dev->coherent_dma_mask;
+		ret = of_dma_configure(&epf->dev, pdev->dev.of_node, true);
 		if (ret) {
 			dev_warn(&epc->dev,
 				 "pcie:failed of_dma_configure() ret:%d\n",
@@ -532,20 +529,17 @@ static void intel_xpcie_enable_multi_functions(struct pci_epf *epf)
 			dev_warn(&epc->dev, "failed to set dma mask ret=%d\n",
 				 ret);
 		}
-		doorbell_clr_addr = thunderbay->doorbell_clear->start + 0x3C;
+		doorbell_clr_addr = xpcie_epf->doorbell_clear->start + 0x3C;
 		doorbell_clr_size = 4;
 		break;
 	case 7:
-		doorbell_clr_addr = thunderbay->doorbell_clear->start + 0x44;
+		doorbell_clr_addr = xpcie_epf->doorbell_clear->start + 0x44;
 		doorbell_clr_size = 4;
 		break;
 	}
 
 	xpcie_epf->xpcie.doorbell_clear =
 				ioremap(doorbell_clr_addr, doorbell_clr_size);
-	dev_dbg(&epc->dev,
-		"virtual doorbell_clear=%p,physical doorbell_clr_addr=%lx\n",
-		 xpcie_epf->xpcie.doorbell_clear, doorbell_clr_addr);
 	intel_xpcie_set_max_functions(&xpcie_epf->xpcie, epc->max_functions);
 	list_add_tail(&xpcie_epf->list, &dev_list);
 	snprintf(xpcie_epf->name, MXLK_MAX_NAME_LEN, "%s_func%x", epf->name,
@@ -556,6 +550,55 @@ static void intel_xpcie_enable_multi_functions(struct pci_epf *epf)
 	if (ret)
 		dev_err(&epf->dev, "failed to request irq\n");
 }
+
+static int intel_xpcie_epf_get_platform_data(struct device *dev,
+					     struct xpcie_epf *xpcie_epf)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct pci_epf *epf = xpcie_epf->epf;
+	struct pci_epc *epc = epf->epc;
+	struct device_node *np;
+	struct resource *res;
+	int ret;
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "dbi");
+	xpcie_epf->dbi_base =
+		devm_ioremap(dev, res->start, resource_size(res));
+	if (IS_ERR(xpcie_epf->dbi_base))
+		return PTR_ERR(xpcie_epf->dbi_base);
+
+	xpcie_epf->irq_doorbell = irq_of_parse_and_map(pdev->dev.of_node,
+						       epf->func_no + 2);
+	xpcie_epf->irq_wdma = irq_of_parse_and_map(pdev->dev.of_node,
+						   epf->func_no + 10);
+	xpcie_epf->irq_rdma = irq_of_parse_and_map(pdev->dev.of_node,
+						   epf->func_no + 18);
+
+	xpcie_epf->doorbell_base = platform_get_resource_byname(pdev,
+								IORESOURCE_MEM,
+								"doorbell");
+	xpcie_epf->doorbell_clear = platform_get_resource_byname(pdev,
+								 IORESOURCE_MEM,
+								 "doorbellclr");
+
+	np = of_parse_phandle(pdev->dev.of_node,
+			      "memory-region", epf->func_no * 2);
+	ret = of_address_to_resource(np, 0, &xpcie_epf->mmr2);
+
+	np = of_parse_phandle(pdev->dev.of_node,
+			      "memory-region", (epf->func_no * 2) + 1);
+	ret = of_address_to_resource(np, 0, &xpcie_epf->mmr4);
+
+	ret = of_property_read_u8(pdev->dev.of_node,
+				  "max-functions",
+				  &epc->max_functions);
+	if (epc->max_functions == 8)
+		xpcie_epf->tbh_half = 0;
+	else if (epc->max_functions == 4)
+		xpcie_epf->tbh_half = 1;
+
+	return 0;
+}
 #else
 static int intel_xpcie_epf_get_platform_data(struct device *dev,
 					     struct xpcie_epf *xpcie_epf)
@@ -622,7 +665,7 @@ static int intel_xpcie_epf_bind(struct pci_epf *epf)
 	struct xpcie_epf *xpcie_epf = epf_get_drvdata(epf);
 	const struct pci_epc_features *features;
 	struct pci_epc *epc = epf->epc;
-#if (!IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (!IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 	u32 bus_num = 0, dev_num = 0;
 #endif
 	struct device *dev;
@@ -632,7 +675,7 @@ static int intel_xpcie_epf_bind(struct pci_epf *epf)
 	if (WARN_ON_ONCE(!epc))
 		return -EINVAL;
 
-#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 	if ((epf->func_no & 0x1))
 		return 0;
 #endif
@@ -647,20 +690,20 @@ static int intel_xpcie_epf_bind(struct pci_epf *epf)
 			return ret;
 	}
 
+	ret = intel_xpcie_epf_get_platform_data(dev, xpcie_epf);
+	if (ret) {
+		dev_err(&epf->dev, "Unable to get platform data\n");
+		return -EINVAL;
+	}
+
 	ret = intel_xpcie_setup_bars(epf, align);
 	if (ret) {
 		dev_err(&epf->dev, "BAR initialization failed\n");
 		return ret;
 	}
-#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 	intel_xpcie_enable_multi_functions(epf);
 #else
-	ret = intel_xpcie_epf_get_platform_data(dev, xpcie_epf);
-	if (ret) {
-		dev_err(&epf->dev, "Unable to get platform data\n");
-		return -EINVAL;
-	}
-
 	if (!strcmp(xpcie_epf->stepping, "A0")) {
 		xpcie_epf->xpcie.legacy_a0 = true;
 		intel_xpcie_iowrite32(1, xpcie_epf->xpcie.mmio +
@@ -697,14 +740,14 @@ static int intel_xpcie_epf_bind(struct pci_epf *epf)
 	}
 
 	intel_xpcie_set_device_status(&xpcie_epf->xpcie, XPCIE_STATUS_READY);
-#if (!IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (!IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 	ret = ioread32(xpcie_epf->apb_base + PCIE_REGS_PCIE_SYS_CFG_CORE);
 	bus_num = (ret >> PCIE_CFG_PBUS_NUM_OFFSET) & PCIE_CFG_PBUS_NUM_MASK;
 	dev_num = (ret >> PCIE_CFG_PBUS_DEV_NUM_OFFSET) &
 			PCIE_CFG_PBUS_DEV_NUM_MASK;
 #endif
 
-#if (!IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (!IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 	xlink_sw_id = FIELD_PREP(XLINK_DEV_INF_TYPE_MASK,
 				 XLINK_DEV_INF_PCIE) |
 		      FIELD_PREP(XLINK_DEV_PHYS_ID_MASK,
diff --git a/drivers/misc/xlink-pcie/local_host/epf.h b/drivers/misc/xlink-pcie/local_host/epf.h
index 08107896351c..4b2c1aeb25c6 100644
--- a/drivers/misc/xlink-pcie/local_host/epf.h
+++ b/drivers/misc/xlink-pcie/local_host/epf.h
@@ -12,7 +12,6 @@
 
 #include <linux/pci-epc.h>
 #include <linux/pci-epf.h>
-#include <pcie-keembay.h>
 
 #include "../common/xpcie.h"
 #include "../common/util.h"
@@ -22,7 +21,7 @@
 
 #define KEEMBAY_XPCIE_STEPPING_MAXLEN 8
 
-#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 #define DMA_CHAN_NUM		(8)
 #else
 #define DMA_CHAN_NUM		(4)
@@ -62,7 +61,7 @@ struct xpcie_dma_ll_desc_buf {
 struct xpcie_epf {
 	struct pci_epf *epf;
 	void *vaddr[BAR_5 + 1];
-#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 	enum pci_barno                  doorbell_bar;
 #endif
 	enum pci_barno comm_bar;
@@ -70,7 +69,7 @@ struct xpcie_epf {
 	const struct pci_epc_features *epc_features;
 	struct xpcie xpcie;
 	int irq;
-#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 	int                             irq_doorbell;
 	int                             irq_rdma;
 	int                             irq_wdma;
@@ -85,6 +84,15 @@ struct xpcie_epf {
 	void __iomem *apb_base;
 	void __iomem *dma_base;
 	void __iomem *dbi_base;
+
+#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
+	struct resource *doorbell_base;
+	struct resource *doorbell_clear;
+	struct resource mmr2;
+	struct resource mmr4;
+	bool tbh_half;
+#endif
+
 	char stepping[KEEMBAY_XPCIE_STEPPING_MAXLEN];
 
 	irq_handler_t			core_irq_callback;
@@ -95,7 +103,7 @@ struct xpcie_epf {
 	struct xpcie_dma_ll_desc_buf     tx_desc_buf;
 	struct xpcie_dma_ll_desc_buf     rx_desc_buf;
 
-#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 #define MXLK_MAX_NAME_LEN (32)
 	char                            name[MXLK_MAX_NAME_LEN];
 	u32                             sw_devid;
@@ -112,7 +120,7 @@ static inline struct device *xpcie_to_dev(struct xpcie *xpcie)
 	return &xpcie_epf->epf->dev;
 }
 
-#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 struct xpcie_epf *intel_xpcie_get_device_by_name(const char *name);
 #endif
 int intel_xpcie_ep_dma_init(struct pci_epf *epf);
diff --git a/drivers/misc/xlink-pcie/remote_host/Makefile b/drivers/misc/xlink-pcie/remote_host/Makefile
index 23ef53e458ed..4fa1dabac359 100644
--- a/drivers/misc/xlink-pcie/remote_host/Makefile
+++ b/drivers/misc/xlink-pcie/remote_host/Makefile
@@ -1,4 +1,4 @@
-ccflags-y += -DCONFIG_PCIE_TBH_EP=1 -DXLINK_PCIE_REMOTE=1
+ccflags-y += -DCONFIG_ARCH_THUNDERBAY=1 -DXLINK_PCIE_REMOTE=1
 
 obj-$(CONFIG_XLINK_PCIE_RH_DRIVER) += mxlk.o
 mxlk-objs := main.o
diff --git a/drivers/misc/xlink-pcie/remote_host/boot.c b/drivers/misc/xlink-pcie/remote_host/boot.c
index 36086f6d4d7d..4258122cb4d7 100644
--- a/drivers/misc/xlink-pcie/remote_host/boot.c
+++ b/drivers/misc/xlink-pcie/remote_host/boot.c
@@ -46,7 +46,7 @@ enum xpcie_stage intel_xpcie_check_magic(struct xpcie_dev *xdev)
 	return STAGE_UNINIT;
 }
 
-#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 void xpcie_device_irq(struct work_struct *work)
 {
 	struct xpcie_dev *xdev = container_of(work, struct xpcie_dev,
diff --git a/drivers/misc/xlink-pcie/remote_host/main.c b/drivers/misc/xlink-pcie/remote_host/main.c
index 7658e368f1ac..028692799f91 100644
--- a/drivers/misc/xlink-pcie/remote_host/main.c
+++ b/drivers/misc/xlink-pcie/remote_host/main.c
@@ -15,7 +15,7 @@
 
 static const struct pci_device_id xpcie_pci_table[] = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_KEEMBAY), 0 },
-#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_TBH_FULL), 0 },
 	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_TBH_PRIME), 0 },
 #endif
@@ -31,7 +31,7 @@ static int intel_xpcie_probe(struct pci_dev *pdev,
 	u16 hw_id;
 	int ret;
 
-#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 	if (PCI_FUNC(pdev->devfn) & 0x1)
 		return 0;
 #endif
@@ -39,7 +39,7 @@ static int intel_xpcie_probe(struct pci_dev *pdev,
 	hw_id = FIELD_PREP(HW_ID_HI_MASK, pdev->bus->number) |
 		FIELD_PREP(HW_ID_LO_MASK, PCI_SLOT(pdev->devfn));
 
-#if (!IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (!IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 	sw_devid = FIELD_PREP(XLINK_DEV_INF_TYPE_MASK, XLINK_DEV_INF_PCIE) |
 		FIELD_PREP(XLINK_DEV_PHYS_ID_MASK, hw_id) |
 		FIELD_PREP(XLINK_DEV_TYPE_MASK, XLINK_DEV_TYPE_KMB) |
@@ -78,7 +78,7 @@ static void intel_xpcie_remove(struct pci_dev *pdev)
 	if (xdev) {
 		intel_xpcie_pci_cleanup(xdev);
 		intel_xpcie_pci_notify_event(xdev, NOTIFY_DEVICE_DISCONNECTED);
-#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 		intel_xpcie_list_del_device(xdev);
 #endif
 		intel_xpcie_remove_device(xdev);
diff --git a/drivers/misc/xlink-pcie/remote_host/pci.c b/drivers/misc/xlink-pcie/remote_host/pci.c
index ad25ffe61e70..f6983d913060 100644
--- a/drivers/misc/xlink-pcie/remote_host/pci.c
+++ b/drivers/misc/xlink-pcie/remote_host/pci.c
@@ -37,7 +37,7 @@ struct xpcie_dev *intel_xpcie_get_device_by_id(u32 id)
 	}
 
 	list_for_each_entry(xdev, &dev_list, list) {
-#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 		if (xdev->sw_devid == id) {
 #else
 		if (xdev->devid == id) {
@@ -116,7 +116,7 @@ static void intel_xpcie_pci_unmap_bar(struct xpcie_dev *xdev)
 	if (xdev->xpcie.bar0) {
 		iounmap((void __iomem *)xdev->xpcie.bar0);
 		xdev->xpcie.bar0 = NULL;
-#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 		xdev->xpcie.doorbell_base = xdev->xpcie.bar0;
 #endif
 	}
@@ -147,7 +147,7 @@ static int intel_xpcie_pci_map_bar(struct xpcie_dev *xdev)
 		dev_err(&xdev->pci->dev, "failed to ioremap BAR0\n");
 		goto bar_error;
 	}
-#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 	xdev->xpcie.doorbell_base = xdev->xpcie.bar0;
 #endif
 	xdev->xpcie.io_comm = (void __force *)pci_ioremap_bar(xdev->pci, 2);
@@ -181,7 +181,7 @@ static irqreturn_t intel_xpcie_core_interrupt(int irq, void *args)
 	enum xpcie_stage stage;
 	u8 event;
 
-#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 	stage = intel_xpcie_check_magic(xdev);
 	if (stage == STAGE_ROM || stage == STAGE_UBOOT || stage == STAGE_RECOV)
 		schedule_work(&xdev->irq_event);
@@ -258,7 +258,7 @@ static void xpcie_device_poll(struct work_struct *work)
 	struct xpcie_dev *xdev = container_of(work, struct xpcie_dev,
 					      wait_event.work);
 	enum xpcie_stage stage = intel_xpcie_check_magic(xdev);
-#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 	u8 max_functions;
 #endif
 	if (stage == STAGE_RECOV) {
@@ -266,7 +266,7 @@ static void xpcie_device_poll(struct work_struct *work)
 			xdev->xpcie.status = XPCIE_STATUS_RECOVERY;
 	} else if (stage == STAGE_OS) {
 		xdev->xpcie.status = XPCIE_STATUS_READY;
-#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 		intel_xpcie_set_physical_device_id(&xdev->xpcie, xdev->devid);
 		max_functions = intel_xpcie_get_max_functions(&xdev->xpcie);
 		xdev->sw_devid =
@@ -320,7 +320,7 @@ static int xpcie_device_init(struct xpcie_dev *xdev)
 
 	INIT_DELAYED_WORK(&xdev->wait_event, xpcie_device_poll);
 	INIT_DELAYED_WORK(&xdev->shutdown_event, xpcie_device_shutdown);
-#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 	INIT_WORK(&xdev->irq_event, xpcie_device_irq);
 #endif
 	rc = intel_xpcie_pci_irq_init(xdev);
@@ -401,7 +401,7 @@ int intel_xpcie_pci_cleanup(struct xpcie_dev *xdev)
 
 	cancel_delayed_work(&xdev->wait_event);
 	cancel_delayed_work(&xdev->shutdown_event);
-#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 	cancel_work_sync(&xdev->irq_event);
 #endif
 	xdev->core_irq_callback = NULL;
@@ -429,7 +429,7 @@ int intel_xpcie_pci_raise_irq(struct xpcie_dev *xdev,
 
 	intel_xpcie_set_doorbell(&xdev->xpcie, TO_DEVICE, type, value);
 	pci_read_config_word(xdev->pci, PCI_STATUS, &pci_status);
-#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 	iowrite32(1, xdev->xpcie.doorbell_base);
 #endif
 	return 0;
@@ -448,7 +448,7 @@ u32 intel_xpcie_get_device_num(u32 *id_list)
 	}
 
 	list_for_each_entry(p, &dev_list, list) {
-#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 		*id_list++ = p->sw_devid;
 #else
 		*id_list++ = p->devid;
@@ -596,7 +596,7 @@ void intel_xpcie_pci_notify_event(struct xpcie_dev *xdev,
 		xdev->event_fn(xdev->devid, event_type);
 }
 
-#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 struct xpcie_dev *intel_xpcie_get_device_by_name(const char *name)
 {
 	struct xpcie_dev *p;
diff --git a/drivers/misc/xlink-pcie/remote_host/pci.h b/drivers/misc/xlink-pcie/remote_host/pci.h
index e8c3de7b3d1a..d0b50bcd8edb 100644
--- a/drivers/misc/xlink-pcie/remote_host/pci.h
+++ b/drivers/misc/xlink-pcie/remote_host/pci.h
@@ -20,7 +20,7 @@
 #include "../common/util.h"
 #include "../common/boot.h"
 
-#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 #include <linux/mxlk_boot_inf.h>
 #endif
 
@@ -36,7 +36,7 @@ struct xpcie_dev {
 	struct pci_dev *pci;
 	char name[XPCIE_MAX_NAME_LEN];
 	u32 devid;
-#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 	u32 sw_devid;
 #endif
 	char fw_name[XPCIE_MAX_NAME_LEN];
@@ -50,7 +50,7 @@ struct xpcie_dev {
 	struct xpcie xpcie;
 	xlink_device_event event_fn;
 
-#if (IS_ENABLED(CONFIG_PCIE_TBH_EP))
+#if (IS_ENABLED(CONFIG_ARCH_THUNDERBAY))
 	struct work_struct irq_event;
 	bool boot_dev_link;
 	mxlk_pcie_boot_event boot_notif_fn;
diff --git a/drivers/pci/controller/dwc/pcie-keembay.h b/drivers/pci/controller/dwc/pcie-keembay.h
deleted file mode 100644
index 5cb8b120ca22..000000000000
--- a/drivers/pci/controller/dwc/pcie-keembay.h
+++ /dev/null
@@ -1,77 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0-only */
-/*
- * pcie-keembay - PCIe controller driver for Intel Keem Bay
- *
- * Copyright (C) 2019 Intel Corporation
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2, as published
- * by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef _PCIE_KEEMBAY_H
-#define _PCIE_KEEMBAY_H
-
-#include <linux/clk.h>
-#include <linux/gpio/consumer.h>
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/pci.h>
-#include <linux/platform_device.h>
-
-#include "pcie-designware.h"
-
-#define KEEMBAY_PCIE_STEPPING_MAXLEN 8
-
-struct keembay_pcie {
-	struct dw_pcie		*pci;
-	void __iomem		*base;
-	enum dw_pcie_device_mode mode;
-	char			stepping[KEEMBAY_PCIE_STEPPING_MAXLEN];
-	int			irq;
-	int			ev_irq;
-	int			err_irq;
-	int			mem_access_irq;
-
-	struct clk		*clk_master;
-	struct clk		*clk_aux;
-	struct gpio_desc	*reset;
-};
-
-#define to_keembay_pcie(x)	dev_get_drvdata((x)->dev)
-
-struct thunderbay_pcie {
-	struct dw_pcie          *pci;
-	void __iomem            *base;
-	enum dw_pcie_device_mode mode;
-	struct resource         *doorbell_base;
-	struct resource         *doorbell_clear;
-	struct resource         *mmr2[8];
-	struct resource         *mmr4[8];
-	bool                    setup_bar[8];
-	int                     irq;
-	int                     irq_doorbell[8];
-	int                     irq_rdma[8];
-	int                     irq_wdma[8];
-
-	bool                    tbh_half;
-
-	void __iomem            *cpr_base;
-	struct dma_pool         *rc_dma_pool;
-	dma_addr_t              rc_dma_mem_pa;
-	void                    *rc_dma_mem_va;
-	struct dma_chan         *rd_dma_chan;
-	bool                    rc_dma;
-};
-
-#define to_thunderbay_pcie(x)				dev_get_drvdata((x)->dev)
-
-#endif /* _PCIE_KEEMBAY_H */
-- 
2.27.0

