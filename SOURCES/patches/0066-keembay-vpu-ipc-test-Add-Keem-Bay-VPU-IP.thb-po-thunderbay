From 7d81e5726e155d899b810b9efb036a657d12a77d Mon Sep 17 00:00:00 2001
From: "Murphy, Paul J" <paul.j.murphy@intel.com>
Date: Wed, 3 Apr 2019 15:32:04 +0000
Subject: [PATCH 066/223] keembay-vpu-ipc-test: Add Keem Bay VPU IPC test

Add Keem Bay VPU IPC test

Signed-off-by: Murphy, Paul J <paul.j.murphy@intel.com>

(cherry picked from commit 041252f4d971816e6fd1d964362326baa1e4c4c6)
---
 drivers/firmware/Kconfig                |  12 +++
 drivers/firmware/Makefile               |   1 +
 drivers/firmware/keembay-vpu-ipc-test.c | 104 ++++++++++++++++++++++++
 3 files changed, 117 insertions(+)
 create mode 100644 drivers/firmware/keembay-vpu-ipc-test.c

diff --git a/drivers/firmware/Kconfig b/drivers/firmware/Kconfig
index 6b2105a93c7d..61bfd254263e 100644
--- a/drivers/firmware/Kconfig
+++ b/drivers/firmware/Kconfig
@@ -166,6 +166,18 @@ config KEEMBAY_VPU_IPC
           on secure world monitor software to do the control of the VPU
           state.
 
+config KEEMBAY_VPU_IPC_TEST
+	tristate "Intel Keem Bay VPU IPC Driver test module"
+	depends on KEEMBAY_VPU_IPC
+	depends on HAVE_ARM_SMCCC
+	help
+	  This option enables a test module for Keem Bay VPU IPC driver.
+	  It depends on Keem Bay IPC driver and Keem Bay VPU IPC driver
+	  being present in the kernel already. This module will attempt
+	  to request the VPU to start, track the boot sequence, exercise
+	  some basic APIs of the Keem Bay VPU IPC driver, and finally
+	  shut down the VPU.
+
 config ISCSI_IBFT_FIND
 	bool "iSCSI Boot Firmware Table Attributes"
 	depends on X86 && ISCSI_IBFT
diff --git a/drivers/firmware/Makefile b/drivers/firmware/Makefile
index cd4b320b43e7..eead372dbe8e 100644
--- a/drivers/firmware/Makefile
+++ b/drivers/firmware/Makefile
@@ -16,6 +16,7 @@ obj-$(CONFIG_ISCSI_IBFT_FIND)	+= iscsi_ibft_find.o
 obj-$(CONFIG_ISCSI_IBFT)	+= iscsi_ibft.o
 obj-$(CONFIG_FIRMWARE_MEMMAP)	+= memmap.o
 obj-$(CONFIG_KEEMBAY_VPU_IPC)	+= keembay-vpu-ipc.o
+obj-$(CONFIG_KEEMBAY_VPU_IPC_TEST) += keembay-vpu-ipc-test.o
 obj-$(CONFIG_RASPBERRYPI_FIRMWARE) += raspberrypi.o
 obj-$(CONFIG_FW_CFG_SYSFS)	+= qemu_fw_cfg.o
 obj-$(CONFIG_QCOM_SCM)		+= qcom_scm.o qcom_scm-smc.o qcom_scm-legacy.o
diff --git a/drivers/firmware/keembay-vpu-ipc-test.c b/drivers/firmware/keembay-vpu-ipc-test.c
new file mode 100644
index 000000000000..db44be98fda1
--- /dev/null
+++ b/drivers/firmware/keembay-vpu-ipc-test.c
@@ -0,0 +1,104 @@
+// SPDX-License-Identifier: GPL-2.0-only OR BSD-3-Clause
+/*
+ * Keem Bay VPU IPC test driver
+ *
+ * Copyright (c) 2019 Intel Corporation.
+ */
+
+#include <linux/io.h>
+#include <linux/keembay-vpu-ipc.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+
+#define KEEMBAY_VPU_IPC_TEST_READY_WAIT_TIME_MS (31000)
+
+static int __init keem_bay_vpu_ipc_test_init(void)
+{
+	int ret;
+	enum intel_keembay_vpu_state state;
+
+	pr_info("Entering VPU IPC test.\n");
+
+	/* Check state */
+	state = intel_keembay_vpu_status();
+	if (state != KEEMBAY_VPU_OFF) {
+		pr_warn("VPU was not OFF, test may fail (it was %d)\n", state);
+
+		/* Stop the VPU */
+		ret = intel_keembay_vpu_stop();
+		if (ret) {
+			pr_err("Failed to stop VPU: %d\n", ret);
+			return ret;
+		}
+	}
+
+	/* Boot VPU */
+	ret = intel_keembay_vpu_startup("vpu.bin");
+	if (ret) {
+		pr_err("Failed to start VPU: %d\n", ret);
+		return ret;
+	}
+	pr_info("Successfully started VPU!\n");
+
+	/* Wait for VPU to be READY */
+	ret = intel_keembay_vpu_wait_for_ready(
+		KEEMBAY_VPU_IPC_TEST_READY_WAIT_TIME_MS);
+	if (ret) {
+		pr_err("Tried to start VPU but never got READY.\n");
+		return ret;
+	}
+	pr_info("Successfully synchronised state with VPU!\n");
+
+	/* Check state */
+	state = intel_keembay_vpu_status();
+	if (state != KEEMBAY_VPU_READY) {
+		pr_err("VPU was not ready, it was %d\n", state);
+		return -EIO;
+	}
+	pr_info("VPU was ready.\n");
+
+	/* Check WDT API */
+	ret = intel_keembay_vpu_get_wdt_count(KEEMBAY_VPU_NCE);
+	if (ret < 0) {
+		pr_err("Error getting NCE WDT count.\n");
+		return ret;
+	}
+	pr_info("NCE WDT count = %d\n", ret);
+
+	ret = intel_keembay_vpu_get_wdt_count(KEEMBAY_VPU_MSS);
+	if (ret < 0) {
+		pr_err("Error getting MSS WDT count.\n");
+		return ret;
+	}
+	pr_info("MSS WDT count = %d\n", ret);
+
+	/* Stop the VPU */
+	ret = intel_keembay_vpu_stop();
+	if (ret) {
+		pr_err("Failed to stop VPU: %d\n", ret);
+		return ret;
+	}
+	pr_info("Successfully stopped VPU!\n");
+
+	/* Check state */
+	state = intel_keembay_vpu_status();
+	if (state != KEEMBAY_VPU_OFF) {
+		pr_err("VPU was not OFF after stop request, it was %d\n",
+		       state);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static void __exit keem_bay_vpu_ipc_test_exit(void)
+{
+	pr_info("Leaving VPU IPC test.\n");
+}
+
+module_init(keem_bay_vpu_ipc_test_init);
+module_exit(keem_bay_vpu_ipc_test_exit);
+
+MODULE_DESCRIPTION("Keem Bay VPU IPC test driver");
+MODULE_AUTHOR("Paul Murphy <paul.j.murphy@intel.com>");
+MODULE_LICENSE("Dual BSD/GPL");
-- 
2.27.0

