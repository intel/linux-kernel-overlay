From 2e329858788645b97dc6cb3f7c0983d790469458 Mon Sep 17 00:00:00 2001
From: Sean V Kelley <sean.v.kelley@intel.com>
Date: Tue, 27 Oct 2020 13:53:02 -0700
Subject: [PATCH 3/5] selftests/cxl: [NOT FOR UPSTREAM] Add CXL test module for
 LVF test card

LVF is a CXL 1.1 compatible test card providing support for
configuration as an CXL 1.1 Type1 and Type2 device. Make use
of CXL 1.1 support via PCI enumeration to evaluate both the card
and the host OS capabilities.

DocLink: <published card spec goes here>

Signed-off-by: Sean V Kelley <sean.v.kelley@intel.com>
---
 tools/testing/selftests/cxl/Kbuild   |  29 +++++
 tools/testing/selftests/cxl/Makefile |  11 ++
 tools/testing/selftests/cxl/lvf.c    | 170 +++++++++++++++++++++++++++
 3 files changed, 210 insertions(+)
 create mode 100644 tools/testing/selftests/cxl/Kbuild
 create mode 100644 tools/testing/selftests/cxl/Makefile
 create mode 100644 tools/testing/selftests/cxl/lvf.c

diff --git a/tools/testing/selftests/cxl/Kbuild b/tools/testing/selftests/cxl/Kbuild
new file mode 100644
index 000000000000..169dff5e62fe
--- /dev/null
+++ b/tools/testing/selftests/cxl/Kbuild
@@ -0,0 +1,29 @@
+# SPDX-License-Identifier: GPL-2.0
+ldflags-y += --wrap=ioremap_wc
+ldflags-y += --wrap=memremap
+ldflags-y += --wrap=devm_ioremap
+ldflags-y += --wrap=devm_memremap
+ldflags-y += --wrap=devm_memunmap
+ldflags-y += --wrap=ioremap
+ldflags-y += --wrap=iounmap
+ldflags-y += --wrap=memunmap
+ldflags-y += --wrap=__devm_request_region
+ldflags-y += --wrap=__devm_release_region
+ldflags-y += --wrap=__request_region
+ldflags-y += --wrap=__release_region
+ldflags-y += --wrap=devm_memremap_pages
+ldflags-y += --wrap=insert_resource
+ldflags-y += --wrap=remove_resource
+ldflags-y += --wrap=acpi_evaluate_object
+ldflags-y += --wrap=acpi_evaluate_dsm
+
+DRIVERS := ../../../../drivers
+CXL_SRC := $(DRIVERS)/pci
+ccflags-y := -I$(srctree)/drivers/pci/
+
+obj-$(CONFIG_PCI_CXL) += cxl.o
+cxl-y := $(CXL_SRC)/cxl.o
+
+ifeq ($(CONFIG_PCI_CXL),y)
+obj-m += lvf.o
+endif
diff --git a/tools/testing/selftests/cxl/Makefile b/tools/testing/selftests/cxl/Makefile
new file mode 100644
index 000000000000..39bd73068a60
--- /dev/null
+++ b/tools/testing/selftests/cxl/Makefile
@@ -0,0 +1,11 @@
+# SPDX-License-Identifier: GPL-2.0
+KDIR ?= ../../../../
+
+default:
+	$(MAKE) -C $(KDIR) M=$$PWD
+
+install: default
+	$(MAKE) -C $(KDIR) M=$$PWD modules_install
+.PHONY: all test clean
+clean:
+	${RM} *.o *.ko *.a .*.cmd *.order *.symvers *.mod *.mod.c
diff --git a/tools/testing/selftests/cxl/lvf.c b/tools/testing/selftests/cxl/lvf.c
new file mode 100644
index 000000000000..af3e33e7c3f4
--- /dev/null
+++ b/tools/testing/selftests/cxl/lvf.c
@@ -0,0 +1,170 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * LVF Test driver for CXL 1.1
+ * Copyright (c) 2020, Intel Corporation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/acpi.h>
+#include <linux/init.h>
+
+#define PCI_CXL_VENDOR_ID(reg)		((reg) & (0xffff))
+#define PCI_CXL_CAP			0x0a
+#define PCI_CXL_CTRL			0x0c
+#define PCI_CXL_STS			0x0e
+#define PCI_CXL_CTRL2			0x10
+#define PCI_CXL_STS2			0x12
+#define PCI_CXL_LOCK			0x14
+#define PCI_CXL_RANGE1_SZ_HIGH		0x18
+#define PCI_CXL_RANGE1_SZ_LOW		0x1c
+#define PCI_CXL_RANGE1_BASE_HIGH	0x20
+#define PCI_CXL_RANGE1_BASE_LOW		0x24
+#define PCI_CXL_CACHE			BIT(0)
+#define PCI_CXL_IO			BIT(1)
+#define PCI_CXL_MEM			BIT(2)
+#define PCI_CXL_HDM_COUNT(reg)		(((reg) & (3 << 4)) >> 4)
+#define PCI_CXL_VIRAL			BIT(14)
+
+static struct pci_device_id ids[] = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x0d93), },
+	{ 0, }
+};
+MODULE_DEVICE_TABLE(pci, ids);
+
+#define FLAG(x, y)	(((x) & (y)))
+
+static int lvf_memory_check(struct pci_dev *dev)
+{
+
+	int cxl = dev->cxl_cap;
+        u64 bus_range1_base, bus_range1_base_high, bus_range1_base_low;
+        u64 bus_range1_sz, bus_range1_sz_high, bus_range1_sz_low;
+	u16 cap, ctrl;
+	int hdmcnt;
+	u32 addr;
+
+	pci_read_config_word(dev, cxl + PCI_CXL_CAP, &cap);
+
+	/* Verify memory capable */
+	if (!(cap & PCI_CXL_MEM)) {
+		pci_warn(dev, "Not a CXL Memory capable device\n");
+		return -EINVAL;
+	}
+
+	/* Verify hdm count */
+	hdmcnt = PCI_CXL_HDM_COUNT(cap);
+	switch (hdmcnt) {
+	case 0:
+		pci_warn(dev, "Illegal HDM count value of %d for CXL.mem Capable=1\n", hdmcnt);
+		return -EINVAL;
+	case 1:
+	case 2:
+		pci_info(dev,"CXL HDM count value of %d\n", hdmcnt);
+		break;
+	case 3:
+	default:
+		pci_warn(dev, "Illegal HDM count value of %d for CXL.mem Capable=1\n", hdmcnt);
+		return -EINVAL;
+	}
+
+
+	pci_read_config_word(dev, cxl + PCI_CXL_CTRL, &ctrl);
+	pci_info(dev,"CXL BUS Control %04x\n", ctrl);
+	pci_info(dev,"CXL PCI_CXL_MEM %04x\n", (unsigned int)PCI_CXL_MEM);
+	pci_info(dev,"CXL CTRL & PCI_CXL_MEM %04x\n", (unsigned int)(ctrl & PCI_CXL_MEM));
+
+	/* Verify memory enabled */
+	if (!(ctrl & PCI_CXL_MEM)) {
+		pci_warn(dev, "CXL Memory not enabled\n");
+		return -EINVAL;
+	}
+
+        /* Memory Size
+         * DVSEC Flex Bus Range1 Size Low (Offset 1Ch)
+         * 31:28 RO Memory_Size_Low: Corresponds to bits 31:28 of Flex Bus Range 1 memory size.
+         * DVSEC Flex Bus Range 1 Size High (Offset 18h)
+         * 31:0 RO Memory_Size_High: Corresponds to bits 63:32 of Flex Bus Range 1 memory size.
+         */
+	pci_read_config_dword(dev, cxl + PCI_CXL_RANGE1_SZ_HIGH, &addr);
+	bus_range1_sz_high = addr;
+	pci_info(dev,"CXL HDM Range 1 Size High = 0x%llx\n", bus_range1_sz_high);
+	pci_read_config_dword(dev, cxl + PCI_CXL_RANGE1_SZ_LOW, &addr);
+	bus_range1_sz_low = addr;
+	pci_info(dev,"CXL HDM Range 1 Size Low = 0x%llx\n", bus_range1_sz_low);
+	bus_range1_sz = (bus_range1_sz_high << 32) + (bus_range1_sz_low & 0xf0000000);
+	pci_info(dev,"CXL HDM Range 1 Size = 0x%llx\n", bus_range1_sz);
+
+
+        /* Memory Base Address
+         * DVSEC Flex Bus Range 1 Base Low (Offset 24h)
+         * 31:28 RO Memory_Base_Low: Corresponds to bits 31:28 of Flex Bus Range 1 base in the host address space.
+         * DVSEC Flex Bus Range 1 Base High (Offset 20h)
+         * 31:0 RO Memory_Base_High: Corresponds to bits 63:32 of Flex Bus Range 1 base in the host address space.
+         */
+	pci_read_config_dword(dev, cxl + PCI_CXL_RANGE1_BASE_HIGH, &addr);
+	bus_range1_base_high = addr;
+	pci_info(dev,"CXL HDM Range 1 Base High = 0x%llx\n", bus_range1_base_high);
+	pci_read_config_dword(dev, cxl + PCI_CXL_RANGE1_BASE_LOW, &addr);
+	bus_range1_base_low = addr;
+	pci_info(dev,"CXL HDM Range 1 Base Low = 0x%llx\n", bus_range1_base_low);
+	bus_range1_base = (bus_range1_base_high << 32) + (bus_range1_base_low & 0xf0000000);
+	pci_info(dev,"CXL HDM Range 1 Base Address = 0x%llx\n", bus_range1_base);
+
+	return 0;
+}
+
+static int lvf_probe(struct pci_dev *dev, const struct pci_device_id *id)
+{
+	/* Do probing type stuff here.
+	 * Like calling request_region();
+	 */
+	if (pci_enable_device(dev)) {
+		dev_err(&dev->dev, "can't enable PCI device\n");
+		return -ENODEV;
+	}
+	//	pci_info(dev, "Detected LVF device\n");
+
+	if (PCI_FUNC(dev->devfn) == 0) {
+		pci_info(dev, "Detected LVF device function 0\n");
+		if (!(dev->cxl_cap))
+			return -EINVAL;
+		lvf_memory_check(dev);
+	}
+
+	return 0;
+}
+
+static void lvf_remove(struct pci_dev *dev)
+{
+	/* clean up any allocated resources and stuff here.
+	 * like call release_region();
+	 */
+}
+
+static struct pci_driver lvf_driver = {
+	.name = "lvf driver",
+	.id_table = ids,
+	.probe = lvf_probe,
+	.remove = lvf_remove,
+};
+
+static int __init lvf_init(void)
+{
+	return pci_register_driver(&lvf_driver);
+}
+
+static void __exit lvf_exit(void)
+{
+	pci_unregister_driver(&lvf_driver);
+}
+
+MODULE_AUTHOR("Sean V Kelley (intel) <seanvk.dev@oregontracks.org>");
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("LVF Driver");
+
+module_init(lvf_init);
+module_exit(lvf_exit);
-- 
2.27.0

