From 0585c873cec3defce785c8d408d92cd0b71f4faa Mon Sep 17 00:00:00 2001
From: Daniele Alessandrelli <daniele.alessandrelli@intel.com>
Date: Wed, 14 Aug 2019 17:39:13 +0100
Subject: [PATCH 068/223] kmb-ipc-test: Add Keem Bay IPC test module

Add module to test Keem Bay IPC.

Signed-off-by: Daniele Alessandrelli <daniele.alessandrelli@intel.com>
---
 drivers/misc/keembay-ipc/Kconfig            |   7 +
 drivers/misc/keembay-ipc/Makefile           |   1 +
 drivers/misc/keembay-ipc/keembay-ipc-test.c | 472 ++++++++++++++++++++
 3 files changed, 480 insertions(+)
 create mode 100644 drivers/misc/keembay-ipc/keembay-ipc-test.c

diff --git a/drivers/misc/keembay-ipc/Kconfig b/drivers/misc/keembay-ipc/Kconfig
index 35f8ce80bf4d..dc3ddee4bbc5 100644
--- a/drivers/misc/keembay-ipc/Kconfig
+++ b/drivers/misc/keembay-ipc/Kconfig
@@ -3,3 +3,10 @@ config KEEMBAY_IPC
 	help
 	  KeemBay IPC enables communication between KeemBay CPU Sub-System
 	  (CSS) and KeemBay Media Sub-System (MSS).
+
+config KEEMBAY_IPC_TEST
+	tristate "Enable Keem Bay IPC Test Module"
+	depends on KEEMBAY_IPC
+	help
+	  KeemBay IPC enables communication between KeemBay CPU Sub-System
+	  (CSS) and KeemBay Media Sub-System (MSS).
diff --git a/drivers/misc/keembay-ipc/Makefile b/drivers/misc/keembay-ipc/Makefile
index 4486e4231bd4..eb2f4c29b7cc 100644
--- a/drivers/misc/keembay-ipc/Makefile
+++ b/drivers/misc/keembay-ipc/Makefile
@@ -2,3 +2,4 @@
 # Makefile for KeemBay IPC Linux driver
 #
 obj-$(CONFIG_KEEMBAY_IPC) += keembay-ipc.o
+obj-$(CONFIG_KEEMBAY_IPC_TEST) += keembay-ipc-test.o
diff --git a/drivers/misc/keembay-ipc/keembay-ipc-test.c b/drivers/misc/keembay-ipc/keembay-ipc-test.c
new file mode 100644
index 000000000000..a47da21f1c60
--- /dev/null
+++ b/drivers/misc/keembay-ipc/keembay-ipc-test.c
@@ -0,0 +1,472 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * kmb-ipc-test.c - Keem Bay IPC Test module.
+ *
+ * Copyright (c) 2019 Intel Corporation.
+ */
+
+#include <linux/debugfs.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/keembay-ipc.h>
+#include <linux/kernel.h>
+#include <linux/kthread.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Daniele Alessandrelli");
+MODULE_DESCRIPTION("A simple Linux module for testing Keem Bay IPC.");
+MODULE_VERSION("0.1");
+
+/* Timeout out in ms. */
+#define RECV_TIMEOUT	(15 * 1000)
+
+#define LOCAL_IPC_MEM_VADDR ((void *) 0xffff000009200000)
+#define LOCAL_IPC_MEM_SIZE  0x200000
+
+/* IPC buffer. */
+struct kmb_ipc_buf {
+	uint32_t data_paddr; /* Physical address where payload is located. */
+	uint32_t data_size;  /* Size of payload. */
+	uint16_t channel;    /* The channel used. */
+	uint8_t src_node;    /* The Node ID of the sender. */
+	uint8_t dst_node;    /* The Node ID of the intended receiver. */
+	uint8_t status;	     /* Either free or allocated. */
+} __packed __aligned(64);
+
+static void remove_ipc_test_dbgfs_tree(void);
+static ssize_t recv_wr(struct file *, const char __user *, size_t, loff_t *);
+static ssize_t send_wr(struct file *, const char __user *, size_t, loff_t *);
+static ssize_t open_wr(struct file *, const char __user *, size_t, loff_t *);
+static ssize_t close_wr(struct file *, const char __user *, size_t,
+			   loff_t *);
+static ssize_t test_loop_wr(struct file *filp, const char __user *buf,
+			       size_t count, loff_t *fpos);
+static ssize_t test_long_send_wr(struct file *filp, const char __user *buf,
+				 size_t count, loff_t *fpos);
+/*
+ * The dentry of the base debugfs directory for thie module
+ * /<dbgfs>/kmb_ipc_test
+ */
+static struct dentry *test_dir;
+
+/* The file operations for the 'recv' file. */
+static const struct file_operations recv_fops = {
+	.owner	= THIS_MODULE,
+	.write	= recv_wr,
+};
+
+/* The file operations for the 'send' file. */
+static const struct file_operations send_fops = {
+	.owner	= THIS_MODULE,
+	.write	= send_wr,
+};
+
+/* The file operations for the 'open' file. */
+static const struct file_operations open_fops = {
+	.owner	= THIS_MODULE,
+	.write	= open_wr,
+};
+
+/* The file operations for the 'close' file. */
+static const struct file_operations close_fops = {
+	.owner	= THIS_MODULE,
+	.write	= close_wr,
+};
+
+/* The file operations for the 'close' file. */
+static const struct file_operations test_loop_fops = {
+	.owner	= THIS_MODULE,
+	.write	= test_loop_wr,
+};
+
+/* The file operations for the 'close' file. */
+static const struct file_operations test_long_send_fops = {
+	.owner	= THIS_MODULE,
+	.write	= test_long_send_wr,
+};
+
+
+static size_t ipc_buf_used_cnt(void)
+{
+	struct kmb_ipc_buf *buffers = LOCAL_IPC_MEM_VADDR;
+	const size_t buf_cnt = LOCAL_IPC_MEM_SIZE / sizeof(struct kmb_ipc_buf);
+	int i, used = 0;
+
+	for (i = 0; i < buf_cnt; i++) {
+		if (buffers[i].status)
+			used++;
+	}
+	WARN_ON(i != 32768);
+	return used;
+}
+
+/* Test loop thread func. */
+static int test_loop_thread_fn(void *data)
+{
+	u16 chan_id = (unsigned long)data;
+	int rc;
+	uint32_t paddr1, paddr2;
+	size_t size1, size2;
+	char name[TASK_COMM_LEN];
+
+	get_task_comm(name, current);
+	pr_info("%s: started\n", name);
+
+	rc = intel_keembay_ipc_open_channel(KMB_IPC_NODE_LEON_MSS, chan_id);
+	if (rc) {
+		pr_info("Failed to open channel: %d\n", rc);
+		goto err;
+	}
+
+	while (!kthread_should_stop()) {
+		rc = intel_keembay_ipc_recv(KMB_IPC_NODE_LEON_MSS, chan_id,
+					    &paddr1, &size1, U32_MAX);
+		if (rc) {
+			pr_info("Failed 1st recv(): %d\n", rc);
+			goto err;
+		}
+		rc = intel_keembay_ipc_recv(KMB_IPC_NODE_LEON_MSS, chan_id,
+					    &paddr2, &size2, U32_MAX);
+		if (rc) {
+			pr_info("Failed 2nd recv(): %d\n", rc);
+			goto err;
+		}
+		rc = intel_keembay_ipc_send(KMB_IPC_NODE_LEON_MSS, chan_id,
+					    paddr1, size1);
+		if (rc) {
+			pr_info("Failed 1st send(): %d\n", rc);
+			goto err;
+		}
+		rc = intel_keembay_ipc_send(KMB_IPC_NODE_LEON_MSS, chan_id,
+					    paddr2, size2);
+		if (rc) {
+			pr_info("Failed 2nd send(): %d\n", rc);
+			goto err;
+		}
+	}
+
+	rc = intel_keembay_ipc_close_channel(KMB_IPC_NODE_LEON_MSS, chan_id);
+	if (rc) {
+		pr_info("Failed to close channel: %d\n", rc);
+		/* Do not jump to error, as we are exiting already. */
+	}
+	pr_info("Test loop thread stopping; channel: %d\n", chan_id);
+
+	return rc;
+err:
+	pr_info("Test loop thread exiting; channel: %d\n", chan_id);
+	/* Leave channel open. */
+	/* TODO: do we get here even when we get a signal by kthread_stop()? */
+	do_exit(rc);
+}
+
+/* Test long send thread func. */
+static int test_long_send_thread_fn(void *data)
+{
+	u16 chan_id = (unsigned long)data;
+	int rc;
+	char name[TASK_COMM_LEN];
+	u32 send_cnt = 0;
+	const u32 send_limit = 1000000;
+
+	get_task_comm(name, current);
+	pr_info("%s: started\n", name);
+
+	rc = intel_keembay_ipc_open_channel(KMB_IPC_NODE_LEON_MSS, chan_id);
+	if (rc) {
+		pr_info("Failed to open channel: %d\n", rc);
+		goto err_open;
+	}
+
+	while (!kthread_should_stop() && send_cnt < send_limit) {
+		rc = intel_keembay_ipc_send(KMB_IPC_NODE_LEON_MSS, chan_id,
+					    0xDEADBEEF, 42);
+		/* If FIFO full sleep and retry. */
+		if (rc == -EBUSY) {
+			usleep_range(1000, 2000);
+			continue;
+		}
+		if (rc) {
+			pr_info("Failed send(): %d\n", rc);
+			break;
+		}
+		send_cnt++;
+		if (!(send_cnt % 1000))
+			pr_info("send_cnt: %u\n", send_cnt);
+	}
+
+	rc = intel_keembay_ipc_close_channel(KMB_IPC_NODE_LEON_MSS, chan_id);
+	if (rc) {
+		pr_info("Failed to close channel: %d\n", rc);
+		/* Do not jump to error, as we are exiting already. */
+	}
+	msleep(1000);
+	pr_info("%s: IPC buf used: %ld\n", name, ipc_buf_used_cnt());
+err_open:
+	pr_info("%s: stopping\n", name);
+
+	/* Exit properly depending on what caused the thread to stop. */
+	if (kthread_should_stop())
+		return rc;
+	do_exit(rc);
+}
+
+/* Parse channel from user buffer. */
+int parse_chan(const char __user *buf, size_t count, unsigned long *chan_id)
+{
+	char *args;
+	int rc;
+
+	/* Consume the data */
+	args = memdup_user_nul(buf, count);
+	if (IS_ERR(args))
+		return PTR_ERR(args);
+	rc = kstrtoul(args, 0, chan_id);
+	kfree(args);
+
+	return rc;
+}
+
+/* Write operation for the 'recv' file. */
+static ssize_t recv_wr(struct file *filp, const char __user *buf,
+			  size_t count, loff_t *fpos)
+{
+	uint32_t paddr;
+	size_t size;
+	int rc;
+	unsigned long chan_id;
+
+	pr_info("RECV write\n");
+
+	rc = parse_chan(buf, count, &chan_id);
+	if (rc)
+		return rc;
+
+	rc = intel_keembay_ipc_recv(KMB_IPC_NODE_LEON_MSS, chan_id,
+					    &paddr, &size, RECV_TIMEOUT);
+	if (rc)
+		pr_info("recv(chan_id=%lu) failed: %d\n", chan_id, rc);
+	else
+		pr_info("recv(chan_id=%lu) paddr: %u\tsize: %ld\n", chan_id,
+			paddr, size);
+
+	return count;
+}
+
+/* Write operation for the 'send' file. */
+static ssize_t send_wr(struct file *filp, const char __user *buf,
+			  size_t count, loff_t *fpos)
+{
+	int rc;
+	unsigned long chan_id;
+
+	pr_info("SEND write\n");
+	if (*fpos) {
+		pr_err("TEST_MOD: write offset must always be zero\n");
+		return -EINVAL;
+	}
+
+	rc = parse_chan(buf, count, &chan_id);
+	if (rc)
+		return rc;
+
+	rc = intel_keembay_ipc_send(KMB_IPC_NODE_LEON_MSS, chan_id,
+				    0xDEADBEEF, 48);
+	pr_info("send(chan_id=%lu): %d\n", chan_id, rc);
+
+	return count;
+}
+
+/* Write operation for the 'close' file. */
+static ssize_t open_wr(struct file *filp, const char __user *buf,
+			       size_t count, loff_t *fpos)
+{
+	int rc;
+	unsigned long chan_id;
+
+	pr_info("OPEN write\n");
+	rc = parse_chan(buf, count, &chan_id);
+	if (rc)
+		return rc;
+
+	rc = intel_keembay_ipc_open_channel(KMB_IPC_NODE_LEON_MSS, chan_id);
+	pr_info("open(chan_id=%lu): %d\n", chan_id, rc);
+
+	return count;
+}
+
+/* Write operation for the 'open' file. */
+static ssize_t close_wr(struct file *filp, const char __user *buf,
+			       size_t count, loff_t *fpos)
+{
+	int rc;
+	unsigned long chan_id;
+
+	pr_info("CLOSE write\n");
+
+	rc = parse_chan(buf, count, &chan_id);
+	if (rc)
+		return rc;
+
+	rc = intel_keembay_ipc_close_channel(KMB_IPC_NODE_LEON_MSS, chan_id);
+	pr_info("close(chan_id=%lu): %d\n", chan_id, rc);
+
+	return count;
+}
+
+/* Write operation for the 'test-loop' file. */
+static ssize_t test_loop_wr(struct file *filp, const char __user *buf,
+			       size_t count, loff_t *fpos)
+{
+	unsigned long chan_id;
+	struct task_struct *test_loop_thread;
+	int rc;
+
+	pr_info("TEST_LOOP write\n");
+
+	rc = parse_chan(buf, count, &chan_id);
+	if (rc)
+		return rc;
+
+	pr_info("Starting test loop for channel %lu\n", chan_id);
+	test_loop_thread = kthread_run(&test_loop_thread_fn, (void *)chan_id,
+				       "test-loop-%lu", chan_id);
+	if (IS_ERR(test_loop_thread))
+		return PTR_ERR(test_loop_thread);
+
+	return count;
+}
+
+/* Write operation for the 'test-long' file. */
+static ssize_t test_long_send_wr(struct file *filp, const char __user *buf,
+				 size_t count, loff_t *fpos)
+{
+	unsigned long chan_id;
+	struct task_struct *thread;
+	int rc;
+
+	pr_info("TEST_LONG write\n");
+
+	rc = parse_chan(buf, count, &chan_id);
+	if (rc)
+		return rc;
+
+	pr_info("Starting test long for channel %lu\n", chan_id);
+	thread = kthread_run(&test_long_send_thread_fn, (void *)chan_id,
+			     "t-long-send-%lu", chan_id);
+	if (IS_ERR(thread))
+		return PTR_ERR(thread);
+
+	return count;
+}
+
+
+/*
+ * My debugfs tree.
+ */
+
+/* Create the DebugFS tree. */
+static int create_ipc_test_dbgfs_tree(void)
+{
+	int retv = 0;
+	struct dentry *file;
+
+	test_dir = debugfs_create_dir("kmb_ipc_test", NULL);
+	/*
+	 * The only error can be -ENODEV; i.e., debugfs is not enabled.
+	 * Therefore, the IS_ERR(test_dir) check is done only here.
+	 */
+	if (IS_ERR(test_dir))
+		return PTR_ERR(test_dir);
+	if (!test_dir)
+		return -ENOMEM;
+	pr_info("TEST_MOD: kmb_ipc_test dir created\n");
+	/* create send file */
+	file = debugfs_create_file("send", 0220, test_dir, NULL,
+				   &send_fops);
+	if (IS_ERR(file)) {
+		retv = PTR_ERR(file);
+		goto error;
+	}
+	if (!file) {
+		retv = -ENOMEM;
+		goto error;
+	}
+	pr_info("TEST_MOD: send file created\n");
+	/* Create open file. */
+	file = debugfs_create_file("open", 0220, test_dir, NULL,
+				   &open_fops);
+	if (!file) {
+		retv = -ENOMEM;
+		goto error;
+	}
+	pr_info("TEST_MOD: open file created\n");
+	/* Create close file. */
+	file = debugfs_create_file("close", 0220, test_dir, NULL,
+				   &close_fops);
+	if (!file) {
+		retv = -ENOMEM;
+		goto error;
+	}
+	pr_info("TEST_MOD: close file created\n");
+
+	/* Create close file. */
+	file = debugfs_create_file("recv", 0220, test_dir, NULL,
+				   &recv_fops);
+	if (!file) {
+		retv = -ENOMEM;
+		goto error;
+	}
+	pr_info("TEST_MOD: recv file created\n");
+
+	/* Create test-loop file. */
+	file = debugfs_create_file("test-loop", 0220, test_dir, NULL,
+				   &test_loop_fops);
+	if (!file) {
+		retv = -ENOMEM;
+		goto error;
+	}
+	pr_info("TEST_MOD: test-loop file created\n");
+
+	/* Create test-long-send file. */
+	file = debugfs_create_file("test-long-send", 0220, test_dir, NULL,
+				   &test_long_send_fops);
+	if (!file) {
+		retv = -ENOMEM;
+		goto error;
+	}
+	pr_info("TEST_MOD: test-long-send file created\n");
+
+	return retv;
+error:
+	remove_ipc_test_dbgfs_tree();
+	return retv;
+}
+
+/* Remove the DebugFS tree. */
+static void remove_ipc_test_dbgfs_tree(void)
+{
+	debugfs_remove_recursive(test_dir);
+}
+
+/*
+ * Module loading / unloading.
+ */
+
+static int __init kmb_ipc_test_init(void)
+{
+	pr_info("TEST_MOD: Init\n");
+	return create_ipc_test_dbgfs_tree();
+}
+
+static void __exit kmb_ipc_test_exit(void)
+{
+	pr_info("TEST_MOD: Exit\n");
+	remove_ipc_test_dbgfs_tree();
+}
+
+module_init(kmb_ipc_test_init);
+module_exit(kmb_ipc_test_exit);
-- 
2.27.0

