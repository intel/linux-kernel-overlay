From b87869486110006c160c2a75ff0a67748224d408 Mon Sep 17 00:00:00 2001
From: Daniele Alessandrelli <daniele.alessandrelli@intel.com>
Date: Mon, 14 Oct 2019 16:49:11 +0100
Subject: [PATCH 075/223] keembay-ipc: Rename physical addresses to VPU
 addresses

What the Keem Bay IPC driver calls 'physical' addresses are actually VPU
addresses; they just happen to match with CPU physical addresses because
the VPU:CPU address mapping is 1:1, but this may change in the future.

Signed-off-by: Daniele Alessandrelli <daniele.alessandrelli@intel.com>
---
 drivers/misc/keembay-ipc/keembay-ipc-common.h | 34 +++----
 drivers/misc/keembay-ipc/keembay-ipc.c        | 94 +++++++++----------
 2 files changed, 61 insertions(+), 67 deletions(-)

diff --git a/drivers/misc/keembay-ipc/keembay-ipc-common.h b/drivers/misc/keembay-ipc/keembay-ipc-common.h
index ca132905fc3d..9b5bf18e5e54 100644
--- a/drivers/misc/keembay-ipc/keembay-ipc-common.h
+++ b/drivers/misc/keembay-ipc/keembay-ipc-common.h
@@ -1,17 +1,8 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * keembay-ipc-common.h - KeemBay IPC common definitions.
+ * KeemBay IPC common definitions.
  *
  * Copyright (C) 2018-2019 Intel Corporation
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the Free
- * Software Foundation; version 2.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
  */
 
 #ifndef __KEEMBAY_IPC_COMMON_H
@@ -36,14 +27,23 @@ enum {
 	KMB_IPC_BUF_ALLOCATED,
 };
 
-/* IPC buffer. */
+/**
+ * struct kmb_ipc_buf - The IPC buffer structure.
+ * @data_addr:	The address where the IPC payload is located; NOTE: this is a
+ *		VPU address (not a CPU one).
+ * @data_size:	The size of the payload.
+ * @channel:	The channel used.
+ * @src_node:	The Node ID of the sender.
+ * @dst_node:	The Node ID of the intended receiver.
+ * @status:	Either free or allocated.
+ */
 struct kmb_ipc_buf {
-	uint32_t data_paddr; /* Physical address where payload is located. */
-	uint32_t data_size;  /* Size of payload. */
-	uint16_t channel;    /* The channel used. */
-	uint8_t src_node;    /* The Node ID of the sender. */
-	uint8_t dst_node;    /* The Node ID of the intended receiver. */
-	uint8_t status;	     /* Either free or allocated. */
+	uint32_t data_addr;
+	uint32_t data_size;
+	uint16_t channel;
+	uint8_t src_node;
+	uint8_t dst_node;
+	uint8_t status;
 } __packed __aligned(KMB_IPC_ALIGNMENT);
 
 #endif /* __KEEMBAY_IPC_COMMON_H */
diff --git a/drivers/misc/keembay-ipc/keembay-ipc.c b/drivers/misc/keembay-ipc/keembay-ipc.c
index 8946b162fdaa..f7979beae045 100644
--- a/drivers/misc/keembay-ipc/keembay-ipc.c
+++ b/drivers/misc/keembay-ipc/keembay-ipc.c
@@ -1,17 +1,8 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * keembay-ipc.c - KeemBay IPC Driver.
+ * KeemBay IPC Driver.
  *
  * Copyright (C) 2018-2019 Intel Corporation
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the Free
- * Software Foundation; version 2.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
  */
 
 #include <linux/completion.h>
@@ -75,7 +66,7 @@
 struct ipc_buf_mem {
 	struct device *dev;	/* Child device managing the memory region. */
 	void *vaddr;		/* The virtual address of the memory region. */
-	dma_addr_t dma_handle;  /* The physical address of the memory region. */
+	dma_addr_t dma_handle;  /* The VPU address of the memory region. */
 	size_t size;		/* The size of the memory region. */
 };
 
@@ -101,7 +92,7 @@ struct ipc_chan {
 
 /**
  * struct tx_data - Element of a TX queue.
- * @paddr:	The physical address of the data to be "transferred".
+ * @vpu_addr:	The VPU address of the data to be "transferred".
  * @size:	The size of the data to be "transferred".
  * @chan_id:	The channel to be used for the "transfer".
  * @dst_node:	The destination node.
@@ -111,7 +102,7 @@ struct ipc_chan {
  *		transfer to complete.
  */
 struct tx_data {
-	u32 paddr;
+	u32 vpu_addr;
 	u32 size;
 	u16 chan_id;
 	u8  dst_node;
@@ -191,8 +182,8 @@ struct keembay_ipc_dev {
  * (list) associated with each channel.
  */
 struct rx_data {
-	/* The physical address of the received data. */
-	uint32_t data_paddr;
+	/* The VPU address of the received data. */
+	uint32_t data_vpu_addr;
 	/* The size of the received data. */
 	uint32_t data_size;
 	/* List head for creating a list of rx_data elements. */
@@ -750,11 +741,11 @@ static int kmb_ipc_probe(struct platform_device *pdev)
 		return rc;
 	}
 	/* Print out some information about the configured memory. */
-	dev_info(dev, "Local vaddr 0x%p paddr 0x%pad size 0x%zX\n",
+	dev_info(dev, "Local vaddr 0x%p vpu_addr 0x%pad size 0x%zX\n",
 		 ipc_dev->local_ipc_mem.vaddr,
 		 &ipc_dev->local_ipc_mem.dma_handle,
 		 ipc_dev->local_ipc_mem.size);
-	dev_info(dev, "Remote vaddr 0x%p paddr 0x%pad size 0x%zX\n",
+	dev_info(dev, "Remote vaddr 0x%p vpu_addr 0x%pad size 0x%zX\n",
 		 ipc_dev->remote_ipc_mem.vaddr,
 		 &ipc_dev->remote_ipc_mem.dma_handle,
 		 ipc_dev->remote_ipc_mem.size);
@@ -817,40 +808,42 @@ static int validate_link_chan(struct device *dev, u8 node_id, u16 chan_id)
 }
 
 /*
- * ipc_phys_to_virt() - Convert IPC physical addresses to virtual addresses.
+ * ipc_vpu_to_virt() - Convert a VPU address to a CPU virtual address.
  *
- * @ipc_mem: The IPC memory region where the physical address is expected to be.
- * @paddr:   The physical address to be converted to a virtual one.
+ * @ipc_mem:  The IPC memory region where the VPU address is expected to be
+ *	      mapped to.
+ * @vpu_addr: The VPU address to be converted to a virtual one.
  *
- * Return: The corresponding virtual address, or NULL if the physical address
+ * Return: The corresponding CPU virtual address, or NULL if the VPU address
  *	   is not in the expected memory range.
  */
-static void *ipc_phys_to_virt(const struct ipc_buf_mem *ipc_mem, uint32_t paddr)
+static void *ipc_vpu_to_virt(const struct ipc_buf_mem *ipc_mem,
+			    uint32_t vpu_addr)
 {
-	if (unlikely(paddr < ipc_mem->dma_handle) ||
-		     paddr >= (ipc_mem->dma_handle + ipc_mem->size))
+	if (unlikely(vpu_addr < ipc_mem->dma_handle) ||
+		     vpu_addr >= (ipc_mem->dma_handle + ipc_mem->size))
 		return NULL;
-	return ipc_mem->vaddr + (paddr - ipc_mem->dma_handle);
+	return ipc_mem->vaddr + (vpu_addr - ipc_mem->dma_handle);
 }
 
 /*
- * ipc_virt_to_phys() - Convert IPC virtual addresses to physical addresses.
- * @ipc_mem: [in]  The IPC memory region where the physical address is expected
- *		   to be.
- * @vaddr:   [in]  The virtual address to be converted to a physical one.
- * @paddr:   [out] Where to store the computed physical address.
+ * ipc_virt_to_vpu() - Convert an CPU virtual address to a VPU address.
+ * @ipc_mem:  [in]  The IPC memory region where the VPU address is expected to
+ *		    be mapped to.
+ * @vaddr:    [in]  The CPU virtual address to be converted to a VPU one.
+ * @vpu_addr: [out] Where to store the computed VPU address.
  *
  * Return: 0 on success, negative error code otherwise.
  */
-static int ipc_virt_to_phys(struct ipc_buf_mem *ipc_mem, void *vaddr,
-			    uint32_t *paddr)
+static int ipc_virt_to_vpu(struct ipc_buf_mem *ipc_mem, void *vaddr,
+			    uint32_t *vpu_addr)
 {
 	if (unlikely((ipc_mem->dma_handle + ipc_mem->size) > 0xFFFFFFFF))
 		return -EINVAL;
 	if (unlikely(vaddr < ipc_mem->vaddr ||
 		     vaddr >= (ipc_mem->vaddr + ipc_mem->size)))
 		return -EINVAL;
-	*paddr = ipc_mem->dma_handle + (vaddr - ipc_mem->vaddr);
+	*vpu_addr = ipc_mem->dma_handle + (vaddr - ipc_mem->vaddr);
 
 	return 0;
 }
@@ -879,7 +872,7 @@ static void process_rx_fifo_entry(uint32_t entry,
 
 	dev_dbg(dev, "RX: Processing entry: %x\n", entry);
 	/* Get IPC buffer. */
-	ipc_buf = ipc_phys_to_virt(&ipc_dev->remote_ipc_mem, entry);
+	ipc_buf = ipc_vpu_to_virt(&ipc_dev->remote_ipc_mem, entry);
 	if (unlikely(!ipc_buf)) {
 		dev_warn(dev, "RX: Message out of expected memory range: %x\n",
 			 entry);
@@ -918,7 +911,7 @@ static void process_rx_fifo_entry(uint32_t entry,
 		goto exit;
 	}
 	/* Read data info. */
-	rx_data->data_paddr = ipc_buf->data_paddr;
+	rx_data->data_vpu_addr = ipc_buf->data_addr;
 	rx_data->data_size = ipc_buf->data_size;
 	/* Put data info in rx channel queue. */
 	spin_lock_irqsave(&chan->rx_lock, flags);
@@ -1033,26 +1026,26 @@ static int tx_data_send(struct keembay_ipc_dev *ipc_dev,
 	ipc_buf->channel = tx_data->chan_id;
 	ipc_buf->src_node = MY_NODE_ID;
 	ipc_buf->dst_node = tx_data->dst_node;
-	ipc_buf->data_paddr = tx_data->paddr;
+	ipc_buf->data_addr = tx_data->vpu_addr;
 	ipc_buf->data_size = tx_data->size;
 	/* Ensure changes to IPC Buffer are performed before entry is sent. */
 	wmb();
 
-	/* Initialize entry to ipc_buf Physical address. */
-	rc = ipc_virt_to_phys(&kmb_ipc_dev->local_ipc_mem, ipc_buf, &entry);
+	/* Initialize entry to ipc_buf VPU address. */
+	rc = ipc_virt_to_vpu(&kmb_ipc_dev->local_ipc_mem, ipc_buf, &entry);
 
 	/*
-	 * Check validity of IPC buffer physical address (these errors never
+	 * Check validity of IPC buffer VPU address (this error should never
 	 * occur if IPC buffer region is defined properly in Device Tree).
 	 */
 	if (unlikely(rc)) {
-		dev_err(dev, "Cannot convert IPC buf vaddr to paddr: %p\n",
+		dev_err(dev, "Cannot convert IPC buf vaddr to vpu_addr: %p\n",
 			ipc_buf);
 		rc = -ENXIO;
 		goto exit;
 	}
-	if (unlikely(entry & 0x3F)) {
-		dev_err(dev, "Allocated IPC buf is not 64-bit aligned: %p\n",
+	if (unlikely(!IS_ALIGNED(entry, KMB_IPC_ALIGNMENT))) {
+		dev_err(dev, "Allocated IPC buf is not 64-byte aligned: %p\n",
 			ipc_buf);
 		rc = -EFAULT;
 		goto exit;
@@ -1230,7 +1223,7 @@ static int tx_thread_fn(void *ptr)
 
 /* Internal send. */
 static int __ipc_send(struct keembay_ipc_dev *ipc_dev, u8 dst_node,
-		      u16 chan_id, u32 paddr, size_t size)
+		      u16 chan_id, u32 vpu_addr, size_t size)
 {
 	struct ipc_link *link = &ipc_dev->leon_mss_link;
 	struct tx_data *tx_data;
@@ -1242,7 +1235,7 @@ static int __ipc_send(struct keembay_ipc_dev *ipc_dev, u8 dst_node,
 		return -ENOMEM;
 	tx_data->dst_node = dst_node;
 	tx_data->chan_id = chan_id;
-	tx_data->paddr = paddr;
+	tx_data->vpu_addr = vpu_addr;
 	tx_data->size = size;
 	tx_data->retv = 1;
 	INIT_LIST_HEAD(&tx_data->list);
@@ -1340,12 +1333,13 @@ EXPORT_SYMBOL(intel_keembay_ipc_close_channel);
  * @node_id:	The node ID of the remote node (i.e., the intended recipient of
  *		the message).
  * @chan_id:	The IPC channel to be used to send the message.
- * @paddr:	The physical address of the data to be transferred.
+ * @vpu_addr:	The VPU address of the data to be transferred.
  * @size:	The size of the data to be transferred.
  *
  * Return:	0 on success, negative error code otherwise.
  */
-int intel_keembay_ipc_send(u8 node_id, u16 chan_id, uint32_t paddr, size_t size)
+int intel_keembay_ipc_send(u8 node_id, u16 chan_id, uint32_t vpu_addr,
+			   size_t size)
 {
 	struct ipc_link *link = &kmb_ipc_dev->leon_mss_link;
 	struct device *dev = &kmb_ipc_dev->plat_dev->dev;
@@ -1368,7 +1362,7 @@ int intel_keembay_ipc_send(u8 node_id, u16 chan_id, uint32_t paddr, size_t size)
 		goto exit;
 	}
 
-	rc = __ipc_send(kmb_ipc_dev, node_id, chan_id, paddr, size);
+	rc = __ipc_send(kmb_ipc_dev, node_id, chan_id, vpu_addr, size);
 exit:
 	/* End sleepable RCU critical section. */
 	srcu_read_unlock(&link->srcu_sp[chan_id], idx);
@@ -1381,7 +1375,7 @@ EXPORT_SYMBOL(intel_keembay_ipc_send);
  * @node_id:	The node ID of the remote node (used to identify the link we
  *		want to receive from).
  * @chan_id:	The IPC channel to read from.
- * @paddr:	[out] The physical address of the received data.
+ * @vpu_addr:	[out] The VPU address of the received data.
  * @size:	[out] Where to store the size of the received data.
  * @timeout:	How long (in ms) the function will block waiting for an IPC
  *		message; if UINT32_MAX it will block indefinitely; if 0 it
@@ -1389,7 +1383,7 @@ EXPORT_SYMBOL(intel_keembay_ipc_send);
  *
  * Return:	0 on success, negative error code otherwise
  */
-int intel_keembay_ipc_recv(u8 node_id, u16 chan_id, uint32_t *paddr,
+int intel_keembay_ipc_recv(u8 node_id, u16 chan_id, uint32_t *vpu_addr,
 			   size_t *size, u32 timeout)
 {
 	struct ipc_link *link = &kmb_ipc_dev->leon_mss_link;
@@ -1467,7 +1461,7 @@ int intel_keembay_ipc_recv(u8 node_id, u16 chan_id, uint32_t *paddr,
 		spin_unlock_irqrestore(&chan->rx_lock, flags);
 	} while (!rx_entry);
 	/* Set output parameters. */
-	*paddr =  rx_entry->data_paddr;
+	*vpu_addr =  rx_entry->data_vpu_addr;
 	*size = rx_entry->data_size;
 	/* Free RX entry. */
 	kfree(rx_entry);
-- 
2.27.0

