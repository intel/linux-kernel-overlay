From 784925eb50ba64e155ef9db4010d02b912af8b30 Mon Sep 17 00:00:00 2001
From: Ricardo Neri <ricardo.neri-calderon@linux.intel.com>
Date: Sat, 28 Mar 2020 15:41:46 -0700
Subject: [PATCH 43/76] DEBUG: thermal: intel: Add debugfs entries

Cc: Andi Kleen <ak@linux.intel.com>
Cc: Aubrey Li <aubrey.li@intel.com>
Cc: Len Brown <len.brown@intel.com>
Cc: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Cc: Tim Chen <tim.c.chen@linux.intel.com>
Cc: "Ravi V. Shankar" <ravi.v.shankar@intel.com>
Signed-off-by: Ricardo Neri <ricardo.neri-calderon@linux.intel.com>
---
 drivers/thermal/intel/intel_hfi.c | 150 ++++++++++++++++++++++++++++++
 1 file changed, 150 insertions(+)

diff --git a/drivers/thermal/intel/intel_hfi.c b/drivers/thermal/intel/intel_hfi.c
index 8d0c67428b0f..af0a8fb3f657 100644
--- a/drivers/thermal/intel/intel_hfi.c
+++ b/drivers/thermal/intel/intel_hfi.c
@@ -20,6 +20,8 @@
 
 #include <linux/cpu.h>
 #include <linux/cpuset.h>
+#include <linux/debugfs.h>
+#include <linux/gfp.h>
 #include <linux/io.h>
 #include <linux/slab.h>
 
@@ -128,6 +130,142 @@ static bool asym_capacity_initialized;
 static struct hfi_cpu_data class0_max_caps;
 static struct hfi_cpu_data class0_min_caps = { U8_MAX, U8_MAX };
 
+#ifdef CONFIG_DEBUG_FS
+static int cpu_capacities_show(struct seq_file *m, void *data)
+{
+	int cpu;
+
+	seq_printf(m, "CPU capacities from arch_scale_cpu_capacity()\n");
+	for_each_online_cpu(cpu)
+		seq_printf(m, "CPU %d capacity %ld\n",
+			   cpu, arch_scale_cpu_capacity(cpu));
+
+	return 0;
+}
+DEFINE_SHOW_ATTRIBUTE(cpu_capacities);
+
+static int hfi_features_show(struct seq_file *s, void *unused)
+{
+	seq_printf(s, "Capabilities:\t\t0x%lx\n", hfi_features.capabilities);
+	seq_printf(s, "Table pages:\t\t%d\n", hfi_features.nr_table_pages);
+	seq_printf(s, "CPU stride:\t\t0x%x\n", hfi_features.cpu_stride);
+
+	return 0;
+}
+DEFINE_SHOW_ATTRIBUTE(hfi_features);
+
+static int hfi_state_show(struct seq_file *s, void *unused)
+{
+	struct hfi_params *params = s->private;
+	struct hfi_hdr *hfi_hdr = params->hdr;
+	u64 msr_val;
+	int cpu;
+
+	/* Dump the relevant registers */
+	rdmsrl_on_cpu(params->handling_cpu, MSR_IA32_PACKAGE_THERM_STATUS, &msr_val);
+	seq_printf(s, "MSR_IA32_PACKAGE_THERM_STATUS:\t\t0x%llx HFI status:%lld\n",
+		   msr_val, (msr_val & 0x4000000) >> 26);
+
+	rdmsrl_on_cpu(params->handling_cpu, MSR_IA32_PACKAGE_THERM_INTERRUPT, &msr_val);
+	seq_printf(s, "MSR_IA32_PACKAGE_THERM_INTERRUPT:\t0x%llx HFI intr: %lld \n",
+		   msr_val, (msr_val & 0x2000000) >> 25);
+
+	rdmsrl_on_cpu(params->handling_cpu, MSR_IA32_HW_FEEDBACK_PTR, &msr_val);
+	seq_printf(s, "MSR_IA32_HW_FEEDBACK_PTR:\t\t0x%llx\n", msr_val);
+
+	rdmsrl_on_cpu(params->handling_cpu, MSR_IA32_HW_FEEDBACK_CONFIG, &msr_val);
+	seq_printf(s, "MSR_IA32_HW_FEEDBACK_CONFIG:\t\t0x%llx\n", msr_val);
+
+	/* Dump the HFI table parameters */
+	seq_printf(s, "\nInitialized:\t%d\n", params->initialized);
+	seq_printf(s, "Table base:\t0x%lx\n", (unsigned long)params->table_base);
+	seq_printf(s, "Headers base:\t0x%lx\n", (unsigned long)params->hdr);
+	seq_printf(s, "Data base:\t0x%lx\n", (unsigned long)params->data);
+	seq_printf(s, "Die id:\t\t%u\n", params->die_id);
+	seq_printf(s, "Handling CPU:\t%u\n", params->handling_cpu);
+	seq_printf(s, "CPUs:\t\t%*pbl\n", cpumask_pr_args(params->cpus));
+	seq_printf(s, "Timestamp:\t%lld\n", *params->ts_counter);
+	seq_printf(s, "\nPer-CPU params:\n");
+	seq_printf(s, "CPU\tAddress\n");
+	for_each_cpu(cpu, params->cpus) {
+		seq_printf(s, "%4d\t%p\n", cpu, per_cpu(hfi_cpu_info, cpu).params);
+	}
+
+	/* Dump the performance capability change indication */
+	seq_printf(s, "\nPerf Cap Change Indication:");
+	seq_printf(s, "%u", hfi_hdr->perf_updated);
+
+	/* Dump the energy efficiency capability change indication */
+	seq_printf(s, "\n\nEnergy Efficiency Cap Change Indication:");
+	seq_printf(s, "%u\n", hfi_hdr->ee_updated);
+
+	/* Dump the HFI table */
+	seq_printf(s, "\nHFI table:\n");
+	seq_printf(s, "CPU\tIndex");
+	seq_printf(s, "\tPe  Ef");
+
+	seq_printf(s, "\n");
+	for_each_cpu(cpu, params->cpus) {
+		s16 index = per_cpu(hfi_cpu_info, cpu).index;
+		void *data_ptr = params->data +
+				       index * hfi_features.cpu_stride;
+		struct hfi_cpu_data *data = data_ptr;
+
+		seq_printf(s, "%4u\t%4d", cpu, index);
+		seq_printf(s, "\t%3u %3u", data->perf_cap, data->ee_cap);
+		seq_printf(s, "\n");
+	}
+
+	return 0;
+}
+
+static int hfi_state_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, hfi_state_show, inode->i_private);
+}
+
+static const struct file_operations hfi_state_ops = {
+	.open		= hfi_state_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static struct dentry *hfi_debugfs_dir;
+
+static void hfi_dbgfs_unregister(void)
+{
+	debugfs_remove_recursive(hfi_debugfs_dir);
+}
+
+static int hfi_dbgfs_register(void)
+{
+	struct dentry *f;
+
+	hfi_debugfs_dir = debugfs_create_dir("intel_hw_feedback", NULL);
+	if (!hfi_debugfs_dir)
+		return -ENOMEM;
+
+	f = debugfs_create_file("capacities", 0444, hfi_debugfs_dir,
+				NULL, &cpu_capacities_fops);
+	if (!f)
+		goto err;
+
+	f = debugfs_create_file("features", 0444, hfi_debugfs_dir,
+				NULL, &hfi_features_fops);
+
+	return 0;
+err:
+	hfi_dbgfs_unregister();
+	return -ENODEV;
+}
+#else
+static int hfi_dbgfs_register(void)
+{
+	return 0;
+}
+#endif /* CONFIG_DEBUG_FS */
+
 bool hfi_has_hw_sched_feedback(void)
 {
 	return boot_cpu_has(X86_FEATURE_INTEL_HFI);
@@ -682,6 +820,16 @@ int enable_hfi(unsigned int cpu)
 	params->die_id = die_id;
 	info->params = params;
 
+#ifdef CONFIG_DEBUG_FS
+	if (hfi_debugfs_dir) {
+		char name[64];
+
+		snprintf(name, 64, "hw_state%u", die_id);
+		debugfs_create_file(name, 0444, hfi_debugfs_dir, params,
+				    &hfi_state_ops);
+	}
+#endif
+
 	/* Enable the hardware feedback interface. */
 	rdmsrl(MSR_IA32_HW_FEEDBACK_CONFIG, msr_val);
 	msr_val |= HFI_CONFIG_ENABLE_BIT;
@@ -815,4 +963,6 @@ void __init intel_hfi_init(void)
 		pr_err("No memory for HFI param instances\n");
 		return;
 	}
+
+	hfi_dbgfs_register();
 }
-- 
2.27.0

