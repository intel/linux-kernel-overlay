From 090388e903c6492e9bc9d581a931263630911c77 Mon Sep 17 00:00:00 2001
From: Paul Murphy <paul.j.murphy@intel.com>
Date: Wed, 29 Apr 2020 16:19:04 +0100
Subject: [PATCH 103/223] keembay-vpu-ipc: Fix reset

Reset as it was implemented, assumes that we can just trigger a reset of
the VPU without loading firmware. That is not the case - we need to
reload the firmware for the VPU to be able to boot.

From an internal state machine point of view, there is now no such thing
as reset, but boot, with or without a filename. We will store off the
filename when it's provided.

Removing RESET code where relevant.

Signed-off-by: Paul Murphy <paul.j.murphy@intel.com>
---
 drivers/firmware/keembay-vpu-ipc.c | 208 +++++++++++++----------------
 1 file changed, 96 insertions(+), 112 deletions(-)

diff --git a/drivers/firmware/keembay-vpu-ipc.c b/drivers/firmware/keembay-vpu-ipc.c
index 2f1c8b80fbbd..13ab9a5ae5b0 100644
--- a/drivers/firmware/keembay-vpu-ipc.c
+++ b/drivers/firmware/keembay-vpu-ipc.c
@@ -22,13 +22,11 @@
 #include <linux/of_platform.h>
 #include <linux/of_reserved_mem.h>
 #include <linux/platform_device.h>
+#include <linux/slab.h>
 
 /* Function ID for the SiP SMC to boot the VPU */
 #define KMB_SIP_SVC_VPU_BOOT (0xFF10)
 
-/* Function ID for the SiP SMC to reset the VPU */
-#define KMB_SIP_SVC_VPU_RESET (0xFF15)
-
 /* Function ID for the SiP SMC to stop the VPU */
 #define KMB_SIP_SVC_VPU_STOP (0xFF16)
 
@@ -215,12 +213,12 @@ struct vpu_ipc_dev {
 	unsigned int mss_wdt_count;
 	wait_queue_head_t ready_queue;
 	struct device *ipc_dev;
+	char *firmware_name;
 };
 
 enum keembay_vpu_event {
 	KEEMBAY_VPU_EVENT_BOOT = 0,
 	KEEMBAY_VPU_EVENT_BOOT_FAILED,
-	KEEMBAY_VPU_EVENT_RESET,
 	KEEMBAY_VPU_EVENT_STOP,
 	KEEMBAY_VPU_EVENT_STOP_COMPLETE,
 	KEEMBAY_VPU_EVENT_NCE_WDT_TIMEOUT,
@@ -273,6 +271,10 @@ static int vpu_ipc_handle_event(struct vpu_ipc_dev *vpu_dev,
 		}
 		break;
 	case KEEMBAY_VPU_READY:
+		if (event == KEEMBAY_VPU_EVENT_BOOT) {
+			vpu_dev->state = KEEMBAY_VPU_BUSY;
+			rc = 0;
+		}
 		if (event == KEEMBAY_VPU_EVENT_NCE_WDT_TIMEOUT ||
 		    event == KEEMBAY_VPU_EVENT_MSS_WDT_TIMEOUT) {
 			vpu_dev->state = KEEMBAY_VPU_ERROR;
@@ -280,10 +282,6 @@ static int vpu_ipc_handle_event(struct vpu_ipc_dev *vpu_dev,
 		}
 		fallthrough;
 	case KEEMBAY_VPU_ERROR:
-		if (event == KEEMBAY_VPU_EVENT_RESET) {
-			vpu_dev->state = KEEMBAY_VPU_BUSY;
-			rc = 0;
-		}
 		if (event == KEEMBAY_VPU_EVENT_STOP) {
 			vpu_dev->state = KEEMBAY_VPU_STOPPING;
 			rc = 0;
@@ -793,27 +791,6 @@ static int request_vpu_boot(struct vpu_ipc_dev *vpu_dev)
 	return 0;
 }
 
-static int request_vpu_reset(struct vpu_ipc_dev *vpu_dev)
-{
-	uint64_t function_id;
-	uint16_t function_number = KMB_SIP_SVC_VPU_RESET;
-	struct arm_smccc_res res;
-
-	function_id = ARM_SMCCC_CALL_VAL(ARM_SMCCC_FAST_CALL, ARM_SMCCC_SMC_32,
-					 ARM_SMCCC_OWNER_SIP, function_number);
-
-	arm_smccc_smc(function_id, vpu_dev->vpu_id, 0, 0, 0, 0, 0, 0, &res);
-
-	if (res.a0) {
-		dev_info(&vpu_dev->pdev->dev, "Reset failed: 0x%lx.\n", res.a0);
-		return -EIO;
-	}
-
-	dev_info(&vpu_dev->pdev->dev, "Reset SMC successful.\n");
-
-	return 0;
-}
-
 static int request_vpu_stop(struct vpu_ipc_dev *vpu_dev)
 {
 	uint64_t function_id;
@@ -1160,6 +1137,89 @@ static int kickoff_vpu_sequence(struct vpu_ipc_dev *vpu_dev,
 	return rc;
 }
 
+static int do_boot_sequence(struct vpu_ipc_dev *vpu_dev,
+			    const char *firmware_name)
+{
+	int rc;
+	int event_rc;
+	const struct firmware *fw;
+	struct device *dev = &vpu_dev->pdev->dev;
+
+	rc = vpu_ipc_handle_event(vpu_dev, KEEMBAY_VPU_EVENT_BOOT);
+	if (rc < 0) {
+		dev_err(dev, "Can't start in this state.\n");
+		return rc;
+	}
+
+	/* Stop the VPU running */
+	rc = request_vpu_stop(vpu_dev);
+	if (rc < 0)
+		dev_err(dev, "Failed stop - continue sequence anyway.\n");
+
+	/*
+	 * If we are given a firmware name, let's work with that, otherwise,
+	 * we will try to boot the last attempted version - which is a reset
+	 * call situation.
+	 */
+	if (firmware_name) {
+		kfree(vpu_dev->firmware_name);
+		vpu_dev->firmware_name = kstrdup(firmware_name, GFP_KERNEL);
+	}
+	if (!vpu_dev->firmware_name) {
+		rc = -EINVAL;
+		dev_err(dev, "Boot requested, but no firmware name provided.\n");
+		goto boot_failed_no_fw;
+	}
+
+	dev_info(dev, "Keem Bay VPU IPC start with %s.\n", vpu_dev->firmware_name);
+
+	/* Request firmware and wait for it. */
+	rc = request_firmware(&fw, vpu_dev->firmware_name, &vpu_dev->pdev->dev);
+	if (rc < 0) {
+		dev_err(dev, "Couldn't find firmware: %d\n", rc);
+		goto boot_failed_no_fw;
+	}
+
+	/* Do checks on the firmware header. */
+	rc = parse_fw_header(vpu_dev, fw);
+	if (rc < 0) {
+		dev_err(dev, "Firmware checks failed.\n");
+		goto boot_failed;
+	}
+
+	/* Write configuration data. */
+	rc = setup_boot_parameters(vpu_dev);
+	if (rc < 0) {
+		dev_err(dev, "Failed to set up boot parameters.\n");
+		goto boot_failed;
+	}
+
+	/* Try 'boot' sequence */
+	rc = kickoff_vpu_sequence(vpu_dev, request_vpu_boot);
+	if (rc < 0) {
+		dev_err(dev, "Failed to boot VPU.\n");
+		goto boot_failed;
+	}
+
+	release_firmware(fw);
+	return 0;
+
+boot_failed:
+	release_firmware(fw);
+
+boot_failed_no_fw:
+	event_rc = vpu_ipc_handle_event(vpu_dev,
+					KEEMBAY_VPU_EVENT_BOOT_FAILED);
+	if (event_rc < 0)
+		dev_err(dev, "Fatal error: failed to handle fail event: %d.\n",
+				event_rc);
+
+	/* Prefer original 'rc' to the 'event_rc'. */
+
+	return rc;
+
+}
+
 int intel_keembay_vpu_ipc_open_channel(struct device *dev, u8 node_id,
 				       u16 chan_id)
 {
@@ -1235,66 +1295,13 @@ EXPORT_SYMBOL(intel_keembay_vpu_ipc_recv);
  */
 int intel_keembay_vpu_startup(struct device *dev, const char *firmware_name)
 {
-	int rc;
-	int event_rc;
-	const struct firmware *fw;
 	struct vpu_ipc_dev *vpu_dev = to_vpu_dev(dev);
 
 	if (IS_ERR(vpu_dev))
 		return -EINVAL;
 
-	rc = vpu_ipc_handle_event(vpu_dev, KEEMBAY_VPU_EVENT_BOOT);
-	if (rc < 0) {
-		dev_err(dev, "Can't start in this state.\n");
-		return rc;
-	}
-
-	dev_info(dev, "Keem Bay VPU IPC start with %s.\n", firmware_name);
-
-	/* Request firmware and wait for it. */
-	rc = request_firmware(&fw, firmware_name, &vpu_dev->pdev->dev);
-	if (rc < 0) {
-		dev_err(dev, "Couldn't find firmware: %d\n", rc);
-		goto boot_failed_no_fw;
-	}
-
-	/* Do checks on the firmware header. */
-	rc = parse_fw_header(vpu_dev, fw);
-	if (rc < 0) {
-		dev_err(dev, "Firmware checks failed.\n");
-		goto boot_failed;
-	}
-
-	/* Write configuration data. */
-	rc = setup_boot_parameters(vpu_dev);
-	if (rc < 0) {
-		dev_err(dev, "Failed to set up boot parameters.\n");
-		goto boot_failed;
-	}
-
-	/* Try 'boot' sequence */
-	rc = kickoff_vpu_sequence(vpu_dev, request_vpu_boot);
-	if (rc < 0) {
-		dev_err(dev, "Failed to boot VPU.\n");
-		goto boot_failed;
-	}
-
-	release_firmware(fw);
-	return 0;
-
-boot_failed:
-	release_firmware(fw);
+	return do_boot_sequence(vpu_dev, firmware_name);
 
-boot_failed_no_fw:
-	event_rc = vpu_ipc_handle_event(vpu_dev,
-					KEEMBAY_VPU_EVENT_BOOT_FAILED);
-	if (event_rc < 0)
-		dev_err(dev, "Fatal error: failed to handle fail event: %d.\n",
-				event_rc);
-
-	/* Prefer original 'rc' to the 'event_rc'. */
-
-	return rc;
 }
 EXPORT_SYMBOL(intel_keembay_vpu_startup);
 
@@ -1308,40 +1315,12 @@ EXPORT_SYMBOL(intel_keembay_vpu_startup);
  */
 int intel_keembay_vpu_reset(struct device *dev)
 {
-	int rc;
-	int event_rc;
 	struct vpu_ipc_dev *vpu_dev = to_vpu_dev(dev);
 
 	if (IS_ERR(vpu_dev))
 		return -EINVAL;
 
-	rc = vpu_ipc_handle_event(vpu_dev, KEEMBAY_VPU_EVENT_RESET);
-	if (rc < 0) {
-		dev_err(dev, "Can't reset in this state.\n");
-		return rc;
-	}
-
-	dev_info(dev, "Keem Bay VPU IPC reset.\n");
-
-	/* Try 'reset' sequence */
-	rc = kickoff_vpu_sequence(vpu_dev, request_vpu_reset);
-	if (rc < 0) {
-		dev_err(dev, "Failed to reset VPU.\n");
-		goto reset_failed;
-	}
-
-	return 0;
-
-reset_failed:
-	/* Reset failed somewhere, reset the state. */
-	event_rc = vpu_ipc_handle_event(vpu_dev, KEEMBAY_VPU_EVENT_BOOT_FAILED);
-	if (event_rc < 0)
-		dev_err(dev, "Fatal error: failed to handle fail event: %d.\n",
-				event_rc);
-
-	/* Prefer original 'rc' to the 'event_rc'. */
-
-	return rc;
+	return do_boot_sequence(vpu_dev, NULL);
 }
 EXPORT_SYMBOL(intel_keembay_vpu_reset);
 
@@ -1377,6 +1356,10 @@ int intel_keembay_vpu_stop(struct device *dev)
 			"Failed to do request to stop - resetting state to OFF anyway.\n");
 	}
 
+	/* Remove any saved-off name */
+	kfree(vpu_dev->firmware_name);
+	vpu_dev->firmware_name = NULL;
+
 	event_rc = vpu_ipc_handle_event(vpu_dev,
 					KEEMBAY_VPU_EVENT_STOP_COMPLETE);
 	if (event_rc < 0) {
@@ -1497,6 +1480,7 @@ static int keembay_vpu_ipc_probe(struct platform_device *pdev)
 	vpu_dev->pdev = pdev;
 	vpu_dev->state = KEEMBAY_VPU_OFF;
 	vpu_dev->ready_message_task = NULL;
+	vpu_dev->firmware_name = NULL;
 	vpu_dev->nce_wdt_count = 0;
 	vpu_dev->mss_wdt_count = 0;
 	spin_lock_init(&vpu_dev->lock);
-- 
2.27.0

