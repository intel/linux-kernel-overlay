From 7f7a0769eeeab1954c393897d8973d5a636e8d19 Mon Sep 17 00:00:00 2001
From: wangjue <wang.jue@intel.com>
Date: Thu, 24 Dec 2020 21:53:24 +0800
Subject: [PATCH 139/223] misc: vpumgr: Add DEC400 codec support in vpumgr
 driver

To support DEC400 codec, a new API is implemented in vpumgr driver
to fetch the intermediate data structure which contains the compression
meta data of the decoded frame, VPUAL will call this API to get and pass
the meta data to VPUIP.

Signed-off-by: wangjue <wang.jue@intel.com>
---
 drivers/misc/vpumgr/vpu_mgr.c | 11 +++++++++++
 drivers/misc/vpumgr/vpu_smm.c | 37 +++++++++++++++++++++++++++++++++++
 drivers/misc/vpumgr/vpu_smm.h |  3 ++-
 include/uapi/misc/vpumgr.h    | 34 +++++++++++++++++++++++++++++++-
 4 files changed, 83 insertions(+), 2 deletions(-)

diff --git a/drivers/misc/vpumgr/vpu_mgr.c b/drivers/misc/vpumgr/vpu_mgr.c
index f7ce6ef5a15e..5a2fe9320e88 100644
--- a/drivers/misc/vpumgr/vpu_mgr.c
+++ b/drivers/misc/vpumgr/vpu_mgr.c
@@ -137,6 +137,8 @@ static long vpumgr_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 	const unsigned int io_size = _IOC_SIZE(cmd);
 	struct vpumgr_vcm_submit *vs;
 	struct vpumgr_vcm_wait *vw;
+	struct _VIV_VIDMEM_METADATA *meta_info = NULL;
+	struct vpumgr_args_fetch_meta *pa;
 	char tmp[128];
 	int rc = 0;
 
@@ -183,6 +185,15 @@ static long vpumgr_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 		rc = vcm_wait(&vpriv->ctx, vw->submit_id, &vw->vpu_rc,
 			      (void *)vw->out, &vw->out_len, vw->timeout_ms);
 		break;
+	case VPUMGR_IOCTL_FETCH_META:
+		rc = smm_fetch_meta(&vpriv->smm, (void *)tmp, &meta_info);
+		pa = (struct vpumgr_args_fetch_meta *)tmp;
+		if (!rc) {
+			if (copy_to_user(pa->meta_buffer, meta_info,
+				sizeof(struct _VIV_VIDMEM_METADATA)) != 0)
+				return -EFAULT;
+		}
+		break;
 	}
 
 	if (!rc) {
diff --git a/drivers/misc/vpumgr/vpu_smm.c b/drivers/misc/vpumgr/vpu_smm.c
index 7f2caa27d12d..7f705b219ff3 100644
--- a/drivers/misc/vpumgr/vpu_smm.c
+++ b/drivers/misc/vpumgr/vpu_smm.c
@@ -57,6 +57,13 @@ struct vpusmm_impbuf {
 	int refcount;
 };
 
+static inline u32 __fourcc(char a, char b, char c, char d)
+{
+	return ((u32)(a) <<  0) |
+			((u32)(b) << 8) |
+			((u32)(c) << 16) |
+			((u32)(d) << 24);
+}
 /*
  * VPU imported dmabuf management
  */
@@ -490,6 +497,36 @@ int smm_ptr2vpu(struct vpumgr_smm *sess, unsigned long *arg)
 	return -EFAULT;
 }
 
+int smm_fetch_meta(struct vpumgr_smm *sess, struct vpumgr_args_fetch_meta *arg,
+		struct _VIV_VIDMEM_METADATA **meta_info)
+{
+	struct device *dev = sess->vdev->sdev;
+	struct dma_buf *dmabuf;
+
+	dmabuf = dma_buf_get(arg->fd);
+	if (IS_ERR(dmabuf))
+		return -EINVAL;
+
+	if (arg->size != sizeof(struct _VIV_VIDMEM_METADATA)) {
+		dev_err(dev, "_VIV_VIDMEM_METADATA size mismatched, failed to fetch meta_info\n");
+		return -EINVAL;
+	}
+
+	if (!dmabuf->priv) {
+		dev_err(dev, "dmabuf->priv is NULL, failed to fetch meta_info\n");
+		return -EINVAL;
+	}
+
+	*meta_info = (struct _VIV_VIDMEM_METADATA *)(dmabuf->priv);
+	dev_dbg(dev, "meta_info->magic = 0x%x\n", (*meta_info)->magic);
+	if ((*meta_info)->magic != __fourcc('V', 'I', 'V', 'M')) {
+		dev_err(dev, "invalid meta_info\n");
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
 int smm_debugfs_stats_show(struct seq_file *file, struct vpumgr_smm *sess)
 {
 	struct rb_node *cur, *next;
diff --git a/drivers/misc/vpumgr/vpu_smm.h b/drivers/misc/vpumgr/vpu_smm.h
index ff547649d95c..a41f16a57978 100644
--- a/drivers/misc/vpumgr/vpu_smm.h
+++ b/drivers/misc/vpumgr/vpu_smm.h
@@ -24,7 +24,8 @@ int smm_alloc(struct vpumgr_smm *sess, struct vpumgr_args_alloc *arg);
 int smm_import(struct vpumgr_smm *sess, struct vpumgr_args_import *arg);
 int smm_unimport(struct vpumgr_smm *sess, int *p_dmabuf_fd);
 int smm_ptr2vpu(struct vpumgr_smm *sess, unsigned long *arg);
-
+int smm_fetch_meta(struct vpumgr_smm *sess, struct vpumgr_args_fetch_meta *arg,
+	struct _VIV_VIDMEM_METADATA **meta_info);
 int smm_debugfs_stats_show(struct seq_file *file, struct vpumgr_smm *sess);
 
 #endif
diff --git a/include/uapi/misc/vpumgr.h b/include/uapi/misc/vpumgr.h
index 910b26e60097..3b8737a39a25 100644
--- a/include/uapi/misc/vpumgr.h
+++ b/include/uapi/misc/vpumgr.h
@@ -17,7 +17,8 @@
 #define VPUMGR_IOCTL_DMABUF_PTR2VPU	_IOWR(VPUMGR_MAGIC, 5, __u64)
 #define VPUMGR_IOCTL_VCM_SUBMIT		_IOWR(VPUMGR_MAGIC, 6, struct vpumgr_vcm_submit)
 #define VPUMGR_IOCTL_VCM_WAIT		_IOWR(VPUMGR_MAGIC, 7, struct vpumgr_vcm_wait)
-#define VPUMGR_IOCTL_END		_IO(VPUMGR_MAGIC, 8)
+#define VPUMGR_IOCTL_FETCH_META	_IOWR(VPUMGR_MAGIC, 8, struct vpumgr_args_fetch_meta)
+#define VPUMGR_IOCTL_END		_IO(VPUMGR_MAGIC, 9)
 
 struct vpumgr_args_alloc {
 	__s32 fd;           /* out: DMABuf fd */
@@ -61,4 +62,35 @@ struct vpumgr_vcm_wait {
 	__u32 timeout_ms;   /*  in: timeout in milliseconds */
 };
 
+struct _VIV_VIDMEM_METADATA {
+	__u32 magic;                /* __FOURCC('v', 'i', 'v', 'm') */
+	__u32 dmabuf_size;          /* DMABUF buffer size in byte (Maximum 4GB) */
+	__u32 time_stamp;           /* time stamp for the DMABUF buffer */
+	__u32 image_format;         /* ImageFormat */
+	__u32 compressed;           /* if DMABUF buffer is compressed by DEC400 */
+
+	struct {
+		__u32 offset;            /* plane buffer address offset from DMABUF address */
+		__u32 stride;            /* pitch in byte */
+		__u32 width;             /* width in pixels */
+		__u32 height;            /* height in pixels */
+		__u32 tile_format;       /* uncompressed tile format */
+		__u32 compress_format;   /* tile mode for DEC400 */
+		__u32 ts_offset;         /* tile status buffer offset within this plane buffer */
+		__s32 ts_fd;             /* fd of separate tile status buffer of the plane buffer */
+		__s32 ts_fd2;            /* valid fd of the ts buffer in consumer side */
+		__s32 ts_vaddr;          /* the vpu virtual address for this ts data buffer */
+		__u32 fc_enabled;        /* gpu fastclear enabled for the plane buffer */
+		__u32 fc_value_lower;    /* gpu fastclear color value (lower 32 bits)
+								for the plane buffer */
+		__u32 fc_value_upper;    /* gpu fastclear color value (upper 32 bits)
+								for the plane buffer */
+	} plane[3];
+};
+
+struct vpumgr_args_fetch_meta {
+	__s32 fd;           /*  in: input DMABuf fd */
+	__u64 size;         /*  in: the size of struct _VIV_VIDMEM_METADATA */
+	void *meta_buffer; /*out: buffer pointer to get VSI Meta Data */
+};
 #endif /* __VPUMGR_UAPI_H */
-- 
2.27.0

