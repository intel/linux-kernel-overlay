From 2e651cf146fe04908cec38d1d779a4ab17ccb766 Mon Sep 17 00:00:00 2001
From: Daniele Alessandrelli <daniele.alessandrelli@intel.com>
Date: Mon, 25 Nov 2019 14:10:35 +0000
Subject: [PATCH 082/223] keembay-ipc: Enable support for multiple IPC devices

Change Keem Bay IPC API so that users must now specify the IPC device
they plan to use.

For (temporary) retro-compatibility, if the VPU/IPC device node does not
specify an IPC phandle, the IPC node to be used is searched among the
siblings of the VPU/IPC node.

The IPC test module and the Keem Bay VPU driver are updated to support
the new API by using the first IPC device they found. Future patches
will add better support.

Signed-off-by: Daniele Alessandrelli <daniele.alessandrelli@intel.com>
---
 drivers/firmware/keembay-vpu-ipc.c          | 130 ++++++++++++++------
 drivers/misc/keembay-ipc/keembay-ipc-test.c |  72 ++++++++---
 drivers/misc/keembay-ipc/keembay-ipc.c      |  75 +++++------
 include/linux/keembay-ipc.h                 |  16 ++-
 4 files changed, 190 insertions(+), 103 deletions(-)

diff --git a/drivers/firmware/keembay-vpu-ipc.c b/drivers/firmware/keembay-vpu-ipc.c
index 06990889c328..445372237cc7 100644
--- a/drivers/firmware/keembay-vpu-ipc.c
+++ b/drivers/firmware/keembay-vpu-ipc.c
@@ -19,6 +19,7 @@
 #include <linux/module.h>
 #include <linux/of.h>
 #include <linux/of_address.h>
+#include <linux/of_platform.h>
 #include <linux/of_reserved_mem.h>
 #include <linux/platform_device.h>
 
@@ -211,6 +212,7 @@ struct vpu_ipc_dev {
 	unsigned int nce_wdt_count;
 	unsigned int mss_wdt_count;
 	wait_queue_head_t ready_queue;
+	struct device *ipc_dev;
 };
 
 enum keembay_vpu_event {
@@ -225,7 +227,7 @@ enum keembay_vpu_event {
 	KEEMBAY_VPU_EVENT_MSS_READY_FAIL
 };
 
-static struct vpu_ipc_dev *vpu_ipc_dev;
+static struct vpu_ipc_dev *kmb_vpu_ipc_dev;
 
 /**
  * vpu_ipc_handle_event() - Handle events and optionally update state
@@ -552,6 +554,49 @@ static int setup_reserved_memory(struct vpu_ipc_dev *vpu_dev)
 	return rc;
 }
 
+static void ipc_device_put(struct vpu_ipc_dev *vpu_dev)
+{
+	put_device(vpu_dev->ipc_dev);
+}
+
+static int ipc_device_get(struct vpu_ipc_dev *vpu_dev)
+{
+	struct device *dev = &vpu_dev->pdev->dev;
+	struct device_node *np;
+	struct platform_device *pdev;
+
+	np = of_parse_phandle(dev->of_node, "intel,keembay-ipc", 0);
+	if (!np) {
+		dev_warn(dev, "Cannot find phandle to IPC device\n");
+		/*
+		 * For (temporary) retro-compatibility, if the IPC phandle is
+		 * not defined, we try to find an IPC device whose DT node is a
+		 * sibling of the VPU node.
+		 */
+		dev_warn(dev, "Fallback: looking for a sibling IPC node\n");
+		np = of_get_compatible_child(dev->parent->of_node,
+					     "intel,keembay-ipc");
+		if (!np) {
+			dev_err(dev, "Couldn't find a sibling IPC node\n");
+			return -ENODEV;
+		}
+	}
+
+	pdev = of_find_device_by_node(np);
+	if (!pdev) {
+		dev_info(dev, "IPC device not probed\n");
+		of_node_put(np);
+		return -EPROBE_DEFER;
+	}
+
+	vpu_dev->ipc_dev = get_device(&pdev->dev);
+	of_node_put(np);
+
+	dev_info(dev, "Using IPC device: %s\n", dev_name(vpu_dev->ipc_dev));
+
+	return 0;
+}
+
 static int retrieve_clocks(struct vpu_ipc_dev *vpu_dev)
 {
 	struct device *dev = &vpu_dev->pdev->dev;
@@ -996,7 +1041,7 @@ static int ready_message_wait_thread(void *arg)
 	 * We will wait a few seconds for the message. We will
 	 * complete earlier if the message is received earlier.
 	 */
-	rc = intel_keembay_ipc_recv(KMB_IPC_NODE_LEON_MSS,
+	rc = intel_keembay_ipc_recv(vpu_dev->ipc_dev, KMB_IPC_NODE_LEON_MSS,
 				    READY_MESSAGE_IPC_CHANNEL, &paddr, &size,
 				    READY_MESSAGE_TIMEOUT_MS);
 	if (rc < 0) {
@@ -1006,7 +1051,8 @@ static int ready_message_wait_thread(void *arg)
 	}
 
 	/* Close the channel. */
-	close_rc = intel_keembay_ipc_close_channel(KMB_IPC_NODE_LEON_MSS,
+	close_rc = intel_keembay_ipc_close_channel(vpu_dev->ipc_dev,
+						   KMB_IPC_NODE_LEON_MSS,
 						   READY_MESSAGE_IPC_CHANNEL);
 	if (close_rc < 0)
 		dev_warn(dev, "Couldn't close IPC channel.\n");
@@ -1077,7 +1123,8 @@ static int kickoff_vpu_sequence(struct vpu_ipc_dev *vpu_dev,
 	 * the VPU, we may miss the message, as the IPC driver will
 	 * discard messages for unopened channels.
 	 */
-	rc = intel_keembay_ipc_open_channel(KMB_IPC_NODE_LEON_MSS,
+	rc = intel_keembay_ipc_open_channel(vpu_dev->ipc_dev,
+					    KMB_IPC_NODE_LEON_MSS,
 					    READY_MESSAGE_IPC_CHANNEL);
 	if (rc < 0) {
 		dev_err(dev,
@@ -1108,7 +1155,8 @@ static int kickoff_vpu_sequence(struct vpu_ipc_dev *vpu_dev,
 close_and_kickoff_failed:
 	/* Close the channel. */
 	error_close_rc = intel_keembay_ipc_close_channel(
-		KMB_IPC_NODE_LEON_MSS, READY_MESSAGE_IPC_CHANNEL);
+				vpu_dev->ipc_dev, KMB_IPC_NODE_LEON_MSS,
+				READY_MESSAGE_IPC_CHANNEL);
 	if (error_close_rc < 0) {
 		dev_err(dev, "Couldn't close IPC channel.\n");
 		/*
@@ -1123,27 +1171,31 @@ static int kickoff_vpu_sequence(struct vpu_ipc_dev *vpu_dev,
 
 int intel_keembay_vpu_ipc_open_channel(u8 node_id, u16 chan_id)
 {
-	return intel_keembay_ipc_open_channel(node_id, chan_id);
+	return intel_keembay_ipc_open_channel(kmb_vpu_ipc_dev->ipc_dev,
+					      node_id, chan_id);
 }
 EXPORT_SYMBOL(intel_keembay_vpu_ipc_open_channel);
 
 int intel_keembay_vpu_ipc_close_channel(u8 node_id, u16 chan_id)
 {
-	return intel_keembay_ipc_close_channel(node_id, chan_id);
+	return intel_keembay_ipc_close_channel(kmb_vpu_ipc_dev->ipc_dev,
+					       node_id, chan_id);
 }
 EXPORT_SYMBOL(intel_keembay_vpu_ipc_close_channel);
 
 int intel_keembay_vpu_ipc_send(u8 node_id, u16 chan_id, uint32_t paddr,
 			       size_t size)
 {
-	return intel_keembay_ipc_send(node_id, chan_id, paddr, size);
+	return intel_keembay_ipc_send(kmb_vpu_ipc_dev->ipc_dev,
+				      node_id, chan_id, paddr, size);
 }
 EXPORT_SYMBOL(intel_keembay_vpu_ipc_send);
 
 int intel_keembay_vpu_ipc_recv(u8 node_id, u16 chan_id, uint32_t *paddr,
 			       size_t *size, u32 timeout)
 {
-	return intel_keembay_ipc_recv(node_id, chan_id, paddr, size, timeout);
+	return intel_keembay_ipc_recv(kmb_vpu_ipc_dev->ipc_dev,
+				      node_id, chan_id, paddr, size, timeout);
 }
 EXPORT_SYMBOL(intel_keembay_vpu_ipc_recv);
 
@@ -1173,9 +1225,9 @@ int intel_keembay_vpu_startup(const char *firmware_name)
 	int rc;
 	int event_rc;
 	const struct firmware *fw;
-	struct device *dev = &vpu_ipc_dev->pdev->dev;
+	struct device *dev = &kmb_vpu_ipc_dev->pdev->dev;
 
-	rc = vpu_ipc_handle_event(vpu_ipc_dev, KEEMBAY_VPU_EVENT_BOOT);
+	rc = vpu_ipc_handle_event(kmb_vpu_ipc_dev, KEEMBAY_VPU_EVENT_BOOT);
 	if (rc < 0) {
 		dev_err(dev, "Can't start in this state.\n");
 		return rc;
@@ -1184,28 +1236,28 @@ int intel_keembay_vpu_startup(const char *firmware_name)
 	dev_info(dev, "Keem Bay VPU IPC start with %s.\n", firmware_name);
 
 	/* Request firmware and wait for it. */
-	rc = request_firmware(&fw, firmware_name, &vpu_ipc_dev->pdev->dev);
+	rc = request_firmware(&fw, firmware_name, &kmb_vpu_ipc_dev->pdev->dev);
 	if (rc < 0) {
 		dev_err(dev, "Couldn't find firmware: %d\n", rc);
 		goto boot_failed_no_fw;
 	}
 
 	/* Do checks on the firmware header. */
-	rc = parse_fw_header(vpu_ipc_dev, fw);
+	rc = parse_fw_header(kmb_vpu_ipc_dev, fw);
 	if (rc < 0) {
 		dev_err(dev, "Firmware checks failed.\n");
 		goto boot_failed;
 	}
 
 	/* Write configuration data. */
-	rc = setup_boot_parameters(vpu_ipc_dev);
+	rc = setup_boot_parameters(kmb_vpu_ipc_dev);
 	if (rc < 0) {
 		dev_err(dev, "Failed to set up boot parameters.\n");
 		goto boot_failed;
 	}
 
 	/* Try 'boot' sequence */
-	rc = kickoff_vpu_sequence(vpu_ipc_dev, request_vpu_boot);
+	rc = kickoff_vpu_sequence(kmb_vpu_ipc_dev, request_vpu_boot);
 	if (rc < 0) {
 		dev_err(dev, "Failed to boot VPU.\n");
 		goto boot_failed;
@@ -1218,8 +1270,8 @@ int intel_keembay_vpu_startup(const char *firmware_name)
 	release_firmware(fw);
 
 boot_failed_no_fw:
-	event_rc = vpu_ipc_handle_event(vpu_ipc_dev,
-			KEEMBAY_VPU_EVENT_BOOT_FAILED);
+	event_rc = vpu_ipc_handle_event(kmb_vpu_ipc_dev,
+					KEEMBAY_VPU_EVENT_BOOT_FAILED);
 	if (event_rc < 0)
 		dev_err(dev, "Fatal error: failed to handle fail event: %d.\n",
 				event_rc);
@@ -1242,9 +1294,9 @@ int intel_keembay_vpu_reset(void)
 {
 	int rc;
 	int event_rc;
-	struct device *dev = &vpu_ipc_dev->pdev->dev;
+	struct device *dev = &kmb_vpu_ipc_dev->pdev->dev;
 
-	rc = vpu_ipc_handle_event(vpu_ipc_dev, KEEMBAY_VPU_EVENT_RESET);
+	rc = vpu_ipc_handle_event(kmb_vpu_ipc_dev, KEEMBAY_VPU_EVENT_RESET);
 	if (rc < 0) {
 		dev_err(dev, "Can't reset in this state.\n");
 		return rc;
@@ -1253,7 +1305,7 @@ int intel_keembay_vpu_reset(void)
 	dev_info(dev, "Keem Bay VPU IPC reset.\n");
 
 	/* Try 'reset' sequence */
-	rc = kickoff_vpu_sequence(vpu_ipc_dev, request_vpu_reset);
+	rc = kickoff_vpu_sequence(kmb_vpu_ipc_dev, request_vpu_reset);
 	if (rc < 0) {
 		dev_err(dev, "Failed to reset VPU.\n");
 		goto reset_failed;
@@ -1263,8 +1315,8 @@ int intel_keembay_vpu_reset(void)
 
 reset_failed:
 	/* Reset failed somewhere, reset the state. */
-	event_rc = vpu_ipc_handle_event(vpu_ipc_dev,
-			KEEMBAY_VPU_EVENT_BOOT_FAILED);
+	event_rc = vpu_ipc_handle_event(kmb_vpu_ipc_dev,
+					KEEMBAY_VPU_EVENT_BOOT_FAILED);
 	if (event_rc < 0)
 		dev_err(dev, "Fatal error: failed to handle fail event: %d.\n",
 				event_rc);
@@ -1287,9 +1339,9 @@ int intel_keembay_vpu_stop(void)
 {
 	int rc;
 	int event_rc;
-	struct device *dev = &vpu_ipc_dev->pdev->dev;
+	struct device *dev = &kmb_vpu_ipc_dev->pdev->dev;
 
-	rc = vpu_ipc_handle_event(vpu_ipc_dev, KEEMBAY_VPU_EVENT_STOP);
+	rc = vpu_ipc_handle_event(kmb_vpu_ipc_dev, KEEMBAY_VPU_EVENT_STOP);
 	if (rc < 0) {
 		dev_err(dev, "Can't stop in this state.\n");
 		return rc;
@@ -1298,13 +1350,13 @@ int intel_keembay_vpu_stop(void)
 	dev_info(dev, "Keem Bay VPU IPC stop.\n");
 
 	/* Request stop */
-	rc = request_vpu_stop(vpu_ipc_dev);
+	rc = request_vpu_stop(kmb_vpu_ipc_dev);
 	if (rc < 0) {
 		dev_err(dev,
 			"Failed to do request to stop - resetting state to OFF anyway.\n");
 	}
 
-	event_rc = vpu_ipc_handle_event(vpu_ipc_dev,
+	event_rc = vpu_ipc_handle_event(kmb_vpu_ipc_dev,
 					KEEMBAY_VPU_EVENT_STOP_COMPLETE);
 	if (event_rc < 0) {
 		dev_err(dev,
@@ -1325,7 +1377,7 @@ EXPORT_SYMBOL(intel_keembay_vpu_stop);
  */
 enum intel_keembay_vpu_state intel_keembay_vpu_status(void)
 {
-	return vpu_ipc_dev->state;
+	return kmb_vpu_ipc_dev->state;
 }
 EXPORT_SYMBOL(intel_keembay_vpu_status);
 
@@ -1342,10 +1394,10 @@ int intel_keembay_vpu_get_wdt_count(enum intel_keembay_wdt_cpu_id id)
 
 	switch (id) {
 	case KEEMBAY_VPU_NCE:
-		rc = vpu_ipc_dev->nce_wdt_count;
+		rc = kmb_vpu_ipc_dev->nce_wdt_count;
 		break;
 	case KEEMBAY_VPU_MSS:
-		rc = vpu_ipc_dev->mss_wdt_count;
+		rc = kmb_vpu_ipc_dev->mss_wdt_count;
 		break;
 	default:
 		break;
@@ -1375,13 +1427,13 @@ int intel_keembay_vpu_wait_for_ready(u32 timeout)
 	 * state without some other transitions, so return
 	 * error immediately for caller to handle.
 	 */
-	if (vpu_ipc_dev->state == KEEMBAY_VPU_ERROR)
+	if (kmb_vpu_ipc_dev->state == KEEMBAY_VPU_ERROR)
 		return -EIO;
 
-	rc = wait_event_interruptible_timeout(vpu_ipc_dev->ready_queue,
-					      vpu_ipc_dev->state ==
-						      KEEMBAY_VPU_READY,
-					      msecs_to_jiffies(timeout));
+	rc = wait_event_interruptible_timeout(
+			kmb_vpu_ipc_dev->ready_queue,
+			kmb_vpu_ipc_dev->state == KEEMBAY_VPU_READY,
+			msecs_to_jiffies(timeout));
 
 	/* Condition was false after timeout elapsed */
 	if (!rc)
@@ -1422,6 +1474,10 @@ static int keembay_vpu_ipc_probe(struct platform_device *pdev)
 		return rc;
 	}
 
+	rc = ipc_device_get(vpu_dev);
+	if (rc)
+		return rc;
+
 	/* Retrieve memory regions, allocate memory */
 	rc = setup_reserved_memory(vpu_dev);
 	if (rc) {
@@ -1449,7 +1505,7 @@ static int keembay_vpu_ipc_probe(struct platform_device *pdev)
 	platform_set_drvdata(pdev, vpu_dev);
 
 	/* Set our local global reference. */
-	vpu_ipc_dev = vpu_dev;
+	kmb_vpu_ipc_dev = vpu_dev;
 
 	return 0;
 
@@ -1464,13 +1520,15 @@ static int keembay_vpu_ipc_remove(struct platform_device *pdev)
 	struct vpu_ipc_dev *vpu_dev = platform_get_drvdata(pdev);
 	struct device *dev = &pdev->dev;
 
-	if (vpu_ipc_dev->ready_message_task) {
+	if (vpu_dev->ready_message_task) {
 		kthread_stop(vpu_dev->ready_message_task);
 		vpu_dev->ready_message_task = NULL;
 	}
 
 	of_reserved_mem_device_release(dev);
 
+	ipc_device_put(vpu_dev);
+
 	dev_info(dev, "Keem Bay VPU IPC driver removed.\n");
 
 	return 0;
diff --git a/drivers/misc/keembay-ipc/keembay-ipc-test.c b/drivers/misc/keembay-ipc/keembay-ipc-test.c
index a47da21f1c60..ed6b099ccce6 100644
--- a/drivers/misc/keembay-ipc/keembay-ipc-test.c
+++ b/drivers/misc/keembay-ipc/keembay-ipc-test.c
@@ -7,11 +7,13 @@
 
 #include <linux/debugfs.h>
 #include <linux/delay.h>
+#include <linux/device.h>
 #include <linux/init.h>
 #include <linux/keembay-ipc.h>
 #include <linux/kernel.h>
 #include <linux/kthread.h>
 #include <linux/module.h>
+#include <linux/platform_device.h>
 #include <linux/slab.h>
 #include <linux/string.h>
 
@@ -46,6 +48,10 @@ static ssize_t test_loop_wr(struct file *filp, const char __user *buf,
 			       size_t count, loff_t *fpos);
 static ssize_t test_long_send_wr(struct file *filp, const char __user *buf,
 				 size_t count, loff_t *fpos);
+
+/* The Keem Bay IPC device under test. */
+static struct device *kmb_ipc_dev;
+
 /*
  * The dentry of the base debugfs directory for thie module
  * /<dbgfs>/kmb_ipc_test
@@ -115,40 +121,42 @@ static int test_loop_thread_fn(void *data)
 	get_task_comm(name, current);
 	pr_info("%s: started\n", name);
 
-	rc = intel_keembay_ipc_open_channel(KMB_IPC_NODE_LEON_MSS, chan_id);
+	rc = intel_keembay_ipc_open_channel(kmb_ipc_dev, KMB_IPC_NODE_LEON_MSS,
+					    chan_id);
 	if (rc) {
 		pr_info("Failed to open channel: %d\n", rc);
 		goto err;
 	}
 
 	while (!kthread_should_stop()) {
-		rc = intel_keembay_ipc_recv(KMB_IPC_NODE_LEON_MSS, chan_id,
-					    &paddr1, &size1, U32_MAX);
+		rc = intel_keembay_ipc_recv(kmb_ipc_dev, KMB_IPC_NODE_LEON_MSS,
+					    chan_id, &paddr1, &size1, U32_MAX);
 		if (rc) {
 			pr_info("Failed 1st recv(): %d\n", rc);
 			goto err;
 		}
-		rc = intel_keembay_ipc_recv(KMB_IPC_NODE_LEON_MSS, chan_id,
-					    &paddr2, &size2, U32_MAX);
+		rc = intel_keembay_ipc_recv(kmb_ipc_dev, KMB_IPC_NODE_LEON_MSS,
+					    chan_id, &paddr2, &size2, U32_MAX);
 		if (rc) {
 			pr_info("Failed 2nd recv(): %d\n", rc);
 			goto err;
 		}
-		rc = intel_keembay_ipc_send(KMB_IPC_NODE_LEON_MSS, chan_id,
-					    paddr1, size1);
+		rc = intel_keembay_ipc_send(kmb_ipc_dev, KMB_IPC_NODE_LEON_MSS,
+					    chan_id, paddr1, size1);
 		if (rc) {
 			pr_info("Failed 1st send(): %d\n", rc);
 			goto err;
 		}
-		rc = intel_keembay_ipc_send(KMB_IPC_NODE_LEON_MSS, chan_id,
-					    paddr2, size2);
+		rc = intel_keembay_ipc_send(kmb_ipc_dev, KMB_IPC_NODE_LEON_MSS,
+					    chan_id, paddr2, size2);
 		if (rc) {
 			pr_info("Failed 2nd send(): %d\n", rc);
 			goto err;
 		}
 	}
 
-	rc = intel_keembay_ipc_close_channel(KMB_IPC_NODE_LEON_MSS, chan_id);
+	rc = intel_keembay_ipc_close_channel(kmb_ipc_dev, KMB_IPC_NODE_LEON_MSS,
+					     chan_id);
 	if (rc) {
 		pr_info("Failed to close channel: %d\n", rc);
 		/* Do not jump to error, as we are exiting already. */
@@ -175,15 +183,16 @@ static int test_long_send_thread_fn(void *data)
 	get_task_comm(name, current);
 	pr_info("%s: started\n", name);
 
-	rc = intel_keembay_ipc_open_channel(KMB_IPC_NODE_LEON_MSS, chan_id);
+	rc = intel_keembay_ipc_open_channel(kmb_ipc_dev, KMB_IPC_NODE_LEON_MSS,
+					    chan_id);
 	if (rc) {
 		pr_info("Failed to open channel: %d\n", rc);
 		goto err_open;
 	}
 
 	while (!kthread_should_stop() && send_cnt < send_limit) {
-		rc = intel_keembay_ipc_send(KMB_IPC_NODE_LEON_MSS, chan_id,
-					    0xDEADBEEF, 42);
+		rc = intel_keembay_ipc_send(kmb_ipc_dev, KMB_IPC_NODE_LEON_MSS,
+					    chan_id, 0xDEADBEEF, 42);
 		/* If FIFO full sleep and retry. */
 		if (rc == -EBUSY) {
 			usleep_range(1000, 2000);
@@ -198,7 +207,8 @@ static int test_long_send_thread_fn(void *data)
 			pr_info("send_cnt: %u\n", send_cnt);
 	}
 
-	rc = intel_keembay_ipc_close_channel(KMB_IPC_NODE_LEON_MSS, chan_id);
+	rc = intel_keembay_ipc_close_channel(kmb_ipc_dev, KMB_IPC_NODE_LEON_MSS,
+					     chan_id);
 	if (rc) {
 		pr_info("Failed to close channel: %d\n", rc);
 		/* Do not jump to error, as we are exiting already. */
@@ -245,8 +255,8 @@ static ssize_t recv_wr(struct file *filp, const char __user *buf,
 	if (rc)
 		return rc;
 
-	rc = intel_keembay_ipc_recv(KMB_IPC_NODE_LEON_MSS, chan_id,
-					    &paddr, &size, RECV_TIMEOUT);
+	rc = intel_keembay_ipc_recv(kmb_ipc_dev, KMB_IPC_NODE_LEON_MSS, chan_id,
+				    &paddr, &size, RECV_TIMEOUT);
 	if (rc)
 		pr_info("recv(chan_id=%lu) failed: %d\n", chan_id, rc);
 	else
@@ -273,7 +283,7 @@ static ssize_t send_wr(struct file *filp, const char __user *buf,
 	if (rc)
 		return rc;
 
-	rc = intel_keembay_ipc_send(KMB_IPC_NODE_LEON_MSS, chan_id,
+	rc = intel_keembay_ipc_send(kmb_ipc_dev, KMB_IPC_NODE_LEON_MSS, chan_id,
 				    0xDEADBEEF, 48);
 	pr_info("send(chan_id=%lu): %d\n", chan_id, rc);
 
@@ -292,7 +302,8 @@ static ssize_t open_wr(struct file *filp, const char __user *buf,
 	if (rc)
 		return rc;
 
-	rc = intel_keembay_ipc_open_channel(KMB_IPC_NODE_LEON_MSS, chan_id);
+	rc = intel_keembay_ipc_open_channel(kmb_ipc_dev, KMB_IPC_NODE_LEON_MSS,
+					    chan_id);
 	pr_info("open(chan_id=%lu): %d\n", chan_id, rc);
 
 	return count;
@@ -311,7 +322,8 @@ static ssize_t close_wr(struct file *filp, const char __user *buf,
 	if (rc)
 		return rc;
 
-	rc = intel_keembay_ipc_close_channel(KMB_IPC_NODE_LEON_MSS, chan_id);
+	rc = intel_keembay_ipc_close_channel(kmb_ipc_dev, KMB_IPC_NODE_LEON_MSS,
+					     chan_id);
 	pr_info("close(chan_id=%lu): %d\n", chan_id, rc);
 
 	return count;
@@ -319,7 +331,7 @@ static ssize_t close_wr(struct file *filp, const char __user *buf,
 
 /* Write operation for the 'test-loop' file. */
 static ssize_t test_loop_wr(struct file *filp, const char __user *buf,
-			       size_t count, loff_t *fpos)
+			    size_t count, loff_t *fpos)
 {
 	unsigned long chan_id;
 	struct task_struct *test_loop_thread;
@@ -446,6 +458,18 @@ static int create_ipc_test_dbgfs_tree(void)
 	return retv;
 }
 
+static struct device *get_ipc_dev(void)
+{
+	struct device_driver *ipc_drv;
+
+	ipc_drv = driver_find("kmb-ipc-driver", &platform_bus_type);
+	if (!ipc_drv) {
+		pr_err("Cannot find IPC driver\n");
+		return NULL;
+	}
+	return driver_find_next_device(ipc_drv, NULL);
+}
+
 /* Remove the DebugFS tree. */
 static void remove_ipc_test_dbgfs_tree(void)
 {
@@ -459,6 +483,13 @@ static void remove_ipc_test_dbgfs_tree(void)
 static int __init kmb_ipc_test_init(void)
 {
 	pr_info("TEST_MOD: Init\n");
+	kmb_ipc_dev = get_ipc_dev();
+	if (!kmb_ipc_dev) {
+		pr_err("Cannot find the IPC device\n");
+		return -ENODEV;
+	}
+	pr_info("Device under test: %s\n", dev_name(kmb_ipc_dev));
+
 	return create_ipc_test_dbgfs_tree();
 }
 
@@ -466,6 +497,7 @@ static void __exit kmb_ipc_test_exit(void)
 {
 	pr_info("TEST_MOD: Exit\n");
 	remove_ipc_test_dbgfs_tree();
+	put_device(kmb_ipc_dev);
 }
 
 module_init(kmb_ipc_test_init);
diff --git a/drivers/misc/keembay-ipc/keembay-ipc.c b/drivers/misc/keembay-ipc/keembay-ipc.c
index 9ce5c4884e52..d36dd75a8d54 100644
--- a/drivers/misc/keembay-ipc/keembay-ipc.c
+++ b/drivers/misc/keembay-ipc/keembay-ipc.c
@@ -184,9 +184,9 @@ struct keembay_ipc_dev {
  */
 struct rx_data {
 	/* The VPU address of the received data. */
-	uint32_t data_vpu_addr;
+	u32 data_vpu_addr;
 	/* The size of the received data. */
-	uint32_t data_size;
+	u32 data_size;
 	/* List head for creating a list of rx_data elements. */
 	struct list_head list;
 };
@@ -199,7 +199,7 @@ struct rx_data {
  * details.
  */
 struct rx_circ_buf {
-	uint32_t buf[RX_SW_FIFO_LEN];
+	u32 buf[RX_SW_FIFO_LEN];
 	int head;
 	int tail;
 };
@@ -218,14 +218,6 @@ static void rx_tasklet_func(unsigned long);
  */
 static struct rx_circ_buf rx_sw_fifo;
 
-/*
- * Global variable pointing to our KeemBay IPC Device.
- *
- * This is meant to be used only when platform_get_drvdata() cannot be used
- * because we lack a reference to our platform_device.
- */
-static struct keembay_ipc_dev *kmb_ipc_dev;
-
 /*
  * Functions related to reserved-memory sub-devices.
  */
@@ -352,13 +344,13 @@ static int local_fifo_cnt(struct keembay_ipc_dev *ipc_dev)
 	 * Bits 15:8:  IPC FIFO write pointer
 	 * Bits  7:0:  IPC FIFO read pointer
 	 */
-	const uint32_t val = ioread32(ipc_dev->local_fifo_reg + IPC_FIFO_STAT);
+	const u32 val = ioread32(ipc_dev->local_fifo_reg + IPC_FIFO_STAT);
 
 	return (val >> 16) & 0xFF;
 }
 
 /* Extract an entry from the FIFO. */
-static uint32_t local_fifo_get(struct keembay_ipc_dev *ipc_dev)
+static u32 local_fifo_get(struct keembay_ipc_dev *ipc_dev)
 {
 	/*
 	 * TIM_IPC_FIFO_ATM
@@ -399,7 +391,7 @@ static void local_fifo_irq_enable(struct keembay_ipc_dev *ipc_dev)
 }
 
 /* Add an entry to a remote FIFO. */
-static void remote_fifo_put(struct keembay_ipc_dev *ipc_dev, uint32_t entry)
+static void remote_fifo_put(struct keembay_ipc_dev *ipc_dev, u32 entry)
 {
 	/*
 	 * TIM_IPC_FIFO.
@@ -457,9 +449,9 @@ static bool remote_fifo_overflow(struct keembay_ipc_dev *ipc_dev)
 	 *
 	 * Writing 0 to any bit position has not effect.
 	 */
-	const uint32_t offset = (MY_NODE_ID < 32) ? IPC_FIFO_OF_FLAG0
+	const u32 offset = (MY_NODE_ID < 32) ? IPC_FIFO_OF_FLAG0
 						  : IPC_FIFO_OF_FLAG1;
-	const uint32_t mask = 1 << (MY_NODE_ID % 32);
+	const u32 mask = 1 << (MY_NODE_ID % 32);
 	const bool rc = ioread32(ipc_dev->remote_fifo_reg + offset) & mask;
 	/* Clear our overflow bit, if we overflowed. */
 	if (rc)
@@ -707,7 +699,7 @@ static int ipc_hw_init(struct platform_device *pdev,
 	spin_lock_init(&ipc_dev->local_fifo_irq_lock);
 	dev_info(&pdev->dev, "Registering handler for IRQ %d\n", irq);
 	rc = devm_request_irq(&pdev->dev, irq, local_fifo_irq_handler, 0,
-			      "keembay-ipc", ipc_dev);
+			      dev_name(&pdev->dev), ipc_dev);
 	return 0;
 }
 
@@ -776,9 +768,6 @@ static int kmb_ipc_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, ipc_dev);
 
-	/* Set the global reference to our device. */
-	kmb_ipc_dev = ipc_dev;
-
 	return 0;
 }
 
@@ -832,7 +821,7 @@ static int validate_link_chan(struct device *dev, u8 node_id, u16 chan_id)
  *	   is not in the expected memory range.
  */
 static void *ipc_vpu_to_virt(const struct ipc_buf_mem *ipc_mem,
-			    uint32_t vpu_addr)
+			    u32 vpu_addr)
 {
 	if (unlikely(vpu_addr < ipc_mem->dma_handle) ||
 		     vpu_addr >= (ipc_mem->dma_handle + ipc_mem->size))
@@ -850,7 +839,7 @@ static void *ipc_vpu_to_virt(const struct ipc_buf_mem *ipc_mem,
  * Return: 0 on success, negative error code otherwise.
  */
 static int ipc_virt_to_vpu(struct ipc_buf_mem *ipc_mem, void *vaddr,
-			    uint32_t *vpu_addr)
+			    u32 *vpu_addr)
 {
 	if (unlikely((ipc_mem->dma_handle + ipc_mem->size) > 0xFFFFFFFF))
 		return -EINVAL;
@@ -873,7 +862,7 @@ static int ipc_virt_to_vpu(struct ipc_buf_mem *ipc_mem, void *vaddr,
  *   buffer).
  * - Add an RX Data descriptor (data ptr and data size) to the channel RX queue.
  */
-static void process_rx_fifo_entry(uint32_t entry,
+static void process_rx_fifo_entry(u32 entry,
 				  struct keembay_ipc_dev *ipc_dev)
 {
 	struct device *dev = &ipc_dev->plat_dev->dev;
@@ -948,7 +937,7 @@ static void process_rx_fifo_entry(uint32_t entry,
  */
 static void rx_tasklet_func(unsigned long ipc_dev_ptr)
 {
-	uint32_t entry;
+	u32 entry;
 	/*
 	 * Memory barrier: make sure that we get buffer head before any other
 	 * operation on the circular buffer.
@@ -1027,7 +1016,7 @@ static int tx_data_send(struct keembay_ipc_dev *ipc_dev,
 {
 	struct kmb_ipc_buf *ipc_buf = NULL;
 	struct device *dev = &ipc_dev->plat_dev->dev;
-	uint32_t entry;
+	u32 entry;
 	int rc;
 
 	dev_dbg(dev, "%s(chan=%u)\n", __func__, tx_data->chan_id);
@@ -1284,13 +1273,14 @@ static int __ipc_send(struct keembay_ipc_dev *ipc_dev, u8 dst_node,
  *
  * Return:	0 on success, negative error code otherwise.
  */
-int intel_keembay_ipc_open_channel(u8 node_id, u16 chan_id)
+int intel_keembay_ipc_open_channel(struct device *dev, u8 node_id, u16 chan_id)
 {
-	int rc;
-	struct device *dev = &kmb_ipc_dev->plat_dev->dev;
-	struct ipc_link *link = &kmb_ipc_dev->leon_mss_link;
+	/* TODO: ensure dev is not NULL. */
+	struct keembay_ipc_dev *ipc_dev = dev_get_drvdata(dev);
+	struct ipc_link *link = &ipc_dev->leon_mss_link;
 	struct ipc_chan *chan, *cur_chan;
 	unsigned long flags;
+	int rc;
 
 	rc = validate_link_chan(dev, node_id, chan_id);
 	if (rc)
@@ -1328,11 +1318,12 @@ EXPORT_SYMBOL(intel_keembay_ipc_open_channel);
  *
  * Return:	0 on success, negative error code otherwise.
  */
-int intel_keembay_ipc_close_channel(u8 node_id, u16 chan_id)
+int intel_keembay_ipc_close_channel(struct device *dev, u8 node_id, u16 chan_id)
 {
+	/* TODO: ensure dev is not NULL. */
+	struct keembay_ipc_dev *ipc_dev = dev_get_drvdata(dev);
+	struct ipc_link *link = &ipc_dev->leon_mss_link;
 	int rc;
-	struct device *dev = &kmb_ipc_dev->plat_dev->dev;
-	struct ipc_link *link = &kmb_ipc_dev->leon_mss_link;
 
 	rc = validate_link_chan(dev, node_id, chan_id);
 	if (rc)
@@ -1356,11 +1347,12 @@ EXPORT_SYMBOL(intel_keembay_ipc_close_channel);
  *
  * Return:	0 on success, negative error code otherwise.
  */
-int intel_keembay_ipc_send(u8 node_id, u16 chan_id, uint32_t vpu_addr,
-			   size_t size)
+int intel_keembay_ipc_send(struct device *dev, u8 node_id, u16 chan_id,
+			   u32 vpu_addr, size_t size)
 {
-	struct ipc_link *link = &kmb_ipc_dev->leon_mss_link;
-	struct device *dev = &kmb_ipc_dev->plat_dev->dev;
+	/* TODO: ensure dev is not NULL. */
+	struct keembay_ipc_dev *ipc_dev = dev_get_drvdata(dev);
+	struct ipc_link *link = &ipc_dev->leon_mss_link;
 	struct ipc_chan *chan;
 	int idx, rc;
 
@@ -1381,7 +1373,7 @@ int intel_keembay_ipc_send(u8 node_id, u16 chan_id, uint32_t vpu_addr,
 		goto exit;
 	}
 
-	rc = __ipc_send(kmb_ipc_dev, node_id, chan_id, vpu_addr, size);
+	rc = __ipc_send(ipc_dev, node_id, chan_id, vpu_addr, size);
 exit:
 	/* End sleepable RCU critical section. */
 	srcu_read_unlock(&link->srcu_sp[chan_id], idx);
@@ -1402,11 +1394,12 @@ EXPORT_SYMBOL(intel_keembay_ipc_send);
  *
  * Return:	0 on success, negative error code otherwise
  */
-int intel_keembay_ipc_recv(u8 node_id, u16 chan_id, uint32_t *vpu_addr,
-			   size_t *size, u32 timeout)
+int intel_keembay_ipc_recv(struct device *dev, u8 node_id, u16 chan_id,
+			   u32 *vpu_addr, size_t *size, u32 timeout)
 {
-	struct ipc_link *link = &kmb_ipc_dev->leon_mss_link;
-	struct device *dev = &kmb_ipc_dev->plat_dev->dev;
+	/* TODO: ensure dev is not NULL. */
+	struct keembay_ipc_dev *ipc_dev = dev_get_drvdata(dev);
+	struct ipc_link *link = &ipc_dev->leon_mss_link;
 	struct ipc_chan *chan;
 	struct rx_data *rx_entry;
 	unsigned long flags;
diff --git a/include/linux/keembay-ipc.h b/include/linux/keembay-ipc.h
index 5feed1efeb6d..34c0b7b04dea 100644
--- a/include/linux/keembay-ipc.h
+++ b/include/linux/keembay-ipc.h
@@ -25,11 +25,15 @@ enum {
 	KMB_IPC_NODE_LEON_MSS,
 };
 
-int intel_keembay_ipc_open_channel(u8 node_id, u16 chan_id);
-int intel_keembay_ipc_close_channel(u8 node_id, u16 chan_id);
-int intel_keembay_ipc_send(u8 node_id, u16 chan_id, uint32_t paddr,
-			   size_t size);
-int intel_keembay_ipc_recv(u8 node_id, u16 chan_id, uint32_t *paddr,
-			   size_t *size, u32 timeout);
+int intel_keembay_ipc_open_channel(struct device *dev, u8 node_id, u16 chan_id);
+
+int intel_keembay_ipc_close_channel(struct device *dev, u8 node_id,
+				    u16 chan_id);
+
+int intel_keembay_ipc_send(struct device *dev, u8 node_id, u16 chan_id,
+			   u32 vpu_addr, size_t size);
+
+int intel_keembay_ipc_recv(struct device *dev, u8 node_id, u16 chan_id,
+			   u32 *vpu_addr, size_t *size, u32 timeout);
 
 #endif /* __KEEMBAY_IPC_H */
-- 
2.27.0

