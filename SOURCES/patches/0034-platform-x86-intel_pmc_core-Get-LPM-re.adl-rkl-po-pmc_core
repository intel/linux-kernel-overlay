From 821df72571a1ff3e53ebb40bcb48b4cfc54d30b4 Mon Sep 17 00:00:00 2001
From: Gayatri Kammela <gayatri.kammela@intel.com>
Date: Sun, 21 Feb 2021 18:11:19 -0800
Subject: [PATCH 34/47] platform/x86: intel_pmc_core: Get LPM requirements for
 Tiger Lake

Platforms that support low power modes such as Tiger Lake has requirement
registers per each sub-state. However, unlike low power mode status and
live status registers, requirement registers are not memory mapped and
hence cannot be read directly. The method used to read the requirement
registers vary from platform to platform and just for Tiger Lake it can be
read via ACPI DSM method.

Hence, add a acpi_evaluate_dsm() to access the contents of requirement
registers and save them in a buffer for easy access to the contents.

Cc: Mark Gross <mark.gross@intel.com>
Cc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Cc: Srinivas Pandruvada <srinivas.pandruvada@intel.com>
Co-developed-by: David E. Box <david.e.box@linux.intel.com>
Signed-off-by: David E. Box <david.e.box@linux.intel.com>
Signed-off-by: Gayatri Kammela <gayatri.kammela@intel.com>
---
 drivers/platform/x86/intel_pmc_core.c | 50 +++++++++++++++++++++++++++
 drivers/platform/x86/intel_pmc_core.h |  2 ++
 2 files changed, 52 insertions(+)

diff --git a/drivers/platform/x86/intel_pmc_core.c b/drivers/platform/x86/intel_pmc_core.c
index d2e3f60c2f42..1a70bb4505fc 100644
--- a/drivers/platform/x86/intel_pmc_core.c
+++ b/drivers/platform/x86/intel_pmc_core.c
@@ -23,7 +23,9 @@
 #include <linux/slab.h>
 #include <linux/suspend.h>
 #include <linux/uaccess.h>
+#include <linux/uuid.h>
 
+#include <acpi/acpi_bus.h>
 #include <asm/cpu_device_id.h>
 #include <asm/intel-family.h>
 #include <asm/msr.h>
@@ -31,6 +33,9 @@
 
 #include "intel_pmc_core.h"
 
+#define ACPI_S0IX_DSM_UUID		"57a6512e-3979-4e9d-9708-ff13b2508972"
+#define ACPI_GET_LOW_MODE_REGISTERS	1
+
 /* PKGC MSRs are common across Intel Core SoCs */
 static const struct pmc_bit_map msr_map[] = {
 	{"Package C2",                  MSR_PKG_C2_RESIDENCY},
@@ -588,6 +593,47 @@ static const struct pmc_reg_map tgl_reg_map = {
 	.lpm_live_status_offset = TGL_LPM_LIVE_STATUS_OFFSET,
 };
 
+static void pmc_core_get_tgl_lpm_reqs(struct platform_device *pdev)
+{
+	struct pmc_dev *pmcdev = platform_get_drvdata(pdev);
+	const int num_modes = pmcdev->map->lpm_num_modes;
+	const int num_maps = pmcdev->map->lpm_num_maps;
+	size_t lpm_size = num_modes * num_maps * 4;
+	union acpi_object *out_obj;
+	struct acpi_device *adev;
+	guid_t s0ix_dsm_guid;
+	u32 *lpm_req_regs;
+
+	adev = ACPI_COMPANION(&pdev->dev);
+	if (!adev)
+		return;
+
+	lpm_req_regs = devm_kzalloc(&pdev->dev, lpm_size * sizeof(u32),
+				     GFP_KERNEL);
+	if (!lpm_req_regs)
+		return;
+
+	guid_parse(ACPI_S0IX_DSM_UUID, &s0ix_dsm_guid);
+
+	out_obj = acpi_evaluate_dsm(adev->handle, &s0ix_dsm_guid, 0,
+				    ACPI_GET_LOW_MODE_REGISTERS, NULL);
+	if (out_obj && out_obj->type == ACPI_TYPE_BUFFER) {
+		u32 *addr = (u32 *)out_obj->buffer.pointer;
+		int size = out_obj->buffer.length;
+
+		if (size != lpm_size)
+			return;
+
+		memcpy_fromio(lpm_req_regs, addr, lpm_size);
+	} else
+		acpi_handle_debug(adev->handle,
+				  "_DSM function 0 evaluation failed\n");
+
+	ACPI_FREE(out_obj);
+
+	pmcdev->lpm_req_regs = lpm_req_regs;
+}
+
 static inline u32 pmc_core_reg_read(struct pmc_dev *pmcdev, int reg_offset)
 {
 	return readl(pmcdev->regbase + reg_offset);
@@ -1312,6 +1358,10 @@ static int pmc_core_probe(struct platform_device *pdev)
 		return -ENOMEM;
 
 	mutex_init(&pmcdev->lock);
+
+	if (pmcdev->map == &tgl_reg_map)
+		pmc_core_get_tgl_lpm_reqs(pdev);
+
 	pmcdev->pmc_xram_read_bit = pmc_core_check_read_lock_bit(pmcdev);
 	pmc_core_get_substates(pmcdev);
 	pmc_core_get_lpm_priority(pmcdev);
diff --git a/drivers/platform/x86/intel_pmc_core.h b/drivers/platform/x86/intel_pmc_core.h
index aa4600dbc3dc..7251b5b0da10 100644
--- a/drivers/platform/x86/intel_pmc_core.h
+++ b/drivers/platform/x86/intel_pmc_core.h
@@ -290,6 +290,7 @@ struct pmc_reg_map {
  * @s0ix_counter:	S0ix residency (step adjusted)
  * @lpm_en:		Bitmap of enabled low power modes
  * @lpm_mode_priority:  Array returning the mode for the given priority/index
+ * @lpm_req_regs:	List of substate requirements
  *
  * pmc_dev contains info about power management controller device.
  */
@@ -306,6 +307,7 @@ struct pmc_dev {
 	u64 s0ix_counter;
 	u32 lpm_en;
 	u8 lpm_mode_priority[LPM_MAX_NUM_MODES];
+	u32 *lpm_req_regs;
 };
 
 #endif /* PMC_CORE_H */
-- 
2.27.0

