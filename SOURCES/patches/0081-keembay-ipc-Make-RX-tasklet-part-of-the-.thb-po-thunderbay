From c8f3d2902cb386b3ef76819723d76ab6057bace2 Mon Sep 17 00:00:00 2001
From: Daniele Alessandrelli <daniele.alessandrelli@intel.com>
Date: Mon, 25 Nov 2019 13:11:04 +0000
Subject: [PATCH 081/223] keembay-ipc: Make RX tasklet part of the
 keembay_ipc_dev struct

The RX tasklet is currently statically defined as a global variable.
This patch makes it a field for the keembay_ipc_dev struct, so that, in
case of multiple IPC devices, each one will have its own tasklet.

Signed-off-by: Daniele Alessandrelli <daniele.alessandrelli@intel.com>
---
 drivers/misc/keembay-ipc/keembay-ipc.c | 26 ++++++++++++++------------
 1 file changed, 14 insertions(+), 12 deletions(-)

diff --git a/drivers/misc/keembay-ipc/keembay-ipc.c b/drivers/misc/keembay-ipc/keembay-ipc.c
index 556197b82bbe..9ce5c4884e52 100644
--- a/drivers/misc/keembay-ipc/keembay-ipc.c
+++ b/drivers/misc/keembay-ipc/keembay-ipc.c
@@ -173,6 +173,7 @@ struct keembay_ipc_dev {
 	spinlock_t local_fifo_irq_lock;
 	void __iomem *local_fifo_reg;
 	void __iomem *remote_fifo_reg;
+	struct tasklet_struct rx_tasklet;
 };
 
 /*
@@ -207,9 +208,8 @@ struct rx_circ_buf {
 static int tx_thread_fn(void *data);
 /* Forward declaration of ISR function. */
 static irqreturn_t local_fifo_irq_handler(int irq, void *dev_id);
-/* The RX tasklet. */
+/* Forward declaration of RX tasklet function. */
 static void rx_tasklet_func(unsigned long);
-static DECLARE_TASKLET(rx_tasklet, rx_tasklet_func, 0);
 
 /*
  * The RX SW FIFO.
@@ -703,6 +703,7 @@ static int ipc_hw_init(struct platform_device *pdev,
 	}
 	ipc_dev->local_fifo_irq = irq;
 	ipc_dev->local_fifo_irq_enabled = true;
+	tasklet_init(&ipc_dev->rx_tasklet, rx_tasklet_func, (uintptr_t)ipc_dev);
 	spin_lock_init(&ipc_dev->local_fifo_irq_lock);
 	dev_info(&pdev->dev, "Registering handler for IRQ %d\n", irq);
 	rc = devm_request_irq(&pdev->dev, irq, local_fifo_irq_handler, 0,
@@ -716,10 +717,10 @@ static int ipc_hw_init(struct platform_device *pdev,
 static void ipc_hw_deinit(struct keembay_ipc_dev *ipc_dev)
 {
 	/*
-	 * Just disable the tasklet as iomem and irq have been requested with
+	 * Just kill the tasklet as iomem and irq have been requested with
 	 * devm_* functions and, therefore, are freed automatically.
 	 */
-	tasklet_disable(&rx_tasklet);
+	tasklet_kill(&ipc_dev->rx_tasklet);
 }
 
 /* Driver probing. */
@@ -945,7 +946,7 @@ static void process_rx_fifo_entry(uint32_t entry,
  *
  * Go through the RX SW FIFO (filled by the RX ISR) and process every entry.
  */
-static void rx_tasklet_func(unsigned long unused)
+static void rx_tasklet_func(unsigned long ipc_dev_ptr)
 {
 	uint32_t entry;
 	/*
@@ -955,19 +956,20 @@ static void rx_tasklet_func(unsigned long unused)
 	const unsigned int head = smp_load_acquire(&rx_sw_fifo.head);
 	unsigned long tail = rx_sw_fifo.tail;
 	const size_t size = ARRAY_SIZE(rx_sw_fifo.buf);
+	struct keembay_ipc_dev *ipc_dev = (struct keembay_ipc_dev *)ipc_dev_ptr;
 
 	while (CIRC_CNT(head, tail, size)) {
 		/* Extract one item from the buffer. */
 		entry = rx_sw_fifo.buf[tail];
 		/* Consume the item. */
-		process_rx_fifo_entry(entry, kmb_ipc_dev);
+		process_rx_fifo_entry(entry, ipc_dev);
 		/* Update tail index (wrapping it if needed) */
 		tail = (tail + 1) & (size - 1);
 	}
 	/* Memory barrier ensuring tail is updated only at the end. */
 	smp_store_release(&rx_sw_fifo.tail, tail);
 	/* Enable Local FIFO interrupt. */
-	local_fifo_irq_enable(kmb_ipc_dev);
+	local_fifo_irq_enable(ipc_dev);
 }
 
 
@@ -1011,7 +1013,7 @@ static irqreturn_t local_fifo_irq_handler(int irq, void *ptr)
 	 * operation done on the circular buffer.
 	 */
 	smp_store_release(&rx_sw_fifo.head, head);
-	tasklet_schedule(&rx_tasklet);
+	tasklet_schedule(&ipc_dev->rx_tasklet);
 	return IRQ_HANDLED;
 }
 
@@ -1030,7 +1032,7 @@ static int tx_data_send(struct keembay_ipc_dev *ipc_dev,
 
 	dev_dbg(dev, "%s(chan=%u)\n", __func__, tx_data->chan_id);
 	/* Allocate and set IPC buffer. */
-	ipc_buf = ipc_buf_tx_alloc(&kmb_ipc_dev->ipc_buf_pool);
+	ipc_buf = ipc_buf_tx_alloc(&ipc_dev->ipc_buf_pool);
 	if (unlikely(!ipc_buf)) {
 		rc = -ENOMEM;
 		goto exit;
@@ -1046,7 +1048,7 @@ static int tx_data_send(struct keembay_ipc_dev *ipc_dev,
 	wmb();
 
 	/* Initialize entry to ipc_buf VPU address. */
-	rc = ipc_virt_to_vpu(&kmb_ipc_dev->local_ipc_mem, ipc_buf, &entry);
+	rc = ipc_virt_to_vpu(&ipc_dev->local_ipc_mem, ipc_buf, &entry);
 
 	/*
 	 * Check validity of IPC buffer VPU address (this error should never
@@ -1070,8 +1072,8 @@ static int tx_data_send(struct keembay_ipc_dev *ipc_dev,
 	dev_dbg(dev, "TX IPC FIFO entry: %x\n", entry);
 
 	/* Send entry and check for overflow. */
-	remote_fifo_put(kmb_ipc_dev, entry);
-	if (remote_fifo_overflow(kmb_ipc_dev)) {
+	remote_fifo_put(ipc_dev, entry);
+	if (remote_fifo_overflow(ipc_dev)) {
 		rc = -EBUSY;
 		goto exit;
 	}
-- 
2.27.0

