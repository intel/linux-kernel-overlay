From b6f6814f4a119ee41e578c2abf64ab1ec7e894cd Mon Sep 17 00:00:00 2001
From: Alexander Shishkin <alexander.shishkin@linux.intel.com>
Date: Thu, 2 May 2019 22:33:31 +0300
Subject: [PATCH 09/23] intel_th: msu: Add a sysfs attribute showing possible
 modes

With the addition of dynamically loadable buffer drivers, there needs
to be a way of knowing the currently available ones without having to
scan the list of loaded modules or trial and error.

Add a sysfs file that lists all the currently available "modes", listing
both the MSC hardware operating modes and loaded buffer drivers.

Signed-off-by: Alexander Shishkin <alexander.shishkin@linux.intel.com>
---
 .../testing/sysfs-bus-intel_th-devices-msc    |  8 +++++++
 drivers/hwtracing/intel_th/msu.c              | 24 +++++++++++++++++++
 2 files changed, 32 insertions(+)

diff --git a/Documentation/ABI/testing/sysfs-bus-intel_th-devices-msc b/Documentation/ABI/testing/sysfs-bus-intel_th-devices-msc
index a74252e580a5..d28fbcceeece 100644
--- a/Documentation/ABI/testing/sysfs-bus-intel_th-devices-msc
+++ b/Documentation/ABI/testing/sysfs-bus-intel_th-devices-msc
@@ -52,3 +52,11 @@ Description:	(RW) Configure whether trace stops when the last available window
 		becomes full (1/y/Y) or wraps around and continues until the next
 		window becomes available again (0/n/N).
 
+What:		/sys/bus/intel_th/devices/<intel_th_id>-msc<msc-id>/modes
+Date:		May 2019
+KernelVersion:	5.2
+Contact:	Alexander Shishkin <alexander.shishkin@linux.intel.com>
+Description:	(RO) Lists all possible modes, that is, values that can be
+		written to the "mode" file described above. This includes
+		the hardware operating modes ("single", "multi", etc) and
+		all the buffer drivers that are currently loaded.
diff --git a/drivers/hwtracing/intel_th/msu.c b/drivers/hwtracing/intel_th/msu.c
index 794630c09587..f614e5400fd6 100644
--- a/drivers/hwtracing/intel_th/msu.c
+++ b/drivers/hwtracing/intel_th/msu.c
@@ -1939,6 +1939,29 @@ mode_store(struct device *dev, struct device_attribute *attr, const char *buf,
 
 static DEVICE_ATTR_RW(mode);
 
+static ssize_t
+modes_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct msu_buffer_entry *mbe;
+	ssize_t ret = 0;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(msc_mode); i++)
+		ret += scnprintf(buf + ret, PAGE_SIZE - ret, "%s\n",
+				 msc_mode[i]);
+
+	mutex_lock(&msu_buffer_mutex);
+	list_for_each_entry(mbe, &msu_buffer_list, entry) {
+		ret += scnprintf(buf + ret, PAGE_SIZE - ret, "%s\n",
+				 mbe->mbuf->name);
+	}
+	mutex_unlock(&msu_buffer_mutex);
+
+	return ret;
+}
+
+static DEVICE_ATTR_RO(modes);
+
 static ssize_t
 nr_pages_show(struct device *dev, struct device_attribute *attr, char *buf)
 {
@@ -2095,6 +2118,7 @@ static DEVICE_ATTR_RW(stop_on_full);
 static struct attribute *msc_output_attrs[] = {
 	&dev_attr_wrap.attr,
 	&dev_attr_mode.attr,
+	&dev_attr_modes.attr,
 	&dev_attr_nr_pages.attr,
 	&dev_attr_win_switch.attr,
 	&dev_attr_stop_on_full.attr,
-- 
2.27.0

