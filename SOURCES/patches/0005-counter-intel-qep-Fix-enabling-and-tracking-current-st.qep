From 2721b7d5efeaf782d813f1be1fc817141f3312c5 Mon Sep 17 00:00:00 2001
From: "Tan, Raymond" <raymond.tan@intel.com>
Date: Tue, 19 Nov 2019 07:35:02 +0800
Subject: [PATCH 05/61] counter: intel-qep: Fix enabling and tracking current
 state of QEP with RPM

This patch utilizes the internal enabled status variable to track
the state of the QEP IP with runtime-pm enabled. Simply reading QEPCON
register when the IP is in D3 state will only return 0xFFFFFFFF
that will display wrong values to the user through sysfs.

The respective pm_runtime_* calls will only happened when there is
state change, e.g. disabled->enabled or vice versa.

Signed-off-by: Tan, Raymond <raymond.tan@intel.com>
---
 drivers/counter/intel-qep.c | 22 ++++++++++++++--------
 1 file changed, 14 insertions(+), 8 deletions(-)

diff --git a/drivers/counter/intel-qep.c b/drivers/counter/intel-qep.c
index b1fd9b7244dd..5c5435de1d27 100644
--- a/drivers/counter/intel-qep.c
+++ b/drivers/counter/intel-qep.c
@@ -130,6 +130,7 @@ static void intel_qep_init(struct intel_qep *qep, bool reset)
 	reg = intel_qep_readl(qep->regs, INTEL_QEPCON);
 	reg &= ~INTEL_QEPCON_EN;
 	intel_qep_writel(qep->regs, INTEL_QEPCON, reg);
+	qep->enabled = false;
 
 	/* make sure peripheral is disabled by reading one more time */
 	reg = intel_qep_readl(qep->regs, INTEL_QEPCON);
@@ -391,11 +392,8 @@ static ssize_t enable_read(struct counter_device *counter,
 		struct counter_count *count, void *priv, char *buf)
 {
 	struct intel_qep *qep = counter_to_qep(counter);
-	u32 reg;
-
-	reg = intel_qep_readl(qep->regs, INTEL_QEPCON);
 
-	return snprintf(buf, PAGE_SIZE, "%d\n", !!(reg & INTEL_QEPCON_EN));
+	return snprintf(buf, PAGE_SIZE, "%d\n", qep->enabled);
 }
 
 static ssize_t enable_write(struct counter_device *counter,
@@ -411,14 +409,22 @@ static ssize_t enable_write(struct counter_device *counter,
 	if (ret < 0)
 		return ret;
 
-	reg = intel_qep_readl(qep->regs, INTEL_QEPCON);
+	if (val && !qep->enabled) {
+		pm_runtime_get_sync(qep->dev);
 
-	if (val)
+		reg = intel_qep_readl(qep->regs, INTEL_QEPCON);
 		reg |= INTEL_QEPCON_EN;
-	else
+		intel_qep_writel(qep->regs, INTEL_QEPCON, reg);
+		qep->enabled = true;
+	} else if (!val && qep->enabled) {
+		reg = intel_qep_readl(qep->regs, INTEL_QEPCON);
 		reg &= ~INTEL_QEPCON_EN;
+		intel_qep_writel(qep->regs, INTEL_QEPCON, reg);
+		qep->enabled = false;
 
-	intel_qep_writel(qep->regs, INTEL_QEPCON, reg);
+		pm_runtime_mark_last_busy(qep->dev);
+		pm_runtime_put_autosuspend(qep->dev);
+	}
 
 	return len;
 }
-- 
2.27.0

