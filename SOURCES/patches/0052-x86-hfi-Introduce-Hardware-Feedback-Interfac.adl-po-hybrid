From 913d59d6a999c374686d19726c04116a76a29f21 Mon Sep 17 00:00:00 2001
From: Ricardo Neri <ricardo.neri-calderon@linux.intel.com>
Date: Mon, 2 Nov 2020 14:49:36 -0800
Subject: [PATCH 52/68] x86/hfi: Introduce Hardware Feedback Interface classes

On Intel hybrid parts, CPUs have asymmetric performance properties.
However, such asymmetry depends not only on the type of CPU but also
on the type of instructions a task executes. This means that different
types of tasks will have different instructions-per-cycle (IPC) ratios.

The Enhanced Hardware Feedback (EHFI) interface provides classification
of tasks based on the instructions they execute. In other words, hardware
can identify specific types of tasks with higher or lower IPC ratios.

Tasks are classified into several classes. Hardware defines the number
of supported classes.

Class 0 denotes tasks for which hardware did not find a suitable class.
The IPC ratio of class 0 is the average of all classes. Thus, use it
to define CPU capacity.

Signed-off-by: Ricardo Neri <ricardo.neri-calderon@linux.intel.com>
---
 arch/x86/platform/intel/hfi.c | 43 ++++++++++++++++++++++++++++++-----
 1 file changed, 37 insertions(+), 6 deletions(-)

diff --git a/arch/x86/platform/intel/hfi.c b/arch/x86/platform/intel/hfi.c
index dd8950697082..aa0608f6c48b 100644
--- a/arch/x86/platform/intel/hfi.c
+++ b/arch/x86/platform/intel/hfi.c
@@ -39,7 +39,8 @@
 
 /**
  * struct hfi_cpu_data - Capabilities of a logical processor in the HFI table.
- *			 These capabilities are unitless.
+ *			 These capabilities are specific to each HFI class and
+ *			 are unitless.
  * @perf_cap:		Performance capability
  * @ee_cap:		Energy efficiency capability
  */
@@ -50,7 +51,7 @@ struct hfi_cpu_data {
 
 /**
  * struct hfi_hdr - Header of the HFI table. Indicates if hardware updated
- *		    data in the table.
+ *		    data in the table. A header is specific to each HFI class.
  * @perf_updated:	Hardware updated performance capabilities
  * @ee_updated:		Hardware updated energy efficiency capabilities
  */
@@ -66,6 +67,9 @@ struct hfi_hdr {
  * @data:		Base address of the table data
  * @cpu_stride:		Stride size to locate capability data of a logical
  *			processor within the table
+ * @class_stride:	Stride size to locate a class within the capability
+ *			data of a logical processor or the HFI table header
+ * @nr_classes:		Number of classes supported
  */
 struct hfi_params {
 	u64		*ts_counter;
@@ -73,6 +77,8 @@ struct hfi_params {
 	void		*data;
 	unsigned int	cpu_stride;
 	bool		enabled;
+	unsigned int	class_stride;
+	unsigned int	nr_classes;
 };
 
 /* CPU's indexes (i.e., rows) in the HFI table */
@@ -261,6 +267,10 @@ static void scale_energy_efficiency(void)
 	}
 }
 
+/*
+ * Use energy efficiency capabilities of class 0. Please see note at
+ * update_capacity().
+ */
 static void update_energy_efficiency(void)
 {
 	struct hfi_hdr *hdr = hfi_params.hdr;
@@ -356,6 +366,16 @@ static int get_hfi_performance_cap(void)
 
 /*
  * Call update_capacity() when there are changes in the HFI table.
+ *
+ * The Enhanced HFI provides performanca capabilities per class of software
+ * threads (as classified by hardware). Class 0 in the Enhanced HFI provides
+ * the performance capabilities for software threads that hardware did not
+ * classify known software threads.
+ *
+ * Furthermore, the first iteration of the HFI does not support classes of
+ * threads. This matchess class 0 of the Enhanced HFI.
+ *
+ * Use EHFI class 0 to define processors capacities.
  */
 static void update_capacity(void)
 {
@@ -538,8 +558,8 @@ void hfi_setup_cpu(struct cpuinfo_x86 *c)
 }
 
 /*
- * The format of the HFI table depends on the number of capabilities that the
- * hardware supports. Keep a data structure to navigate the table.
+ * The format of the HFI table depends on the number of capabilities and classes
+ * that the hardware supports. Keep a data structure to navigate the table.
  */
 static void __init init_hfi_params(void *table_base, unsigned long capabilities)
 {
@@ -558,12 +578,19 @@ static void __init init_hfi_params(void *table_base, unsigned long capabilities)
 	/* The HFI header is below the time-stamp. */
 	hfi_params.hdr = table_base + sizeof(*hfi_params.ts_counter);
 
+	/*
+	 * Capability fields of an HFI class are grouped together. Classes are
+	 * continuous.  Hence, use the number of supported features to locate
+	 * a specific class.
+	 */
+	hfi_params.class_stride = nr_capabilities;
+
 	/*
 	 * The header contains change indications for each supported feature.
 	 * The size of the table header is rounded up to be a multiple of 8
 	 * bytes.
 	 */
-	size = DIV_ROUND_UP(nr_capabilities, 8) * 8;
+	size = DIV_ROUND_UP(nr_capabilities * hfi_params.nr_classes, 8) * 8;
 
 	/* The HFI data starts below the header. */
 	hfi_params.data = hfi_params.hdr + size;
@@ -572,7 +599,8 @@ static void __init init_hfi_params(void *table_base, unsigned long capabilities)
 	 * Data of each logical processor is also rounded up to be a multiple
 	 * of 8 bytes.
 	 */
-	hfi_params.cpu_stride = DIV_ROUND_UP(nr_capabilities, 8) * 8;
+	hfi_params.cpu_stride = DIV_ROUND_UP(nr_capabilities *
+					     hfi_params.nr_classes, 8) * 8;
 }
 
 static void __init intel_hfi_init(void)
@@ -602,6 +630,9 @@ static void __init intel_hfi_init(void)
 		return;
 	}
 
+	/* For now, use only one class of the HFI table */
+	hfi_params.nr_classes = 1;
+
 	raw_data = kcalloc(num_possible_cpus(), sizeof(*raw_data), GFP_KERNEL);
 	if (!raw_data) {
 		pr_err("No memory for raw data\n");
-- 
2.27.0

