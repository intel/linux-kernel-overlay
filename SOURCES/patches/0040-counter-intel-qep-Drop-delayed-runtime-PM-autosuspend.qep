From 2be942d825eab90c41d44c5e853280164a577762 Mon Sep 17 00:00:00 2001
From: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date: Fri, 12 Feb 2021 13:35:11 +0200
Subject: [PATCH 40/69] counter: intel-qep: Drop delayed runtime PM autosuspend

It is unlikely this device is continuously enabled and disabled in short
bursts and where delayed runtime PM autosuspend is needed for reducing
the resume latency in those cases.

Instead let the device suspend immediately when usage ends. This
simplifies the code a bit and makes usage consistent since now
autosuspending is not consistent across functions.

Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
---
 drivers/counter/intel-qep.c | 9 +++------
 1 file changed, 3 insertions(+), 6 deletions(-)

diff --git a/drivers/counter/intel-qep.c b/drivers/counter/intel-qep.c
index cea102ac8110..8eb2e8ddc886 100644
--- a/drivers/counter/intel-qep.c
+++ b/drivers/counter/intel-qep.c
@@ -425,8 +425,7 @@ static ssize_t enable_write(struct counter_device *counter,
 		qep->enabled = false;
 		mutex_unlock(&qep->lock);
 
-		pm_runtime_mark_last_busy(qep->dev);
-		pm_runtime_put_autosuspend(qep->dev);
+		pm_runtime_put(qep->dev);
 	}
 
 	return len;
@@ -721,9 +720,7 @@ static int intel_qep_probe(struct pci_dev *pci, const struct pci_device_id *id)
 	if (ret)
 		goto err_irq;
 
-	pm_runtime_set_autosuspend_delay(dev, 1000);
-	pm_runtime_use_autosuspend(dev);
-	pm_runtime_put_noidle(dev);
+	pm_runtime_put(dev);
 	pm_runtime_allow(dev);
 
 	return devm_counter_register(&pci->dev, &qep->counter);
@@ -740,7 +737,7 @@ static void intel_qep_remove(struct pci_dev *pci)
 	struct device *dev = &pci->dev;
 
 	pm_runtime_forbid(dev);
-	pm_runtime_get_noresume(dev);
+	pm_runtime_get(dev);
 
 	intel_qep_writel(qep, INTEL_QEPCON, 0);
 	devm_free_irq(&pci->dev, pci_irq_vector(pci, 0), qep);
-- 
2.27.0

