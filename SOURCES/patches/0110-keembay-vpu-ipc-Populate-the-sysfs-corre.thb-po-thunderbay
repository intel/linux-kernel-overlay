From 7fa65a3ed228b354c893a6b45465190575e68de1 Mon Sep 17 00:00:00 2001
From: Paul Murphy <paul.j.murphy@intel.com>
Date: Tue, 12 May 2020 20:05:27 +0100
Subject: [PATCH 110/223] keembay-vpu-ipc: Populate the sysfs correctly

Adding more information to sysfs.
Will update ABI separately.
Getting the real information from the device tree and assigning into the
driver local variable.
Pushing the required information to the VPU.

Signed-off-by: Paul Murphy <paul.j.murphy@intel.com>
---
 drivers/firmware/keembay-vpu-ipc.c | 179 ++++++++++++++++++++++++++---
 1 file changed, 165 insertions(+), 14 deletions(-)

diff --git a/drivers/firmware/keembay-vpu-ipc.c b/drivers/firmware/keembay-vpu-ipc.c
index a0c5bf549281..b5fea3cc10d3 100644
--- a/drivers/firmware/keembay-vpu-ipc.c
+++ b/drivers/firmware/keembay-vpu-ipc.c
@@ -103,6 +103,12 @@
 /* Every PLL has this many outputs. */
 #define NUM_PLL_OUTPUTS (4)
 
+/* SoC SKU length, in bytes. */
+#define SOC_INFO_SKU_BYTES 6
+
+/* SoC stepping length, in bytes. */
+#define SOC_INFO_STEPPING_BYTES 2
+
 /**
  * struct boot_parameters
  * @magic_number:		Magic number to indicate structure populated
@@ -158,7 +164,8 @@ struct boot_parameters {
 	uint32_t si_stepping;
 	uint64_t device_id;
 	uint64_t feature_exclusion;
-	uint32_t reserved_4[58];
+	uint64_t sku;
+	uint32_t reserved_4[56];
 	/* Unused/reserved: 0x400 - 0xFFF */
 	uint32_t reserved_5[0x300];
 } __packed;
@@ -235,6 +242,14 @@ struct vpu_ipc_dev {
 	char *firmware_name;
 };
 
+struct vpu_ipc_soc_info {
+	u64 device_id;
+	u64 feature_exclusion;
+	u32 hardware_id;
+	u8 stepping[2];
+	u8 sku[6];
+};
+
 enum keembay_vpu_event {
 	KEEMBAY_VPU_EVENT_BOOT = 0,
 	KEEMBAY_VPU_EVENT_BOOT_FAILED,
@@ -250,8 +265,7 @@ static struct vpu_ipc_dev *to_vpu_dev(struct device *dev);
 
 static struct kobject *vpu_ipc_kobj;
 
-static u64 device_id;
-static u64 feature_exclusion;
+static struct vpu_ipc_soc_info *vpu_ipc_soc_info;
 
 /**
  * vpu_ipc_handle_event() - Handle events and optionally update state
@@ -780,16 +794,24 @@ static int setup_boot_parameters(struct vpu_ipc_dev *vpu_dev)
 	vpu_dev->boot_params->nce_wdt_to_irq_a53_redir =
 		vpu_dev->nce_wdt_redirect;
 
-	/* TODO: setup A53SS_VERSION_ID */
-	vpu_dev->boot_params->a53ss_version_id = 0x0;
+	/* Setup A53SS_VERSION_ID */
+	vpu_dev->boot_params->a53ss_version_id = vpu_ipc_soc_info->hardware_id;
 
-	/* TODO: setup Silicon stepping */
-	vpu_dev->boot_params->si_stepping = 0x0;
+	/* Setup Silicon stepping */
+	vpu_dev->boot_params->si_stepping = vpu_ipc_soc_info->stepping[0] |
+					    vpu_ipc_soc_info->stepping[1] << 8;
 
 	/* Set feature exclude and device id information. */
-	vpu_dev->boot_params->device_id = device_id;
-	vpu_dev->boot_params->feature_exclusion = feature_exclusion;
-
+	vpu_dev->boot_params->device_id = vpu_ipc_soc_info->device_id;
+	vpu_dev->boot_params->feature_exclusion = vpu_ipc_soc_info->feature_exclusion;
+
+	/* Set SKU information */
+	vpu_dev->boot_params->sku = (u64)vpu_ipc_soc_info->sku[0] |
+				    (u64)vpu_ipc_soc_info->sku[1] << 8 |
+				    (u64)vpu_ipc_soc_info->sku[2] << 16 |
+				    (u64)vpu_ipc_soc_info->sku[3] << 24 |
+				    (u64)vpu_ipc_soc_info->sku[4] << 32 |
+				    (u64)vpu_ipc_soc_info->sku[5] << 40;
 	return 0;
 }
 
@@ -1507,6 +1529,11 @@ int intel_keembay_vpu_wait_for_ready(struct device *dev, u32 timeout)
 }
 EXPORT_SYMBOL(intel_keembay_vpu_wait_for_ready);
 
+static inline ssize_t show_attr_u32(char *buf, u32 val)
+{
+	return sprintf(buf, "0x%x\n", val);
+}
+
 static inline ssize_t show_attr_u64(char *buf, u64 val)
 {
 	return sprintf(buf, "0x%llx\n", val);
@@ -1526,18 +1553,68 @@ static inline ssize_t store_attr_u64(const char *buf, size_t n, u64 *dest)
 	return n;
 }
 
+static inline ssize_t show_attr_u8_array(char *buf, u8 *array, size_t src_len)
+{
+	size_t i = 0;
+	ssize_t ret_len = 0;
+
+	for (i = 0; i < src_len; i++)
+		ret_len += sprintf(buf + ret_len, "%c", array[i]);
+	ret_len += sprintf(buf + ret_len, "\n");
+	return ret_len;
+}
+
+static inline ssize_t store_attr_u8_array(const char *buf, size_t src_len,
+		u8 *array, size_t dst_len)
+{
+	size_t copy_len = min_t(size_t, src_len, dst_len);
+
+	memcpy(array, buf, copy_len);
+	return src_len;
+}
+
+static ssize_t stepping_show(struct device *dev,
+		struct device_attribute *attr,
+		char *buf)
+{
+	return show_attr_u8_array(buf, vpu_ipc_soc_info->stepping, SOC_INFO_STEPPING_BYTES);
+}
+
+static ssize_t stepping_store(struct device *dev,
+	struct device_attribute *attr,
+	const char *buf, size_t n)
+{
+	return store_attr_u8_array(buf, n, vpu_ipc_soc_info->stepping, SOC_INFO_STEPPING_BYTES);
+}
+static DEVICE_ATTR_RW(stepping);
+
+static ssize_t sku_show(struct device *dev,
+		struct device_attribute *attr,
+		char *buf)
+{
+	return show_attr_u8_array(buf, vpu_ipc_soc_info->sku, SOC_INFO_SKU_BYTES);
+}
+
+static ssize_t sku_store(struct device *dev,
+	struct device_attribute *attr,
+	const char *buf, size_t n)
+{
+	return store_attr_u8_array(buf, n, vpu_ipc_soc_info->sku, SOC_INFO_SKU_BYTES);
+}
+static DEVICE_ATTR_RW(sku);
+
 static ssize_t device_id_show(struct device *dev,
 		struct device_attribute *attr,
 		char *buf)
 {
-	return show_attr_u64(buf, device_id);
+	return show_attr_u64(buf, vpu_ipc_soc_info->device_id);
 }
 
 static ssize_t device_id_store(struct device *dev,
 		struct device_attribute *attr,
 		const char *buf, size_t n)
 {
-	return store_attr_u64(buf, n, &device_id);
+	return store_attr_u64(buf, n, &vpu_ipc_soc_info->device_id);
 }
 static DEVICE_ATTR_RW(device_id);
 
@@ -1545,20 +1622,38 @@ static ssize_t feature_exclusion_show(struct device *dev,
 		struct device_attribute *attr,
 		char *buf)
 {
-	return show_attr_u64(buf, feature_exclusion);
+	return show_attr_u64(buf, vpu_ipc_soc_info->feature_exclusion);
 }
 
 static ssize_t feature_exclusion_store(struct device *dev,
 	struct device_attribute *attr,
 	const char *buf, size_t n)
 {
-	return store_attr_u64(buf, n, &feature_exclusion);
+	return store_attr_u64(buf, n, &vpu_ipc_soc_info->feature_exclusion);
 }
 static DEVICE_ATTR_RW(feature_exclusion);
 
+static ssize_t hardware_id_show(struct device *dev,
+		struct device_attribute *attr,
+		char *buf)
+{
+	return show_attr_u32(buf, vpu_ipc_soc_info->hardware_id);
+}
+
+static ssize_t hardware_id_store(struct device *dev,
+	struct device_attribute *attr,
+	const char *buf, size_t n)
+{
+	return -EPERM;
+}
+static DEVICE_ATTR_RW(hardware_id);
+
 static const struct attribute *vpu_ipc_attrs[] = {
+	&dev_attr_stepping.attr,
+	&dev_attr_sku.attr,
 	&dev_attr_device_id.attr,
 	&dev_attr_feature_exclusion.attr,
+	&dev_attr_hardware_id.attr,
 	NULL
 };
 
@@ -1689,6 +1784,51 @@ static struct vpu_ipc_dev *to_vpu_dev(struct device *dev)
 	return platform_get_drvdata(pdev);
 }
 
+static int retrieve_dt_soc_information(void)
+{
+	struct device_node *soc_info_dn;
+	int ret;
+
+	soc_info_dn = of_find_node_by_path("/soc/version-info");
+	if (!soc_info_dn)
+		return -ENOENT;
+
+	ret = of_property_read_u64(soc_info_dn, "feature-exclusion",
+				   &vpu_ipc_soc_info->feature_exclusion);
+	if (ret) {
+		pr_err("Property 'feature-exclusion' can't be read.\n");
+		return ret;
+	}
+	ret = of_property_read_u64(soc_info_dn, "device-id",
+				   &vpu_ipc_soc_info->device_id);
+	if (ret) {
+		pr_err("Property 'device-id' can't be read.\n");
+		return ret;
+	}
+	ret = of_property_read_u32(soc_info_dn, "hardware-id",
+				   &vpu_ipc_soc_info->hardware_id);
+	if (ret) {
+		pr_err("Property 'hardware-id' can't be read.\n");
+		return ret;
+	}
+	ret = of_property_read_u8_array(soc_info_dn, "sku",
+					vpu_ipc_soc_info->sku,
+					SOC_INFO_SKU_BYTES);
+	if (ret) {
+		pr_err("Property 'sku' can't be read.\n");
+		return ret;
+	}
+	ret = of_property_read_u8_array(soc_info_dn, "stepping",
+					vpu_ipc_soc_info->stepping,
+					SOC_INFO_STEPPING_BYTES);
+	if (ret) {
+		pr_err("Property 'stepping' can't be read.\n");
+		return ret;
+	}
+
+	return 0;
+}
+
 static int __init vpu_ipc_sysfs_init(void)
 {
 	int rc;
@@ -1697,10 +1837,20 @@ static int __init vpu_ipc_sysfs_init(void)
 	if (!vpu_ipc_kobj)
 		return -ENOMEM;
 
+	vpu_ipc_soc_info = kzalloc(sizeof(*vpu_ipc_soc_info), GFP_KERNEL);
+	if (!vpu_ipc_soc_info) {
+		rc = -ENOMEM;
+		goto cleanup_kobj;
+	}
+
 	rc = sysfs_create_files(vpu_ipc_kobj, vpu_ipc_attrs);
 	if (rc < 0)
 		goto cleanup_kobj;
 
+	rc = retrieve_dt_soc_information();
+	if (rc < 0)
+		pr_warn("VPU IPC failed to find SoC info, using defaults.\n");
+
 	return 0;
 
 cleanup_kobj:
@@ -1712,6 +1862,7 @@ static int __init vpu_ipc_sysfs_init(void)
 static void __exit vpu_ipc_sysfs_exit(void)
 {
 	sysfs_remove_files(vpu_ipc_kobj, vpu_ipc_attrs);
+	kfree(vpu_ipc_soc_info);
 	kobject_put(vpu_ipc_kobj);
 }
 
-- 
2.27.0

