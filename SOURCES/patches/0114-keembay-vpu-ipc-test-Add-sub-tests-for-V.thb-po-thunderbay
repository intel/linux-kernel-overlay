From ee2c990be1eabb12604a8de302d98d6ef83fde92 Mon Sep 17 00:00:00 2001
From: Daniele Alessandrelli <daniele.alessandrelli@intel.com>
Date: Thu, 28 May 2020 18:15:06 +0100
Subject: [PATCH 114/223] keembay-vpu-ipc-test: Add sub-tests for VPU start,
 stop and reset

In addition to the main test (which starts, reset and stop the VPU all
at once), more standalone tests are added:
- A test that starts the VPU and leaves it running
- A test that resets the VPU
- A test that stops the VPU

These new tests are meant to help debugging when the main tests fails.

Signed-off-by: Daniele Alessandrelli <daniele.alessandrelli@intel.com>
---
 drivers/firmware/keembay-vpu-ipc-test.c | 261 ++++++++++++++++++++----
 1 file changed, 222 insertions(+), 39 deletions(-)

diff --git a/drivers/firmware/keembay-vpu-ipc-test.c b/drivers/firmware/keembay-vpu-ipc-test.c
index c85e842906f3..fc8166d0e238 100644
--- a/drivers/firmware/keembay-vpu-ipc-test.c
+++ b/drivers/firmware/keembay-vpu-ipc-test.c
@@ -40,6 +40,15 @@ static int test_fw_name_open(struct inode *inode, struct file *file);
 /* Forward declaration of the write function for the 'test_fw_name' file. */
 static ssize_t test_fw_name_wr(struct file *, const char __user *, size_t,
 				loff_t *);
+/* Forward declaration of the write function for the 'test_vpu_start' file. */
+static ssize_t test_vpu_start_wr(struct file *, const char __user *, size_t,
+				 loff_t *);
+/* Forward declaration of the write function for the 'test_vpu_reset' file. */
+static ssize_t test_vpu_reset_wr(struct file *, const char __user *, size_t,
+				 loff_t *);
+/* Forward declaration of the write function for the 'test_vpu_stop' file. */
+static ssize_t test_vpu_stop_wr(struct file *, const char __user *, size_t,
+				loff_t *);
 /* Forward declaration of the write function for the 'test_vpu' file. */
 static ssize_t test_vpu_wr(struct file *, const char __user *, size_t,
 			   loff_t *);
@@ -55,6 +64,24 @@ static LIST_HEAD(dut_list);
  */
 static struct dentry *test_dir;
 
+/* The file operations for the 'test_vpu_start' file. */
+static const struct file_operations test_vpu_start_fops = {
+	.owner	= THIS_MODULE,
+	.write	= test_vpu_start_wr,
+};
+
+/* The file operations for the 'test_vpu_reset' file. */
+static const struct file_operations test_vpu_reset_fops = {
+	.owner	= THIS_MODULE,
+	.write	= test_vpu_reset_wr,
+};
+
+/* The file operations for the 'test_vpu_stop' file. */
+static const struct file_operations test_vpu_stop_fops = {
+	.owner	= THIS_MODULE,
+	.write	= test_vpu_stop_wr,
+};
+
 /* The file operations for the 'test_vpu' file. */
 static const struct file_operations test_vpu_fops = {
 	.owner	= THIS_MODULE,
@@ -101,26 +128,11 @@ static int intel_keembay_vpu_ipc_test_send_data(struct device *dev)
 	return ret;
 }
 
-static int run_vpu_test(struct device *dev)
+static int test_vpu_start(struct device *dev)
 {
 	int ret;
 	enum intel_keembay_vpu_state state;
 
-	pr_info("Starting VPU/IPC test for device: %s\n", dev_name(dev));
-
-	/* Check state */
-	state = intel_keembay_vpu_status(dev);
-	if (state != KEEMBAY_VPU_OFF) {
-		pr_warn("VPU was not OFF, test may fail (it was %d)\n", state);
-
-		/* Stop the VPU */
-		ret = intel_keembay_vpu_stop(dev);
-		if (ret) {
-			pr_err("Failed to stop VPU: %d\n", ret);
-			return ret;
-		}
-	}
-
 	/* Boot VPU */
 	ret = intel_keembay_vpu_startup(dev, test_fw_name);
 	if (ret) {
@@ -145,20 +157,12 @@ static int run_vpu_test(struct device *dev)
 	}
 	pr_info("VPU was ready.\n");
 
-	/* Check WDT API */
-	ret = intel_keembay_vpu_get_wdt_count(dev, KEEMBAY_VPU_NCE);
-	if (ret < 0) {
-		pr_err("Error getting NCE WDT count.\n");
-		return ret;
-	}
-	pr_info("NCE WDT count = %d\n", ret);
+	return 0;
+}
 
-	ret = intel_keembay_vpu_get_wdt_count(dev, KEEMBAY_VPU_MSS);
-	if (ret < 0) {
-		pr_err("Error getting MSS WDT count.\n");
-		return ret;
-	}
-	pr_info("MSS WDT count = %d\n", ret);
+static int test_vpu_reset(struct device *dev)
+{
+	int ret;
 
 	/* Reset the VPU */
 	ret = intel_keembay_vpu_reset(dev);
@@ -176,15 +180,14 @@ static int run_vpu_test(struct device *dev)
 	}
 	pr_info("Successfully synchronised state with VPU - after reset!\n");
 
-	/* Send test data on test channel */
-	ret = intel_keembay_vpu_ipc_test_send_data(dev);
-	if (ret) {
-		pr_err("Tried to send data but failed.\n");
-		return ret;
-	}
-	pr_info("Successfully sent test data!\n");
+	return 0;
+}
+
+static int test_vpu_stop(struct device *dev)
+{
+	int ret;
+	enum intel_keembay_vpu_state state;
 
-	/* Stop the VPU */
 	ret = intel_keembay_vpu_stop(dev);
 	if (ret) {
 		pr_err("Failed to stop VPU: %d\n", ret);
@@ -199,10 +202,127 @@ static int run_vpu_test(struct device *dev)
 		       state);
 		return -EIO;
 	}
-
 	return 0;
 }
 
+static int run_vpu_test(struct device *dev)
+{
+	int ret;
+	enum intel_keembay_vpu_state state;
+
+	pr_info("Starting VPU/IPC test for device: %s\n", dev_name(dev));
+
+	/* Check state */
+	state = intel_keembay_vpu_status(dev);
+	if (state != KEEMBAY_VPU_OFF) {
+		pr_warn("VPU was not OFF, test may fail (it was %d)\n", state);
+
+		/* Stop the VPU */
+		ret = intel_keembay_vpu_stop(dev);
+		if (ret) {
+			pr_err("Failed to stop VPU: %d\n", ret);
+			return ret;
+		}
+	}
+
+	/* Start VPU */
+	ret = test_vpu_start(dev);
+	if (ret)
+		return ret;
+
+	/* Check WDT API */
+	ret = intel_keembay_vpu_get_wdt_count(dev, KEEMBAY_VPU_NCE);
+	if (ret < 0) {
+		pr_err("Error getting NCE WDT count.\n");
+		return ret;
+	}
+	pr_info("NCE WDT count = %d\n", ret);
+
+	ret = intel_keembay_vpu_get_wdt_count(dev, KEEMBAY_VPU_MSS);
+	if (ret < 0) {
+		pr_err("Error getting MSS WDT count.\n");
+		return ret;
+	}
+	pr_info("MSS WDT count = %d\n", ret);
+
+	/* vpu_reset() */
+	ret = test_vpu_reset(dev);
+	if (ret)
+		return ret;
+
+	/* Send test data on test channel */
+	ret = intel_keembay_vpu_ipc_test_send_data(dev);
+	if (ret) {
+		pr_err("Tried to send data but failed.\n");
+		return ret;
+	}
+	pr_info("Successfully sent test data!\n");
+
+	/* VPU_STOP */
+	ret = test_vpu_stop(dev);
+
+	return ret;
+}
+
+/* VPU Start Test thread function. */
+static int test_vpu_start_thread_fn(void *data)
+{
+	struct device *vpu_dev = data;
+	int rc;
+	char name[TASK_COMM_LEN];
+
+	get_task_comm(name, current);
+	pr_info("%s: started\n", name);
+
+	rc = test_vpu_start(vpu_dev);
+	if (rc)
+		pr_info("VPU Start test FAILED for %s: %d\n",
+			dev_name(vpu_dev), rc);
+	else
+		pr_info("VPU Start test SUCCESSFUL for %s\n",
+			dev_name(vpu_dev));
+	do_exit(rc);
+}
+
+/* VPU Reset Test thread function. */
+static int test_vpu_reset_thread_fn(void *data)
+{
+	struct device *vpu_dev = data;
+	int rc;
+	char name[TASK_COMM_LEN];
+
+	get_task_comm(name, current);
+	pr_info("%s: started\n", name);
+
+	rc = test_vpu_reset(vpu_dev);
+	if (rc)
+		pr_info("VPU Reset test FAILED for %s: %d\n",
+			dev_name(vpu_dev), rc);
+	else
+		pr_info("VPU Reset test SUCCESSFUL for %s\n",
+			dev_name(vpu_dev));
+	do_exit(rc);
+}
+
+/* VPU Stop Test thread function. */
+static int test_vpu_stop_thread_fn(void *data)
+{
+	struct device *vpu_dev = data;
+	int rc;
+	char name[TASK_COMM_LEN];
+
+	get_task_comm(name, current);
+	pr_info("%s: started\n", name);
+
+	rc = test_vpu_stop(vpu_dev);
+	if (rc)
+		pr_info("VPU Stop test FAILED for %s: %d\n", dev_name(vpu_dev),
+			rc);
+	else
+		pr_info("VPU Stop test SUCCESSFUL for %s\n", dev_name(vpu_dev));
+	do_exit(rc);
+}
+
 /* VPU Test thread func. */
 static int test_vpu_thread_fn(void *data)
 {
@@ -221,6 +341,54 @@ static int test_vpu_thread_fn(void *data)
 	do_exit(rc);
 }
 
+static ssize_t test_vpu_start_wr(struct file *filp, const char __user *buf,
+				 size_t count, loff_t *fpos)
+{
+	struct task_struct *thread;
+	struct device *vpu_dev = filp->f_inode->i_private;
+
+	pr_info("TEST_VPU_START write: %s\n", dev_name(vpu_dev));
+
+	thread = kthread_run(&test_vpu_start_thread_fn, (void *)vpu_dev,
+			     "t-vpu-start-%s", dev_name(vpu_dev));
+	if (IS_ERR(thread))
+		return PTR_ERR(thread);
+
+	return count;
+}
+
+static ssize_t test_vpu_reset_wr(struct file *filp, const char __user *buf,
+				 size_t count, loff_t *fpos)
+{
+	struct task_struct *thread;
+	struct device *vpu_dev = filp->f_inode->i_private;
+
+	pr_info("TEST_VPU_RESET write: %s\n", dev_name(vpu_dev));
+
+	thread = kthread_run(&test_vpu_reset_thread_fn, (void *)vpu_dev,
+			     "t-vpu-reset-%s", dev_name(vpu_dev));
+	if (IS_ERR(thread))
+		return PTR_ERR(thread);
+
+	return count;
+}
+
+static ssize_t test_vpu_stop_wr(struct file *filp, const char __user *buf,
+				size_t count, loff_t *fpos)
+{
+	struct task_struct *thread;
+	struct device *vpu_dev = filp->f_inode->i_private;
+
+	pr_info("TEST_VPU_STOP write: %s\n", dev_name(vpu_dev));
+
+	thread = kthread_run(&test_vpu_stop_thread_fn, (void *)vpu_dev,
+			     "t-vpu-stop-%s", dev_name(vpu_dev));
+	if (IS_ERR(thread))
+		return PTR_ERR(thread);
+
+	return count;
+}
+
 static ssize_t test_vpu_wr(struct file *filp, const char __user *buf,
 			   size_t count, loff_t *fpos)
 {
@@ -255,7 +423,22 @@ static int add_dev_to_dbgfs_tree(struct device *dev, struct dentry *base_dir)
 				   &test_vpu_fops);
 	if (!file)
 		return -ENOMEM;
-	pr_info("TEST_MOD: send file created\n");
+
+	/* Create test_vpu file */
+	file = debugfs_create_file("test_vpu_start", 0220, dev_dir, dev,
+				   &test_vpu_start_fops);
+	if (!file)
+		return -ENOMEM;
+
+	file = debugfs_create_file("test_vpu_reset", 0220, dev_dir, dev,
+				   &test_vpu_reset_fops);
+	if (!file)
+		return -ENOMEM;
+
+	file = debugfs_create_file("test_vpu_stop", 0220, dev_dir, dev,
+				   &test_vpu_stop_fops);
+	if (!file)
+		return -ENOMEM;
 
 	return 0;
 }
-- 
2.27.0

