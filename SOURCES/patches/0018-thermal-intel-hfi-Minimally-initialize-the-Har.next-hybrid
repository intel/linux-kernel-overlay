From ec7b8fef5a0c72702e9450d16cdad90a673029b6 Mon Sep 17 00:00:00 2001
From: Ricardo Neri <ricardo.neri-calderon@linux.intel.com>
Date: Fri, 25 May 2018 13:20:46 +0800
Subject: [PATCH 18/76] thermal: intel: hfi: Minimally initialize the Hardware
 Feedback Interface

Intel hardware can provide guidance to the OS scheduler to improve workload
balancing through the Hardware Feedback Interface (HFI). For each CPU in
the system, hardware provides a performance capability and an energy
efficiency capability rating. These ratings are numbers between 0 and 255
where a higher number depicts a higher capability. Hardware computes these
scores based on the operating conditions of the system such as power and
thermal limits. These ratings are shared with the operating system in a
table resident in memory. Each logical CPU has an entry in the table. When
the hardware updates the ratings, it generates a thermal interrupt. Each
package in the system has its own HFI instance.

The size and format of the HFI table depend on the supported features and
can only be determined at runtime. As an initial step to enable the HFI,
parse its features and allocate, per package, one data structure with the
necessary parameters to read and navigate the HFI tables.

The HFI relies on both the system's package-level thermal management and
the local APIC thermal monitor register. The thermal throttle event code
already configures such hardware. Thus, invoke the HFI code from there.

Subsequent changesets will provide per-CPU initialization and interrupt
handling.

Cc: Andi Kleen <ak@linux.intel.com>
Cc: Aubrey Li <aubrey.li@linux.intel.com>
Cc: Len Brown <len.brown@intel.com>
Cc: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Cc: Tim Chen <tim.c.chen@linux.intel.com>
Cc: "Ravi V. Shankar" <ravi.v.shankar@intel.com>
Co-developed by: Aubrey Li <aubrey.li@linux.intel.com>
Signed-off-by: Aubrey Li <aubrey.li@linux.intel.com>
Signed-off-by: Ricardo Neri <ricardo.neri-calderon@linux.intel.com>
---
Changes since v5:
  * Reduced the scope of the patch to only parse the HFI features and allocate
    per-package HFI table params.
  * Added a new hfi_parse_features() to discover HFI features in a separate
    function.
  * Removed initialization from device_initcall(). Instead, initialize HFI
    from thermal_throttle_init_device() as HFI depends on both package-
    level thermal features and thermal vector of the local APIC.
  * Relocated hfi.c to drivers/thermal/intel, following therm_throt.c

Changes since v4:
  * Removed unnecessary CPU hotplug callback and logic to get the indexes
    of CPUs in the HFI table. Instead, a subsequent patch will initialize
    the index from identify_cpu() (in the CPU hotplug online path). (Len)
  * Reworded Kconfig option for accuracy. (Tim)
  * Add __packed attribute to HFI data structures. It is probably not
    necessary today but the structure my change in the future. (Len)
  * Remove struct hfi_info. Instead, use a per-CPU variable for a CPU's
    index in the HFI table. A value of -1 means the index is not
    initialized. (Len).
  * Renamed local variable edx of intel_hfi_init() to the more generic name
    reg.
  * Removed check (topology_max_packages() > 1) as such macro returns the
    number of *logical* packages, which can be larger than the number of
    physical packages if kernel command line arguments make the condition
    (maxcpus < nr_cpus) true, or some CPUs fail to come online.
  * Generalized data structures to accommodate the Enhanced Hardware
    Feedback Interface.
  * Added a new init_hfi_params() function to set parameters to navigate
    the table.
  * Removed per-CPU timestamp. All capacities will be updated when
    hardware updates the HFI table.

Changes since v3:
  * Removed unnecessary headers.
  * Use [alloc|free]_pages_exact() instead of __get_free_pages() to handle
    memory for the HFI table. Also, fix bug on the number of requested
    pages. (Dave)
  * Explain why memory for the HFI table must be page-aligned. (Dave)
  * Dropped pointless sanity check for CPUID with respect to the maximum
    number requested pages for the HFI table. (Dave)
  * Set CPUs' HFI indexes when initializing the HFI table. This removes the
    previous check for initialization when handling the thermal interrupt.
    (PeterZ)
  * Improved inline comments. (PeterZ)

Changes since v2:
  * None

Changes since v1:
  * Used __GFP_ZERO instead of memset(base, 0, size) to initialize the HFI
    memory page. (Peter Z)
  * Removed per-CPU printouts when initializing the HFI. (Peter Z)
  * Changed the size of hfi_table.cpu_cap from NR_CPUS to zero. Memory for
    this data structure is dynamically allocated based on CPUID info.
    (Peter Z)
  * Relocated the implementation of function x86_hfi_check_event() to the
    patch in which it is used. (Peter Z)
  * Divided HFI initialization into two sections: put basic initialization
    in a device initcall. Complete per-CPU initialization in a CPU hotplug
    online callback. (Ravi)
  * Removed useless overwrite of table_pages in every CPU. Instead, use the
    CPUID information from the CPU doing the HFI initialization. (Peter Z)
  * Removed per-CPU printouts during initialization. (Peter Z)
  * Renamed functions with the more appropriate prefix intel_hfi*. (Len)
  * Minor rewords in Kconfig option description. (Len)
  * Initialized package-level MSRs only once. (Srinivas)
  * Added a paragraph describing what the new hfi.c does. (Andi)
  * Sanity-check the number of pages requested by HFI in CPUID. (Andi)
  * Removed pointless check of the validity of the virtual base address of
    the HFI table. (Andi)
---
 arch/x86/include/asm/cpufeatures.h  |   1 +
 arch/x86/include/asm/hfi.h          |  33 +++++++
 arch/x86/include/asm/msr-index.h    |   6 ++
 drivers/thermal/intel/Kconfig       |  14 +++
 drivers/thermal/intel/Makefile      |   1 +
 drivers/thermal/intel/intel_hfi.c   | 144 ++++++++++++++++++++++++++++
 drivers/thermal/intel/therm_throt.c |   3 +
 7 files changed, 202 insertions(+)
 create mode 100644 arch/x86/include/asm/hfi.h
 create mode 100644 drivers/thermal/intel/intel_hfi.c

diff --git a/arch/x86/include/asm/cpufeatures.h b/arch/x86/include/asm/cpufeatures.h
index ac37830ae941..df1ba5098f71 100644
--- a/arch/x86/include/asm/cpufeatures.h
+++ b/arch/x86/include/asm/cpufeatures.h
@@ -325,6 +325,7 @@
 #define X86_FEATURE_HWP_ACT_WINDOW	(14*32+ 9) /* HWP Activity Window */
 #define X86_FEATURE_HWP_EPP		(14*32+10) /* HWP Energy Perf. Preference */
 #define X86_FEATURE_HWP_PKG_REQ		(14*32+11) /* HWP Package Level Request */
+#define X86_FEATURE_INTEL_HFI		(14*32+19) /* Hardware Feedback Interface */
 
 /* AMD SVM Feature Identification, CPUID level 0x8000000a (EDX), word 15 */
 #define X86_FEATURE_NPT			(15*32+ 0) /* Nested Page Table support */
diff --git a/arch/x86/include/asm/hfi.h b/arch/x86/include/asm/hfi.h
new file mode 100644
index 000000000000..2c72f24c734e
--- /dev/null
+++ b/arch/x86/include/asm/hfi.h
@@ -0,0 +1,33 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+#ifndef _ASM_X86_INTEL_HFI_H
+#define _ASM_X86_INTEL_HFI_H
+
+/* Hardware Feedback Interface Enumeration */
+#define CPUID_HFI_LEAF			6
+#define CPUID_HFI_CAP_MASK		0xff
+#define CPUID_HFI_TABLE_SIZE_MASK	0x0f00
+#define CPUID_HFI_TABLE_SIZE_SHIFT	8
+#define CPUID_HFI_CPU_INDEX_MASK	0xffff0000
+#define CPUID_HFI_CPU_INDEX_SHIFT	16
+
+/* Hardware Feedback Interface Pointer */
+#define HFI_PTR_VALID_BIT		BIT(0)
+#define HFI_PTR_ADDR_SHIFT		12
+
+/* Hardware Feedback Interface Configuration */
+#define HFI_CONFIG_ENABLE_BIT		BIT(0)
+
+/* Hardware Feedback Interface Capabilities */
+#define HFI_CAPABILITIES_MASK		0xff
+#define HFI_CAPABILITIES_NR		8
+#define HFI_CAPABILITIES_PERFORMANCE	BIT(0)
+#define HFI_CAPABILITIES_ENERGY_EFF	BIT(1)
+
+#if defined(CONFIG_INTEL_HFI)
+void __init intel_hfi_init(void);
+#else
+static inline void intel_hfi_init(void) { }
+#endif
+
+#endif /* _ASM_X86_HFI_H */
diff --git a/arch/x86/include/asm/msr-index.h b/arch/x86/include/asm/msr-index.h
index 211ba3375ee9..efb78ef854de 100644
--- a/arch/x86/include/asm/msr-index.h
+++ b/arch/x86/include/asm/msr-index.h
@@ -685,12 +685,14 @@
 
 #define PACKAGE_THERM_STATUS_PROCHOT		(1 << 0)
 #define PACKAGE_THERM_STATUS_POWER_LIMIT	(1 << 10)
+#define PACKAGE_THERM_STATUS_HFI_UPDATED	(1 << 26)
 
 #define MSR_IA32_PACKAGE_THERM_INTERRUPT	0x000001b2
 
 #define PACKAGE_THERM_INT_HIGH_ENABLE		(1 << 0)
 #define PACKAGE_THERM_INT_LOW_ENABLE		(1 << 1)
 #define PACKAGE_THERM_INT_PLN_ENABLE		(1 << 24)
+#define PACKAGE_THERM_INT_HFI_ENABLE		(1 << 25)
 
 /* Thermal Thresholds Support */
 #define THERM_INT_THRESHOLD0_ENABLE    (1 << 15)
@@ -935,4 +937,8 @@
 #define MSR_VM_IGNNE                    0xc0010115
 #define MSR_VM_HSAVE_PA                 0xc0010117
 
+/* Hardware Feedback Interface */
+#define MSR_IA32_HW_FEEDBACK_PTR        0x17d0
+#define MSR_IA32_HW_FEEDBACK_CONFIG     0x17d1
+
 #endif /* _ASM_X86_MSR_INDEX_H */
diff --git a/drivers/thermal/intel/Kconfig b/drivers/thermal/intel/Kconfig
index e4299ca3423c..ebfb7384ba29 100644
--- a/drivers/thermal/intel/Kconfig
+++ b/drivers/thermal/intel/Kconfig
@@ -90,3 +90,17 @@ config INTEL_TCC_COOLING
 	  Note that, on different platforms, the behavior might be different
 	  on how fast the setting takes effect, and how much the CPU frequency
 	  is reduced.
+
+config INTEL_HFI
+	bool "Intel Hardware Feedback Interface"
+	depends on CPU_SUP_INTEL
+	depends on SCHED_MC && X86_THERMAL_VECTOR
+	help
+	  Select this option to enable the Hardware Feedback Interface in
+	  Intel hybrid processors. If selected, hardware provides guidance to
+	  the scheduler to enhance task placement. The feedback provided by the
+	  HFI feeds the scheduler to update the capacity of CPUs. Depending on
+	  the operating conditions of the system, the capacity of CPUs may
+	  change during runtime.
+
+	  Say Y to enable the Hardware Feedback Interface, say Y.
diff --git a/drivers/thermal/intel/Makefile b/drivers/thermal/intel/Makefile
index 5ff2afa388f7..d6164cd3ecb5 100644
--- a/drivers/thermal/intel/Makefile
+++ b/drivers/thermal/intel/Makefile
@@ -12,3 +12,4 @@ obj-$(CONFIG_INTEL_BXT_PMIC_THERMAL) += intel_bxt_pmic_thermal.o
 obj-$(CONFIG_INTEL_PCH_THERMAL)	+= intel_pch_thermal.o
 obj-$(CONFIG_INTEL_TCC_COOLING)	+= intel_tcc_cooling.o
 obj-$(CONFIG_X86_THERMAL_VECTOR) += therm_throt.o
+obj-$(CONFIG_INTEL_HFI) += intel_hfi.o
diff --git a/drivers/thermal/intel/intel_hfi.c b/drivers/thermal/intel/intel_hfi.c
new file mode 100644
index 000000000000..0f0a48d72ebc
--- /dev/null
+++ b/drivers/thermal/intel/intel_hfi.c
@@ -0,0 +1,144 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Hardware Feedback Interface Driver
+ *
+ * Copyright (c) 2021, Intel Corporation.
+ *
+ * Authors: Aubrey Li <aubrey.li@linux.intel.com>
+ *          Ricardo Neri <ricardo.neri-calderon@linux.intel.com>
+ *
+ *
+ * The Hardware Feedback Interface provides a performance and energy efficiency
+ * capability rating fo each logical processor in the system. Hardware
+ * continuously updates these ratings depending on the operating conditions
+ * of the system (e.g., power limits, thermal constraints, etc). This file
+ * provides functionality to use the HFI to update the capacities of CPUs as
+ * seen by the scheduler.
+ */
+
+#define pr_fmt(fmt)  "intel-hfi: " fmt
+
+#include <linux/slab.h>
+
+#include <asm/hfi.h>
+
+/**
+ * struct hfi_cpu_data - Capabilities of a logical processor in the HFI table.
+ *			 These capabilities are unitless.
+ * @perf_cap:		Performance capability
+ * @ee_cap:		Energy efficiency capability
+ */
+struct hfi_cpu_data {
+	u8	perf_cap;
+	u8	ee_cap;
+} __packed;
+
+/**
+ * struct hfi_hdr - Header of the HFI table. Indicates if hardware updated
+ *		    data in the table.
+ * @perf_updated:	Hardware updated performance capabilities
+ * @ee_updated:		Hardware updated energy efficiency capabilities
+ */
+struct hfi_hdr {
+	u8 perf_updated;
+	u8 ee_updated;
+} __packed;
+
+/**
+ * struct hfi_params - Parameters needed to parse and navigate the HFI table
+ * @ts_counter:		Time stamp of the last update of the table
+ * @hdr:		Base address of the table header
+ * @data:		Base address of the table data
+ */
+struct hfi_params {
+	u64			*ts_counter;
+	void			*hdr;
+	void			*data;
+};
+
+/**
+ * struct hfi_features - Capabilities supported in all dies/pacakges
+ * @capabilities:	Bitmask of supported capabilities per class
+ * @nr_table_pages:	Size of the HFI table in 4KB pages
+ * @cpu_stride:		Stride size to locate capability data of a logical
+ *			processor within the table (i.e., row stride)
+ * @hdr_size:		Size of table header
+ * @parsed:		True if HFI features have been parsed
+ */
+struct hfi_features {
+	unsigned long	capabilities;
+	unsigned int	nr_table_pages;
+	unsigned int	cpu_stride;
+	unsigned int	hdr_size;
+	bool		parsed;
+};
+
+static int max_hfi_param_instances;
+static struct hfi_params *hfi_param_instances;
+
+static struct hfi_features hfi_features;
+
+static __init int hfi_parse_features(void)
+{
+	unsigned int nr_capabilities, reg;
+
+	if (!boot_cpu_has(X86_FEATURE_INTEL_HFI))
+		return -ENODEV;
+
+	if (hfi_features.parsed)
+		return 0;
+
+	/*
+	 * If we are here we know that CPUID_HFI_LEAF exists. Parse the
+	 * supported capabilities and the size of the HFI table.
+	 */
+	reg = cpuid_edx(CPUID_HFI_LEAF);
+
+	hfi_features.capabilities = reg & HFI_CAPABILITIES_MASK;
+	if (!(hfi_features.capabilities & HFI_CAPABILITIES_PERFORMANCE)) {
+		pr_err("Performance reporting not supported! Not using HFI\n");
+		return -ENODEV;
+	}
+
+	/* The number of 4KB pages required by the table */
+	hfi_features.nr_table_pages = ((reg & CPUID_HFI_TABLE_SIZE_MASK) >>
+				      CPUID_HFI_TABLE_SIZE_SHIFT) + 1;
+
+	/*
+	 * The number of supported capabilities determines the number of
+	 * columns in the HFI table.
+	 */
+	nr_capabilities = bitmap_weight(&hfi_features.capabilities,
+					HFI_CAPABILITIES_NR);
+
+	/*
+	 * The header contains change indications for each supported feature.
+	 * The size of the table header is rounded up to be a multiple of 8
+	 * bytes.
+	 */
+	hfi_features.hdr_size = DIV_ROUND_UP(nr_capabilities, 8) * 8;
+
+	/*
+	 * Data of each logical processor is also rounded up to be a multiple
+	 * of 8 bytes.
+	 */
+	hfi_features.cpu_stride = DIV_ROUND_UP(nr_capabilities, 8) * 8;
+
+	hfi_features.parsed = true;
+	return 0;
+}
+
+void __init intel_hfi_init(void)
+{
+	if (hfi_parse_features())
+		return;
+
+	max_hfi_param_instances = topology_max_packages() *
+				  topology_max_die_per_package();
+	hfi_param_instances = kcalloc(max_hfi_param_instances,
+				      sizeof(*hfi_param_instances), GFP_KERNEL);
+	if (!hfi_param_instances) {
+		pr_err("No memory for HFI param instances\n");
+		return;
+	}
+}
diff --git a/drivers/thermal/intel/therm_throt.c b/drivers/thermal/intel/therm_throt.c
index f8e882592ba5..581a276dcf60 100644
--- a/drivers/thermal/intel/therm_throt.c
+++ b/drivers/thermal/intel/therm_throt.c
@@ -29,6 +29,7 @@
 #include <asm/thermal.h>
 #include <asm/traps.h>
 #include <asm/apic.h>
+#include <asm/hfi.h>
 #include <asm/irq.h>
 #include <asm/msr.h>
 
@@ -509,6 +510,8 @@ static __init int thermal_throttle_init_device(void)
 	if (!atomic_read(&therm_throt_en))
 		return 0;
 
+	intel_hfi_init();
+
 	ret = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, "x86/therm:online",
 				thermal_throttle_online,
 				thermal_throttle_offline);
-- 
2.27.0

