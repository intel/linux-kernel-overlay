From 688883f418225ef99653fd6a956b4c287cd9c28f Mon Sep 17 00:00:00 2001
From: Mike Healy <mikex.healy@intel.com>
Date: Fri, 16 Oct 2020 03:46:47 -0700
Subject: [PATCH 127/223] vpu-ipc: VPU authentication update

Boot VPU via call to OPTEE TA

Signed-off-by: Mike Healy <mikex.healy@intel.com>
---
 drivers/firmware/Kconfig           |   1 +
 drivers/firmware/keembay-vpu-ipc.c | 316 +++++++++++++++++++++++------
 2 files changed, 260 insertions(+), 57 deletions(-)

diff --git a/drivers/firmware/Kconfig b/drivers/firmware/Kconfig
index 61bfd254263e..311c95efbe36 100644
--- a/drivers/firmware/Kconfig
+++ b/drivers/firmware/Kconfig
@@ -159,6 +159,7 @@ config KEEMBAY_VPU_IPC
 	tristate "Intel Keem Bay VPU IPC Driver"
 	depends on KEEMBAY_IPC
 	depends on HAVE_ARM_SMCCC
+	depends on TEE && OPTEE
 	help
 	  This option enables support for loading and communicating with
           the firmware on the VPU of the Keem Bay SoC. The driver depends
diff --git a/drivers/firmware/keembay-vpu-ipc.c b/drivers/firmware/keembay-vpu-ipc.c
index 5acf8344f728..b5ba5fb443fa 100644
--- a/drivers/firmware/keembay-vpu-ipc.c
+++ b/drivers/firmware/keembay-vpu-ipc.c
@@ -22,9 +22,17 @@
 #include <linux/of_reserved_mem.h>
 #include <linux/platform_device.h>
 #include <linux/slab.h>
+#include <linux/tee_drv.h>
 
 #include <linux/soc/intel/keembay-ipc.h>
 
+/* The function IDs implemented in VPU AUTH TA */
+#define KMB_TA_VPU_BOOT		0
+#define KMB_TA_VPU_STOP		1
+
+/* The number of parameters passed to VPU AUTH TA */
+#define NUM_TEE_PARAMS		1
+
 /* Function ID for the SiP SMC to boot the VPU */
 #define KMB_SIP_SVC_VPU_BOOT (0xFF10)
 
@@ -71,6 +79,9 @@
 /* Size allowed for header region */
 #define MAX_HEADER_SIZE (0x1000)
 
+/* Maximum size of X509 certificate */
+#define MAX_X509_SIZE 0x1000
+
 /* VPU reset vector must be aligned to 4kB. */
 #define VPU_RESET_VECTOR_ALIGNMENT (0x1000)
 
@@ -218,6 +229,7 @@ struct vpu_ipc_dev {
 	enum intel_keembay_vpu_state state;
 	struct vpu_mem reserved_mem;
 	struct atf_mem x509_mem;
+	size_t x509_size;
 	struct vpu_mem mss_ipc_mem;
 	uint64_t boot_vec_paddr;
 	struct boot_parameters *boot_params;
@@ -242,6 +254,9 @@ struct vpu_ipc_dev {
 	struct device *ipc_dev;
 	char *firmware_name;
 	void (*callback)(struct device *dev, enum intel_keembay_vpu_event);
+	struct tee_context *tee_ctx;
+	struct tee_shm *shm;
+	u32 tee_session;
 };
 
 struct vpu_ipc_soc_info {
@@ -263,12 +278,60 @@ enum keembay_vpu_event {
 	KEEMBAY_VPU_EVENT_MSS_READY_FAIL
 };
 
+/**
+ * struct vpu_boot_ta_shmem
+ * @fw_header_addr:	Memory address of VPU firmware header data
+ * @fw_header_size:	Size of VPU header data
+ * @fw_version_addr:	Memory address of VPU firmware version data
+ * @fw_version_size:	Size of VPU firmware version data
+ * @fw_load_addr:	Memory address of VPU firmware image
+ * @fw_load_size:	Size of VPU firmware image
+ * @x509_addr:		Memory address of VPU binary X.509 certificate
+ * @x509_size:		Size of X.509 certificate
+ * @fw_entry_addr:	VPU boot entry address
+ * @slice_id;		VPU slice ID to be used
+ */
+struct vpu_boot_ta_shmem {
+	u64 fw_header_addr;
+	u32 fw_header_size;
+	u64 fw_version_addr;
+	u32 fw_version_size;
+	u64 fw_load_addr;
+	u32 fw_load_size;
+	u64 x509_addr;
+	u32 x509_size;
+	u64 fw_entry_addr;
+	u32 slice_id;
+} __packed;
+
 static struct vpu_ipc_dev *to_vpu_dev(struct device *dev);
 
 static struct kobject *vpu_ipc_kobj;
 
 static struct vpu_ipc_soc_info *vpu_ipc_soc_info;
 
+/**
+ * VPU_AUTH_TA_UUID: 7671AC66-1B46-4B34-B929-18BB15D398EE
+ *
+ * Randomly generated, and must correspond to the GUID on the TA side.
+ */
+static const uuid_t vpu_auth_ta_uuid =
+	UUID_INIT(0x7671AC66, 0x1B46, 0x4B34,
+		  0xB9, 0x29, 0x18, 0xBB, 0x15, 0xD3, 0x98, 0xEE);
+
+/**
+ * vpu_auth_ta_match() - Determine if GlobalPlatform compliant
+ * @ver:		Version data of TEE device
+ * @data:		Optional additional data for match function
+ *
+ * Returns: 1 if compliant, 0 if not compliant
+ */
+static int vpu_auth_ta_match(struct tee_ioctl_version_data *ver,
+			     const void *data)
+{
+	return ver->gen_caps & TEE_GEN_CAP_GP;
+}
+
 /**
  * vpu_ipc_notify_event() - Trigger callback
  * @vpu_dev:		Private data
@@ -371,7 +434,7 @@ static int vpu_ipc_handle_event(struct vpu_ipc_dev *vpu_dev,
 
 	if (rc)
 		dev_err(dev, "Can't handle event %d in state %d\n",
-				event, vpu_dev->state);
+			event, vpu_dev->state);
 
 	return rc;
 }
@@ -848,39 +911,61 @@ static int setup_boot_parameters(struct vpu_ipc_dev *vpu_dev)
 	return 0;
 }
 
+static void init_ta_args(struct vpu_ipc_dev *vpu_dev,
+			 struct tee_ioctl_invoke_arg *inv_arg,
+			 struct tee_param *param)
+{
+	memset(inv_arg, 0, sizeof(*inv_arg));
+	memset(param, 0, sizeof(*param) * NUM_TEE_PARAMS);
+
+	inv_arg->session = vpu_dev->tee_session;
+	inv_arg->num_params = NUM_TEE_PARAMS;
+
+	param[0].attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT;
+	param[0].u.memref.shm_offs = 0x0;
+	param[0].u.memref.size = vpu_dev->shm->size;
+	param[0].u.memref.shm = vpu_dev->shm;
+}
+
 static int request_vpu_boot(struct vpu_ipc_dev *vpu_dev)
 {
-	uint64_t function_id;
-	uint16_t function_number = KMB_SIP_SVC_VPU_BOOT;
-	struct arm_smccc_res res;
-
-	function_id = ARM_SMCCC_CALL_VAL(ARM_SMCCC_FAST_CALL, ARM_SMCCC_SMC_32,
-					 ARM_SMCCC_OWNER_SIP, function_number);
-
-	/* Arguments are as follows:
-	 * 1. VPU ID (was 'Reserved region physical base address')
-	 * 2. Reserved region size
-	 * 3. Firmware image physical base address
-	 * 4. Firmware image size
-	 * 5. Entry point for VPU
-	 * 6. X509 certificate location
-	 * 7. IMR driver number
-	 *
-	 * FIXME: fw_res addresses are VPU addresses; convert them to CPU
-	 * physical addresses.
-	 *
-	 * FIXME: Parameter 'Reserved region physical base address' was removed
-	 * by IO team when they added multi-slice support in ATF. This needs to
-	 * be re-added somehow.
-	 */
-	arm_smccc_smc(function_id, vpu_dev->vpu_id,
-		      vpu_dev->reserved_mem.size, vpu_dev->fw_res.start,
-		      resource_size(&vpu_dev->fw_res), vpu_dev->boot_vec_paddr,
-		      vpu_dev->x509_mem.paddr, vpu_dev->imr, &res);
+	struct vpu_boot_ta_shmem *vpu_boot_ta_args;
+	struct device *dev = &vpu_dev->pdev->dev;
+	struct tee_param param[NUM_TEE_PARAMS];
+	struct tee_ioctl_invoke_arg inv_arg;
+	int ret;
 
-	if (res.a0) {
-		dev_info(&vpu_dev->pdev->dev, "Boot failed: 0x%lx.\n", res.a0);
-		return -EIO;
+	init_ta_args(vpu_dev, &inv_arg, param);
+	inv_arg.func = KMB_TA_VPU_BOOT;
+
+	vpu_boot_ta_args = tee_shm_get_va(vpu_dev->shm, 0);
+	if (IS_ERR(vpu_boot_ta_args)) {
+		dev_err(dev, "Failed to get address of TEE shared memory\n");
+		return PTR_ERR(vpu_boot_ta_args);
+	}
+
+	memset(vpu_boot_ta_args, 0, sizeof(*vpu_boot_ta_args));
+
+	vpu_boot_ta_args->fw_header_addr = vpu_dev->x509_mem.paddr +
+					   vpu_dev->x509_size;
+	vpu_boot_ta_args->fw_header_size = MAX_HEADER_SIZE;
+	vpu_boot_ta_args->fw_load_addr = vpu_dev->fw_res.start;
+	vpu_boot_ta_args->fw_load_size = resource_size(&vpu_dev->fw_res);
+	vpu_boot_ta_args->fw_version_addr = vpu_boot_ta_args->fw_load_addr -
+					    MAX_FIRMWARE_VERSION_SIZE;
+	vpu_boot_ta_args->fw_version_size = MAX_FIRMWARE_VERSION_SIZE;
+	vpu_boot_ta_args->x509_addr = vpu_dev->x509_mem.paddr;
+	vpu_boot_ta_args->x509_size = vpu_dev->x509_size;
+	vpu_boot_ta_args->fw_entry_addr = vpu_dev->boot_vec_paddr;
+	vpu_boot_ta_args->slice_id = vpu_dev->vpu_id;
+
+	ret = tee_client_invoke_func(vpu_dev->tee_ctx, &inv_arg, param);
+	if ((ret < 0) || (inv_arg.ret != 0)) {
+		dev_err(dev, "KMB_TA_VPU_BOOT invoke err: %x\n",
+			inv_arg.ret);
+		if (ret)
+			return ret;
+		return -EINVAL;
 	}
 
 	dev_info(&vpu_dev->pdev->dev, "Boot SMC successful.\n");
@@ -890,18 +975,32 @@ static int request_vpu_boot(struct vpu_ipc_dev *vpu_dev)
 
 static int request_vpu_stop(struct vpu_ipc_dev *vpu_dev)
 {
-	uint64_t function_id;
-	uint16_t function_number = KMB_SIP_SVC_VPU_STOP;
-	struct arm_smccc_res res;
+	struct vpu_boot_ta_shmem *vpu_boot_ta_args;
+	struct device *dev = &vpu_dev->pdev->dev;
+	struct tee_param param[NUM_TEE_PARAMS];
+	struct tee_ioctl_invoke_arg inv_arg;
+	int ret;
 
-	function_id = ARM_SMCCC_CALL_VAL(ARM_SMCCC_FAST_CALL, ARM_SMCCC_SMC_32,
-					 ARM_SMCCC_OWNER_SIP, function_number);
+	init_ta_args(vpu_dev, &inv_arg, param);
+	inv_arg.func = KMB_TA_VPU_STOP;
 
-	arm_smccc_smc(function_id, vpu_dev->vpu_id, 0, 0, 0, 0, 0, 0, &res);
+	vpu_boot_ta_args = tee_shm_get_va(vpu_dev->shm, 0);
+	if (IS_ERR(vpu_boot_ta_args)) {
+		dev_err(dev, "Failed to get address of TEE shared memory\n");
+		return PTR_ERR(vpu_boot_ta_args);
+	}
 
-	if (res.a0) {
-		dev_info(&vpu_dev->pdev->dev, "Stop failed: 0x%lx.\n", res.a0);
-		return -EIO;
+	memset(vpu_boot_ta_args, 0, sizeof(*vpu_boot_ta_args));
+
+	vpu_boot_ta_args->slice_id = vpu_dev->vpu_id;
+
+	ret = tee_client_invoke_func(vpu_dev->tee_ctx, &inv_arg, param);
+	if ((ret < 0) || (inv_arg.ret != 0)) {
+		dev_err(dev, "KMB_TA_VPU_STOP invoke err: %x\n",
+			inv_arg.ret);
+		if (ret)
+			return ret;
+		return -EINVAL;
 	}
 
 	dev_info(&vpu_dev->pdev->dev, "Stop SMC successful.\n");
@@ -926,12 +1025,13 @@ static void *get_vpu_dev_vaddr(struct vpu_ipc_dev *vpu_dev,
 static int parse_fw_header(struct vpu_ipc_dev *vpu_dev,
 			   const struct firmware *fw)
 {
-	struct firmware_header *fw_header = NULL;
 	struct resource config_res, version_res, total_reserved_res;
-	void *fw_region = NULL;
+	struct device *dev = &vpu_dev->pdev->dev;
+	struct firmware_header *fw_header = NULL;
 	void *version_region = NULL;
 	void *config_region = NULL;
-	struct device *dev = &vpu_dev->pdev->dev;
+	void *x509_region = NULL;
+	void *fw_region = NULL;
 
 	/* Is the fw size big enough to read the header? */
 	if (fw->size < sizeof(struct firmware_header)) {
@@ -1088,7 +1188,55 @@ static int parse_fw_header(struct vpu_ipc_dev *vpu_dev,
 	/* Save off boot vector physical address */
 	vpu_dev->boot_vec_paddr = fw_header->entry_point;
 
-	/* TODO: handle X.509 region */
+	/* Handle X.509 region */
+	x509_region = vpu_dev->x509_mem.vaddr;
+	if (!x509_region) {
+		dev_err(dev,
+			"Couldn't get CPU virtual address for X.509 certificate area.\n");
+		return -EINVAL;
+	}
+
+	/*
+	 * fw->size already checked to be >= (MAX_HEADER_SIZE +
+	 * MAX_FIRMWARE_VERSION_SIZE + fw_header->image_size) above.
+	 */
+	vpu_dev->x509_size = fw->size - (MAX_HEADER_SIZE +
+					 MAX_FIRMWARE_VERSION_SIZE +
+					 fw_header->image_size);
+	if (!vpu_dev->x509_size) {
+		dev_err(dev,
+			"X.509 certificate not present in firmware image.\n");
+		return -EINVAL;
+	}
+	if (vpu_dev->x509_size > MAX_X509_SIZE) {
+		dev_err(dev,
+			"X.509 certificate size exceeds maximum allowable.\n");
+		return -EINVAL;
+	}
+
+	if (vpu_dev->x509_size + MAX_HEADER_SIZE > vpu_dev->x509_mem.size) {
+		dev_err(dev,
+			"X.509 certificate and firmware header too large to fit in allocated memory\n");
+		return -EINVAL;
+	}
+
+	/*
+	 * Copy X.509 certificate: the cert is located in the file @ offset of
+	 * MAX_HEADER_SIZE + MAX_FIRMWARE_VERSION_SIZE + fw_header->image_size,
+	 * size has been checked to not be larger than that allowed.
+	 */
+	memcpy_toio(x509_region,
+		    &fw->data[MAX_HEADER_SIZE + MAX_FIRMWARE_VERSION_SIZE +
+			      fw_header->image_size],
+		    vpu_dev->x509_size);
+
+	/*
+	 * Copy header to X.509 region directly after certificate
+	 * Certificate size + MAX_HEADER_SIZE has already been checked
+	 * to confirm both will fit in the allocated memory.
+	 */
+	memcpy_toio(x509_region + vpu_dev->x509_size, fw->data,
+		    MAX_HEADER_SIZE);
 
 	return 0;
 }
@@ -1169,12 +1317,11 @@ static int create_ready_message_thread(struct vpu_ipc_dev *vpu_dev)
 	return 0;
 }
 
-static int kickoff_vpu_sequence(struct vpu_ipc_dev *vpu_dev,
-				int (*boot_fn)(struct vpu_ipc_dev *))
+static int kickoff_vpu_sequence(struct vpu_ipc_dev *vpu_dev)
 {
-	int rc;
-	int error_close_rc;
 	struct device *dev = &vpu_dev->pdev->dev;
+	int error_close_rc;
+	int rc;
 
 	/*
 	 * OK, ready to start the parsing/copying process. We now
@@ -1198,7 +1345,7 @@ static int kickoff_vpu_sequence(struct vpu_ipc_dev *vpu_dev,
 	}
 
 	/* Request boot */
-	rc = boot_fn(vpu_dev);
+	rc = request_vpu_boot(vpu_dev);
 	if (rc < 0) {
 		dev_err(dev, "Failed to do request to boot.\n");
 		goto close_and_kickoff_failed;
@@ -1237,10 +1384,10 @@ static int kickoff_vpu_sequence(struct vpu_ipc_dev *vpu_dev,
 static int do_boot_sequence(struct vpu_ipc_dev *vpu_dev,
 			    const char *firmware_name)
 {
-	int rc;
-	int event_rc;
-	const struct firmware *fw;
 	struct device *dev = &vpu_dev->pdev->dev;
+	const struct firmware *fw;
+	int event_rc;
+	int rc;
 
 	rc = vpu_ipc_handle_event(vpu_dev, KEEMBAY_VPU_EVENT_BOOT);
 	if (rc < 0) {
@@ -1292,7 +1439,7 @@ static int do_boot_sequence(struct vpu_ipc_dev *vpu_dev,
 	}
 
 	/* Try 'boot' sequence */
-	rc = kickoff_vpu_sequence(vpu_dev, request_vpu_boot);
+	rc = kickoff_vpu_sequence(vpu_dev);
 	if (rc < 0) {
 		dev_err(dev, "Failed to boot VPU.\n");
 		goto boot_failed;
@@ -1314,7 +1461,6 @@ static int do_boot_sequence(struct vpu_ipc_dev *vpu_dev,
 	/* Prefer original 'rc' to the 'event_rc'. */
 
 	return rc;
-
 }
 
 int intel_keembay_vpu_ipc_open_channel(struct device *dev, u8 node_id,
@@ -1681,7 +1827,8 @@ static ssize_t sku_store(struct device *dev,
 	struct device_attribute *attr,
 	const char *buf, size_t n)
 {
-	return store_attr_u8_array(buf, n, vpu_ipc_soc_info->sku, sizeof(vpu_ipc_soc_info->sku));
+	return store_attr_u8_array(buf, n, vpu_ipc_soc_info->sku,
+				   sizeof(vpu_ipc_soc_info->sku));
 }
 static DEVICE_ATTR_RW(sku);
 
@@ -1734,9 +1881,10 @@ static const struct attribute *vpu_ipc_attrs[] = {
 
 static int keembay_vpu_ipc_probe(struct platform_device *pdev)
 {
-	int rc;
-	struct vpu_ipc_dev *vpu_dev;
+	struct tee_ioctl_open_session_arg sess_arg;
 	struct device *dev = &pdev->dev;
+	struct vpu_ipc_dev *vpu_dev;
+	int rc;
 
 	dev_info(dev, "Keem Bay VPU IPC probing.\n");
 
@@ -1796,6 +1944,47 @@ static int keembay_vpu_ipc_probe(struct platform_device *pdev)
 		goto probe_fail_post_resmem_setup;
 	}
 
+	/* Open context with TEE driver */
+	vpu_dev->tee_ctx = tee_client_open_context(NULL, vpu_auth_ta_match,
+						   NULL, NULL);
+
+	if (IS_ERR(vpu_dev->tee_ctx)) {
+		if (PTR_ERR(vpu_dev->tee_ctx) == -ENOENT) {
+			rc = -EPROBE_DEFER;
+			goto probe_fail_post_resmem_setup;
+		}
+		dev_err(dev, "%s: tee_client_open_context failed\n", __func__);
+		rc = PTR_ERR(vpu_dev->tee_ctx);
+		goto probe_fail_post_resmem_setup;
+	}
+
+	/* Open a session with VPU auth TA */
+	memset(&sess_arg, 0, sizeof(sess_arg));
+	memcpy(sess_arg.uuid, vpu_auth_ta_uuid.b, TEE_IOCTL_UUID_LEN);
+	sess_arg.clnt_login = TEE_IOCTL_LOGIN_PUBLIC;
+	sess_arg.num_params = 0;
+
+	rc = tee_client_open_session(vpu_dev->tee_ctx, &sess_arg, NULL);
+	if ((rc < 0) || (sess_arg.ret != 0)) {
+		dev_err(dev, "%s: tee_client_open_session failed, err=%x\n",
+			__func__, sess_arg.ret);
+		if (!rc)
+			rc = -EINVAL;
+		goto probe_fail_post_tee_ctx_setup;
+	}
+	vpu_dev->tee_session = sess_arg.session;
+
+	/* Allocate dynamic shared memory for VPU boot params */
+	vpu_dev->shm = tee_shm_alloc(vpu_dev->tee_ctx,
+				     sizeof(struct vpu_boot_ta_shmem),
+				     (TEE_SHM_MAPPED | TEE_SHM_DMA_BUF));
+
+	if (IS_ERR(vpu_dev->shm)) {
+		dev_err(dev, "%s: tee_shm_alloc failed\n", __func__);
+		rc = -ENOMEM;
+		goto probe_fail_post_tee_session_setup;
+	}
+
 	/* Set platform data reference. */
 	platform_set_drvdata(pdev, vpu_dev);
 
@@ -1803,6 +1992,12 @@ static int keembay_vpu_ipc_probe(struct platform_device *pdev)
 
 	return 0;
 
+probe_fail_post_tee_session_setup:
+	tee_client_close_session(vpu_dev->tee_ctx, vpu_dev->tee_session);
+
+probe_fail_post_tee_ctx_setup:
+	tee_client_close_context(vpu_dev->tee_ctx);
+
 probe_fail_post_resmem_setup:
 	of_reserved_mem_device_release(dev);
 
@@ -1821,6 +2016,12 @@ static int keembay_vpu_ipc_remove(struct platform_device *pdev)
 
 	of_reserved_mem_device_release(dev);
 
+	tee_shm_free(vpu_dev->shm);
+
+	tee_client_close_session(vpu_dev->tee_ctx, vpu_dev->tee_session);
+
+	tee_client_close_context(vpu_dev->tee_ctx);
+
 	ipc_device_put(vpu_dev);
 
 	dev_info(dev, "Keem Bay VPU IPC driver removed.\n");
@@ -1964,4 +2165,5 @@ module_exit(vpu_ipc_exit);
 MODULE_DESCRIPTION("Keem Bay VPU IPC Driver");
 MODULE_AUTHOR("Paul Murphy <paul.j.murphy@intel.com>");
 MODULE_AUTHOR("Daniele Alessandrelli <daniele.alessandrelli@intel.com>");
+MODULE_AUTHOR("Darren Roche <darren.b.roche@intel.com>");
 MODULE_LICENSE("Dual BSD/GPL");
-- 
2.27.0

